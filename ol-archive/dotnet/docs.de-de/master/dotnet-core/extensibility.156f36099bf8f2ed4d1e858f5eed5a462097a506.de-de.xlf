<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-188fee3" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c13349c34af944d5a55d57161246f865274cc888</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\preview3\tools\extensibility.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b8ebb51b4778d8dc724f08466eef9aa57e342064</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dc46bf3603484dee61be4a98ebc403b8b9057325</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">.NET Core-CLI-Erweiterbarkeitsmodell</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">.NET Core-CLI-Erweiterbarkeitsmodell</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>CLI, extensibility, custom commands, .NET Core</source>
          <target state="translated">CLI, Erweiterbarkeit, benutzerdefinierte Befehle, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">.NET Core-CLI-Erweiterbarkeitsmodell</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Übersicht</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This document will cover the main ways how to extend the CLI tools and explain the scenarios that drive each of them.</source>
          <target state="translated">In diesem Dokument werden die Hauptverfahren beschrieben, mit denen die CLI-Tools erweitert werden, und die Szenarios erläutert, die jedes dieser Tools antreiben.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It will the outline how to consume the tools as well as provide short notes on how to build both types of tools.</source>
          <target state="translated">Es wird dargestellt, wie die Tools genutzt werden sollen und wie beide Arten der Tools erstellt werden.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How to extend CLI tools</source>
          <target state="translated">So können Sie CLI-Tools erweitern</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Preview 3 CLI tools can be extended in three main ways:</source>
          <target state="translated">Die Preview 3 CLI-Tools können auf drei Arten erweitert werden:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Via NuGet packages on a per-project basis</source>
          <target state="translated">Projektweise über NuGet-Pakete</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Via NuGet packages with custom targets</source>
          <target state="translated">Über NuGet-Pakete mit benutzerdefinierten Zielen</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Via the system's PATH</source>
          <target state="translated">Über die Systemvariable PATH</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The three extensibility mechanisms outlined above are not exclusive; you can use all or just one or combine them.</source>
          <target state="translated">Die drei oben beschriebenen Erweiterbarkeitsmechanismen schließen sich nicht gegenseitig aus. Sie können alle oder nur einen verwenden oder sie kombinieren.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Which one to pick depends largely on what is the goal you are trying to achieve with your extension.</source>
          <target state="translated">Welchen Sie auswählen, hängt größtenteils davon ab, welches Ziel Sie mit der Erweiterung erreichen möchten.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Per-project based extensibility</source>
          <target state="translated">Projektbezogene Erweiterbarkeit</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Per-project tools are <bpt id="p1">[</bpt>framework-dependented deployments<ept id="p1">](../deploying/index.md)</ept> that are distributed as NuGet packages.</source>
          <target state="translated">Projektbezogene Tools sind <bpt id="p1">[</bpt>frameworkabhängige Bereitstellungen<ept id="p1">](../deploying/index.md)</ept>, die als NuGet-Pakete verteilt werden.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Tools are only available in the context of the project that references them and for which they are restored; invocation outside of the context of the project (for example, outside of the directory that contains the project) will fail as the command will not be able to be found.</source>
          <target state="translated">Tools sind nur im Kontext des Projekts, das auf sie verweist, und für das sie wiederhergestellt werden, verfügbar. Ein Aufruf außerhalb des Projektkontexts (beispielsweise außerhalb des Verzeichnisses, das das Projekt enthält) schlägt fehl, da der Befehl nicht gefunden werden kann.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>These tools are perfect for build servers, since nothing outside of the project file is needed.</source>
          <target state="translated">Diese Tools sind ideal für Buildserver, da nichts außer der Projektdatei erforderlich ist.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The build process runs restore for the project it builds and tools will be available.</source>
          <target state="translated">Der Buildprozess führt die Wiederherstellung für das Projekt, das es erstellt, aus, und die Tools stehen zur Verfügung.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Language projects, such as F#, are also in this category; after all, each project can only be written in one specific language.</source>
          <target state="translated">Sprachprojekte, wie F#, befinden sich auch in dieser Kategorie. Immerhin kann jedes Projekt nur in einer bestimmten Sprache geschrieben werden.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Finally, this extensibility model provides support for creation of tools that need access to the built output of the project.</source>
          <target state="translated">Schließlich bietet dieses Erweiterbarkeitsmodell Unterstützung für die Erstellung von Tools, die Zugriff auf die Buildausgabe des Projekts benötigen.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For instance, various Razor view tools in <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC applications fall into this category.</source>
          <target state="translated">Verschiedene Razor-Ansicht-Tools in <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept>-MVC-Anwendungen fallen z.B. in diese Kategorie.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consuming per-project tools</source>
          <target state="translated">Tools pro Projekt verwenden</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Consuming these tools requires you to add a <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element for each tool you want to use to your project file.</source>
          <target state="translated">Zum Nutzen dieser Tools müssen Sie das Element <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> für jedes Tool hinzufügen, das Sie der Projektdatei verwenden möchten.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Inside the <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element, you reference the package in which the tool resides and you specify the version you need.</source>
          <target state="translated">Im Element <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> verweisen Sie auf das Paket, in dem sich das Tool befindet, und geben die Version an, die Sie benötigen.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>After running <ph id="ph1">`dotnet restore`</ph>, the tool and its dependencies are restored.</source>
          <target state="translated">Nach der Ausführung von <ph id="ph1">`dotnet restore`</ph> werden das Tool und die zugehörigen Abhängigkeiten wiederhergestellt.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For tools that need to load the build output of the project for execution, there is usually another dependency which is listed under the regular dependencies in the project file.</source>
          <target state="translated">Für Tools, die die Buildausgabe des Projekts zur Ausführung laden müssen, gibt es normalerweise eine andere Abhängigkeit, die unter den regulären Abhängigkeiten in der Projektdatei angezeigt wird.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Since the Preview 3 version of the CLI uses MSBuild as its build engine, it is recommended that these parts of the tool be written as custom MSBuild targets and tasks since that way they can take part in the overall build process.</source>
          <target state="translated">Da die Preview 3-Version der CLI als Buildmodul MSBuild verwendet, wird empfohlen, diese Teile des Tools als benutzerdefinierte MSBuild-Ziele- und -Aufgaben zu schreiben, da sie auf diese Weise am gesamten Buildprozess teilnehmen können.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Also, they can get any and all data easily that is produced via the build, for example the location of the output files, the current configuration being built etc. All of this information in Preview 3 becomes a set of MSBuild properties that can be read from any target.</source>
          <target state="translated">Außerdem können sie mühelos sämtliche Daten abrufen, die über den Build erstellt werden, z.B. den Speicherort der Ausgabedateien, die aktuell erstellte Konfiguration usw. Alle diese Informationen in der Preview 3-Version bilden eine Gruppe von MSBuild-Eigenschaften, die von jedem beliebigen Ziel gelesen werden können.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>We will see how to add a custom target using NuGet later in this document.</source>
          <target state="translated">Weiter unten in diesem Dokument erfahren Sie, wie über NuGet ein benutzerdefiniertes Ziel hinzugefügt wird.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Let's review an example of adding a simple tools-only tool to a simple project.</source>
          <target state="translated">Betrachten wir ein Beispiel, bei dem ein Tools-Only-Tool zu einem einfachen Projekt hinzugefügt wird.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Given an example command called <ph id="ph1">`dotnet-api-search`</ph> that allows you to search through the NuGet packages for the specified API, here is a console application's project file that uses that tool:</source>
          <target state="translated">Für einen Beispielbefehl namens <ph id="ph1">`dotnet-api-search`</ph>, mit dem Sie die NuGet-Pakete nach der angegebenen API durchsuchen können, sehen Sie hier die Projektdatei einer Konsolenanwendung, die dieses Tool verwendet:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element is structured in a similar way as the <ph id="ph2">`&lt;PackageReference&gt;`</ph> element.</source>
          <target state="translated">Das Element <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> weist eine ähnliche Struktur auf wie das Element <ph id="ph2">`&lt;PackageReference&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>It needs the package ID of the package containing the tool and its version at the very least.</source>
          <target state="translated">Er benötigt mindestens die Paket-ID des Pakets mit dem Tool und dessen Version.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Building tools</source>
          <target state="translated">Erstellen von Tools</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>As mentioned, tools are just portable console applications.</source>
          <target state="translated">Wie bereits erwähnt, sind Tools nur portable Konsolenanwendungen.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You would build one as you would build any console application.</source>
          <target state="translated">Sie würden eins erstellen, so wie Sie alle Konsolenanwendungen erstellen würden.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>After you build it, you would use <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> command to create a NuGet package (nupkg) that contains your code, information about its dependencies and so on.</source>
          <target state="translated">Nachdem Sie es erstellt haben, würden Sie den <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept>-Befehl ausführen, um ein NuGet-Paket (Nupkg) zu erstellen, das Ihren Code, die Informationen zu seinen Abhängigkeiten usw. enthält.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The package name can be whatever the author wants, but the application inside, the actual tool binary, has to conform to the convention of <ph id="ph1">`dotnet-&lt;command&gt;`</ph> in order for <ph id="ph2">`dotnet`</ph> to be able to invoke it.</source>
          <target state="translated">Der Verfasser kann den Paketnamen bestimmen, aber die Anwendung darin, das tatsächliche Binär-Tool, muss der <ph id="ph1">`dotnet-&lt;command&gt;`</ph>-Konvention entsprechen, damit <ph id="ph2">`dotnet`</ph> es aufrufen kann.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In Preview 3 bits, the <ph id="ph1">`dotnet pack`</ph> command will not pack the <ph id="ph2">`runtimeconfig.json`</ph> file that is needed to run the tool.</source>
          <target state="translated">In Preview 3-Bits packt der Befehl <ph id="ph1">`dotnet pack`</ph> nicht die Datei <ph id="ph2">`runtimeconfig.json`</ph>, die benötigt wird, um das Tool auszuführen.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In order to package this file, you have two options:</source>
          <target state="translated">Zum Packen dieser Datei haben Sie zwei Möglichkeiten:</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Create a <ph id="ph1">`nuspec`</ph> file and use <ph id="ph2">`dotnet nuget pack`</ph> command newly available to Preview 3 CLI to include the file</source>
          <target state="translated">Erstellen der Datei <ph id="ph1">`nuspec`</ph> und Ausführen des Befehls <ph id="ph2">`dotnet nuget pack`</ph>, der in Preview 3 CLI neu verfügbar ist, um die Datei einzufügen</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Use the new <ph id="ph1">`&lt;Content&gt;`</ph> element in an <ph id="ph2">`&lt;ItemGroup&gt;`</ph> in your project file to include the file manually</source>
          <target state="translated">Verwenden des neuen Elements <ph id="ph1">`&lt;Content&gt;`</ph> im Element <ph id="ph2">`&lt;ItemGroup&gt;`</ph> in der Projektdatei, um die Datei manuell einzufügen</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Working with nuspec files is beyond the scope of this article, however you can find a lot of good information in the <bpt id="p1">[</bpt>official NuGet docs<ept id="p1">](https://docs.nuget.org/ndocs/create-packages/creating-a-package#the-role-and-structure-of-the--nuspec-file)</ept>.</source>
          <target state="translated">Das Arbeiten mit NUSPEC-Dateien ist nicht Gegenstand dieses Artikels. Viele nützliche Informationen dazu finden Sie der <bpt id="p1">[</bpt>offiziellen NuGet-Dokumentation<ept id="p1">](https://docs.nuget.org/ndocs/create-packages/creating-a-package#the-role-and-structure-of-the--nuspec-file)</ept>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If you decide on the second approach, you can see the example <ph id="ph1">`csproj`</ph> file and how it is configured below:</source>
          <target state="translated">Wenn Sie sich für den zweiten Ansatz entscheiden, finden Sie nachstehend ein Beispiel der Datei <ph id="ph1">`csproj`</ph> und ihrer Konfiguration:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">`&lt;ItemGroup&gt;`</ph> instructs the <ph id="ph2">`dotnet pack`</ph> command to pack any <ph id="ph3">`runtimeconfig.json`</ph> files in the build output directory (designated by the <ph id="ph4">`$(OutputPath)`</ph> variable) and place it into the <ph id="ph5">`lib`</ph> folder for the built target framework.</source>
          <target state="translated">Dieses <ph id="ph1">`&lt;ItemGroup&gt;`</ph>-Element weist den Befehl <ph id="ph2">`dotnet pack`</ph> an, alle <ph id="ph3">`runtimeconfig.json`</ph>-Dateien im Ausgabeverzeichnis des Builds (das von der Variablen <ph id="ph4">`$(OutputPath)`</ph> angegeben wird) zu packen und im Ordner <ph id="ph5">`lib`</ph> des erstellten Zielframeworks zu platzieren.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The built target framework is designated similarly to the output path by using a MSBuild property.</source>
          <target state="translated">Das erstellte Zielframework wird ähnlich dem Ausgabepfad mithilfe einer MSBuild-Eigenschaft festgelegt.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>After this is set, the resulting tool nupkg file will contain all that is needed for running the tool.</source>
          <target state="translated">Nach dieser Festlegung enthält die NUPGK-Datei des resultierenden Tools alles, was für die Ausführung des Tools erforderlich ist.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Since tools are portable applications, the user consuming the tool has to have the version of the .NET Core libraries that the tool was built against in order to run the tool.</source>
          <target state="translated">Da Tools portierbare Anwendungen sind, benötigt der Benutzer des Tools die Version der .NET Core-Bibliotheken, für die das Tool entwickelt wurde, um das Tool auszuführen.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Any other dependency that the tool uses and that is not contained within the .NET Core libraries is restored and placed in the NuGet cache.</source>
          <target state="translated">Jede andere Abhängigkeit, die das Tool verwendet und nicht in den .NET Core-Bibliotheken enthalten ist, wird wiederhergestellt und im NuGet-Cache gespeichert.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The entire tool is, therefore, run using the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache.</source>
          <target state="translated">Das gesamte Tool wird daher mithilfe der Assemblys aus den .NET Core-Bibliotheken sowie Assemblys aus dem NuGet-Cache ausgeführt.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>These kind of tools have a dependency graph that is completely separate from the dependency graph of the project that uses them.</source>
          <target state="translated">Diese Art von Tools haben ein Abhängigkeitsdiagramm, das komplett unabhängig ist vom Abhängigkeitsdiagramm des Projekts, welches sie verwendet.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The restore process will first restore the project's dependencies, and will then restore each of the tools and their dependencies.</source>
          <target state="translated">Der Wiederherstellungsvorgang wird zuerst die Projektabhängigkeiten wiederherstellen und dann jedes der Tools und deren Abhängigkeiten.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You can find richer examples and different combinations of this in the <bpt id="p1">[</bpt>.NET Core CLI repo<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.</source>
          <target state="translated">Umfangreichere Beispiele und verschiedene Kombinationen dessen finden Sie im <bpt id="p1">[</bpt>.NET Core-CLI-Repository<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You can also see the <bpt id="p1">[</bpt>implementation of tools used<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> in the same repo.</source>
          <target state="translated">Sie finden auch die <bpt id="p1">[</bpt>Implementierung von verwendeten Tools<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> im gleichen Repository.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Custom targets</source>
          <target state="translated">Benutzerdefinierte Ziele</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>NuGet has had the capability to package custom MSBuild target and props files for a while now and you can find the official documentation on this on the <bpt id="p1">[</bpt>NuGet documentation site<ept id="p1">](https://docs.nuget.org/ndocs/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>.</source>
          <target state="translated">NuGet bietet seit geraumer Zeit die Möglichkeit, benutzerdefinierte MSBuild-Ziel- und Eigenschaftendateien zu packen. Sie finden die offizielle Dokumentation dazu auf der <bpt id="p1">[</bpt>Website der NuGet-Dokumentation<ept id="p1">](https://docs.nuget.org/ndocs/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>With the move in the CLI to using MSBuild, the same mechanism of extensibility applies to .NET Core projects.</source>
          <target state="translated">Mit dem Schritt in der CLI zum Verwenden von MSBuild gilt derselbe Mechanismus für Erweiterbarkeit für .NET Core-Projekte.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You would use this type of extensiblity when you want to extend the build process or when you want to access any of the artifacts in the build process, such as generated files or inspect the configuration under which the build is invoked etc.</source>
          <target state="translated">Sie nutzen diese Art von Erweiterbarkeit, wenn Sie den Buildprozess erweitern möchten, im Buildprozess auf Artefakte wie generierte Dateien zugreifen oder die Konfiguration überprüfen möchten, in der der Build aufgerufen wird usw.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The sample target's project file is included below for reference.</source>
          <target state="translated">Zur Referenz ist die Projektdatei des Beispielziels unten aufgeführt.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>It shows how to use the new <ph id="ph1">`csproj`</ph> syntax for instructing <ph id="ph2">`dotnet pack`</ph> command what to package to place the targets files as well as assemblies into the <ph id="ph3">`build`</ph> folder inside the package.</source>
          <target state="translated">Sie sehen, wie die neue <ph id="ph1">`csproj`</ph>-Syntax genutzt wird, um den Befehl <ph id="ph2">`dotnet pack`</ph> anzuweisen, was gepackt werden soll, damit die Zieldateien und Assemblys im Ordner <ph id="ph3">`build`</ph> im Paket platziert werden.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Take note of the <ph id="ph1">`&lt;ItemGroup&gt;`</ph> below that has the <ph id="ph2">`Label`</ph> property set to "dotnet pack instructions".</source>
          <target state="translated">Beachten Sie das Element <ph id="ph1">`&lt;ItemGroup&gt;`</ph> darunter, dessen <ph id="ph2">`Label`</ph>-Eigenschaft auf „dotnet pack instructions“ festgelegt ist.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Consuming custom targets is done by providing a <ph id="ph1">`&lt;PackageReference&gt;`</ph> that points to the package and its version inside the project that is being extended.</source>
          <target state="translated">Die Nutzung benutzerdefinierter Ziele erfolgt durch Bereitstellung einer <ph id="ph1">`&lt;PackageReference&gt;`</ph>, die auf ein Paket und dessen Version innerhalb des Projekts verweist, das erweitert wird.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Unlike the tools, the custom targets package does get included into the consuming project's dependency closure.</source>
          <target state="translated">Im Gegensatz zu den Tools wird das benutzerdefinierte Zielpaket in die Hülle der Abhängigkeiten des nutzenden Projekts eingeschlossen.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Using the custom target depends solely on how you configure it.</source>
          <target state="translated">Die Verwendung des benutzerdefinierten Ziels hängt ausschließlich von seiner Konfiguration ab.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Since it is the usual MSBuild target, it can depend on a given target, run after another target and can also be manually invoked using the <ph id="ph1">`dotnet msbuild /t:&lt;target-name&gt;`</ph> command.</source>
          <target state="translated">Da es das übliche MSBuild-Ziel ist, kann es von einem angegebenen Ziel abhängen, nach einem anderen Ziel ausgeführt werden und mit dem Befehl <ph id="ph1">`dotnet msbuild /t:&lt;target-name&gt;`</ph> auch manuell aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>However, if you wish to provide a better user experience to your users, you can combine per-project tools and custom targets.</source>
          <target state="translated">Wenn Sie jedoch Ihren Benutzern eine bessere Erfahrung bieten möchten, können Sie projektbezogene Tools und benutzerdefinierte Ziele kombinieren.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In this scenario, the per-project tool would essentially just accept whatever needed parameters and would translate that into the required <ph id="ph1">`dotnet msbuild`</ph> invocation that would execute the target.</source>
          <target state="translated">In diesem Szenario akzeptiert das projektbezogene Tool lediglich die benötigten Parameter, die in den erforderlichen Aufruf von <ph id="ph1">`dotnet msbuild`</ph> übersetzt werden, über den das Ziel ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You can see a sample of this kind of sinergy on the <bpt id="p1">[</bpt>MVP Summit 2016 Hackathon samples<ept id="p1">](https://github.com/dotnet/MVPSummitHackathon2016)</ept> repo in the <bpt id="p2">[</bpt><ph id="ph1">`dotnet-packer`</ph><ept id="p2">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept> project.</source>
          <target state="translated">Sie sehen ein Beispiel dieser Art von Synergie im Repository mit den <bpt id="p1">[</bpt>MVP Summit 2016 Hackathon-Beispielen<ept id="p1">](https://github.com/dotnet/MVPSummitHackathon2016)</ept> im Projekt <bpt id="p2">[</bpt><ph id="ph1">`dotnet-packer`</ph><ept id="p2">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility</source>
          <target state="translated">PFAD-basierte Erweiterbarkeit</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more than a single project.</source>
          <target state="translated">Die PFAD-basierte Erweiterbarkeit wird in der Regel für Entwicklungscomputer verwendet, bei denen Sie ein Tool brauchen, das konzeptionell mehr als ein einzelnes Projekt abdeckt.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The main drawback of this extensions mechanism is that it is tied to the machine where the tool exists.</source>
          <target state="translated">Der größte Nachteil dieses Extensionsmechanismus ist, dass es mit dem Computer verknüpft ist, auf dem das Tool existiert.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If you need it on another machine, you would have to deploy it.</source>
          <target state="translated">Wenn Sie ihn auf einem anderen Computer benötigen, müssten Sie ihn bereitstellen.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>This pattern of CLI toolset extensibility is very simple.</source>
          <target state="translated">Dieses Muster der Erweiterbarkeit des CLI-Toolsets ist sehr einfach.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>As covered in the <bpt id="p1">[</bpt>.NET Core CLI overview<ept id="p1">](index.md)</ept>, <ph id="ph1">`dotnet`</ph> driver can run any command that is named after the <ph id="ph2">`dotnet-&lt;command&gt;`</ph> convention.</source>
          <target state="translated">Wie in der <bpt id="p1">[</bpt>Übersicht über die .NET Core-CLI<ept id="p1">](index.md)</ept> beschrieben, kann der <ph id="ph1">`dotnet`</ph>-Treiber jeden Befehl ausführen, der nach der <ph id="ph2">`dotnet-&lt;command&gt;`</ph>-Konvention benannt ist.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The default resolution logic will first probe several locations and will finally fall to the system PATH.</source>
          <target state="translated">Die Standardaufkösungslogik wird zuerst mehrere Speicherorte überprüfen und schließlich an den SYSTEMPFAD fallen.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If the requested command exists in the system PATH and is a binary that can be invoked, <ph id="ph1">`dotnet`</ph> driver will invoke it.</source>
          <target state="translated">Wenn der angeforderte Befehl im SYSTEMPFAD vorhanden und eine Binärdatei ist, die aufgerufen werden kann, wird sie der <ph id="ph1">`dotnet`</ph>-Treiber aufrufen.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The binary can be pretty much anything that the operating system can execute.</source>
          <target state="translated">Die Binärdatei kann nahezu alles sein, das vom Betriebssystem ausgeführt werden kann.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>On Unix systems, this means anything that has the execute bit set via <ph id="ph1">`chmod +x`</ph>.</source>
          <target state="translated">Auf Unix-Systemen bedeutet dies alles, das das ausführbare Bit über <ph id="ph1">`chmod +x`</ph> festgelegt hat.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>On Windows it means anything that Windows knows how to run.</source>
          <target state="translated">Auf Windows bedeutet dies alles, das Windows ausführen kann.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>As an example, let's take a look at a very simple implementation of a <ph id="ph1">`dotnet clean`</ph> command.</source>
          <target state="translated">Als Beispiel sehen wir uns eine sehr einfache Implementierung eines <ph id="ph1">`dotnet clean`</ph>-Befehls an.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>We will use <ph id="ph1">`bash`</ph> to implement this command.</source>
          <target state="translated">Wir verwenden <ph id="ph1">`bash`</ph>, um den Befehl zu implementieren.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The command will simply delete the <ph id="ph1">`bin/`</ph> and <ph id="ph2">`obj/`</ph> directories in the current directory.</source>
          <target state="translated">Der Befehl löscht einfach die <ph id="ph1">`bin/`</ph>- und <ph id="ph2">`obj/`</ph>-Verzeichnisse im aktuellen Verzeichnis.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`--lock`</ph> argument is passed to it, it will also delete <ph id="ph2">`project.lock.json`</ph> file.</source>
          <target state="translated">Wenn das <ph id="ph1">`--lock`</ph>-Argument übergeben wird, wird es auch die <ph id="ph2">`project.lock.json`</ph>-Datei löschen.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The entirety of the command is given below.</source>
          <target state="translated">Der gesamte Befehl wird unten angezeigt.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>On macOS, we can save this script as <ph id="ph1">`dotnet-clean`</ph> and set its executable bit with <ph id="ph2">`chmod +x dotnet-clean`</ph>.</source>
          <target state="translated">Auf Mac OS können wir dieses Skript als <ph id="ph1">`dotnet-clean`</ph> speichern und sein ausführbares Bit mit <ph id="ph2">`chmod +x dotnet-clean`</ph> festlegen.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>We can then create a symbolic link to it in <ph id="ph1">`/usr/local/bin`</ph> using the command <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph>.</source>
          <target state="translated">Wir erstellen dann eine symbolische Verknüpfung in <ph id="ph1">`/usr/local/bin`</ph> mit dem Befehl <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This will make it possible to invoke the clean command using the <ph id="ph1">`dotnet clean`</ph> syntax.</source>
          <target state="translated">So kann der Befehl „Bereinigen“ mit der <ph id="ph1">`dotnet clean`</ph>-Syntax aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>You can test this by creating an app, running <ph id="ph1">`dotnet build`</ph> on it and then running <ph id="ph2">`dotnet clean`</ph>.</source>
          <target state="translated">Sie können dies testen, indem Sie eine App erstellen, <ph id="ph1">`dotnet build`</ph> und anschließend <ph id="ph2">`dotnet clean`</ph> darauf ausführen.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Schlussfolgerung</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The .NET Core CLI tools allow three main extensibility points.</source>
          <target state="translated">Die .NET Core CLI-Tools lassen drei wichtige Erweiterungsmöglichkeiten zu.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The per-project tools are contained within the project's context, but they allow easy installation through restoration.</source>
          <target state="translated">Die pprojektbezogenen Tools sind im Kontext des Projekts enthalten, aber sie ermöglichen eine einfache Installation über die Wiederherstellung.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Custom targets allow you to easily extend the build process with custom tasks.</source>
          <target state="translated">Mithilfe benutzerdefinierter Ziele können Sie den Buildprozess einfach mit benutzerdefinierten Aufgaben erweitern.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>PATH-based tools are good for general, cross-project tools that are usable on a single machine.</source>
          <target state="translated">Auf PATH basierende Tools eignen sich für allgemeine projektübergreifende Tools, die auf einem einzelnen Computer verwendet werden.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>