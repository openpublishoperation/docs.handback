<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5509f09b3f7957049194ea7af9952bb6b5ec7539</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\deploying\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">416c430ca40031e61bb4d28a92a500ba0a77d0f4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6ed2a68a1ecf9e339364a72f741269724244e706</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core Application Deployment</source>
          <target state="translated">Implementación de aplicaciones .NET Core</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core Application Deployment</source>
          <target state="translated">Implementación de aplicaciones .NET Core</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, .NET Core deployment</source>
          <target state="translated">.NET, .NET Core, implementación de .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core Application Deployment</source>
          <target state="translated">Implementación de aplicaciones .NET Core</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can create two types of deployments for .NET Core applications:</source>
          <target state="translated">Puede crear dos tipos de implementaciones para aplicaciones .NET Core:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Framework-dependent deployment.</source>
          <target state="translated">Implementación dependiente de Framework.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>As the name implies, framework-dependent deployment (FDD) relies on a shared system-wide version of .NET Core to be present on the target system.</source>
          <target state="translated">Como su nombre indica, la implementación dependiente de Framework (FDD) se basa en la presencia de una versión compartida de .NET Core en todo el sistema en el sistema de destino.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Because .NET Core is already present, your app is also portable between installations of .NET Core.</source>
          <target state="translated">Como .NET Core ya está presente, la aplicación también es portátil entre instalaciones de .NET Core.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Your app contains only its own code and any third-party dependencies that are outside of the .NET Core libraries.</source>
          <target state="translated">La aplicación solo contiene su propio código y dependencias de terceros que están fuera de las bibliotecas .NET Core.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>FDDs contain .dll files that can be launched by using the <bpt id="p1">[</bpt>dotnet utility<ept id="p1">](../tools/dotnet.md)</ept> from the command line.</source>
          <target state="translated">FDD contiene archivos .dll que se pueden iniciar utilizando la <bpt id="p1">[</bpt>utilidad dotnet<ept id="p1">](../tools/dotnet.md)</ept> desde la línea de comandos.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`dotnet app.dll`</ph> runs an application named <ph id="ph2">`app`</ph>.</source>
          <target state="translated">Por ejemplo, <ph id="ph1">`dotnet app.dll`</ph> ejecuta una aplicación denominada <ph id="ph2">`app`</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Self-contained deployment.</source>
          <target state="translated">Implementación autocontenida.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Unlike FDD, a self-contained deployment (SCD) does not rely on any shared components to be present on the target system.</source>
          <target state="translated">A diferencia de FDD, una implementación autocontenida (SCD) no depende de que los componentes compartidos estén presentes en el sistema de destino.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>All components, including both .NET Core libraries and the .NET Core runtime, are included with the application and are isolated from other .NET Core applications.</source>
          <target state="translated">Todos los componentes, incluidas las bibliotecas y el entorno de ejecución de .NET Core, se incluyen con la aplicación y están aislados de otras aplicaciones .NET Core.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>SCDs include an executable (such as <ph id="ph1">`app.exe`</ph> on Windows platforms for an application named <ph id="ph2">`app`</ph>), which is  a renamed version of the platform-specific .NET Core host, and a .dll file (such as <ph id="ph3">`app.dll`</ph>), which is the actual application.</source>
          <target state="translated">Las SCD incluyen un archivo ejecutable (como <ph id="ph1">`app.exe`</ph> en plataformas de Windows para una aplicación denominada <ph id="ph2">`app`</ph>), que es una versión con otro nombre del host de .NET Core específico de la plataforma y un archivo .dll (como <ph id="ph3">`app.dll`</ph>), que es la aplicación real.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Framework-dependent deployments (FDD)</source>
          <target state="translated">Implementaciones dependientes de Framework (FDD)</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For an FDD, you deploy only your app and any third-party dependencies.</source>
          <target state="translated">En una FDD, solo se implementa su aplicación y cualquier dependencia de terceros.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You do not have to deploy .NET Core, since your app will use the version of .NET Core that's present on the target system.</source>
          <target state="translated">No tiene que implementar .NET Core, puesto que la aplicación usará la versión de .NET Core que esté presente en el sistema de destino.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This is the default deployment model for .NET Core apps.</source>
          <target state="translated">Este es el modelo de implementación predeterminado para aplicaciones .NET Core.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Why create a framework-dependent deployment?</source>
          <target state="translated">¿Por qué crear una implementación dependiente del marco?</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Deploying an FDD has a number of advantages:</source>
          <target state="translated">La implementación de FDD tienen varias ventajas:</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You do not have to define the target operating systems that your .NET Core app will run on in advance.</source>
          <target state="translated">No es necesario definir por adelantado los sistemas operativos de destino en los que se ejecutará la aplicación .NET Core.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Because .NET Core uses a common PE file format for executables and libraries regardless of operating system, .NET Core can execute your app regardless of the underlying operating system.</source>
          <target state="translated">Como .NET Core usa un formato de archivo PE común para archivos ejecutables y bibliotecas independientemente del sistema operativo, .NET Core puede ejecutar la aplicación con independencia del sistema operativo subyacente.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information on the PE file format, see <bpt id="p1">[</bpt>.NET Assembly File Format<ept id="p1">](../../standard/assembly-format.md)</ept>.</source>
          <target state="translated">Para más información sobre el formato de archivo PE, consulte <bpt id="p1">[</bpt>.NET Assembly File Format<ept id="p1">](../../standard/assembly-format.md)</ept> (Formato de archivo de ensamblado .NET).</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The size of your deployment package is small.</source>
          <target state="translated">El tamaño de su paquete de implementación es pequeño.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You only have to deploy your app and its dependencies, not .NET Core itself.</source>
          <target state="translated">Solo tendrá que implementar la aplicación y sus dependencias, .NET Core propiamente dicho.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Multiple apps use the same .NET Core installation, which reduces both disk space and memory usage on host systems.</source>
          <target state="translated">Varias aplicaciones usan la misma instalación de .NET Core, lo que reduce tanto el espacio en disco y el uso de memoria en sistemas host.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>There are also a few disadvantages:</source>
          <target state="translated">Hay también algunas desventajas:</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Your app can run only if the version of .NET Core that you target, or a later version, is already installed on the host system.</source>
          <target state="translated">Su aplicación solo se puede ejecutar si la versión de .NET Core de destino, o una versión posterior, ya está instalada en el sistema host.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>It is possible for the .NET Core runtime and libraries to change without your knowledge in future releases.</source>
          <target state="translated">Es posible que el entorno de tiempo de ejecución y las bibliotecas .NET Core cambien en futuras versiones sin su conocimiento.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In rare cases, this may change the behavior of your app.</source>
          <target state="translated">En raras ocasiones, esto puede cambiar el comportamiento de la aplicación.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Deploying a framework-dependent deployment</source>
          <target state="translated">Implementación de una implementación dependiente del marco</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Deploying a framework-dependent deployment with no third-party dependencies simply involves building, testing, and publishing the app.</source>
          <target state="translated">La implementación de una implementación dependiente del marco sin dependencias de terceros implica simplemente la compilación, la prueba y la publicación de la aplicación.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A simple example written in C# illustrates the process.</source>
          <target state="translated">Un sencillo ejemplo escrito en C# ilustra el proceso.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The example uses the <bpt id="p1">[</bpt>dotnet utility<ept id="p1">](../tools/dotnet.md)</ept> from the command line; however, you can also use a development environment, such as Visual Studio or Visual Studio Code, to compile, test, and publish the example.</source>
          <target state="translated">En el ejemplo se usa la <bpt id="p1">[</bpt>utilidad dotnet<ept id="p1">](../tools/dotnet.md)</ept> desde la línea de comandos; sin embargo, también puede usar un entorno de desarrollo, como Visual Studio o Visual Studio Code para compilar, probar y publicar el ejemplo.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Create a directory for your project, and from the command line, type <bpt id="p1">[</bpt>dotnet new<ept id="p1">](../tools/dotnet-new.md)</ept> to create a new C# console project.</source>
          <target state="translated">Cree un directorio para el proyecto y, en la línea de comandos, escriba <bpt id="p1">[</bpt>dotnet new<ept id="p1">](../tools/dotnet-new.md)</ept> para crear un nuevo proyecto de consola de C#.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Open the <ph id="ph1">`Program.cs`</ph> file in an editor, and replace the auto-generated code with the following code.</source>
          <target state="translated">Abra el archivo <ph id="ph1">`Program.cs`</ph> en un editor y reemplace el código generado automáticamente por el código siguiente.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>It prompts the user to enter text, and then displays the individual words entered by the user.</source>
          <target state="translated">Se pide al usuario que escriba texto y, a continuación, se muestran las palabras individuales escritas por el usuario.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>It uses the regular expression <ph id="ph1">`\w+`</ph> to separate the words in the input text.</source>
          <target state="translated">Se usa la expresión regular <ph id="ph1">`\w+`</ph> para separar las palabras en el texto de entrada.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Run the <bpt id="p1">[</bpt>dotnet restore<ept id="p1">](../tools/dotnet-restore.md)</ept> command to restore the dependencies specified in your project.</source>
          <target state="translated">Ejecute el comando <bpt id="p1">[</bpt>dotnet restore<ept id="p1">](../tools/dotnet-restore.md)</ept> para restaurar las dependencias especificadas en el proyecto.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Create a debug build of your app by using the <bpt id="p1">[</bpt>dotnet build<ept id="p1">](../tools/dotnet-build.md)</ept> command.</source>
          <target state="translated">Cree una compilación de depuración de su aplicación mediante el comando <bpt id="p1">[</bpt>dotnet build<ept id="p1">](../tools/dotnet-build.md)</ept>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>After you've debugged and tested the program, you can create the files to be deployed with your app by using the <ph id="ph1">`dotnet publish -f netcoreapp1.0 -c release`</ph> command.</source>
          <target state="translated">Después de depurar y probar el programa, puede crear los archivos que se implementarán con la aplicación mediante el comando <ph id="ph1">`dotnet publish -f netcoreapp1.0 -c release`</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This creates a release (rather than a debug) version of your app.</source>
          <target state="translated">Con esto se crea una versión (en lugar de una depuración) de la aplicación.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The resulting files are placed in a directory named <ph id="ph1">`publish`</ph> that is in a subdirectory of your project's <ph id="ph2">`.\bin\release\netcoreapp1.0`</ph> subdirectory.</source>
          <target state="translated">Los archivos resultantes se colocan en un directorio llamado <ph id="ph1">`publish`</ph> que se encuentra en un subdirectorio del subdirectorio <ph id="ph2">`.\bin\release\netcoreapp1.0`</ph> del proyecto.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app.</source>
          <target state="translated">Junto con los archivos de la aplicación, el proceso de publicación emite un archivo de base de datos de programa (.pdb) que contiene información de depuración sobre la aplicación.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.</source>
          <target state="translated">El archivo es útil principalmente para depurar excepciones; puede elegir no empaquetarlo con los archivos de la aplicación.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The complete set of application  files can be deployed in any way you'd like.</source>
          <target state="translated">El conjunto completo de archivos de la aplicación se puede implementar del modo que quiera.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For example, you can package them in a zip file, use a simple <ph id="ph1">`copy`</ph> command, or deploy them with any installation package of your choice.</source>
          <target state="translated">Por ejemplo, puede empaquetarlos en un archivo comprimido, usar un simple comando <ph id="ph1">`copy`</ph> o implementarlos con el paquete de instalación que prefiera.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>In addition to the application binaries, the installer should also either bundle the shared framework installer or check for it as a prerequisite as part of the application installation.</source>
          <target state="translated">Además de los archivos binarios de la aplicación, el instalador debe también empaquetar el programa de instalación de un marco compartido o buscarlo como requisito previo como parte de la instalación de la aplicación.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Installation of the shared framework requires Administrator/root access since it is machine-wide.</source>
          <target state="translated">La instalación del marco compartido requiere acceso raíz o de administrador dado que implica a toda la máquina.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Deploying a framework-dependent deployment with third-party dependencies</source>
          <target state="translated">Implementación de una implementación dependiente del marco con dependencias de terceros</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Deploying a framework-dependent deployment with one or more third-party dependencies involves three additional steps before you can run the <ph id="ph1">`dotnet restore`</ph> command:</source>
          <target state="translated">La implementación de una implementación dependiente del marco con una o varias dependencias de terceros implica tres pasos adicionales antes de ejecutar el comando <ph id="ph1">`dotnet restore`</ph>:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Add references to any third-party libraries to the <ph id="ph1">`dependencies`</ph> section of your <ph id="ph2">`project.json`</ph> file.</source>
          <target state="translated">Agregue referencias a las bibliotecas de terceros a la sección <ph id="ph1">`dependencies`</ph> de su archivo <ph id="ph2">`project.json`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The following  <ph id="ph1">`dependencies`</ph> section uses Json.NET as a third-party library.</source>
          <target state="translated">La siguiente sección <ph id="ph1">`dependencies`</ph> usa Json.NET como biblioteca de terceros.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you haven't already, download the NuGet package containing the third-party dependency.</source>
          <target state="translated">Si no lo ha hecho ya, descargue el paquete de NuGet que contiene la dependencia de terceros.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>To download the package, execute the <ph id="ph1">`dotnet restore`</ph> command after adding the dependency.</source>
          <target state="translated">Para descargar el paquete, ejecute el comando <ph id="ph1">`dotnet restore`</ph> después de agregar la dependencia.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Because the dependency is resolved out of the local NuGet cache at publish time, it must be available on your system.</source>
          <target state="translated">Como la dependencia se resuelve fuera de la caché local de NuGet en tiempo de publicación, debe estar disponible en el sistema.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Note that a framework-dependent deployment with third-party dependencies will only be as portable as its third-party dependencies.</source>
          <target state="translated">Tenga en cuenta que una implementación dependiente del marco con dependencias de terceros solo será tan portátil como sus dependencias de terceros.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For example, if a third-party library only supports macOS, the app will not be portable to Windows systems.</source>
          <target state="translated">Por ejemplo, si una biblioteca de terceros solo admite macOS, la aplicación no se podrá portar a sistemas Windows.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This can happen if the third-party dependency itself depends on native code.</source>
          <target state="translated">Esto puede ocurrir si la dependencia de terceros propiamente dicha depende del código nativo.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A good example of this is Kestrel server.</source>
          <target state="translated">Un buen ejemplo de ello es el servidor Kestrel.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>When an FDD is created for an application with this kind of third-party dependency, the published output will contain a folder for each <bpt id="p1">[</bpt>Runtime Identifier (RID)<ept id="p1">](../rid-catalog.md#what-are-rids)</ept> that the native dependency supports (and that exists in its NuGet package).</source>
          <target state="translated">Cuando se crea una FDD para una aplicación con esta clase de dependencia de terceros, el resultado publicado contendrá una carpeta para cada <bpt id="p1">[</bpt>identificador en tiempo de ejecución (RID)<ept id="p1">](../rid-catalog.md#what-are-rids)</ept> que admita la dependencia nativa (y que exista en su paquete de NuGet).</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Self-contained deployments (SCD)</source>
          <target state="translated">Implementaciones autocontenidas (SCD)</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For a self-contained deployment, you deploy not only your app and any third-party dependencies, but the version of .NET Core that you build your app with.</source>
          <target state="translated">En una implementación autocontenida, no solo implementa su aplicación y cualquier dependencia de terceros, sino también la versión de .NET Core con la que compila la aplicación.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Creating an SCD does not, however, include the <bpt id="p1">[</bpt>native dependencies of .NET Core<ept id="p1">](https://github.com/dotnet/core/blob/master/Documentation/prereqs.md)</ept> itself on various platforms (for example, OpenSSL on macOS) so these need to be installed before running the application.</source>
          <target state="translated">La creación de una SCD no incluye, sin embargo, las <bpt id="p1">[</bpt>dependencias nativas de .NET Core<ept id="p1">](https://github.com/dotnet/core/blob/master/Documentation/prereqs.md)</ept> propiamente dichas en diversas plataformas (por ejemplo, OpenSSL en macOS) así que es necesario instalarlas antes de ejecutar la aplicación.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Why deploy a Self-contained deployment?</source>
          <target state="translated">¿Por qué realizar una implementación autocontenida?</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Deploying a Self-contained deployment has two major advantages:</source>
          <target state="translated">La implementación de una implementación autocontenida tiene dos ventajas principales:</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>You have sole control of the version of .NET Core that is deployed with your app.</source>
          <target state="translated">Tiene el control exclusivo de la versión de .NET Core que se implementa con la aplicación.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>.NET Core can be serviced only by you.</source>
          <target state="translated">El mantenimiento de .NET Core solo puede realizarlo usted.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>You can be assured that the target system can run your .NET Core app, since you're providing the version of .NET Core that it will run on.</source>
          <target state="translated">Puede tener la seguridad de que el sistema de destino puede ejecutar su aplicación de .NET Core, dado que usted proporciona la versión de .NET Core en la que se ejecuta.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>It also has a number of disadvantages:</source>
          <target state="translated">También tiene algunos inconvenientes:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Because .NET Core is included in your deployment package, you must select the target platforms for which you build deployment packages in advance.</source>
          <target state="translated">Como .NET Core se incluye en el paquete de implementación, debe seleccionar por adelantado las plataformas de destino en las que se compilan los paquetes de implementación.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The size of your deployment package is relatively large, since you have to include .NET Core as well as your app and its third-party dependencies.</source>
          <target state="translated">El tamaño de su paquete de implementación es relativamente grande, ya que tendrá que incluir .NET Core, así como la aplicación y sus dependencias de terceros.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Deploying numerous self-contained .NET Core apps to a system can consume significant amounts of disk space, since each app duplicates .NET Core files.</source>
          <target state="translated">La implementación de numerosas aplicaciones .NET Core autocontenidas en un sistema puede consumir importantes cantidades de espacio en disco, puesto que cada aplicación duplica archivos de .NET Core.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="simpleSelf"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Deploying a simple self-contained deployment</source>
          <target state="translated"><bpt id="p1">&lt;a name="simpleSelf"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Implementación de una implementación autocontenida sencilla</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Deploying a self-contained deployment with no third-party dependencies involves creating the project, modifying the project.json file, building, testing, and publishing the app.</source>
          <target state="translated">La implementación de una implementación autocontenida sin dependencias de terceros implica crear el proyecto, modificar el archivo project.json y compilar, probar y publicar la aplicación.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>A simple example written in C# illustrates the process.</source>
          <target state="translated">Un sencillo ejemplo escrito en C# ilustra el proceso.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The example uses the <ph id="ph1">`dotnet`</ph> utility from the command line; however, you can also use a development environment, such as Visual Studio or Visual Studio Code, to compile, test, and publish the example.</source>
          <target state="translated">En el ejemplo se usa la utilidad <ph id="ph1">`dotnet`</ph> desde la línea de comandos; sin embargo, también puede usar un entorno de desarrollo, como Visual Studio o Visual Studio Code para compilar, probar y publicar el ejemplo.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Create a directory for your project, and from the command line, type <ph id="ph1">`dotnet new`</ph> to create a new C# console project.</source>
          <target state="translated">Cree un directorio para el proyecto y, en la línea de comandos, escriba <ph id="ph1">`dotnet new`</ph> para crear un nuevo proyecto de consola de C#.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Open the <ph id="ph1">`Program.cs`</ph> file in an editor, and replace the auto-generated code with the following code.</source>
          <target state="translated">Abra el archivo <ph id="ph1">`Program.cs`</ph> en un editor y reemplace el código generado automáticamente por el código siguiente.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>It prompts the user to enter text, and then displays the individual words entered by the user.</source>
          <target state="translated">Se pide al usuario que escriba texto y, a continuación, se muestran las palabras individuales escritas por el usuario.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>It uses the regular expression <ph id="ph1">`\w+`</ph> to separate the words in the input text.</source>
          <target state="translated">Se usa la expresión regular <ph id="ph1">`\w+`</ph> para separar las palabras en el texto de entrada.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Open the <ph id="ph1">`project.json`</ph> file and in the <ph id="ph2">`frameworks`</ph> section, remove the following line:</source>
          <target state="translated">Abra el archivo <ph id="ph1">`project.json`</ph> y quita la línea siguiente de la sección <ph id="ph2">`frameworks`</ph>:</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The Framework section should appear as follows after you've modified it:</source>
          <target state="translated">La sección Framework debe aparecer de la manera siguiente una vez modificada:</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Removing the <ph id="ph1">`"type": "platform"`</ph> attribute indicates that the framework is provided as a set of components local to our app, rather than as a system-wide platform package.</source>
          <target state="translated">Al quitar el atributo <ph id="ph1">`"type": "platform"`</ph> se indica que el marco se proporciona como un conjunto de componentes locales a nuestra aplicación, y no como un paquete de plataforma de todo el sistema.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Create a <ph id="ph1">`runtimes`</ph> section in your <ph id="ph2">`project.json`</ph> file that defines the platforms your app targets, and specify the runtime identifier of each platform that you target.</source>
          <target state="translated">Cree una sección <ph id="ph1">`runtimes`</ph> en el archivo <ph id="ph2">`project.json`</ph> que defina las plataformas a las que se dirige su aplicación, y especifique el identificador de tiempo de ejecución de cada una.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime IDentifier catalog<ept id="p1">](../rid-catalog.md)</ept> for a list of runtime identifiers.</source>
          <target state="translated">Para ver una lista de identificadores de tiempo de ejecución, consulte el <bpt id="p1">[</bpt>catálogo de identificadores de tiempo de ejecución<ept id="p1">](../rid-catalog.md)</ept>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>For example, the following <ph id="ph1">`runtimes`</ph> section indicates that the app runs on 64-bit Windows 10 operating systems and the 64-bit OS X Version 10.10 operating system.</source>
          <target state="translated">Por ejemplo, la siguiente sección <ph id="ph1">`runtimes`</ph> indica que la aplicación se ejecuta en sistemas operativos Windows 10 de 64 bits y OS X versión 10.10 de 64 bits.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Note that you also need to add a comma to separate the <ph id="ph1">`runtimes`</ph> section from the previous section.</source>
          <target state="translated">Tenga en cuenta también de que debe agregar una coma para separar la sección <ph id="ph1">`runtimes`</ph> de la sección anterior.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>A complete sample <ph id="ph1">`project.json`</ph> file appears later in this section.</source>
          <target state="translated">Más adelante en esta sección aparece un ejemplo completo del archivo <ph id="ph1">`project.json`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Run the <ph id="ph1">`dotnet restore`</ph> command to restore the dependencies specified in your project.</source>
          <target state="translated">Ejecute el comando <ph id="ph1">`dotnet restore`</ph> para restaurar las dependencias especificadas en el proyecto.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Create debug builds of your app on each of the target platforms by using the <ph id="ph1">`dotnet build`</ph> command.</source>
          <target state="translated">Cree compilaciones de depuración de la aplicación en cada plataforma de destino mediante el comando <ph id="ph1">`dotnet build`</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Unless you specify the runtime identifier you'd like to build, the <ph id="ph1">`dotnet build`</ph> command creates a build only for the current system's runtime ID.</source>
          <target state="translated">A menos que especifique el identificador de tiempo de ejecución que desea quiere compilar, el comando <ph id="ph1">`dotnet build`</ph> crea una compilación solo para el ID de tiempo de ejecución actual del sistema.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>You can build your app for both target platforms with the commands:</source>
          <target state="translated">Puede compilar la aplicación para ambas plataformas de destino con los comandos:</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The debug builds of your app for each platform will be found in the project's <ph id="ph1">`.\bin\Debug\netcoreapp1.0\&lt;runtime_identifier&gt;`</ph> subdirectory.</source>
          <target state="translated">Las compilaciones de depuración de la aplicación para cada plataforma se encontrarán en el directorio <ph id="ph1">`.\bin\Debug\netcoreapp1.0\&lt;runtime_identifier&gt;`</ph> del proyecto.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>After you've debugged and tested the program, you can create the files to be deployed with your app for each platform that it targets by using the <ph id="ph1">`dotnet publish`</ph> command for both target platforms as follows:</source>
          <target state="translated">Después de depurar y probar el programa, puede crear los archivos que se implementarán con la aplicación para cada plataforma de destino mediante la ejecución del comando <ph id="ph1">`dotnet publish`</ph> en ambas plataformas de destino, de la manera siguiente:</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This creates a release (rather than a debug) version of your app for each target platform.</source>
          <target state="translated">Se crea una versión de lanzamiento (en lugar de una depuración) de la aplicación para cada plataforma de destino.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The resulting files are placed in a subdirectory named <ph id="ph1">`publish`</ph> that is in a subdirectory of your project's <ph id="ph2">`.\bin\release\netcoreapp1.0\&lt;runtime_identifier&gt;`</ph> subdirectory.</source>
          <target state="translated">Los archivos resultantes se colocan en un subdirectorio denominado <ph id="ph1">`publish`</ph> que se encuentra en un subdirectorio del subdirectorio <ph id="ph2">`.\bin\release\netcoreapp1.0\&lt;runtime_identifier&gt;`</ph> del proyecto.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Note that each subdirectory contains the complete set of files (both your app files and all .NET Core files) needed to launch your app.</source>
          <target state="translated">Tenga en cuenta que cada subdirectorio contiene el conjunto completo de archivos (los archivos de aplicación y todos los archivos de .NET Core) necesario para iniciar la aplicación.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app.</source>
          <target state="translated">Junto con los archivos de la aplicación, el proceso de publicación emite un archivo de base de datos de programa (.pdb) que contiene información de depuración sobre la aplicación.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.</source>
          <target state="translated">El archivo es útil principalmente para depurar excepciones; puede elegir no empaquetarlo con los archivos de la aplicación.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The published files can be deployed in any way you'd like.</source>
          <target state="translated">Los archivos publicados se pueden implementar de la forma que desee.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For example, you can package them in a zip file, use a simple <ph id="ph1">`copy`</ph> command, or deploy them with any installation package of your choice.</source>
          <target state="translated">Por ejemplo, puede empaquetarlos en un archivo comprimido, usar un simple comando <ph id="ph1">`copy`</ph> o implementarlos con el paquete de instalación que prefiera.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The following is the complete <ph id="ph1">`project.json`</ph> file for this project.</source>
          <target state="translated">El siguiente es el archivo <ph id="ph1">`project.json`</ph> completo para este proyecto.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Deploying a self-contained deployment with third-party dependencies</source>
          <target state="translated">Implementación de una implementación autocontenida con dependencias de terceros</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Deploying a self-contained deployment with one or more third-party dependencies involves adding the third party dependency:</source>
          <target state="translated">Implementar una implementación autocontenida con una o varias dependencias de terceros implica agregar la dependencia de terceros:</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Add references to any third-party libraries to the <ph id="ph1">`dependencies`</ph> section of your <ph id="ph2">`project.json`</ph> file.</source>
          <target state="translated">Agregue referencias a las bibliotecas de terceros a la sección <ph id="ph1">`dependencies`</ph> de su archivo <ph id="ph2">`project.json`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The following  <ph id="ph1">`dependencies`</ph> section uses Json.NET as a third-party library.</source>
          <target state="translated">La siguiente sección <ph id="ph1">`dependencies`</ph> usa Json.NET como biblioteca de terceros.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If you haven't already, download the NuGet package containing the third-party dependency to your system.</source>
          <target state="translated">Si aún no lo ha hecho, descargue el paquete de NuGet que contiene la dependencia de terceros en el sistema.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>To make the dependency available to your app, execute the <ph id="ph1">`dotnet restore`</ph> command after adding the dependency.</source>
          <target state="translated">Para que la dependencia esté disponibles para la aplicación, ejecute el comando <ph id="ph1">`dotnet restore`</ph> después de agregar la dependencia.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Because the dependency is resolved out of the local NuGet cache at publish time, it must be available on your system.</source>
          <target state="translated">Como la dependencia se resuelve fuera de la caché local de NuGet en tiempo de publicación, debe estar disponible en el sistema.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The following is the complete project.json file for this project:</source>
          <target state="translated">El siguientes es el archivo project.json completo para este proyecto:</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>When you deploy your application, any third-party dependencies used in your app are also contained with your application files.</source>
          <target state="translated">Al implementar la aplicación, los archivos de aplicación también contienen las dependencias de terceros usadas en la aplicación.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Third-party libraries do not already have to be present on the system on which the app is running.</source>
          <target state="translated">Las bibliotecas de terceros no están aún presentes en el sistema en el que se ejecuta la aplicación.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Note that you can only deploy a self-contained deployment with a third-party library to platforms supported by that library.</source>
          <target state="translated">Tenga en cuenta que solo puede implementar una implementación autocontenida con una biblioteca de terceros en plataformas compatibles con esa biblioteca.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This is similar to having third-party dependencies with native dependencies in your framework-dependent deployment.</source>
          <target state="translated">Esto es parecido a tener dependencias de terceros con dependencias nativas en la implementación dependiente del marco.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Deploying a self-contained deployment with a smaller footprint</source>
          <target state="translated">Implementación de una implementación autocontenida con una superficie menor</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>If the availability of adequate storage space on target systems is likely to be an issue, you can reduce the overall footprint of your app by excluding some system components.</source>
          <target state="translated">Si la disponibilidad de espacio de almacenamiento adecuado en sistemas de destino puede ser un problema, puede reducir la superficie general de la aplicación excluyendo algunos componentes del sistema.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>To do this, you explicitly define the .NET Core components that your app includes in your project.json file.</source>
          <target state="translated">Para ello, defina explícitamente los componentes de .NET Core que incluye su aplicación en su archivo project.json.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>To create a self-contained deployment with a smaller footprint, start by following the first two steps for creating a self-contained deployment.</source>
          <target state="translated">Para crear una implementación autocontenida con una superficie menor, comience siguiendo los dos primeros pasos para crear una implementación autocontenida.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Once you've run the <ph id="ph1">`dotnet new`</ph> command and added the C# source code to your app, do the following:</source>
          <target state="translated">Cuando haya ejecutado el comando <ph id="ph1">`dotnet new`</ph> y agregado el código fuente de C# a la aplicación, haga lo siguiente:</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Open the <ph id="ph1">`project.json`</ph> file and replace the <ph id="ph2">`frameworks`</ph> section with the following:</source>
          <target state="translated">Abra el archivo <ph id="ph1">`project.json`</ph> y reemplace la sección <ph id="ph2">`frameworks`</ph> por lo siguiente:</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>This does two things:</source>
          <target state="translated">Esto hace dos cosas:</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>It indicates that, instead of using the entire <ph id="ph1">`netcoreapp1.0`</ph> framework, which includes .NET Core CLR, the .NET Core Library, and a number of other system components, our app uses only the .NET Standard Library.</source>
          <target state="translated">Indica que, en lugar de usar el marco entero <ph id="ph1">`netcoreapp1.0`</ph>, que incluye .NET Core CLR, la biblioteca .NET Core y varios otros componentes del sistema, la aplicación emplea solamente a la biblioteca estándar. NET.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>By removing the <ph id="ph1">`"type": "platform"`</ph> attribute, it indicates that the framework is provided as a set of components local to our app, rather than as a system-wide platform package.</source>
          <target state="translated">Al quitar el atributo <ph id="ph1">`"type": "platform"`</ph> se indica que el marco se proporciona como un conjunto de componentes locales a nuestra aplicación, y no como un paquete de plataforma de todo el sistema.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Replace the <ph id="ph1">`dependencies`</ph> section with the following:</source>
          <target state="translated">Reemplace la sección <ph id="ph1">`dependencies`</ph> por lo siguiente:</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>This defines the system components used by our app.</source>
          <target state="translated">Esto define los componentes del sistema usados por nuestra aplicación.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The system components packaged with our app include the .NET Standard Library, the .NET Core runtime, and the .NET Core host.</source>
          <target state="translated">Los componentes del sistema empaquetados con nuestra aplicación incluyen la biblioteca estándar. NET, el entorno de tiempo de ejecución de .NET Core y el host de .NET Core.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>This produces a self-contained deployment with a smaller footprint.</source>
          <target state="translated">Esto produce una implementación autocontenida con una superficie menor.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>As you did in the <bpt id="p1">[</bpt>Deploying a simple self-contained deployment<ept id="p1">](#simpleSelf)</ept> example, create a <ph id="ph1">`runtimes`</ph> section in your <ph id="ph2">`project.json`</ph> file that defines the platforms your app targets and specify the runtime identifier of each platform that you target.</source>
          <target state="translated">Al igual que hizo en el ejemplo <ph id="ph1">`runtimes`</ph>Implementación de una implementación autocontenida sencilla<ph id="ph2">`project.json`</ph>, cree una sección <bpt id="p1">[</bpt> en el archivo <ept id="p1">](#simpleSelf)</ept> que defina las plataformas a las que se dirige su aplicación, y especifique el identificador de tiempo de ejecución de cada una.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime IDentifier catalog<ept id="p1">](../rid-catalog.md)</ept> for a list of runtime identifiers.</source>
          <target state="translated">Para ver una lista de identificadores de tiempo de ejecución, consulte el <bpt id="p1">[</bpt>catálogo de identificadores de tiempo de ejecución<ept id="p1">](../rid-catalog.md)</ept>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>For example, the following <ph id="ph1">`runtimes`</ph> section indicates that the app runs on 64-bit Windows 10 operating systems and the 64-bit OS X Version 10.10 operating system.</source>
          <target state="translated">Por ejemplo, la siguiente sección <ph id="ph1">`runtimes`</ph> indica que la aplicación se ejecuta en sistemas operativos Windows 10 de 64 bits y OS X versión 10.10 de 64 bits.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Note that you also need to add a comma to separate the <ph id="ph1">`runtimes`</ph> section from the previous section.</source>
          <target state="translated">Tenga en cuenta también de que debe agregar una coma para separar la sección <ph id="ph1">`runtimes`</ph> de la sección anterior.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>A complete sample <ph id="ph1">`project.json`</ph> file appears later in this section.</source>
          <target state="translated">Más adelante en esta sección aparece un ejemplo completo del archivo <ph id="ph1">`project.json`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Run the <ph id="ph1">`dotnet restore`</ph> command to restore the dependencies specified in your project.</source>
          <target state="translated">Ejecute el comando <ph id="ph1">`dotnet restore`</ph> para restaurar las dependencias especificadas en el proyecto.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Create debug builds of your app on each of the target platforms by using the <ph id="ph1">`dotnet build`</ph> command.</source>
          <target state="translated">Cree compilaciones de depuración de la aplicación en cada plataforma de destino mediante el comando <ph id="ph1">`dotnet build`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Unless you specify the runtime identifier you'd like to build, the <ph id="ph1">`dotnet build`</ph> command creates a build only for the current system's runtime ID.</source>
          <target state="translated">A menos que especifique el identificador de tiempo de ejecución que desea quiere compilar, el comando <ph id="ph1">`dotnet build`</ph> crea una compilación solo para el ID de tiempo de ejecución actual del sistema.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>You can build your app for both target platforms with the commands:</source>
          <target state="translated">Puede compilar la aplicación para ambas plataformas de destino con los comandos:</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>After you've debugged and tested the program, you can create the files to be deployed with your app for each platform that it targets by using the <ph id="ph1">`dotnet publish`</ph> command for both target platforms as follows:</source>
          <target state="translated">Después de depurar y probar el programa, puede crear los archivos que se implementarán con la aplicación para cada plataforma de destino mediante la ejecución del comando <ph id="ph1">`dotnet publish`</ph> en ambas plataformas de destino, de la manera siguiente:</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>This creates a release (rather than a debug) version of your app for each target platform.</source>
          <target state="translated">Se crea una versión de lanzamiento (en lugar de una depuración) de la aplicación para cada plataforma de destino.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The resulting files are placed in a subdirectory named <ph id="ph1">`publish`</ph> that is in a subdirectory of your project's <ph id="ph2">`.\bin\release\netstandard1.6\&lt;runtime_identifier&gt;`</ph> subdirectory.</source>
          <target state="translated">Los archivos resultantes se colocan en un subdirectorio denominado <ph id="ph1">`publish`</ph> que se encuentra en un subdirectorio del subdirectorio <ph id="ph2">`.\bin\release\netstandard1.6\&lt;runtime_identifier&gt;`</ph> del proyecto.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Note that each subdirectory contains the complete set of files (both your app files and all .NET Core files) needed to launch your app.</source>
          <target state="translated">Tenga en cuenta que cada subdirectorio contiene el conjunto completo de archivos (los archivos de aplicación y todos los archivos de .NET Core) necesario para iniciar la aplicación.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app.</source>
          <target state="translated">Junto con los archivos de la aplicación, el proceso de publicación emite un archivo de base de datos de programa (.pdb) que contiene información de depuración sobre la aplicación.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.</source>
          <target state="translated">El archivo es útil principalmente para depurar excepciones; puede elegir no empaquetarlo con los archivos de la aplicación.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The published files can be deployed in any way you'd like.</source>
          <target state="translated">Los archivos publicados se pueden implementar de la forma que desee.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>For example, you can package them in a zip file, use a simple <ph id="ph1">`copy`</ph> command, or deploy them with any installation package of your choice.</source>
          <target state="translated">Por ejemplo, puede empaquetarlos en un archivo comprimido, usar un simple comando <ph id="ph1">`copy`</ph> o implementarlos con el paquete de instalación que prefiera.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following is the complete <ph id="ph1">`project.json`</ph> file for this project.</source>
          <target state="translated">El siguiente es el archivo <ph id="ph1">`project.json`</ph> completo para este proyecto.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>