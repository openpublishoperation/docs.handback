<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a35385cbb08614493fdcfc74504b00178dc532ea</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tools\test-protocol.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">571f9ba49be9fc4a0d1dd23f2457b2087630460a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc71dad02f1e86873b9019185f14ff3375d92ce9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">Protocolo de comunicación de prueba de la CLI de .NET Core</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">Protocolo de comunicación de prueba de la CLI de .NET Core</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">Protocolo de comunicación de prueba de la CLI de .NET Core</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introducción</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Anytime you pass a port to dotnet test, the command will run in design time.</source>
          <target state="translated">Cada vez que pasa un puerto a prueba de dotnet, el comando se ejecutará en tiempo de diseño.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>That means that dotnet test will connect to that port using TCP and will then exchange an established set of messages with whatever else is connected to that port.</source>
          <target state="translated">Eso significa que la prueba de dotnet se conectará a ese puerto a través de TCP y, luego, intercambiará un conjunto establecido de mensajes con lo que sea que esté conectado a ese puerto.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When this happens, the runner also receives a new port that dotnet test will use to communicate with it.</source>
          <target state="translated">Cuando esto sucede, el ejecutor también recibe un puerto nuevo que la prueba de dotnet usará para comunicarse con él.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The reason why the runner also uses TCP to communicate with dotnet test is because in design mode, it is not sufficient to just output results to the console.</source>
          <target state="translated">El ejecutor también usa TCP para comunicarse con la prueba de dotnet porque, en el modo de diseño, no resulta suficiente solo mostrar los resultados en la consola.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The command needs to send the adapter structure messages containing the results of the test execution.</source>
          <target state="translated">El comando necesita enviar los mensajes de la estructura del adaptador que contienen los resultados de la ejecución de la prueba.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Communication protocol at design time.</source>
          <target state="translated">Protocolo de comunicación en tiempo de diseño.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Because during design time, dotnet test connects to a port when it starts up, the adapter needs to be listening on that port otherwise dotnet test will fail.</source>
          <target state="translated">Como durante el tiempo de diseño, la prueba de dotnet se conecta a un puerto cuando se inicia, el adaptador debe escuchar en ese puerto; de lo contrario, la prueba de dotnet generará un error.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>We did it like this so that the adapter could reserve all the ports it needs by binding and listening to them before dotnet test ran and tried to get ports for the runner.</source>
          <target state="translated">Esto se diseñó así para que el adaptador pudiera reservar todos los puertos necesarios al enlazarse con ellos y escucharlos antes de que la prueba de dotnet se ejecute e intente obtener los puertos para el ejecutor.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Once dotnet test starts, it sends a TestSession.Connected message to the adapter indicating that it is ready to receive messages.</source>
          <target state="translated">Una vez que se inicia la prueba de dotnet, envía un mensaje de tipo TestSession.Connected al adaptador para indicar que está preparada para recibir mensajes.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>It is possible to send an optional <bpt id="p1">[</bpt>version check<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept> message with the adapter version of the protocol in it.</source>
          <target state="translated">Es posible enviar un mensaje de <bpt id="p1">[</bpt>comprobación de la versión<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept> con la versión del adaptador del protocolo en él.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Dotnet test will send back the version of the protocol that it supports.</source>
          <target state="translated">La prueba de dotnet enviará de vuelta la versión del protocolo que admite.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>All messages have the format described here: <bpt id="p1">[</bpt>Message.cs<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>.</source>
          <target state="translated">Todos los mensajes tienen este formato: <bpt id="p1">[</bpt>Message.cs<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The payload formats for each message is described in links to the classes used to serialize/deserialize the information in the description of the protocol.</source>
          <target state="translated">Los formatos de carga de cada mensaje se describen en los vínculos a las clases que se usan para serializar/deserializar la información que aparece en la descripción del protocolo.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Test Execution</source>
          <target state="translated">Ejecución de pruebas</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Test Execution</source>
          <target state="translated">Ejecución de pruebas</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>After the optional version check, the adapter sends a TestExecution.GetTestRunnerProcessStartInfo, with the <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> it wants to execute inside of it.</source>
          <target state="translated">Después de la comprobación opcional de la versión, el adaptador envía un mensaje de tipo TestExecution.GetTestRunnerProcessStartInfo, con la <bpt id="p1">[</bpt>prueba<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> que desea ejecutar dentro.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Dotnet test sends back a FileName and Arguments inside a <bpt id="p1">[</bpt>TestStartInfo<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.DotNet.Tools.Test/TestStartInfo.cs)</ept> payload that the adapter can use to start the runner.</source>
          <target state="translated">La prueba de dotnet envía de vuelta un nombre de archivo y argumentos dentro de una carga de tipo <bpt id="p1">[</bpt>TestStartInfo<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.DotNet.Tools.Test/TestStartInfo.cs)</ept> que el adaptador puede usar para iniciar el ejecutor.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In the past, we would send the list of tests to run as part of that argument, but we were actually going over the command line size limit for some test projects.</source>
          <target state="translated">Anteriormente, habríamos enviado la lista de las pruebas a ejecutar como parte de ese argumento pero, en realidad, habríamos superado el límite de tamaño de la línea de comandos en algunos proyectos de prueba.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>As part of the arguments, we send a port that the runner should connect to and for executing tests, a --wait-command flag, that indicates that the runner should connect to the port and wait for commands, instead of going ahead and executing the tests.</source>
          <target state="translated">Como parte de los argumentos, enviamos un puerto al que se debe conectar el ejecutor y, para la ejecución de las pruebas, una marca de tipo --wait-command, que indica que el ejecutor se debe conectar al puerto y esperar los comandos, en lugar de avanzar y ejecutar las pruebas.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>At this point, the adapter can launch the runner (and attach to it for debugging if it chooses to).</source>
          <target state="translated">En este punto, el adaptador puede iniciar el ejecutor (y conectarse a él para realizar una depuración, si decide hacerlo).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Once the runner starts, it sends dotnet test a TestRunner.WaitCommand message that indicates it is ready to receive commands, at which point dotnet test sends a TestRunner.Execute with the list of <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> to run.</source>
          <target state="translated">Una vez que se inicia el ejecutor, envía a la prueba de dotnet un mensaje de tipo TestRunner.WaitCommand que indica que está preparado para recibir comandos, en cuyo caso la prueba de dotnet envía un mensaje de tipo TestRunner.Execute con la lista de las <bpt id="p1">[</bpt>pruebas<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> que se deben ejecutar.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This bypasses the command line size limit described above.</source>
          <target state="translated">Con esto se omite el límite de tamaño de la línea de comandos que se describió anteriormente.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The runner then sends dotnet test (and it passes forward to the adapter) a TestExecution.TestStarted for each tests as they start with the <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> information inside of it.</source>
          <target state="translated">Luego, el ejecutor envía a la prueba de dotnet (y pasa al adaptador) un mensaje de tipo TestExecution.TestStarted para cada prueba a medida que se inicia con la información sobre la <bpt id="p1">[</bpt>prueba<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> dentro de él.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The runner also sends dotnet test (and it forwards to the adapter) a TestExecution.TestResult for each test with the <bpt id="p1">[</bpt>individual result<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept> of the test.</source>
          <target state="translated">El ejecutor también envía a la prueba de dotnet (y pasa al adaptador) un mensaje de tipo TestExecution.TestResult para cada prueba con el <bpt id="p1">[</bpt>resultado individual<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept> de la misma.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>After all tests finish, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestExecution.Completed to the adapter.</source>
          <target state="translated">Una vez que se realizan todas las pruebas, el ejecutor envía un mensaje de tipo TestRunner.Completed a la prueba de dotnet que, a su vez, lo envía como mensaje de tipo TestExecution.Completed al adaptador.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.</source>
          <target state="translated">Una vez que el adaptador está listo, envía a la prueba de dotnet un mensaje de tipo TestSession.Terminate, el que hará que la prueba de dotnet se apague.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Test discovery</source>
          <target state="translated">Detección de pruebas</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Test discovery</source>
          <target state="translated">Detección de pruebas</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>After the optional version check, the adapter sends a TestDiscovery.Start message.</source>
          <target state="translated">Después de la comprobación opcional de la versión, el adaptador envía un mensaje de tipo TestDiscovery.Start.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Because in this case, the adapter does not need to attach to the process, dotnet test will start the runner itself.</source>
          <target state="translated">Como en este caso el adaptador no necesita conectarse al proceso, la prueba de dotnet iniciará el ejecutor mismo.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Also, since there is no long list of arguments to be passed to the runner, no --wait-command flag is needed to be passed to the runner.</source>
          <target state="translated">Además, y debido a que no se debe pasar ninguna lista larga de argumentos al ejecutor, no es necesario pasar ninguna marca --wait-command al ejecutor.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>dotnet test only passes a --list argument to the runner, which means the runner should not run the tests, just list them.</source>
          <target state="translated">La prueba de dotnet solo pasa un argumento --list al ejecutor, lo que significa que el ejecutor no debe ejecutar las pruebas, sino que solo mostrarlas.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The runner then sends dotnet test (and it passes forward to the adapter) a TestDiscovery.TestFound for each <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> found.</source>
          <target state="translated">Luego, el ejecutor envía a la prueba de dotnet (y pasa al adaptador) un mensaje de tipo TestDiscovery.TestFound para cada <bpt id="p1">[</bpt>prueba<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> que se encuentra.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>After all tests are discovered, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestDiscovery.Completed to the adapter.</source>
          <target state="translated">Una vez que se realizan todas las pruebas, el ejecutor envía un mensaje de tipo TestRunner.Completed a la prueba de dotnet que, a su vez, lo envía como mensaje de tipo TestDiscovery.Completed al adaptador.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.</source>
          <target state="translated">Una vez que el adaptador está listo, envía a la prueba de dotnet un mensaje de tipo TestSession.Terminate, el que hará que la prueba de dotnet se apague.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>