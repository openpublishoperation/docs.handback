<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5271b63a47aa2fcc81cd9c8b1ffd22e618829412</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\exceptions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4039eb59d735cb586da4b617c06c78c4c56de430</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">be4d291e2a7cf2236c26ac277caceef429e3920d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Handling and throwing exceptions in .NET</source>
          <target state="translated">Controlar y generar excepciones en .NET</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Understand how to use exceptions in .NET</source>
          <target state="translated">Aprender a usar excepciones en .NET</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Handling and throwing exceptions in .NET</source>
          <target state="translated">Controlar y generar excepciones en .NET</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Applications must be able to handle errors that occur during execution in a consistent manner.</source>
          <target state="translated">Las aplicaciones tienen que ser capaces de controlar de forma coherente los errores que se producen durante la ejecución.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>.NET provides a model for notifying applications of errors in a uniform way: .NET operations indicate failure by throwing exceptions.</source>
          <target state="translated">.NET proporciona un modelo para notificar errores a las aplicaciones de manera uniforme: las operaciones .NET indican errores iniciando excepciones.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Excepciones</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>An exception is any error condition or unexpected behavior that is encountered by an executing program.</source>
          <target state="translated">Una excepción es cualquier condición de error o comportamiento inesperado que encuentra un programa en ejecución.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Exceptions can be thrown because of a fault in your code or in code that you call (such as a shared library), unavailable operating system resources, unexpected conditions that the runtime encounters (such as code that cannot be verified), and so on.</source>
          <target state="translated">Las excepciones pueden iniciarse debido a un error en el código propio o en el código al que se llama (por ejemplo, una biblioteca compartida), a recursos del sistema operativo no disponibles, a condiciones inesperadas que encuentra el runtime (por ejemplo, imposibilidad de comprobar el código), etc.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Your application can recover from some of these conditions, but not from others.</source>
          <target state="translated">La aplicación puede recuperarse de algunas de estas condiciones, pero no de todas.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Although you can recover from most application exceptions, you cannot recover from most runtime exceptions.</source>
          <target state="translated">Aunque es posible recuperarse de la mayoría de las excepciones que se producen en la aplicación, no ocurre lo mismo con las excepciones de runtime.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In .NET, an exception is an object that inherits from the <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept> class.</source>
          <target state="translated">En .NET, una excepción es un objeto que hereda de la clase <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>An exception is thrown from an area of code where a problem has occurred.</source>
          <target state="translated">Una excepción se inicia desde un área del código en la que ha producido un problema.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The exception is passed up the stack until the application handles it or the program terminates.</source>
          <target state="translated">La excepción se pasa hacia arriba en la pila hasta que la aplicación la controla o el programa finaliza.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Exceptions vs. traditional error-handling methods</source>
          <target state="translated">Comparación entre los métodos tradicionales de control de errores y las excepciones</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Traditionally, a language's error-handling model relied on either the language's unique way of detecting errors and locating handlers for them, or on the error-handling mechanism provided by the operating system.</source>
          <target state="translated">Tradicionalmente, el modelo de control de errores de un lenguaje se basaba en el modo exclusivo del lenguaje de detectar los errores y buscarles controladores, o bien en el mecanismo de control de errores ofrecido por el sistema operativo.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The way .NET implements exception handling provides the following advantages:</source>
          <target state="translated">La forma en que .NET implementa el control de excepciones proporciona las siguientes ventajas:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Exception throwing and handling works the same for .NET programming languages.</source>
          <target state="translated">La administración e iniciación de excepciones funciona de igual modo para los lenguajes de programación. NET.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Does not require any particular language syntax for handling exceptions, but allows each language to define its own syntax.</source>
          <target state="translated">No requiere ninguna sintaxis de lenguaje específica para controlar las excepciones, pero permite que cada lenguaje defina su propia sintaxis.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Exceptions can be thrown across process and even machine boundaries.</source>
          <target state="translated">Las excepciones pueden iniciarse en varios procesos en incluso límites de máquina.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Exception-handling code can be added to an application to increase program reliability.</source>
          <target state="translated">Se puede agregar el código de control de excepciones a una aplicación para aumentar la confiabilidad del programa.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Exceptions offer advantages over other methods of error notification, such as return codes.</source>
          <target state="translated">Las excepciones ofrecen ventajas sobre otros métodos de notificación de errores, por ejemplo, los códigos de retorno.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Failures do not go unnoticed because if an exception is thrown and you don't handle it, the runtime terminates your application.</source>
          <target state="translated">Lo errores no pasan desapercibidos porque si se inicia una excepción y no la controla, el runtime finaliza la aplicación.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Invalid values do not continue to propagate through the system as a result of code that fails to check for a failure return code.</source>
          <target state="translated">Los valores no válidos no continúan propagándose por el sistema como resultado de que el código no pueda encontrar un código de retorno de error.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Exception class and properties</source>
          <target state="translated">Clase Exception y propiedades</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">@System.Exception</ph> class is the base class from which exceptions inherit.</source>
          <target state="translated">La clase <ph id="ph1">@System.Exception</ph> es la clase base de la que heredan las excepciones.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">@System.InvalidCastException</ph> class hierarchy is as follows:</source>
          <target state="translated">Por ejemplo, la jerarquía de clases de <ph id="ph1">@System.InvalidCastException</ph> es como sigue:</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">@System.Exception</ph> class has the following properties that help make understanding an exception easier.</source>
          <target state="translated">La clase <ph id="ph1">@System.Exception</ph> tiene las siguientes propiedades que facilitan la comprensión de una excepción.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Property Name</source>
          <target state="translated">Nombre de la propiedad</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">@System.Collections.IDictionary</ph> that holds arbitrary data in key-value pairs.</source>
          <target state="translated">Un <ph id="ph1">@System.Collections.IDictionary</ph> que contiene datos arbitrarios en pares de clave y valor.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Can hold a URL (or URN) to a help file that provides extensive information about the cause of an exception.</source>
          <target state="translated">Puede contener una dirección URL (o URN) a un archivo de ayuda que proporciona amplia información sobre la causa de una excepción.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>This property can be used to create and preserve a series of exceptions during exception handling.</source>
          <target state="translated">Esta propiedad puede usarse para crear y mantener una serie de excepciones durante el control de excepciones.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You can use it to create a new exception that contains previously caught exceptions.</source>
          <target state="translated">Puede usarla para crear una nueva excepción que contiene excepciones detectadas con anterioridad.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The original exception can be captured by the second exception in the <ph id="ph1">@System.Exception.InnerException</ph> property, allowing code that handles the second exception to examine the additional information.</source>
          <target state="translated">La segunda excepción en la propiedad <ph id="ph1">@System.Exception.InnerException</ph> puede capturar la excepción original, lo que permite que el código que controla la segunda excepción examine la información adicional.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a method that receives an argument that's improperly formatted.</source>
          <target state="translated">Por ejemplo, supongamos que tiene un método que recibe un argumento que contiene un formato incorrecto.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The code tries to read the argument, but an exception is thrown.</source>
          <target state="translated">El código intenta leer el argumento, pero se inicia una excepción.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The method catches the exception and throws a <ph id="ph1">@System.FormatException.</ph> To improve the caller's ability to determine the reason an exception is thrown, it is sometimes desirable for a method to catch an exception thrown by a helper routine and then throw an exception more indicative of the error that has occurred.</source>
          <target state="translated">El método detecta la excepción y produce un <ph id="ph1">@System.FormatException.</ph>. Para mejorar la capacidad del autor de llamada a la hora de determinar por qué se inicia una excepción, a veces, para un método es recomendable detectar una excepción iniciada por una rutina auxiliar y, después, iniciar una excepción más indicativa del error que se ha producido.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A new and more meaningful exception can be created, where the inner exception reference can be set to the original exception.</source>
          <target state="translated">Puede crear una excepción nueva y más significativa, donde se puede establecer la referencia a la excepción interna en la excepción original.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This more meaningful exception can then be thrown to the caller.</source>
          <target state="translated">Después, se puede iniciar esta excepción más significativa para el autor de llamada.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Note that with this functionality, you can create a series of linked exceptions that ends with the exception that was thrown first.</source>
          <target state="translated">Tenga en cuenta que con esta funcionalidad, puede crear una serie de excepciones vinculadas que termina con la excepción que se inicia en primer lugar.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Provides details about the cause of an exception.</source>
          <target state="translated">Proporciona detalles sobre la causa de una excepción.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of the application or the object that causes the error.</source>
          <target state="translated">Devuelve o establece el nombre de la aplicación o del objeto que generó el error.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Contains a stack trace that can be used to determine where an error occurred.</source>
          <target state="translated">Contiene un seguimiento de la pila que puede usarse para determinar dónde se produjo un error.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The stack trace includes the source file name and program line number if debugging information is available.</source>
          <target state="translated">El seguimiento de la pila contiene el nombre del archivo de código fuente y el número de línea del programa si está disponible la información de depuración.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Most of the classes that inherit from <ph id="ph1">@System.Exception</ph> do not implement additional members or provide additional functionality; they simply inherit from <ph id="ph2">@System.Exception.</ph> Therefore, the most important information for an exception can be found in the hierarchy of exception classes, the exception name, and the information contained in the exception.</source>
          <target state="translated">La mayoría de las clases que heredan de <ph id="ph1">@System.Exception</ph> no implementan miembros adicionales ni proporcionan funcionalidades adicionales. Simplemente, heredan de <ph id="ph2">@System.Exception.</ph>. Por tanto, se puede encontrar la información más importante para una excepción en la jerarquía de clases de excepción, el nombre de la excepción y la información contenida en la excepción.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>It is recommended to throw and catch only objects that derive from <ph id="ph1">@System.Exception,</ph> but you can throw any object that derives from the <ph id="ph2">@System.Object</ph> class as an exception.</source>
          <target state="translated">Se recomienda iniciar y detectar solo los objetos que se derivan de <ph id="ph1">@System.Exception,</ph>, pero puede iniciar cualquier objeto que se deriva de la clase <ph id="ph2">@System.Object</ph> como una excepción.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Note that not all languages support throwing and catching objects that do not derive from <ph id="ph1">@System.Exception.</ph></source>
          <target state="translated">Tenga en cuenta que no todos los lenguajes admiten iniciar y detectar objetos que no se derivan de <ph id="ph1">@System.Exception.</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Common Exceptions</source>
          <target state="translated">Excepciones comunes</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The following table lists some common exceptions with examples of what can cause them.</source>
          <target state="translated">En la tabla siguiente se muestra algunas excepciones comunes con ejemplos de las causas que las originan.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Exception type</source>
          <target state="translated">Tipo de excepción</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Base type</source>
          <target state="translated">Tipo base</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Ejemplo</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Base class for all exceptions.</source>
          <target state="translated">Clase base de todas las excepciones.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>None (use a derived class of this exception).</source>
          <target state="translated">Ninguno (utilice una clase derivada de esta excepción).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Thrown by the runtime only when an array is indexed improperly.</source>
          <target state="translated">El tiempo de ejecución la genera solo cuando una matriz no está correctamente indexada.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Indexing an array outside its valid range: <ph id="ph1">`arr[arr.Length+1]`</ph></source>
          <target state="translated">La indexación de una matriz fuera de su intervalo válido: <ph id="ph1">`arr[arr.Length+1]`</ph></target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Thrown by the runtime only when a null object is referenced.</source>
          <target state="translated">El tiempo de ejecución la genera solo cuando se hace referencia a un objeto null.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Thrown by methods when in an invalid state.</source>
          <target state="translated">Los métodos la generan si se produce un estado no válido.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Calling <ph id="ph1">`Enumerator.GetNext()`</ph> after removing an Item from the underlying collection.</source>
          <target state="translated">Llamada a <ph id="ph1">`Enumerator.GetNext()`</ph> después de quitar un elemento de la colección subyacente.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Base class for all argument exceptions.</source>
          <target state="translated">Clase base de todas las excepciones de argumento.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>None (use a derived class of this exception).</source>
          <target state="translated">Ninguno (utilice una clase derivada de esta excepción).</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Thrown by methods that do not allow an argument to be null.</source>
          <target state="translated">Los métodos que no permiten que un argumento sea null la generan.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Thrown by methods that verify that arguments are in a given range.</source>
          <target state="translated">Los métodos que comprueban que los argumentos se encuentran en un intervalo determinado la generan.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>How to use the try/catch block to catch exceptions</source>
          <target state="translated">Cómo usar el bloque Try/Catch para detectar excepciones</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Place the sections of code that might throw exceptions in a <ph id="ph1">`try`</ph> block and place code that handles exceptions in a <ph id="ph2">`catch`</ph> block.</source>
          <target state="translated">Coloque las secciones del código que pueden iniciar excepciones en un bloque <ph id="ph1">`try`</ph> y coloque el código que controla las excepciones en un bloque <ph id="ph2">`catch`</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`catch`</ph> block is a series of statements beginning with the keyword <ph id="ph2">`catch`</ph>, followed by an exception type and an action to be taken.</source>
          <target state="translated">El bloque <ph id="ph1">`catch`</ph> es una serie de instrucciones que comienzan con la palabra clave <ph id="ph2">`catch`</ph>, seguido de un tipo de excepción y la acción que se debe realizar.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The following code example uses a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block to catch a possible exception.</source>
          <target state="translated">El siguiente ejemplo de código usa un bloque <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> para detectar una posible excepción.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Main`</ph> method contains a <ph id="ph2">`try`</ph> block with a <ph id="ph3">@System.IO.StreamReader</ph> statement that opens a data file called <ph id="ph4">`data.txt`</ph> and writes a string from the file.</source>
          <target state="translated">El método <ph id="ph1">`Main`</ph> contiene un bloque <ph id="ph2">`try`</ph> con una instrucción de <ph id="ph3">@System.IO.StreamReader</ph> que abre un archivo de datos denominado <ph id="ph4">`data.txt`</ph> y escribe una cadena del archivo.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Following the <ph id="ph1">`try`</ph> block is a <ph id="ph2">`catch`</ph> block that catches any exception that results from the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">Después del bloque <ph id="ph1">`try`</ph> aparece un bloque <ph id="ph2">`catch`</ph> que detecta cualquier excepción que se produzca desde el bloque <ph id="ph3">`try`</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The common language runtime catches exceptions that are not caught by a catch block.</source>
          <target state="translated">Common Language Runtime detecta las excepciones que no se detectan mediante un bloque Catch.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Depending on how the runtime is configured, a debug dialog box appears, or the program stops executing and a dialog box with exception information appears, or an error is printed out to STDERR.</source>
          <target state="translated">Dependiendo de cómo esté configurado el runtime, aparece un cuadro de diálogo de depuración, el programa deja de ejecutarse y aparece un cuadro de diálogo con información sobre la excepción o bien se imprime un error en STDERR.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Almost any line of code can cause an exception, particularly exceptions that are thrown by the common language runtime itself, such as <ph id="ph1">@System.OutOfMemoryException.</ph> Most applications don't have to deal with these exceptions, but you should be aware of this possibility when writing libraries to be used by others.</source>
          <target state="translated">Prácticamente cualquier línea de código puede producir una excepción, especialmente excepciones que produce el propio common language runtime, como <ph id="ph1">@System.OutOfMemoryException.</ph>. La mayoría de las aplicaciones no tienen que tratar con estas excepciones, pero debe tener en cuenta esta posibilidad al escribir bibliotecas que puedan usar otros usuarios.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For suggestions on when to set code in a Try block, see <bpt id="p1">[</bpt>Best Practices for Exceptions<ept id="p1">](#best-practices-for-exceptions)</ept>.</source>
          <target state="translated">Para obtener sugerencias sobre cuándo establecer el código en un bloque Try, consulte <bpt id="p1">[</bpt>Procedimientos recomendados para excepciones<ept id="p1">](#best-practices-for-exceptions)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>How to use specific exceptions in a Catch block</source>
          <target state="translated">Cómo usar excepciones específicas en un bloque Catch</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The preceding code example illustrates a basic <ph id="ph1">`catch`</ph> statement that catches any exception.</source>
          <target state="translated">El ejemplo de código anterior muestra una instrucción <ph id="ph1">`catch`</ph> básica que detecta cualquier excepción.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>In general, though, it's good programming practice to catch a specific type of exception rather than use a basic <ph id="ph1">`catch`</ph> statement.</source>
          <target state="translated">Pero en general, en programación es recomendable detectar un tipo de excepción específico en lugar de usar una instrucción <ph id="ph1">`catch`</ph> básica.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>When an exception occurs, it is passed up the stack and each catch block is given the opportunity to handle it.</source>
          <target state="translated">Cuando se produce una excepción, se pasa a la pila y cada bloque Catch tiene la oportunidad de controlarla.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The order of catch statements is important.</source>
          <target state="translated">El orden de las instrucciones Catch es importante.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Put catch blocks targeted to specific exceptions before a general exception catch block or the compiler might issue an error.</source>
          <target state="translated">Ponga los bloques Catch dirigidos a excepciones específicas antes de un bloque Catch de excepción general o el compilador podría emitir un error.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The proper catch block is determined by matching the type of the exception to the name of the exception specified in the catch block.</source>
          <target state="translated">El bloque Catch adecuado se determina haciendo coincidir el tipo de la excepción con el nombre de la excepción especificada en el bloque Catch.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If there is no specific catch block, the exception is caught by a general catch block, if one exists.</source>
          <target state="translated">Si no hay ningún bloque Catch específico, la excepción se detecta mediante un bloque Catch general, si existe alguno.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The following code example uses a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block to catch an <ph id="ph4">@System.InvalidCastException.</ph> The sample creates a class called <ph id="ph5">`Employee`</ph> with a single property, employee level (<ph id="ph6">`Emlevel`</ph>).</source>
          <target state="translated">El siguiente ejemplo de código utiliza un bloque <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> para capturar un <ph id="ph4">@System.InvalidCastException.</ph>. El ejemplo crea una clase denominada <ph id="ph5">`Employee`</ph> con una única propiedad, el nivel de empleado (<ph id="ph6">`Emlevel`</ph>).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A method, <ph id="ph1">`PromoteEmployee`</ph>, takes an object and increments the employee level.</source>
          <target state="translated">Un método, <ph id="ph1">`PromoteEmployee`</ph>, toma un objeto e incrementa el nivel del empleado.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">@System.InvalidCastException</ph> occurs when a <ph id="ph2">@System.DateTime</ph> instance is passed to the <ph id="ph3">`PromoteEmployee`</ph> method.</source>
          <target state="translated">Una <ph id="ph1">@System.InvalidCastException</ph> se produce cuando una instancia de <ph id="ph2">@System.DateTime</ph> se pasa al método <ph id="ph3">`PromoteEmployee`</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>How to use finally blocks</source>
          <target state="translated">Cómo usar bloques Finally</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>When an exception occurs, execution stops and control is given to the appropriate exception handler.</source>
          <target state="translated">Cuando se produce una excepción, se detiene la ejecución y se proporciona el control al controlador de excepciones adecuado.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>This often means that lines of code you expect to be executed are bypassed.</source>
          <target state="translated">A menudo, esto significa que se omiten líneas de código que esperaba que se ejecuten.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Some resource cleanup, such as closing a file, needs to be done even if an exception is thrown.</source>
          <target state="translated">Se debe realizar alguna limpieza de recursos, como cerrar un archivo, aunque se inicie una excepción.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>To do this, you can use a <ph id="ph1">`finally`</ph> block.</source>
          <target state="translated">Para ello, puede usar un bloque <ph id="ph1">`finally`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`finally`</ph> block always executes, regardless of whether an exception is thrown.</source>
          <target state="translated">Un bloque <ph id="ph1">`finally`</ph> siempre se ejecuta, independientemente de si se inicia una excepción.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The following code example uses a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block to catch an <ph id="ph4">@System.ArgumentOutOfRangeException.</ph> The <ph id="ph5">`Main`</ph> method creates two arrays and attempts to copy one to the other.</source>
          <target state="translated">El siguiente ejemplo de código utiliza un bloque <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> para capturar un <ph id="ph4">@System.ArgumentOutOfRangeException.</ph>. El método <ph id="ph5">`Main`</ph> crea dos matrices e intenta copiar una en la otra.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The action generates an <ph id="ph1">@System.ArgumentOutOfRangeException</ph> and the error is written to the console.</source>
          <target state="translated">La acción genera un <ph id="ph1">@System.ArgumentOutOfRangeException</ph> y el error se escribe en la consola.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`finally`</ph> block executes regardless of the outcome of the copy action.</source>
          <target state="translated">Este bloque <ph id="ph1">`finally`</ph> se ejecuta independientemente del resultado de la acción de copia.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>How to explicitly throw exceptions</source>
          <target state="translated">Cómo iniciar excepciones explícitamente</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can explicitly throw an exception using the <ph id="ph1">`throw`</ph> statement.</source>
          <target state="translated">Puede iniciar explícitamente una excepción mediante la instrucción <ph id="ph1">`throw`</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>You can also throw a caught exception again using the <ph id="ph1">`throw`</ph> statement.</source>
          <target state="translated">También se puede iniciar una excepción detectada usando de nuevo la instrucción <ph id="ph1">`throw`</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>It is good coding practice to add information to an exception that is re-thrown to provide more information when debugging.</source>
          <target state="translated">En diseño de código, es recomendable agregar información a una excepción que se vuelve a iniciar para proporcionar más información durante la depuración.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The following code example uses a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block to catch a possible <ph id="ph4">@System.IO.FileNotFoundException.</ph> Following the <ph id="ph5">`try`</ph> block is a <ph id="ph6">`catch`</ph> block that catches the <ph id="ph7">@System.IO.FileNotFoundException</ph> and writes a message to the console if the data file is not found.</source>
          <target state="translated">El siguiente ejemplo de código utiliza un bloque <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> para capturar un posible <ph id="ph4">@System.IO.FileNotFoundException.</ph>. Después del bloque <ph id="ph5">`try`</ph>, hay un bloque <ph id="ph6">`catch`</ph> que captura el <ph id="ph7">@System.IO.FileNotFoundException</ph> y escribe un mensaje en la consola si no se encuentra el archivo de datos.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The next statement is the <ph id="ph1">`throw`</ph> statement that throws a new <ph id="ph2">@System.IO.FileNotFoundException</ph> and adds text information to the exception.</source>
          <target state="translated">La siguiente instrucción es <ph id="ph1">`throw`</ph> que inicia un parámetro <ph id="ph2">@System.IO.FileNotFoundException</ph> nuevo y agrega información de texto a la excepción.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>How to create user-defined exceptions</source>
          <target state="translated">Cómo crear excepciones definidas por el usuario</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>.NET provides a hierarchy of exception classes ultimately derived from the base class <ph id="ph1">@System.Exception.</ph> However, if none of the predefined exceptions meets your needs, you can create your own exception classes by deriving from the <ph id="ph2">@System.Exception</ph> class.</source>
          <target state="translated">.NET proporciona una jerarquía de clases de excepción que se derivan en última instancia de la clase base <ph id="ph1">@System.Exception.</ph>. Sin embargo, si ninguna de las excepciones predefinidas satisface sus necesidades, puede crear sus propias clases de excepciones derivadas de la clase <ph id="ph2">@System.Exception</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>When creating your own exceptions, end the class name of the user-defined exception with the word "Exception," and implement the three common constructors, as shown in the following example.</source>
          <target state="translated">Al crear sus propias excepciones, termine el nombre de clase de la excepción definida por el usuario con la palabra "Exception" e implemente los tres constructores comunes, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The example defines a new exception class named <ph id="ph1">`EmployeeListNotFoundException`</ph>.</source>
          <target state="translated">En el ejemplo se define una nueva clase de excepción denominada <ph id="ph1">`EmployeeListNotFoundException`</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The class is derived from <ph id="ph1">@System.Exception</ph> and includes three constructors.</source>
          <target state="translated">La clase se deriva de <ph id="ph1">@System.Exception</ph> e incluye tres constructores.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In situations where you are using remoting, you must ensure that the metadata for any user-defined exceptions is available at the server (callee) and to the client (the proxy object or caller).</source>
          <target state="translated">En situaciones en que use la comunicación remota, debe asegurarse de que los metadatos de todas las excepciones definidas por el usuario estén disponibles en el servidor (destinatario) y en el cliente (el objeto proxy o autor de la llamada).</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Best practices for exceptions<ept id="p1">](#best-practices-for-exceptions)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Procedimientos recomendados para excepciones<ept id="p1">](#best-practices-for-exceptions)</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Best practices for exceptions</source>
          <target state="translated">Procedimientos recomendados para excepciones</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>A well-designed app handles exceptions and errors to prevent app crashes.</source>
          <target state="translated">Una aplicación diseñada correctamente controla las excepciones y los errores para evitar que se bloquee.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This section describes best practices for handling and creating exceptions.</source>
          <target state="translated">En este artículo se describen los procedimientos recomendados para controlar y crear excepciones.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Use try/catch/finally blocks</source>
          <target state="translated">Uso de bloques Try/Catch/Finally</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph><ph id="ph4">/</ph><ph id="ph5">`finally`</ph> blocks around code that can potentially generate an exception.</source>
          <target state="translated">Use bloques de código <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph><ph id="ph4">/</ph><ph id="ph5">`finally`</ph> que podría generar una excepción.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`catch`</ph> blocks, always order exceptions from the most specific to the least specific.</source>
          <target state="translated">Ordene siempre las excepciones de los bloques <ph id="ph1">`catch`</ph> de la más específica a la menos.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Use a <ph id="ph1">`finally`</ph> block to clean up resources, whether you can recover or not.</source>
          <target state="translated">Use un bloque <ph id="ph1">`finally`</ph> para limpiar los recursos, tanto si puede recuperarlos como si no.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Handle common conditions without throwing exceptions</source>
          <target state="translated">Administrar condiciones comunes sin iniciar excepciones</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For conditions that are likely to occur but might trigger an exception, consider handling them in a way that will avoid the exception.</source>
          <target state="translated">Para las condiciones con probabilidad de producirse, pero que podrían desencadenar una excepción, considere la posibilidad de controlarlas de forma que se evite la excepción.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For example, if you try to close a connection that is already closed, you'll get an <ph id="ph1">`InvalidOperationException`</ph>.</source>
          <target state="translated">Por ejemplo, si intenta se cerrar una conexión que ya está cerrada, obtendrá <ph id="ph1">`InvalidOperationException`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>You can avoid that by using an <ph id="ph1">`if`</ph> statement to check the connection state before trying to close it.</source>
          <target state="translated">Se puede evitar mediante una instrucción <ph id="ph1">`if`</ph> para comprobar el estado de conexión antes de intentar cerrarla.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>If you don't check connection state before closing, you can catch the <ph id="ph1">`InvalidOperationException`</ph> exception.</source>
          <target state="translated">Si no comprueba el estado de la conexión antes de cerrar, se puede detectar la excepción <ph id="ph1">`InvalidOperationException`</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The method to choose depends on how often you expect the event to occur.</source>
          <target state="translated">El método que se elija depende de la frecuencia con la que espera que se produzca el evento.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Use exception handling if the event doesn't occur very often, that is, if the event is truly exceptional and indicates an error (such as an unexpected end-of-file).</source>
          <target state="translated">Utilice el control de excepciones si el evento no se produce con frecuencia, es decir, si el evento es muy excepcional e indica un error (como un final de archivo inesperado).</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>When you use exception handling, less code is executed in normal conditions.</source>
          <target state="translated">Cuando se usa el control de excepciones, se ejecuta menos código en condiciones normales.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Check for error conditions in code if the event happens routinely and could be considered part of normal execution.</source>
          <target state="translated">Compruebe condiciones de error en el código cuando el evento se produce con frecuencia y se puede considerar como parte de la ejecución normal.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>When you check for common error conditions, less code is executed because you avoid exceptions.</source>
          <target state="translated">Cuando se buscan condiciones de error comunes, se ejecuta menos código porque se evitan excepciones.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Design classes so that exceptions can be avoided</source>
          <target state="translated">Diseñar clases para que se puedan evitar excepciones</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>A class can provide methods or properties that enable you to avoid making a call that would trigger an exception.</source>
          <target state="translated">Una clase puede proporcionar métodos o propiedades que permiten evitar realizar una llamada que desencadenaría una excepción.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>For example, a <ph id="ph1">@System.IO.FileStream</ph> class provides methods that help determine whether the end of the file has been reached.</source>
          <target state="translated">Por ejemplo, una clase <ph id="ph1">@System.IO.FileStream</ph> proporciona métodos que ayudan a determinar si se ha alcanzado el final del archivo.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>These can be used to avoid the exception that is thrown if you read past the end of the file.</source>
          <target state="translated">Esto se puede usar para evitar la excepción que se inicia si se lee más allá del final del archivo.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The following example shows how to read to the end of a file without triggering an exception.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo leer hasta el final de un archivo sin desencadenar una excepción.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Another way to avoid exceptions is to return null for extremely common error cases instead of throwing an exception.</source>
          <target state="translated">Otro modo de evitar excepciones es devolver NULL para los casos de errores muy frecuentes en lugar de iniciar una excepción.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>An extremely common error case can be considered normal flow of control.</source>
          <target state="translated">Un caso de error muy común se puede considerar como un flujo de control normal.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>By returning null in these cases, you minimize the performance impact to an app.</source>
          <target state="translated">Al devolver un valor null en estos casos, se minimiza el impacto en el rendimiento de una aplicación.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Throw exceptions instead of returning an error code</source>
          <target state="translated">Iniciar excepciones en lugar de devolver un código de error</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Exceptions ensure that failures do not go unnoticed because calling code didn't check a return code.</source>
          <target state="translated">Las excepciones garantizan que los errores no pasen desapercibidos porque la llamada al código no compruebe un código de retorno.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Use the predefined .NET exception types</source>
          <target state="translated">Uso de los tipos de excepción predefinidos de .NET</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Introduce a new exception class only when a predefined one doesn't apply.</source>
          <target state="translated">Solo se deben introducir nuevas clases de excepción si no se puede aplicar ningún tipo predefinido.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Throw an <ph id="ph1">@System.InvalidOperationException</ph> exception if a property set or method call is not appropriate given the object's current state.</source>
          <target state="translated">Inicie una excepción <ph id="ph1">@System.InvalidOperationException</ph> si un conjunto de propiedades o una llamada a un método no resultan apropiados de acuerdo con el estado actual del objeto.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Throw an <ph id="ph1">@System.ArgumentException</ph> exception or one of the predefined classes that derive from <ph id="ph2">@System.ArgumentException</ph> if invalid parameters are passed.</source>
          <target state="translated">Inicie una excepción <ph id="ph1">@System.ArgumentException</ph> o una de las clases predefinidas que derivan de <ph id="ph2">@System.ArgumentException</ph> si se pasan parámetros no válidos.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>End exception class names with the word <ph id="ph1">`Exception`</ph></source>
          <target state="translated">Termine los nombres de clases de excepción con la palabra <ph id="ph1">`Exception`</ph></target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>When a custom exception is necessary, name it appropriately and derive it from the <ph id="ph1">@System.Exception</ph> class.</source>
          <target state="translated">Cuando se necesite una excepción personalizada, debe ponerse el nombre apropiado y derivarla de la clase <ph id="ph1">@System.Exception</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Include three constructors in custom exception classes</source>
          <target state="translated">Incluir tres constructores en las clases de excepciones personalizadas</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Use at least the three common constructors when creating your own exception classes: the default constructor, a constructor that takes a string message, and a constructor that takes a string message and an inner exception.</source>
          <target state="translated">Use al menos tres constructores comunes al crear sus propias clases de excepción: el constructor predeterminado, un constructor que tome un mensaje de cadena y un constructor que tome un mensaje de cadena y una excepción interna.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Exception.%23ctor,</ph> which uses default values.</source>
          <target state="translated"><ph id="ph1">@System.Exception.%23ctor,</ph>, que utiliza valores predeterminados.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Exception.%23ctor(System.String),</ph> which accepts a string message.</source>
          <target state="translated"><ph id="ph1">@System.Exception.%23ctor(System.String),</ph>, que acepta un mensaje de cadena.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Exception.%23ctor(System.String,System.Exception),</ph> which accepts a string message and an inner exception.</source>
          <target state="translated"><ph id="ph1">@System.Exception.%23ctor(System.String,System.Exception),</ph>, que acepta un mensaje de cadena y una excepción interna.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>For an example, see <bpt id="p1">[</bpt>How to: Create User-Defined Exceptions<ept id="p1">](#how-to-create-user-defined-exceptions)</ept>.</source>
          <target state="translated">Por ejemplo, consulte <bpt id="p1">[</bpt>Cómo: Crear excepciones definidas por el usuario<ept id="p1">](#how-to-create-user-defined-exceptions)</ept>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Ensure that exception data is available when code executes remotely</source>
          <target state="translated">Asegúrese de que los datos de excepción estén disponibles cuando el código se ejecute de forma remota</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>When you create user-defined exceptions, ensure that the metadata for the exceptions is available to code that is executing remotely.</source>
          <target state="translated">Cuando cree excepciones definidas por el usuario, debe garantizar que los metadatos de las excepciones están disponibles para el código que se ejecute de forma remota.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example, on .NET runtimes that implement App Domains, exceptions may occur across App domains.</source>
          <target state="translated">Por ejemplo, en runtimes de .NET que implementan los dominios de aplicación, pueden producirse excepciones entre dominios de aplicación.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Suppose App Domain A creates App Domain B, which executes code that throws an exception.</source>
          <target state="translated">Por ejemplo, supongamos que el dominio de aplicación A crea el dominio de aplicación B, que ejecuta código que inicia una excepción.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>For App Domain A to properly catch and handle the exception, it must be able to find the assembly that contains the exception thrown by App Domain B. If App Domain B throws an exception that is contained in an assembly under its application base, but not under App Domain A's application base, App Domain A will not be able to find the exception, and the common language runtime will throw a <ph id="ph1">@System.IO.FileNotFoundException</ph> exception.</source>
          <target state="translated">Para que el dominio de aplicación A detecte y controle la excepción correctamente, debe poder encontrar el ensamblado que contiene la excepción iniciada por el dominio de aplicación B. Si el dominio de aplicación B inicia una excepción contenida en un ensamblado en su base de aplicación pero no en la base de aplicación del dominio de aplicación A, el dominio de aplicación A no podrá encontrar la excepción y common language runtime iniciará una excepción de <ph id="ph1">@System.IO.FileNotFoundException</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>To avoid this situation, you can deploy the assembly that contains the exception information in two ways:</source>
          <target state="translated">Para evitar esta situación, puede implementar el ensamblado que contiene la información de la excepción de dos maneras:</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Put the assembly into a common application base shared by both app domains.</source>
          <target state="translated">Ponga el ensamblado en una base de aplicación compartida por los dos dominios de aplicación.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> o -</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>If the domains do not share a common application base, sign the assembly that contains the exception information with a strong name and deploy the assembly into the global assembly cache.</source>
          <target state="translated">Si los dominios no comparten una base de aplicación común, firme el ensamblado que contiene la información de la excepción con un nombre seguro e impleméntelo en la caché global de ensamblados.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Include a localized description string in every exception</source>
          <target state="translated">Incluir una cadena descriptiva localizada en todas las excepciones</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The error message that the user sees is derived from the description string of the exception that was thrown, and not from the name of the exception class.</source>
          <target state="translated">El mensaje de error que ve el usuario deriva de la cadena descriptiva de la excepción que se inició y no del nombre de la clase de excepción.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Use grammatically correct error messages</source>
          <target state="translated">Usar mensajes de error gramaticalmente correctos</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Write clear sentences and include ending punctuation.</source>
          <target state="translated">Escriba frases claras e incluya puntuación final.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Each sentence in a description string of an exception should end in a period.</source>
          <target state="translated">Cara oración de una cadena descriptiva de una excepción debe acabar con un punto.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>For example, "The log table has overflowed.”</source>
          <target state="translated">Por ejemplo, "la tabla del registro se ha desbordado."</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>would be an appropriate description string.</source>
          <target state="translated">sería una cadena de descripción adecuada.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>In custom exceptions, provide additional properties as needed</source>
          <target state="translated">En excepciones personalizadas, proporcione propiedades adicionales según sea necesario</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Provide additional properties for an exception (in addition to the description string) only when there's a programmatic scenario where the additional information is useful.</source>
          <target state="translated">Únicamente proporcione información adicional para una excepción (además de la cadena descriptiva) si hay un escenario de programación en que dicha información sea útil.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">@System.IO.FileNotFoundException</ph> provides the <ph id="ph2">@System.IO.FileNotFoundException.FileName</ph> property.</source>
          <target state="translated">Por ejemplo, <ph id="ph1">@System.IO.FileNotFoundException</ph> proporciona la propiedad <ph id="ph2">@System.IO.FileNotFoundException.FileName</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Place throw statements so that the stack trace will be helpful</source>
          <target state="translated">Colocar instrucciones de iniciación para que el seguimiento de la pila sea útil</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The stack trace begins at the statement where the exception is thrown and ends at the <ph id="ph1">`catch`</ph> statement that catches the exception.</source>
          <target state="translated">El seguimiento de pila comienza en la instrucción en que se produce la excepción y termina en la instrucción <ph id="ph1">`catch`</ph> que detecta la excepción.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Use exception builder methods</source>
          <target state="translated">Usar métodos de generador de excepciones</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>It is common for a class to throw the same exception from different places in its implementation.</source>
          <target state="translated">Es habitual que una clase produzca la misma excepción desde distintos lugares de su implementación.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>To avoid excessive code, use helper methods that create the exception and return it.</source>
          <target state="translated">Para evitar el exceso de código, use métodos auxiliares que creen la excepción y la devuelvan.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In some cases, it's more appropriate to use the exception's constructor to build the exception.</source>
          <target state="translated">En algunos casos, es más apropiado usar el constructor de excepciones para generar la excepción.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>An example is a global exception class such as <ph id="ph1">@System.ArgumentException,</ph></source>
          <target state="translated">Un ejemplo es una clase de excepción global, como <ph id="ph1">@System.ArgumentException,</ph></target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Clean up intermediate results when throwing an exception</source>
          <target state="translated">Eliminar los resultados intermedios cuando se inicie una excepción</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Callers should be able to assume that there are no side effects when an exception is thrown from a method.</source>
          <target state="translated">Los autores de llamadas deben poder asumir que no se producen efectos no deseados cuando se produce una excepción desde un método.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>For example, if you have code that transfers money by withdrawing from one account and depositing in another account, and an exception is thrown while executing the deposit, you don't want the withdrawal to remain in effect.</source>
          <target state="translated">Por ejemplo, si tiene código que transfiere dinero mediante la retirada de una cuenta y el depósito en otra, y se inicia una excepción mientras se ejecuta el depósito, no quiere que la retirada siga siendo efectiva.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>One way to handle this situation is to catch any exceptions thrown by the deposit transaction and roll back the withdrawal.</source>
          <target state="translated">Para controlar esta situación se puede detectar cualquier excepción iniciada por la transacción del depósito y revertir la retirada.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>This example illustrates the use of <ph id="ph1">`throw`</ph> to re-throw the original exception, which can make it easier for callers to see the real cause of the problem without having to examine the <ph id="ph2">@System.Exception.InnerException</ph> property.</source>
          <target state="translated">Este ejemplo muestra el uso de <ph id="ph1">`throw`</ph> para volver a iniciar la excepción original, que puede facilitar a los autores de llamada ver la causa del problema real sin tener que examinar la propiedad <ph id="ph2">@System.Exception.InnerException</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>An alternative is to throw a new exception and include the original exception as the inner exception:</source>
          <target state="translated">Como alternativa se puede iniciar una nueva excepción e incluir la excepción original como excepción interna:</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vea también</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>To learn more about how exceptions work in .NET, see <bpt id="p1">[</bpt>What Every Dev needs to Know About Exceptions in the Runtime<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/exceptions.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de cómo funcionan las excepciones en. NET, consulte <bpt id="p1">[</bpt>Qué deben saber los desarrolladores sobre las excepciones en runtime<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/exceptions.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>