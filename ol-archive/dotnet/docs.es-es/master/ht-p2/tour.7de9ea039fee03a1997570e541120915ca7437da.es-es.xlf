<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02e2fa22e36fd2f6618527ad3c89cbbd8587dfe2</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\tour.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b5d2ad1e76f36733598999f425a89b00a11b9cd</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">486574494fd69fdc2cf6ac253f6e6e902ee27923</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Tour of .NET</source>
          <target state="translated">Paseo por .NET</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>A guided tour through some of the prominent features of the .NET platform.</source>
          <target state="translated">Una visita guiada a través de algunas de las características más importantes de la plataforma. NET.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, Tour, Programming Languages, Unsafe, Memory Management, Type Safety, Async</source>
          <target state="translated">.NET, .NET Core, Paseo, Lenguajes de programación, Unsafe, Administración de memoria, Seguridad de tipos, Asincrónico</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Tour of .NET</source>
          <target state="translated">Paseo por .NET</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>.NET is a general purpose development platform.</source>
          <target state="translated">.NET es una plataforma de desarrollo de uso general.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It has several key features, such as multiple programming languages, asynchronous and concurrent programming models, and native interoperability which enable a wide range of scenarios across multiple platforms.</source>
          <target state="translated">Tiene varias características importantes, como varios lenguajes de programación, modelos de programación asincrónica y simultánea e interoperabilidad nativa que permite una amplia variedad de escenarios en diversas plataformas.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This article offers a guided tour through some of the key features of the .NET platform.</source>
          <target state="translated">Este artículo ofrece un paseo guiado por algunas de las características clave de la plataforma. NET.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>.NET Architectural Components<ept id="p1">](components.md)</ept> to learn about each of the architectural "pieces" of .NET and what they're used for.</source>
          <target state="translated">Consulte <bpt id="p1">[</bpt>Componentes de la arquitectura .NET<ept id="p1">](components.md)</ept> para más información sobre cada una de las "piezas" de arquitectura .NET y para qué se usan.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>How to run the code samples</source>
          <target state="translated">Ejecución de ejemplos de código</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To learn how to set up a development environment to run the code samples, check out <bpt id="p1">[</bpt>Getting Started<ept id="p1">](getting-started.md)</ept>.</source>
          <target state="translated">Para más información sobre cómo configurar un entorno de desarrollo para ejecutar los ejemplos de código, consulte <bpt id="p1">[</bpt>Introducción<ept id="p1">](getting-started.md)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can copy and paste code samples from this page into your environment to execute them.</source>
          <target state="translated">Puede copiar y pegar ejemplos de código de esta página para ejecutarlos en su entorno.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In the future, this documentation site will have the ability to run these code samples in your browser.</source>
          <target state="translated">En el futuro, este sitio de documentación tendrá la posibilidad de ejecutar estos ejemplos de código en el explorador.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Programming languages</source>
          <target state="translated">Lenguajes de programación</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>.NET supports multiple programming languages.</source>
          <target state="translated">.NET admite varios lenguajes de programación.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>.NET runtimes implement the <bpt id="p1">[</bpt>Common Language Infrastructure (CLI)<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>, which (among other things) specifies a language-independent runtime and language interoperability.</source>
          <target state="translated">Los entornos de tiempo de ejecución .NET implementan <bpt id="p1">[</bpt>Common Language Infrastructure (CLI)<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>, que, entre otras cosas, especifica un entorno de tiempo de ejecución independiente del lenguaje y la interoperabilidad del lenguaje.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This means that you can choose any .NET language to build apps and services on .NET.</source>
          <target state="translated">Esto significa que puede elegir cualquier lenguaje .NET para crear aplicaciones y servicios en. NET.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic .NET.</source>
          <target state="translated">Microsoft desarrolla activamente y admite tres lenguajes. NET: C#, F # y Visual Basic. NET.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages.</source>
          <target state="translated">C# es simple, eficaz, incluye seguridad de tipos y está orientado a objetos, al mismo tiempo que mantiene la expresividad y elegancia de los lenguajes de estilo C.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Anyone familiar with C and similar languages will find few problems in adapting to C#.</source>
          <target state="translated">Cualquiera que esté familiarizado con C y lenguajes similares, encontrará pocos problemas para adaptarse a C#.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>C# Guide<ept id="p1">](../csharp/index.md)</ept> to learn more about C#.</source>
          <target state="translated">Consulte la <bpt id="p1">[</bpt>Guía de C#<ept id="p1">](../csharp/index.md)</ept> para más información sobre C#.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</source>
          <target state="translated">F # es un lenguaje de programación multiplataforma, principalmente funcional, que también admite la programación tradicional imperativa y orientada en objetos.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>F# Guide<ept id="p1">](../fsharp/index.md)</ept> to learn more about F#.</source>
          <target state="translated">Consulte la <bpt id="p1">[</bpt>Guía de F #<ept id="p1">](../fsharp/index.md)</ept> para más información sobre F #.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.</source>
          <target state="translated">Visual Basic es un lenguaje fácil de aprender que puede usar para crear una gran variedad de aplicaciones que se ejecutan en .NET Framework.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Automatic memory management</source>
          <target state="translated">Administración de memoria automática</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>.NET uses <bpt id="p1">[</bpt>garbage collection<ept id="p1">](garbagecollection/index.md)</ept> to provide automatic memory management for programs.</source>
          <target state="translated">.NET utiliza <bpt id="p1">[</bpt>recolección de elementos no utilizados<ept id="p1">](garbagecollection/index.md)</ept> para proporcionar administración automática de memoria para los programas.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.</source>
          <target state="translated">El GC opera con un enfoque diferido para la administración de memoria y prefiere el rendimiento de la aplicación sobre la recolección inmediata de la memoria.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To learn more about the .NET GC, check out <bpt id="p1">[</bpt>Fundamentals of garbage collection (GC)<ept id="p1">](garbagecollection/fundamentals.md)</ept>.</source>
          <target state="translated">Para más información sobre GC de .NET, consulte <bpt id="p1">[</bpt>Fundamentals of garbage collection (GC)<ept id="p1">](garbagecollection/fundamentals.md)</ept> (Fundamentos de la recolección de elementos no utilizados [GC]).</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following two lines both allocate memory:</source>
          <target state="translated">Las dos líneas siguientes asignan memoria:</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>There is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</source>
          <target state="translated">No hay ninguna palabra clave análoga para anular la asignación de memoria, ya que la anulación de la asignación se realiza automáticamente cuando el recolector de elementos no utilizados reclama la memoria a través de su ejecución programada.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Types within a given scope normally go out of scope once a method completes, at which point they can be collected.</source>
          <target state="translated">Los tipos dentro de un ámbito dado quedan normalmente fuera de ámbito cuando se completa un método, momento en el cual pueden recopilarse.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the <ph id="ph1">`using`</ph> statement:</source>
          <target state="translated">Sin embargo, puede indicar al GC que un objeto determinado esté fuera de ámbito en cuanto el método se cierre mediante la instrucción <ph id="ph1">`using`</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L6-L9)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L6-L9)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Once the <ph id="ph1">`using`</ph> block completes, the GC will know that the <ph id="ph2">`stream`</ph> object in the previous example is free to be collected and its memory reclaimed.</source>
          <target state="translated">Una vez que se complete el bloque de <ph id="ph1">`using`</ph>, el GC sabrá que el objeto <ph id="ph2">`stream`</ph> en el ejemplo anterior ya se puede recopilar y reclamar su memoria.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Rules for this have slightly different semantics in F#.</source>
          <target state="translated">Reglas para esto tienen una semántica ligeramente diferente en F#.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>To learn more about resource management in F#, check out <bpt id="p1">[</bpt>Resource Management: The <ph id="ph1">`use`</ph> Keyword<ept id="p1">](../fsharp/language-reference/resource-management-the-use-keyword.md)</ept></source>
          <target state="translated">Para más información sobre la administración de recursos en F #, consulte el artículo sobre la <bpt id="p1">[</bpt>administración de recursos y la palabra clave <ph id="ph1">`use`</ph> <ept id="p1">](../fsharp/language-reference/resource-management-the-use-keyword.md)</ept>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>One of the less obvious but quite far-reaching features that a garbage collector enables is memory safety.</source>
          <target state="translated">La protección de la memoria es una de las características menos obvias, pero con un alcance bastante grande, que es posible gracias a un recolector de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).</source>
          <target state="translated">El valor invariable de protección de la memoria es muy simple: un programa tiene protección de la memoria si solo tiene acceso a la memoria que se ha asignado (y no liberado).</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Dangling pointers are always bugs, and tracking them down is often quite difficult.</source>
          <target state="translated">Los punteros pendientes siempre suponen errores y localizarlos suele ser bastante difícil.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The .NET runtime provides additional services, to complete the promise of memory safety, not naturally offered by a GC.</source>
          <target state="translated">El runtime de .NET proporciona servicios adicionales para completar la promesa de protección de la memoria, que no ofrece de forma natural un GC.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>It ensures that programs do not index off the end of an array or accessing a phantom field off the end of an object.</source>
          <target state="translated">Garantiza que los programas no indicen el final de una matriz ni tengan acceso a un campo fantasma al final de un objeto.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following example will throw an exception as a result of memory safety.</source>
          <target state="translated">En el ejemplo siguiente, se iniciará una excepción como resultado de la protección de la memoria.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L11-L12)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L11-L12)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Type safety</source>
          <target state="translated">Seguridad de tipos</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Objects are allocated in terms of types.</source>
          <target state="translated">Los objetos se asignan en términos de tipos.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The only operations allowed for a given object, and the memory it consumes, are those of its type.</source>
          <target state="translated">Las únicas operaciones permitidas para un objeto determinado, y la memoria que consume, son los de su tipo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dog`</ph> type may have <ph id="ph2">`Jump`</ph> and <ph id="ph3">`WagTail`</ph> methods, but not likely a <ph id="ph4">`SumTotal`</ph> method.</source>
          <target state="translated">Un tipo <ph id="ph1">`Dog`</ph> puede tener métodos <ph id="ph2">`Jump`</ph> y <ph id="ph3">`WagTail`</ph>, pero no es probable que tenga un método <ph id="ph4">`SumTotal`</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A program can only call the declared methods of a given type.</source>
          <target state="translated">Un programa solo puede llamar a los métodos declarados de un tipo determinado.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or <ph id="ph1">`object`</ph>).</source>
          <target state="translated">Todas las demás llamadas producirán un error en tiempo de compilación o una excepción en tiempo de ejecución (en el caso de usar características dinámicas o <ph id="ph1">`object`</ph>).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>.NET languages are object-oriented, with hierarchies of base and derived classes.</source>
          <target state="translated">Los lenguajes .NET están orientados a objetos, con las jerarquías de clases base y derivadas.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The .NET runtime will only allow object casts and calls that align with the object hierarchy.</source>
          <target state="translated">El runtime de .NET solo permitirá llamadas y conversaciones de objetos que se alineen con la jerarquía de objetos.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Remember that every type defined in any .NET language derives from the base <ph id="ph1">`object`</ph> type.</source>
          <target state="translated">Recuerde que cada tipo definido en cualquier lenguaje .NET se deriva del tipo <ph id="ph1">`object`</ph> base.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</source>
          <target state="translated">La seguridad de tipos también se usa para ayudar a aplicar la encapsulación a través de la garantía de la fidelidad de las palabras clave del descriptor de acceso.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Accessor keywords are artifacts which control access to members of a given type by other code.</source>
          <target state="translated">Las palabras clave del descriptor de acceso son artefactos que controlan el acceso a los miembros de un tipo determinado a través de otro código.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>These are usually used for various kinds of data within a type that are used to manage its behavior.</source>
          <target state="translated">Normalmente se usan para distintos tipos de datos dentro de un tipo, que se usan para administrar su comportamiento.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>C#, Visual Basic, and F# support local <bpt id="p1">**</bpt>type inference<ept id="p1">**</ept>.</source>
          <target state="translated">C#, Visual Basic y F# admiten <bpt id="p1">**</bpt>inferencia de tipos<ept id="p1">**</ept> local.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side.</source>
          <target state="translated">La inferencia de tipos significa que el compilador deducirá el tipo de expresión en el lado izquierdo a partir de la expresión en el lado derecho.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This doesn't mean that the type safety is broken or avoided.</source>
          <target state="translated">Esto no significa que la seguridad de tipos se divida o evite.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The resulting type <bpt id="p1">**</bpt>has<ept id="p1">**</ept> a strong type with everything that implies.</source>
          <target state="translated">El tipo resultante <bpt id="p1">**</bpt>tiene<ept id="p1">**</ept> un tipo seguro con todo lo que ello implica.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Let's rewrite the first two lines of the previous example to introduce type inference.</source>
          <target state="translated">Reescribamos las dos primeras líneas del ejemplo anterior para introducir la inferencia de tipos.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Note that the rest of the example is completely the same.</source>
          <target state="translated">Observe que el resto del ejemplo es completamente lo mismo.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>F# has even further type inference capabilities than method-local type inference found in C# and Visual Basic.</source>
          <target state="translated">F# tiene incluso más funcionalidades de inferencia de tipos que la inferencia de tipos method-local encontrada en C# y Visual Basic.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>To learn more, check out <bpt id="p1">[</bpt>Type Inference<ept id="p1">](../fsharp/language-reference/type-inference.md)</ept>.</source>
          <target state="translated">Para más información, consulte <bpt id="p1">[</bpt>Type Inference<ept id="p1">](../fsharp/language-reference/type-inference.md)</ept> (Inferencia de tipos).</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">Delegados y expresiones lambda</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Delegates are like C++ function pointers, with a big difference that they are type safe.</source>
          <target state="translated">Los delegados son como los punteros de función de C++, con la gran diferencia de que tienen seguridad de tipos.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>They are a kind of disconnected method within the CLR type system.</source>
          <target state="translated">Son un tipo de método sin conexión en el sistema de tipos de CLR.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Regular methods are attached to a class and only directly callable through static or instance calling conventions.</source>
          <target state="translated">Los métodos regulares están conectados a una clase y solo se pueden llamar a través de convenciones de llamadas estáticas o de instancias.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Delegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.</source>
          <target state="translated">Los delegados se usan en varias API y lugares en el mundo .NET, especialmente a través de expresiones lambda, que son los pilares de LINQ.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept> document.</source>
          <target state="translated">Obtenga más información al respecto en el documento <bpt id="p1">[</bpt>Delegados y expresiones lambda<ept id="p1">](delegates-lambdas.md)</ept>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Genéricos</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Generics are a feature that was added in .NET Framework 2.0.</source>
          <target state="translated">Los genéricos son una característica que se agregó en .NET Framework 2.0.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In short, generics allow the programmer to introduce a "type parameter" when designing their classes, that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</source>
          <target state="translated">En resumen, los genéricos permiten al programador introducir un "parámetro de tipo" al diseñar sus clases, que permite al código de cliente (los usuarios del tipo) especificar el tipo exacto que se debe usar en lugar del parámetro de tipo.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Generics were added to help programmers implement generic data structures.</source>
          <target state="translated">Los genéricos se agregaron para ayudar a los programadores a implementar estructuras de datos genéricos.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Before their arrival, in order for a, say, <ph id="ph1">`List`</ph> type to be generic, it would have to work with elements that were of type <ph id="ph2">`object`</ph>.</source>
          <target state="translated">Antes de su llegada, para que un tipo <ph id="ph1">`List`</ph> fuese genérico, por ejemplo, habría que trabajar con elementos que fuesen de tipo <ph id="ph2">`object`</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This would have various performance as well as semantic problems, not to mention possible subtle runtime errors.</source>
          <target state="translated">Esto tendría diferentes problemas de rendimiento, así como semánticos, además de los posibles errores sutiles de tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <ph id="ph1">`InvalidCastException`</ph> is thrown on working with the list's members.</source>
          <target state="translated">Lo más destacado de esto último se produciría cuando una estructura de datos contiene, por ejemplo, enteros y cadenas, y se inicia la excepción <ph id="ph1">`InvalidCastException`</ph> al trabajar con los miembros de la lista.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following sample shows a basic program running using an instance of <ph id="ph1">@System.Collections.Generic.List%601</ph> types.</source>
          <target state="translated">El siguiente ejemplo muestra un ejecución de programa básico mediante una instancia de tipos <ph id="ph1">@System.Collections.Generic.List%601</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GenericsShort<ept id="p2">](../../samples/csharp/snippets/tour/GenericsShort.csx)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GenericsShort<ept id="p2">](../../samples/csharp/snippets/tour/GenericsShort.csx)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept> article.</source>
          <target state="translated">Para obtener más información, consulte el artículo <bpt id="p1">[</bpt>Información general (genéricos) de tipos genéricos<ept id="p1">](generics.md)</ept>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Async programming</source>
          <target state="translated">Programación asincrónica</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Async programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs.</source>
          <target state="translated">La programación asincrónica es un concepto de primera clase en .NET, con compatibilidad asincrónica en el tiempo de ejecución, las bibliotecas de Framework y las construcciones de lenguaje .NET.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Internally, they are based off of objects (such as <ph id="ph1">`Task`</ph>) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</source>
          <target state="translated">Internamente, se basa en objetos (como <ph id="ph1">`Task`</ph>) que sacan partido del sistema operativo para realizar trabajos dependientes de E/s de la forma más eficaz posible.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To learn more about async programming in .NET, start with the <bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de la programación asincrónica en .NET, comience con la <bpt id="p1">[</bpt>Información general sobre la asincronía<ept id="p1">](async.md)</ept>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ)</source>
          <target state="translated">Language-Integrated Query (LINQ)</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</source>
          <target state="translated">LINQ es un conjunto eficaz de características para C# y VB que permiten escribir código simple y declarativo para operar en los datos.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!</source>
          <target state="translated">Los datos pueden estar en muchos formatos (como objetos en memoria, en una base de datos SQL o un documento XML), pero el código LINQ que escriba normalmente no aparecerá de forma diferente para cada origen de datos.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>To learn more and see some samples, check out <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</source>
          <target state="translated">Para obtener más información y ver algunos ejemplos, consulte <bpt id="p1">[</bpt>LINQ (Language-Integrated Query)<ept id="p1">](using-linq.md)</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">Interoperabilidad nativa</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Every operating system in current use provides a lot of platform support for various programming tasks.</source>
          <target state="translated">Cada sistema operativo actualmente en uso proporciona mucha compatibilidad de plataformas para varias tareas de programación.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>.NET provides several ways to tap into those APIs.</source>
          <target state="translated">.NET proporciona varias maneras de aprovechar dichas API.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Collectively, this support is called "native interoperability" and in this section we will take a look at how to access native APIs from managed, .NET code.</source>
          <target state="translated">En conjunto, esta compatibilidad se denomina "interoperabilidad nativa" y en esta sección explicaremos cómo tener acceso a las API nativas desde código administrado . NET.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The main way to do native interoperability is via "platform invoke" or P/Invoke for short.</source>
          <target state="translated">La principal manera de crear interoperabilidad nativa es a través de "invocación de plataforma" o P/Invoke para abreviar.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>This support in .NET Core is available across Linux and Windows platforms.</source>
          <target state="translated">Esta compatibilidad con .NET Core está disponible en plataformas Windows y Linux.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Another, Windows-only way of doing native interoperability is known as "COM interop" which is used to work with <bpt id="p1">[</bpt>COM components<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in managed code.</source>
          <target state="translated">Otra manera de crear interoperabilidad nativa exclusiva de Windows se conoce como "Interoperabilidad COM", que se usa para trabajar con <bpt id="p1">[</bpt>componentes COM<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> en código administrado.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>It is built on top of P/Invoke infrastructure, but it works in subtly different ways.</source>
          <target state="translated">Se basa en la infraestructura de P/Invoke, pero funciona de forma ligeramente diferente.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</source>
          <target state="translated">La mayoría de la compatibilidad de interoperabilidad de Mono (y, por tanto, de Xamarin) para Java y Objective-C se compila de forma similar, es decir, usan los mismos principios.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept> document.</source>
          <target state="translated">Obtenga más información al respecto en el documento <bpt id="p1">[</bpt>Interoperabilidad nativa<ept id="p1">](native-interop.md)</ept>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Unsafe code</source>
          <target state="translated">Código no seguro</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The CLR enables the ability to access native memory and do pointer arithmetic via <ph id="ph1">`unsafe`</ph> code.</source>
          <target state="translated">El CLR permite la capacidad de tener acceso a la memoria nativa y realizar aritmética de punteros a través de código <ph id="ph1">`unsafe`</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>These operations are needed for certain algorithms and system interoperability.</source>
          <target state="translated">Estas operaciones son necesarias para determinados algoritmos y para la interoperabilidad del sistema.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm.</source>
          <target state="translated">Aunque es eficaz, se desaconseja el uso de código no seguro a menos que sea necesario para la interoperabilidad con las API del sistema o para implementar el algoritmo más eficaz.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety.</source>
          <target state="translated">Es posible que el código no seguro no se ejecute del mismo modo en entornos diferentes y que también pierda las ventajas de un recolector de elementos no utilizados y de la seguridad de tipos.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.</source>
          <target state="translated">Se recomienda limitar y centralizar el código no seguro lo máximo posible, y probar el código a conciencia.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The following example is a modified version of the <ph id="ph1">`ToString()`</ph> method from the <ph id="ph2">`StringBuilder`</ph> class.</source>
          <target state="translated">El ejemplo siguiente es una versión modificada del método <ph id="ph1">`ToString()`</ph> desde la clase <ph id="ph2">`StringBuilder`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>It illustrates how using <ph id="ph1">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:</source>
          <target state="translated">Ilustra cómo mediante el código <ph id="ph1">`unsafe`</ph> se puede implementar de forma eficiente un algoritmo desplazándose por los fragmentos de memoria directamente:</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Unsafe<ept id="p2">](../../samples/csharp/snippets/tour/Unsafe.csx)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Unsafe<ept id="p2">](../../samples/csharp/snippets/tour/Unsafe.csx)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">Pasos siguientes</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If you're interested in a tour of C# features, check out <bpt id="p1">[</bpt>Tour of C#<ept id="p1">](../csharp/tour-of-csharp/index.md)</ept>.</source>
          <target state="translated">Si está interesado en un paseo por las características de C#, consulte <bpt id="p1">[</bpt>Paseo por C#<ept id="p1">](../csharp/tour-of-csharp/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If you're interested in a tour of F# features, check out <bpt id="p1">[</bpt>Tour of F#<ept id="p1">](../fsharp/tour.md)</ept>.</source>
          <target state="translated">Si está interesado en un paseo por las características de F #, consulte <bpt id="p1">[</bpt>Paseo por F #<ept id="p1">](../fsharp/tour.md)</ept>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>If you want to get started with writing code of your own, check out <bpt id="p1">[</bpt>Getting Started<ept id="p1">](getting-started.md)</ept>.</source>
          <target state="translated">Si desea empezar a escribir su propio código, consulte <bpt id="p1">[</bpt>Introducción<ept id="p1">](getting-started.md)</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>To learn about important components of .NET, check out <bpt id="p1">[</bpt>.NET Architectural Components<ept id="p1">](components.md)</ept>.</source>
          <target state="translated">Para más información sobre los principales componentes de. NET, consulte <bpt id="p1">[</bpt>Componentes de la arquitectura .NET<ept id="p1">](components.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>