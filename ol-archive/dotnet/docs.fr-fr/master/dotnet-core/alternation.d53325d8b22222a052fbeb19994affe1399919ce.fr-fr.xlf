<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fa2a880e5bcc36354bd59d3dc032180c89984f1d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\alternation.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7ea1cf18c32a4315469a45805fc35de30ba6d032</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3d3448326504745578e19e66b9f54daab59c4a45</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Alternation constructs in regular expressions</source>
          <target state="translated">Constructions d’alternative dans les expressions régulières</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Alternation constructs in regular expressions</source>
          <target state="translated">Constructions d’alternative dans les expressions régulières</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Alternation constructs in regular expressions</source>
          <target state="translated">Constructions d’alternative dans les expressions régulières</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Alternation constructs modify a regular expression to enable either/or or conditional matching.</source>
          <target state="translated">Les constructions d'alternative modifient une expression régulière pour permettre la correspondance de type inclusif/exclusif ou conditionnelle.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>.NET supports three alternation constructs:</source>
          <target state="translated">.NET prend en charge trois constructions d’alternative :</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Pattern matching with <bpt id="p1">**</bpt><ph id="ph1">|</ph><ept id="p1">**</ept></source>
          <target state="translated">Critères spéciaux avec <bpt id="p1">**</bpt><ph id="ph1">|</ph><ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Conditional matching with <bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></source>
          <target state="translated">Correspondance conditionnelle avec <bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>oui<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>non<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Conditional matching based on a valid captured group</source>
          <target state="translated">Correspondance conditionnelle selon un groupe capturé valide</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Pattern matching with |</source>
          <target state="translated">Critères spéciaux avec |</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.</source>
          <target state="translated">Vous pouvez utiliser la barre verticale (|) pour mettre en correspondance un modèle d’une série, dans laquelle le caractère | sépare chaque modèle.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Like the positive character class, the | character can be used to match any one of a number of single characters.</source>
          <target state="translated">Tout comme la classe de caractères positive, le caractère | peut être utilisé pour mettre en correspondance n’importe quel nombre de caractères uniques.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The following example uses both a positive character class and either/or pattern matching with the | character to locate occurrences of the words "gray" or "grey" in a string.</source>
          <target state="translated">L’exemple suivant utilise une classe de caractères positive et des critères spéciaux de type inclusif/exclusif avec le caractère | pour trouver des occurrences des mots « gray » ou « grey » dans une chaîne.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>In this case, the | character produces a regular expression that is more verbose.</source>
          <target state="translated">Dans ce cas, le caractère | produit une expression régulière qui est plus détaillée.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The regular expression that uses the | character, <ph id="ph1">`\bgr(a|e)y\b,`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">L’expression régulière qui utilise le caractère |, <ph id="ph1">`\bgr(a|e)y\b,`</ph>, est interprétée comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">Commencer à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Match the characters "gr".</source>
          <target state="translated">Mettre en correspondance les caractères « gr ».</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>`(a</source>
          <target state="translated">`(a</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>e)`</source>
          <target state="translated">e)`</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Match either an "a" or an "e".</source>
          <target state="translated">Mettre en correspondance un « a » ou un « e ».</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Match a "y" on a word boundary.</source>
          <target state="translated">Mettre en correspondance un « y » à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The | character can also be used to perform an either/or match with multiple characters or subexpressions, which can include any combination of character literals and regular expression language elements.</source>
          <target state="translated">Le caractère | peut également être utilisé pour effectuer une correspondance de type inclusif/exclusif avec plusieurs caractères ou sous-expressions, qui peuvent inclure toute combinaison de caractère littéraux et éléments de langage d’expressions régulières.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>(The character class does not provide this functionality.) The following example uses the | character to extract either a U.S. Social Security Number (SSN), which is a 9-digit number with the format <bpt id="p1">*</bpt>ddd-dd-dddd<ept id="p1">*</ept>, or a U.S. Employer Identification Number (EIN), which is a 9-digit number with the format <bpt id="p2">*</bpt>dd-ddddddd<ept id="p2">*</ept>.</source>
          <target state="translated">(La classe de caractères ne fournit pas cette fonctionnalité.) L’exemple suivant utilise le caractère | pour extraire un numéro de sécurité sociale (SSN) américain, qui est un nombre de 9 chiffres au format <bpt id="p1">*</bpt>ddd-dd-dddd<ept id="p1">*</ept>, ou un numéro d’identification de l’employeur (EIN) américain, qui est un nombre de 9 chiffres au format <bpt id="p2">*</bpt>dd-ddddddd<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b(\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">L'expression régulière <ph id="ph1">`\b(\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b`</ph> est interprétée comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">Commencer à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>`(\d{2}-\d{7}</source>
          <target state="translated">`(\d{2}-\d{7}</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>;\d{3}-\d{2}-\d{4})`</source>
          <target state="translated">;\d{3}-\d{2}-\d{4})`</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Match either of the following: two decimal digits followed by a hyphen followed by seven decimal digits; or three decimal digits, a hyphen, two decimal digits, another hyphen, and four decimal digits.</source>
          <target state="translated">Mettre en correspondance l'un ou l'autre des éléments suivants : deux chiffres décimaux suivis d'un trait d'union suivi de sept chiffres décimaux, ou alors trois chiffres décimaux, un trait d'union, deux chiffres décimaux, un autre trait d'union et quatre chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Conditional matching with an expression</source>
          <target state="translated">Correspondance conditionnelle avec une expression</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.</source>
          <target state="translated">Cet élément de langage tente de mettre en correspondance un modèle parmi deux fournis selon qu'il parvient ou non à mettre en correspondance un modèle initial.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Its syntax is:</source>
          <target state="translated">Sa syntaxe est la suivante :</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>oui<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>non<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> is the initial pattern to match, <bpt id="p2">*</bpt>yes<ept id="p2">*</ept> is the pattern to match if expression is matched, and <bpt id="p3">*</bpt>no<ept id="p3">*</ept> is the optional pattern to match if <bpt id="p4">*</bpt>expression<ept id="p4">*</ept> is not matched.</source>
          <target state="translated">où <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> est le modèle initial à faire correspondre, <bpt id="p2">*</bpt>oui<ept id="p2">*</ept> est le modèle à faire correspondre si l’expression est mise en correspondance, et <bpt id="p3">*</bpt>no<ept id="p3">*</ept> est le modèle facultatif à faire correspondre si l’<bpt id="p4">*</bpt>expression<ept id="p4">*</ept> n’est pas mise en correspondance.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The regular expression engine treats <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> as a zero-width assertion; that is, the regular expression engine does not advance in the input stream after it evaluates <bpt id="p2">*</bpt>expression<ept id="p2">*</ept>.</source>
          <target state="translated">Le moteur d’expression régulière traite l’<bpt id="p1">*</bpt>expression<ept id="p1">*</ept> comme une assertion de largeur nulle ; c’est-à-dire que le moteur d’expression régulière n’avance pas dans le flux d’entrée après avoir évalué l’<bpt id="p2">*</bpt>expression<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Therefore, this construct is equivalent to the following:</source>
          <target state="translated">Par conséquent, cette construction est équivalente à la suivante :</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph2">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>oui<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph2">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>non<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a zero-width assertion construct.</source>
          <target state="translated">où <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> est une construction d’assertion de largeur nulle.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.) Because the regular expression engine interprets <bpt id="p2">*</bpt>expression<ept id="p2">*</ept> as an anchor (a zero-width assertion), <bpt id="p3">*</bpt>expression<ept id="p3">*</ept> must either be a zero-width assertion (for more information, see <bpt id="p4">[</bpt>Anchors in regular expressions<ept id="p4">](anchors.md)</ept>) or a subexpression that is also contained in <bpt id="p5">*</bpt>yes<ept id="p5">*</ept>.</source>
          <target state="translated">(Pour plus d’informations, consultez <bpt id="p1">[</bpt>Constructions de regroupement dans les expressions régulières<ept id="p1">](grouping.md)</ept>.) Étant donné que le moteur d’expression régulière interprète l’<bpt id="p2">*</bpt>expression<ept id="p2">*</ept> comme une ancre (assertion de largeur nulle), l’<bpt id="p3">*</bpt>expression<ept id="p3">*</ept> doit être soit une assertion de largeur nulle (pour plus d’informations, consultez <bpt id="p4">[</bpt>Ancres dans les expressions régulières<ept id="p4">](anchors.md)</ept>), soit une sous-expression qui est également contenue dans <bpt id="p5">*</bpt>oui<ept id="p5">*</ept>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Otherwise, the <bpt id="p1">*</bpt>yes<ept id="p1">*</ept> pattern cannot be matched.</source>
          <target state="translated">Sinon, aucune correspondance ne peut être établie avec le modèle <bpt id="p1">*</bpt>oui<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> is a named or numbered capturing group, the alternation construct is interpreted as a capture test; for more information, see the next section, <bpt id="p2">[</bpt>Conditional matching based on a valid captured group<ept id="p2">](#conditional-matching-based-on-a-valid-captured-group)</ept>.</source>
          <target state="translated">Si l’<bpt id="p1">*</bpt>expression<ept id="p1">*</ept> est un groupe de capture nommé ou numéroté, la construction d’alternative est interprétée comme un test de capture. Pour plus d’informations, consultez la section suivante, <bpt id="p2">[</bpt>Correspondance conditionnelle selon un groupe capturé valide<ept id="p2">](#conditional-matching-based-on-a-valid-captured-group)</ept>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>In other words, the regular expression engine does not attempt to match the captured substring, but instead tests for the presence or absence of the group.</source>
          <target state="translated">En d'autres termes, le moteur des expressions régulières ne tente pas de mettre en correspondance la sous-chaîne capturée, mais à la place teste la présence ou l'absence du groupe.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following example is a variation of the example that appears in the previous section.</source>
          <target state="translated">L’exemple suivant est une variante de l’exemple qui s’affiche dans la section précédente.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>It uses conditional matching to determine whether the first three characters after a word boundary are two digits followed by a hyphen.</source>
          <target state="translated">Il utilise la mise en correspondance conditionnelle pour déterminer si les trois premiers caractères après une limite de mot se composent de deux chiffres suivis d'un trait d'union.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>If they are, it attempts to match a U.S. Employer Identification Number (EIN).</source>
          <target state="translated">Si c'est le cas, il tente de mettre en correspondance un numéro d'identification de l'employeur (EIN) américain.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If not, it attempts to match a U.S. Social Security Number (SSN).</source>
          <target state="translated">Si ce n'est pas le cas, il tente de mettre en correspondance un numéro de sécurité sociale (SSN) américain.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(?(\d{2}-)\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\b(?(\d{2}-)\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b`</ph> est interprété comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">Commencer à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Determine whether the next three characters consist of two digits followed by a hyphen.</source>
          <target state="translated">Déterminer si les trois caractères suivants se composent de deux chiffres suivis d'un trait d'union.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If the previous pattern matches, match two digits followed by a hyphen followed by seven digits.</source>
          <target state="translated">Si le modèle précédent correspond, mettre en correspondance deux chiffres suivis d'un trait d'union suivi de sept chiffres.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If the previous pattern does not match, match three decimal digits, a hyphen, two decimal digits, another hyphen, and four decimal digits.</source>
          <target state="translated">Si le modèle ne correspond pas, faire correspondre trois chiffres décimaux, un trait d'union, deux chiffres décimaux, un autre trait d'union et quatre chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Match a word boundary.</source>
          <target state="translated">Mettre en correspondance la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Conditional matching based on a valid captured group</source>
          <target state="translated">Correspondance conditionnelle selon un groupe capturé valide</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.</source>
          <target state="translated">Cet élément de langage essaie de faire correspondre l'un de deux modèles selon qu'il peut correspondre à un groupe capturé spécifié.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Its syntax is:</source>
          <target state="translated">Sa syntaxe est la suivante :</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>nom<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>oui<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>non<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">ou</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>numéro<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>oui<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>non<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is the name and <bpt id="p2">*</bpt>number<ept id="p2">*</ept> is the number of a capturing group, <bpt id="p3">*</bpt>yes<ept id="p3">*</ept> is the expression to match if name or number has a match, and <bpt id="p4">*</bpt>no<ept id="p4">*</ept> is the optional expression to match if it does not.</source>
          <target state="translated">où <bpt id="p1">*</bpt>nom<ept id="p1">*</ept> est le nom et <bpt id="p2">*</bpt>numéro<ept id="p2">*</ept> est le numéro d’un groupe de capture, <bpt id="p3">*</bpt>oui<ept id="p3">*</ept> est l’expression à faire correspondre si nom ou nombre a une correspondance et <bpt id="p4">*</bpt>non<ept id="p4">*</ept> est l’expression facultative à faire correspondre dans le cas contraire.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>name<ept id="p1">*</ept> does not correspond to the name of a capturing group that is used in the regular expression pattern, the alternation construct is interpreted as an expression test, as explained in the previous section.</source>
          <target state="translated">Si <bpt id="p1">*</bpt>nom<ept id="p1">*</ept> ne correspond pas au nom d’un groupe de capture utilisé dans le modèle d’expression régulière, la construction d’alternative est interprétée comme un test d’expression, comme expliqué dans la section précédente.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Typically, this means that expression evaluates to <ph id="ph1">`false`</ph>.</source>
          <target state="translated">En général, cela signifie que l’expression prend la valeur <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`number`</ph> does not correspond to a numbered capturing group that is used in the regular expression pattern, the regular expression engine throws an <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept>.</source>
          <target state="translated">Si <ph id="ph1">`number`</ph> ne correspond pas à un groupe de capture numéroté utilisé dans le modèle d’expression régulière, le moteur d’expression régulière lève un <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The following example is a variation of the example that appears in the previous section.</source>
          <target state="translated">L’exemple suivant est une variante de l’exemple qui s’affiche dans la section précédente.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>It uses a capturing group named <ph id="ph1">`n2`</ph> that consists of two digits followed by a hyphen.</source>
          <target state="translated">Il utilise un groupe de capture nommé <ph id="ph1">`n2`</ph> qui se compose de deux chiffres suivis d'un trait d'union.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The alternation construct tests whether this capturing group has been matched in the input string.</source>
          <target state="translated">La construction d'alternative tests si ce groupe de capture a été mis en correspondance dans la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If it has, the alternation construct attempts to match the last seven digits of a nine-digit U.S. Employer Identification Number (EIN).</source>
          <target state="translated">Si c'est le cas, la construction alternative essaie de mettre en correspondance les sept derniers chiffres d'un numéro d'identification de l'employeur (EIN) américain.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If it has not, it attempts to match a nine-digit U.S. Social Security Number (SSN).</source>
          <target state="translated">Si ce n'est le cas, il essaie de faire correspondre un numéro de sécurité sociale (SSN) américain.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(?&lt;n2&gt;\d{2}-)*(?(n2)\d{7}|\d{3}-\d{2}-\d{4})\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\b(?&lt;n2&gt;\d{2}-)*(?(n2)\d{7}|\d{3}-\d{2}-\d{4})\b`</ph> est interprété comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">Commencer à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of two digits followed by a hyphen.</source>
          <target state="translated">Mettre en correspondance zéro ou une occurrence de deux chiffres suivis d'un trait d'union.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`n2`</ph>.</source>
          <target state="translated">Nommer ce groupe de capture <ph id="ph1">`n2`</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Test whether <ph id="ph1">`n2`</ph> was matched in the input string.</source>
          <target state="translated">Testez si <ph id="ph1">`n2`</ph> a été mis en correspondance dans la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`n2`</ph> was matched, match seven decimal digits.</source>
          <target state="translated">Si <ph id="ph1">`n2`</ph> a été mis en correspondance, faites correspondre sept chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>;\d{3}-\d{2}-\d{4}`</source>
          <target state="translated">;\d{3}-\d{2}-\d{4}`</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`n2`</ph> was not matched, match three decimal digits, a hyphen, two decimal digits, another hyphen, and four decimal digits.</source>
          <target state="translated">Si <ph id="ph1">`n2`</ph> ne correspondait pas, faites correspondre trois chiffres décimaux, un trait d'union, deux chiffres décimaux, un autre trait d'union et quatre chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Match a word boundary.</source>
          <target state="translated">Mettre en correspondance la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A variation of this example that uses a numbered group instead of a named group is shown in the following example.</source>
          <target state="translated">Une variation de cet exemple qui utilise un groupe numéroté au lieu d'un groupe nommé est illustrée dans l'exemple suivant.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Its regular expression pattern is <ph id="ph1">`\b(\d{2}-)*(?(1)\d{7}|\d{3}-\d{2}-\d{4})\b`</ph>.</source>
          <target state="translated">Son modèle d'expression régulière est <ph id="ph1">`\b(\d{2}-)*(?(1)\d{7}|\d{3}-\d{2}-\d{4})\b`</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Langage des expressions régulières - Aide-mémoire<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>