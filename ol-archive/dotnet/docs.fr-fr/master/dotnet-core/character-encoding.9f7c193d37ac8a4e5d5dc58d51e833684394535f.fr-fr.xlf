<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a8f42fa6a37f8de6f13186ea2ac17b2b2ced1601</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\character-encoding.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">729741797caea2fd0dad6a3beac21cc6e356b0d8</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b3b23336c2f6d3d51c94110149950c68c41b93a0</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Character encoding in .NET</source>
          <target state="translated">Encodage de caractères dans .NET</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Character encoding in .NET</source>
          <target state="translated">Encodage de caractères dans .NET</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Character encoding in .NET</source>
          <target state="translated">Encodage de caractères dans .NET</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Characters are abstract entities that can be represented in many different ways.</source>
          <target state="translated">Les caractères sont des entités abstraites qui peuvent être représentées de nombreuses façons différentes.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>A character encoding is a system that pairs each character in a supported character set with some value that represents that character.</source>
          <target state="translated">Un encodage de caractères est un système qui associe chaque caractère d'un jeu de caractères pris en charge à une valeur qui représente ce caractère.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, Morse code is a character encoding that pairs each character in the Roman alphabet with a pattern of dots and dashes that are suitable for transmission over telegraph lines.</source>
          <target state="translated">Par exemple, le code Morse est un encodage de caractères qui associe chaque caractère de l'alphabet latin à une séquence de points et de tirets qui conviennent pour la transmission sur des lignes télégraphiques.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A character encoding for computers pairs each character in a supported character set with a numeric value that represents that character.</source>
          <target state="translated">Un encodage de caractères pour les ordinateurs associe chaque caractère d'un jeu de caractères à une valeur numérique qui représente ce caractère.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A character encoding has two distinct components:</source>
          <target state="translated">Un encodage de caractères a deux composants distincts :</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>An encoder, which translates a sequence of characters into a sequence of numeric values (bytes).</source>
          <target state="translated">Un encodeur, qui convertit une séquence de caractères en une séquence de valeurs numériques (octets).</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>A decoder, which translates a sequence of bytes into a sequence of characters.</source>
          <target state="translated">Un décodeur, qui convertit une séquence d'octets en une séquence de caractères.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Character encoding describes the rules by which an encoder and a decoder operate.</source>
          <target state="translated">L'encodage de caractères décrit les règles selon lesquelles un encodeur et un décodeur fonctionnent.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> class describes the rules for encoding to, and decoding from, 8-bit Unicode Transformation Format (UTF-8), which uses one to four bytes to represent a single Unicode character.</source>
          <target state="translated">Par exemple, la classe <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> décrit les règles d’encodage et de décodage UTF-8, qui utilise de un à quatre octets pour représenter un caractère Unicode.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Encoding and decoding can also include validation.</source>
          <target state="translated">L’encodage et le décodage peuvent également inclure une validation.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> class checks all surrogates to make sure they constitute valid surrogate pairs.</source>
          <target state="translated">Par exemple, la classe <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> vérifie tous les substituts afin de vérifier qu’ils constituent des paires de substitution valide.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>(A surrogate pair consists of a character with a code point that ranges from U+D800 to U+DBFF followed by a character with a code point that ranges from U+DC00 to U+DFFF.) A fallback strategy determines how an encoder handles invalid characters or how a decoder handles invalid bytes.</source>
          <target state="translated">(Une paire de substitution se compose d'un caractère avec un point de code allant de U+D800 à U+DBFF, suivi d'un caractère avec un point de code allant de U+DC00 à U+DFFF.) Une stratégie de secours détermine comment un encodeur traite les caractères non valides ou comment un décodeur gère les octets non valides.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The .NET encoding classes provide a way to store and convert character data.</source>
          <target state="translated">Les classes d’encodage .NET permettent de stocker et de convertir les données caractères.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>They should not be used to store binary data in string form.</source>
          <target state="translated">Elles ne doivent pas utilisées pour stocker des données binaires sous forme de chaîne.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Depending on the encoding used, converting binary data to string format with the encoding classes can introduce unexpected behavior and produce inaccurate or corrupted data.</source>
          <target state="translated">En fonction de l'encodage utilisé, la conversion de données binaires en un format chaîne avec les classes d'encodage peut entraîner un comportement inattendu et produire des données incorrectes ou endommagées.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To convert binary data to a string form, use the <bpt id="p1">[</bpt>Convert.ToBase64String<ept id="p1">](xref:System.Convert.ToBase64String(System.Byte[]))</ept> method.</source>
          <target state="translated">Pour convertir les données binaires en chaîne, utilisez la méthode <bpt id="p1">[</bpt>Convert.ToBase64String<ept id="p1">](xref:System.Convert.ToBase64String(System.Byte[]))</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>.NET uses the UTF-16 encoding (represented by the <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> class) to represent characters and strings.</source>
          <target state="translated">.NET utilise l’encodage UTF-16 (représenté par la classe <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept>) pour représenter des caractères et des chaînes.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Applications that target the common language runtime use encoders to map Unicode character representations supported by the common language runtime to other encoding schemes.</source>
          <target state="translated">Les applications qui ciblent le common language runtime utilisent des encodeurs pour mapper les représentations de caractères Unicode prises en charge par le common language runtime à d'autres schémas de codage.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>They use decoders to map characters from non-Unicode encodings to Unicode.</source>
          <target state="translated">Elles utilisent des décodeurs pour mapper les caractères des encodages non-Unicode à Unicode.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This topic consists of the following sections:</source>
          <target state="translated">Cette rubrique contient les sections suivantes :</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Encodings in .NET<ept id="p1">](#encodings-in-net)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Encodages dans .NET<ept id="p1">](#encodings-in-net)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Selecting an encoding class<ept id="p1">](#selecting-an-encoding-class)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Sélection d’une classe d’encodage<ept id="p1">](#selecting-an-encoding-class)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using an encoding object<ept id="p1">](#using-an-encoding-object)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Utilisation d’un objet d’encodage<ept id="p1">](#using-an-encoding-object)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Choosing a fallback strategy<ept id="p1">](#choosing-a-fallback-strategy)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Choix d’une stratégie de secours<ept id="p1">](#choosing-a-fallback-strategy)</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Implémentation d’une stratégie de secours personnalisée<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Encodings in .NET</source>
          <target state="translated">Encodages dans .NET</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>All character encoding classes in .NET inherit from the <bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> class, which is an abstract class that defines the functionality common to all character encodings.</source>
          <target state="translated">Toutes les classes d’encodage de caractères dans .NET héritent de la classe <bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept>, qui est une classe abstraite définissant les fonctionnalités communes à tous les encodages de caractères.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>To access the individual encoding objects implemented in .NET, do the following:</source>
          <target state="translated">Pour accéder aux objets d’encodage individuels implémentés dans .NET, procédez comme suit :</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Use the static properties of the <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> class, which return objects that represent the standard character encodings available in .NET (ASCII, UTF-7, UTF-8, UTF-16, and UTF-32).</source>
          <target state="translated">Utilisez les propriétés statiques de la classe <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept>, qui retournent des objets représentant les encodages de caractères standard disponibles dans .NET (ASCII, UTF-7, UTF-8, UTF-16 et UTF-32).</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>Encoding.Unicode<ept id="p1">](xref:System.Text.Encoding.Unicode)</ept> property returns a <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept> object.</source>
          <target state="translated">Par exemple, la propriété <bpt id="p1">[</bpt>Encoding.Unicode<ept id="p1">](xref:System.Text.Encoding.Unicode)</ept> retourne un objet <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Each object uses replacement fallback to handle strings that it cannot encode and bytes that it cannot decode.</source>
          <target state="translated">Chaque objet utilise la stratégie de secours pour les remplacements pour traiter les chaînes qu'il ne peut pas encoder et les octets qu'il ne peut pas décoder.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Replacement fallback<ept id="p1">](#replacement-fallback)</ept> section.)</source>
          <target state="translated">(Pour plus d’informations, consultez la section <bpt id="p1">[</bpt>Stratégie de secours pour les remplacements<ept id="p1">](#replacement-fallback)</ept>.)</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Call the encoding's class constructor.</source>
          <target state="translated">Appelez le constructeur de classe de l'encodage.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Objects for the ASCII, UTF-7, UTF-8, UTF-16, and UTF-32 encodings can be instantiated in this way.</source>
          <target state="translated">Les objets pour les encodages ASCII, UTF-7, UTF-8, UTF-16 et UTF-32 peuvent être instanciés de cette façon.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>By default, each object uses replacement fallback to handle strings that it cannot encode and bytes that it cannot decode, but you can specify that an exception should be thrown instead.</source>
          <target state="translated">Par défaut, chaque objet utilise la stratégie de secours pour les remplacements pour traiter les chaînes qu'il ne peut pas encoder et les octets qu'il ne peut pas décoder, mais vous pouvez spécifier qu'au lieu de cela, une exception doit être levée.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Replacement fallback<ept id="p1">](#replacement-fallback)</ept> and <bpt id="p2">[</bpt>Exception fallback<ept id="p2">](#exception-fallback)</ept> sections.)</source>
          <target state="translated">(Pour plus d’informations, consultez les sections <bpt id="p1">[</bpt>Stratégie de secours pour les remplacements<ept id="p1">](#replacement-fallback)</ept> et <bpt id="p2">[</bpt>Stratégie de secours pour les exceptions<ept id="p2">](#exception-fallback)</ept>.)</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">[</bpt>Encoding.Encoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> constructor and pass it an integer that represents the encoding.</source>
          <target state="translated">Appelez le constructeur <bpt id="p1">[</bpt>Encoding.Encoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> et passez-lui un entier qui représente l’encodage.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Standard encoding objects use replacement fallback, and code page and double-byte character set (DBCS) encoding objects use best-fit fallback to handle strings that they cannot encode and bytes that they cannot decode.</source>
          <target state="translated">Les objets d'encodage standard utilisent la stratégie de secours pour les remplacements. Les objets d'encodage de page de codes et de jeu de caractères codés sur deux octets (DBCS) utilisent la stratégie de secours la mieux adaptée pour traiter les chaînes qu'ils ne peuvent pas encoder et les octets qu'ils ne peuvent pas décoder.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Best-Fit fallback<ept id="p1">](#best-fit-fallback)</ept> section.)</source>
          <target state="translated">(Pour plus d’informations, consultez la section <bpt id="p1">[</bpt>Stratégie de secours la mieux adaptée<ept id="p1">](#best-fit-fallback)</ept>.)</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">[</bpt>Encoding.GetEncoding<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> method, which returns any standard, code page, or DBCS encoding available in .NET.</source>
          <target state="translated">Appelez la méthode <bpt id="p1">[</bpt>Encoding.GetEncoding<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept>, qui retourne les encodages standard, de page de codes ou DBCS disponibles dans .NET.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Overloads let you specify a fallback object for both the encoder and the decoder.</source>
          <target state="translated">Les surcharges vous permettent de spécifier un objet de secours pour l'encodeur et pour le décodeur.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The Unicode Standard assigns a code point (a number) and a name to each character in every supported script.</source>
          <target state="translated">La norme Unicode affecte un point de code (un nombre) et un nom à chaque caractère de chaque jeu de caractères pris en charge.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For example, the character "A" is represented by the code point U+0041 and the name "LATIN CAPITAL LETTER A".</source>
          <target state="translated">Par exemple, le caractère "A" est représenté par le point de code U+0041 et par le nom "LETTRE MAJUSCULE LATINE A".</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The Unicode Transformation Format (UTF) encodings define ways to encode that code point into a sequence of one or more bytes.</source>
          <target state="translated">Les encodages UTF (Unicode Transformation Format) définissent des moyens d'encoder ce point de code en une séquence d'un ou plusieurs octets.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A Unicode encoding scheme simplifies world-ready application development because it allows characters from any character set to be represented in a single encoding.</source>
          <target state="translated">Un schéma d'encodage Unicode simplifie le développement d'applications mondialisées, car il permet la représentation avec un encodage unique des caractères provenant de n'importe quel jeu de caractères.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Application developers no longer have to keep track of the encoding scheme that was used to produce characters for a specific language or writing system, and data can be shared among systems internationally without being corrupted.</source>
          <target state="translated">Les développeurs d'applications ne doivent plus faire le suivi du schéma d'encodage qui a été utilisé pour produire des caractères pour une langue ou un système d'écriture spécifique, et les données peuvent être partagées entre des systèmes à une échelle internationale sans risque d'endommagement.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>.NET supports three encodings defined by the Unicode standard: UTF-8, UTF-16, and UTF-32.</source>
          <target state="translated">.NET prend en charge trois encodages définis par la norme Unicode : UTF-8, UTF-16 et UTF-32.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For more information, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode<ept id="p1">](http://www.unicode.org/)</ept> home page.</source>
          <target state="translated">Pour plus d’informations, consultez la norme Unicode dans la page d’accueil <bpt id="p1">[</bpt>Unicode<ept id="p1">](http://www.unicode.org/)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>.NET supports the character encoding systems listed in the following table.</source>
          <target state="translated">.NET prend en charge les systèmes d’encodage de caractères répertoriés dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encodage</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">Classe</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Advantages/disadvantages</source>
          <target state="translated">Avantages et inconvénients</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept></target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Encodes a limited range of characters by using the lower seven bits of a byte.</source>
          <target state="translated">Encode une plage de caractères limitée en utilisant les sept bits de poids le plus faible d'un octet.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Because this encoding only supports character values from U+0000 through U+007F, in most cases it is inadequate for internationalized applications.</source>
          <target state="translated">Étant donné que cet encodage prend en charge seulement des valeurs de caractère de U+0000 à U+007F, dans la plupart des cas, il ne convient pas aux applications internationalisées.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UTF7Encoding<ept id="p1">](xref:System.Text.UTF7Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UTF7Encoding<ept id="p1">](xref:System.Text.UTF7Encoding)</ept></target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Represents characters as sequences of 7-bit ASCII characters.</source>
          <target state="translated">Représente les caractères sous forme de séquences de caractères ASCII sur 7 bits.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Non-ASCII Unicode characters are represented by an escape sequence of ASCII characters.</source>
          <target state="translated">Les caractères Unicode non-ASCII sont représentés par une séquence d'échappement de caractères ASCII.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>UTF-7 supports protocols such as e-mail and newsgroup protocols.</source>
          <target state="translated">UTF-7 prend en charge les protocoles de messagerie et les protocoles de groupe de discussion.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>However, UTF-7 is not particularly secure or robust.</source>
          <target state="translated">UTF-7 n'est cependant pas particulièrement sécurisé ou robuste.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In some cases, changing one bit can radically alter the interpretation of an entire UTF-7 string.</source>
          <target state="translated">Dans certains cas, la modification d'un seul bit peut changer radicalement l'interprétation de toute une chaîne UTF-7.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In other cases, different UTF-7 strings can encode the same text.</source>
          <target state="translated">Dans d'autres cas, des chaînes UTF-7 différentes peuvent correspondre à l'encodage d'un même texte.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For sequences that include non-ASCII characters, UTF-7 requires more space than UTF-8, and encoding/decoding is slower.</source>
          <target state="translated">Pour les séquences incluant des caractères non-ASCII, UTF-7 nécessite davantage d'espace qu'UTF-8, et l'encodage/décodage est plus lent.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Consequently, you should use UTF-8 instead of UTF-7 if possible.</source>
          <target state="translated">Par conséquent, il est préférable d'utiliser UTF-8 au lieu d'UTF-7 si c'est possible.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a sequence of one to four bytes.</source>
          <target state="translated">Représente chaque point de code Unicode sous la forme d'une séquence de un à quatre octets.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>UTF-8 supports 8-bit data sizes and works well with many existing operating systems.</source>
          <target state="translated">UTF-8 prend en charge des tailles de données de 8 bits et fonctionne bien avec de nombreux systèmes d'exploitation.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For the ASCII range of characters, UTF-8 is identical to ASCII encoding and allows a broader set of characters.</source>
          <target state="translated">Pour la plage de caractères ASCII, UTF-8 est identique à l'encodage ASCII et permet un ensemble de caractères plus large.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, for Chinese-Japanese-Korean (CJK) scripts, UTF-8 can require three bytes for each character, and can potentially cause larger data sizes than UTF-16.</source>
          <target state="translated">Cependant, pour les jeux de caractères Chinois-Japonais-Coréen (CJC), UTF-8 peut nécessiter trois octets pour chaque caractère et aboutir potentiellement à des tailles de données supérieures à celles d'UTF-16.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Note that sometimes the amount of ASCII data, such as HTML tags, justifies the increased size for the CJK range.</source>
          <target state="translated">Notez que parfois, la quantité de données ASCII, comme des balises HTML, justifie l'augmentation de la taille pour les jeux de caractères CJC.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a sequence of one or two 16-bit integers.</source>
          <target state="translated">Représente chaque point de code Unicode sous la forme d'une séquence de un ou deux entiers sur 16 bits.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Most common Unicode characters require only one UTF-16 code point, although Unicode supplementary characters (U+10000 and greater) require two UTF-16 surrogate code points.</source>
          <target state="translated">La plupart des caractères Unicode courants ne nécessitent qu'un seul point de code UTF-16, tandis que les caractères Unicode additionnels (U+10000 et supérieurs) nécessitent deux points de code de substitution UTF-16.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Both little-endian and big-endian byte orders are supported.</source>
          <target state="translated">Les ordres des octets Little Endian et Big Endian sont pris en charge.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>UTF-16 encoding is used by the common language runtime to represent Char and String values, and it is used by the Windows operating system to represent WCHAR values.</source>
          <target state="translated">L’encodage UTF-16 est utilisé par le Common Language Runtime pour représenter les valeurs Char et String, et il est utilisé par le système d’exploitation Windows pour représenter les valeurs WCHAR.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a 32-bit integer.</source>
          <target state="translated">Représente chaque point de code Unicode sous la forme d'un entier 32 bits.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Both little-endian and big-endian byte orders are supported.</source>
          <target state="translated">Les ordres des octets Little Endian et Big Endian sont pris en charge.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>UTF-32 encoding is used when applications want to avoid the surrogate code point behavior of UTF-16 encoding on operating systems for which encoded space is too important.</source>
          <target state="translated">L'encodage UTF-32 est utilisé quand les applications ne doivent pas avoir le comportement du point de code de substitution de l'encodage UTF-16 sur les systèmes d'exploitation pour lesquels l'espace encodé est trop important.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Single glyphs rendered on a display can still be encoded with more than one UTF-32 character.</source>
          <target state="translated">Les glyphes uniques restitués à l'affichage peuvent néanmoins encore être encodés avec plusieurs caractères UTF-32.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>These encodings enable you to work with Unicode characters as well as with encodings that are most commonly used in legacy applications.</source>
          <target state="translated">Ces encodages vous permettent de travailler avec des caractères Unicode ainsi qu'avec les encodages les plus couramment utilisés dans les applications héritées.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>In addition, you can create a custom encoding by defining a class that derives from <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> and overriding its members.</source>
          <target state="translated">En outre, vous pouvez créer un encodage personnalisé en définissant une classe qui dérive de <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> et en remplaçant ses membres.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>By default, .NET Core does not make available any code page encodings other than code page 28591 and the Unicode encodings, such as UTF-8 and UTF-16.</source>
          <target state="translated">Par défaut, .NET Core ne met à disposition aucune page de codes autre que la page de codes 28591 et les encodages Unicode, comme UTF-8 et UTF-16.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>However, you can add the code page encodings found in standard Windows apps that target the .NET Framework to your app.</source>
          <target state="translated">Vous pouvez cependant ajouter à votre application les encodages des pages de code qui se trouvent dans les applications Windows standard ciblant le .NET Framework.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For complete information, see the <bpt id="p1">[</bpt>EncodingProvider<ept id="p1">](xref:System.Text.EncodingProvider)</ept> topic.</source>
          <target state="translated">Pour plus d’informations, consultez la rubrique <bpt id="p1">[</bpt>EncodingProvider<ept id="p1">](xref:System.Text.EncodingProvider)</ept>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Selecting an Encoding class</source>
          <target state="translated">Sélection d’une classe d’encodage</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If you have the opportunity to choose the encoding to be used by your application, you should use a Unicode encoding, preferably either <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> or <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>.</source>
          <target state="translated">Si vous avez la possibilité de choisir l’encodage utilisé par votre application, utilisez un encodage Unicode, de préférence <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> ou <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>(.NET also supports a third Unicode encoding, <bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept>.)</source>
          <target state="translated">(.NET prend également en charge un troisième encodage Unicode, <bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept>.)</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If you are planning to use an ASCII encoding (<bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>), choose <bpt id="p2">[</bpt>UTF8Encoding<ept id="p2">](xref:System.Text.UTF8Encoding)</ept> instead.</source>
          <target state="translated">Si vous envisagez d’utiliser un encodage ASCII (<bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>), choisissez <bpt id="p2">[</bpt>UTF8Encoding<ept id="p2">](xref:System.Text.UTF8Encoding)</ept> à la place.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The two encodings are identical for the ASCII character set, but <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> has the following advantages:</source>
          <target state="translated">Les deux encodages sont identiques pour le jeu de caractères ASCII, mais <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> présente les avantages suivants :</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>It can represent every Unicode character, whereas <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> supports only the Unicode character values between U+0000 and U+007F.</source>
          <target state="translated">Il peut représenter tous les caractères Unicode, alors qu’<bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> prend en charge seulement les valeurs des caractères Unicode comprises entre U+0000 et U+007F.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>It provides error detection and better security.</source>
          <target state="translated">Il offre une fonction de détection d'erreur et une meilleure sécurité.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>It has been tuned to be as fast as possible and should be faster than any other encoding.</source>
          <target state="translated">Il a été optimisé pour être aussi rapide que possible et il doit normalement être plus rapide n'importe quel autre encodage.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Even for content that is entirely ASCII, operations performed with <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> are faster than operations performed with <bpt id="p2">[</bpt>ASCIIEncoding<ept id="p2">](xref:System.Text.ASCIIEncoding)</ept>.</source>
          <target state="translated">Même pour du contenu qui est entièrement en ASCII, les opérations effectuées avec <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> sont plus rapides que les celles effectuées avec <bpt id="p2">[</bpt>ASCIIEncoding<ept id="p2">](xref:System.Text.ASCIIEncoding)</ept>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>You should consider using <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> only for legacy applications.</source>
          <target state="translated">Il est préférable d’utiliser <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> seulement pour les applications héritées.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>However, even for legacy applications, <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> might be a better choice for the following reasons (assuming default settings):</source>
          <target state="translated">Cependant, même pour les applications héritées, <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> peut être un meilleur choix pour les raisons suivantes (en supposant que les paramètres par défaut sont utilisés) :</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If your application has content that is not strictly ASCII and encodes it with <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>, each non-ASCII character encodes as a question mark (?).</source>
          <target state="translated">Si votre application a du contenu qui n’est pas strictement ASCII et qu’elle l’encode avec <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>, chaque caractère non-ASCII est encodé sous la forme d’un point d’interrogation (?).</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If the application then decodes this data, the information is lost.</source>
          <target state="translated">Si l'application décode ensuite ces données, les informations sont perdues.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If your application has content that is not strictly ASCII and encodes it with <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>, the result seems unintelligible if interpreted as ASCII.</source>
          <target state="translated">Si votre application a du contenu qui n’est pas strictement ASCII et qu’elle l’encode avec <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>, le résultat paraît inintelligible s’il est interprété comme étant en ASCII.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>However, if the application then uses a UTF-8 decoder to decode this data, the data performs a round trip successfully.</source>
          <target state="translated">Cependant, si l'application utilise ensuite un décodeur UTF-8 pour décoder ces données, les données apparaissent à nouveau correctes.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In a web application, characters sent to the client in response to a web request should reflect the encoding used on the client.</source>
          <target state="translated">Dans une application web, les caractères envoyés au client en réponse à une demande web doivent refléter l'encodage utilisé sur le client.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In most cases, you should set the <bpt id="p1">[</bpt>HttpResponse.ContentEncoding<ept id="p1">](xref:System.Net.HttpResponseHeader.ContentEncoding)</ept> property to the value returned by the <bpt id="p2">[</bpt>HttpRequestHeader.ContentEncoding<ept id="p2">](xref:System.Net.HttpRequestHeader.ContentEncoding)</ept> property to display text in the encoding that the user expects.</source>
          <target state="translated">Dans la plupart des cas, vous devez affecter à la propriété <bpt id="p1">[</bpt>HttpResponse.ContentEncoding<ept id="p1">](xref:System.Net.HttpResponseHeader.ContentEncoding)</ept> la valeur retournée par la propriété <bpt id="p2">[</bpt>HttpRequestHeader.ContentEncoding<ept id="p2">](xref:System.Net.HttpRequestHeader.ContentEncoding)</ept> pour afficher le texte dans l’encodage attendu par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Using an encoding object</source>
          <target state="translated">Utilisation d’un objet d’encodage</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>An encoder converts a string of characters (most commonly, Unicode characters) to its numeric (byte) equivalent.</source>
          <target state="translated">Un encodeur convertit une chaîne de caractères (le plus souvent, des caractères Unicode) en son équivalent numérique (en octets).</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For example, you might use an ASCII encoder to convert Unicode characters to ASCII so that they can be displayed at the console.</source>
          <target state="translated">Par exemple, vous pouvez utiliser un encodeur ASCII pour convertir des caractères Unicode en ASCII, pour pouvoir les afficher sur la console.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>To perform the conversion, you call the <bpt id="p1">[</bpt>Encoding.GetBytes<ept id="p1">](xref:System.Text.Encoding.GetBytes(System.Char[]))</ept> method.</source>
          <target state="translated">Pour effectuer la conversion, vous appelez la méthode <bpt id="p1">[</bpt>Encoding.GetBytes<ept id="p1">](xref:System.Text.Encoding.GetBytes(System.Char[]))</ept>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>If you want to determine how many bytes are needed to store the encoded characters before performing the encoding, you can call the <bpt id="p1">[</bpt>GetByteCount<ept id="p1">](xref:System.Text.Encoding.GetByteCount(System.Char[]))</ept> method.</source>
          <target state="translated">Pour déterminer le nombre d’octets nécessaires pour stocker les caractères encodés avant de procéder à l’encodage, vous pouvez appeler la méthode <bpt id="p1">[</bpt>GetByteCount<ept id="p1">](xref:System.Text.Encoding.GetByteCount(System.Char[]))</ept>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following example uses a single byte array to encode strings in two separate operations.</source>
          <target state="translated">L'exemple suivant utilise un tableau d'octets seuls pour encoder des chaînes dans deux opérations distinctes.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It maintains an index that indicates the starting position in the byte array for the next set of ASCII-encoded bytes.</source>
          <target state="translated">Il gère un index qui indique la position de départ dans le tableau d'octets pour l'ensemble suivant d'octets encodés en ASCII.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It calls the <bpt id="p1">[</bpt>ASCIIEncoding.GetByteCount(String)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetByteCount(System.String))</ept> method to ensure that the byte array is large enough to accommodate the encoded string.</source>
          <target state="translated">Il appelle la méthode <bpt id="p1">[</bpt>ASCIIEncoding.GetByteCount(String)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetByteCount(System.String))</ept> pour vérifier que le tableau d’octets est assez grand pour contenir la chaîne encodée.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>It then calls the <bpt id="p1">[</bpt>ASCIIEncoding.GetBytes(String, Int32, Int32, Byte[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32))</ept> method to encode the characters in the string.</source>
          <target state="translated">Il appelle ensuite la méthode <bpt id="p1">[</bpt>ASCIIEncoding.GetBytes(String, Int32, Int32, Byte[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32))</ept> pour encoder les caractères dans la chaîne.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>A decoder converts a byte array that reflects a particular character encoding into a set of characters, either in a character array or in a string.</source>
          <target state="translated">Un décodeur convertit un tableau d'octets qui reflète un encodage de caractères spécifique en un jeu de caractères dans un tableau de caractères ou dans une chaîne.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>To decode a byte array into a character array, you call the <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> method.</source>
          <target state="translated">Pour décoder un tableau d’octets en tableau de caractères, vous appelez la méthode <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>To decode a byte array into a string, you call the <bpt id="p1">[</bpt>GetString<ept id="p1">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept> method.</source>
          <target state="translated">Pour décoder un tableau d’octets en chaîne, vous appelez la méthode <bpt id="p1">[</bpt>GetString<ept id="p1">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If you want to determine how many characters are needed to store the decoded bytes before performing the decoding, you can call the <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> method.</source>
          <target state="translated">Pour déterminer le nombre d’octets nécessaires pour stocker les caractères décodés avant de procéder au décodage, vous pouvez appeler la méthode <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The following example encodes three strings and then decodes them into a single array of characters.</source>
          <target state="translated">L'exemple suivant encode trois chaînes, puis les décode dans un même tableau de caractères.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>It maintains an index that indicates the starting position in the character array for the next set of decoded characters.</source>
          <target state="translated">Il gère un index qui indique la position de départ dans le tableau de caractères pour l'ensemble suivant de caractères décodés.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>It calls the <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> method to ensure that the character array is large enough to accommodate all the decoded characters.</source>
          <target state="translated">Il appelle la méthode <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> pour vérifier que le tableau de caractères est assez grand pour contenir les caractères décodés.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>It then calls the <bpt id="p1">[</bpt>ASCIIEncoding.GetChars(Byte[], Int32, Int32, Char[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> method to decode the byte array.</source>
          <target state="translated">Il appelle ensuite la méthode <bpt id="p1">[</bpt>ASCIIEncoding.GetChars(Byte[], Int32, Int32, Char[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> pour décoder le tableau d’octets.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The encoding and decoding methods of a class derived from <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> are designed to work on a complete set of data; that is, all the data to be encoded or decoded is supplied in a single method call.</source>
          <target state="translated">Les méthodes d’encodage et de décodage d’une classe dérivée de <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> sont conçues pour fonctionner sur un ensemble de données complet ; autrement dit, toutes les données à encoder ou à décoder sont fournies dans un seul appel de méthode.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>However, in some cases, data is available in a stream, and the data to be encoded or decoded may be available only from separate read operations.</source>
          <target state="translated">Cependant, dans certains cas, les données sont disponibles dans un flux, et les données à encoder ou à décoder peuvent être disponibles seulement via des opérations de lecture distinctes.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>This requires the encoding or decoding operation to remember any saved state from its previous invocation.</source>
          <target state="translated">Ceci nécessite la conservation par l'opération d'encodage ou de décodage des états enregistrés depuis son précédent appel.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Methods of classes derived from <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> and <bpt id="p2">[</bpt>Decoder<ept id="p2">](xref:System.Text.Decoder)</ept> are able to handle encoding and decoding operations that span multiple method calls.</source>
          <target state="translated">Les méthodes des classes dérivées d’<bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> et de <bpt id="p2">[</bpt>Decoder<ept id="p2">](xref:System.Text.Decoder)</ept> sont capables de traiter les opérations de codage et de décodage qui recouvrent plusieurs appels de méthode.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> object for a particular encoding is available from that encoding's <bpt id="p2">[</bpt>Encoding.GetEncoder<ept id="p2">](xref:System.Text.Encoding.GetEncoder)</ept> property.</source>
          <target state="translated">Un objet <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> est disponible pour un encodage particulier à partir de la propriété <bpt id="p2">[</bpt>Encoding.GetEncoder<ept id="p2">](xref:System.Text.Encoding.GetEncoder)</ept> de cet encodage.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> object for a particular encoding is available from that encoding's <bpt id="p2">[</bpt>Encoding.GetDecoder<ept id="p2">](xref:System.Text.Encoding.GetDecoder)</ept> property.</source>
          <target state="translated">Un objet <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> est disponible pour un encodage particulier à partir de la propriété <bpt id="p2">[</bpt>Encoding.GetDecoder<ept id="p2">](xref:System.Text.Encoding.GetDecoder)</ept> de cet encodage.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For decoding operations, note that classes derived from <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> include a <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> method, but they do not have a method that corresponds to <bpt id="p3">[</bpt>Encoding.GetString<ept id="p3">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept>.</source>
          <target state="translated">Pour les opérations de décodage, notez que les classes dérivées de <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> incluent une méthode <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept>, mais qu’elles n’ont pas de méthode qui correspond à <bpt id="p3">[</bpt>Encoding.GetString<ept id="p3">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between using the <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> and <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> methods for decoding a Unicode byte array.</source>
          <target state="translated">L’exemple suivant montre la différence entre l’utilisation des méthodes <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> et <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> pour le décodage d’un tableau d’octets Unicode.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The example encodes a string that contains some Unicode characters to a file, and then uses the two decoding methods to decode them ten bytes at a time.</source>
          <target state="translated">L'exemple encode une chaîne qui contient des caractères Unicode vers un fichier, puis utilise les deux méthodes de décodage pour les décoder par dix octets à la fois.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Because a surrogate pair occurs in the tenth and eleventh bytes, it is decoded in separate method calls.</source>
          <target state="translated">Une paire de substitution se trouvant dans les dixième et onzième octets, elle est décodée dans des appels de méthode distincts.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>As the output shows, the <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> method is not able to correctly decode the bytes and instead replaces them with U+FFFD (REPLACEMENT CHARACTER).</source>
          <target state="translated">Comme la sortie le montre, la méthode <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> ne peut pas décoder correctement les octets et les remplace par U+FFFD (CARACTÈRE DE REMPLACEMENT).</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>On the other hand, the <bpt id="p1">[</bpt>Decoder.GetChars<ept id="p1">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> method is able to successfully decode the byte array to get the original string.</source>
          <target state="translated">En revanche, la méthode <bpt id="p1">[</bpt>Decoder.GetChars<ept id="p1">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> peut décoder correctement le tableau d’octets pour obtenir la chaîne d’origine.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Choosing a fallback strategy</source>
          <target state="translated">Choix d’une stratégie de secours</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>When a method tries to encode or decode a character but no mapping exists, it must implement a fallback strategy that determines how the failed mapping should be handled.</source>
          <target state="translated">Quand une méthode tente d'encoder ou de décoder un caractère, mais qu'il n'existe pas de mappage, elle doit implémenter une stratégie de secours qui détermine comment l'échec du mappage doit être traité.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>There are three types of fallback strategies:</source>
          <target state="translated">Il existe trois types de stratégies de secours :</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Best-fit fallback</source>
          <target state="translated">Stratégie de secours la mieux adaptée</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Replacement fallback</source>
          <target state="translated">Stratégie de secours pour les remplacements</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Exception fallback</source>
          <target state="translated">Stratégie de secours pour les exceptions</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The most common problems in encoding operations occur when a Unicode character cannot be mapped to a particular code page encoding.</source>
          <target state="translated">Les problèmes les plus courants des opérations d'encodage se produisent quand un caractère Unicode ne peut pas être mappé à un encodage de page de codes particulier.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The most common problems in decoding operations occur when invalid byte sequences cannot be translated into valid Unicode characters.</source>
          <target state="translated">Les problèmes les plus courants des opérations de décodage se produisent quand des séquences d'octets non valides ne peut pas être traduites en caractères Unicode valides.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>For these reasons, you should know which fallback strategy a particular encoding object uses.</source>
          <target state="translated">Pour ces raisons, vous devez savoir quelle stratégie de secours est utilisée par un objet de codage particulier.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should specify the fallback strategy used by an encoding object when you instantiate the object.</source>
          <target state="translated">Chaque fois que c'est possible, vous devez spécifier la stratégie de secours utilisée par un objet d'encodage quand vous instanciez l'objet.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Best-fit fallback</source>
          <target state="translated">Stratégie de secours la mieux adaptée</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>When a character does not have an exact match in the target encoding, the encoder can try to map it to a similar character.</source>
          <target state="translated">Quand un caractère n'a pas de correspondance exacte dans l'encodage cible, l'encodeur peut essayer de le mapper à un caractère similaire.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>(Best-fit fallback is mostly an encoding rather than a decoding issue.</source>
          <target state="translated">(La stratégie de secours la mieux adaptée est principalement un codage plutôt qu'un problème de décodage.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>There are very few code pages that contain characters that cannot be successfully mapped to Unicode.) Best-fit fallback is the default for code page and double-byte character set encodings that are retrieved by the <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> and <bpt id="p2">[</bpt>Encoding.GetEncoding(String)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.String))</ept> overloads.</source>
          <target state="translated">Il existe très peu de pages de codes contenant des caractères qui ne peuvent pas être mappés à Unicode.) La stratégie de secours la mieux adaptée correspond aux valeurs par défaut des encodages de pages de codes et de jeux de caractères codés sur deux octets, qui sont récupérés par les surcharges <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> et <bpt id="p2">[</bpt>Encoding.GetEncoding(String)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.String))</ept>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>In theory, the Unicode encoding classes provided in .NET (<bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>, <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>, and <bpt id="p3">[</bpt>UTF32Encoding<ept id="p3">](xref:System.Text.UTF32Encoding)</ept>) support every character in every character set, so they can be used to eliminate best-fit fallback issues.</source>
          <target state="translated">En théorie, les classes d’encodage Unicode fournies dans .NET (<bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>, <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept> et <bpt id="p3">[</bpt>UTF32Encoding<ept id="p3">](xref:System.Text.UTF32Encoding)</ept>) prennent en charge tous les caractères de tous les jeux de caractères : elles peuvent donc être utilisées pour éliminer les problèmes liés à la stratégie de secours la mieux adaptée.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Best-fit strategies vary for different code pages, and they are not documented in detail.</source>
          <target state="translated">Les stratégies de secours les mieux adaptées varient pour les différentes pages de code et elles ne sont pas documentées en détail.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>For example, for some code pages, full-width Latin characters map to the more common half-width Latin characters.</source>
          <target state="translated">Par exemple, pour certaines pages de codes, les caractères latins à pleine chasse sont mappés aux caractères latins à demi-chasse plus courants.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>For other code pages, this mapping is not made.</source>
          <target state="translated">Pour d'autres pages de codes, ce mappage n'est pas effectué.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Even under an aggressive best-fit strategy, there is no imaginable fit for some characters in some encodings.</source>
          <target state="translated">Même avec une stratégie la plus adaptée appliquée de façon agressive, il n'existe pas d'ajustement possible pour certains caractères dans certains encodages.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example, a Chinese ideograph has no reasonable mapping to code page 1252.</source>
          <target state="translated">Par exemple, un idéogramme chinois n'a pas de mappage acceptable avec la page de codes 1252.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>In this case, a replacement string is used.</source>
          <target state="translated">Dans ce cas, une chaîne de remplacement est utilisée.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>By default, this string is just a single QUESTION MARK (U+003F).</source>
          <target state="translated">Par défaut, cette chaîne est simplement un POINT D'INTERROGATION (U+003F).</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The following example uses code page 1252 (the Windows code page for Western European languages) to illustrate best-fit mapping and its drawbacks.</source>
          <target state="translated">L'exemple suivant utilise la page de codes 1252 (la page de codes Windows pour les langues d'Europe occidentale) pour illustrer le mappage le mieux adapté et ses inconvénients.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> method is used to retrieve an encoding object for code page 1252.</source>
          <target state="translated">La méthode <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> est utilisée pour récupérer un objet d’encodage pour la page de codes 1252.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>By default, it uses a best-fit mapping for Unicode characters that it does not support.</source>
          <target state="translated">Par défaut, elle utilise un mappage le mieux adapté pour les caractères Unicode qu'elle ne prend pas en charge.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The example instantiates a string that contains three non-ASCII characters - CIRCLED LATIN CAPITAL LETTER S (U+24C8), SUPERSCRIPT FIVE (U+2075), and INFINITY (U+221E) - separated by spaces.</source>
          <target state="translated">L'exemple instancie une chaîne contenant trois caractères non-ASCII, LETTRE MAJUSCULE LATINE S CERCLÉE (U+24C8), EXPOSANT CINQ (U+2075) et INFINI (U+221E), séparés par des espaces.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, when the string is encoded, the three original non-space characters are replaced by QUESTION MARK (U+003F), DIGIT FIVE (U+0035), and DIGIT EIGHT (U+0038).</source>
          <target state="translated">Comme le montre la sortie de l'exemple, quand la chaîne est encodée, les trois caractères d'origine autres qu'un espace sont remplacés par POINT D'INTERROGATION (U+003F), CHIFFRE CINQ (U+0035) et CHIFFRE HUIT (U+0038).</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>DIGIT EIGHT is a particularly poor replacement for the unsupported INFINITY character, and QUESTION MARK indicates that no mapping was available for the original character.</source>
          <target state="translated">CHIFFRE HUIT est un substitut particulièrement médiocre pour le caractère INFINI non pris en charge, et POINT D'INTERROGATION indique qu'aucun mappage n'est disponible pour le caractère d'origine.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Best-fit mapping is the default behavior for an <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> object that encodes Unicode data into code page data, and there are legacy applications that rely on this behavior.</source>
          <target state="translated">Le mappage le mieux adapté est le comportement par défaut d’un objet <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> qui encode des données Unicode en données de page de codes, et il existe des applications héritées qui s’appuient sur ce comportement.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>However, most new applications should avoid best-fit behavior for security reasons.</source>
          <target state="translated">Cependant, la plupart des nouvelles applications doivent éviter ce comportement le mieux adapté pour des raisons de sécurité.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For example, applications should not put a domain name through a best-fit encoding.</source>
          <target state="translated">Par exemple, les applications ne doivent pas établir un nom de domaine via un encodage le mieux adapté.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>You can also implement a custom best-fit fallback mapping for an encoding.</source>
          <target state="translated">Vous pouvez également implémenter un mappage de stratégie de secours la mieux adaptée personnalisé pour un encodage.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> section.</source>
          <target state="translated">Pour plus d’informations, consultez la section <bpt id="p1">[</bpt>Implémentation d’une stratégie de secours personnalisée<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>If best-fit fallback is the default for an encoding object, you can choose another fallback strategy when you retrieve an <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> object by calling the <bpt id="p2">[</bpt>Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> or <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> overload.</source>
          <target state="translated">Si la stratégie de secours la mieux adaptée est la valeur par défaut d’un objet d’encodage, vous pouvez choisir une autre stratégie de secours quand vous récupérez un objet <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> en appelant la surcharge <bpt id="p2">[</bpt>Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> ou <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The following section includes an example that replaces each character that cannot be mapped to code page 1252 with an asterisk (<ph id="ph1">\*</ph>).</source>
          <target state="translated">La section suivante contient un exemple qui remplace chaque caractère qui ne peut pas être mappé à la page de codes 1252 par un astérisque (<ph id="ph1">\*</ph>).</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Replacement fallback</source>
          <target state="translated">Stratégie de secours pour les remplacements</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>When a character does not have an exact match in the target scheme, but there is no appropriate character that it can be mapped to, the application can specify a replacement character or string.</source>
          <target state="translated">Quand un caractère n'a pas de correspondance exacte dans le schéma cible, mais qu'il n'existe pas de caractère approprié auquel il peut être mappé, l'application peut spécifier un caractère ou une chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>This is the default behavior for the Unicode decoder, which replaces any two-byte sequence that it cannot decode with REPLACEMENT_CHARACTER (U+FFFD).</source>
          <target state="translated">Il s'agit du comportement par défaut pour le décodeur Unicode, qui remplace toutes les séquences de deux octets qu'il ne peut pas décoder par CARACTÈRE_DE_REMPLACEMENT (U+FFFD).</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>It is also the default behavior of the <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> class, which replaces each character that it cannot encode or decode with a question mark.</source>
          <target state="translated">C’est également le comportement par défaut de la classe <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>, qui remplace chaque caractère qu’elle ne peut pas encoder ou décoder par un point d’interrogation.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The following example illustrates character replacement for the Unicode string from the previous example.</source>
          <target state="translated">L'exemple suivant illustre le remplacement de caractères pour la chaîne Unicode de l'exemple précédent.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>As the output shows, each character that cannot be decoded into an ASCII byte value is replaced by 0x3F, which is the ASCII code for a question mark.</source>
          <target state="translated">Comme le montre la sortie, chaque caractère qui ne peut pas être décodé en une valeur d'octet ASCII est remplacé par 0x3F, qui est le code ASCII pour un point d'interrogation.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>.NET includes the <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> and <bpt id="p2">[</bpt>DecoderReplacementFallback<ept id="p2">](xref:System.Text.DecoderReplacementFallback)</ept> classes, which substitute a replacement string if a character does not map exactly in an encoding or decoding operation.</source>
          <target state="translated">.NET inclut les classes <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> et <bpt id="p2">[</bpt>DecoderReplacementFallback<ept id="p2">](xref:System.Text.DecoderReplacementFallback)</ept>, qui substituent une chaîne de remplacement si un caractère ne correspond pas exactement dans une opération d’encodage ou de décodage.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>By default, this replacement string is a question mark, but you can call a class constructor overload to choose a different string.</source>
          <target state="translated">Par défaut, cette chaîne de remplacement est un point d'interrogation, mais vous pouvez appeler une surcharge de constructeur de classe pour choisir une autre chaîne.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Typically, the replacement string is a single character, although this is not a requirement.</source>
          <target state="translated">En général, la chaîne de remplacement est un caractère unique, même si ce n’est pas obligatoire.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The following example changes the behavior of the code page 1252 encoder by instantiating an <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> object that uses an asterisk (<ph id="ph1">\*</ph>) as a replacement string.</source>
          <target state="translated">L’exemple suivant change le comportement de l’encodeur de la page de codes 1252 en instanciant un objet <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> qui utilise un astérisque (<ph id="ph1">\*</ph>) comme chaîne de remplacement.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>You can also implement a replacement class for an encoding.</source>
          <target state="translated">Vous pouvez également implémenter une classe de remplacement pour un encodage.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> section.</source>
          <target state="translated">Pour plus d’informations, consultez la section <bpt id="p1">[</bpt>Implémentation d’une stratégie de secours personnalisée<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>In addition to QUESTION MARK (U+003F), the Unicode REPLACEMENT CHARACTER (U+FFFD) is commonly used as a replacement string, particularly when decoding byte sequences that cannot be successfully translated into Unicode characters.</source>
          <target state="translated">En plus du POINT D'INTERROGATION (U+003F), le CARACTÈRE DE REMPLACEMENT Unicode (U+FFFD) est couramment utilisé comme chaîne de remplacement, en particulier lors du décodage de séquences d'octets qui ne peuvent pas être converties en caractères Unicode.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>However, you are free to choose any replacement string, and it can contain multiple characters.</source>
          <target state="translated">Vous êtes cependant libre de choisir n'importe quelle chaîne de remplacement, qui peut contenir plusieurs caractères.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Exception fallback</source>
          <target state="translated">Stratégie de secours pour les exceptions</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Instead of providing a best-fit fallback or a replacement string, an encoder can throw an <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> if it is unable to encode a set of characters, and a decoder can throw a <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> if it is unable to decode a byte array.</source>
          <target state="translated">Au lieu de fournir une stratégie de secours la mieux adaptée ou une chaîne de remplacement, un encodeur peut lever une exception <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> s’il ne peut pas encoder un jeu de caractères, et un décodeur peut lever une exception <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> s’il ne peut pas décoder un tableau d’octets.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>To throw an exception in encoding and decoding operations, you supply an <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> object and a <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> object, respectively, to the <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> method.</source>
          <target state="translated">Pour lever une exception dans les opérations d’encodage et de décodage, vous fournissez respectivement un objet <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> et un objet <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> à la méthode <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The following example illustrates exception fallback with the ASCIIEncoding class.</source>
          <target state="translated">L’exemple suivant montre la stratégie de secours pour les exceptions avec la classe ASCIIEncoding.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>You can also implement a custom exception handler for an encoding operation.</source>
          <target state="translated">Vous pouvez également implémenter un gestionnaire d'exceptions personnalisé pour une opération d'encodage.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> section.</source>
          <target state="translated">Pour plus d’informations, consultez la section <bpt id="p1">[</bpt>Implémentation d’une stratégie de secours personnalisée<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> and <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> objects provide the following information about the condition that caused the exception:</source>
          <target state="translated">Les objets <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> et <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> fournissent les informations suivantes sur la condition qui a provoqué l’exception :</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> object includes an <bpt id="p2">[</bpt>IsUnknownSurrogate<ept id="p2">](xref:System.Text.EncoderFallbackException.IsUnknownSurrogate)</ept> method, which indicates whether the character or characters that cannot be encoded represent an unknown surrogate pair (in which case, the method returns <ph id="ph1">`true`</ph>) or an unknown single character (in which case, the method returns <ph id="ph2">`false`</ph>).</source>
          <target state="translated">L’objet <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> comprend une méthode <bpt id="p2">[</bpt>IsUnknownSurrogate<ept id="p2">](xref:System.Text.EncoderFallbackException.IsUnknownSurrogate)</ept>, qui indique si le ou les caractères qui ne peuvent pas être encodés représentent une paire de substitution inconnue (auquel cas la méthode retourne <ph id="ph1">`true`</ph>) ou un seul caractère inconnu (auquel cas la méthode retourne <ph id="ph2">`false`</ph>).</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The characters in the surrogate pair are available from the <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknownHigh<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknownHigh)</ept> and <bpt id="p2">[</bpt>EncoderFallbackException.CharUnknownLow<ept id="p2">](xref:System.Text.EncoderFallbackException.CharUnknownLow)</ept> properties.</source>
          <target state="translated">Les caractères de la paire de substitution sont disponibles à partir des propriétés <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknownHigh<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknownHigh)</ept> et <bpt id="p2">[</bpt>EncoderFallbackException.CharUnknownLow<ept id="p2">](xref:System.Text.EncoderFallbackException.CharUnknownLow)</ept>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The unknown single character is available from the <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknown<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknown)</ept> property.</source>
          <target state="translated">Le caractère unique inconnu est disponible à partir de la propriété <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknown<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknown)</ept>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackException.Index<ept id="p1">](xref:System.Text.EncoderFallbackException.Index)</ept> property indicates the position in the string at which the first character that could not be encoded was found.</source>
          <target state="translated">La propriété <bpt id="p1">[</bpt>EncoderFallbackException.Index<ept id="p1">](xref:System.Text.EncoderFallbackException.Index)</ept> indique la position dans la chaîne du premier caractère qui n’a pas pu être encodé.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>DecoderFallbackException<ept id="p1">](xref:System.Text.DecoderFallbackException)</ept> object includes a <bpt id="p2">[</bpt>BytesUnknown<ept id="p2">](xref:System.Text.DecoderFallbackException.BytesUnknown)</ept> property that returns an array of bytes that cannot be decoded.</source>
          <target state="translated">L’objet <bpt id="p1">[</bpt>DecoderFallbackException<ept id="p1">](xref:System.Text.DecoderFallbackException)</ept> inclut une propriété <bpt id="p2">[</bpt>BytesUnknown<ept id="p2">](xref:System.Text.DecoderFallbackException.BytesUnknown)</ept> qui retourne un tableau d’octets qui ne peut pas être décodé.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>DecoderFallbackException.Index<ept id="p1">](xref:System.Text.DecoderFallbackException.Index)</ept> property indicates the starting position of the unknown bytes.</source>
          <target state="translated">La propriété <bpt id="p1">[</bpt>DecoderFallbackException.Index<ept id="p1">](xref:System.Text.DecoderFallbackException.Index)</ept> indique la position de départ des octets inconnus.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Although the <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> and <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> objects provide adequate diagnostic information about the exception, they do not provide access to the encoding or decoding buffer.</source>
          <target state="translated">Bien que les objets <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> et <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> fournissent des informations de diagnostic adéquates sur l’exception, ils ne donnent pas accès à la mémoire tampon d’encodage ou de décodage.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Therefore, they do not allow invalid data to be replaced or corrected within the encoding or decoding method.</source>
          <target state="translated">Par conséquent, ils ne permettent pas le remplacement ou la correction des données non valides dans la méthode d'encodage ou de décodage.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Implementing a custom fallback strategy</source>
          <target state="translated">Implémentation d’une stratégie de secours personnalisée</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>In addition to the best-fit mapping that is implemented internally by code pages, .NET includes the following classes for implementing a fallback strategy:</source>
          <target state="translated">En plus du mappage le mieux adapté implémenté en interne par les pages de codes, .NET comprend les classes suivantes pour l’implémentation d’une stratégie de secours :</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> and <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> to replace characters in encoding operations.</source>
          <target state="translated">Utilisez <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> et <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> pour remplacer des caractères dans des opérations d’encodage.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>DecoderReplacementFallback<ept id="p1">](xref:System.Text.DecoderReplacementFallback)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> to replace characters in decoding operations.</source>
          <target state="translated">Utilisez <bpt id="p1">[</bpt>DecoderReplacementFallback<ept id="p1">](xref:System.Text.DecoderReplacementFallback)</ept> et <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> pour remplacer des caractères dans des opérations de décodage.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>EncoderExceptionFallback<ept id="p1">](xref:System.Text.EncoderExceptionFallback)</ept> and <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> to throw an <bpt id="p3">[</bpt>EncoderFallbackException<ept id="p3">](xref:System.Text.EncoderFallbackException)</ept> when a character cannot be encoded.</source>
          <target state="translated">Utilisez <bpt id="p1">[</bpt>EncoderExceptionFallback<ept id="p1">](xref:System.Text.EncoderExceptionFallback)</ept> et <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> pour lever une exception <bpt id="p3">[</bpt>EncoderFallbackException<ept id="p3">](xref:System.Text.EncoderFallbackException)</ept> quand un caractère ne peut pas être encodé.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>DecoderExceptionFallback<ept id="p1">](xref:System.Text.DecoderExceptionFallback)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> to throw a <bpt id="p3">[</bpt>DecoderFallbackException<ept id="p3">](xref:System.Text.DecoderFallbackException)</ept> when a character cannot be decoded.</source>
          <target state="translated">Utilisez <bpt id="p1">[</bpt>DecoderExceptionFallback<ept id="p1">](xref:System.Text.DecoderExceptionFallback)</ept> et <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> pour lever une exception <bpt id="p3">[</bpt>DecoderFallbackException<ept id="p3">](xref:System.Text.DecoderFallbackException)</ept> quand un caractère ne peut pas être décodé.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>In addition, you can implement a custom solution that uses best-fit fallback, replacement fallback, or exception fallback, by following these steps:</source>
          <target state="translated">En outre, vous pouvez implémenter une solution personnalisée qui utilise une stratégie de secours la mieux adaptée, une stratégie de secours pour les remplacements ou une stratégie de secours pour les exceptions, en procédant comme suit :</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Derive a class from <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> for decoding operations.</source>
          <target state="translated">Dérivez une classe d’<bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> pour les opérations d’encodage et de <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> pour les opérations de décodage.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Derive a class from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> for decoding operations.</source>
          <target state="translated">Dérivez une classe d’<bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> pour les opérations d’encodage et de <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> pour les opérations de décodage.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>For exception fallback, if the predefined <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> and <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> classes do not meet your needs, derive a class from an exception object such as <bpt id="p3">[</bpt>Exception<ept id="p3">](xref:System.Exception)</ept> or <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept>.</source>
          <target state="translated">Pour la stratégie de secours pour les exeptions, si les classes <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> et <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> ne répondent pas à vos besoins, dérivez une classe d’un objet d’exception comme <bpt id="p3">[</bpt>Exception<ept id="p3">](xref:System.Exception)</ept> ou <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Deriving from EncoderFallback or DecoderFallback</source>
          <target state="translated">Dérivation depuis EncoderFallback ou DecoderFallback</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>To implement a custom fallback solution, you must create a class that inherits from <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> for decoding operations.</source>
          <target state="translated">Pour implémenter une solution de stratégie de secours personnalisée, vous devez créer une classe qui hérite d’<bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> pour les opérations d’encodage, et de <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> pour les opérations de décodage.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Instances of these classes are passed to the <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> method and serve as the intermediary between the encoding class and the fallback implementation.</source>
          <target state="translated">Les instances de ces classes sont passées à la méthode <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> et servent d’intermédiaire entre la classe d’encodage et l’implémentation de la stratégie de secours.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>When you create a custom fallback solution for an encoder or decoder, you must implement the following members:</source>
          <target state="translated">Quand vous créez une solution de secours personnalisée pour un encodeur ou un décodeur, vous devez implémenter les membres suivants :</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallback.MaxCharCount<ept id="p1">](xref:System.Text.EncoderFallback.MaxCharCount)</ept> or <bpt id="p2">[</bpt>DecoderFallback.MaxCharCount<ept id="p2">](xref:System.Text.DecoderFallback.MaxCharCount)</ept> property, which returns the maximum possible number of characters that the best-fit, replacement, or exception fallback can return to replace a single character.</source>
          <target state="translated">La propriété <bpt id="p1">[</bpt>EncoderFallback.MaxCharCount<ept id="p1">](xref:System.Text.EncoderFallback.MaxCharCount)</ept> ou <bpt id="p2">[</bpt>DecoderFallback.MaxCharCount<ept id="p2">](xref:System.Text.DecoderFallback.MaxCharCount)</ept>, qui retourne le nombre maximal possible de caractères que les stratégies de secours la mieux adaptée, pour les remplacements ou pour les exceptions peuvent retourner pour remplacer un caractère unique.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>For a custom exception fallback, its value is zero.</source>
          <target state="translated">Pour une stratégie de secours pour les exceptions personnalisée, sa valeur est zéro.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> or <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> method, which returns your custom <bpt id="p3">[</bpt>EncoderFallbackBuffer<ept id="p3">](xref:System.Text.EncoderFallbackBuffer)</ept> or <bpt id="p4">[</bpt>DecoderFallbackBuffer<ept id="p4">](xref:System.Text.DecoderFallbackBuffer)</ept> implementation.</source>
          <target state="translated">La méthode <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> ou <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> qui retourne votre implémentation <bpt id="p3">[</bpt>EncoderFallbackBuffer<ept id="p3">](xref:System.Text.EncoderFallbackBuffer)</ept> ou <bpt id="p4">[</bpt>DecoderFallbackBuffer<ept id="p4">](xref:System.Text.DecoderFallbackBuffer)</ept> personnalisée.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The method is called by the encoder when it encounters the first character that it is unable to successfully encode, or by the decoder when it encounters the first byte that it is unable to successfully decode.</source>
          <target state="translated">La méthode est appelée par l'encodeur quand il rencontre le premier caractère qu'il est impossible d'encoder correctement, ou par le décodeur quand il rencontre le premier octet qu'il est impossible de décoder correctement.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Deriving from EncoderFallbackBuffer or DecoderFallbackBuffer</source>
          <target state="translated">Dérivation depuis EncoderFallbackBuffer ou DecoderFallbackBuffer</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>To implement a custom fallback solution, you must also create a class that inherits from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> for decoding operations.</source>
          <target state="translated">Pour implémenter une solution de stratégie de secours personnalisée, vous devez aussi créer une classe qui hérite d’<bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> pour les opérations d’encodage, et de <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> pour les opérations de décodage.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Instances of these classes are returned by the <ph id="ph1">`CreateFallbackBuffer`</ph> method of the <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> and <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> classes.</source>
          <target state="translated">Les instances de ces classes sont retournées par la méthode <ph id="ph1">`CreateFallbackBuffer`</ph> des classes <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> et <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> method is called by the encoder when it encounters the first character that it is not able to encode, and the <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> method is called by the decoder when it encounters one or more bytes that it is not able to decode.</source>
          <target state="translated">La méthode <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> est appelée par l’encodeur quand il rencontre le premier caractère qu’il ne peut pas encoder, et la méthode <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> est appelée par le décodeur quand il rencontre un ou plusieurs octets qu’il ne peut pas décoder.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> classes provide the fallback implementation.</source>
          <target state="translated">Les classes <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> et <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> fournissent l’implémentation de la stratégie de secours.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Each instance represents a buffer that contains the fallback characters that will replace the character that cannot be encoded or the byte sequence that cannot be decoded.</source>
          <target state="translated">Chaque instance représente une mémoire tampon qui contient les caractères de secours destinés à remplacer le caractère qui ne peut pas être encodé ou la séquence d'octets qui ne peut pas être décodée.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>When you create a custom fallback solution for an encoder or decoder, you must implement the following members:</source>
          <target state="translated">Quand vous créez une solution de secours personnalisée pour un encodeur ou un décodeur, vous devez implémenter les membres suivants :</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.%23ctor)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> method.</source>
          <target state="translated">La méthode <bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.%23ctor)</ept> ou <bpt id="p2">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Char,System.Int32))</ept> is called by the encoder to provide the fallback buffer with information about the character that it cannot encode.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Char,System.Int32))</ept> est appelée par l’encodeur pour fournir à la mémoire tampon de la stratégie de secours des informations concernant le caractère qu’elle ne peut pas encoder.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Because the character to be encoded may be a surrogate pair, this method is overloaded.</source>
          <target state="translated">Étant donné que le caractère à encoder peut être une paire de substitution, cette méthode est surchargée.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>One overload is passed the character to be encoded and its index in the string.</source>
          <target state="translated">Le caractère à encoder et son index dans la chaîne sont passés à une surcharge.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The second overload is passed the high and low surrogate along with its index in the string.</source>
          <target state="translated">La demi-zone haute et la demi-zone basse, ainsi que son index dans la chaîne, sont passés à la deuxième surcharge.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> method is called by the decoder to provide the fallback buffer with information about the bytes that it cannot decode.</source>
          <target state="translated">La méthode <bpt id="p1">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> est appelée par le décodeur pour fournir à la mémoire tampon de la stratégie de secours des informations sur les octets qu’elle ne peut pas décoder.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>This method is passed an array of bytes that it cannot decode, along with the index of the first byte.</source>
          <target state="translated">Cette méthode reçoit un tableau d'octets qu'elle ne peut pas décoder, ainsi que l'index du premier octet.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The fallback method should return <ph id="ph1">`true`</ph> if the fallback buffer can supply a best-fit or replacement character or characters; otherwise, it should return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">La méthode de secours doit retourner <ph id="ph1">`true`</ph> si la mémoire tampon de secours peut fournir un ou plusieurs caractères les mieux adaptés ou de remplacement ; sinon, elle doit retourner <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>For an exception fallback, the fallback method should throw an exception.</source>
          <target state="translated">Pour une stratégie de secours pour les exceptions, la méthode de secours doit lever une exception.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.GetNextChar<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.GetNextChar)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.GetNextChar<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.GetNextChar)</ept> method, which is called repeatedly by the encoder or decoder to get the next character from the fallback buffer.</source>
          <target state="translated">La méthode <bpt id="p1">[</bpt>EncoderFallbackBuffer.GetNextChar<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.GetNextChar)</ept> ou <bpt id="p2">[</bpt>DecoderFallbackBuffer.GetNextChar<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.GetNextChar)</ept>, qui est appelée à plusieurs reprises par l’encodeur ou le décodeur pour obtenir le caractère suivant de la mémoire tampon de la stratégie de secours.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>When all fallback characters have been returned, the method should return U+0000.</source>
          <target state="translated">Quand tous les caractères de secours ont été retournés, la méthode doit retourner U+0000.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.Remaining<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Remaining)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.Remaining<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Remaining)</ept> property, which returns the number of characters remaining in the fallback buffer.</source>
          <target state="translated">La propriété <bpt id="p1">[</bpt>EncoderFallbackBuffer.Remaining<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Remaining)</ept> ou <bpt id="p2">[</bpt>DecoderFallbackBuffer.Remaining<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Remaining)</ept>, qui retourne le nombre de caractères restants dans la mémoire tampon de la stratégie de secours.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.MovePrevious<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.MovePrevious)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.MovePrevious<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.MovePrevious)</ept> method, which moves the current position in the fallback buffer to the previous character.</source>
          <target state="translated">La méthode <bpt id="p1">[</bpt>EncoderFallbackBuffer.MovePrevious<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.MovePrevious)</ept> ou <bpt id="p2">[</bpt>DecoderFallbackBuffer.MovePrevious<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.MovePrevious)</ept>, qui déplace la position actuelle dans la mémoire tampon de la stratégie de secours vers le caractère précédent.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.Reset<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Reset)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.Reset<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Reset)</ept> method, which reinitializes the fallback buffer.</source>
          <target state="translated">La méthode <bpt id="p1">[</bpt>EncoderFallbackBuffer.Reset<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Reset)</ept> ou <bpt id="p2">[</bpt>DecoderFallbackBuffer.Reset<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Reset)</ept>, qui réinitialise la mémoire tampon de la stratégie de secours.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>If the fallback implementation is a best-fit fallback or a replacement fallback, the classes derived from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> also maintain two private instance fields: the exact number of characters in the buffer; and the index of the next character in the buffer to return.</source>
          <target state="translated">Si l’implémentation de la stratégie de secours est une stratégie de secours la mieux adaptée ou pour les remplacements, les classes dérivées d’<bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> et <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> gèrent également deux champs d’instance privés : le nombre exact de caractères dans la mémoire tampon et l’index du caractère suivant dans la mémoire tampon à retourner.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>An EncoderFallback example</source>
          <target state="translated">Exemple basé sur EncoderFallback</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>An earlier example used replacement fallback to replace Unicode characters that did not correspond to ASCII characters with an asterisk (<ph id="ph1">\*</ph>).</source>
          <target state="translated">L’exemple précédent utilisait une stratégie de sauvegarde pour les remplacements pour remplacer les caractères Unicode qui ne correspondaient pas aux caractères ASCII par un astérisque (<ph id="ph1">\*</ph>).</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The following example uses a custom best-fit fallback implementation instead to provide a better mapping of non-ASCII characters.</source>
          <target state="translated">L'exemple suivant utilise à la place une implémentation de stratégie de secours la mieux adaptée personnalisée pour fournir un meilleur mappage des caractères non-ASCII.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The following code defines a class named <ph id="ph1">`CustomMapper`</ph> that is derived from <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> to handle the best-fit mapping of non-ASCII characters.</source>
          <target state="translated">Le code suivant définit une classe nommée <ph id="ph1">`CustomMapper`</ph> qui est dérivée d’<bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> pour gérer le mappage le mieux adapté des caractères non-ASCII.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`CreateFallbackBuffer`</ph> method returns a <ph id="ph2">`CustomMapperFallbackBuffer`</ph> object, which provides the <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> implementation.</source>
          <target state="translated">Sa méthode <ph id="ph1">`CreateFallbackBuffer`</ph> renvoie un objet <ph id="ph2">`CustomMapperFallbackBuffer`</ph>, qui fournit l’implémentation <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CustomMapper`</ph> class uses a <bpt id="p1">[</bpt>Dictionary<ph id="ph2">&amp;lt;</ph>TKey, TValue<ph id="ph3">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.Dictionary%602)</ept> object to store the mappings of unsupported Unicode characters (the key value) and their corresponding 8-bit characters (which are stored in two consecutive bytes in a 64-bit integer).</source>
          <target state="translated">La classe <ph id="ph1">`CustomMapper`</ph> utilise un objet <bpt id="p1">[</bpt>Dictionary<ph id="ph2">&amp;lt;</ph>TKey, TValue<ph id="ph3">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.Dictionary%602)</ept> pour stocker les mappages des caractères Unicode non pris en charge (la valeur de la clé) et leurs caractères 8 bits correspondants (qui sont stockés dans deux octets consécutifs dans un entier 64 bits).</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>To make this mapping available to the fallback buffer, the <ph id="ph1">`CustomMapper`</ph> instance is passed as a parameter to the <ph id="ph2">`CustomMapperFallbackBuffer`</ph> class constructor.</source>
          <target state="translated">Pour que ce mappage soit disponible pour la mémoire tampon de secours, l'instance de <ph id="ph1">`CustomMapper`</ph> est passée comme paramètre au constructeur de classe <ph id="ph2">`CustomMapperFallbackBuffer`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Because the longest mapping is the string "INF" for the Unicode character U+221E, the <ph id="ph1">`MaxCharCount`</ph> property returns 3.</source>
          <target state="translated">Comme le mappage le plus long est la chaîne "INF" pour le caractère Unicode U+221E, la propriété <ph id="ph1">`MaxCharCount`</ph> retourne 3.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The following code defines the <ph id="ph1">`CustomMapperFallbackBuffer`</ph> class, which is derived from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>.</source>
          <target state="translated">Le code suivant définit la classe <ph id="ph1">`CustomMapperFallbackBuffer`</ph>, qui est dérivée d’<bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The dictionary that contains best-fit mappings and that is defined in the <ph id="ph1">`CustomMapper`</ph> instance is available from its class constructor.</source>
          <target state="translated">Le dictionnaire qui contient les mappages les mieux adaptés et qui est défini dans l'instance de <ph id="ph1">`CustomMapper`</ph> est disponible à partir de son constructeur de classe.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`Fallback`</ph> method returns <ph id="ph2">`true`</ph> if any of the Unicode characters that the ASCII encoder cannot encode are defined in the mapping dictionary; otherwise, it returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Sa méthode <ph id="ph1">`Fallback`</ph> retourne <ph id="ph2">`true`</ph> si un des caractères Unicode que l'encodeur ASCII ne peut pas encoder est défini dans le dictionnaire de mappage ; sinon, elle retourne <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>For each fallback, the private <ph id="ph1">`count`</ph> variable indicates the number of characters that remain to be returned, and the private <ph id="ph2">`index`</ph> variable indicates the position in the string buffer, <ph id="ph3">`charsToReturn`</ph>, of the next character to return.</source>
          <target state="translated">Pour chaque stratégie de secours, la variable privée <ph id="ph1">`count`</ph> indique le nombre de caractères qui restent à retourner, et la variable privée <ph id="ph2">`index`</ph> indique la position du caractère suivant à retourner dans la mémoire tampon de la chaîne, <ph id="ph3">`charsToReturn`</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The following code then instantiates the <ph id="ph1">`CustomMapper`</ph> object and passes an instance of it to the <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> method.</source>
          <target state="translated">Le code suivant instancie ensuite l’objet <ph id="ph1">`CustomMapper`</ph> et passe une instance de celui-ci à la méthode <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The output indicates that the best-fit fallback implementation successfully handles the three non-ASCII characters in the original string.</source>
          <target state="translated">La sortie indique que l'implémentation de la stratégie de secours la mieux adaptée gère correctement les trois caractères non-ASCII de la chaîne d'origine.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.Encoder<ept id="p1">](xref:System.Text.Encoder)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.Encoder<ept id="p1">](xref:System.Text.Encoder)</ept></target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept></target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.Decoder<ept id="p1">](xref:System.Text.Decoder)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.Decoder<ept id="p1">](xref:System.Text.Decoder)</ept></target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.DecoderFallback<ept id="p1">](xref:System.Text.DecoderFallback)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.DecoderFallback<ept id="p1">](xref:System.Text.DecoderFallback)</ept></target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>