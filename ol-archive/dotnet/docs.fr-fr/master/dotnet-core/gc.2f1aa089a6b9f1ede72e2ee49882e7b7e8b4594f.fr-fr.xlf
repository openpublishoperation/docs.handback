<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">36423ac3248b14a9bb95611d5997d06b927fa88e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\garbagecollection\gc.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5fddc7c4d814369615344ef28602633d8736b4ec</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1337b68771f95336d70594d78f544bfa19cfa815</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Automatic memory management and garbage collection</source>
          <target state="translated">Gestion automatique de la mémoire et garbage collection</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Automatic memory management and garbage collection</source>
          <target state="translated">Gestion automatique de la mémoire et garbage collection</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Automatic memory management and garbage collection</source>
          <target state="translated">Gestion automatique de la mémoire et garbage collection</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Automatic memory management is one of the services that the Common Language Runtime provides during managed execution.</source>
          <target state="translated">La gestion automatique de la mémoire est un des services que le Common Language Runtime fournit au cours de l'exécution managée.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The Common Language Runtime's garbage collector manages the allocation and release of memory for an application.</source>
          <target state="translated">Le Garbage collector du Common Language Runtime gère l’allocation et la libération de mémoire pour une application.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For developers, this means that you do not have to write code to perform memory management tasks when you develop managed applications.</source>
          <target state="translated">Les développeurs n’ont donc plus à écrire du code pour exécuter leurs tâches de gestion de mémoire lors du développement d’applications managées.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak, or attempting to access memory for an object that has already been freed.</source>
          <target state="translated">La gestion automatique de la mémoire permet d'éliminer des problèmes fréquents tels que l'oubli de libération d'un objet ou les fuites de mémoire ou encore les tentatives d'accès à la mémoire à la recherche d'un objet qui a déjà été libéré.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This section describes how the garbage collector allocates and releases memory.</source>
          <target state="translated">Cette section décrit la façon dont le « garbage collector » alloue et libère la mémoire.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Allocating Memory</source>
          <target state="translated">Allocation de mémoire</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</source>
          <target state="translated">Lorsque vous initialisez un nouveau processus, le runtime réserve une région d'espace d'adressage contigu pour le processus.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This reserved address space is called the managed heap.</source>
          <target state="translated">Cet espace d'adressage est appelé le tas managé.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</source>
          <target state="translated">Le tas managé garde un pointeur vers l'adresse qui sera allouée au nouvel objet du tas.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Initially, this pointer is set to the managed heap's base address.</source>
          <target state="translated">À l’origine, ce pointeur indique l’adresse de base du tas managé.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>All reference types are allocated on the managed heap.</source>
          <target state="translated">Tous les types référence sont alloués sur le tas managé.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</source>
          <target state="translated">Lorsqu’une application crée le premier type référence, la mémoire est allouée pour le type à l’adresse de base du tas managé.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</source>
          <target state="translated">Lorsque l'application crée l'objet suivant, le « garbage collector » lui alloue de la mémoire dans l'espace d'adressage qui suit immédiatement le premier objet.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</source>
          <target state="translated">Aussi longtemps que de l'espace d'adressage est disponible, le « garbage collector » continue à allouer de l'espace pour de nouveaux objets selon la même procédure.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Allocating memory from the managed heap is faster than unmanaged memory allocation.</source>
          <target state="translated">L'allocation de mémoire à partir du tas managé est plus rapide que l'allocation de mémoire non managée.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Because the runtime allocates memory for an object by adding a value to a pointer, it is almost as fast as allocating memory from the stack.</source>
          <target state="translated">Étant donné que le runtime alloue de la mémoire pour un objet en ajoutant une valeur à un pointeur, elle est pratiquement aussi rapide que l'allocation de mémoire à partir de la pile.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects very quickly.</source>
          <target state="translated">En outre, puisque les nouveaux objets auxquels un espace mémoire est alloué sont stockés à la suite dans le tas managé, une application peut accéder très rapidement aux objets.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Releasing Memory</source>
          <target state="translated">Libération de la mémoire</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</source>
          <target state="translated">Le moteur d'optimisation du « garbage collector » détermine le meilleur moment pour lancer une opération garbage collection sur base des allocations de mémoire effectuées.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</source>
          <target state="translated">Lorsque le « garbage collector » effectue une opération garbage collection, il libère la mémoire pour les objets qui ne sont plus utilisées par l'application.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It determines which objects are no longer being used by examining the application's roots.</source>
          <target state="translated">Il détermine les objets qui ne sont plus utilisés en examinant les racines de l'application.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Every application has a set of roots.</source>
          <target state="translated">Chaque application possède un jeu de racines.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Each root either refers to an object on the managed heap or is set to null.</source>
          <target state="translated">Chaque racine fait référence à un objet du tas managé ou, à défaut, a la valeur Null.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</source>
          <target state="translated">Les racines de l’application comprennent des champs statiques, des variables et des paramètres locaux sur la pile d’un thread et des Registres du processeur.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The garbage collector has access to the list of active roots that the just-in-time (JIT) compiler and the runtime maintain.</source>
          <target state="translated">Le Garbage collector a accès à la liste des racines actives entretenues par le compilateur juste-à-temps (JIT) et le runtime.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Using this list, it examines an application's roots, and in the process creates a graph that contains all the objects that are reachable from the roots.</source>
          <target state="translated">En utilisant cette liste, il examine des racines d'application et crée, au cours du processus, un graphique qui contient tous les objets accessibles à partir des racines.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Objects that are not in the graph are unreachable from the application's roots.</source>
          <target state="translated">Les objets non compris dans le graphique ne sont pas accessibles à partir des racines de l'application.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The garbage collector considers unreachable objects garbage and will release the memory allocated for them.</source>
          <target state="translated">Le « garbage collector » examine les objets inaccessibles et libère la mémoire qui leur a été allouée.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</source>
          <target state="translated">Au cours d'une opération garbage collection, le « garbage collector » examine le tas managé pour y détecter les blocs de mémoire occupés par des objets inaccessibles.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</source>
          <target state="translated">Chaque fois qu'il détecte un objet inaccessible, il utilise une fonction de copie de mémoire pour compacter les objets accessibles en mémoire et libérer les blocs d'espaces d'adressage alloués aux objets inaccessibles.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</source>
          <target state="translated">Lorsque la mémoire allouée aux objets accessibles a été réduite, le « garbage collector » procède aux corrections de pointeurs nécessaires pour que les racines des applications pointent vers les nouveaux emplacements des objets.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>It also positions the managed heap's pointer after the last reachable object.</source>
          <target state="translated">Il positionne aussi le pointeur du tas managé après le dernier objet accessible.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Note that memory is compacted only if a collection discovers a significant number of unreachable objects.</source>
          <target state="translated">Vous remarquerez que la mémoire est compactée uniquement si une collection détecte un nombre significatif d'objets inaccessibles.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</source>
          <target state="translated">Si tous les objets du tas managé survivent à une collection, il n'est pas nécessaire de procéder à un compactage de la mémoire.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>To improve performance, the runtime allocates memory for large objects in a separate heap.</source>
          <target state="translated">Pour améliorer les performances, le runtime alloue de la mémoire pour les objets de grandes dimensions dans un tas séparé.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The garbage collector automatically releases the memory for large objects.</source>
          <target state="translated">Le « garbage collector » libère automatiquement la mémoire des objets de grande dimension.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>However, to avoid moving large objects in memory, this memory is not compacted.</source>
          <target state="translated">Cependant, pour éviter de déplacer de grands objets en mémoire, la mémoire n'est pas compactée.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Generations and Performance</source>
          <target state="translated">Générations et performances</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>To optimize the performance of the garbage collector, the managed heap is divided into three generations: 0, 1, and 2.</source>
          <target state="translated">Pour optimiser les performances du garbage collector, le tas managé est divisé en trois générations : 0, 1 et 2.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The runtime's garbage collection algorithm is based on several generalizations that the computer software industry has discovered to be true by experimenting with garbage collection schemes.</source>
          <target state="translated">L'algorithme de garbage collection du runtime est basé sur plusieurs généralisations que l'industrie informatique a observées en expérimentant des modèles de garbage collection.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>First, it is faster to compact the memory for a portion of the managed heap than for the entire managed heap.</source>
          <target state="translated">En premier lieu, il est plus rapide de compacter la mémoire pour une partie du tas managé que pour le tas tout entier.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Secondly, newer objects will have shorter lifetimes and older objects will have longer lifetimes.</source>
          <target state="translated">Deuxièmement, les nouveaux objets ont des durées de vie plus courtes que les objets plus anciens.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Lastly, newer objects tend to be related to each other and accessed by the application around the same time.</source>
          <target state="translated">Enfin, les nouveaux objets sont fréquemment liés entre eux et l'application y accède à peu près au même moment.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The runtime's garbage collector stores new objects in generation 0.</source>
          <target state="translated">Le garbage collector du runtime stocke les nouveaux objets dans la génération 0.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</source>
          <target state="translated">Les objets qui sont créés à un stade précoce de la durée de vie de l'application et qui survivent aux collectes sont promus et stockés dans les générations 1 et 2.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The process of object promotion is described later in this topic.</source>
          <target state="translated">Le processus de promotion d'objet est décrit ultérieurement dans cette rubrique.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Because it is faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</source>
          <target state="translated">Parce qu'il est plus rapide de compacter une partie du tas managé que le tas tout entier, ce schéma permet au « garbage collector » de libérer la mémoire dans une génération spécifique plutôt que de libérer la mémoire de l'intégralité du tas managé chaque fois qu'une opération garbage collection est effectuée.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>In reality, the garbage collector performs a collection when generation 0 is full.</source>
          <target state="translated">En fait, le « garbage collector » procède à une opération collection lorsque la génération 0 est complète.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>If an application attempts to create a new object when generation 0 is full, the garbage collector discovers that there is no address space remaining in generation 0 to allocate for the object.</source>
          <target state="translated">Si une application tente de créer un nouvel objet lorsque la génération 0 est complète, le « garbage collector » observe qu'il n'y a plus d'espace d'adressage disponible dans la génération 0 à allouer à l'objet.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The garbage collector performs a collection in an attempt to free address space in generation 0 for the object.</source>
          <target state="translated">Le « garbage collector » effectue une opération garbage collection en essayant de libérer de l'espace d'adressage pour l'objet dans la génération 0.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</source>
          <target state="translated">Le « garbage collector » commence par examiner les objets de la génération 0 plutôt que tous les objets du tas managé.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This is the most efficient approach, because new objects tend to have short lifetimes, and it is expected that many of the objects in generation 0 will no longer be in use by the application when a collection is performed.</source>
          <target state="translated">Cette approche est la plus efficace parce que les nouveaux objets ont en règle générale une durée de vie courte et qu'une grande part des objets de la génération 0 ne seront plus utilisés par l'application lorsqu'une opération garbage collection sera effectuée.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In addition, a collection of generation 0 alone often reclaims enough memory to allow the application to continue creating new objects.</source>
          <target state="translated">En outre, une opération garbage collection de la génération 0 récupère souvent à elle seule suffisamment de mémoire pour permettre à l’application de continuer à créer de nouveaux objets.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects as explained in <bpt id="p1">[</bpt>Releasing Memory<ept id="p1">](#releasing-memory)</ept> earlier in this topic.</source>
          <target state="translated">Après avoir effectué une collection de génération 0, le Garbage collector compacte la mémoire pour les objets accessibles comme expliqué dans la section <bpt id="p1">[</bpt>Libération de la mémoire<ept id="p1">](#releasing-memory)</ept>, plus haut dans cette rubrique.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The garbage collector then promotes these objects and considers this portion of the managed heap generation 1.</source>
          <target state="translated">Le garbage collector promeut ensuite ces objets et considère que cette partie du tas managé appartient à la génération 1.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</source>
          <target state="translated">Étant donné que les objets qui survivent aux collectes ont tendance à avoir de plus longues durées de vie, il est logique de les promouvoir à une génération supérieure.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>As a result, the garbage collector does not have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</source>
          <target state="translated">En conséquence, le « garbage collector »n'a pas à réexaminer les objets des générations 1 et 2 chaque fois qu'il effectue une opération garbage collection de la génération 0.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>After the garbage collector performs its first collection of generation 0 and promotes the reachable objects to generation 1, it considers the remainder of the managed heap generation 0.</source>
          <target state="translated">Après avoir exécuté sa première opération garbage collection de la génération 0 et promu les objets accessibles à la génération 1, le garbage collector considère que le reste du tas managé appartient à la génération 0.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>It continues to allocate memory for new objects in generation 0 until generation 0 is full and it is necessary to perform another collection.</source>
          <target state="translated">Il continue à allouer de la mémoire pour les nouveaux objets de la génération 0 jusqu'à ce qu'elle soit complète et qu'il soit nécessaire d'effectuer une autre collecte.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>At this point, the garbage collector's optimizing engine determines whether it is necessary to examine the objects in older generations.</source>
          <target state="translated">À ce stade, le moteur d'optimisation du « garbage collector » détermine s'il est nécessaire d'examiner les objets des générations plus anciennes.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For example, if a collection of generation 0 does not reclaim enough memory for the application to successfully complete its attempt to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</source>
          <target state="translated">Par exemple, si une collecte de génération 0 ne libère pas assez de mémoire pour que l'application puisse terminer sa création d'objet, le garbage collector peut exécuter une collecte de génération 1, puis de génération 2.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If this does not reclaim enough memory, the garbage collector can perform a collection of generations 2, 1, and 0.</source>
          <target state="translated">Si cela ne libère pas assez de mémoire, le garbage collector peut exécuter une collecte de génération 2, 1 et 0.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>After each collection, the garbage collector compacts the reachable objects in generation 0 and promotes them to generation 1.</source>
          <target state="translated">Après chaque collecte, le garbage collector condense les objets accessibles dans la génération 0 et les promeut à la génération 1.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Objects in generation 1 that survive collections are promoted to generation 2.</source>
          <target state="translated">Les objets qui survivent aux collectes sont promus et stockés dans les générations 1 et 2.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Because the garbage collector supports only three generations, objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</source>
          <target state="translated">Comme le garbage collector ne prend en charge que trois générations, les objets de génération 2 qui survivent à une collecte restent dans la génération 2 jusqu'à ce qu'ils soient considérés comme impossibles à atteindre lors d'une prochaine collecte.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Releasing Memory for Unmanaged Resources</source>
          <target state="translated">Libération de mémoire pour des ressources non managées</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For the majority of the objects that your application creates, you can rely on the garbage collector to automatically perform the necessary memory management tasks.</source>
          <target state="translated">Pour la majorité des objets créés par votre application, vous pouvez laisser au « garbage collector » le soin de réaliser automatiquement les tâches de gestion de mémoire requises.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>However, unmanaged resources require explicit cleanup.</source>
          <target state="translated">Cependant, les ressources non managées requièrent un nettoyage explicite.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</source>
          <target state="translated">Le type le plus répandu de ressource non managée est un objet qui enveloppe une ressource de système d'exploitation telle qu'un handle de fichier ou de fenêtre ou une connexion réseau.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it does not have specific knowledge about how to clean up the resource.</source>
          <target state="translated">Bien que le « garbage collector » soit en mesure de suivre la durée de vie d'un objet managé qui encapsule une ressource non managée, il ne possède pas de connaissances spécifiques sur la façon de nettoyer une ressource.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>When you create an object that encapsulates an unmanaged resource, it is recommended that you provide the necessary code to clean up the unmanaged resource in a public <ph id="ph1">`Dispose`</ph> method.</source>
          <target state="translated">Lors de la création d’un objet qui encapsule une ressource non managée, il est recommandé de fournir le code nécessaire pour nettoyer la ressource non managée dans une méthode <ph id="ph1">`Dispose`</ph> publique.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>By providing a <ph id="ph1">`Dispose`</ph> method, you enable users of your object to explicitly free its memory when they are finished with the object.</source>
          <target state="translated">En fournissant une méthode <ph id="ph1">`Dispose`</ph>, vous donnez la possibilité aux utilisateurs de votre objet d’en libérer explicitement la mémoire lorsqu’ils ont fini de s’en servir.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>When you use an object that encapsulates an unmanaged resource, you should be aware of <ph id="ph1">`Dispose`</ph> and call it as necessary.</source>
          <target state="translated">Lorsque vous utilisez un objet qui encapsule une ressource non managée, vous devez garder à l’esprit la méthode <ph id="ph1">`Dispose`</ph> et l’appeler si nécessaire.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For more information about cleaning up unmanaged resources and an example of a design pattern for implementing <ph id="ph1">`Dispose`</ph>, see <bpt id="p1">[</bpt>Garbage Collection in .NET<ept id="p1">](index.md)</ept>.</source>
          <target state="translated">Pour obtenir plus d’informations sur le nettoyage de ressources non managées et un exemple de modèle de conception pour l’implémentation de la méthode <ph id="ph1">`Dispose`</ph>, consultez <bpt id="p1">[</bpt>Garbage collection dans le .NET<ept id="p1">](index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.GC<ept id="p1">](xref:System.GC)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.GC<ept id="p1">](xref:System.GC)</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Garbage collection in .NET<ept id="p1">](index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Garbage collection dans le .NET<ept id="p1">](index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>