<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-f0362aa" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">83555650a5a3ce9ed28d329aa82f5ead75e2d9cb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tools\test-protocol.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e618b25e49aa9cb637676c5386d24f07f432c88f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a314c30f40aa822195fbc4b01331f6093852380c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol | Microsoft Docs</source>
          <target state="translated">Protocole de communication de test des outils CLI .NET Core │ Microsoft Docs</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">Protocole de communication de test des outils CLI .NET Core</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">Protocole de communication de test des outils CLI .NET Core</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic applies to .NET Core Tools Preview 2.</source>
          <target state="translated">Cette rubrique s'applique aux outils .NET Core Preview 2.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For the .NET Core Tools RC4 documentation, see the <bpt id="p1">[</bpt>.NET Core command-line interface tools (.NET Core Tools RC4)<ept id="p1">](../preview3/tools/index.md)</ept> section.</source>
          <target state="translated">Pour obtenir la documentation sur les outils .NET Core RC4, consultez la section <bpt id="p1">[</bpt>Outils de l’interface de ligne de commande .NET Core (outils .NET Core RC4)<ept id="p1">](../preview3/tools/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Anytime you pass a port to dotnet test, the command will run in design time.</source>
          <target state="translated">Chaque fois que vous passez un port à dotnet-test, la commande est exécutée au moment du design.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>That means that <ph id="ph1">`dotnet test`</ph> will connect to that port using TCP and will then exchange an established set of messages with whatever else is connected to that port.</source>
          <target state="translated">Cela signifie que <ph id="ph1">`dotnet test`</ph> se connecte à ce port à l’aide du protocole TCP et qu’il échange ensuite un ensemble établi de messages avec les autres éléments connectés à ce port.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When this happens, the runner also receives a new port that <ph id="ph1">`dotnet test`</ph> will use to communicate with it.</source>
          <target state="translated">Quand cela se produit, le Test Runner reçoit également un nouveau port qui est utilisé par <ph id="ph1">`dotnet test`</ph> pour communiquer avec lui.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The reason why the runner also uses TCP to communicate with <ph id="ph1">`dotnet test`</ph> is because in design mode, it is not sufficient to just output results to the console.</source>
          <target state="translated">Le Test Runner utilise également le protocole TCP pour communiquer avec <ph id="ph1">`dotnet test`</ph>, car en mode Design, il ne suffit pas d’afficher les résultats dans la console.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The command needs to send the adapter structure messages containing the results of the test execution.</source>
          <target state="translated">La commande doit envoyer les messages concernant la structure de l’adaptateur qui contiennent les résultats de l’exécution du test.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Communication protocol at design time.</source>
          <target state="translated">Protocole de communication au moment du design</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Because during design time, <ph id="ph1">`dotnet test`</ph> connects to a port when it starts up, the adapter needs to be listening on that port otherwise <ph id="ph2">`dotnet test`</ph> will fail.</source>
          <target state="translated">Étant donné qu’au moment du design, <ph id="ph1">`dotnet test`</ph> se connecte à un port quand il démarre, l’adaptateur doit écouter ce port, sinon <ph id="ph2">`dotnet test`</ph> échoue.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>We did it like this so that the adapter could reserve all the ports it needs by binding and listening to them before <ph id="ph1">`dotnet test`</ph> ran and tried to get ports for the runner.</source>
          <target state="translated">De cette façon, l’adaptateur peut réserver tous les ports dont il a besoin en établissant une liaison avec ces ports et en les écoutant avant que <ph id="ph1">`dotnet test`</ph> ne soit exécuté et tente d’obtenir des ports pour le Test Runner.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Once <ph id="ph1">`dotnet test`</ph> starts, it sends a TestSession.Connected message to the adapter indicating that it is ready to receive messages.</source>
          <target state="translated">Une fois <ph id="ph1">`dotnet test`</ph> démarré, il envoie un message TestSession.Connected à l’adaptateur indiquant qu’il est prêt à recevoir des messages.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>It is possible to send an optional <bpt id="p1">[</bpt>version check<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept> message with the adapter version of the protocol in it.</source>
          <target state="translated">Il est possible d’envoyer un message facultatif de <bpt id="p1">[</bpt>vérification de la version<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept> contenant la version de l’adaptateur du protocole.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dotnet test`</ph> will send back the version of the protocol that it supports.</source>
          <target state="translated"><ph id="ph1">`dotnet test`</ph> renvoie ensuite la version du protocole qu’il prend en charge.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>All messages have the format described here: <bpt id="p1">[</bpt>Message.cs<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>.</source>
          <target state="translated">Tous les messages ont le format décrit ici : <bpt id="p1">[</bpt>Message.cs<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The payload formats for each message is described in links to the classes used to serialize/deserialize the information in the description of the protocol.</source>
          <target state="translated">Pour connaître le format de charge utile de chaque message, cliquez sur les liens associés aux classes utilisées pour sérialiser/désérialiser les informations contenues dans la description du protocole.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Test Execution</source>
          <target state="translated">Exécution de tests</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Test Execution</source>
          <target state="translated">Exécution de tests</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>After the optional version check, the adapter sends a TestExecution.GetTestRunnerProcessStartInfo, with the <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> it wants to execute inside of it.</source>
          <target state="translated">Après la vérification de version facultative, l’adaptateur envoie un TestExecution.GetTestRunnerProcessStartInfo, contenant les <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> qu’il souhaite exécuter.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dotnet test`</ph> sends back a FileName and Arguments inside a <bpt id="p1">[</bpt>TestStartInfo<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/dotnet/commands/dotnet-test/TestStartInfo.cs)</ept> payload that the adapter can use to start the runner.</source>
          <target state="translated"><ph id="ph1">`dotnet test`</ph> renvoie des éléments FileName et Arguments dans une charge utile <bpt id="p1">[</bpt>TestStartInfo<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/dotnet/commands/dotnet-test/TestStartInfo.cs)</ept>, que l’adaptateur peut utiliser pour démarrer le Test Runner.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>In the past, we would send the list of tests to run as part of that argument, but we were actually going over the command line size limit for some test projects.</source>
          <target state="translated">Auparavant, la liste des tests à exécuter était envoyée dans le cadre de l’argument. Toutefois, pour certains projets de test, cela provoquait le dépassement de la taille limite autorisée par la ligne de commande.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>As part of the arguments, we send a port that the runner should connect to and for executing tests, a --wait-command flag, that indicates that the runner should connect to the port and wait for commands, instead of going ahead and executing the tests.</source>
          <target state="translated">Dans le cadre de ces arguments, nous envoyons un port auquel le Test Runner doit se connecter, et, pour l’exécution des tests, un indicateur --wait-command, qui indique que le Test Runner doit se connecter au port et attendre les commandes, au lieu de poursuivre l’exécution des tests.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>At this point, the adapter can launch the runner (and attach to it for debugging if it chooses to).</source>
          <target state="translated">À ce stade, l’adaptateur peut lancer le Test Runner (et s’attacher à celui-ci pour le débogage, le cas échéant).</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Once the runner starts, it sends <ph id="ph1">`dotnet test`</ph> a TestRunner.WaitCommand message that indicates it is ready to receive commands, at which point <ph id="ph2">`dotnet test`</ph> sends a TestRunner.Execute with the list of <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> to run.</source>
          <target state="translated">Une fois le Test Runner démarré, il envoie à <ph id="ph1">`dotnet test`</ph> un message TestRunner.WaitCommand indiquant qu’il est prêt à recevoir des commandes. <ph id="ph2">`dotnet test`</ph> envoie alors un message TestRunner.Execute avec la liste des <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> à exécuter.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This bypasses the command line size limit described above.</source>
          <target state="translated">Cela permet de contourner la limite de taille de ligne de commande décrite ci-dessus.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The runner then sends <ph id="ph1">`dotnet test`</ph> (and it passes forward to the adapter) a TestExecution.TestStarted for each tests as they start with the <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> information inside of it.</source>
          <target state="translated">Le Test Runner envoie ensuite à <ph id="ph1">`dotnet test`</ph> (qui le transfère à l’adaptateur) un message TestExecution.TestStarted contenant les informations de <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> au début de chaque test.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The runner also sends <ph id="ph1">`dotnet test`</ph> (and it forwards to the adapter) a TestExecution.TestResult for each test with the <bpt id="p1">[</bpt>individual result<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept> of the test.</source>
          <target state="translated">Le Test Runner envoie également à <ph id="ph1">`dotnet test`</ph> (qui le transfère à l’adaptateur) un message TestExecution.TestResult contenant le <bpt id="p1">[</bpt>résultat individuel<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept> de chaque test.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>After all tests finish, the runner sends a TestRunner.Completed message to dotnet test, which <ph id="ph1">`dotnet test`</ph> sends as TestExecution.Completed to the adapter.</source>
          <target state="translated">Une fois tous les tests terminés, le Test Runner envoie un message TestRunner.Completed à dotnet test, que <ph id="ph1">`dotnet test`</ph> envoie comme message TestExecution.Completed à l’adaptateur.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Once the adapter is done, it sends <ph id="ph1">`dotnet test`</ph> a TestSession.Terminate which will cause <ph id="ph2">`dotnet test`</ph> to shutdown.</source>
          <target state="translated">Quand l’adaptateur a terminé, il envoie à <ph id="ph1">`dotnet test`</ph> un message TestSession.Terminate qui entraîne l’arrêt de <ph id="ph2">`dotnet test`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Test discovery</source>
          <target state="translated">Découverte des tests</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Test discovery</source>
          <target state="translated">Découverte des tests</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>After the optional version check, the adapter sends a TestDiscovery.Start message.</source>
          <target state="translated">Après la vérification de version facultative, l’adaptateur envoie un message TestDiscovery.Start.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Because in this case, the adapter does not need to attach to the process, <ph id="ph1">`dotnet test`</ph> will start the runner itself.</source>
          <target state="translated">Dans ce cas, l’adaptateur n’a pas besoin d’être attaché au processus. <ph id="ph1">`dotnet test`</ph> démarre donc le Test Runner lui-même.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Also, since there is no long list of arguments to be passed to the runner, no --wait-command flag is needed to be passed to the runner.</source>
          <target state="translated">De plus, puisque vous n’avez pas à passer une longue liste d’arguments au Test Runner, il est inutile de lui passer l’indicateur --wait-command.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dotnet test`</ph> only passes a --list argument to the runner, which means the runner should not run the tests, just list them.</source>
          <target state="translated"><ph id="ph1">`dotnet test`</ph> passe uniquement un argument --list au Test Runner, ce qui signifie que ce dernier ne doit pas exécuter les tests, mais simplement les répertorier.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The runner then sends <ph id="ph1">`dotnet test`</ph> (and it passes forward to the adapter) a TestDiscovery.TestFound for each <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> found.</source>
          <target state="translated">Le Test Runner envoie ensuite à <ph id="ph1">`dotnet test`</ph> (qui le transfère ensuite à l’adaptateur) un message TestDiscovery.TestFound pour chaque <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> trouvé.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>After all tests are discovered, the runner sends a TestRunner.Completed message to dotnet test, which <ph id="ph1">`dotnet test`</ph> sends as TestDiscovery.Completed to the adapter.</source>
          <target state="translated">Une fois tous les tests découverts, le Test Runner envoie un message TestRunner.Completed à dotnet test, que <ph id="ph1">`dotnet test`</ph> envoie comme message TestDiscovery.Completed à l’adaptateur.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Once the adapter is done, it sends <ph id="ph1">`dotnet test`</ph> a TestSession.Terminate which will cause <ph id="ph2">`dotnet test`</ph> to shutdown.</source>
          <target state="translated">Quand l’adaptateur a terminé, il envoie à <ph id="ph1">`dotnet test`</ph> un message TestSession.Terminate qui entraîne l’arrêt de <ph id="ph2">`dotnet test`</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>