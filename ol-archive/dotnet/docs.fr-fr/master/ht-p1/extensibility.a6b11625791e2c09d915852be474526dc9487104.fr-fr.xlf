<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4223f296224c9b62c88b72f0f643c8b8b6fc9f6b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tools\extensibility.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b6fec3e8b7b8e43a49178e846ebc37853a638b6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3948c7ede4e56778f4a4a5cd5b52f78ff3096855</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">Modèle d’extensibilité des outils CLI .NET Core</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">Modèle d’extensibilité des outils CLI .NET Core</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>CLI, extensibility, custom commands, .NET Core</source>
          <target state="translated">CLI, extensibilité, commandes personnalisées, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">Modèle d’extensibilité des outils CLI .NET Core</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Vue d'ensemble</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This document will cover the main ways how to extend the CLI tools and explain the scenarios that drive each of them.</source>
          <target state="translated">Ce document explique les principales méthodes permettant d’étendre les outils CLI, et décrit les scénarios dans lesquels elles sont utilisées.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It will the outline how to consume the tools as well as provide short notes on how to build both types of tools.</source>
          <target state="translated">Ce document décrit comment utiliser les outils et explique brièvement comment créer ces deux types d’outils.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How to extend CLI tools</source>
          <target state="translated">Extension des outils CLI</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The CLI tools can be extended in two main ways:</source>
          <target state="translated">Les outils CLI peuvent être étendus de deux façons :</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Via NuGet packages on a per-project basis</source>
          <target state="translated">Via les packages NuGet, par projet</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Via the system's PATH</source>
          <target state="translated">Via le chemin (PATH) du système</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The two extensibility mechanisms outlined above are not exclusive; you can use both or just one.</source>
          <target state="translated">Les deux mécanismes d’extensibilité présentés ci-dessus ne sont pas exclusifs. Vous pouvez n’en utiliser qu’un ou les deux à la fois.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Which one to pick depends largely on what is the goal you are trying to achieve with your extension.</source>
          <target state="translated">Le choix de la méthode dépend en grande partie de l’objectif de votre extension.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Per-project based extensibility</source>
          <target state="translated">Extensibilité par projet</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Per-project tools are <bpt id="p1">[</bpt>portable console applications<ept id="p1">](../deploying/index.md)</ept> that are distributed as NuGet packages.</source>
          <target state="translated">Les outils par projet sont des <bpt id="p1">[</bpt>applications console portables<ept id="p1">](../deploying/index.md)</ept> qui sont distribuées dans les packages NuGet.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Tools are only available in the context of the project that references them and for which they are restored; invocation outside of the context of the project (for example, outside of the directory that contains the project) will fail as the command will not be able to be found.</source>
          <target state="translated">Les outils sont uniquement disponibles dans le contexte du projet qui les référence et pour lequel ils sont restaurés. Les appels en dehors du contexte du projet (par exemple, en dehors du répertoire qui contient le projet) échoueront, car la commande ne pourra pas être trouvée.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>These tools are perfect for build servers as well, since nothing outside of <ph id="ph1">`project.json`</ph> is needed.</source>
          <target state="translated">Ces outils sont également parfaits pour les serveurs de build, puisque rien en dehors de <ph id="ph1">`project.json`</ph> n’est nécessaire.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The build process runs restore for the project it builds and tools will be available.</source>
          <target state="translated">Le processus de génération exécute la restauration pour le projet qu’il génère, et des outils seront disponibles.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Language projects, such as F#, are also in this category; after all, each project can only be written in one specific language.</source>
          <target state="translated">Les projets de langage, tels que F#, figurent également dans cette catégorie. Chaque projet ne peut être écrit que dans un langage.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Finally, this extensibility model provides support for creation of tools that need access to the built output of the project.</source>
          <target state="translated">Enfin, ce modèle d’extensibilité prend en charge la création d’outils qui ont besoin d’accéder à la sortie générée du projet.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For instance, various Razor view tools in <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC applications fall into this category.</source>
          <target state="translated">Par exemple, les outils d’affichage Razor des applications MVC <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> appartiennent à cette catégorie.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Consuming per-project tools</source>
          <target state="translated">Utilisation des outils par projet</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consuming these tools requires you to add a <ph id="ph1">`tools`</ph> node to your <ph id="ph2">`project.json`</ph>.</source>
          <target state="translated">L’utilisation de ces outils nécessite l’ajout d’un nœud <ph id="ph1">`tools`</ph> à votre <ph id="ph2">`project.json`</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Inside the <ph id="ph1">`tools`</ph> node, you reference the package in which the tool resides.</source>
          <target state="translated">Dans le nœud <ph id="ph1">`tools`</ph>, vous devez référencer le package dans lequel réside l’outil.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>After running <ph id="ph1">`dotnet restore`</ph>, the tool and its dependencies are restored.</source>
          <target state="translated">Après l’exécution de <ph id="ph1">`dotnet restore`</ph>, l’outil et ses dépendances sont restaurés.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For tools that need to load the build output of the project for execution, there is usually another dependency which is listed under the regular dependencies in the project file.</source>
          <target state="translated">Pour les outils qui doivent charger la sortie de génération du projet pour l’exécution, il existe généralement une autre dépendance qui est répertoriée sous les dépendances régulières du fichier projet.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This means that tools that load project's code have two components:</source>
          <target state="translated">Cela signifie que les outils qui chargent le code du projet possèdent deux composants :</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The "tools" main invoker</source>
          <target state="translated">Le demandeur principal des outils</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Any number of other tools that contain the logic to work with</source>
          <target state="translated">Tout autre outil contenant la logique à utiliser</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Why two things?</source>
          <target state="translated">Pourquoi deux composants ?</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Tools that need to load the build output of a project need to have unified dependency graph with the project they are working.</source>
          <target state="translated">Les outils qui doivent charger la sortie de génération d’un projet doivent avoir un graphique de dépendance unifié avec le projet qu’ils utilisent.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>By adding the dependency bit, we enable NuGet to resolve these dependencies as a unified graph.</source>
          <target state="translated">En ajoutant le bit de dépendance, nous permettons à NuGet de résoudre ces dépendances en tant que graphique unifié.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The invoker is there because it needs to reason about the location as well as the frameworks of the dependency tool.</source>
          <target state="translated">Le demandeur est là pour évaluer l’emplacement, ainsi que les frameworks de l’outil de dépendance.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The invoker can accept all of the redirection arguments (<ph id="ph1">`-c`</ph>, <ph id="ph2">`-o`</ph>, <ph id="ph3">`-b`</ph>) that the user specifies and finds the dependency tool; it can also implement any policies for cases where multiple dependency tools exist for multiple frameworks (that is, does it run all of them, just one, etc.) In general, logic can be shared between these two tools any way that is needed.</source>
          <target state="translated">Le demandeur peut accepter tous les arguments de redirection (<ph id="ph1">`-c`</ph>, <ph id="ph2">`-o`</ph>, <ph id="ph3">`-b`</ph>) que l’utilisateur spécifie, et rechercher l’outil de dépendance. Il peut également implémenter des stratégies lorsqu’il existe plusieurs outils de dépendance pour plusieurs frameworks (par exemple, doit-il tous les exécuter ou n’en exécuter qu’un seul ?) En règle générale, une logique peut être entièrement partagée par ces deux outils.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Let's review an example of adding a simple tools-only tool to a simple project.</source>
          <target state="translated">Voyons un exemple d’ajout d’un outil simple de type « tools-only » à un projet simple.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Given an example command called <ph id="ph1">`dotnet-api-search`</ph> that allows you to search through the NuGet packages for the specified API, here is a console application's <ph id="ph2">`project.json`</ph> file that uses that tool:</source>
          <target state="translated">Prenons un exemple de commande appelé <ph id="ph1">`dotnet-api-search`</ph> qui vous permette de parcourir les packages NuGet à la recherche de l’API spécifiée. Voici le fichier <ph id="ph2">`project.json`</ph> de l’application console qui utilise cet outil :</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`tools`</ph> node is structured in a similar way as the <ph id="ph2">`dependencies`</ph> node.</source>
          <target state="translated">Le nœud <ph id="ph1">`tools`</ph> est structuré de la même façon que le nœud <ph id="ph2">`dependencies`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>It needs the package ID of the package containing the tool and its version at the very least.</source>
          <target state="translated">Il a besoin, au minimum, de l’ID de package du package qui contient l’outil et sa version.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In the example above, we can see that there is another statement, the <ph id="ph1">`imports`</ph> one.</source>
          <target state="translated">Dans l’exemple ci-dessus, nous voyons qu’il existe une autre instruction : <ph id="ph1">`imports`</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This influences the tool's restore process and specifies that the tool is also compatible, in addition to any targeted frameworks the tools has, with <ph id="ph1">`dnxcore50`</ph> target.</source>
          <target state="translated">Cela influe sur le processus de restauration de l’outil et spécifie que l’outil est également compatible, en plus des frameworks ciblés dont dispose l’outil, avec le <ph id="ph1">`dnxcore50`</ph> cible.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For more information you can consult the <bpt id="p1">[</bpt>project.json reference<ept id="p1">](project-json.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez la <bpt id="p1">[</bpt>documentation de référence project.json<ept id="p1">](project-json.md)</ept>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Building tools</source>
          <target state="translated">Outils de création</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>As mentioned, tools are just portable console applications.</source>
          <target state="translated">Comme nous l’avons mentionné précédemment, les outils sont des applications console portables.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You would build one as you would build any console application.</source>
          <target state="translated">Ils peuvent être créés comme toute autre application console.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>After you build it, you would use <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> command to create a NuGet package (nupkg) that contains your code, information about its dependencies and so on.</source>
          <target state="translated">Une fois l’outil créé, utilisez la commande <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> pour créer un package NuGet (nupkg) devant contenir votre code, les informations sur ses dépendances, etc.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The package name can be whatever the author wants, but the application inside, the actual tool binary, has to conform to the convention of <ph id="ph1">`dotnet-&lt;command&gt;`</ph> in order for <ph id="ph2">`dotnet`</ph> to be able to invoke it.</source>
          <target state="translated">L’auteur est libre de nommer le package comme il l’entend. Toutefois, l’application qui s’y trouve, le fichier binaire de l’outil, doit respecter la convention de <ph id="ph1">`dotnet-&lt;command&gt;`</ph> afin de pouvoir être appelée par <ph id="ph2">`dotnet`</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Since tools are portable applications, the user consuming the tool has to have the version of the .NET Core libraries that the tool was built against in order to run the tool.</source>
          <target state="translated">Étant donné que les outils sont des applications portables, l’utilisateur qui utilise un outil doit disposer de la version des bibliothèques .NET Core à l’aide desquelles l’outil a été développé, afin de pouvoir l’exécuter.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Any other dependency that the tool uses and that is not contained within the .NET Core libraries is restored and placed in the NuGet cache.</source>
          <target state="translated">Toute autre dépendance que l’outil utilise et qui ne figure pas dans les bibliothèques .NET Core est restaurée et placée dans le cache de NuGet.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The entire tool is, therefore, run using the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache.</source>
          <target state="translated">L’outil entier est, par conséquent, exécuté à l’aide des assemblys des bibliothèques .NET Core et du cache de NuGet.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>These kind of tools have a dependency graph that is completely separate from the dependency graph of the project that uses them.</source>
          <target state="translated">Ces types d’outils ont un graphique de dépendance qui est complètement distinct du graphique de dépendance du projet qui les utilise.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The restore process will first restore the project's dependencies, and will then restore each of the tools and their dependencies.</source>
          <target state="translated">Le processus de restauration restaure d’abord les dépendances du projet, puis restaure chacun des outils et leurs dépendances.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can find richer examples and different combinations of this in the <bpt id="p1">[</bpt>.NET Core CLI repo<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.</source>
          <target state="translated">Vous trouverez des exemples plus complets dans le <bpt id="p1">[</bpt>dépôt sur les outils CLI .NET Core<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You can also see the <bpt id="p1">[</bpt>implementation of tools used<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> in the same repo.</source>
          <target state="translated">Vous pouvez également voir l’<bpt id="p1">[</bpt>implémentation des outils utilisés<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> dans le même dépôt.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Building tools that load project's build outputs for execution is slightly different.</source>
          <target state="translated">Le processus de création d’outils chargeant les sorties de génération du projet pour l’exécution est légèrement différent.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>As stated, for these kinds of tools there are two components:</source>
          <target state="translated">Comme mentionné précédemment, pour ces types d’outils, il existe deux composants :</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>A dispatcher tool that the user invokes</source>
          <target state="translated">Un répartiteur que l’utilisateur appelle</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>A framework-specific dependency that contains the logic on how to find the build outputs and what to do with it</source>
          <target state="translated">Une dépendance spécifique au framework qui contient la logique de recherche et d’utilisation des sorties de génération</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A prime example of this are <bpt id="p1">[</bpt>Entity Framework (EF)<ept id="p1">](https://github.com/aspnet/EntityFramework)</ept> commands as well as the <bpt id="p2">[</bpt><ph id="ph1">`dotnet test`</ph><ept id="p2">](dotnet-test.md)</ept> command.</source>
          <target state="translated">Les commandes <bpt id="p1">[</bpt>Entity Framework (EF)<ept id="p1">](https://github.com/aspnet/EntityFramework)</ept> et la commande <bpt id="p2">[</bpt><ph id="ph1">`dotnet test`</ph><ept id="p2">](dotnet-test.md)</ept> constituent de bons exemples.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In both cases, there is a tool that is referenced in the <ph id="ph1">`tools`</ph> node of the <ph id="ph2">`project.json`</ph> and that is the main dispatcher.</source>
          <target state="translated">Dans les deux cas, nous avons un outil qui est référencé dans le nœud <ph id="ph1">`tools`</ph> du <ph id="ph2">`project.json`</ph> et qui est le répartiteur principal.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The user invokes this tool on the command line.</source>
          <target state="translated">L’utilisateur appelle cet outil sur la ligne de commande.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The second piece of the puzzle is the dependency that is given in the project's main dependencies (either root ones or framework-specific ones).</source>
          <target state="translated">La deuxième pièce du puzzle est la dépendance donnée dans les dépendances principales du projet (les dépendances racines ou celles spécifiques au framework).</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This package contains the actual logic of the tool.</source>
          <target state="translated">Ce package contient la logique de l’outil.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The package is a normal dependency, thus it will be restored as part of the restore process for the project.</source>
          <target state="translated">Le package est une dépendance normale. Il sera donc restauré dans le cadre du processus de restauration du projet.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Unlike the previous kind of tools, these tool are actually part of the graph of the project that consumes them.</source>
          <target state="translated">À la différence du type d’outils précédent, ces outils font partie du graphique du projet qui les utilise.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This is because they need access to the project's code and potentially all of its dependencies.</source>
          <target state="translated">Ceci s’explique par le fait qu’ils doivent accéder au code du projet et, potentiellement, à toutes ses dépendances.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For instance, the EF tools need this because they need to scan the assemblies to find the code they need, such as migrations.</source>
          <target state="translated">C’est le cas, par exemple, des outils Entity Framework, car ils doivent analyser les assemblys pour trouver le code dont ils ont besoin (par ex. les migrations).</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Another reason why this two-pronged solution exists is to allow a cleaner invocation model.</source>
          <target state="translated">Cette solution à deux niveaux permet également un modèle d’appel plus propre.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Most CLI commands that drop certain artifacts on disk (for example, <ph id="ph1">`dotnet build`</ph>, <ph id="ph2">`dotnet publish`</ph>) allow users to redirect the outputs to a different path using the <ph id="ph3">`--output`</ph> argument or <ph id="ph4">`--build-base-path`</ph> argument or <ph id="ph5">`--configuration`</ph> argument.</source>
          <target state="translated">La plupart des commandes CLI qui suppriment certains artefacts du disque (par exemple, <ph id="ph1">`dotnet build`</ph>, <ph id="ph2">`dotnet publish`</ph>) permettent aux utilisateurs de rediriger les sorties vers un autre emplacement à l’aide de l’argument <ph id="ph3">`--output`</ph>, <ph id="ph4">`--build-base-path`</ph> ou <ph id="ph5">`--configuration`</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For EF tools, for example, to be able to find the build output of your project, you would have to provide the same arguments with the same values to <bpt id="p1">*</bpt>both<ept id="p1">*</ept> <ph id="ph1">`dotnet`</ph> driver as well as the <ph id="ph2">`ef`</ph> command.</source>
          <target state="translated">Pour les outils Entity Framework, par exemple, pour être en mesure de trouver la sortie de génération de votre projet, vous devez fournir les mêmes arguments avec les mêmes valeurs <bpt id="p1">*</bpt>à la fois<ept id="p1">*</ept> pour le pilote <ph id="ph1">`dotnet`</ph> et la commande <ph id="ph2">`ef`</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>With the invocation model, the users pass any arguments to the dispatcher tool which can then use that to find the needed binary that contains the logic in the output directories.</source>
          <target state="translated">Avec le modèle d’appel, les utilisateurs passent tous les arguments à l’outil répartiteur qui les utilise ensuite pour trouver le fichier binaire nécessaire contenant la logique parmi les répertoires de sortie.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>A good example of this approach can be found in the <bpt id="p1">[</bpt>.NET Core CLI repo<ept id="p1">](https://github.com/dotnet/cli)</ept>:</source>
          <target state="translated">Un bon exemple de cette approche se trouve dans le <bpt id="p1">[</bpt>dépôt sur les outils CLI .NET Core<ept id="p1">](https://github.com/dotnet/cli)</ept> :</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Sample project.json file<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/TestAssets/DesktopTestProjects/AppWithDirectDependencyDesktopAndPortable/project.json)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Exemple de fichier project.json<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/TestAssets/DesktopTestProjects/AppWithDirectDependencyDesktopAndPortable/project.json)</ept></target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Implementation of the dispatcher<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-dependency-tool-invoker)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Implémentation du répartiteur<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-dependency-tool-invoker)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Implementation of the framework-specific dependency<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-desktop-and-portable)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Implémentation de la dépendance spécifique du framework<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-desktop-and-portable)</ept></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility</source>
          <target state="translated">Extensibilité basée sur le chemin (PATH)</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more than a single project.</source>
          <target state="translated">L’extensibilité basée sur le chemin est généralement utilisée pour les ordinateurs de développement qui nécessitent un outil qui traite conceptuellement plusieurs projets.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The main drawback of this extensions mechanism is that it is tied to the machine where the tool exists.</source>
          <target state="translated">Le principal inconvénient de ce mécanisme d’extension est qu’il est limité à l’ordinateur sur lequel est installé l’outil.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If you need it on another machine, you would have to deploy it.</source>
          <target state="translated">Si vous avez besoin de l’installer sur un autre ordinateur, vous devrez le déployer.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This pattern of CLI toolset extensibility is very simple.</source>
          <target state="translated">Ce modèle d’extensibilité des outils CLI est très simple.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>As covered in the <bpt id="p1">[</bpt>.NET Core CLI overview<ept id="p1">](index.md)</ept>, <ph id="ph1">`dotnet`</ph> driver can run any command that is named after the <ph id="ph2">`dotnet-&lt;command&gt;`</ph> convention.</source>
          <target state="translated">Comme indiqué dans la <bpt id="p1">[</bpt>présentation des outils CLI .NET Core<ept id="p1">](index.md)</ept>, le pilote <ph id="ph1">`dotnet`</ph> peut exécuter toutes les commandes dont le nom respecte la convention <ph id="ph2">`dotnet-&lt;command&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The default resolution logic will first probe several locations and will finally fall to the system PATH.</source>
          <target state="translated">La logique de résolution par défaut sonde d’abord plusieurs emplacements avant d’arriver au chemin système.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If the requested command exists in the system PATH and is a binary that can be invoked, <ph id="ph1">`dotnet`</ph> driver will invoke it.</source>
          <target state="translated">Si la commande demandée existe dans le chemin système et s’il s’agit d’un fichier binaire qui peut être appelé, le pilote <ph id="ph1">`dotnet`</ph> l’appellera.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The binary can be pretty much anything that the operating system can execute.</source>
          <target state="translated">La seule qualité indispensable au fichier binaire est d’être exécutable par le système d’exploitation.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>On Unix systems, this means anything that has the execute bit set via <ph id="ph1">`chmod +x`</ph>.</source>
          <target state="translated">Sur les systèmes Unix, il peut s’agir de tous les fichiers dont le bit d’exécution est défini via <ph id="ph1">`chmod +x`</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>On Windows it means anything that Windows knows how to run.</source>
          <target state="translated">Sur les systèmes Windows, il peut s’agir de n’importe quel fichier que Windows peut exécuter.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>As an example, let's take a look at a very simple implementation of a <ph id="ph1">`dotnet clean`</ph> command.</source>
          <target state="translated">Voyons par exemple une implémentation très simple d’une commande <ph id="ph1">`dotnet clean`</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>We will use <ph id="ph1">`bash`</ph> to implement this command.</source>
          <target state="translated">Nous allons utiliser <ph id="ph1">`bash`</ph> pour implémenter cette commande.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The command will simply delete the <ph id="ph1">`bin/`</ph> and <ph id="ph2">`obj/`</ph> directories in the current directory.</source>
          <target state="translated">La commande supprime les répertoires <ph id="ph1">`bin/`</ph> et <ph id="ph2">`obj/`</ph> situés dans le répertoire actif.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`--lock`</ph> argument is passed to it, it will also delete <ph id="ph2">`project.lock.json`</ph> file.</source>
          <target state="translated">Si l’argument <ph id="ph1">`--lock`</ph> lui est passé, elle supprime également le fichier <ph id="ph2">`project.lock.json`</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The entirety of the command is given below.</source>
          <target state="translated">L’intégralité de la commande est affichée ci-dessous.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>On macOS, we can save this script as <ph id="ph1">`dotnet-clean`</ph> and set its executable bit with <ph id="ph2">`chmod +x dotnet-clean`</ph>.</source>
          <target state="translated">Sur Mac OS, nous pouvons enregistrer ce script en tant que <ph id="ph1">`dotnet-clean`</ph> et définir son bit exécutable avec <ph id="ph2">`chmod +x dotnet-clean`</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>We can then create a symbolic link to it in <ph id="ph1">`/usr/local/bin`</ph> using the command <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph>.</source>
          <target state="translated">Nous pouvons ensuite créer un lien symbolique vers le script dans <ph id="ph1">`/usr/local/bin`</ph> à l’aide de la commande <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This will make it possible to invoke the clean command using the <ph id="ph1">`dotnet clean`</ph> syntax.</source>
          <target state="translated">Cela permet d’appeler la commande Clean à l’aide de la syntaxe <ph id="ph1">`dotnet clean`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>You can test this by creating an app, running <ph id="ph1">`dotnet build`</ph> on it and then running <ph id="ph2">`dotnet clean`</ph>.</source>
          <target state="translated">Vous pouvez tester cela en créant une application, en exécutant <ph id="ph1">`dotnet build`</ph> sur l’application, puis en exécutant <ph id="ph2">`dotnet clean`</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The .NET Core CLI tools allow two main extensibility points.</source>
          <target state="translated">Les outils CLI .NET Core permettent deux principaux points d’extensibilité.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The per-project tools are contained within the project's context, but they allow easy installation through restoration.</source>
          <target state="translated">Les outils par projet sont contenus dans le contexte du projet, mais ils permettent une installation rapide grâce à une restauration.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>PATH-based tools are good for general, cross-project tools that are usable on a single machine.</source>
          <target state="translated">Les outils basés sur le chemin sont efficaces pour les outils généraux multiprojets qui sont utilisables sur un seul ordinateur.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>