<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fba870a93784b579da1065a07d82974951ac7e28</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">95b746403eed8e13100defe90c42c880febbf750</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d8d70bd22979ff7663a27372887eb04ebd6c598f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">Initiation à .NET</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">Initiation à .NET</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">Initiation à .NET</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>"Getting Started with .NET Core" tutorials<ept id="p1">](../core/getting-started.md)</ept> to learn how to create a simple .NET Core application.</source>
          <target state="translated">Consultez les <bpt id="p1">[</bpt>didacticiels « Bien démarrer avec .NET Core »<ept id="p1">](../core/getting-started.md)</ept> pour savoir comment créer une application .NET Core simple.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It only takes a few minutes to get your first app up and running.</source>
          <target state="translated">Il suffit de quelques minutes pour créer votre première application et la rendre opérationnelle.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>.NET is a general purpose development platform.</source>
          <target state="translated">.NET est une plateforme de développement généraliste.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>It can be used for any kind of app type or workload where general purpose solutions are used.</source>
          <target state="translated">Elle peut être utilisée pour n’importe quel type d’application ou charge de travail faisant appel à des solutions généralistes.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>It has several key features that are attractive to many developers, including automatic memory management and modern programming languages, that make it easier to efficiently build high-quality applications.</source>
          <target state="translated">Elle comporte plusieurs fonctionnalités clés susceptibles de séduire de nombreux développeurs, notamment la gestion automatique de la mémoire et les langages de programmation modernes, qui facilitent sensiblement la création d’applications de haute qualité.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>.NET enables a high-level programming environment with many convenience features, while providing low-level access to native memory and APIs.</source>
          <target state="translated">.NET met à votre disposition un environnement de programmation général avec de nombreuses fonctionnalités pratiques, tout en donnant un accès aux API et à la mémoire natives.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Multiple implementations of .NET are available, based on open <bpt id="p1">[</bpt>.NET Standards<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)</ept> that specify the fundamentals of the platform.</source>
          <target state="translated">Plusieurs implémentations de .NET sont disponibles, basées sur des <bpt id="p1">[</bpt>normes .NET<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)</ept> ouvertes qui spécifient les principes fondamentaux de la plateforme.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>They are separately optimized for different application types (for example, desktop, mobile, gaming, cloud) and support many chips (for example, x86/x64, ARM) and operating systems (for example, Windows, Linux, iOS, Android, macOS).</source>
          <target state="translated">Elles sont optimisées individuellement pour différents types d’application (par exemple, bureau, mobile, jeu, cloud) et prennent en charge plusieurs processeurs (par exemple, x86/x64, ARM) et systèmes d’exploitation (par exemple, Windows, Linux, iOS, Android, Mac OS).</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Open source is also an important part of the .NET ecosystem, with multiple .NET implementations and many libraries available under OSI-approved licenses.</source>
          <target state="translated">L’open source est également une partie importante de l’écosystème .NET, avec plusieurs implémentations .NET et de nombreuses bibliothèques disponibles sous licences certifiées OSI.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>Overview of .NET implementations<ept id="p1">](../about/products.md)</ept> document to figure out all of the different editions of .NET that are available, both Microsoft's and others.</source>
          <target state="translated">Consultez la <bpt id="p1">[</bpt>Vue d’ensemble des implémentations .NET<ept id="p1">](../about/products.md)</ept> pour déterminer toutes les différentes éditions de .NET qui sont disponibles, à la fois chez Microsoft et d’autres éditeurs.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This Primer will help you understand some of the key concepts in the .NET Platform and point you to more resources for each given topic.</source>
          <target state="translated">Cette initiation doit vous permettre de comprendre certains concepts clés de la plateforme .NET et vous indiquer des ressources supplémentaires pour chaque rubrique donnée.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>By the end of it, you should have enough information to be able to recognize significant terms and concepts in the .NET Platform and to know how to further your knowledge about them.</source>
          <target state="translated">À la fin de celle-ci, vous disposerez de suffisamment d’informations pour pouvoir reconnaître les termes et les concepts significatifs de la plateforme .NET et pour savoir comment approfondir votre connaissance en la matière.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A stroll through .NET</source>
          <target state="translated">Tour d’horizon de .NET</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>As any mature and advanced application development framework, .NET has many powerful features that make the developer's job easier and aim to make writing code more powerful and expressive.</source>
          <target state="translated">Comme tout framework de développement d’applications avancé et mature, .NET offre de nombreuses fonctionnalités utiles qui facilitent le travail du développeur et visent à rendre l’écriture de code plus expressive et plus puissante.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This section will outline the basics of the most salient features and provide pointers to more detailed discussions where needed.</source>
          <target state="translated">Cette section décrit les principes de base des fonctionnalités les plus importantes et pointe sur des discussions plus détaillées si nécessaire.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>After finishing this stroll, you should have enough information to be able to read the samples on our GitHub repos as well as other code and understand what is going on.</source>
          <target state="translated">À la fin de ce tour d’horizon, vous disposerez de suffisamment d’informations pour pouvoir lire les exemples de notre dépôt GitHub et d’autre code, et pour comprendre de quoi il retourne.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Programming languages<ept id="p1">](#programming-languages)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Langages de programmation<ept id="p1">](#programming-languages)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Automatic memory management<ept id="p1">](#automatic-memory-management)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Gestion automatique de la mémoire<ept id="p1">](#automatic-memory-management)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type safety<ept id="p1">](#type-safety)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Cohérence des types<ept id="p1">](#type-safety)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](#delegates-and-lambdas)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Délégués et expressions lambda<ept id="p1">](#delegates-and-lambdas)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types (Generics)<ept id="p1">](#generic-types-generics)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types génériques (Génériques)<ept id="p1">](#generic-types-generics)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Language Integrated Query (LINQ)<ept id="p1">](#language-integrated-query-linq)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](#language-integrated-query-linq)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Async programming<ept id="p1">](#async-programming)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Programmation asynchrone<ept id="p1">](#async-programming)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Native interoperability<ept id="p1">](#native-interoperability)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Interopérabilité native<ept id="p1">](#native-interoperability)</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Unsafe code<ept id="p1">](#unsafe-code)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Code unsafe<ept id="p1">](#unsafe-code)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Programming languages</source>
          <target state="translated">Langages de programmation</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>As a developer, you can choose any programming language that supports .NET to create your application.</source>
          <target state="translated">En qualité de développeur, vous pouvez choisir n’importe quel langage de programmation qui prend en charge .NET pour créer votre application.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Because .NET provides language independence and interoperability, you can interact with other .NET applications and components regardless of the language with which they were developed.</source>
          <target state="translated">Comme .NET fournit l’indépendance et l’interopérabilité des langages, vous pouvez interagir avec d’autres applications et composants .NET, quel que soit le langage utilisé pour leur développement.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Languages that allow you to develop applications for the .NET Platform adhere to the <bpt id="p1">[</bpt>Common Language Infrastructure (CLI) specification<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>.</source>
          <target state="translated">Les langages qui vous permettent de développer des applications pour la plateforme .NET respectent la <bpt id="p1">[</bpt>Spécification CLI (Common Language Infrastructure)<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Microsoft languages that .NET supports include C#, F#, and Visual Basic.</source>
          <target state="translated">Les langages Microsoft que .NET prend en charge sont notamment C#, F# et Visual Basic.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages.</source>
          <target state="translated">C# est simple, puissant, de type sécurisé et orienté objet, tout en conservant l’expressivité et l’élégance des langages de style C.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Anyone familiar with C and similar languages will find few problems in adapting to C#.</source>
          <target state="translated">Les utilisateurs familiarisés avec le langage C et les langages similaires auront peu de difficultés à s’adapter à C#.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</source>
          <target state="translated">F# est un langage de programmation multiplateforme et fonctionnel qui prend également en charge la programmation orientée objet et impérative traditionnelle.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.</source>
          <target state="translated">Visual Basic est un langage facile à apprendre que vous pouvez utiliser pour créer une variété d’applications qui s’exécutent sur .NET.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In the current release of .NET Core, only C# is fully supported across all Microsoft tools.</source>
          <target state="translated">Dans la version actuelle de .NET Core, C# est entièrement pris en charge par tous les outils Microsoft.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>F# is supported in the .NET Core SDK, but does not have Visual Studio tooling yet.</source>
          <target state="translated">F# est pris en charge dans le SDK .NET Core, mais n’a pas encore les outils Visual Studio.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Visual Basic support for the SDK and Visual Studio tooling are coming.</source>
          <target state="translated">La prise en charge de Visual Basic pour le SDK et les outils Visual Studio sera bientôt disponible.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Automatic memory management</source>
          <target state="translated">Gestion automatique de la mémoire</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Garbage collection is the most well-known of .NET features.</source>
          <target state="translated">Le garbage collection est la fonctionnalité .NET la mieux connue.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Developers do not need to actively manage memory, although there are mechanisms to provide more information to the garbage collector (GC).</source>
          <target state="translated">Les développeurs n’ont pas besoin de gérer activement la mémoire, bien qu’il existe des mécanismes pour fournir plus d’informations au récupérateur de mémoire.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>C# includes the <ph id="ph1">`new`</ph> keyword to allocate memory in terms of a particular type, and the <ph id="ph2">`using`</ph> keyword to provide scope for the usage of the object.</source>
          <target state="translated">C# inclut le mot clé <ph id="ph1">`new`</ph> pour allouer de la mémoire en termes d’un type particulier et le mot clé <ph id="ph2">`using`</ph> pour définir la portée de l’utilisation de l’objet.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.</source>
          <target state="translated">Le récupérateur de mémoire opère avec une approche différée de la gestion de la mémoire, préférant le débit de l’application à la collecte immédiate de la mémoire.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following two lines both allocate memory:</source>
          <target state="translated">Les deux lignes suivantes allouent de la mémoire :</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>There is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled running.</source>
          <target state="translated">Il n’existe aucun mot clé analogue pour libérer de la mémoire, car la libération de mémoire se produit automatiquement quand le récupérateur de mémoire réclame la mémoire dans son exécution planifiée.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Method variables normally go out of scope once a method completes, at which point they can be collected.</source>
          <target state="translated">Les variables de méthode sont normalement hors de portée à la fin d’une méthode, point auquel elles peuvent être récupérées.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the <ph id="ph1">`using`</ph> statement.</source>
          <target state="translated">Toutefois, vous pouvez indiquer au récupérateur de mémoire qu’un objet en particulier est hors de portée avant la fin de la méthode à l’aide de l’instruction <ph id="ph1">`using`</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Once the <ph id="ph1">`using`</ph> block completes, the GC will know that the <ph id="ph2">`stream`</ph> object in the example above is free to be collected and its memory reclaimed.</source>
          <target state="translated">Une fois que le bloc <ph id="ph1">`using`</ph> a terminé, le récupérateur de mémoire sait que l’objet <ph id="ph2">`stream`</ph> dans l’exemple ci-dessus peut être collecté et sa mémoire récupérée.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>One of the less obvious but quite far-reaching features that a garbage collector enables is memory safety.</source>
          <target state="translated">Une des fonctionnalités les moins évidentes et pourtant assez importantes que le récupérateur de mémoire active est la sûreté de la mémoire.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).</source>
          <target state="translated">L’invariant de la sûreté de la mémoire est très simple : un programme a une mémoire sécurisée s’il accède uniquement à la mémoire qui a été allouée (et non libérée).</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Dangling pointers are always bugs, and tracking them down is often quite difficult.</source>
          <target state="translated">Les pointeurs non résolus sont toujours des bogues et leur suivi est souvent très difficile.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The .NET runtime provides additional services, to complete the promise of memory safety, not naturally offered by a GC.</source>
          <target state="translated">Le runtime .NET fournit des services supplémentaires pour assurer la sûreté de la mémoire, qui ne sont pas naturellement offerts par un récupérateur de mémoire.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>It ensures that programs do not index off the end of an array or accessing a phantom field off the end of an object.</source>
          <target state="translated">Il garantit que les programmes n’indexent pas à la fin d’un tableau ou accèdent à un champ fantôme à la fin d’un objet.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The following example will throw an exception as a result of memory safety.</source>
          <target state="translated">L’exemple suivant lève une exception en raison de la sûreté de la mémoire.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Type safety</source>
          <target state="translated">Cohérence des types</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Objects are allocated in terms of types.</source>
          <target state="translated">Les objets sont alloués en termes de types.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The only operations allowed for a given object, and the memory it consumes, are those of its type.</source>
          <target state="translated">Les seules opérations autorisées pour un objet donné et la mémoire qu’il consomme sont celles de son type.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dog`</ph> type may have <ph id="ph2">`Jump`</ph> and <ph id="ph3">`WagTail`</ph> methods, but not likely a <ph id="ph4">`SumTotal`</ph> method.</source>
          <target state="translated">Un type <ph id="ph1">`Dog`</ph> peut avoir des méthodes <ph id="ph2">`Jump`</ph> et <ph id="ph3">`WagTail`</ph>, mais probablement pas une méthode <ph id="ph4">`SumTotal`</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A program can only call the declared methods of a given type.</source>
          <target state="translated">Un programme peut appeler uniquement les méthodes déclarées d’un type donné.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or <ph id="ph1">`object`</ph>).</source>
          <target state="translated">Tous les autres appels entraînent une erreur au moment de la compilation ou une exception au moment de l’exécution (en cas d’utilisation de fonctionnalités dynamiques ou du type <ph id="ph1">`object`</ph>).</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>.NET languages are object-oriented, with hierarchies of base and derived classes.</source>
          <target state="translated">Les langages .NET sont orientés objet, avec des hiérarchies de classes de base et dérivées.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The .NET runtime will only allow object casts and calls that align with the object hierarchy.</source>
          <target state="translated">Le runtime .NET autorise uniquement les casts et les appels d’objet qui s’alignent sur la hiérarchie d’objets.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Remember that every type defined in any .NET language derives from the base <ph id="ph1">`object`</ph> type.</source>
          <target state="translated">N’oubliez pas que chaque type défini dans un langage .NET dérive du type <ph id="ph1">`object`</ph> de base.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</source>
          <target state="translated">La cohérence des types est également utilisée pour aider à appliquer l’encapsulation en garantissant la fidélité des mots clés d’accesseur.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Accessor keywords are artifacts which control access to members of a given type by other code.</source>
          <target state="translated">Les mots clés d’accesseur sont des artefacts qui contrôlent l’accès aux membres d’un type donné par un autre code.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>These are usually used for various kinds of data within a type that are used to manage its behavior.</source>
          <target state="translated">Ils servent généralement à différentes sortes de données dans un type utilisées pour gérer son comportement.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Some .NET languages support <bpt id="p1">**</bpt>type inference<ept id="p1">**</ept>.</source>
          <target state="translated">Certains langages .NET prennent en charge l’<bpt id="p1">**</bpt>inférence de type<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side.</source>
          <target state="translated">L’inférence de type signifie que le compilateur déduit le type de l’expression à gauche à partir de l’expression à droite.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This doesn't mean that the type safety is broken or avoided.</source>
          <target state="translated">Cela ne signifie pas que la cohérence des types est interrompue ou évitée.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The resulting type <bpt id="p1">**</bpt>has<ept id="p1">**</ept> a strong type with everything that implies.</source>
          <target state="translated">Le type résultant <bpt id="p1">**</bpt>a<ept id="p1">**</ept> un type fort avec tout ce que cela implique.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Let's rewrite the first two lines of the previous example to introduce type inference.</source>
          <target state="translated">Réécrivons les deux premières lignes de l’exemple précédent pour introduire l’inférence de type.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You will note that the rest of the example is completely the same.</source>
          <target state="translated">Notez que le reste de l’exemple est complètement identique.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">Délégués et expressions lambda</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Delegates are like C++ function pointers, with a big difference that they are type safe.</source>
          <target state="translated">Les délégués sont comme des pointeurs de fonction C++, à la grande différence qu’ils sont de type sécurisé.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>They are a kind of disconnected method within the CLR type system.</source>
          <target state="translated">Ils représentent une sorte de méthode déconnectée au sein du système de type CLR.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Regular methods are attached to a class and only directly callable through static or instance calling conventions.</source>
          <target state="translated">Les méthodes régulières sont attachées à une classe et peuvent être appelées directement uniquement par des conventions d’appel statiques ou d’instance.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Delegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.</source>
          <target state="translated">Les délégués sont utilisés dans diverses API et emplacements de l’environnement .NET, en particulier dans les expressions lambda, qui sont la pierre angulaire de LINQ.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept> document.</source>
          <target state="translated">Pour en savoir plus sur ce sujet, lisez le document <bpt id="p1">[</bpt>Délégués et expressions lambda<ept id="p1">](delegates-lambdas.md)</ept>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Generic types (Generics)</source>
          <target state="translated">Types génériques (Génériques)</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Generic types, also commonly called "generics", are a feature that was added in .NET Framework 2.0.</source>
          <target state="translated">Les types génériques, ou les « génériques », sont une fonctionnalité qui a été ajoutée dans .NET Framework 2.0.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In short, generics allow the programmer to introduce a "type parameter" when designing their classes, that will allow the client code (the users of the type) to specify the exact type to use in place of the type parameter.</source>
          <target state="translated">En bref, les génériques permettent au programmeur d’introduire un « paramètre de type » quand il désigne leurs classes qui permettra au code client (les utilisateurs du type) de spécifier le type exact à utiliser à la place du paramètre de type.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Generics were added in order to help programmers implement generic data structures.</source>
          <target state="translated">Les génériques ont été ajoutés pour aider les programmeurs à implémenter des structures de données génériques.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Before their arrival, in order for a, say, <bpt id="p1">_</bpt>List<ept id="p1">_</ept> type to be generic, it would have to work with elements that were of type <bpt id="p2">_</bpt>object<ept id="p2">_</ept>.</source>
          <target state="translated">Avant leur arrivée, pour qu’un type <bpt id="p1">_</bpt>liste<ept id="p1">_</ept>, par exemple, soit générique, il fallait utiliser des éléments qui étaient de type <bpt id="p2">_</bpt>objet<ept id="p2">_</ept>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This would have various performance as well as semantic problems, not to mention possible subtle runtime errors.</source>
          <target state="translated">Cela entraînait des variations de performances ainsi que des problèmes sémantiques, sans oublier les possibles erreurs d’exécution subtiles.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <bpt id="p1">_</bpt>InvalidCastException<ept id="p1">_</ept> is thrown on working with the list's members.</source>
          <target state="translated">Les erreurs les plus connues dans cette dernière catégorie interviennent quand une structure de données contient, par exemple, des entiers et des chaînes et qu’une exception <bpt id="p1">_</bpt>InvalidCastException<ept id="p1">_</ept> est levée lors de l’utilisation des membres de la liste.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The below sample shows a basic program running using an instance of <ph id="ph1">@System.Collections.Generic.List%601</ph> types.</source>
          <target state="translated">L’exemple ci-dessous montre une exécution de programme de base utilisant une instance des types <ph id="ph1">@System.Collections.Generic.List%601</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept> article.</source>
          <target state="translated">Pour plus d’informations, consultez l’article <bpt id="p1">[</bpt>Vue d’ensemble des types génériques (Génériques)<ept id="p1">](generics.md)</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Async programming</source>
          <target state="translated">Programmation asynchrone</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Async programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs.</source>
          <target state="translated">La programmation asynchrone est un concept de première classe dans .NET, avec prise en charge asynchrone dans le runtime, les bibliothèques de framework et les constructions de langage .NET.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Internally, they are based off of objects (such as <ph id="ph1">`Task`</ph>) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</source>
          <target state="translated">En interne, ils sont basés sur des objets (comme <ph id="ph1">`Task`</ph>) qui tirent parti du système d’exploitation pour effectuer aussi efficacement que possible des tâches utilisant des E/S.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>To learn more about async programming in .NET, start with the <bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept>.</source>
          <target state="translated">Pour en savoir plus sur la programmation asynchrone dans .NET, commencez par la <bpt id="p1">[</bpt>Vue d’ensemble d’Async<ept id="p1">](async.md)</ept>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ)</source>
          <target state="translated">LINQ (Language-Integrated Query)</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</source>
          <target state="translated">LINQ est un ensemble puissant de fonctionnalités pour C# et VB qui vous permettent d’écrire du code simple et déclaratif pour l’exploitation des données.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!</source>
          <target state="translated">Les données peuvent se présenter sous plusieurs formes (comme des objets en mémoire, dans une base de données SQL ou un document XML), mais le code LINQ que vous écrivez généralement n’est pas différent pour chaque source de données !</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>To learn more and see some samples, check out <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</source>
          <target state="translated">Pour en savoir plus et obtenir des exemples, consultez <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">Interopérabilité native</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Every operating system in current use provides a lot of platform support for various programming tasks.</source>
          <target state="translated">Chaque système d’exploitation en cours d’utilisation prend en charge un grand nombre de plateformes pour diverses tâches de programmation.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>.NET provides several ways to tap into those APIs.</source>
          <target state="translated">.NET offre plusieurs moyens de tirer parti de ces API.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Collectively, this support is called "native interoperability" and in this section we will take a look at how to access native APIs from managed, .NET code.</source>
          <target state="translated">Collectivement, cette prise en charge est appelée « interopérabilité native » et, dans cette section, nous allons voir comment accéder aux API natives à partir du code managé .NET.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The main way to do native interoperability is via "platform invoke" or P/Invoke for short.</source>
          <target state="translated">Le principal moyen d’effectuer une interopérabilité native est via l’« appel de code non managé » ou P/Invoke, en forme abrégée.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This support in .NET Core is available across Linux and Windows platforms.</source>
          <target state="translated">Cette prise en charge dans .NET Core est disponible sur les plateformes Linux et Windows.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Another, Windows-only way of doing native interoperability is known as "COM interop" which is used to work with <bpt id="p1">[</bpt>COM components<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in managed code.</source>
          <target state="translated">Un autre moyen de faire une interopérabilité native sur Windows uniquement est connu sous le nom de « COM Interop », utilisé pour travailler avec des <bpt id="p1">[</bpt>composants COM<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> dans du code managé.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It is built on top of P/Invoke infrastructure, but it works in subtly different ways.</source>
          <target state="translated">Il est basé sur l’infrastructure de P/Invoke, mais fonctionne légèrement différemment.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</source>
          <target state="translated">Une grande partie de la prise en charge d’interopérabilité dans Mono (et donc dans Xamarin) pour Java et Objective-C est générée de la même façon, autrement dit, ils utilisent les mêmes principes.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept> document.</source>
          <target state="translated">Pour en savoir plus, lisez le document <bpt id="p1">[</bpt>Interopérabilité native<ept id="p1">](native-interop.md)</ept>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Unsafe code</source>
          <target state="translated">Code unsafe</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The CLR enables the ability to access native memory and do pointer arithmetic via <ph id="ph1">`unsafe`</ph> code.</source>
          <target state="translated">Le CLR permet d’accéder à la mémoire native et d’effectuer une opération arithmétique de pointeur via du code <ph id="ph1">`unsafe`</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>These operations are needed for certain algorithms and system interoperability.</source>
          <target state="translated">Ces opérations sont nécessaires pour certains algorithmes et pour l’interopérabilité du système.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm.</source>
          <target state="translated">L’utilisation de code unsafe, bien que puissante, est déconseillée, sauf si elle est nécessaire pour assurer l’interopérabilité avec les API système ou implémenter l’algorithme le plus efficace.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety.</source>
          <target state="translated">Le code unsafe peut ne pas s’exécuter de la même façon dans différents environnements et perd les avantages d’un récupérateur de mémoire et de la cohérence des types.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.</source>
          <target state="translated">Il est recommandé de restreindre et centraliser le code unsafe autant que possible, et de tester ce code de manière approfondie.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ToString()`</ph> method from the <bpt id="p1">[</bpt>StringBuilder class<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327)</ept> illustrates how using <ph id="ph2">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:</source>
          <target state="translated">La méthode <ph id="ph1">`ToString()`</ph> de la <bpt id="p1">[</bpt>classe StringBuilder<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327)</ept> illustre comment l’utilisation de code <ph id="ph2">`unsafe`</ph> peut implémenter efficacement un algorithme en déplaçant directement des segments de mémoire :</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The term ".NET runtime" is used throughout the document to accommodate for the multiple implementations of .NET, such as CLR, Mono, IL2CPP and others.</source>
          <target state="translated">Le terme « runtime .NET » est utilisé dans le document pour englober les différentes implémentations de .NET, comme CLR, Mono, IL2CPP et d’autres.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The more specific names are only used if needed.</source>
          <target state="translated">Les noms plus spécifiques sont utilisés uniquement si nécessaire.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>This document is not intended to be historical in nature, but describe the .NET platform as it is now.</source>
          <target state="translated">Ce document n’est pas historique, mais il décrit la plateforme .NET dans son état actuel.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It isn't important whether a .NET feature has always been available or was only recently introduced, only that it is important enough to highlight and discuss.</source>
          <target state="translated">Cela n’a pas d’importance qu’une fonctionnalité .NET ait toujours été disponible ou ait été introduite seulement récemment, nous exposons uniquement ce qui est suffisamment important pour le souligner et en discuter.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>