<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3efd30bade564fe1b7dbf93237a9ff40c58c5f1e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\best-practices-strings.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e466b1fa40bcf6a82fdf2349f2b6346dd591d696</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">32d24a667cd981642c7344e4a4899a410e95b9f2</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Best practices for using strings</source>
          <target state="translated">Bonnes pratiques pour l’utilisation de chaînes</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Best practices for using strings</source>
          <target state="translated">Bonnes pratiques pour l’utilisation de chaînes</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Best practices for using strings</source>
          <target state="translated">Bonnes pratiques pour l’utilisation de chaînes</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>.NET provides extensive support for developing localized and globalized applications, and makes it easy to apply the conventions of either the current culture or a specific culture when performing common operations such as sorting and displaying strings.</source>
          <target state="translated">.NET offre une prise en charge complète du développement d’applications localisées et globalisées, et facilite l’application des conventions de la culture actuelle ou d’une culture spécifique lors de l’exécution d’opérations courantes telles que le tri et l’affichage de chaînes.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>But sorting or comparing strings is not always a culture-sensitive operation.</source>
          <target state="translated">Toutefois, le tri ou la comparaison de chaînes n'est pas toujours une opération dépendante de la culture.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, strings that are used internally by an application typically should be handled identically across all cultures.</source>
          <target state="translated">Par exemple, les chaînes utilisées en interne par une application doivent généralement être gérées de la même manière dans toutes les cultures.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When culturally independent string data, such as XML tags, HTML tags, user names, file paths, and the names of system objects, are interpreted as if they were culture-sensitive, application code can be subject to subtle bugs, poor performance, and, in some cases, security issues.</source>
          <target state="translated">Quand des données de type chaîne culturellement indépendantes, telles que des étiquettes XML, des étiquettes HTML, des noms d’utilisateurs, des chemins d’accès aux fichiers et des noms d’objets système, sont interprétées comme si elles étaient dépendantes de la culture, le code d’application peut faire l’objet de bogues subtils, de performances médiocres et, dans certains cas, de problèmes de sécurité.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This article examines the string sorting, comparison, and casing methods in .NET, presents recommendations for selecting an appropriate string-handling method, and provides additional information about string-handling methods.</source>
          <target state="translated">Cet article examine les méthodes de tri, de comparaison et d’application de la casse pour les chaînes dans .NET, présente des recommandations pour sélectionner une méthode appropriée de gestion des chaînes et fournit des informations supplémentaires sur les méthodes de gestion des chaînes.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It also examines how formatted data, such as numeric data and date and time data, is handled for display and for storage.</source>
          <target state="translated">Elle décrit également comment les données mises en forme, telles que les données numériques et les données de date et d'heure, sont traitées pour l'affichage et pour le stockage.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This article contains the following sections:</source>
          <target state="translated">Cet article contient les sections suivantes :</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Recommendations for string usage<ept id="p1">](#recommendations-for-string-usage)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recommandations relatives à l’utilisation de chaînes<ept id="p1">](#recommendations-for-string-usage)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Specifying string comparisons explicitly<ept id="p1">](#specifying-string-comparisons-explicitly)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Spécification explicite de comparaisons de chaînes<ept id="p1">](#specifying-string-comparisons-explicitly)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The details of string comparison<ept id="p1">](#the-details-of-string-comparison)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Détails de la comparaison de chaînes<ept id="p1">](#the-details-of-string-comparison)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Choosing a StringComparison member for your method call<ept id="p1">](#choosing-a-stringcomparison-member-for-your-method-call)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Choix d’un membre StringComparison pour votre appel de méthode<ept id="p1">](#choosing-a-stringcomparison-member-for-your-method-call)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Common string comparison methods<ept id="p1">](#common-string-comparison-methods)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Méthodes courantes de comparaison de chaînes<ept id="p1">](#common-string-comparison-methods)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Methods that perform string comparison indirectly<ept id="p1">](#methods-that-perform-string-comparison-indirectly)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Méthodes qui effectuent indirectement la comparaison de chaînes<ept id="p1">](#methods-that-perform-string-comparison-indirectly)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Displaying and persisting formatted data<ept id="p1">](#displaying-and-persisting-formatted-data)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Affichage et persistance des données mises en forme<ept id="p1">](#displaying-and-persisting-formatted-data)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Recommendations for string usage</source>
          <target state="translated">Recommandations relatives à l’utilisation de chaînes</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>When you develop with .NET, follow these simple recommendations when you use strings:</source>
          <target state="translated">Dans le cadre du développement à l’aide de .NET, suivez les recommandations simples ci-après quand vous utilisez des chaînes :</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Use overloads that explicitly specify the string comparison rules for string operations.</source>
          <target state="translated">Utilisez des surcharges qui spécifient explicitement les règles de comparaison de chaînes pour les opérations de chaînes.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Typically, this involves calling a method overload that has a parameter of type <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</source>
          <target state="translated">Cela implique généralement l’appel d’une surcharge de méthode avec un paramètre de type <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> or <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> for comparisons as your safe default for culture-agnostic string matching.</source>
          <target state="translated">Utilisez <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> ou <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> pour les comparaisons et faites-en votre valeur par défaut sécurisée pour la mise en correspondance de chaînes de culture non spécifiée.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Use comparisons with <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> or <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> for better performance.</source>
          <target state="translated">Utilisez des comparaisons avec <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> ou <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> pour atteindre de meilleures performances.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Use string operations that are based on <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept> when you display output to the user.</source>
          <target state="translated">Utilisez les opérations de chaînes basées sur <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept> quand vous affichez la sortie à l’utilisateur.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Use the non-linguistic <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> or <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> values instead of string operations based on <bpt id="p3">[</bpt>CultureInfo.InvariantCulture<ept id="p3">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> when the comparison is linguistically irrelevant (symbolic, for example).</source>
          <target state="translated">Utilisez des valeurs <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> ou <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> non linguistiques plutôt que des opérations de chaînes basées sur <bpt id="p3">[</bpt>CultureInfo.InvariantCulture<ept id="p3">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> quand la comparaison est linguistiquement non pertinente (symbolique, par exemple).</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>String.ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> method instead of the <bpt id="p2">[</bpt>String.ToLowerInvariant<ept id="p2">](xref:System.String.ToLowerInvariant)</ept> method when you normalize strings for comparison.</source>
          <target state="translated">Utilisez la méthode <bpt id="p1">[</bpt>String.ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> plutôt que la méthode <bpt id="p2">[</bpt>String.ToLowerInvariant<ept id="p2">](xref:System.String.ToLowerInvariant)</ept> quand vous normalisez des chaînes à des fins de comparaison.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Use an overload of the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Equals`</ph> method to test whether two strings are equal.</source>
          <target state="translated">Utilisez une surcharge de la méthode <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Equals`</ph> pour tester si deux chaînes sont égales.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Use an overload of the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> and <bpt id="p2">[</bpt>String.CompareTo<ept id="p2">](xref:System.String.CompareTo(System.String))</ept> methods to sort strings, not to check for equality.</source>
          <target state="translated">Utilisez une surcharge des méthodes <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> et <bpt id="p2">[</bpt>String.CompareTo<ept id="p2">](xref:System.String.CompareTo(System.String))</ept> pour trier des chaînes, et non pour en vérifier l’égalité.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Use culture-sensitive formatting to display non-string data, such as numbers and dates, in a user interface.</source>
          <target state="translated">Utilisez la mise en forme en fonction de la culture pour afficher des données non-chaînées, telles que les nombres et les dates, dans une interface utilisateur.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Use formatting with the invariant culture to persist non-string data in string form.</source>
          <target state="translated">Utilisez la mise en forme en fonction de la culture dite indifférente pour rendre les données non-chaînées sous forme de chaîne.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Avoid the following practices when you use strings:</source>
          <target state="translated">Quand vous utilisez des chaînes, évitez les pratiques suivantes :</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Do not use overloads that do not explicitly or implicitly specify the string comparison rules for string operations.</source>
          <target state="translated">N'utilisez pas de surcharges qui ne spécifient pas explicitement ou implicitement les règles de comparaison de chaînes pour les opérations de chaînes.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Do not use an overload of the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> or <bpt id="p2">[</bpt>String.CompareTo<ept id="p2">](xref:System.String.CompareTo(System.String))</ept> methods and test for a return value of zero to determine whether two strings are equal.</source>
          <target state="translated">N’utilisez pas de surcharge de la méthode <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> ou <bpt id="p2">[</bpt>String.CompareTo<ept id="p2">](xref:System.String.CompareTo(System.String))</ept>et ne testez pas une valeur de retour de zéro pour déterminer si deux chaînes sont égales.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Do not use culture-sensitive formatting to persist numeric data or date and time data in string form.</source>
          <target state="translated">N'utilisez pas la mise en forme qui tient compte de la culture pour rendre des données numériques ou les données de date et d'heure sous forme de chaîne.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Specifying string comparisons explicitly</source>
          <target state="translated">Spécification explicite de comparaisons de chaînes</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Most of the string manipulation methods in .NET are overloaded.</source>
          <target state="translated">La plupart des méthodes de manipulation de chaînes dans .NET sont surchargées.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Typically, one or more overloads accept default settings, whereas others accept no defaults and instead define the precise way in which strings are to be compared or manipulated.</source>
          <target state="translated">Une ou plusieurs surcharges acceptent généralement des paramètres par défaut, contrairement à d'autres qui définissent avec précision la façon dont les chaînes doivent être comparées ou manipulées.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Most of the methods that do not rely on defaults include a parameter of type <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>, which is an enumeration that explicitly specifies rules for string comparison by culture and case.</source>
          <target state="translated">La plupart des méthodes qui ne s’appuient pas sur des valeurs par défaut incluent un paramètre de type <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>, qui est une énumération spécifiant explicitement des règles pour la comparaison de chaînes selon la culture et la casse.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The following table describes the <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> enumeration members.</source>
          <target state="translated">Le tableau suivant décrit les membres de l’énumération <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>StringComparison member</source>
          <target state="translated">Membre StringComparison</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept></target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Performs a case-sensitive comparison using the current culture.</source>
          <target state="translated">Effectue une comparaison respectant la casse à l'aide de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CurrentCultureIgnoreCase<ept id="p1">](xref:System.StringComparison.CurrentCultureIgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>CurrentCultureIgnoreCase<ept id="p1">](xref:System.StringComparison.CurrentCultureIgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Performs a case-insensitive comparison using the current culture.</source>
          <target state="translated">Effectue une comparaison ne respectant pas la casse à l'aide de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Performs an ordinal comparison.</source>
          <target state="translated">Effectue une comparaison ordinale.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Performs a case-insensitive ordinal comparison.</source>
          <target state="translated">Effectue une comparaison ordinale ne respectant pas la casse.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> method, which returns the index of a substring in a <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> object that matches either a character or a string, has nine overloads:</source>
          <target state="translated">Par exemple, la méthode <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph>, qui retourne l’index d’une sous-chaîne contenue dans un objet <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> correspondant à un caractère ou à une chaîne, a neuf surcharges :</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IndexOf(Char)<ept id="p1">](xref:System.String.IndexOf(System.Char))</ept>, <bpt id="p2">[</bpt>IndexOf(Char, Int32)<ept id="p2">](xref:System.String.IndexOf(System.Char,System.Int32))</ept>, and <bpt id="p3">[</bpt>IndexOf(Char, Int32, Int32)<ept id="p3">](xref:System.String.IndexOf(System.Char,System.Int32,System.Int32))</ept>, which by default perform an ordinal (case-sensitive and culture-insensitive) search for a character in the string.</source>
          <target state="translated"><bpt id="p1">[</bpt>IndexOf(Char)<ept id="p1">](xref:System.String.IndexOf(System.Char))</ept>, <bpt id="p2">[</bpt>IndexOf(Char, Int32)<ept id="p2">](xref:System.String.IndexOf(System.Char,System.Int32))</ept> et <bpt id="p3">[</bpt>IndexOf(Char, Int32, Int32)<ept id="p3">](xref:System.String.IndexOf(System.Char,System.Int32,System.Int32))</ept>, qui effectuent par défaut une recherche ordinale (respectant la casse et indépendante de la culture) d’un caractère dans la chaîne ;</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IndexOf(String)<ept id="p1">](xref:System.String.IndexOf(System.String))</ept>, <bpt id="p2">[</bpt>IndexOf(String, Int32)<ept id="p2">](xref:System.String.IndexOf(System.String,System.Int32))</ept>, and <bpt id="p3">[</bpt>IndexOf(String, Int32, Int32)<ept id="p3">](xref:System.String.IndexOf(System.String,System.Int32,System.Int32))</ept>, which by default perform a case-sensitive and culture-sensitive search for a substring in the string.</source>
          <target state="translated"><bpt id="p1">[</bpt>IndexOf(String)<ept id="p1">](xref:System.String.IndexOf(System.String))</ept>, <bpt id="p2">[</bpt>IndexOf(String, Int32)<ept id="p2">](xref:System.String.IndexOf(System.String,System.Int32))</ept> et <bpt id="p3">[</bpt>IndexOf(String, Int32, Int32)<ept id="p3">](xref:System.String.IndexOf(System.String,System.Int32,System.Int32))</ept>, qui effectuent par défaut une recherche respectant la casse et dépendante de la culture d’une sous-chaîne dans la chaîne ;</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IndexOf(String, StringComparison)<ept id="p1">](xref:System.String.IndexOf(System.String,System.StringComparison))</ept>, <bpt id="p2">[</bpt>IndexOf(String, Int32, StringComparison)<ept id="p2">](xref:System.String.IndexOf(System.String,System.Int32,System.StringComparison))</ept>, and <bpt id="p3">[</bpt>IndexOf(String, Int32, Int32, StringComparison)<ept id="p3">](xref:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison))</ept>, which include a parameter of type StringComparison that allows the form of the comparison to be specified.</source>
          <target state="translated"><bpt id="p1">[</bpt>IndexOf(String, StringComparison)<ept id="p1">](xref:System.String.IndexOf(System.String,System.StringComparison))</ept>, <bpt id="p2">[</bpt>IndexOf(String, Int32, StringComparison)<ept id="p2">](xref:System.String.IndexOf(System.String,System.Int32,System.StringComparison))</ept> et <bpt id="p3">[</bpt>IndexOf(String, Int32, Int32, StringComparison)<ept id="p3">](xref:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison))</ept>, qui incluent un paramètre de type StringComparison qui permet de spécifier la forme de la comparaison.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>We recommend that you select an overload that does not use default values, for the following reasons:</source>
          <target state="translated">Nous vous recommandons de sélectionner une surcharge qui n'utilise pas de valeurs par défaut, pour les raisons suivantes :</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Some overloads with default parameters (those that search for a <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept> in the string instance) perform an ordinal comparison, whereas others (those that search for a string in the string instance) are culture-sensitive.</source>
          <target state="translated">Certaines surcharges ayant des paramètres par défaut (celles qui recherchent un <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept> dans l’instance de chaîne) effectuent une comparaison ordinale, tandis que d’autres (celles qui recherchent une chaîne dans l’instance de chaîne) sont dépendantes de la culture.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It is difficult to remember which method uses which default value, and easy to confuse the overloads.</source>
          <target state="translated">Il est difficile de mémoriser quelle méthode utilise quelle valeur par défaut, et les surcharges peuvent être facilement confondues.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The intent of the code that relies on default values for method calls is not clear.</source>
          <target state="translated">L'objectif du code qui s'appuie sur des valeurs par défaut pour les appels de méthode n'est pas clair.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In the following example, which relies on defaults, it is difficult to know whether the developer actually intended an ordinal or a linguistic comparison of two strings, or whether a case difference between <ph id="ph1">`protocol`</ph> and "http" might cause the test for equality to return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Dans l'exemple suivant, qui s'appuie sur des valeurs par défaut, il est difficile de savoir si le développeur voulait en fait une comparaison ordinale ou linguistique de deux chaînes, ou si une différence de casse entre <ph id="ph1">`protocol`</ph> et "http" pourrait entraîner le retour de <ph id="ph2">`false`</ph> par le test d'égalité.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you call a method that does not rely on defaults, because it makes the intent of the code unambiguous.</source>
          <target state="translated">En général, nous vous recommandons d'appeler une méthode qui ne s'appuie pas sur des valeurs par défaut, car elle rend l'objectif du code non équivoque.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This, in turn, makes the code more readable and easier to debug and maintain.</source>
          <target state="translated">Cela rend ensuite le code plus lisible et plus facile à déboguer et à gérer.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The following example addresses the questions raised about the previous example.</source>
          <target state="translated">L'exemple suivant aborde les questions soulevées à propos de l'exemple précédent.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>It makes it clear that ordinal comparison is used and that differences in case are ignored.</source>
          <target state="translated">Il explique que la comparaison ordinale est utilisée et que les différences de casse sont ignorées.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The details of string comparison</source>
          <target state="translated">Détails de la comparaison de chaînes</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>String comparison is the heart of many string-related operations, particularly sorting and testing for equality.</source>
          <target state="translated">La comparaison de chaînes est le cœur de nombreuses opérations liées aux chaînes, en particulier le tri et le test d'égalité.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Strings sort in a determined order: If "my" appears before "string" in a sorted list of strings, "my" must compare less than or equal to "string".</source>
          <target state="translated">Les chaînes sont triées dans un ordre déterminé : si "my" s'affiche avant "string" dans une liste triée de chaînes, "my" doit être considéré comme inférieur ou égal à "string".</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Additionally, comparison implicitly defines equality.</source>
          <target state="translated">En outre, la comparaison définit implicitement l'égalité.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The comparison operation returns zero for strings it deems equal.</source>
          <target state="translated">L'opération de comparaison retourne zéro pour les chaînes qu'il estime égales.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A good interpretation is that neither string is less than the other.</source>
          <target state="translated">Considérer qu'aucune chaîne n'est inférieure à l'autre constitue une bonne interprétation.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Most meaningful operations involving strings include one or both of these procedures: comparing with another string, and executing a well-defined sort operation.</source>
          <target state="translated">La plupart des opérations significatives impliquant des chaînes incluent l'une des procédures suivantes, ou les deux : comparaison avec une autre chaîne et exécution d'une opération de tri bien définie.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>However, evaluating two strings for equality or sort order does not yield a single, correct result; the outcome depends on the criteria used to compare the strings.</source>
          <target state="translated">Toutefois, l'évaluation de l'égalité ou de l'ordre de tri de deux chaînes ne produit pas un résultat correct unique ; le résultat dépend des critères utilisés pour comparer les chaînes.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>In particular, string comparisons that are ordinal or that are based on the casing and sorting conventions of the current culture or the invariant culture (a locale-agnostic culture based on the English language) may produce different results.</source>
          <target state="translated">En particulier, les comparaisons de chaînes qui sont ordinales ou basées sur les conventions de casse et de tri de la culture actuelle ou la culture dite indifférente (culture aux paramètres régionaux non spécifiés basée sur la langue anglaise) peuvent produire des résultats différents.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>String comparisons that use the current culture</source>
          <target state="translated">Comparaisons de chaînes qui utilisent la culture actuelle</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>One criterion involves using the conventions of the current culture when comparing strings.</source>
          <target state="translated">L'un des critères à prendre en compte est l'utilisation des conventions de la culture actuelle lors de la comparaison de chaînes.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Comparisons that are based on the current culture use the thread's current culture or locale.</source>
          <target state="translated">Les comparaisons basées sur la culture actuelle utilisent la culture ou les paramètres régionaux actuels du thread.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You should always use comparisons that are based on the current culture when data is linguistically relevant, and when it reflects culture-sensitive user interaction.</source>
          <target state="translated">Vous devez toujours utiliser des comparaisons basées sur la culture actuelle quand les données sont linguistiquement pertinentes et quand elles reflètent l'intervention de l'utilisateur dépendante de la culture.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, comparison and casing behavior in .NET changes when the culture changes.</source>
          <target state="translated">Toutefois, le comportement de la comparaison et de la casse dans .NET change en fonction de la culture.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This happens when an application executes on a computer that has a different culture than the computer on which the application was developed, or when the executing thread changes its culture.</source>
          <target state="translated">Cela se produit quand une application s'exécute sur un ordinateur dont la culture est différente de celle de l'ordinateur sur lequel l'application a été développée, ou quand le thread en cours d'exécution change sa culture.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This behavior is intentional, but it remains non-obvious to many developers.</source>
          <target state="translated">Ce comportement est intentionnel, mais il reste peu évident à de nombreux développeurs.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following example illustrates differences in sort order between the U.S. English ("en-US") and Swedish ("sv-SE") cultures.</source>
          <target state="translated">L'exemple suivant illustre les différences au niveau de l'ordre de tri entre les cultures Anglais (États-Unis) ("en-US") et Suédois ("sv-SE").</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Note that the words "ångström", "Windows", and "Visual Studio" appear in different positions in the sorted string arrays.</source>
          <target state="translated">Notez que les mots « ångström », « Windows » et « Visual Studio » s’affichent à des positions différentes dans les tableaux de chaînes triées.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Case-insensitive comparisons that use the current culture are the same as culture-sensitive comparisons, except that they ignore case as dictated by the thread's current culture.</source>
          <target state="translated">Les comparaisons ne respectant pas la casse qui utilisent la culture actuelle sont identiques aux comparaisons dépendantes de la culture, mais elles ignorent la casse, comme défini par la culture actuelle du thread.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This behavior may manifest itself in sort orders as well.</source>
          <target state="translated">Ce comportement peut également se manifester dans les ordres de tri.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Comparisons that use current culture semantics are the default for the following methods:</source>
          <target state="translated">Les comparaisons qui utilisent la sémantique de la culture actuelle sont la valeur par défaut pour les méthodes suivantes :</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> overloads that do not include a <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> parameter.</source>
          <target state="translated">surcharges <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> qui n’incluent pas de paramètre <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> ;</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String.CompareTo<ept id="p1">](xref:System.String.CompareTo(System.String))</ept> overloads.</source>
          <target state="translated">surcharges <bpt id="p1">[</bpt>String.CompareTo<ept id="p1">](xref:System.String.CompareTo(System.String))</ept> ;</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The default <bpt id="p1">[</bpt>String.StartsWith(String)<ept id="p1">](xref:System.String.StartsWith(System.String))</ept> method.</source>
          <target state="translated">méthode <bpt id="p1">[</bpt>String.StartsWith(String)<ept id="p1">](xref:System.String.StartsWith(System.String))</ept> par défaut ;</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The default <bpt id="p1">[</bpt>String.EndsWith(String)<ept id="p1">](xref:System.String.EndsWith(System.String))</ept> method.</source>
          <target state="translated">méthode <bpt id="p1">[</bpt>String.EndsWith(String)<ept id="p1">](xref:System.String.EndsWith(System.String))</ept> par défaut ;</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> overloads that accept a <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> as a search parameter and that do not have a <bpt id="p3">[</bpt>StringComparison<ept id="p3">](xref:System.StringComparison)</ept> parameter.</source>
          <target state="translated">surcharges <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> qui acceptent un <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> en tant que paramètre de recherche et qui n’ont pas de paramètre <bpt id="p3">[</bpt>StringComparison<ept id="p3">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`LastIndexOf`</ph> overloads that accept a <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> as a search parameter and that do not have a <bpt id="p3">[</bpt>StringComparison<ept id="p3">](xref:System.StringComparison)</ept> parameter.</source>
          <target state="translated">surcharges <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`LastIndexOf`</ph> qui acceptent un <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> comme paramètre de recherche et qui n’ont pas de paramètre <bpt id="p3">[</bpt>StringComparison<ept id="p3">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>In any case, we recommend that you call an overload that has a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> parameter to make the intent of the method call clear.</source>
          <target state="translated">Dans tous les cas, nous vous recommandons d’appeler une surcharge qui a un paramètre <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> pour que l’objectif de l’appel de la méthode soit clair.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Subtle and not so subtle bugs can emerge when non-linguistic string data is interpreted linguistically, or when string data from a particular culture is interpreted using the conventions of another culture.</source>
          <target state="translated">Des bogues, plus ou moins subtils, peuvent émerger quand des données de type chaîne non linguistiques sont interprétées linguistiquement, ou quand des données de type chaîne d'une culture particulière sont interprétées à l'aide des conventions d'une autre culture.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The canonical example is the Turkish-I problem.</source>
          <target state="translated">L'exemple canonique est le problème du caractère I en turc.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For nearly all Latin alphabets, including U.S. English, the character "i" (\u0069) is the lowercase version of the character "I" (\u0049).</source>
          <target state="translated">Dans presque tous les alphabets latins, y compris l'anglais (États-Unis), le caractère "i" (\u0069) est la version en minuscule du caractère "I" (\u0049).</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This casing rule quickly becomes the default for someone programming in such a culture.</source>
          <target state="translated">Cette règle de casse devient rapidement la valeur par défaut pour quelqu'un qui effectue de la programmation dans une telle culture.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>However, the Turkish ("tr-TR") alphabet includes an "I with a dot" character "İ" (\u0130), which is the capital version of "i".</source>
          <target state="translated">Toutefois, l’alphabet turc ("tr-TR") inclut un caractère "I avec un point", "İ" (\u0130), qui est la version en majuscule de "i".</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Turkish also includes a lowercase "i without a dot" character, "ı" (\u0131), which capitalizes to "I".</source>
          <target state="translated">Le turc comprend également un caractère "i sans point" minuscule, "ı" (\u0131), dont la majuscule est "I".</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This behavior occurs in the Azerbaijani ("az") culture as well.</source>
          <target state="translated">Ce comportement se produit également dans la culture azérie ("az").</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Therefore, assumptions made about capitalizing "i" or lowercasing "I" are not valid among all cultures.</source>
          <target state="translated">Par conséquent, les suppositions faites sur la mise en majuscule du "i" ou de la mise en minuscule du "I" ne sont pas valides dans toutes les cultures.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>If you use the default overloads for string comparison routines, they will be subject to variance between cultures.</source>
          <target state="translated">Si vous utilisez les surcharges par défaut pour les routines de comparaison de chaînes, elles varieront suivant les cultures.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If the data to be compared is non-linguistic, using the default overloads can produce undesirable results, as the following attempt to perform a case-insensitive comparison of the strings "file" and "FILE" illustrates.</source>
          <target state="translated">Si les données à comparer sont non linguistiques, l'utilisation de surcharges par défaut peut produire des résultats indésirables, comme le montre la tentative suivante d'exécution d'une comparaison ne respectant pas la casse des chaînes "file" et "FILE".</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This comparison could cause significant problems if the culture is inadvertently used in security-sensitive settings, as in the following example.</source>
          <target state="translated">Cette comparaison peut provoquer de sérieux problèmes si la culture est utilisée par inadvertance dans des paramètres de sécurité sensibles, comme dans l'exemple suivant.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>A method call such as <ph id="ph1">`IsFileURI("file:")`</ph> returns <ph id="ph2">`true`</ph> if the current culture is U.S. English, but <ph id="ph3">`false`</ph> if the current culture is Turkish.</source>
          <target state="translated">Un appel de méthode tel que <ph id="ph1">`IsFileURI("file:")`</ph> retourne la valeur <ph id="ph2">`true`</ph> si la culture actuelle est Anglais (États-Unis), mais <ph id="ph3">`false`</ph> si la culture actuelle est Turc.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Thus, on Turkish systems, someone could circumvent security measures that block access to case-insensitive URIs that begin with "FILE:".</source>
          <target state="translated">Par conséquent, sur les systèmes turcs, quelqu'un pourrait contourner les mesures de sécurité qui bloquent l'accès aux URI ne respectant pas la casse qui commencent par "FILE:".</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>In this case, because "file:" is meant to be interpreted as a non-linguistic, culture-insensitive identifier, the code should instead be written as shown in the following example.</source>
          <target state="translated">Dans ce cas, étant donné que "file:" doit être interprété comme un identificateur non linguistique indépendant de la culture, le code doit plutôt être écrit comme indiqué dans l'exemple suivant.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Ordinal String Operations</source>
          <target state="translated">Opérations de chaînes ordinales</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Specifying the <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> or <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> value in a method call signifies a non-linguistic comparison in which the features of natural languages are ignored.</source>
          <target state="translated">La spécification de la valeur <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> ou <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> dans un appel de méthode signifie une comparaison non linguistique dans laquelle les fonctionnalités linguistiques naturelles sont ignorées.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Methods that are invoked with these <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> values base string operation decisions on simple byte comparisons instead of casing or equivalence tables that are parameterized by culture.</source>
          <target state="translated">Les méthodes qui sont appelées avec ces valeurs <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> font reposer les décisions d’opération de chaîne sur de simples comparaisons d’octets plutôt que sur la casse ou des tables d’équivalences paramétrables par la culture.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In most cases, this approach best fits the intended interpretation of strings while making code faster and more reliable.</source>
          <target state="translated">Dans la plupart des cas, cette approche correspond le mieux à l'interprétation de chaînes prévue tout en rendant le code plus rapide et plus fiable.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Ordinal comparisons are string comparisons in which each byte of each string is compared without linguistic interpretation; for example, "windows" does not match "Windows".</source>
          <target state="translated">Les comparaisons ordinales sont des comparaisons de chaînes dans lesquelles chaque octet de chaque chaîne est comparé sans interprétation linguistique ; par exemple, "windows" ne correspond pas à "Windows".</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Use this comparison when the context dictates that strings should be matched exactly or demands conservative matching policy.</source>
          <target state="translated">Utilisez cette comparaison quand le contexte indique que les chaînes doivent correspondre exactement ou demande une stratégie de correspondance classique.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Additionally, ordinal comparison is the fastest comparison operation because it applies no linguistic rules when determining a result.</source>
          <target state="translated">En outre, la comparaison ordinale est l'opération de comparaison la plus rapide, car elle n'applique aucune règle linguistique lors de la détermination d'un résultat.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Strings in .NET can contain embedded null characters.</source>
          <target state="translated">Les chaînes dans .NET peuvent contenir des caractères Null incorporés.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>One of the clearest differences between ordinal and culture-sensitive comparison (including comparisons that use the invariant culture) concerns the handling of embedded null characters in a string.</source>
          <target state="translated">L'une des différences les plus évidentes entre la comparaison ordinale et la comparaison dépendante de la culture (y compris les comparaisons qui utilisent la culture dite indifférente) concerne la gestion des caractères Null incorporés dans une chaîne.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>These characters are ignored when you use the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> and <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph2">`Equals`</ph> methods to perform culture-sensitive comparisons (including comparisons that use the invariant culture).</source>
          <target state="translated">Ces caractères sont ignorés quand vous utilisez les méthodes <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> et <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph2">`Equals`</ph> pour effectuer des comparaisons dépendantes de la culture (notamment des comparaisons qui utilisent la culture dite indifférente).</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>As a result, in culture-sensitive comparisons, strings that contain embedded null characters can be considered equal to strings that do not.</source>
          <target state="translated">Par conséquent, dans les comparaisons dépendantes de la culture, les chaînes qui contiennent des caractères Null incorporés peuvent être considérées comme égales à des chaînes qui n'en contiennent pas.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Although string comparison methods disregard embedded null characters, string search methods such as <bpt id="p1">[</bpt>String.Contains<ept id="p1">](xref:System.String.Contains(System.String))</ept>, <bpt id="p2">[</bpt>String.EndsWith<ept id="p2">](xref:System.String.EndsWith(System.String))</ept>, <bpt id="p3">[</bpt>String.IndexOf<ept id="p3">](xref:System.String.IndexOf(System.Char))</ept>, <bpt id="p4">[</bpt>String.LastIndexOf<ept id="p4">](xref:System.String.LastIndexOf(System.String))</ept>, and <bpt id="p5">[</bpt>String.StartsWith<ept id="p5">](xref:System.String.StartsWith(System.String))</ept> do not.</source>
          <target state="translated">Bien que les méthodes de comparaison de chaînes ignorent les caractères Null incorporés, les méthodes de recherche de chaîne comme <bpt id="p1">[</bpt>String.Contains<ept id="p1">](xref:System.String.Contains(System.String))</ept>, <bpt id="p2">[</bpt>String.EndsWith<ept id="p2">](xref:System.String.EndsWith(System.String))</ept>, <bpt id="p3">[</bpt>String.IndexOf<ept id="p3">](xref:System.String.IndexOf(System.Char))</ept>, <bpt id="p4">[</bpt>String.LastIndexOf<ept id="p4">](xref:System.String.LastIndexOf(System.String))</ept> et <bpt id="p5">[</bpt>String.StartsWith<ept id="p5">](xref:System.String.StartsWith(System.String))</ept> ne les ignorent pas.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following example performs a culture-sensitive comparison of the string "Aa" with a similar string that contains several embedded null characters between "A" and "a", and shows how the two strings are considered equal.</source>
          <target state="translated">L'exemple suivant effectue une comparaison dépendante de la culture de la chaîne "Aa" avec une chaîne semblable qui contient plusieurs caractères Null incorporés entre "A" et "a", et montre comment les deux chaînes sont considérées comme égales.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>However, the strings are not considered equal when you use ordinal comparison, as the following example shows.</source>
          <target state="translated">Toutefois, les chaînes ne sont pas considérées comme égales quand vous utilisez la comparaison ordinale, comme le montre l'exemple suivant.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Case-insensitive ordinal comparisons are the next most conservative approach.</source>
          <target state="translated">Les comparaisons ordinales ne respectant pas la casse sont l'approche la plus conservatrice suivante.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>These comparisons ignore most casing; for example, "windows" matches "Windows".</source>
          <target state="translated">Ces comparaisons ignorent la plus grande partie de la casse ; par exemple, "windows" correspond à "Windows".</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>When dealing with ASCII characters, this policy is equivalent to <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>, except that it ignores the usual ASCII casing.</source>
          <target state="translated">Lors du traitement de caractères ASCII, cette stratégie est équivalente à <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>, excepté qu’elle ignore la casse ASCII habituelle.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Therefore, any character in [A, Z] (\u0041-\u005A) matches the corresponding character in [a,z] (\u0061-\007A).</source>
          <target state="translated">Par conséquent, tout caractère de la plage [A, Z] (\u0041-\u005A) correspond au caractère correspondant de la plage [a,z] (\u0061-\007A).</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Casing outside the ASCII range uses the invariant culture's tables.</source>
          <target state="translated">La casse hors de la plage ASCII utilise les tables de la culture dite indifférente.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Therefore, the following comparison:</source>
          <target state="translated">Par conséquent, la comparaison suivante :</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>is equivalent to (but faster than) this comparison:</source>
          <target state="translated">est équivalente à la comparaison suivante (mais plus rapide) :</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>These comparisons are still very fast.</source>
          <target state="translated">Ces comparaisons restent très rapides.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Both <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> and <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> use the binary values directly, and are best suited for matching.</source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> et <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> utilisent les valeurs binaires directement et conviennent mieux à la mise en correspondance.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>When you are not sure about your comparison settings, use one of these two values.</source>
          <target state="translated">Quand vous n'êtes pas sûr de vos paramètres de comparaison, utilisez l'une de ces deux valeurs.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>However, because they perform a byte-by-byte comparison, they do not sort by a linguistic sort order (like an English dictionary) but by a binary sort order.</source>
          <target state="translated">Toutefois, étant donné qu'elles effectuent une comparaison octet par octet, elles n'effectuent pas le tri selon un ordre de tri linguistique (comme un dictionnaire français), mais selon un ordre de tri binaire.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The results may look odd in most contexts if displayed to users.</source>
          <target state="translated">Les résultats peuvent sembler étranges dans la plupart des contextes s'ils sont affichés aux utilisateurs.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Ordinal semantics are the default for <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Equals`</ph> overloads that do not include a <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> argument (including the equality operator).</source>
          <target state="translated">La sémantique ordinale est la valeur par défaut pour les surcharges <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Equals`</ph> qui n’incluent pas d’argument <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> (notamment l’opérateur d’égalité).</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>In any case, we recommend that you call an overload that has a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> parameter.</source>
          <target state="translated">Dans tous les cas, nous vous recommandons d’appeler une surcharge ayant un paramètre <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>String operations that use the invariant culture</source>
          <target state="translated">Opérations de chaîne qui utilisent la culture dite indifférente</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Comparisons with the invariant culture use the <bpt id="p1">[</bpt>CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> property returned by the static <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> property.</source>
          <target state="translated">Les comparaisons avec la culture dite indifférente utilisent la propriété <bpt id="p1">[</bpt>CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> retournée par la méthode <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> statique.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>This behavior is the same on all systems; it translates any characters outside its range into what it believes are equivalent invariant characters.</source>
          <target state="translated">Ce comportement est le même sur tous les systèmes ; il traduit tous les caractères en dehors de sa plage en ce qu'il suppose être des caractères invariants équivalents.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>This policy can be useful for maintaining one set of string behavior across cultures, but it often provides unexpected results.</source>
          <target state="translated">Cette stratégie peut être utile pour la gestion d'un jeu de comportements de chaîne dans toutes les cultures, mais elle donne souvent des résultats inattendus.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Case-insensitive comparisons with the invariant culture use the static <bpt id="p1">[</bpt>CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> property returned by the static <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> property for comparison information as well.</source>
          <target state="translated">Les comparaisons ne respectant pas la casse avec la culture dite indifférente utilisent la propriété <bpt id="p1">[</bpt>CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> statique retournée par la propriété <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> statique pour les informations de comparaison également.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Any case differences among these translated characters are ignored.</source>
          <target state="translated">Toutes les différences de casse entre ces caractères traduits sont ignorées.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>CultureInfo.InvariantCulture<ept id="p1">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> object makes a <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> method interpret certain sets of characters as equivalent.</source>
          <target state="translated">L’objet <bpt id="p1">[</bpt>CultureInfo.InvariantCulture<ept id="p1">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> entraîne l’interprétation par la méthode <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> de certains jeux de caractères comme étant équivalents.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For example, the following equivalence is valid under the invariant culture:</source>
          <target state="translated">Par exemple, l'équivalence suivante est valide dans la culture dite indifférente :</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>InvariantCulture: a + ̊ = å</source>
          <target state="translated">InvariantCulture: a + ̊ = å</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The latin small lette A character "a" (\u0061), when it is next to the combining ring above character "+ " ̊" (\u030a), is interpreted as the latin small letter A with ring above character "å" (\u00e5).</source>
          <target state="translated">Le caractère Lettre minuscule latine A "a" (\u0061), quand il se trouve à côté du caractère diacritique rond en chef "+ " ̊" (\u030a), est interprété comme une lettre minuscule latine A avec diacritique rond en chef "å" (\u00e5).</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>As the following example shows, this behavior differs from ordinal comparison.</source>
          <target state="translated">Comme le montre l'exemple suivant, ce comportement diffère de la comparaison ordinale.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>When interpreting file names, cookies, or anything else where a combination such as "å" can appear, ordinal comparisons still offer the most transparent and fitting behavior.</source>
          <target state="translated">Lors de l’interprétation de noms de fichiers, de cookies ou de tout autre élément dans lequel peut s’afficher une combinaison telle que "å", les comparaisons ordinales offrent toujours le comportement le plus transparent et le plus approprié.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>On balance, the invariant culture has very few properties that make it useful for comparison.</source>
          <target state="translated">En définitive, la culture dite indifférente a très peu de propriétés qui la rendent utile pour la comparaison.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>It does comparison in a linguistically relevant manner, which prevents it from guaranteeing full symbolic equivalence, but it is not the choice for display in any culture.</source>
          <target state="translated">Elle effectue la comparaison d'une manière linguistiquement pertinente, qui l'empêche de garantir une équivalence symbolique complète, mais elle ne constitue pas le choix approprié pour l'affichage dans n'importe quelle culture.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>For example, if a large data file that contains a list of sorted identifiers for display accompanies an application, adding to this list would require an insertion with invariant-style sorting.</source>
          <target state="translated">Par exemple, si un fichier de données volumineux qui contient une liste d'identificateurs triés à des fins d'affichage accompagne une application, un ajout à cette liste nécessiterait une insertion avec un tri de style invariant.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Choosing a StringComparison member for your method call</source>
          <target state="translated">Choix d’un membre StringComparison pour votre appel de méthode</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The following table outlines the mapping from semantic string context to a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> enumeration member.</source>
          <target state="translated">Le tableau suivant décrit le mappage entre le contexte de chaîne sémantique et un membre de l’énumération <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Data</source>
          <target state="translated">Données</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Comportement</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Corresponding System.StringComparison value</source>
          <target state="translated">Valeur System.StringComparison correspondante</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Case-sensitive internal identifiers, case-sensitive identifiers in standards such as XML and HTTP, or case-sensitive security-related settings.</source>
          <target state="translated">Identificateurs internes respectant la casse, identificateurs respectant la casse dans des normes telles que XML et HTTP ou paramètres liés à la sécurité respectant la casse.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>A non-linguistic identifier, where bytes match exactly.</source>
          <target state="translated">Identificateur non linguistique, où les octets correspondent exactement.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept></target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Case-insensitive internal identifiers, case-insensitive identifiers in standards such as XML and HTTP, file paths, registry keys and values, environment variables, resource identifiers (for example, handle names), or case-insensitive security-related settings.</source>
          <target state="translated">Identificateurs internes ne respectant pas la casse, identificateurs ne respectant pas la casse dans des normes telles que XML et HTTP, chemins de fichiers, clés et valeurs de Registre, variables d’environnement, identificateurs de ressources (par exemple, noms de handle) ou paramètres liés à la sécurité ne respectant pas la casse.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>A non-linguistic identifier, where case is irrelevant.</source>
          <target state="translated">Identificateur non linguistique, où la casse est sans importance.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Data displayed to the user or most user input.</source>
          <target state="translated">Données affichées à l’utilisateur ou la plupart des entrées d’utilisateur.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Data that requires local linguistic customs.</source>
          <target state="translated">Données qui nécessitent des usages linguistiques locaux.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept> or <bpt id="p2">[</bpt>CurrentCultureIgnoreCase<ept id="p2">](xref:System.StringComparison.CurrentCultureIgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept> ou <bpt id="p2">[</bpt>CurrentCultureIgnoreCase<ept id="p2">](xref:System.StringComparison.CurrentCultureIgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Common string comparison methods</source>
          <target state="translated">Méthodes courantes de comparaison de chaînes</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The following sections describe the methods that are most commonly used for string comparison.</source>
          <target state="translated">Les sections suivantes décrivent les méthodes le plus souvent utilisées pour la comparaison de chaînes.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>String.Compare</source>
          <target state="translated">String.Compare</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interprétation par défaut : <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>As the operation most central to string interpretation, all instances of these method calls should be examined to determine whether strings should be interpreted according to the current culture, or dissociated from the culture (symbolically).</source>
          <target state="translated">En tant qu'opération la plus centrale de l'interprétation de chaînes, toutes les instances de ces appels de méthode doivent être examinées pour déterminer si les chaînes doivent être interprétées d'après la culture actuelle ou être dissociées de la culture (symboliquement).</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Typically, it is the latter, and a <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> comparison should be used instead.</source>
          <target state="translated">En général, il s’agit de la dernière et une comparaison <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> doit plutôt être utilisée.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>System.Globalization.CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> class, which is returned by the <bpt id="p2">[</bpt>CultureInfo.CompareInfo<ept id="p2">](xref:System.Globalization.CultureInfo.CompareInfo)</ept> property, also includes a <bpt id="p3">[</bpt>Compare<ept id="p3">](xref:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32,System.Globalization.CompareOptions))</ept> method that provides a large number of matching options (ordinal, ignoring white space, ignoring kana type, and so on) by means of the <bpt id="p4">[</bpt>CompareOptions<ept id="p4">](xref:System.Globalization.CompareOptions)</ept> flag enumeration.</source>
          <target state="translated">La classe <bpt id="p1">[</bpt>System.Globalization.CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept>, retournée par la propriété <bpt id="p2">[</bpt>CultureInfo.CompareInfo<ept id="p2">](xref:System.Globalization.CultureInfo.CompareInfo)</ept>, inclut également une méthode <bpt id="p3">[</bpt>Compare<ept id="p3">](xref:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32,System.Globalization.CompareOptions))</ept> qui fournit un grand nombre d’options de mise en correspondance (ordinale, ignorant les espaces blancs, ignorant le type kana, etc.) au moyen de l’énumération d’indicateur <bpt id="p4">[</bpt>CompareOptions<ept id="p4">](xref:System.Globalization.CompareOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>String.CompareTo</source>
          <target state="translated">String.CompareTo</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interprétation par défaut : <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>This method does not currently offer an overload that specifies a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> type.</source>
          <target state="translated">Cette méthode n’offre actuellement pas de surcharge spécifiant un type <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>It is usually possible to convert this method to the recommended <bpt id="p1">[</bpt>String.Compare(String, String, StringComparison)<ept id="p1">](xref:System.String.Compare(System.String,System.String,System.StringComparison))</ept> form.</source>
          <target state="translated">Il est généralement possible de convertir cette méthode dans la forme <bpt id="p1">[</bpt>String.Compare(String, String, StringComparison)<ept id="p1">](xref:System.String.Compare(System.String,System.String,System.StringComparison))</ept> recommandée.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Types that implement the <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> and <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept> interfaces implement this method.</source>
          <target state="translated">Les types qui implémentent les interfaces <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> et <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept> implémentent cette méthode.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Because it does not offer the option of a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> parameter, implementing types often let the user specify a <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> in their constructor.</source>
          <target state="translated">Étant donné qu’elle n’offre pas la possibilité d’un paramètre <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>, les types d’implémentation permettent souvent à l’utilisateur de spécifier un <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> dans leur constructeur.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`FileName`</ph> class whose class constructor includes a <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> parameter.</source>
          <target state="translated">L’exemple suivant définit une classe <ph id="ph1">`FileName`</ph> dont le constructeur de classe inclut un paramètre <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is then used in the <ph id="ph1">`FileName.CompareTo`</ph> method.</source>
          <target state="translated">Cet objet <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> est alors utilisé dans la méthode <ph id="ph1">`FileName.CompareTo`</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>String.Equals</source>
          <target state="translated">String.Equals</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>.</source>
          <target state="translated">Interprétation par défaut : <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> class lets you test for equality by calling either the static or instance <ph id="ph1">`Equals`</ph> method overloads, or by using the static equality operator.</source>
          <target state="translated">La classe <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> vous permet de tester l’égalité en appelant les surcharges de la méthode <ph id="ph1">`Equals`</ph> statique ou d’instance, ou en utilisant l’opérateur d’égalité statique.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The overloads and operator use ordinal comparison by default.</source>
          <target state="translated">Par défaut, les surcharges et l'opérateur utilisent la comparaison ordinale.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>However, we still recommend that you call an overload that explicitly specifies the <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> type even if you want to perform an ordinal comparison; this makes it easier to search code for a certain string interpretation.</source>
          <target state="translated">Toutefois, nous vous recommandons quand même d’appeler une surcharge qui spécifie explicitement le type <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>, même si vous voulez effectuer une comparaison ordinale ; cela simplifie la recherche d’une interprétation de chaîne particulière dans du code.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>String.ToUpper and String.ToLower</source>
          <target state="translated">String.ToUpper et String.ToLower</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interprétation par défaut : <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>You should be careful when you use these methods, because forcing a string to a uppercase or lowercase is often used as a small normalization for comparing strings regardless of case.</source>
          <target state="translated">Vous devez faire preuve de prudence quand vous utilisez ces méthodes, car imposer une majuscule ou une minuscule dans une chaîne est souvent utilisé comme une petite normalisation pour la comparaison de chaînes indépendamment de la casse.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>If so, consider using a case-insensitive comparison.</source>
          <target state="translated">Si tel est le cas, vous devez envisager d'utiliser une comparaison ne respectant pas la casse.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>String.ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> and <bpt id="p2">[</bpt>String.ToLowerInvariant<ept id="p2">](xref:System.String.ToLowerInvariant)</ept> methods are also available.</source>
          <target state="translated">Les méthodes <bpt id="p1">[</bpt>String.ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> et <bpt id="p2">[</bpt>String.ToLowerInvariant<ept id="p2">](xref:System.String.ToLowerInvariant)</ept> sont également disponibles.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> is the standard way to normalize case.</source>
          <target state="translated"><bpt id="p1">[</bpt>ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> est le moyen standard de normaliser la casse.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Comparisons made using <bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> are behaviorally the composition of two calls: calling <bpt id="p2">[</bpt>ToUpperInvariant<ept id="p2">](xref:System.String.ToUpperInvariant)</ept> on both string arguments, and doing a comparison using <bpt id="p3">[</bpt>StringComparison.Ordinal<ept id="p3">](xref:System.StringComparison.Ordinal)</ept>.</source>
          <target state="translated">Les comparaisons faites à l’aide de <bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> se composent sur le plan comportemental de deux appels : appel à <bpt id="p2">[</bpt>ToUpperInvariant<ept id="p2">](xref:System.String.ToUpperInvariant)</ept> sur les deux arguments de chaîne et comparaison à l’aide de <bpt id="p3">[</bpt>StringComparison.Ordinal<ept id="p3">](xref:System.StringComparison.Ordinal)</ept>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Overloads are also available for converting to uppercase and lowercase in a specific culture, by passing a <bpt id="p1">[</bpt>CultureInfo<ept id="p1">](xref:System.Globalization.CultureInfo)</ept> object that represents that culture to the method.</source>
          <target state="translated">Des surcharges sont également disponibles pour la conversion en majuscules et en minuscules dans une culture spécifique, en passant à la méthode un objet <bpt id="p1">[</bpt>CultureInfo<ept id="p1">](xref:System.Globalization.CultureInfo)</ept> qui représente cette culture.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Char.ToUpper and Char.ToLower</source>
          <target state="translated">Char.ToUpper et Char.ToLower</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interprétation par défaut : <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>These methods work similarly to the <bpt id="p1">[</bpt>String.ToUpper<ept id="p1">](xref:System.String.ToUpper)</ept> and <bpt id="p2">[</bpt>String.ToLower<ept id="p2">](xref:System.String.ToLower)</ept> methods described in the previous section.</source>
          <target state="translated">Ces méthodes fonctionnent de façon similaire aux méthodes <bpt id="p1">[</bpt>String.ToUpper<ept id="p1">](xref:System.String.ToUpper)</ept> et <bpt id="p2">[</bpt>String.ToLower<ept id="p2">](xref:System.String.ToLower)</ept> décrites dans la section précédente.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>String.StartsWith and String.EndsWith</source>
          <target state="translated">String.StartsWith et String.EndsWith</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interprétation par défaut : <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>By default, both of these methods perform a culture-sensitive comparison.</source>
          <target state="translated">Par défaut, ces deux méthodes effectuent une comparaison dépendante de la culture.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>String.IndexOf and String.LastIndexOf</source>
          <target state="translated">String.IndexOf et String.LastIndexOf</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interprétation par défaut : <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>There is a lack of consistency in how the default overloads of these methods perform comparisons.</source>
          <target state="translated">La façon dont les surcharges par défaut de ces méthodes effectuent les comparaisons n'est pas cohérente.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>All <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> and <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph2">`LastIndexOf`</ph> methods that include a <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept> parameter perform an ordinal comparison, but the default <bpt id="p4">[</bpt>String<ept id="p4">](xref:System.String)</ept> <ph id="ph3">`IndexOf`</ph> and [String<ph id="ph4">`](xref:System.String) `</ph>LastIndexOf` methods that include a <bpt id="p5">[</bpt>String<ept id="p5">](xref:System.String)</ept> parameter perform a culture-sensitive comparison.</source>
          <target state="translated">Toutes les méthodes <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> et <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph2">`LastIndexOf`</ph> qui incluent un paramètre <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept> effectuent une comparaison ordinale, mais les méthodes <bpt id="p4">[</bpt>String<ept id="p4">](xref:System.String)</ept> <ph id="ph3">`IndexOf`</ph> et [String<ph id="ph4">`](xref:System.String) `</ph>LastIndexOf` par défaut qui incluent un paramètre <bpt id="p5">[</bpt>String<ept id="p5">](xref:System.String)</ept> effectuent une comparaison dépendante de la culture.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>If you call <ph id="ph1">` `</ph>IndexOf<ph id="ph2">` or `</ph>LastIndexOf` method and pass it a string to locate in the current instance, we recommend that you call an overload that explicitly specifies the <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> type.</source>
          <target state="translated">Si vous appelez la méthode <ph id="ph1">` `</ph>IndexOf<ph id="ph2">` or `</ph>LastIndexOf` et que vous lui passez une chaîne à localiser dans l’instance actuelle, nous vous recommandons d’appeler une surcharge qui spécifie explicitement le type <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The overloads that include a <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept> argument do not allow you to specify a <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> type.</source>
          <target state="translated">Les surcharges qui incluent un argument <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept> ne vous permettent pas de spécifier un type <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Methods that perform string comparison indirectly</source>
          <target state="translated">Méthodes qui effectuent indirectement la comparaison de chaînes</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Some non-string methods that have string comparison as a central operation use the <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> type.</source>
          <target state="translated">Certaines méthodes autres que les méthodes de chaîne dont l’opération centrale est la comparaison de chaînes utilisent le type <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> class includes four static properties that return <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> instances whose <ph id="ph1">`Compare`</ph> methods perform the following types of string comparisons:</source>
          <target state="translated">La classe <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> inclut quatre propriétés statiques qui retournent des instances de <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> dont les méthodes <ph id="ph1">`Compare`</ph> effectuent les types de comparaisons de chaînes suivants :</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Culture-sensitive string comparisons using the current culture.</source>
          <target state="translated">Comparaisons de chaînes dépendantes de la culture à l'aide de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is returned by the <bpt id="p2">[</bpt>StringComparer.CurrentCulture<ept id="p2">](xref:System.StringComparer.CurrentCulture)</ept> property.</source>
          <target state="translated">Cet objet <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> est retourné par la propriété <bpt id="p2">[</bpt>StringComparer.CurrentCulture<ept id="p2">](xref:System.StringComparer.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Case-insensitive comparisons using the current culture.</source>
          <target state="translated">Comparaisons ne respectant pas la casse à l'aide de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is returned by the <bpt id="p2">[</bpt>StringComparer.CurrentCultureIgnoreCase<ept id="p2">](xref:System.StringComparer.CurrentCultureIgnoreCase)</ept> property.</source>
          <target state="translated">Cet objet <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> est retourné par la propriété <bpt id="p2">[</bpt>StringComparer.CurrentCultureIgnoreCase<ept id="p2">](xref:System.StringComparer.CurrentCultureIgnoreCase)</ept>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Ordinal comparison.</source>
          <target state="translated">Comparaison ordinale.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is returned by the <bpt id="p2">[</bpt>StringComparer.Ordinal<ept id="p2">](xref:System.StringComparer.Ordinal)</ept> property.</source>
          <target state="translated">Cet objet <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> est retourné par la propriété <bpt id="p2">[</bpt>StringComparer.Ordinal<ept id="p2">](xref:System.StringComparer.Ordinal)</ept>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Case-insensitive ordinal comparison.</source>
          <target state="translated">Comparaison ordinale ne respectant pas la casse.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is returned by the <bpt id="p2">[</bpt>StringComparer.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparer.OrdinalIgnoreCase)</ept> property.</source>
          <target state="translated">Cet objet <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> est retourné par la propriété <bpt id="p2">[</bpt>StringComparer.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparer.OrdinalIgnoreCase)</ept>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Array.Sort and Array.BinarySearch</source>
          <target state="translated">Array.Sort et Array.BinarySearch</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interprétation par défaut : <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>When you store any data in a collection, or read persisted data from a file or database into a collection, switching the current culture can invalidate the invariants in the collection.</source>
          <target state="translated">Quand vous stockez des données dans une collection ou quand vous lisez des données persistantes à partir d’un fichier ou d’une base de données dans une collection, le changement de culture actuelle peut invalider les invariants de la collection.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Array.BinarySearch<ept id="p1">](xref:System.Array.BinarySearch(System.Array,System.Object))</ept> method assumes that the elements in the array to be searched are already sorted.</source>
          <target state="translated">La méthode <bpt id="p1">[</bpt>Array.BinarySearch<ept id="p1">](xref:System.Array.BinarySearch(System.Array,System.Object))</ept> suppose que les éléments du tableau dans lequel effectuer la recherche sont déjà triés.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>To sort any string element in the array, the <bpt id="p1">[</bpt>Array.Sort<ept id="p1">](xref:System.Array.Sort(System.Array))</ept> method calls the [String] <ph id="ph1">`Compare`</ph> method to order individual elements.</source>
          <target state="translated">Pour trier tout élément de chaîne dans le tableau, la méthode <bpt id="p1">[</bpt>Array.Sort<ept id="p1">](xref:System.Array.Sort(System.Array))</ept> appelle la méthode [String] <ph id="ph1">`Compare`</ph> pour classer les éléments individuels.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Using a culture-sensitive comparer can be dangerous if the culture changes between the time that the array is sorted and its contents are searched.</source>
          <target state="translated">L'utilisation d'un comparateur dépendant de la culture peut s'avérer dangereux si la culture change entre le moment où le tableau est trié et le moment où son contenu fait l'objet d'une recherche.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>For example, in the following code, storage and retrieval operate on the comparer that is provided implicitly by the <ph id="ph1">`Thread.CurrentThread.CurrentCulture`</ph> property.</source>
          <target state="translated">Par exemple, dans le code suivant, le stockage et la récupération fonctionnent sur le comparateur fourni implicitement par la propriété <ph id="ph1">`Thread.CurrentThread.CurrentCulture`</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>If the culture can change between the calls to <ph id="ph1">`StoreNames`</ph> and <ph id="ph2">`DoesNameExist`</ph>, and especially if the array contents are persisted somewhere between the two method calls, the binary search may fail.</source>
          <target state="translated">Si la culture peut changer entre les appels à <ph id="ph1">`StoreNames`</ph> et <ph id="ph2">`DoesNameExist`</ph>, et surtout si le contenu du tableau est rendu persistant à un moment donné entre les deux appels de méthode, la recherche binaire peut échouer.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>A recommended variation appears in the following example, which uses the same ordinal (culture-insensitive) comparison method both to sort and to search the array.</source>
          <target state="translated">L'exemple suivant, qui utilise la même méthode de comparaison ordinale (indépendante de la culture) pour trier le tableau et pour effectuer une recherche, présente une variation recommandée.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The change code is reflected in the lines labeled <ph id="ph1">`Line A`</ph> and <ph id="ph2">`Line B`</ph> in the two examples.</source>
          <target state="translated">Le code de modification est reflété dans les lignes libellées <ph id="ph1">`Line A`</ph> et <ph id="ph2">`Line B`</ph> dans les deux exemples.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>If this data is persisted and moved across cultures, and sorting is used to present this data to the user, you might consider using <ph id="ph1">`StringComparison.InvariantCulture`</ph>, which operates linguistically for better user output but is unaffected by changes in culture.</source>
          <target state="translated">Si ces données sont rendues persistantes et déplacées dans toutes les cultures, et que le tri est utilisé pour présenter ces données à l'utilisateur, vous pouvez envisager d'utiliser <ph id="ph1">`StringComparison.InvariantCulture`</ph>, qui fonctionne linguistiquement pour une meilleure sortie d'utilisateur mais n'est pas affecté par les modifications apportées à la culture.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The following example modifies the two previous examples to use the invariant culture for sorting and searching the array.</source>
          <target state="translated">L'exemple suivant modifie les deux exemples précédents pour utiliser la culture dite indifférente pour le tri du tableau et la recherche dans celui-ci.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Collections Example: Hashtable Constructor</source>
          <target state="translated">Exemple de collections : constructeur Hashtable</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Hashing strings provides a second example of an operation that is affected by the way in which strings are compared.</source>
          <target state="translated">Le hachage de chaînes constitue un deuxième exemple d'opération qui est affectée par la façon dont des chaînes sont comparées.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following example instantiates a <bpt id="p1">[</bpt>Hashtable<ept id="p1">](xref:System.Collections.Hashtable)</ept> object by passing it the <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> object that is returned by the <bpt id="p3">[</bpt>StringComparer.OrdinalIgnoreCase<ept id="p3">](xref:System.StringComparer.OrdinalIgnoreCase)</ept> property.</source>
          <target state="translated">L’exemple suivant instancie un objet <bpt id="p1">[</bpt>Hashtable<ept id="p1">](xref:System.Collections.Hashtable)</ept> en lui passant l’objet <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> qui est retourné par la propriété <bpt id="p3">[</bpt>StringComparer.OrdinalIgnoreCase<ept id="p3">](xref:System.StringComparer.OrdinalIgnoreCase)</ept>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Because a class <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> that is derived from <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> implements the <bpt id="p3">[</bpt>IEqualityComparer<ept id="p3">](xref:System.Collections.IEqualityComparer)</ept> interface, its <bpt id="p4">[</bpt>GetHashCode<ept id="p4">](xref:System.Collections.IEqualityComparer)</ept> method is used to compute the hash code of strings in the hash table.</source>
          <target state="translated">Étant donné qu’une classe <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> dérivée de <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> implémente l’interface <bpt id="p3">[</bpt>IEqualityComparer<ept id="p3">](xref:System.Collections.IEqualityComparer)</ept>, sa méthode <bpt id="p4">[</bpt>GetHashCode<ept id="p4">](xref:System.Collections.IEqualityComparer)</ept> est utilisée pour calculer le code de hachage des chaînes dans la table de hachage.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Displaying and persisting formatted data</source>
          <target state="translated">Affichage et persistance des données mises en forme</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>When you display non-string data such as numbers and dates and times to users, format them by using the user's cultural settings.</source>
          <target state="translated">Lorsque vous affichez des données non-chaînées telles que les nombres et les dates et heures aux utilisateurs, mettez-les en forme en utilisant les paramètres de la culture de l'utilisateur.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>By default, the <bpt id="p1">[</bpt>String.Format<ept id="p1">](xref:System.String.Format(System.IFormatProvider,System.String,System.Object))</ept> method and the <ph id="ph1">`ToString`</ph> methods of the numeric types and the date and time types use the current thread culture for formatting operations.</source>
          <target state="translated">Par défaut, la méthode <bpt id="p1">[</bpt>String.Format<ept id="p1">](xref:System.String.Format(System.IFormatProvider,System.String,System.Object))</ept> et les méthodes <ph id="ph1">`ToString`</ph> des types numériques et des types de date et d’heure utilisent la culture du thread actuelle pour les opérations de mise en forme.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>To explicitly specify that the formatting method should use the current culture, you can call an overload of a formatting method that has a provider parameter, such as <bpt id="p1">[</bpt>String.Format(IFormatProvider, String, Object[])<ept id="p1">](xref:System.String.Format(System.IFormatProvider,System.String,System.Object))</ept> or <bpt id="p2">[</bpt>DateTime.ToString(IFormatProvider)<ept id="p2">](xref:System.DateTime.ToString(System.IFormatProvider))</ept>, and pass it the <bpt id="p3">[</bpt>CultureInfo.CurrentCulture<ept id="p3">](xref:System.Globalization.CultureInfo.CurrentCulture)</ept> property.</source>
          <target state="translated">Pour spécifier explicitement que la méthode de mise en forme doit utiliser la culture actuelle, vous pouvez appeler une surcharge d’une méthode de mise en forme qui a un paramètre de fournisseur, comme <bpt id="p1">[</bpt>String.Format(IFormatProvider, String, Object[])<ept id="p1">](xref:System.String.Format(System.IFormatProvider,System.String,System.Object))</ept> ou <bpt id="p2">[</bpt>DateTime.ToString(IFormatProvider)<ept id="p2">](xref:System.DateTime.ToString(System.IFormatProvider))</ept>, puis lui passer la propriété <bpt id="p3">[</bpt>CultureInfo.CurrentCulture<ept id="p3">](xref:System.Globalization.CultureInfo.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>You can persist non-string data either as binary data or as formatted data.</source>
          <target state="translated">Vous pouvez rendre persistantes des données non-chaînées soit comme données binaires, soit comme données mises en forme.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>If you choose to save it as formatted data, you should call a formatting method overload that includes a <bpt id="p1">*</bpt>provider<ept id="p1">*</ept> parameter and pass it the <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> property.</source>
          <target state="translated">Si vous choisissez de l’enregistrer comme données mises en forme, vous devez appeler une surcharge de méthode de mise en forme qui inclut un paramètre <bpt id="p1">*</bpt>provider<ept id="p1">*</ept> et le passer à la propriété <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The invariant culture provides a consistent format for formatted data that is independent of culture and machine.</source>
          <target state="translated">La culture dite indifférente fournit un format cohérent pour les données mises en forme qui est indépendant de la culture et de l'ordinateur.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>In contrast, persisting data that is formatted by using cultures other than the invariant culture has a number of limitations:</source>
          <target state="translated">En revanche, assurer la persistance de données mises en forme à l'aide de cultures autres que la culture dite indifférente a plusieurs limites :</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The data is likely to be unusable if it is retrieved on a system that has a different culture, or if the user of the current system changes the current culture and tries to retrieve the data.</source>
          <target state="translated">Les données seront vraisemblablement inutilisables si elles sont récupérées sur un système ayant une autre culture, ou si l'utilisateur du système actuel change la culture actuelle et essaie de récupérer les données.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The properties of a culture on a specific computer can differ from standard values.</source>
          <target state="translated">Les propriétés d'une culture sur un ordinateur spécifique peuvent différer des valeurs standard.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>At any time, a user can customize culture-sensitive display settings.</source>
          <target state="translated">À tout moment, un utilisateur peut personnaliser les paramètres d'affichage selon la culture.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Because of this, formatted data that is saved on a system may not be readable after the user customizes cultural settings.</source>
          <target state="translated">De ce fait, les données mises en forme sont stockées sur un système et peuvent ne pas être lisibles lorsque l'utilisateur personnalise les paramètres de culture.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The portability of formatted data across computers is likely to be even more limited.</source>
          <target state="translated">La portabilité des données mises en forme sur différents ordinateurs peut être encore plus limitée.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>International, regional, or national standards that govern the formatting of numbers or dates and times change over time, and these changes are incorporated into operating system updates.</source>
          <target state="translated">Les normes internationales, régionales ou nationales qui régissent la mise en forme des nombres ou des dates et heures évoluent au fil du temps, et ces modifications sont intégrées dans les mises à jour du système d’exploitation.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>When formatting conventions change, data that was formatted by using the previous conventions may become unreadable.</source>
          <target state="translated">Quand les conventions de mise en forme changent, les données qui ont été mises en forme en utilisant les conventions antérieures peuvent devenir illisibles.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The following example illustrates the limited portability that results from using culture-sensitive formatting to persist data.</source>
          <target state="translated">L'exemple suivant illustre la portabilité limitée qui résulte de l'utilisation de la mise en forme qui tient compte de la culture pour assurer la persistance des données.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The example saves an array of date and time values to a file.</source>
          <target state="translated">L'exemple enregistre un tableau de valeurs de date et d'heure dans un fichier.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>These are formatted by using the conventions of the English (United States) culture.</source>
          <target state="translated">Celles-ci sont mises en forme en utilisant les conventions culturelles de l'anglais (États-Unis).</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>After the application changes the current thread culture to French (Switzerland), it tries to read the saved values by using the formatting conventions of the current culture.</source>
          <target state="translated">Une fois que l'application change la culture du thread actuel pour appliquer le français (Suisse), elle essaie de lire les valeurs enregistrées en utilisant les conventions de mise en forme de la culture actuelle.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The attempt to read two of the data items throws a <bpt id="p1">[</bpt>FormatException<ept id="p1">](xref:System.FormatException)</ept> exception, and the array of dates now contains two incorrect elements that are equal to <bpt id="p2">[</bpt>MinValue<ept id="p2">](xref:System.DateTime.MinValue)</ept>.</source>
          <target state="translated">La tentative de lecture de deux des éléments de données lève une exception <bpt id="p1">[</bpt>FormatException<ept id="p1">](xref:System.FormatException)</ept> et le tableau de dates contient maintenant deux éléments incorrects égaux à <bpt id="p2">[</bpt>MinValue<ept id="p2">](xref:System.DateTime.MinValue)</ept>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>However, if you replace the <bpt id="p1">[</bpt>CultureInfo.CurrentCulture<ept id="p1">](xref:System.Globalization.CultureInfo.CurrentCulture)</ept> property with <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> in the calls to <bpt id="p3">[</bpt>DateTime.ToString(String, IFormatProvider)<ept id="p3">](xref:System.DateTime.ToString(System.String,System.IFormatProvider))</ept> and <bpt id="p4">[</bpt>DateTime.Parse(String, IFormatProvider)<ept id="p4">](xref:System.DateTime.Parse(System.String,System.IFormatProvider))</ept>, the persisted date and time data is successfully restored, as the following output shows.</source>
          <target state="translated">Toutefois, si vous remplacez la propriété <bpt id="p1">[</bpt>CultureInfo.CurrentCulture<ept id="p1">](xref:System.Globalization.CultureInfo.CurrentCulture)</ept> par <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> dans les appels à <bpt id="p3">[</bpt>DateTime.ToString(String, IFormatProvider)<ept id="p3">](xref:System.DateTime.ToString(System.String,System.IFormatProvider))</ept> et <bpt id="p4">[</bpt>DateTime.Parse(String, IFormatProvider)<ept id="p4">](xref:System.DateTime.Parse(System.String,System.IFormatProvider))</ept>, les données de date et d’heure persistantes sont correctement restaurées, comme le montre la sortie suivante.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Manipulating strings<ept id="p1">](manipulating-strings.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Manipulation de chaînes<ept id="p1">](manipulating-strings.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>