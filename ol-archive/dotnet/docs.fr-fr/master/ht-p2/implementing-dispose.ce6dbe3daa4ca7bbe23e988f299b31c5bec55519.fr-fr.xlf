<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dfe2cebfbcf1f4c2697683ebda8c1e11567fd015</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\garbagecollection\implementing-dispose.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9c767e094bcc0eeef3aa68e876ddf7c6b336dc37</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a104a3574d5165774f427301e61a67f85eb2407f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Implementing a dispose method</source>
          <target state="translated">Implémentation d’une méthode Dispose</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Implementing a dispose method</source>
          <target state="translated">Implémentation d’une méthode Dispose</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Implementing a dispose method</source>
          <target state="translated">Implémentation d’une méthode Dispose</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You implement a <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> method to release unmanaged resources used by your application.</source>
          <target state="translated">Vous implémentez une méthode <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> pour libérer les ressources non managées utilisées par votre application.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The .NET garbage collector does not allocate or release unmanaged memory.</source>
          <target state="translated">Le Garbage collector .NET n’alloue pas de mémoire non managée, et n’en libère pas non plus.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The pattern for disposing an object, referred to as a dispose pattern, imposes order on the lifetime of an object.</source>
          <target state="translated">Le modèle pour supprimer un objet, dénommé « modèle de suppression », impose un ordre sur la durée de vie d’un objet.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The dispose pattern is used only for objects that access unmanaged resources, such as file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</source>
          <target state="translated">Le modèle de suppression est utilisé uniquement pour les objets qui accèdent à des ressources non managées, telles que les handles de fichiers et de canaux, les handles d’attente, les handles d’attente ou les pointeurs vers les blocs de mémoire non managée.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This is because the garbage collector is very efficient at reclaiming unused managed objects, but it is unable to reclaim unmanaged objects.</source>
          <target state="translated">Cela est dû au fait que le récupérateur de mémoire est très efficace pour récupérer les objets managés inutilisés, mais ne peut pas récupérer les objets non managés.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The dispose pattern has two variations:</source>
          <target state="translated">Le modèle de suppression comporte deux variantes :</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You wrap each unmanaged resource that a type uses in a safe handle (that is, in a class derived from <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept>).</source>
          <target state="translated">Vous encapsulez chaque ressource non managée utilisée par un type dans un handle sécurisé (autrement dit, dans une classe dérivée de <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept>).</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In this case, you implement the <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> interface and an additional <ph id="ph1">`Dispose(Boolean)`</ph> method.</source>
          <target state="translated">Dans ce cas, vous implémentez l’interface <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> et une méthode <ph id="ph1">`Dispose(Boolean)`</ph> supplémentaire.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This is the recommended variation and doesn't require overriding the <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> method.</source>
          <target state="translated">Il s’agit de la variante recommandée. Elle ne requiert pas le remplacement de la méthode <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Microsoft.Win32.SafeHandles<ept id="p1">](xref:Microsoft.Win32.SafeHandles)</ept> namespace provides a set of classes derived from <bpt id="p2">[</bpt>SafeHandle<ept id="p2">](xref:System.Runtime.InteropServices.SafeHandle)</ept>, which are listed in the <bpt id="p3">[</bpt>Using safe handles<ept id="p3">](#using-safe-handles)</ept> section.</source>
          <target state="translated">L’espace de noms <bpt id="p1">[</bpt>Microsoft.Win32.SafeHandles<ept id="p1">](xref:Microsoft.Win32.SafeHandles)</ept> fournit un ensemble de classes dérivées de <bpt id="p2">[</bpt>SafeHandle<ept id="p2">](xref:System.Runtime.InteropServices.SafeHandle)</ept>, qui sont répertoriées dans la section <bpt id="p3">[</bpt>Utilisation des handles sécurisés<ept id="p3">](#using-safe-handles)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept>.</source>
          <target state="translated">Si vous ne parvenez pas à trouver une classe qui convient pour libérer votre ressource non managée, vous pouvez implémenter votre propre sous-classe de <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You implement the <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> interface and an additional <ph id="ph1">`Dispose(Boolean`</ph>) method, and you also override the <bpt id="p2">[</bpt>Object.Finalize<ept id="p2">](xref:System.Object.Finalize)</ept> method.</source>
          <target state="translated">Vous implémentez l’interface <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> et une méthode <ph id="ph1">`Dispose(Boolean`</ph>) supplémentaire, puis vous remplacez la méthode <bpt id="p2">[</bpt>Object.Finalize<ept id="p2">](xref:System.Object.Finalize)</ept>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You must override <bpt id="p1">[</bpt>Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> to ensure that unmanaged resources are disposed of if your <bpt id="p2">[</bpt>IDisposable.Dispose<ept id="p2">](xref:System.IDisposable.Dispose)</ept> implementation is not called by a consumer of your type.</source>
          <target state="translated">Vous devez remplacer <bpt id="p1">[</bpt>Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> pour garantir que les ressources non managées sont supprimées si votre implémentation de <bpt id="p2">[</bpt>IDisposable.Dispose<ept id="p2">](xref:System.IDisposable.Dispose)</ept> n’est pas appelée par un consommateur de votre type.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you use the recommended technique discussed in the previous bullet, the <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> class does this on your behalf.</source>
          <target state="translated">Si vous utilisez la technique recommandée présentée dans le point précédent, la classe <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> effectue cette opération en votre nom.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To help ensure that resources are always cleaned up appropriately, a <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> method should be callable multiple times without throwing an exception.</source>
          <target state="translated">Pour garantir que les ressources sont toujours correctement nettoyées, une méthode <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> doit pouvoir être appelée à plusieurs reprises sans lever d’exception.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The code example provided for the <bpt id="p1">[</bpt>GC.KeepAlive<ept id="p1">](xref:System.GC.KeepAlive(System.Object))</ept> method shows how aggressive garbage collection can cause a finalizer to run while a member of the reclaimed object is still executing.</source>
          <target state="translated">L’exemple de code fourni pour la méthode <bpt id="p1">[</bpt>GC.KeepAlive<ept id="p1">](xref:System.GC.KeepAlive(System.Object))</ept> affiche la façon dont un garbage collection agressif peut entraîner l’exécution d’un finaliseur pendant qu’un membre de l’objet demandé est toujours en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>It is a good idea to call the <bpt id="p1">[</bpt>KeepAlive<ept id="p1">](xref:System.GC.KeepAlive(System.Object))</ept> method at the end of a lengthy <ph id="ph1">`Dispose`</ph> method.</source>
          <target state="translated">Il est conseillé d’appeler la méthode <bpt id="p1">[</bpt>KeepAlive<ept id="p1">](xref:System.GC.KeepAlive(System.Object))</ept> à la fin d’une méthode <ph id="ph1">`Dispose`</ph> longue.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Dispose() and Dispose(Boolean)</source>
          <target state="translated">Dispose() et Dispose(Boolean)</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> interface requires the implementation of a single parameterless method, <bpt id="p2">[</bpt>Dispose<ept id="p2">](xref:System.IDisposable.Dispose)</ept>.</source>
          <target state="translated">L’interface <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> exige l’implémentation d’une méthode unique sans paramètre, <bpt id="p2">[</bpt>Dispose<ept id="p2">](xref:System.IDisposable.Dispose)</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>However, the dispose pattern requires two <ph id="ph1">`Dispose`</ph> methods to be implemented:</source>
          <target state="translated">Toutefois, le modèle de suppression requiert deux méthodes <ph id="ph1">`Dispose`</ph> à implémenter :</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A public non-virtual (<ph id="ph1">`NonInheritable`</ph> in Visual Basic) <bpt id="p1">[</bpt>IDisposable.Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> implementation that has no parameters.</source>
          <target state="translated">Implémentation non virtuelle publique de <bpt id="p1">[</bpt>IDisposable.Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> (<ph id="ph1">`NonInheritable`</ph> en Visual Basic) qui n’a aucun paramètre.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>A protected virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic) <ph id="ph2">`Dispose`</ph> method whose signature is:</source>
          <target state="translated">Méthode virtuelle (<ph id="ph1">`Overridable`</ph> en Visual Basic) <ph id="ph2">`Dispose`</ph> dont la signature est :</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The Dispose() overload</source>
          <target state="translated">Surcharge de Dispose()</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Because the public, non-virtual (<ph id="ph1">`NonInheritable`</ph> in Visual Basic), parameterless <ph id="ph2">`Dispose`</ph> method is called by a consumer of the type, its purpose is to free unmanaged resources and to indicate that the finalizer, if one is present, doesn't have to run.</source>
          <target state="translated">Comme la méthode <ph id="ph1">`NonInheritable`</ph> sans paramètre non virtuelle (<ph id="ph2">`Dispose`</ph> en Visual Basic) publique est appelée par un consommateur de type, son objectif est de libérer les ressources non managées et d'indiquer que le finaliseur, s'il en existe un, ne doit pas s'exécuter.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Because of this, it has a standard implementation:</source>
          <target state="translated">De ce fait, son implémentation standard est la suivante :</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Dispose`</ph> method performs all object cleanup, so the garbage collector no longer needs to call the objects' <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> override.</source>
          <target state="translated">La méthode <ph id="ph1">`Dispose`</ph> effectue le nettoyage de tous les objets. Le Garbage collector n’a plus donc besoin d’appeler la substitution <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept>des objets.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Therefore, the call to the <bpt id="p1">[</bpt>GC.SuppressFinalize<ept id="p1">](xref:System.GC.SuppressFinalize(System.Object))</ept> method prevents the garbage collector from running the finalizer.</source>
          <target state="translated">Par conséquent, l’appel à la méthode <bpt id="p1">[</bpt>GC.SuppressFinalize<ept id="p1">](xref:System.GC.SuppressFinalize(System.Object))</ept> empêche le Garbage collector d’exécuter le finaliseur.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If the type has no finalizer, the call to <bpt id="p1">[</bpt>SuppressFinalize<ept id="p1">](xref:System.GC.SuppressFinalize(System.Object))</ept> has no effect.</source>
          <target state="translated">Si le type n’a pas de finaliseur, l’appel à <bpt id="p1">[</bpt>SuppressFinalize<ept id="p1">](xref:System.GC.SuppressFinalize(System.Object))</ept> n’a aucun effet.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Note that the actual work of releasing unmanaged resources is performed by the second overload of the <ph id="ph1">`Dispose`</ph> method.</source>
          <target state="translated">Notez que le travail réel de libération des ressources non managées est effectué par la deuxième surcharge de la méthode <ph id="ph1">`Dispose`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The Dispose(Boolean) overload</source>
          <target state="translated">Surcharge de Dispose(Boolean)</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In the second overload, the <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> parameter is a <bpt id="p2">[</bpt>Boolean<ept id="p2">](xref:System.Boolean)</ept> that indicates whether the method call comes from a <bpt id="p3">[</bpt>Dispose<ept id="p3">](xref:System.IDisposable.Dispose)</ept> method (its value is <ph id="ph1">`true`</ph>) or from a finalizer (its value is <ph id="ph2">`false`</ph>).</source>
          <target state="translated">Dans la seconde surcharge, le paramètre <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> est un <bpt id="p2">[</bpt>Boolean<ept id="p2">](xref:System.Boolean)</ept> qui indique si l’appel de la méthode provient d’une méthode <bpt id="p3">[</bpt>Dispose<ept id="p3">](xref:System.IDisposable.Dispose)</ept> (sa valeur est <ph id="ph1">`true`</ph>) ou d’un finaliseur (sa valeur est <ph id="ph2">`false`</ph>).</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The body of the method consists of two blocks of code:</source>
          <target state="translated">Le corps de la méthode se compose de deux blocs de code :</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>A block that frees unmanaged resources.</source>
          <target state="translated">Un bloc qui libère les ressources non managées.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This block executes regardless of the value of the <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> parameter.</source>
          <target state="translated">Ce bloc s’exécute indépendamment de la valeur du paramètre <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A conditional block that frees managed resources.</source>
          <target state="translated">Un bloc conditionnel qui libère les ressources managées.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This block executes if the value of <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Ce bloc s’exécute si la valeur de <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> est <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The managed resources that it frees can include:</source>
          <target state="translated">Les ressources managées qu'il libère peuvent inclure :</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Managed objects that implement IDisposable<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Objets managés qui implémentent IDisposable<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The conditional block can be used to call their <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> implementation.</source>
          <target state="translated">Le bloc conditionnel peut être utilisé pour appeler leur implémentation de <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If you have used a safe handle to wrap your unmanaged resource, you should call the <bpt id="p1">[</bpt>SafeHandle.Dispose(Boolean<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean))</ept> implementation here.</source>
          <target state="translated">Si vous avez utilisé un handle sécurisé pour encapsuler votre ressource non managée, vous devez appeler l’implémentation de <bpt id="p1">[</bpt>SafeHandle.Dispose(Boolean<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean))</ept> ici.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Managed objects that consume large amounts of memory or consume scarce resources.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Objets managés qui consomment de grandes quantités de mémoire ou consomment des ressources rares.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Freeing these objects explicitly in the <ph id="ph1">`Dispose`</ph> method releases them faster than if they were reclaimed non-deterministically by the garbage collector.</source>
          <target state="translated">La libération de ces objets explicitement dans la méthode <ph id="ph1">`Dispose`</ph> les libère plus rapidement que s'ils ont été récupérés de façon non déterministe par le récupérateur de mémoire.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If the method call comes from a finalizer (that is, if <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> is <ph id="ph1">`false`</ph>), only the code that frees unmanaged resources executes.</source>
          <target state="translated">Si l’appel de la méthode vient d’un finaliseur (autrement dit, si <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> a la valeur <ph id="ph1">`false`</ph>), seul le code qui libère les ressources non managées s’exécute.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Because the order in which the garbage collector destroys managed objects during finalization is not defined, calling this <ph id="ph1">`Dispose`</ph> overload with a value of <ph id="ph2">`false`</ph> prevents the finalizer from trying to release managed resources that may have already been reclaimed.</source>
          <target state="translated">Étant donné que l'ordre dans lequel le récupérateur de mémoire détruit les objets managés pendant la finalisation n'est pas défini, l'appel de cette surcharge <ph id="ph1">`Dispose`</ph> avec la valeur <ph id="ph2">`false`</ph> empêche le finaliseur d'essayer de libérer les ressources managées qui peuvent avoir déjà été récupérées.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Implementing the dispose pattern for a base class</source>
          <target state="translated">Implémentation du modèle de suppression d'une classe de base</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If you implement the dispose pattern for a base class, you must provide the following:</source>
          <target state="translated">Si vous implémentez le modèle de suppression d’une classe de base, vous devez spécifier ce qui suit :</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You should implement this pattern for all base classes that implement <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> and are not <ph id="ph1">`sealed`</ph>.</source>
          <target state="translated">Vous devez implémenter ce modèle pour toutes les classes de base qui implémentent <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> et qui ne sont pas <ph id="ph1">`sealed`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> implementation that calls the <ph id="ph1">`Dispose(Boolean)`</ph> method.</source>
          <target state="translated">Une implémentation de <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> qui appelle la méthode <ph id="ph1">`Dispose(Boolean)`</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dispose(Boolean)`</ph> method that performs the actual work of releasing resources.</source>
          <target state="translated">Une méthode <ph id="ph1">`Dispose(Boolean)`</ph> qui effectue le travail réel de libération des ressources.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Either a class derived from <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> that wraps your unmanaged resource (recommended), or an override to the <bpt id="p2">[</bpt>Object.Finalize<ept id="p2">](xref:System.Object.Finalize)</ept> method.</source>
          <target state="translated">Une classe dérivée de <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> qui encapsule votre ressource managée (recommandée) ou une substitution de la méthode <bpt id="p2">[</bpt>Object.Finalize<ept id="p2">](xref:System.Object.Finalize)</ept>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept>SafeHandle class provides a finalizer that frees you from having to code one.</source>
          <target state="translated">La classe <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> fournit un finaliseur qui vous permet de ne pas avoir à en coder un.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</source>
          <target state="translated">Voici le modèle général d’implémentation du modèle de suppression d’une classe de base qui utilise un handle sécurisé.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The previous example uses a <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> object to illustrate the pattern; any object derived from <bpt id="p2">[</bpt>SafeHandle<ept id="p2">](xref:System.Runtime.InteropServices.SafeHandle)</ept> could be used instead.</source>
          <target state="translated">L’exemple précédent utilise un objet <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> pour illustrer le modèle, mais il est possible d’utiliser à la place n’importe quel objet dérivé de <bpt id="p2">[</bpt>SafeHandle<ept id="p2">](xref:System.Runtime.InteropServices.SafeHandle)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Note that the example does not properly instantiate its <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> object.</source>
          <target state="translated">Notez que l’exemple n’instancie pas correctement son objet <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Here's the general pattern for implementing the dispose pattern for a base class that overrides <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept>.</source>
          <target state="translated">Voici le modèle général d’implémentation du modèle de suppression d’une classe de base qui remplace <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In C#, you override <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> by defining a <ph id="ph1">`destructor`</ph>.</source>
          <target state="translated">En C#, vous substituez <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> en définissant un <ph id="ph1">`destructor`</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Implementing the dispose pattern for a derived class</source>
          <target state="translated">Implémentation du modèle de suppression d’une classe dérivée</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A class derived from a class that implements the <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> interface shouldn't implement <bpt id="p2">[</bpt>IDisposable<ept id="p2">](xref:System.IDisposable)</ept>, because the base class implementation of <bpt id="p3">[</bpt>IDisposable.Dispose<ept id="p3">](xref:System.IDisposable.Dispose)</ept> is inherited by its derived classes.</source>
          <target state="translated">Une classe dérivée d’une classe qui implémente l’interface <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> ne doit pas implémenter <bpt id="p2">[</bpt>IDisposable<ept id="p2">](xref:System.IDisposable)</ept>, car l’implémentation de la classe de base de <bpt id="p3">[</bpt>IDisposable.Dispose<ept id="p3">](xref:System.IDisposable.Dispose)</ept> est héritée par ses classes dérivées.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Instead, to implement the dispose pattern for a derived class, you provide the following:</source>
          <target state="translated">À la place, pour implémenter le modèle de suppression d’une classe dérivée, vous fournissez ce qui suit :</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`protected Dispose(Boolean)`</ph> method that overrides the base class method and performs the actual work of releasing the resources of the derived class.</source>
          <target state="translated">Une méthode <ph id="ph1">`protected Dispose(Boolean)`</ph> qui substitue la méthode de la classe de base et effectue le travail réel de libération des ressources de la classe dérivée.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This method should also call the <ph id="ph1">`Dispose(Boolean)`</ph> method of the base class and pass it a value of <ph id="ph2">`true`</ph> for the <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> argument.</source>
          <target state="translated">Cette méthode doit également appeler la méthode <ph id="ph1">`Dispose(Boolean)`</ph> de la classe de base et lui passer une valeur <ph id="ph2">`true`</ph> pour l’argument <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Either a class derived from <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> that wraps your unmanaged resource (recommended), or an override to the <bpt id="p2">[</bpt>Object.Finalize<ept id="p2">](xref:System.Object.Finalize)</ept> method.</source>
          <target state="translated">Une classe dérivée de <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> qui encapsule votre ressource managée (recommandée) ou une substitution de la méthode <bpt id="p2">[</bpt>Object.Finalize<ept id="p2">](xref:System.Object.Finalize)</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> class provides a finalizer that frees you from having to code one.</source>
          <target state="translated">La classe <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept>fournit un finaliseur qui vous permet de ne pas avoir à en coder un.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If you do provide a finalizer, it should call the <ph id="ph1">`Dispose(Boolean)`</ph> overload with a <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> argument of <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si vous fournissez un finaliseur, il doit appeler la surcharge <ph id="ph1">`Dispose(Boolean)`</ph> avec un argument <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> égal à <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</source>
          <target state="translated">Voici le modèle général d’implémentation du modèle de suppression d’une classe dérivée qui utilise un handle sécurisé :</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The previous example uses a <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> object to illustrate the pattern; any object derived from <bpt id="p2">[</bpt>SafeHandle<ept id="p2">](xref:System.Runtime.InteropServices.SafeHandle)</ept> could be used instead.</source>
          <target state="translated">L’exemple précédent utilise un objet <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> pour illustrer le modèle, mais il est possible d’utiliser à la place n’importe quel objet dérivé de <bpt id="p2">[</bpt>SafeHandle<ept id="p2">](xref:System.Runtime.InteropServices.SafeHandle)</ept>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Note that the example does not properly instantiate its <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> object.</source>
          <target state="translated">Notez que l’exemple n’instancie pas correctement son objet <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Here's the general pattern for implementing the dispose pattern for a derived class that overrides <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept>:</source>
          <target state="translated">Voici le modèle général d’implémentation du modèle de suppression d’une classe dérivée qui remplace <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> :</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In C#, you override <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> by defining a <ph id="ph1">`destructor`</ph>.</source>
          <target state="translated">En C#, vous substituez <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> en définissant un <ph id="ph1">`destructor`</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Using safe handles</source>
          <target state="translated">Utilisation des handles sécurisés</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</source>
          <target state="translated">L’écriture de code pour le finaliseur d’un objet est une tâche complexe qui peut provoquer des problèmes si elle n’est pas effectuée correctement.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Therefore, we recommend that you construct <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> objects instead of implementing a finalizer.</source>
          <target state="translated">Par conséquent, nous vous recommandons de construire des objets <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> au lieu d’implémenter un finaliseur.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Classes derived from the <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> class simplify object lifetime issues by assigning and releasing handles without interruption.</source>
          <target state="translated">Les classes dérivées de la classe <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> simplifient les problèmes de durée de vie des objets en assignant et en libérant des handles sans interruption.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>They contain a critical finalizer that is guaranteed to run while an application domain is unloading.</source>
          <target state="translated">Elles contiennent un finaliseur critique dont le fonctionnement pendant le déchargement d'un domaine d'application est garanti.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The following derived classes in the <bpt id="p1">[</bpt>Microsoft.Win32.SafeHandles<ept id="p1">](xref:Microsoft.Win32.SafeHandles)</ept> namespace provide safe handles:</source>
          <target state="translated">Les classes dérivées suivantes de l’espace de noms <bpt id="p1">[</bpt>Microsoft.Win32.SafeHandles<ept id="p1">](xref:Microsoft.Win32.SafeHandles)</ept> fournissent des handles sécurisés :</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept>, <bpt id="p2">[</bpt>SafeMemoryMappedFileHandle<ept id="p2">](xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle)</ept>, and <bpt id="p3">[</bpt>SafePipeHandle<ept id="p3">](xref:Microsoft.Win32.SafeHandles.SafePipeHandle)</ept> class, for files, memory mapped files, and pipes.</source>
          <target state="translated">La classe <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept>, <bpt id="p2">[</bpt>SafeMemoryMappedFileHandle<ept id="p2">](xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle)</ept> et <bpt id="p3">[</bpt>SafePipeHandle<ept id="p3">](xref:Microsoft.Win32.SafeHandles.SafePipeHandle)</ept>, pour les fichiers, les fichiers mappés en mémoire et les canaux.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeMemoryMappedViewHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle)</ept> class, for memory views.</source>
          <target state="translated">La classe <bpt id="p1">[</bpt>SafeMemoryMappedViewHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle)</ept>, pour les vues de la mémoire.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeNCryptKeyHandle<ept id="p1">](https://msdn.microsoft.com/en-us/library/microsoft.win32.safehandles.safencryptkeyhandle(v=vs.110).aspx)</ept>, <bpt id="p2">[</bpt>SafeNCryptProviderHandle<ept id="p2">](https://msdn.microsoft.com/en-us/library/microsoft.win32.safehandles.safencryptproviderhandle(v=vs.110).aspx)</ept>, and <bpt id="p3">[</bpt>SafeNCryptSecretHandle<ept id="p3">](https://msdn.microsoft.com/en-us/library/microsoft.win32.safehandles.safencryptsecrethandle(v=vs.110).aspx)</ept> classes, for cryptography constructs.</source>
          <target state="translated">Les classes <bpt id="p1">[</bpt>SafeNCryptKeyHandle<ept id="p1">](https://msdn.microsoft.com/en-us/library/microsoft.win32.safehandles.safencryptkeyhandle(v=vs.110).aspx)</ept>, <bpt id="p2">[</bpt>SafeNCryptProviderHandle<ept id="p2">](https://msdn.microsoft.com/en-us/library/microsoft.win32.safehandles.safencryptproviderhandle(v=vs.110).aspx)</ept> et <bpt id="p3">[</bpt>SafeNCryptSecretHandle<ept id="p3">](https://msdn.microsoft.com/en-us/library/microsoft.win32.safehandles.safencryptsecrethandle(v=vs.110).aspx)</ept>, pour les constructions de chiffrement.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeRegistryHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle)</ept> class, for registry keys.</source>
          <target state="translated">La classe <bpt id="p1">[</bpt>SafeRegistryHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle)</ept>, pour les clés de Registre.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeWaitHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeWaitHandle)</ept> class, for wait handles.</source>
          <target state="translated">La classe <bpt id="p1">[</bpt>SafeWaitHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeWaitHandle)</ept>, pour les handles d’attente.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Using a safe handle to implement the dispose pattern for a base class</source>
          <target state="translated">Utilisation d’un handle sécurisé pour implémenter le modèle de suppression d’une classe de base</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The following example illustrates the dispose pattern for a base class, <ph id="ph1">`DisposableStreamResource`</ph>, that uses a safe handle to encapsulate unmanaged resources.</source>
          <target state="translated">L'exemple suivant illustre le modèle de suppression d'une classe de base, <ph id="ph1">`DisposableStreamResource`</ph>, qui utilise un handle sécurisé pour encapsuler les ressources non managées.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>It defines a <ph id="ph1">`DisposableResource`</ph> class that uses a <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> to wrap a <bpt id="p2">[</bpt>Stream<ept id="p2">](xref:System.IO.Stream)</ept> object that represents an open file.</source>
          <target state="translated">Il définit une classe <ph id="ph1">`DisposableResource`</ph>qui utilise un <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> pour encapsuler un objet <bpt id="p2">[</bpt>Stream<ept id="p2">](xref:System.IO.Stream)</ept> qui représente un fichier ouvert.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`DisposableResource`</ph> method also includes a single property, <ph id="ph2">`Size`</ph>, that returns the total number of bytes in the file stream.</source>
          <target state="translated">La méthode <ph id="ph1">`DisposableResource`</ph> inclut également une seule propriété, <ph id="ph2">`Size`</ph>, qui retourne le nombre total d'octets du flux de fichier.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Using a safe handle to implement the dispose pattern for a derived class</source>
          <target state="translated">Utilisation d'un handle sécurisé pour implémenter le modèle de suppression d'une classe dérivée</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The following example illustrates the dispose pattern for a derived class, <ph id="ph1">`DisposableStreamResource2`</ph>, that inherits from the <ph id="ph2">`DisposableStreamResource`</ph> class presented in the previous example.</source>
          <target state="translated">L'exemple suivant illustre le modèle de suppression d'une classe dérivée, <ph id="ph1">`DisposableStreamResource2`</ph>, qui hérite de la classe <ph id="ph2">`DisposableStreamResource`</ph> présentée dans l'exemple précédent.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The class adds an additional method, <ph id="ph1">`WriteFileInfo`</ph>, and uses a <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> object to wrap the handle of the writable file.</source>
          <target state="translated">La classe ajoute une méthode supplémentaire, <ph id="ph1">`WriteFileInfo`</ph>, et utilise un objet <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> pour encapsuler le handle du fichier accessible en écriture.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SuppressFinalize<ept id="p1">](xref:System.GC.SuppressFinalize(System.Object))</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>SuppressFinalize<ept id="p1">](xref:System.GC.SuppressFinalize(System.Object))</ept></target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept></target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IDisposable.Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IDisposable.Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept></target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Microsoft.Win32.SafeHandles<ept id="p1">](xref:Microsoft.Win32.SafeHandles)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Microsoft.Win32.SafeHandles<ept id="p1">](xref:Microsoft.Win32.SafeHandles)</ept></target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept></target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IDisposable.Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IDisposable.Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>