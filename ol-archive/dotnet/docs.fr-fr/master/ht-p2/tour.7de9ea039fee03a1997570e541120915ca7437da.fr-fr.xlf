<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02e2fa22e36fd2f6618527ad3c89cbbd8587dfe2</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\tour.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b5d2ad1e76f36733598999f425a89b00a11b9cd</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">486574494fd69fdc2cf6ac253f6e6e902ee27923</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Tour of .NET</source>
          <target state="translated">Présentation de .NET</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>A guided tour through some of the prominent features of the .NET platform.</source>
          <target state="translated">Visite guidée de certaines fonctionnalités principales de la plateforme .NET.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, Tour, Programming Languages, Unsafe, Memory Management, Type Safety, Async</source>
          <target state="translated">.NET, .NET Core, Présentation, Langages de programmation, Non sécurisé, Gestion de la mémoire, Cohérence des types, Asynchrone</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Tour of .NET</source>
          <target state="translated">Présentation de .NET</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>.NET is a general purpose development platform.</source>
          <target state="translated">.NET est une plateforme de développement généraliste.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It has several key features, such as multiple programming languages, asynchronous and concurrent programming models, and native interoperability which enable a wide range of scenarios across multiple platforms.</source>
          <target state="translated">Elle comporte plusieurs fonctionnalités clés, telles que plusieurs langages de programmation, des modèles de programmation asynchrone et simultanée et une interopérabilité native, qui permettent un large éventail de scénarios sur plusieurs plateformes.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This article offers a guided tour through some of the key features of the .NET platform.</source>
          <target state="translated">Cet article propose une visite guidée de certaines fonctionnalités principales de la plateforme .NET.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>.NET Architectural Components<ept id="p1">](components.md)</ept> to learn about each of the architectural "pieces" of .NET and what they're used for.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>Composants architecturaux de .NET<ept id="p1">](components.md)</ept> pour en savoir plus sur chacune des « parties » architecturales de .NET et sur leur finalité.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>How to run the code samples</source>
          <target state="translated">Guide pratique pour exécuter les exemples de code</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To learn how to set up a development environment to run the code samples, check out <bpt id="p1">[</bpt>Getting Started<ept id="p1">](getting-started.md)</ept>.</source>
          <target state="translated">Pour savoir comment configurer un environnement de développement pour exécuter les exemples de code, consultez <bpt id="p1">[</bpt>Bien démarrer<ept id="p1">](getting-started.md)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can copy and paste code samples from this page into your environment to execute them.</source>
          <target state="translated">Vous pouvez copier et coller les exemples de code à partir de cette page dans votre environnement pour les exécuter.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In the future, this documentation site will have the ability to run these code samples in your browser.</source>
          <target state="translated">À l’avenir, ce site de documentation pourra exécuter ces exemples de code dans votre navigateur.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Programming languages</source>
          <target state="translated">Langages de programmation</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>.NET supports multiple programming languages.</source>
          <target state="translated">.NET prend en charge plusieurs langages de programmation.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>.NET runtimes implement the <bpt id="p1">[</bpt>Common Language Infrastructure (CLI)<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>, which (among other things) specifies a language-independent runtime and language interoperability.</source>
          <target state="translated">Les runtimes .NET implémentent le <bpt id="p1">[</bpt>Common Language Infrastructure (CLI)<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>, qui, entre autres, spécifie un runtime indépendant du langage et une interopérabilité des langages.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This means that you can choose any .NET language to build apps and services on .NET.</source>
          <target state="translated">Cela signifie que vous pouvez choisir n’importe quel langage .NET pour générer des applications et services sur .NET.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic .NET.</source>
          <target state="translated">Microsoft développe et prend en charge activement trois langages .NET : C#, F# et Visual Basic .NET.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages.</source>
          <target state="translated">C# est simple, puissant, de type sécurisé et orienté objet, tout en conservant l’expressivité et l’élégance des langages de style C.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Anyone familiar with C and similar languages will find few problems in adapting to C#.</source>
          <target state="translated">Les utilisateurs familiarisés avec le langage C et les langages similaires auront peu de difficultés à s’adapter à C#.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>C# Guide<ept id="p1">](../csharp/index.md)</ept> to learn more about C#.</source>
          <target state="translated">Consultez le <bpt id="p1">[</bpt>Guide C#<ept id="p1">](../csharp/index.md)</ept> pour en savoir plus sur C#.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</source>
          <target state="translated">F# est un langage de programmation multiplateforme et fonctionnel qui prend également en charge la programmation orientée objet et impérative traditionnelle.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>F# Guide<ept id="p1">](../fsharp/index.md)</ept> to learn more about F#.</source>
          <target state="translated">Consultez le <bpt id="p1">[</bpt>Guide F#<ept id="p1">](../fsharp/index.md)</ept> pour en savoir plus sur F#.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.</source>
          <target state="translated">Visual Basic est un langage facile à apprendre que vous pouvez utiliser pour créer une variété d’applications qui s’exécutent sur .NET.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Automatic memory management</source>
          <target state="translated">Gestion automatique de la mémoire</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>.NET uses <bpt id="p1">[</bpt>garbage collection<ept id="p1">](garbagecollection/index.md)</ept> to provide automatic memory management for programs.</source>
          <target state="translated">.NET utilise le <bpt id="p1">[</bpt>garbage collection<ept id="p1">](garbagecollection/index.md)</ept> pour fournir une gestion automatique de la mémoire pour les programmes.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.</source>
          <target state="translated">Le récupérateur de mémoire opère avec une approche différée de la gestion de la mémoire, préférant le débit de l’application à la collecte immédiate de la mémoire.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To learn more about the .NET GC, check out <bpt id="p1">[</bpt>Fundamentals of garbage collection (GC)<ept id="p1">](garbagecollection/fundamentals.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le garbage collector .NET, consultez <bpt id="p1">[</bpt>Notions de base du garbage collection (GC)<ept id="p1">](garbagecollection/fundamentals.md)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following two lines both allocate memory:</source>
          <target state="translated">Les deux lignes suivantes allouent de la mémoire :</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>There is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</source>
          <target state="translated">Il n’existe aucun mot clé analogue pour libérer de la mémoire, car la libération de mémoire se produit automatiquement quand le récupérateur de mémoire réclame la mémoire dans son exécution planifiée.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Types within a given scope normally go out of scope once a method completes, at which point they can be collected.</source>
          <target state="translated">Les types dans une portée donnée sont normalement hors de portée à la fin d’une méthode, point auquel ils peuvent être récupérés.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the <ph id="ph1">`using`</ph> statement:</source>
          <target state="translated">Toutefois, vous pouvez indiquer au récupérateur de mémoire qu’un objet en particulier est hors de portée avant la fin de la méthode à l’aide de l’instruction <ph id="ph1">`using`</ph> :</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L6-L9)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L6-L9)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Once the <ph id="ph1">`using`</ph> block completes, the GC will know that the <ph id="ph2">`stream`</ph> object in the previous example is free to be collected and its memory reclaimed.</source>
          <target state="translated">Une fois que le bloc <ph id="ph1">`using`</ph> a terminé, le récupérateur de mémoire sait que l’objet <ph id="ph2">`stream`</ph> dans l’exemple précédent peut être collecté et sa mémoire récupérée.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Rules for this have slightly different semantics in F#.</source>
          <target state="translated">En F#, les règles concernant ce point ont une sémantique légèrement différente.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>To learn more about resource management in F#, check out <bpt id="p1">[</bpt>Resource Management: The <ph id="ph1">`use`</ph> Keyword<ept id="p1">](../fsharp/language-reference/resource-management-the-use-keyword.md)</ept></source>
          <target state="translated">Pour en savoir plus sur la gestion des ressources en F#, consultez <bpt id="p1">[</bpt>Resource Management: The <ph id="ph1">`use`</ph> Keyword<ept id="p1">](../fsharp/language-reference/resource-management-the-use-keyword.md)</ept> (Gestion des ressources : mot clé « use »).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>One of the less obvious but quite far-reaching features that a garbage collector enables is memory safety.</source>
          <target state="translated">Une des fonctionnalités les moins évidentes et pourtant assez importantes que le récupérateur de mémoire active est la sûreté de la mémoire.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).</source>
          <target state="translated">L’invariant de la sûreté de la mémoire est très simple : un programme a une mémoire sécurisée s’il accède uniquement à la mémoire qui a été allouée (et non libérée).</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Dangling pointers are always bugs, and tracking them down is often quite difficult.</source>
          <target state="translated">Les pointeurs non résolus sont toujours des bogues et leur suivi est souvent très difficile.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The .NET runtime provides additional services, to complete the promise of memory safety, not naturally offered by a GC.</source>
          <target state="translated">Le runtime .NET fournit des services supplémentaires pour assurer la sûreté de la mémoire, qui ne sont pas naturellement offerts par un récupérateur de mémoire.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>It ensures that programs do not index off the end of an array or accessing a phantom field off the end of an object.</source>
          <target state="translated">Il garantit que les programmes n’indexent pas à la fin d’un tableau ou accèdent à un champ fantôme à la fin d’un objet.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following example will throw an exception as a result of memory safety.</source>
          <target state="translated">L’exemple suivant lève une exception en raison de la sûreté de la mémoire.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L11-L12)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L11-L12)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Type safety</source>
          <target state="translated">Cohérence des types</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Objects are allocated in terms of types.</source>
          <target state="translated">Les objets sont alloués en termes de types.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The only operations allowed for a given object, and the memory it consumes, are those of its type.</source>
          <target state="translated">Les seules opérations autorisées pour un objet donné et la mémoire qu’il consomme sont celles de son type.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dog`</ph> type may have <ph id="ph2">`Jump`</ph> and <ph id="ph3">`WagTail`</ph> methods, but not likely a <ph id="ph4">`SumTotal`</ph> method.</source>
          <target state="translated">Un type <ph id="ph1">`Dog`</ph> peut avoir des méthodes <ph id="ph2">`Jump`</ph> et <ph id="ph3">`WagTail`</ph>, mais probablement pas une méthode <ph id="ph4">`SumTotal`</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A program can only call the declared methods of a given type.</source>
          <target state="translated">Un programme peut appeler uniquement les méthodes déclarées d’un type donné.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or <ph id="ph1">`object`</ph>).</source>
          <target state="translated">Tous les autres appels entraînent une erreur au moment de la compilation ou une exception au moment de l’exécution (en cas d’utilisation de fonctionnalités dynamiques ou du type <ph id="ph1">`object`</ph>).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>.NET languages are object-oriented, with hierarchies of base and derived classes.</source>
          <target state="translated">Les langages .NET sont orientés objet, avec des hiérarchies de classes de base et dérivées.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The .NET runtime will only allow object casts and calls that align with the object hierarchy.</source>
          <target state="translated">Le runtime .NET autorise uniquement les casts et les appels d’objet qui s’alignent sur la hiérarchie d’objets.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Remember that every type defined in any .NET language derives from the base <ph id="ph1">`object`</ph> type.</source>
          <target state="translated">N’oubliez pas que chaque type défini dans un langage .NET dérive du type <ph id="ph1">`object`</ph> de base.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</source>
          <target state="translated">La cohérence des types est également utilisée pour aider à appliquer l’encapsulation en garantissant la fidélité des mots clés d’accesseur.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Accessor keywords are artifacts which control access to members of a given type by other code.</source>
          <target state="translated">Les mots clés d’accesseur sont des artefacts qui contrôlent l’accès aux membres d’un type donné par un autre code.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>These are usually used for various kinds of data within a type that are used to manage its behavior.</source>
          <target state="translated">Ils servent généralement à différentes sortes de données dans un type utilisées pour gérer son comportement.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>C#, Visual Basic, and F# support local <bpt id="p1">**</bpt>type inference<ept id="p1">**</ept>.</source>
          <target state="translated">C#, Visual Basic et F# prennent en charge l’<bpt id="p1">**</bpt>inférence de type<ept id="p1">**</ept> locale.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side.</source>
          <target state="translated">L’inférence de type signifie que le compilateur déduit le type de l’expression à gauche à partir de l’expression à droite.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This doesn't mean that the type safety is broken or avoided.</source>
          <target state="translated">Cela ne signifie pas que la cohérence des types est interrompue ou évitée.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The resulting type <bpt id="p1">**</bpt>has<ept id="p1">**</ept> a strong type with everything that implies.</source>
          <target state="translated">Le type résultant <bpt id="p1">**</bpt>a<ept id="p1">**</ept> un type fort avec tout ce que cela implique.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Let's rewrite the first two lines of the previous example to introduce type inference.</source>
          <target state="translated">Réécrivons les deux premières lignes de l’exemple précédent pour introduire l’inférence de type.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Note that the rest of the example is completely the same.</source>
          <target state="translated">Notez que le reste de l’exemple est complètement identique.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>F# has even further type inference capabilities than method-local type inference found in C# and Visual Basic.</source>
          <target state="translated">F# offre des fonctionnalités d’inférence de type qui vont au-delà de l’inférence de type limitée aux méthodes disponible en C# et Visual Basic.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>To learn more, check out <bpt id="p1">[</bpt>Type Inference<ept id="p1">](../fsharp/language-reference/type-inference.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Type Inference<ept id="p1">](../fsharp/language-reference/type-inference.md)</ept> (Inférence de type).</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">Délégués et expressions lambda</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Delegates are like C++ function pointers, with a big difference that they are type safe.</source>
          <target state="translated">Les délégués sont comme des pointeurs de fonction C++, à la grande différence qu’ils sont de type sécurisé.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>They are a kind of disconnected method within the CLR type system.</source>
          <target state="translated">Ils représentent une sorte de méthode déconnectée au sein du système de type CLR.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Regular methods are attached to a class and only directly callable through static or instance calling conventions.</source>
          <target state="translated">Les méthodes régulières sont attachées à une classe et peuvent être appelées directement uniquement par des conventions d’appel statiques ou d’instance.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Delegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.</source>
          <target state="translated">Les délégués sont utilisés dans diverses API et emplacements de l’environnement .NET, en particulier dans les expressions lambda, qui sont la pierre angulaire de LINQ.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept> document.</source>
          <target state="translated">Pour en savoir plus sur ce sujet, lisez le document <bpt id="p1">[</bpt>Délégués et expressions lambda<ept id="p1">](delegates-lambdas.md)</ept>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Génériques</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Generics are a feature that was added in .NET Framework 2.0.</source>
          <target state="translated">Les génériques sont une fonctionnalité qui a été ajoutée dans .NET Framework 2.0.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In short, generics allow the programmer to introduce a "type parameter" when designing their classes, that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</source>
          <target state="translated">En bref, les génériques permettent au programmeur d’introduire un « paramètre de type » quand il désigne leurs classes qui permet au code client (les utilisateurs du type) de spécifier le type exact à utiliser à la place du paramètre de type.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Generics were added to help programmers implement generic data structures.</source>
          <target state="translated">Les génériques ont été ajoutés pour aider les programmeurs à implémenter des structures de données génériques.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Before their arrival, in order for a, say, <ph id="ph1">`List`</ph> type to be generic, it would have to work with elements that were of type <ph id="ph2">`object`</ph>.</source>
          <target state="translated">Avant leur arrivée, pour qu’un type <ph id="ph1">`List`</ph>, par exemple, soit générique, il fallait utiliser des éléments qui étaient de type <ph id="ph2">`object`</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This would have various performance as well as semantic problems, not to mention possible subtle runtime errors.</source>
          <target state="translated">Cela entraînait des variations de performances ainsi que des problèmes sémantiques, sans oublier les possibles erreurs d’exécution subtiles.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <ph id="ph1">`InvalidCastException`</ph> is thrown on working with the list's members.</source>
          <target state="translated">Les erreurs les plus connues dans cette dernière catégorie interviennent quand une structure de données contient, par exemple, des entiers et des chaînes et qu’une exception <ph id="ph1">`InvalidCastException`</ph> est levée pendant l’utilisation des membres de la liste.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following sample shows a basic program running using an instance of <ph id="ph1">@System.Collections.Generic.List%601</ph> types.</source>
          <target state="translated">L’exemple suivant montre une exécution de programme de base utilisant une instance des types <ph id="ph1">@System.Collections.Generic.List%601</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GenericsShort<ept id="p2">](../../samples/csharp/snippets/tour/GenericsShort.csx)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GenericsShort<ept id="p2">](../../samples/csharp/snippets/tour/GenericsShort.csx)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept> article.</source>
          <target state="translated">Pour plus d’informations, consultez l’article <bpt id="p1">[</bpt>Vue d’ensemble des types génériques (Génériques)<ept id="p1">](generics.md)</ept>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Async programming</source>
          <target state="translated">Programmation asynchrone</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Async programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs.</source>
          <target state="translated">La programmation asynchrone est un concept de première classe dans .NET, avec prise en charge asynchrone dans le runtime, les bibliothèques de framework et les constructions de langage .NET.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Internally, they are based off of objects (such as <ph id="ph1">`Task`</ph>) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</source>
          <target state="translated">En interne, ils sont basés sur des objets (comme <ph id="ph1">`Task`</ph>) qui tirent parti du système d’exploitation pour effectuer aussi efficacement que possible des tâches utilisant des E/S.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To learn more about async programming in .NET, start with the <bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept>.</source>
          <target state="translated">Pour en savoir plus sur la programmation asynchrone dans .NET, commencez par la <bpt id="p1">[</bpt>Vue d’ensemble d’Async<ept id="p1">](async.md)</ept>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ)</source>
          <target state="translated">LINQ (Language-Integrated Query)</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</source>
          <target state="translated">LINQ est un ensemble puissant de fonctionnalités pour C# et VB qui vous permettent d’écrire du code simple et déclaratif pour l’exploitation des données.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!</source>
          <target state="translated">Les données peuvent se présenter sous plusieurs formes (comme des objets en mémoire, dans une base de données SQL ou un document XML), mais le code LINQ que vous écrivez généralement n’est pas différent pour chaque source de données !</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>To learn more and see some samples, check out <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</source>
          <target state="translated">Pour en savoir plus et obtenir des exemples, consultez <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">Interopérabilité native</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Every operating system in current use provides a lot of platform support for various programming tasks.</source>
          <target state="translated">Chaque système d’exploitation en cours d’utilisation prend en charge un grand nombre de plateformes pour diverses tâches de programmation.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>.NET provides several ways to tap into those APIs.</source>
          <target state="translated">.NET offre plusieurs moyens de tirer parti de ces API.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Collectively, this support is called "native interoperability" and in this section we will take a look at how to access native APIs from managed, .NET code.</source>
          <target state="translated">Collectivement, cette prise en charge est appelée « interopérabilité native » et, dans cette section, nous allons voir comment accéder aux API natives à partir du code managé .NET.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The main way to do native interoperability is via "platform invoke" or P/Invoke for short.</source>
          <target state="translated">Le principal moyen d’effectuer une interopérabilité native est via l’« appel de code non managé » ou P/Invoke, en forme abrégée.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>This support in .NET Core is available across Linux and Windows platforms.</source>
          <target state="translated">Cette prise en charge dans .NET Core est disponible sur les plateformes Linux et Windows.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Another, Windows-only way of doing native interoperability is known as "COM interop" which is used to work with <bpt id="p1">[</bpt>COM components<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in managed code.</source>
          <target state="translated">Un autre moyen de faire une interopérabilité native sur Windows uniquement est connu sous le nom de « COM Interop », utilisé pour travailler avec des <bpt id="p1">[</bpt>composants COM<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> dans du code managé.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>It is built on top of P/Invoke infrastructure, but it works in subtly different ways.</source>
          <target state="translated">Il est basé sur l’infrastructure de P/Invoke, mais fonctionne légèrement différemment.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</source>
          <target state="translated">Une grande partie de la prise en charge d’interopérabilité dans Mono (et donc dans Xamarin) pour Java et Objective-C est générée de la même façon, autrement dit, ils utilisent les mêmes principes.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept> document.</source>
          <target state="translated">Pour en savoir plus, lisez le document <bpt id="p1">[</bpt>Interopérabilité native<ept id="p1">](native-interop.md)</ept>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Unsafe code</source>
          <target state="translated">Code unsafe</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The CLR enables the ability to access native memory and do pointer arithmetic via <ph id="ph1">`unsafe`</ph> code.</source>
          <target state="translated">Le CLR permet d’accéder à la mémoire native et d’effectuer une opération arithmétique de pointeur via du code <ph id="ph1">`unsafe`</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>These operations are needed for certain algorithms and system interoperability.</source>
          <target state="translated">Ces opérations sont nécessaires pour certains algorithmes et pour l’interopérabilité du système.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm.</source>
          <target state="translated">L’utilisation de code unsafe, bien que puissante, est déconseillée, sauf si elle est nécessaire pour assurer l’interopérabilité avec les API système ou implémenter l’algorithme le plus efficace.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety.</source>
          <target state="translated">Le code unsafe peut ne pas s’exécuter de la même façon dans différents environnements et perd les avantages d’un récupérateur de mémoire et de la cohérence des types.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.</source>
          <target state="translated">Il est recommandé de restreindre et centraliser le code unsafe autant que possible, et de tester ce code de manière approfondie.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The following example is a modified version of the <ph id="ph1">`ToString()`</ph> method from the <ph id="ph2">`StringBuilder`</ph> class.</source>
          <target state="translated">L’exemple suivant est une version modifiée de la méthode <ph id="ph1">`ToString()`</ph> à partir de la classe <ph id="ph2">`StringBuilder`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>It illustrates how using <ph id="ph1">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:</source>
          <target state="translated">Il illustre comment l’utilisation de code <ph id="ph1">`unsafe`</ph> peut implémenter efficacement un algorithme en déplaçant directement des segments de mémoire :</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Unsafe<ept id="p2">](../../samples/csharp/snippets/tour/Unsafe.csx)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Unsafe<ept id="p2">](../../samples/csharp/snippets/tour/Unsafe.csx)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">Étapes suivantes</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If you're interested in a tour of C# features, check out <bpt id="p1">[</bpt>Tour of C#<ept id="p1">](../csharp/tour-of-csharp/index.md)</ept>.</source>
          <target state="translated">Si vous êtes intéressé par une présentation des fonctionnalités de C#, consultez <bpt id="p1">[</bpt>Tour of C#<ept id="p1">](../csharp/tour-of-csharp/index.md)</ept> (Présentation de C#).</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If you're interested in a tour of F# features, check out <bpt id="p1">[</bpt>Tour of F#<ept id="p1">](../fsharp/tour.md)</ept>.</source>
          <target state="translated">Si vous êtes intéressé par une présentation des fonctionnalités de F#, consultez <bpt id="p1">[</bpt>Tour of F#<ept id="p1">](../fsharp/tour.md)</ept> (Présentation de F#).</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>If you want to get started with writing code of your own, check out <bpt id="p1">[</bpt>Getting Started<ept id="p1">](getting-started.md)</ept>.</source>
          <target state="translated">Si vous voulez vous familiariser avec l’écriture de votre propre code, consultez <bpt id="p1">[</bpt>Getting Started<ept id="p1">](getting-started.md)</ept> (Bien démarrer).</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>To learn about important components of .NET, check out <bpt id="p1">[</bpt>.NET Architectural Components<ept id="p1">](components.md)</ept>.</source>
          <target state="translated">Pour obtenir des informations sur les composants importants de .NET, consultez <bpt id="p1">[</bpt>Composants architecturaux de .NET<ept id="p1">](components.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>