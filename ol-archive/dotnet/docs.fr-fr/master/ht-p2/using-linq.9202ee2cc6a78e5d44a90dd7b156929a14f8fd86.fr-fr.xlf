<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0d941d7722353c68051bb761f4b05a6e304291ef</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\using-linq.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">37f7c80da13d49cc162ccaef9fa38e94e54530a1</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e96eb3810eb31f7770d3225aa9c81ae905d5cc01</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>LINQ (Language Integrated Query)</source>
          <target state="translated">LINQ (Language Integrated Query)</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>LINQ (Language Integrated Query)</source>
          <target state="translated">LINQ (Language Integrated Query)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>LINQ (Language Integrated Query)</source>
          <target state="translated">LINQ (Language Integrated Query)</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>What is it?</source>
          <target state="translated">Qu’est-ce que c’est ?</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>LINQ provides language-level querying capabilities and a <bpt id="p1">[</bpt>higher-order function<ept id="p1">](https://en.wikipedia.org/wiki/Higher-order_function)</ept> API to C# and VB as a way to write expressive, declarative code.</source>
          <target state="translated">LINQ fournit des fonctionnalités d’interrogation au niveau du langage et une API de <bpt id="p1">[</bpt>fonction d’ordre supérieur<ept id="p1">](https://en.wikipedia.org/wiki/Higher-order_function)</ept> pour C# et VB pour pouvoir écrire du code déclaratif, expressif.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Language-level query syntax:</source>
          <target state="translated">Syntaxe de requête au niveau du langage :</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Same example using the <ph id="ph1">`IEnumerable&lt;T&gt;`</ph> API:</source>
          <target state="translated">Même exemple en utilisant l’API <ph id="ph1">`IEnumerable&lt;T&gt;`</ph> :</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>LINQ is Expressive</source>
          <target state="translated">LINQ est expressif</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Imagine you have a list of pets, but want to convert it into a dictionary where you can access a pet directly by its <ph id="ph1">`RFID`</ph> value.</source>
          <target state="translated">Imaginez que vous avez une liste d’animaux domestiques, mais que vous voulez la convertir en dictionnaire dans lequel vous pouvez accéder à un animal directement par sa valeur <ph id="ph1">`RFID`</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Traditional imperative code:</source>
          <target state="translated">Code impératif traditionnel :</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The intention behind the code is not to create a new <ph id="ph1">`Dictionary&lt;int, Pet&gt;`</ph> and add to it via a loop, it is to convert an existing list into a dictionary!</source>
          <target state="translated">L’intention du code n’est pas de créer un <ph id="ph1">`Dictionary&lt;int, Pet&gt;`</ph> et d’y ajouter des éléments par une boucle, c’est de convertir une liste existante en dictionnaire !</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>LINQ preserves the intention whereas the imperative code does not.</source>
          <target state="translated">LINQ conserve l’intention contrairement au code impératif.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Equivalent LINQ expression:</source>
          <target state="translated">Expression LINQ équivalente :</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The code using LINQ is valuable because it evens the playing field between intent and code when reasoning as a programmer.</source>
          <target state="translated">Le code qui utilise LINQ est utile, car il égalise le terrain entre l’intention et le code dans un contexte de programmation.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Another bonus is code brevity.</source>
          <target state="translated">Un autre bonus est la concision du code.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Imagine reducing large portions of a codebase by 1/3 as done above.</source>
          <target state="translated">Imaginez que vous pouvez réduire d’un tiers les grandes parties d’un code Base comme illustré ci-dessus.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Pretty sweet deal, right?</source>
          <target state="translated">Intéressant, n’est-ce pas ?</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>LINQ Providers Simplify Data Access</source>
          <target state="translated">Les fournisseurs LINQ simplifient l’accès aux données</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For a significant chunk of software out in the wild, everything revolves around dealing with data from some source (Databases, JSON, XML, etc).</source>
          <target state="translated">Pour la plupart des logiciels en général, tout tourne autour du traitement de données à partir d’une source (bases de données, JSON, XML, etc.).</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Often this involves learning a new API for each data source, which can be annoying.</source>
          <target state="translated">Cela implique souvent d’apprendre une nouvelle API par source de données, ce qui peut s’avérer fastidieux.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>LINQ simplifies this by abstracting common elements of data access into a query syntax which looks the same no matter which data source you pick.</source>
          <target state="translated">LINQ simplifie le problème en faisant abstraction de l’accès aux éléments de donnée communs dans une syntaxe de requête qui semble la même, quelle que soit la source de données choisie.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consider the following: finding all XML elements with a specific attribute value.</source>
          <target state="translated">Imaginons que vous recherchez tous les éléments XML avec une valeur d’attribut spécifique.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Writing code to manually traverse the XML document to perform this task would be far more challenging.</source>
          <target state="translated">Écrire du code pour parcourir manuellement le document XML afin de rechercher ces éléments est une tâche très complexe.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Interacting with XML isn’t the only thing you can do with LINQ Providers.</source>
          <target state="translated">Les fournisseurs LINQ ne vous permettent pas seulement d’interagir avec le XML.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Linq to SQL<ept id="p1">](https://msdn.microsoft.com/library/bb386976.aspx)</ept> is a fairly bare-bones Object-Relational Mapper (ORM) for an MSSQL Server Database.</source>
          <target state="translated"><bpt id="p1">[</bpt>LINQ to SQL<ept id="p1">](https://msdn.microsoft.com/library/bb386976.aspx)</ept> est un mappeur ORM (Object-Relational Mapper) de base de données MSSQL relativement minimaliste.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>JSON.NET<ept id="p1">](http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm)</ept> library provides efficient JSON Document traversal via LINQ.</source>
          <target state="translated">La bibliothèque <bpt id="p1">[</bpt>JSON.NET<ept id="p1">](http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm)</ept> fournit un balayage efficace du document JSON via LINQ.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Furthermore, if there isn’t a library which does what you need, you can also <bpt id="p1">[</bpt>write your own LINQ Provider<ept id="p1">](https://msdn.microsoft.com/library/Bb546158.aspx)</ept>!</source>
          <target state="translated">Par ailleurs, si vous n’avez pas de bibliothèque pour faire ce dont vous avez besoin, vous pouvez également <bpt id="p1">[</bpt>écrire votre propre fournisseur LINQ<ept id="p1">](https://msdn.microsoft.com/library/Bb546158.aspx)</ept> !</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Why Use the Query Syntax?</source>
          <target state="translated">Pourquoi utiliser la syntaxe de requête ?</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This is a question which often comes up.</source>
          <target state="translated">C’est une question qui revient souvent.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>After all, this,</source>
          <target state="translated">Après tout,</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>is a lot more concise than this:</source>
          <target state="translated">est beaucoup plus concis que ce qui suit :</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Isn’t the API syntax just a more concise way to do the query syntax?</source>
          <target state="translated">La syntaxe d’API n’est-elle pas simplement un moyen plus concis d’effectuer la syntaxe de requête ?</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">Non.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The query syntax allows for the use the <bpt id="p1">**</bpt>let<ept id="p1">**</ept> clause, which allows you to introduce and bind a variable within the scope of the expression, using it in subsequent pieces of the expression.</source>
          <target state="translated">La syntaxe de requête permet d’utiliser la clause <bpt id="p1">**</bpt>let<ept id="p1">**</ept>, ce qui vous permet d’introduire et de lier une variable dans la portée de l’expression, en l’utilisant dans les parties suivantes de l’expression.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Reproducing the same code with only the API syntax can be done, but will most likely lead to code which is hard to read.</source>
          <target state="translated">Vous pouvez reproduire le même code avec la seule syntaxe d’API, mais vous obtiendrez très probablement du code difficile à lire.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>So this begs the question, <bpt id="p1">**</bpt>should you just use the query syntax?<ept id="p1">**</ept></source>
          <target state="translated">Ce qui nous amène à la question suivante : <bpt id="p1">**</bpt>devez-vous vous contenter d’utiliser la syntaxe de requête ?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The answer to this question is <bpt id="p1">**</bpt>yes<ept id="p1">**</ept> if...</source>
          <target state="translated">La réponse à cette question est <bpt id="p1">**</bpt>oui<ept id="p1">**</ept>, si...</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Your existing codebase already uses the query syntax</source>
          <target state="translated">Votre code Base utilise déjà la syntaxe de requête</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You need to scope variables within your queries due to complexity</source>
          <target state="translated">Vous devez définir l’étendue des variables dans vos requêtes en raison de la complexité</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>You prefer the query syntax and it won’t distract from your codebase</source>
          <target state="translated">Vous préférez la syntaxe de requête et elle ne vous détournera pas de votre code Base</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The answer to this question is <bpt id="p1">**</bpt>no<ept id="p1">**</ept> if...</source>
          <target state="translated">La réponse à cette question est <bpt id="p1">**</bpt>non<ept id="p1">**</ept>, si...</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Your existing codebase already uses the API syntax</source>
          <target state="translated">Votre code Base utilise déjà la syntaxe d’API</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You have no need to scope variables within your queries</source>
          <target state="translated">Vous n’avez pas besoin de définir l’étendue des variables dans vos requêtes</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You prefer the API syntax and it won’t distract from your codebase</source>
          <target state="translated">Vous préférez la syntaxe d’API et elle ne vous détournera pas de votre code Base</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Essential Samples</source>
          <target state="translated">Exemples essentiels</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For a truly comprehensive list of LINQ samples, visit <bpt id="p1">[</bpt>101 LINQ Samples<ept id="p1">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept>.</source>
          <target state="translated">Pour obtenir la liste complète des exemples LINQ, consultez <bpt id="p1">[</bpt>101 LINQ Samples<ept id="p1">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept> (101 exemples LINQ).</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The following is a quick demonstration of some of the essential pieces of LINQ.</source>
          <target state="translated">Voici une démonstration rapide de quelques-uns des éléments essentiels de LINQ.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This is in no way comprehensive, as LINQ provides significantly more functionality than what is showcased here.</source>
          <target state="translated">Ces exemples ne sont pas exhaustifs, car LINQ fournit beaucoup plus de fonctionnalités que ce qui est présenté ici.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The bread and butter - <ph id="ph1">`Where`</ph>, <ph id="ph2">`Select`</ph>, and <ph id="ph3">`Aggregate`</ph>:</source>
          <target state="translated">Les indispensables : <ph id="ph1">`Where`</ph>, <ph id="ph2">`Select`</ph> et <ph id="ph3">`Aggregate`</ph> :</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Flattening a list of lists:</source>
          <target state="translated">Aplanissement d’une liste de listes :</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Union between two sets (with custom comparator):</source>
          <target state="translated">Union entre deux ensembles (avec un comparateur personnalisé) :</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Intersection between two sets:</source>
          <target state="translated">Intersection entre deux ensembles :</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Ordering:</source>
          <target state="translated">Tri :</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Finally, a more advanced sample: determining if the values of the properties of two instances of the same type are equal (Borrowed and modified from <bpt id="p1">[</bpt>this StackOverflow post<ept id="p1">](http://stackoverflow.com/a/844855)</ept>):</source>
          <target state="translated">Enfin, un exemple plus avancé : déterminer si les valeurs des propriétés de deux instances du même type sont égales (emprunté à <bpt id="p1">[</bpt>ce billet StackOverflow<ept id="p1">](http://stackoverflow.com/a/844855)</ept> et modifié) :</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>PLINQ</source>
          <target state="translated">PLINQ</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>PLINQ, or Parallel LINQ, is a parallel execution engine for LINQ expressions.</source>
          <target state="translated">PLINQ, ou Parallel LINQ, est un moteur d’exécution parallèle pour les expressions LINQ.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In other words, a regular LINQ expressions can be trivially parallelized across any number of threads.</source>
          <target state="translated">En d’autres termes, des expressions régulières LINQ peuvent être parallélisées de manière simple sur n’importe quel nombre de threads.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This is accomplished via a call to <ph id="ph1">`AsParallel()`</ph> preceding the expression.</source>
          <target state="translated">Cela s’effectue par un appel à <ph id="ph1">`AsParallel()`</ph> avant l’expression.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">Considérez ce qui suit :</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This code will partition <ph id="ph1">`facebookUsers`</ph> across system threads as necessary, sum up the total likes on each thread in parallel, sum the results computed by each thread, and project that result into a nice string.</source>
          <target state="translated">Ce code partitionne <ph id="ph1">`facebookUsers`</ph> entre les threads système si nécessaire, additionne le nombre total de mentions J’aime sur chaque thread en parallèle, additionne les résultats calculés par chaque thread et projette ce résultat dans une chaîne très pratique.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In diagram form:</source>
          <target state="translated">Sous forme de diagramme :</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>PLINQ diagram</source>
          <target state="translated">Diagramme PLINQ</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Parallelizable CPU-bound jobs which can be easily expressed via LINQ (in other words, are pure functions and have no side effects) are a great candidate for PLINQ.</source>
          <target state="translated">Les tâches parallèles utilisant le processeur qui peuvent être facilement exprimées par LINQ (en d’autres termes, qui sont des fonctions pures et n’ont aucun effet secondaire) sont parfaites pour PLINQ.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For jobs which <bpt id="p1">_</bpt>do<ept id="p1">_</ept> have a side effect, consider using the <bpt id="p2">[</bpt>Task Parallel Library<ept id="p2">](https://msdn.microsoft.com/library/dd460717.aspx)</ept>.</source>
          <target state="translated">Pour les tâches qui <bpt id="p1">_</bpt>ont<ept id="p1">_</ept> un effet secondaire, utilisez la <bpt id="p2">[</bpt>bibliothèque parallèle de tâches<ept id="p2">](https://msdn.microsoft.com/library/dd460717.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Further Resources:</source>
          <target state="translated">Ressources supplémentaires :</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>101 LINQ Samples<ept id="p1">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>101 exemples LINQ<ept id="p1">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Linqpad<ept id="p1">](https://www.linqpad.net/)</ept>, a playground environment and Database querying engine for C#/F#/VB</source>
          <target state="translated"><bpt id="p1">[</bpt>Linqpad<ept id="p1">](https://www.linqpad.net/)</ept>, environnement de laboratoire et moteur d’interrogation de base de données pour C#/F#/VB</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>EduLinq<ept id="p1">](http://codeblog.jonskeet.uk/2011/02/23/reimplementing-linq-to-objects-part-45-conclusion-and-list-of-posts/)</ept>, an e-book for learning how LINQ-to-objects is implemented</source>
          <target state="translated"><bpt id="p1">[</bpt>EduLinq<ept id="p1">](http://codeblog.jonskeet.uk/2011/02/23/reimplementing-linq-to-objects-part-45-conclusion-and-list-of-posts/)</ept>, livre électronique pour apprendre comment LINQ-to-objects est implémenté</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>