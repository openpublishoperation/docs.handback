<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0734347048742657b8e33a1fffae15448ecad4f3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\garbagecollection\gc.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">28a616416d222585b1acea71f0a6d2ed046d62ee</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1337b68771f95336d70594d78f544bfa19cfa815</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Automatic memory management and garbage collection</source>
          <target state="translated">Gestione automatica della memoria e Garbage Collection</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Automatic memory management and garbage collection</source>
          <target state="translated">Gestione automatica della memoria e Garbage Collection</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Automatic memory management and garbage collection</source>
          <target state="translated">Gestione automatica della memoria e Garbage Collection</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Automatic memory management is one of the services that the Common Language Runtime provides during managed execution.</source>
          <target state="translated">Gestione automatica della memoria è uno dei servizi offerti da Common Language Runtime durante l'esecuzione gestita.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The Common Language Runtime's garbage collector manages the allocation and release of memory for an application.</source>
          <target state="translated">L'allocazione e il rilascio di memoria per un'applicazione vengono gestiti da Garbage Collector di Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For developers, this means that you do not have to write code to perform memory management tasks when you develop managed applications.</source>
          <target state="translated">Agli sviluppatori non viene quindi richiesta la scrittura di codice per eseguire attività di gestione della memoria quando si sviluppano applicazioni gestite.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak, or attempting to access memory for an object that has already been freed.</source>
          <target state="translated">La gestione automatica della memoria consente di evitare che si verifichino i problemi consueti legati alla gestione della memoria, quale la mancata liberazione di un oggetto e il conseguente spreco di memoria allocata ma non più referenziabile o il tentativo di accesso alla memoria per un oggetto già liberato.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This section describes how the garbage collector allocates and releases memory.</source>
          <target state="translated">In questa sezione viene descritta la modalità utilizzata dal Garbage Collector per l'allocazione e il rilascio di memoria.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Allocating Memory</source>
          <target state="translated">Allocazione di memoria</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</source>
          <target state="translated">Quando si inizializza un nuovo processo, per tale processo viene riservata una regione contigua di spazio degli indirizzi.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This reserved address space is called the managed heap.</source>
          <target state="translated">Lo spazio degli indirizzi riservato viene definito heap gestito.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</source>
          <target state="translated">Nell'heap gestito viene conservato un puntatore all'indirizzo in cui verrà allocato il successivo oggetto dell'heap.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Initially, this pointer is set to the managed heap's base address.</source>
          <target state="translated">Le impostazioni iniziali del puntatore corrispondono all'indirizzo di base dell'heap gestito.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>All reference types are allocated on the managed heap.</source>
          <target state="translated">Tutti i tipi di riferimento vengono allocati nell'heap gestito.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</source>
          <target state="translated">Quando il primo tipo di riferimento viene creato da un'applicazione, per tale tipo viene allocata memoria nell'indirizzo di base dell'heap gestito.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</source>
          <target state="translated">Quando l'oggetto successivo viene creato dall'applicazione, la memoria destinata a tale oggetto viene allocata dal Garbage Collector nello spazio degli indirizzi immediatamente successivo al primo oggetto.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</source>
          <target state="translated">Lo spazio per i nuovi oggetti verrà allocato in questo modo dal Garbage Collector fino all'esaurimento dello spazio degli indirizzi.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Allocating memory from the managed heap is faster than unmanaged memory allocation.</source>
          <target state="translated">L'allocazione della memoria dall'heap gestito risulta più veloce dell'allocazione di memoria non gestita.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Because the runtime allocates memory for an object by adding a value to a pointer, it is almost as fast as allocating memory from the stack.</source>
          <target state="translated">Poiché la memoria per un oggetto viene allocata da Common Language Runtime tramite un incremento di un valore a un puntatore, tale operazione risulta veloce almeno quanto l'allocazione di memoria dallo stack.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects very quickly.</source>
          <target state="translated">Poiché inoltre i nuovi oggetti allocati consecutivamente vengono archiviati in modo contiguo nell'heap gestito, l'accesso a tali oggetti da parte dell'applicazione risulta molto rapido.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Releasing Memory</source>
          <target state="translated">Rilascio di memoria</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</source>
          <target state="translated">Il modulo di ottimizzazione del Garbage Collector consente di determinare il momento migliore per l'esecuzione di una raccolta sulla base delle allocazioni in corso.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</source>
          <target state="translated">Durante l'esecuzione di una raccolta, la memoria per gli oggetti non più utilizzati dall'applicazione viene rilasciata dal Garbage Collector.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It determines which objects are no longer being used by examining the application's roots.</source>
          <target state="translated">L'individuazione degli oggetti non più in uso viene effettuata tramite l'esame delle radici dell'applicazione.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Every application has a set of roots.</source>
          <target state="translated">Ogni applicazione dispone di un insieme di radici.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Each root either refers to an object on the managed heap or is set to null.</source>
          <target state="translated">Ogni radice fa riferimento a un oggetto dell'heap gestito o è impostata su null.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</source>
          <target state="translated">Le radici di un'applicazione includono campi statici, variabili e parametri locali su uno stack di thread e registri della CPU.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The garbage collector has access to the list of active roots that the just-in-time (JIT) compiler and the runtime maintain.</source>
          <target state="translated">Garbage Collector ha accesso all'elenco delle radici attive mantenute dal compilatore JIT e dal runtime.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Using this list, it examines an application's roots, and in the process creates a graph that contains all the objects that are reachable from the roots.</source>
          <target state="translated">Usando questo elenco, il Garbage Collector esamina le radici dell'applicazione e crea, nel corso di tale esame, un grafico contenente tutti gli oggetti raggiungibili dalle directory radice.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Objects that are not in the graph are unreachable from the application's roots.</source>
          <target state="translated">Gli oggetti non inclusi nel grafo non sono raggiungibili dalle radici dell'applicazione.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The garbage collector considers unreachable objects garbage and will release the memory allocated for them.</source>
          <target state="translated">Gli oggetti non raggiungibili vengono considerati dal Garbage Collector come oggetti da eliminare e la memoria allocata per tali oggetti viene rilasciata.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</source>
          <target state="translated">Nel corso di una raccolta, l'heap gestito viene esaminato dal Garbage Collector, alla ricerca dei blocchi di spazi degli indirizzi occupati da oggetti non raggiungibili.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</source>
          <target state="translated">Quando un oggetto non raggiungibile viene rilevato, viene utilizzata una funzione di copia della memoria che consente di ricompattare lo spazio allocato per gli oggetti ancora raggiungibili nella memoria, liberando i blocchi di spazi degli indirizzi allocati per oggetti non raggiungibili.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</source>
          <target state="translated">Una volta compattata la memoria per gli oggetti non raggiungibili, il Garbage Collector aggiorna i puntatori agli oggetti ai rispettivi nuovi indirizzi, in modo che le radici dell'applicazione puntino agli oggetti nelle rispettive nuove posizioni.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>It also positions the managed heap's pointer after the last reachable object.</source>
          <target state="translated">Il puntatore relativo all'heap gestito viene inoltre posizionato dopo l'ultimo oggetto non raggiungibile.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Note that memory is compacted only if a collection discovers a significant number of unreachable objects.</source>
          <target state="translated">Si noti che la compressione della memoria viene effettuata solo se durante la raccolta viene rilevato un numero significativo di oggetti non raggiungibili.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</source>
          <target state="translated">Se tutti gli oggetti dell'heap gestito superano la raccolta, non è necessaria alcuna compressione della memoria.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>To improve performance, the runtime allocates memory for large objects in a separate heap.</source>
          <target state="translated">Per migliorare le prestazioni, la memoria per oggetti di grandi dimensioni viene allocata da Common Language Runtime in un heap separato.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The garbage collector automatically releases the memory for large objects.</source>
          <target state="translated">La memoria per oggetti di grandi dimensioni viene rilasciata automaticamente dal Garbage Collector.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>However, to avoid moving large objects in memory, this memory is not compacted.</source>
          <target state="translated">Per evitare lo spostamento di oggetti di grandi dimensioni nella memoria, non viene effettuata la compattazione della memoria.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Generations and Performance</source>
          <target state="translated">Generazioni e prestazioni</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>To optimize the performance of the garbage collector, the managed heap is divided into three generations: 0, 1, and 2.</source>
          <target state="translated">Per ottimizzare le prestazioni del Garbage Collector, l'heap gestito è diviso in tre generazioni: 0, 1 e 2.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The runtime's garbage collection algorithm is based on several generalizations that the computer software industry has discovered to be true by experimenting with garbage collection schemes.</source>
          <target state="translated">L'algoritmo del Garbage Collection del runtime si basa su svariate generalizzazioni la cui validità è stata verificata dai produttori di software per computer tramite sperimentazioni con gli schemi di Garbage Collection.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>First, it is faster to compact the memory for a portion of the managed heap than for the entire managed heap.</source>
          <target state="translated">Prima di tutto è stato rilevato che la compattazione per una parte dell'heap gestito risulta più rapida della compressione per l'intero heap gestito.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Secondly, newer objects will have shorter lifetimes and older objects will have longer lifetimes.</source>
          <target state="translated">In secondo luogo, la durata degli oggetti più recenti sarà inferiore alla durata degli oggetti meno recenti.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Lastly, newer objects tend to be related to each other and accessed by the application around the same time.</source>
          <target state="translated">Gli oggetti più recenti infine sono solitamente correlati e l'applicazione accede a tali oggetti quasi nello stesso momento.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The runtime's garbage collector stores new objects in generation 0.</source>
          <target state="translated">Il Garbage Collector del runtime archivia i nuovi oggetti nella generazione 0.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</source>
          <target state="translated">Gli oggetti creati nelle prime fasi della durata dell'applicazione che non vengono raccolti vengono promossi e archiviati nelle generazioni 1 e 2.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The process of object promotion is described later in this topic.</source>
          <target state="translated">Il processo di promozione dell'oggetto viene descritto più avanti in questo argomento.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Because it is faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</source>
          <target state="translated">Poiché la compressione di una porzione dell'heap gestito risulta più rapida della compressione dell'intero heap, questo schema consente al Garbage Collector di rilasciare la memoria in una specifica generazione, anziché rilasciare la memoria per l'intero heap gestito a ogni raccolta.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>In reality, the garbage collector performs a collection when generation 0 is full.</source>
          <target state="translated">La raccolta viene in realtà effettuata dal Garbage Collector quando la generazione 0 è piena.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>If an application attempts to create a new object when generation 0 is full, the garbage collector discovers that there is no address space remaining in generation 0 to allocate for the object.</source>
          <target state="translated">Se un'applicazione tenta di creare un nuovo oggetto quando la generazione 0 è piena, il Garbage Collector rileva che nella generazione 0 non è più disponibile spazio degli indirizzi da allocare per l'oggetto.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The garbage collector performs a collection in an attempt to free address space in generation 0 for the object.</source>
          <target state="translated">Per tentare di liberare spazio degli indirizzi per l'oggetto nella generazione 0, viene effettuata una raccolta.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</source>
          <target state="translated">Il Garbage Collector esamina prima di tutto gli oggetti presenti nella generazione 0, anziché tutti gli oggetti presenti nell'heap gestito.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This is the most efficient approach, because new objects tend to have short lifetimes, and it is expected that many of the objects in generation 0 will no longer be in use by the application when a collection is performed.</source>
          <target state="translated">Questo è infatti l'approccio più efficiente, poiché la durata degli oggetti recenti è solitamente ridotta e si presume che molti degli oggetti presenti nella generazione 0 non siano più utilizzati dall'applicazione quando si effettua una raccolta.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In addition, a collection of generation 0 alone often reclaims enough memory to allow the application to continue creating new objects.</source>
          <target state="translated">L'effettuazione della raccolta sulla sola generazione 0 consente inoltre di recuperare spesso memoria sufficiente per consentire all'applicazione di continuare a creare nuovi oggetti.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects as explained in <bpt id="p1">[</bpt>Releasing Memory<ept id="p1">](#releasing-memory)</ept> earlier in this topic.</source>
          <target state="translated">Al termine della raccolta nella generazione 0 effettuata da Garbage Collector, la memoria per gli oggetti raggiungibili viene compressa come illustrato precedentemente in <bpt id="p1">[</bpt>Rilascio di memoria<ept id="p1">](#releasing-memory)</ept> in questo argomento.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The garbage collector then promotes these objects and considers this portion of the managed heap generation 1.</source>
          <target state="translated">Il Garbage Collector promuove quindi questi oggetti e questa parte dell'heap gestito viene considerata come generazione 1.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</source>
          <target state="translated">Poiché la durata degli oggetti non raccolti è solitamente più lunga, la promozione a una generazione superiore risulta opportuna.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>As a result, the garbage collector does not have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</source>
          <target state="translated">Il riesame degli oggetti nelle generazioni 1 e 2 da parte del Garbage Collector non sarà quindi necessario a ogni raccolta della generazione 0.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>After the garbage collector performs its first collection of generation 0 and promotes the reachable objects to generation 1, it considers the remainder of the managed heap generation 0.</source>
          <target state="translated">Una volta completata la prima raccolta della generazione 0 e una volta promossi gli oggetti raggiungibili alla generazione 1, la parte restante dell'heap gestito verrà considerata dal Garbage Collector come generazione 0.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>It continues to allocate memory for new objects in generation 0 until generation 0 is full and it is necessary to perform another collection.</source>
          <target state="translated">Il Garbage Collector continuerà quindi ad allocare memoria per i nuovi oggetti nella generazione 0 fino a quando la generazione 0 non risulterà piena e non sarà necessario eseguire un'altra raccolta.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>At this point, the garbage collector's optimizing engine determines whether it is necessary to examine the objects in older generations.</source>
          <target state="translated">A questo punto il modulo di ottimizzazione del Garbage Collector consentirà di determinare se sia necessario esaminare gli oggetti delle generazioni meno recenti.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For example, if a collection of generation 0 does not reclaim enough memory for the application to successfully complete its attempt to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</source>
          <target state="translated">Se ad esempio una raccolta effettuata nella generazione 0 non consente di recuperare memoria sufficiente per il corretto completamento del tentativo di creazione di un nuovo oggetto da parte dell'applicazione, il Garbage Collector potrà eseguire una raccolta della generazione 1, quindi della generazione 2.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If this does not reclaim enough memory, the garbage collector can perform a collection of generations 2, 1, and 0.</source>
          <target state="translated">Se la memoria recuperata non risulta sufficiente, il Garbage Collector potrà eseguire una raccolta nelle generazioni 2, 1 e 0.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>After each collection, the garbage collector compacts the reachable objects in generation 0 and promotes them to generation 1.</source>
          <target state="translated">Al termine di ogni raccolta, gli oggetti raggiungibili nella generazione 0 vengono compressi dal Garbage Collector e promossi alla generazione 1.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Objects in generation 1 that survive collections are promoted to generation 2.</source>
          <target state="translated">Gli oggetti presenti nella generazione 1 non raccolti vengono promossi alla generazione 2.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Because the garbage collector supports only three generations, objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</source>
          <target state="translated">Poiché il Garbage Collector supporta solo tre generazioni, gli oggetti presenti nella generazione 2 non raccolti rimangono nella generazione 2 fino a quando non vengono considerati non raggiungibili da raccolte successive.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Releasing Memory for Unmanaged Resources</source>
          <target state="translated">Rilascio di memoria per le risorse non gestite</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For the majority of the objects that your application creates, you can rely on the garbage collector to automatically perform the necessary memory management tasks.</source>
          <target state="translated">Le attività di gestione della memoria necessarie vengono effettuate dal Garbage Collector per la maggior parte degli oggetti creati dall'applicazione.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>However, unmanaged resources require explicit cleanup.</source>
          <target state="translated">Per le risorse non gestite è tuttavia necessario il rilascio esplicito.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</source>
          <target state="translated">Il tipo più comune di risorsa non gestita è rappresentato da un oggetto che esegue il wrapping di una risorsa del sistema operativo, quale un handle di file, un handle di finestra o una connessione di rete.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it does not have specific knowledge about how to clean up the resource.</source>
          <target state="translated">Benché il Garbage Collector sia in grado di tenere traccia della durata di un oggetto gestito in cui è incapsulata una risorsa non gestita, non dispone di dati sufficienti per effettuare il rilascio della risorsa.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>When you create an object that encapsulates an unmanaged resource, it is recommended that you provide the necessary code to clean up the unmanaged resource in a public <ph id="ph1">`Dispose`</ph> method.</source>
          <target state="translated">Quando si crea un oggetto che incapsula una risorsa non gestita, è consigliabile specificare il codice necessario per pulire la risorsa non gestita in un metodo <ph id="ph1">`Dispose`</ph> pubblico.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>By providing a <ph id="ph1">`Dispose`</ph> method, you enable users of your object to explicitly free its memory when they are finished with the object.</source>
          <target state="translated">Specificando un metodo <ph id="ph1">`Dispose`</ph> si consente agli utenti dell'oggetto di liberarne esplicitamente la memoria dopo l'uso dell'oggetto.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>When you use an object that encapsulates an unmanaged resource, you should be aware of <ph id="ph1">`Dispose`</ph> and call it as necessary.</source>
          <target state="translated">Quando si usa un oggetto che incapsula una risorsa non gestita, è consigliabile tenere in considerazione il metodo <ph id="ph1">`Dispose`</ph> e di chiamarlo se necessario.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For more information about cleaning up unmanaged resources and an example of a design pattern for implementing <ph id="ph1">`Dispose`</ph>, see <bpt id="p1">[</bpt>Garbage Collection in .NET<ept id="p1">](index.md)</ept>.</source>
          <target state="translated">Per altre informazioni su come pulire una risorsa non gestita e per un esempio di modello di progettazione per l'implementazione di <ph id="ph1">`Dispose`</ph>, vedere <bpt id="p1">[</bpt>Garbage Collection in .NET<ept id="p1">](index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vedere anche</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.GC<ept id="p1">](xref:System.GC)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.GC<ept id="p1">](xref:System.GC)</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Garbage collection in .NET<ept id="p1">](index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Garbage Collection in .NET<ept id="p1">](index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>