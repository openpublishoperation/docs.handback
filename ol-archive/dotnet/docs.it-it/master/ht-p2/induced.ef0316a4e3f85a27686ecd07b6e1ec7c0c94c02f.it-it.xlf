<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a10822518f0687dc7bbb06dd0fb77f6d9a3196fb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\garbagecollection\induced.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a9baaf4b5ef4785d3ed2207e62d076e46e936925</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e9e40cc681a3ec063165539d4708e61996c678e4</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Induced collections</source>
          <target state="translated">Raccolte indotte</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Induced collections</source>
          <target state="translated">Raccolte indotte</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Induced collections</source>
          <target state="translated">Raccolte indotte</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In most cases, the garbage collector can determine the best time to perform a collection, and you should let it run independently.</source>
          <target state="translated">Nella maggior parte dei casi, tramite il Garbage Collector è possibile determinare il momento migliore per eseguire una raccolta ed è consigliabile consentire l'esecuzione in modo indipendente.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>There are rare situations when a forced collection might improve your application's performance.</source>
          <target state="translated">In rari casi una raccolta forzata può migliorare le prestazioni dell'applicazione.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>In these cases, you can induce garbage collection by using the <bpt id="p1">[</bpt>GC.Collect<ept id="p1">](xref:System.GC.Collect)</ept> method to force a garbage collection.</source>
          <target state="translated">In questi casi, si può indurre un'operazione di Garbage Collection usando il metodo <bpt id="p1">[</bpt>GC.Collect<ept id="p1">](xref:System.GC.Collect)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>Collect<ept id="p1">](xref:System.GC.Collect)</ept> method when there is a significant reduction in the amount of memory being used at a specific point in your application's code.</source>
          <target state="translated">Usare il metodo <bpt id="p1">[</bpt>Collect<ept id="p1">](xref:System.GC.Collect)</ept> quando si verifica una riduzione significativa della quantità di memoria usata in un momento specifico nel codice dell'applicazione.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For example, if your application uses a complex dialog box that has several controls, calling <bpt id="p1">[</bpt>Collect<ept id="p1">](xref:System.GC.Collect)</ept> when the dialog box is closed could improve performance by immediately reclaiming the memory used by the dialog box.</source>
          <target state="translated">Se ad esempio l'applicazione usa una finestra di dialogo complessa con numerosi comandi, la chiamata del metodo <bpt id="p1">[</bpt>Collect<ept id="p1">](xref:System.GC.Collect)</ept> quando la finestra di dialogo è chiusa può migliorare le prestazioni mediante l'immediato recupero della memoria usata dalla finestra di dialogo.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Be sure that your application is not inducing garbage collection too frequently, because that can decrease performance if the garbage collector is trying to reclaim objects at non-optimal times.</source>
          <target state="translated">Assicurarsi che l'applicazione non induca troppo spesso l'operazione di Garbage Collection, in quanto può causare una riduzione delle prestazioni se il Garbage Collector tenta di recuperare oggetti in momenti non ottimali.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can supply a <bpt id="p1">[</bpt>GCCollectionMode.Optimized<ept id="p1">](xref:System.GCCollectionMode.Optimized)</ept> enumeration value to the <bpt id="p2">[</bpt>Collect<ept id="p2">](xref:System.GC.Collect)</ept> method to collect only when collection would be productive, as discussed in the next section.</source>
          <target state="translated">È possibile specificare un valore di enumerazione <bpt id="p1">[</bpt>GCCollectionMode.Optimized<ept id="p1">](xref:System.GCCollectionMode.Optimized)</ept> nel metodo <bpt id="p2">[</bpt>Collect<ept id="p2">](xref:System.GC.Collect)</ept> in modo che la raccolta venga eseguita solo quando è produttivo, come descritto nella sezione successiva.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>GC collection mode</source>
          <target state="translated">Modalità di raccolta Garbage Collection</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You can use one of the <bpt id="p1">[</bpt>GC.Collect<ept id="p1">](xref:System.GC.Collect)</ept> method overloads that includes a <bpt id="p2">[</bpt>GCCollectionMode<ept id="p2">](xref:System.GCCollectionMode)</ept> value to specify the behavior for a forced collection as follows.</source>
          <target state="translated">È possibile usare uno degli overload del metodo <bpt id="p1">[</bpt>GC.Collect<ept id="p1">](xref:System.GC.Collect)</ept> che include un valore <bpt id="p2">[</bpt>GCCollectionMode<ept id="p2">](xref:System.GCCollectionMode)</ept> per specificare il comportamento di una raccolta forzata, come indicato di seguito.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>GCCollectionMode value</source>
          <target state="translated">Valore GCCollectionMode</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Default<ept id="p1">](xref:System.GCCollectionMode.Default)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Default<ept id="p1">](xref:System.GCCollectionMode.Default)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Uses the default garbage collection setting for the running version of the .NET Framework.</source>
          <target state="translated">Usa l'impostazione di Garbage Collection predefinita per la versione di .NET Framework in esecuzione.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Forced<ept id="p1">](xref:System.GCCollectionMode.Forced)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Forced<ept id="p1">](xref:System.GCCollectionMode.Forced)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Forces garbage collection to occur immediately.</source>
          <target state="translated">Forza l'esecuzione immediata dell'operazione di Garbage Collection.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling the <bpt id="p1">[</bpt>GC.Collect()<ept id="p1">](xref:System.GC.Collect)</ept> overload.</source>
          <target state="translated">Equivale alla chiamata dell'overload di <bpt id="p1">[</bpt>GC.Collect()<ept id="p1">](xref:System.GC.Collect)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>It results in a full blocking collection of all generations.</source>
          <target state="translated">Restituisce una raccolta di blocco completa di tutte le generazioni.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You can also compact the large object heap by setting the <bpt id="p1">[</bpt>GCSettings.LargeObjectHeapCompactionMode<ept id="p1">](xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode)</ept> property to <bpt id="p2">[</bpt>GCLargeObjectHeapCompactionMode.CompactOnce<ept id="p2">](xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce)</ept> before forcing an immediate full blocking garbage collection.</source>
          <target state="translated">Prima di forzare l'esecuzione immediata di un'operazione completa di Garbage Collection di blocco, è anche possibile comprimere gli heap di oggetti di grandi dimensioni impostando la proprietà <bpt id="p1">[</bpt>GCSettings.LargeObjectHeapCompactionMode<ept id="p1">](xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode)</ept> su <bpt id="p2">[</bpt>GCLargeObjectHeapCompactionMode.CompactOnce<ept id="p2">](xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Optimized<ept id="p1">](xref:System.GCCollectionMode.Optimized)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Optimized<ept id="p1">](xref:System.GCCollectionMode.Optimized)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Enables the garbage collector to determine whether the current time is optimal to reclaim objects.</source>
          <target state="translated">Consente al Garbage Collector di determinare se il momento corrente è ottimale per recuperare oggetti.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The garbage collector could determine that a collection would not be productive enough to be justified, in which case it will return without reclaiming objects.</source>
          <target state="translated">Il Garbage Collector può determinare che una raccolta non è sufficientemente produttiva per giustificarne l'esecuzione, nel qual caso esce dalla funzione senza recuperare oggetti.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Background or blocking collections</source>
          <target state="translated">Raccolte in background o di blocco</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can call the <bpt id="p1">[</bpt>GC.Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> method overload to specify whether an induced collection is blocking or not.</source>
          <target state="translated">È possibile chiamare l'overload del metodo <bpt id="p1">[</bpt>GC.Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> per specificare se una raccolta indotta è di blocco o meno.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The type of collection performed depends on a combination of the method's <bpt id="p1">*</bpt>mode<ept id="p1">*</ept> and <bpt id="p2">*</bpt>blocking<ept id="p2">*</ept> parameters.</source>
          <target state="translated">Il tipo della raccolta eseguita dipende da una combinazione dei parametri <bpt id="p1">*</bpt>mode<ept id="p1">*</ept> e <bpt id="p2">*</bpt>blocking<ept id="p2">*</ept> del metodo.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>mode<ept id="p1">*</ept> is a member of the <bpt id="p2">[</bpt>GCCollectionMode<ept id="p2">](xref:System.GCCollectionMode)</ept> enumeration, and <bpt id="p3">*</bpt>blocking<ept id="p3">*</ept> is a <bpt id="p4">[</bpt>Boolean<ept id="p4">](xref:System.Boolean)</ept> value.</source>
          <target state="translated">Il parametro <bpt id="p1">*</bpt>mode<ept id="p1">*</ept> è parte dell'enumerazione <bpt id="p2">[</bpt>GCCollectionMode<ept id="p2">](xref:System.GCCollectionMode)</ept> e <bpt id="p3">*</bpt>blocking<ept id="p3">*</ept> è un valore <bpt id="p4">[</bpt>booleano<ept id="p4">](xref:System.Boolean)</ept>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following table summarizes the interaction of the mode and blocking arguments.</source>
          <target state="translated">La tabella seguente riepiloga l'interazione degli argomenti Mode e Blocking.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>mode<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>mode<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>blocking<ept id="p1">*</ept> = true</source>
          <target state="translated"><bpt id="p1">*</bpt>blocking<ept id="p1">*</ept> = true</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>blocking<ept id="p1">*</ept> = false</source>
          <target state="translated"><bpt id="p1">*</bpt>blocking<ept id="p1">*</ept> = false</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Forced<ept id="p1">](xref:System.GCCollectionMode.Forced)</ept> or <bpt id="p2">[</bpt>Default<ept id="p2">](xref:System.GCCollectionMode.Default)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Forzata<ept id="p1">](xref:System.GCCollectionMode.Forced)</ept> o <bpt id="p2">[</bpt>Predefinita<ept id="p2">](xref:System.GCCollectionMode.Default)</ept></target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>A blocking collection is performed as soon as possible.</source>
          <target state="translated">Viene eseguita una raccolta di blocco il prima possibile.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>If a background collection is in progress and generation is 0 or 1, the <bpt id="p1">[</bpt>Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> method immediately triggers a blocking collection and returns when the collection is finished.</source>
          <target state="translated">Se è in corso una raccolta in background e la generazione è 0 o 1, il metodo <bpt id="p1">[</bpt>Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> attiva immediatamente una raccolta di blocco e viene restituito quando la raccolta viene completata.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If a background collection is in progress and the generation parameter is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</source>
          <target state="translated">Se è in corso una raccolta in background e il parametro della generazione è 2, il metodo attende fino a quando la raccolta in background non viene completata, attiva una raccolta di blocco di generazione 2 e viene restituito.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A collection is performed as soon as possible.</source>
          <target state="translated">Viene eseguita una raccolta il prima possibile.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated">Il metodo <bpt id="p1">[</bpt>Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> richiede una raccolta in background, ma non è garantita. A seconda del caso, può essere ancora eseguita una raccolta di blocco.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">Se è già in corso una raccolta in background, il metodo viene restituito immediatamente.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Optimized<ept id="p1">](xref:System.GCCollectionMode.Optimized)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Optimized<ept id="p1">](xref:System.GCCollectionMode.Optimized)</ept></target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>A blocking collection may be performed, depending on the state of the garbage collector and the generation parameter.</source>
          <target state="translated">È possibile eseguire una raccolta di blocco, a seconda dello stato del Garbage Collector e del parametro di generazione.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">Il Garbage Collector tenta di garantire prestazioni ottimali.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>A collection may be performed, depending on the state of the garbage collector.</source>
          <target state="translated">È possibile eseguire una raccolta, a seconda dello stato del Garbage Collector.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated">Il metodo <bpt id="p1">[</bpt>Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> richiede una raccolta in background, ma non è garantita. A seconda del caso, può essere ancora eseguita una raccolta di blocco.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">Il Garbage Collector tenta di garantire prestazioni ottimali.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">Se è già in corso una raccolta in background, il metodo viene restituito immediatamente.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vedere anche</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Latency modes<ept id="p1">](latency.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Modalità di latenza<ept id="p1">](latency.md)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Garbage collection in .NET<ept id="p1">](index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Garbage Collection in .NET<ept id="p1">](index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>