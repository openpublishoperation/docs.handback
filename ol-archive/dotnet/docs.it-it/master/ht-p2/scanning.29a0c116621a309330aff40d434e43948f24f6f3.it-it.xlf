<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8951e4ca82c0148bae7e8279681920ffabb523be</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\scanning.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b31360b3634fb8e5fd90463083a8be59c07be365</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d053878964559a80554a78cf7c481c56411c33b9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Regular expression example: scanning for HREFs</source>
          <target state="translated">Esempio di espressione regolare: ricerca di HREF</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Regular expression example scanning for HREFs</source>
          <target state="translated">Esempio di espressione regolare: ricerca di HREF</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Regular expression example: scanning for HREFs</source>
          <target state="translated">Esempio di espressione regolare: ricerca di HREF</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The following example searches an input string and displays all the href="…" values and their locations in the string.</source>
          <target state="translated">Nell'esempio riportato di seguito viene cercata una stringa di input e vengono visualizzati tutti i valori href="…" e le relative posizioni nella stringa.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The Regex Object</source>
          <target state="translated">L'oggetto Regex</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`DumpHRefs`</ph> method can be called multiple times from user code, it uses the <ph id="ph2">`static`</ph> <bpt id="p1">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method.</source>
          <target state="translated">Poiché il metodo <ph id="ph1">`DumpHRefs`</ph> può essere chiamato più volte dal codice utente, viene usato il metodo <ph id="ph2">`static`</ph> <bpt id="p1">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This enables the regular expression engine to cache the regular expression and avoids the overhead of instantiating a new <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object each time the method is called.</source>
          <target state="translated">In questo modo il motore delle espressioni regolari memorizza nella cache l'espressione regolare ed evita il sovraccarico di un'istanza di un nuovo oggetto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> ogni volta che viene chiamato il metodo.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> object is then used to iterate through all matches in the string.</source>
          <target state="translated">Viene quindi usato un oggetto <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> per eseguire un'iterazione in tutte le corrispondenze nella stringa.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following example then illustrates a call to the <ph id="ph1">`DumpHRefs`</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrata una chiamata al metodo <ph id="ph1">`DumpHRefs`</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`href\s*=\s*(?:["']&amp;#40;?&lt;1&gt;[^"']*)["']|(?&lt;1&gt;\S+))`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Il criterio di ricerca di espressioni regolari <ph id="ph1">`href\s*=\s*(?:["']&amp;#40;?&lt;1&gt;[^"']*)["']|(?&lt;1&gt;\S+))`</ph> è interpretato nel modo illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Match the literal string "href".</source>
          <target state="translated">Corrisponde alla stringa letterale "href".</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The match is case-insensitive.</source>
          <target state="translated">La corrispondenza non fa distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">Trovare la corrispondenza di zero o più spazi vuoti.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>`Match the equals sign.</source>
          <target state="translated">Corrisponde al segno di uguale.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">Trovare la corrispondenza di zero o più spazi vuoti.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Match one of the following without assigning the result to a captured group: A quotation mark or apostrophe, followed by zero or more occurrences of any character other than a quotation mark or apostrophe, followed by a quotation mark or apostrophe.</source>
          <target state="translated">Corrisponde a uno dei seguenti elementi senza assegnazione del risultato a un gruppo acquisito: Una virgoletta o un apostrofo, seguito da zero o più occorrenze di qualsiasi carattere diverso dai primi, seguito da una virgoletta o un apostrofo.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The group named <ph id="ph1">`1`</ph> is included in this pattern.</source>
          <target state="translated">Il gruppo denominato <ph id="ph1">`1`</ph> è incluso in questo modello.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>-or- One or more non-white-space characters.</source>
          <target state="translated">-or- Uno o più caratteri diversi dallo spazio vuoto.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The group named <ph id="ph1">`1`</ph> is included in this pattern.</source>
          <target state="translated">Il gruppo denominato <ph id="ph1">`1`</ph> è incluso in questo modello.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Assign zero or more occurrences of any character other than a quotation mark or apostrophe to the capturing group named <ph id="ph1">`1`</ph>.</source>
          <target state="translated">Assegnare zero o più occorrenze di qualsiasi carattere diverso da una virgoletta o un apostrofo al gruppo di acquisizione denominato <ph id="ph1">`1`</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Assign one or more non-white-space characters to the capturing group named <ph id="ph1">`1`</ph>.</source>
          <target state="translated">Assegnare uno o più caratteri diversi da spazi vuoti al gruppo di acquisizione denominato <ph id="ph1">`1`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Match Result Class</source>
          <target state="translated">Classe di risultati di corrispondenza</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The results of a search are stored in the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> class, which provides access to all the substrings extracted by the search.</source>
          <target state="translated">I risultati della ricerca vengono archiviati nella classe <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept>, che offre l'accesso a tutte le sottostringhe estratte dalla ricerca.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>It also remembers the string being searched and the regular expression being used, so it can call the <bpt id="p1">[</bpt>Match.NextMatch<ept id="p1">](xref:System.Text.RegularExpressions.Match.NextMatch)</ept> method to perform another search starting where the last one ended.</source>
          <target state="translated">Tale classe memorizza anche la stringa cercata e l'espressione regolare usata, pertanto è possibile chiamare il metodo <bpt id="p1">[</bpt>Match.NextMatch<ept id="p1">](xref:System.Text.RegularExpressions.Match.NextMatch)</ept> per eseguire un'altra ricerca a partire dal punto in cui è terminata quella più recente.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Explicitly Named Captures</source>
          <target state="translated">Acquisizioni denominate in modo esplicito</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In traditional regular expressions, capturing parentheses are automatically numbered sequentially.</source>
          <target state="translated">Nelle espressioni regolari tradizionali, le parentesi di cattura vengono automaticamente numerate in sequenza.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This leads to two problems.</source>
          <target state="translated">Ciò comporta due problemi.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>First, if a regular expression is modified by inserting or removing a set of parentheses, all code that refers to the numbered captures must be rewritten to reflect the new numbering.</source>
          <target state="translated">In primo luogo, se un'espressione regolare viene modificata dall'inserimento o rimozione di un set di parentesi, tutto il codice che fa riferimento alle catture numerate deve essere riscritto per riflettere la nuova numerazione.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Second, because different sets of parentheses often are used to provide two alternative expressions for an acceptable match, it might be difficult to determine which of the two expressions actually returned a result.</source>
          <target state="translated">In secondo luogo, poiché diversi set di parentesi spesso vengono usati per specificare due espressioni alternative per una corrispondenza accettabile, potrebbe essere difficile determinare quale delle due espressioni ha effettivamente restituito un risultato.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>To address these problems, the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class supports the syntax <ph id="ph1">`(?&lt;name&gt;…)`</ph> for capturing a match into a specified slot (the slot can be named using a string or an integer; integers can be recalled more quickly).</source>
          <target state="translated">Per risolvere questi problemi, la classe <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> supporta la sintassi <ph id="ph1">`(?&lt;name&gt;…)`</ph> per l'acquisizione di una corrispondenza in uno slot specificato (che è possibile denominare tramite una stringa o un numero intero, che può essere chiamato più rapidamente).</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Thus, alternative matches for the same string all can be directed to the same place.</source>
          <target state="translated">Le corrispondenze alternative per la stessa stringa possono perciò essere tutte indirizzate verso la stessa posizione.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In case of a conflict, the last match dropped into a slot is the successful match.</source>
          <target state="translated">In caso di conflitto, l'ultima corrispondenza rilasciata in uno slot è quella corretta.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>(However, a complete list of multiple matches for a single slot is available.</source>
          <target state="translated">(È tuttavia disponibile un elenco completo di più corrispondenze per un unico slot.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>Group.Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collection for details.)</source>
          <target state="translated">Per informazioni dettagliate, vedere la raccolta <bpt id="p1">[</bpt>Group.Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept>.)</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vedere anche</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET regular expressions<ept id="p1">](regular-expressions.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Espressioni regolari .NET<ept id="p1">](regular-expressions.md)</ept></target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression examples<ept id="p1">](regex-examples.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Esempi di espressioni regolari<ept id="p1">](regex-examples.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>