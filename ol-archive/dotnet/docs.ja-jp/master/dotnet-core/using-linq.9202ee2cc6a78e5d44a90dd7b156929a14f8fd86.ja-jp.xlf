<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6d9c163255939c3732177ecccb373479ab610447</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\using-linq.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ce9cd076984fe2a5cd9a34ec6bb0a96a7476bc46</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e96eb3810eb31f7770d3225aa9c81ae905d5cc01</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>LINQ (Language Integrated Query)</source>
          <target state="translated">LINQ (統合言語クエリ)</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>LINQ (Language Integrated Query)</source>
          <target state="translated">LINQ (統合言語クエリ)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>LINQ (Language Integrated Query)</source>
          <target state="translated">LINQ (統合言語クエリ)</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>What is it?</source>
          <target state="translated">LINQ とは</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>LINQ provides language-level querying capabilities and a <bpt id="p1">[</bpt>higher-order function<ept id="p1">](https://en.wikipedia.org/wiki/Higher-order_function)</ept> API to C# and VB as a way to write expressive, declarative code.</source>
          <target state="translated">LINQ では、言語レベルのクエリ機能と、表現力豊かな宣言コードを記述する方法として C# および VB に<bpt id="p1">[</bpt>高階関数<ept id="p1">](https://en.wikipedia.org/wiki/Higher-order_function)</ept> API が提供されます。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Language-level query syntax:</source>
          <target state="translated">言語レベルのクエリ構文:</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Same example using the <ph id="ph1">`IEnumerable&lt;T&gt;`</ph> API:</source>
          <target state="translated">上記を <ph id="ph1">`IEnumerable&lt;T&gt;`</ph> API を使用して表した場合の例:</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>LINQ is Expressive</source>
          <target state="translated">LINQ は表現力が豊か</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Imagine you have a list of pets, but want to convert it into a dictionary where you can access a pet directly by its <ph id="ph1">`RFID`</ph> value.</source>
          <target state="translated">たとえば、ペットのリストはあるが、<ph id="ph1">`RFID`</ph> 値で直接ペットにアクセスできる辞書に変換する必要があるとします。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Traditional imperative code:</source>
          <target state="translated">従来の命令型コード:</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The intention behind the code is not to create a new <ph id="ph1">`Dictionary&lt;int, Pet&gt;`</ph> and add to it via a loop, it is to convert an existing list into a dictionary!</source>
          <target state="translated">コードの目的は、新しい <ph id="ph1">`Dictionary&lt;int, Pet&gt;`</ph> を作成し、ループを使用して追加することではなく、既存のリストを辞書に変換することです。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>LINQ preserves the intention whereas the imperative code does not.</source>
          <target state="translated">LINQ ではこの目的が維持されますが、命令型コードでは維持されません。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Equivalent LINQ expression:</source>
          <target state="translated">同等の LINQ 式:</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The code using LINQ is valuable because it evens the playing field between intent and code when reasoning as a programmer.</source>
          <target state="translated">プログラマーとして考えると、目的とコードを同等にするため、LINQ を使用するコードのほうが有益です。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Another bonus is code brevity.</source>
          <target state="translated">また、コードが簡潔であるという利点があります。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Imagine reducing large portions of a codebase by 1/3 as done above.</source>
          <target state="translated">上記のように、コードベースの大部分を 3 分の 1 に減らせることを考えれば、</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Pretty sweet deal, right?</source>
          <target state="translated">賢明な選択です。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>LINQ Providers Simplify Data Access</source>
          <target state="translated">LINQ プロバイダーでデータ アクセスが簡単に</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For a significant chunk of software out in the wild, everything revolves around dealing with data from some source (Databases, JSON, XML, etc).</source>
          <target state="translated">実環境の非常に多くのソフトウェアでは、すべてのことが一部のソース (データベース、JSON、XML など) からのデータ処理を中心に展開されます。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Often this involves learning a new API for each data source, which can be annoying.</source>
          <target state="translated">多くの場合、これには面倒なデータ ソースごとの新しい API の学習が含まれます。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>LINQ simplifies this by abstracting common elements of data access into a query syntax which looks the same no matter which data source you pick.</source>
          <target state="translated">LINQ は、データ アクセスの一般的な要素を、選択されたデータ ソースに関係なく同じようなクエリ構文に抽象化することで、これを簡略化します。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consider the following: finding all XML elements with a specific attribute value.</source>
          <target state="translated">たとえば、特定の属性値を持つ XML 要素をすべて検索するとします。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Writing code to manually traverse the XML document to perform this task would be far more challenging.</source>
          <target state="translated">コードを記述して XML ドキュメントを手動でスキャンし、このタスクを実行するのはとても難しいことです。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Interacting with XML isn’t the only thing you can do with LINQ Providers.</source>
          <target state="translated">XML との対話が、LINQ プロバイダーでできる唯一のことではありません。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Linq to SQL<ept id="p1">](https://msdn.microsoft.com/library/bb386976.aspx)</ept> is a fairly bare-bones Object-Relational Mapper (ORM) for an MSSQL Server Database.</source>
          <target state="translated"><bpt id="p1">[</bpt>Linq to SQL<ept id="p1">](https://msdn.microsoft.com/library/bb386976.aspx)</ept> は、MSSQL Server データベースの必要最低限のオブジェクト リレーショナル マッパー (ORM) です。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>JSON.NET<ept id="p1">](http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm)</ept> library provides efficient JSON Document traversal via LINQ.</source>
          <target state="translated"><bpt id="p1">[</bpt>JSON.NET<ept id="p1">](http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm)</ept> ライブラリでは、LINQ を使用して効率的に JSON ドキュメントをトラバースできます。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Furthermore, if there isn’t a library which does what you need, you can also <bpt id="p1">[</bpt>write your own LINQ Provider<ept id="p1">](https://msdn.microsoft.com/library/Bb546158.aspx)</ept>!</source>
          <target state="translated">さらに、必要な作業を行うライブラリがない場合は、<bpt id="p1">[</bpt>独自の LINQ プロバイダーを記述する<ept id="p1">](https://msdn.microsoft.com/library/Bb546158.aspx)</ept>こともできます。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Why Use the Query Syntax?</source>
          <target state="translated">クエリ構文を使用する理由</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This is a question which often comes up.</source>
          <target state="translated">これはよくある質問です。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>After all, this,</source>
          <target state="translated">いずれにせよ、</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>is a lot more concise than this:</source>
          <target state="translated">上の構文は下の構文よりもずっと簡潔です。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Isn’t the API syntax just a more concise way to do the query syntax?</source>
          <target state="translated">API 構文は単に、クエリ構文を実行するより簡潔な方法であるだけでしょうか? </target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">いいえ。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The query syntax allows for the use the <bpt id="p1">**</bpt>let<ept id="p1">**</ept> clause, which allows you to introduce and bind a variable within the scope of the expression, using it in subsequent pieces of the expression.</source>
          <target state="translated">クエリ構文では <bpt id="p1">**</bpt>let<ept id="p1">**</ept> 句を使用できます。したがって、式の後ろの部分でこの句を使用すれば、式のスコープ内で変数を導入してバインドすることができます。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Reproducing the same code with only the API syntax can be done, but will most likely lead to code which is hard to read.</source>
          <target state="translated">API 構文だけでも同じコードを再現できますが、コードが読み取りにくくなる可能性が高くなります。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>So this begs the question, <bpt id="p1">**</bpt>should you just use the query syntax?<ept id="p1">**</ept></source>
          <target state="translated">そこで、<bpt id="p1">**</bpt>クエリ構文を使用する必要があるかどうか<ept id="p1">**</ept>ですが、</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The answer to this question is <bpt id="p1">**</bpt>yes<ept id="p1">**</ept> if...</source>
          <target state="translated">次のような場合には、使用する必要が<bpt id="p1">**</bpt>あります<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Your existing codebase already uses the query syntax</source>
          <target state="translated">既存のコードベースで既にクエリ構文を使用している。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You need to scope variables within your queries due to complexity</source>
          <target state="translated">複雑になるため、クエリ内で変数をスコープする必要がある。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>You prefer the query syntax and it won’t distract from your codebase</source>
          <target state="translated">クエリ構文が好ましく、コードベースから注意がそれることはない。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The answer to this question is <bpt id="p1">**</bpt>no<ept id="p1">**</ept> if...</source>
          <target state="translated">次のような場合には、使用する必要は<bpt id="p1">**</bpt>ありません<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Your existing codebase already uses the API syntax</source>
          <target state="translated">既存のコードベースで既に API 構文を使用している。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You have no need to scope variables within your queries</source>
          <target state="translated">クエリ内で変数をスコープする必要はない。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You prefer the API syntax and it won’t distract from your codebase</source>
          <target state="translated">API 構文が好ましく、コードベースから注意がそれることはない。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Essential Samples</source>
          <target state="translated">重要なサンプル</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For a truly comprehensive list of LINQ samples, visit <bpt id="p1">[</bpt>101 LINQ Samples<ept id="p1">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept>.</source>
          <target state="translated">LINQ サンプルの一覧については、「<bpt id="p1">[</bpt>101 LINQ Samples<ept id="p1">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept>」 (101 個の LINQ サンプル) を参照してください。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The following is a quick demonstration of some of the essential pieces of LINQ.</source>
          <target state="translated">以下に、LINQ の重要な要素をいくつか簡単に示します。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This is in no way comprehensive, as LINQ provides significantly more functionality than what is showcased here.</source>
          <target state="translated">これは決して包括的なものではありません。LINQ ではここで紹介するものよりはるかに多くの機能が提供されます。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The bread and butter - <ph id="ph1">`Where`</ph>, <ph id="ph2">`Select`</ph>, and <ph id="ph3">`Aggregate`</ph>:</source>
          <target state="translated">最も基本的かつ重要な要素 - <ph id="ph1">`Where`</ph>、<ph id="ph2">`Select`</ph>、および <ph id="ph3">`Aggregate`</ph>:</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Flattening a list of lists:</source>
          <target state="translated">リストをまとめてフラット化する場合:</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Union between two sets (with custom comparator):</source>
          <target state="translated">2 つのセットの和集合 (カスタム比較子を含む):</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Intersection between two sets:</source>
          <target state="translated">2 つのセットの積集合:</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Ordering:</source>
          <target state="translated">並べ替え:</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Finally, a more advanced sample: determining if the values of the properties of two instances of the same type are equal (Borrowed and modified from <bpt id="p1">[</bpt>this StackOverflow post<ept id="p1">](http://stackoverflow.com/a/844855)</ept>):</source>
          <target state="translated">最後に、より高度なサンプルを以下に示します。同じ型の&amp;2; つのインスタンスのプロパティ値が等しいかどうかを判断します (<bpt id="p1">[</bpt>この StackOverflow の投稿<ept id="p1">](http://stackoverflow.com/a/844855)</ept>から借用し、変更したもの)。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>PLINQ</source>
          <target state="translated">PLINQ</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>PLINQ, or Parallel LINQ, is a parallel execution engine for LINQ expressions.</source>
          <target state="translated">PLINQ (Parallel LINQ) は、LINQ 式の並列実行エンジンです。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In other words, a regular LINQ expressions can be trivially parallelized across any number of threads.</source>
          <target state="translated">つまり、LINQ の正規表現は、任意の数のスレッドで普通に並列化できます。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This is accomplished via a call to <ph id="ph1">`AsParallel()`</ph> preceding the expression.</source>
          <target state="translated">これは、式の前に <ph id="ph1">`AsParallel()`</ph> を指定して呼び出すことで実行できます。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">次に例を示します。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This code will partition <ph id="ph1">`facebookUsers`</ph> across system threads as necessary, sum up the total likes on each thread in parallel, sum the results computed by each thread, and project that result into a nice string.</source>
          <target state="translated">このコードでは、必要に応じてシステム スレッドにまたがる <ph id="ph1">`facebookUsers`</ph> をパーティション分割し、各スレッドの "いいね!" の数を合計し、スレッドごとの計算結果を合計して、その結果を適切な文字列に投影します。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In diagram form:</source>
          <target state="translated">図で表すと次のようになります。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>PLINQ diagram</source>
          <target state="translated">PLINQ の図</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Parallelizable CPU-bound jobs which can be easily expressed via LINQ (in other words, are pure functions and have no side effects) are a great candidate for PLINQ.</source>
          <target state="translated">LINQ で簡単に表すことができる (つまり、純粋関数で副作用のない) 並列化可能な CPU 制約のあるジョブは、PLINQ の候補として最適です。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For jobs which <bpt id="p1">_</bpt>do<ept id="p1">_</ept> have a side effect, consider using the <bpt id="p2">[</bpt>Task Parallel Library<ept id="p2">](https://msdn.microsoft.com/library/dd460717.aspx)</ept>.</source>
          <target state="translated">副作用の<bpt id="p1">_</bpt>ある<ept id="p1">_</ept>ジョブの場合は、<bpt id="p2">[</bpt>タスク並列ライブラリ<ept id="p2">](https://msdn.microsoft.com/library/dd460717.aspx)</ept>の使用を検討してください。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Further Resources:</source>
          <target state="translated">他のリソース:</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>101 LINQ Samples<ept id="p1">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>101 個の LINQ サンプル<ept id="p1">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Linqpad<ept id="p1">](https://www.linqpad.net/)</ept>, a playground environment and Database querying engine for C#/F#/VB</source>
          <target state="translated"><bpt id="p1">[</bpt>Linqpad<ept id="p1">](https://www.linqpad.net/)</ept>。プレイグラウンド環境とデータベース クエリ エンジン (C#/F#/VB 用)</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>EduLinq<ept id="p1">](http://codeblog.jonskeet.uk/2011/02/23/reimplementing-linq-to-objects-part-45-conclusion-and-list-of-posts/)</ept>, an e-book for learning how LINQ-to-objects is implemented</source>
          <target state="translated"><bpt id="p1">[</bpt>EduLinq<ept id="p1">](http://codeblog.jonskeet.uk/2011/02/23/reimplementing-linq-to-objects-part-45-conclusion-and-list-of-posts/)</ept>。LINQ to Objects の実装方法を学習するための電子書籍</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>