<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">74f421a5badd9f2c7bf10fa1dfdf98161bba2ce8</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\collections\threadsafe\when-to-use-a-thread-safe-collection.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">098df41a5c9d3bf053e5ec0a9b66a8b09370dce9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">034c347f9f958dcea9ed516407642c3f80cd0b2f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>When to Use a Thread-Safe Collection</source>
          <target state="translated">スレッド セーフなコレクションを使用する状況</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>When to Use a Thread-Safe Collection</source>
          <target state="translated">スレッド セーフなコレクションを使用する状況</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>When to Use a Thread-Safe Collection</source>
          <target state="translated">スレッド セーフなコレクションを使用する状況</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ConcurrentQueue`</ph>, <ph id="ph2">`ConcurrentStack`</ph>, <ph id="ph3">`ConcurrentDictionary`</ph>, <ph id="ph4">`ConcurrentBag`</ph>, and <ph id="ph5">`BlockingCollection`</ph> collection types are specially designed to support multi-threaded add and remove operations.</source>
          <target state="translated"><ph id="ph1">`ConcurrentQueue`</ph>、<ph id="ph2">`ConcurrentStack`</ph>、<ph id="ph3">`ConcurrentDictionary`</ph>、<ph id="ph4">`ConcurrentBag`</ph> と <ph id="ph5">`BlockingCollection`</ph> コレクション型は、マルチ スレッドの追加および削除の操作をサポートするために、特別に設計されています。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms.</source>
          <target state="translated">スレッド セーフを確保するために、これらの新しい型では、さまざまな種類の効率的なロック同期機構とロック制御の不要な同期機構が使用されます。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Synchronization adds overhead to an operation.</source>
          <target state="translated">同期を行うと、操作にオーバーヘッドが追加されます。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</source>
          <target state="translated">オーバーヘッドの量は、使用する同期の種類、実行する操作の種類、およびその他の要因 (コレクションに同時にアクセスしようとするスレッドの数など) によって異なります。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</source>
          <target state="translated">一部のシナリオでは、同期のオーバーヘッドがほとんどなく、外部ロックで保護されるスレッド セーフでない同等の型よりもマルチスレッド型の方が、パフォーマンスとスケーラビリティが大幅に向上することがあります。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</source>
          <target state="translated">その他のシナリオでは、オーバーヘッドが原因で、スレッド セーフな型のパフォーマンスとスケーラビリティが、外部からロックされるスレッド セーフでないバージョンの型と同等かそれ以下になることもあります。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</source>
          <target state="translated">以下のセクションでは、スレッド セーフなコレクションと、読み取り操作および書き込み操作でユーザー指定のロックを使用するスレッド セーフでない同等のコレクションの使い分けに関する一般的なガイダンスを示します。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</source>
          <target state="translated">パフォーマンスはさまざまな要因に左右されるため、このガイダンスは特定の状況には沿っておらず、すべての状況で有効であるとは限りません。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</source>
          <target state="translated">パフォーマンスが重要な場合、使用するコレクション型を判断する最適な方法は、代表的なコンピューター構成および負荷に基づいてパフォーマンスを計測することです。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This document uses the following terms:</source>
          <target state="translated">このドキュメントでは、次の用語が使用されています。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Pure producer-consumer scenario:<ept id="p1">*</ept> Any given thread is either adding or removing elements, but not both.</source>
          <target state="translated"><bpt id="p1">*</bpt>純粋プロデューサー/コンシューマー シナリオ:<ept id="p1">*</ept> 任意のスレッドで、要素の追加または削除のいずれかが実行されますが、両方は実行されません。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Mixed producer-consumer scenario:<ept id="p1">*</ept> Any given thread is both adding and removing elements.</source>
          <target state="translated"><bpt id="p1">*</bpt>混合プロデューサー/コンシューマー シナリオ:<ept id="p1">*</ept> 任意のスレッドで、要素を追加および削除の両方が実行されます。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Speedup:<ept id="p1">*</ept> Faster algorithmic performance relative to another type in the same scenario.</source>
          <target state="translated"><bpt id="p1">*</bpt>高速化:<ept id="p1">*</ept> 同じシナリオで別の型と比較してアルゴリズムのパフォーマンスが向上することです。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Scalability:<ept id="p1">*</ept> The increase in performance that is proportional to the number of cores on the computer.</source>
          <target state="translated"><bpt id="p1">*</bpt>スケーラビリティ:<ept id="p1">*</ept> コンピューターのコア数に比例したパフォーマンスの向上。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>An algorithm that scales performs faster on eight cores than it does on two cores.</source>
          <target state="translated">スケーリングするアルゴリズムのパフォーマンスは、コア数が 2 の場合よりも 8 の場合の方が向上します。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> vs. Queue<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph></source>
          <target state="translated">ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> 対 Queue<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> can offer modest performance benefits over a <bpt id="p2">[</bpt>System.Collections.Generic.Queue<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Queue-1)</ept> that has an external lock.</source>
          <target state="translated">純粋プロデューサー/コンシューマー シナリオでは、各要素の処理時間がとても短い (命令が少ない) 場合、<bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> は、外部ロックを使用する <bpt id="p2">[</bpt>System.Collections.Generic.Queue<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Queue-1)</ept> よりも若干優れたパフォーマンスを提供します。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In this scenario, <ph id="ph1">`ConcurrentQueue&lt;T&gt;`</ph> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</source>
          <target state="translated">このシナリオでは、キューへの配置とキューからの取り出しをそれぞれ専用のスレッドが実行している場合に、<ph id="ph1">`ConcurrentQueue&lt;T&gt;`</ph> のパフォーマンスが最大限に引き出されます。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>If you do not enforce this rule, then <ph id="ph1">`Queue&lt;T&gt;`</ph> might even perform slightly faster than <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph> on computers that have multiple cores.</source>
          <target state="translated">この規則を強制していない場合、<ph id="ph1">`Queue&lt;T&gt;`</ph> は、複数のコアを持つコンピューター上の <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph> よりも若干向上する場合があります。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <ph id="ph1">`ConcurrentQueue&lt;T&gt;`</ph>, which then has very good scalability.</source>
          <target state="translated">処理時間が 500 FLOPS (浮動小数点演算) 以上の場合、2 つのスレッドを使用する規則は <ph id="ph1">`ConcurrentQueue&lt;T&gt;`</ph> に適用されません。この型でとても優れたスケーラビリティが実現します。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Queue&lt;T&gt;`</ph> does not scale well in this scenario.</source>
          <target state="translated"><ph id="ph1">`Queue&lt;T&gt;`</ph> は、このシナリオではスケーラビリティの点で劣ります。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In mixed producer-consumer scenarios, when the processing time is very small, a <ph id="ph1">`Queue&lt;T&gt;`</ph> that has an external lock scales better than <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph> does.</source>
          <target state="translated">混合プロデューサー/コンシューマー シナリオでは、処理時間がとても短い場合、外部ロックを使用する <ph id="ph1">`Queue&lt;T&gt;`</ph> のスケーラビリティは <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph> よりも優れています。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>However, when processing time is around 500 FLOPS or more, then the <ph id="ph1">`ConcurrentQueue&lt;T&gt;`</ph> scales better.</source>
          <target state="translated">ただし、処理時間が約 500 FLOPS 以上の場合、<ph id="ph1">`ConcurrentQueue&lt;T&gt;`</ph> の方がスケーラビリティに優れます。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>ConcurrentStack vs. Stack</source>
          <target state="translated">ConcurrentStack 対 Stack</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In pure producer-consumer scenarios, when processing time is very small, then <bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentStack<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> and <bpt id="p2">[</bpt>System.Collections.Generic.Stack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Stack-1)</ept> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</source>
          <target state="translated">純粋プロデューサー/コンシューマー シナリオでは、処理時間が非常に短い場合、プッシュとポップをそれぞれ専用のスレッドが実行しているときは、<bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentStack<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> および外部ロックを使用する <bpt id="p2">[</bpt>System.Collections.Generic.Stack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Stack-1)</ept> のパフォーマンスはほぼ同じであると考えられます。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>However, as the number of threads increases, both types slow down because of increased contention, and <ph id="ph1">`Stack&lt;T&gt;`</ph> might perform better than <ph id="ph2">`ConcurrentStack&lt;T&gt;`</ph>.</source>
          <target state="translated">ただし、スレッド数が増えると、競合が増えることで両方の型のパフォーマンスが低下し、<ph id="ph1">`Stack&lt;T&gt;`</ph> の方が <ph id="ph2">`ConcurrentStack&lt;T&gt;`</ph> よりも優れたパフォーマンスを示すことがあります。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</source>
          <target state="translated">処理時間が約 500 FLOPS 以上の場合は、両方の型がほぼ同じスケーラビリティを示します。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In mixed producer-consumer scenarios, <ph id="ph1">`ConcurrentStack&lt;T&gt;`</ph> is faster for both small and large workloads.</source>
          <target state="translated">混合プロデューサー/コンシューマー シナリオでは、ワークロードの大小にかかわらず、<ph id="ph1">`ConcurrentStack&lt;T&gt;`</ph> の方が高速です。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The use of the <ph id="ph1">`PushRange`</ph> and <ph id="ph2">`TryPopRange`</ph> may greatly speed up access times.</source>
          <target state="translated"><ph id="ph1">`PushRange`</ph> と <ph id="ph2">`TryPopRange`</ph> を使用すると、アクセス時間が大幅に短縮される可能性があります。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>ConcurrentDictionary vs. Dictionary</source>
          <target state="translated">ConcurrentDictionary 対 Dictionary</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In general, use a <bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2)</ept> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</source>
          <target state="translated">一般に、複数のスレッドから同時にキーまたは値を追加および更新している任意のシナリオでは、<bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2)</ept> を使用します。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>In scenarios that involve frequent updates and relatively few reads, the <ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> generally offers modest benefits.</source>
          <target state="translated">更新を頻繁に行い、読み取りは比較的少ないシナリオでは、通常、<ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> には大きな利点はありません。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In scenarios that involve many reads and many updates, the <ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> generally is significantly faster on computers that have any number of cores.</source>
          <target state="translated">読み取りも更新も多いシナリオでは、通常、コンピューターに任意の数のコアを備えられる場合は <ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> の方が大幅に高速です。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>In scenarios that involve frequent updates, you can increase the degree of concurrency in the <ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> and then measure to see whether performance increases on computers that have more cores.</source>
          <target state="translated">更新を頻繁に行うシナリオでは、<ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> で同時実行の程度を上げて、コンピューターのコア数が多いほどパフォーマンスが向上するかどうかを計測できます。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If you change the concurrency level, avoid global operations as much as possible.</source>
          <target state="translated">同時実行レベルを変更する場合、グローバル操作はできるだけ避けてください。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If you are only reading key or values, the <bpt id="p1">[</bpt>System.Collections.Generic.Dictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2)</ept> is faster because no synchronization is required if the dictionary is not being modified by any threads.</source>
          <target state="translated">キーまたは値の読み取りのみを行う場合、ディクショナリがスレッドによって変更されないときは同期が不要なため、<bpt id="p1">[</bpt>System.Collections.Generic.Dictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2)</ept> の方が高速です。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>ConcurrentBag</source>
          <target state="translated">ConcurrentBag</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In pure producer-consumer scenarios, <bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentBag<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept> will probably perform more slowly than the other concurrent collection types.</source>
          <target state="translated">純粋プロデューサー/コンシューマー シナリオでは、<bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentBag<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept> は、その他の同時実行コレクション型よりもパフォーマンスの点で劣ると考えられます。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In mixed producer-consumer scenarios, <ph id="ph1">`ConcurrentBag&lt;T&gt;`</ph> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</source>
          <target state="translated">混合プロデューサー/コンシューマー シナリオでは、通常、ワークロードの大小にかかわらず、<ph id="ph1">`ConcurrentBag&lt;T&gt;`</ph> は他の同時実行コレクション型よりもはるかに高速でスケーラビリティに優れます。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>BlockingCollection</source>
          <target state="translated">BlockingCollection</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>When bounding and blocking semantics are required, <bpt id="p1">[</bpt>System.Collections.Concurrent.BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> will probably perform faster than any custom implementation.</source>
          <target state="translated">境界ブロッキング セマンティクスが必要な場合は、<bpt id="p1">[</bpt>System.Collections.Concurrent.BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> の方がカスタム実装よりもパフォーマンスの点で優れると考えられます。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>It also supports rich cancellation, enumeration, and exception handling.</source>
          <target state="translated">この型では、高度なキャンセル、列挙、および例外処理もサポートされます。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">関連項目</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept></target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Thread-Safe Collections<ept id="p1">](index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>スレッドセーフなコレクション<ept id="p1">](index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>