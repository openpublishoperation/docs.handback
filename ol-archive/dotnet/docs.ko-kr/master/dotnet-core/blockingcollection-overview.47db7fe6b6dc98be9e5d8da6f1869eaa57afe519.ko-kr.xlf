<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8a770fb7143a547031daf231d1a0863322c3cfaa</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\collections\threadsafe\blockingcollection-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5bc7ad31f5c5c5bb22695a7e7e2cb6f0118fa3fa</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">251ba741ba26217dd42939dd73f9e65137e27a21</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="translated">BlockingCollection 개요</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="translated">BlockingCollection 개요</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="translated">BlockingCollection 개요</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> is a thread-safe collection class that provides the following features:</source>
          <target state="translated"><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept>는 스레드로부터 안전한 컬렉션 클래스이며 제공하는 기능은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>An implementation of the Producer-Consumer pattern.</source>
          <target state="translated">공급자-소비자 패턴 구현</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Thread-safe addition and removal of items from a collection.</source>
          <target state="translated">스레드로부터 안전한 컬렉션 항목 추가 및 제거</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Optional maximum capacity.</source>
          <target state="translated">선택적 최대 용량</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Insertion and removal operations that block when collection is empty or full.</source>
          <target state="translated">컬렉션이 비어 있거나 가득 찬 경우 차단할 작업 삽입 및 제거</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Insertion and removal "try" operations that do not block or that block up to a specified period of time.</source>
          <target state="translated">지정된 시간까지 차단하지 않거나 차단할 “시도” 작업 삽입 및 제거</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Encapsulates any collection type that implements <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>를 구현하는 모든 컬렉션 형식의 캡슐화</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Cancellation with cancellation tokens.</source>
          <target state="translated">취소 토큰으로 취소</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Two kinds of enumeration with <ph id="ph1">`foreach`</ph>:</source>
          <target state="translated"><ph id="ph1">`foreach`</ph>를 사용하는 다음 두 가지 유형의 열거</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Read-only enumeration.</source>
          <target state="translated">읽기 전용 열거</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Enumeration that removes items as they are enumerated.</source>
          <target state="translated">열거된 항목을 제거하는 열거</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Bounding and Blocking Support</source>
          <target state="translated">한계 지정 및 차단 지원</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> supports bounding and blocking.</source>
          <target state="translated"><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept>는 한계 지정 및 차단을 지원합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Bounding means you can set the maximum capacity of the collection.</source>
          <target state="translated">한계 지정이란 컬렉션의 최대 용량을 설정하는 것을 의미합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.</source>
          <target state="translated">메모리에서 컬렉션의 최대 크기를 제어할 수 있고 공급자 스레드가 소비자 스레드와 보조를 맞춰 실행되도록 할 수 있기 때문에 특정 시나리오에서 한계 지정은 중요한 의미를 가집니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.</source>
          <target state="translated">다중 스레드 또는 작업은 동시에 항목을 컬렉션에 추가할 수 있습니다. 컬렉션이 지정된 최대 용량에 도달하는 경우 항목 하나를 제거할 때까지 공급자 스레드를 차단합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.</source>
          <target state="translated">여러 소비자에서 항목을 동시에 제거할 수 있습니다. 컬렉션이 비어 있는 경우 공급자가 항목 하나를 추가할 때까지 소비자 스레드를 차단합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>A producing thread can call <ph id="ph1">`CompleteAdding`</ph> to indicate that no more items will be added.</source>
          <target state="translated">공급자 스레드는 <ph id="ph1">`CompleteAdding`</ph>을 호출하여 더 이상 추가할 항목이 없음을 나타낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consumers monitor the <ph id="ph1">`IsCompleted`</ph> property to know when the collection is empty and no more items will be added.</source>
          <target state="translated">소비자 스레드는 컬렉션이 비어 있고 항목이 더 이상 추가되지 않는 시점을 파악하기 위해 <ph id="ph1">`IsCompleted`</ph> 속성을 모니터링합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The following example shows a simple <ph id="ph1">`BlockingCollection`</ph> with a bounded capacity of 100.</source>
          <target state="translated">다음 예제에서는 한계 용량이 100인 간단한 <ph id="ph1">`BlockingCollection`</ph>을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A producer task adds items to the collection as long as some external condition is true, and then calls <ph id="ph1">`CompleteAdding`</ph>.</source>
          <target state="translated">공급자 작업에서는 일부 외부 조건이 true이면 항목을 컬렉션에 추가한 다음 <ph id="ph1">`CompleteAdding`</ph>을 호출합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The consumer task takes items until the <ph id="ph1">`IsCompleted`</ph> property is true.</source>
          <target state="translated">소비자 작업에서는 <ph id="ph1">`IsCompleted`</ph> 속성이 true일 때까지 항목을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For a complete example, see <bpt id="p1">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</source>
          <target state="translated">완전한 예제는 <bpt id="p1">[</bpt>방법: BlockingCollection에서 개별적으로 항목 추가 및 가져오기<ept id="p1">](how-to-add-and-take-items.md)</ept>를 참조하십시오.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Timed Blocking Operations</source>
          <target state="translated">시간 지정된 차단 작업</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In timed blocking <ph id="ph1">`TryAdd`</ph> and <ph id="ph2">`TryTake`</ph> operations on bounded collections, the method tries to add or take an item.</source>
          <target state="translated">한계 지정된 컬렉션의 시간 지정된 <ph id="ph1">`TryAdd`</ph> 및 <ph id="ph2">`TryTake`</ph> 차단 작업에서 메서드는 항목을 추가하거나 가져오려고 합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If an item is available it is placed into the variable that was passed in by reference, and the method returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">사용 가능한 항목이 있으면 이 항목은 참조로 전달된 변수에 저장되고 메서드에서 <ph id="ph1">`true`</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If no item is retrieved after a specified time-out period the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">지정된 제한 시간이 경과한 후에 검색되는 항목이 없으면 메서드에서 <ph id="ph1">`false`</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The thread is then free to do some other useful work before trying again to access the collection.</source>
          <target state="translated">그러면 스레드에서 유용한 다른 작업을 수행한 후에 컬렉션에 대한 액세스를 다시 시도할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For an example of timed blocking access, see the second example in <bpt id="p1">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</source>
          <target state="translated">시간 지정된 차단 액세스에 대한 예제는 <bpt id="p1">[</bpt>방법: BlockingCollection에서 개별적으로 항목 추가 및 가져오기<ept id="p1">](how-to-add-and-take-items.md)</ept>에 있는 두 번째 예제를 참조하십시오.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Cancelling Add and Take Operations</source>
          <target state="translated">추가 및 가져오기 작업 취소</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Add and Take operations are typically performed in a loop.</source>
          <target state="translated">추가 및 가져오기 작업은 일반적으로 루프에서 수행됩니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can cancel a loop by passing in a <ph id="ph1">`CancellationToken`</ph> to the <ph id="ph2">`TryAdd`</ph> or <ph id="ph3">`TryTake`</ph> method, and then checking the value of the token's <ph id="ph4">`IsCancellationRequested`</ph> property on each iteration.</source>
          <target state="translated"><ph id="ph2">`TryAdd`</ph> 또는 <ph id="ph3">`TryTake`</ph> 메서드에 <ph id="ph1">`CancellationToken`</ph>을 전달한 다음, 각 반복마다 이 토큰의 <ph id="ph4">`IsCancellationRequested`</ph> 속성 값을 확인하여 루프를 취소할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If the value is <ph id="ph1">`true`</ph>, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.</source>
          <target state="translated">이 속성 값이 <ph id="ph1">`true`</ph>이면 사용자가 모든 리소스를 정리하고 루프를 종료하여 취소 요청에 응답해야 합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following example shows an overload of <ph id="ph1">`TryAdd`</ph> that takes a cancellation token, and the code that uses it:</source>
          <target state="translated">다음 예제에서는 취소 토큰을 사용하는 <ph id="ph1">`TryAdd`</ph>의 오버로드 및 이 오버로드를 사용하는 코드를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Specifying the Collection Type</source>
          <target state="translated">컬렉션 형식 지정</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When you create a <ph id="ph1">`BlockingCollection&lt;T&gt;;`</ph>, you can specify not only the bounded capacity but also the type of collection to use.</source>
          <target state="translated"><ph id="ph1">`BlockingCollection&lt;T&gt;;`</ph>를 만들 때는 한계 지정되는 용량뿐 아니라 사용할 컬렉션의 형식도 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, you could specify a <bpt id="p1">[</bpt>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> for first in-first out (FIFO) behavior, or a <bpt id="p2">[</bpt>ConcurrentStack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> for last in-first out (LIFO) behavior.</source>
          <target state="translated">예를 들어 FIFO(선입 선출) 동작에 <bpt id="p1">[</bpt>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept>를 지정하거나 LIFO(후입 선출) 동작에 <bpt id="p2">[</bpt>ConcurrentStack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept>를 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can use any collection class that implements the <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept> interface.</source>
          <target state="translated"><bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept> 인터페이스를 구현하는 컬렉션 클래스를 모두 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The default collection type for <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> is <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph>.</source>
          <target state="translated"><ph id="ph1">`BlockingCollection&lt;T&gt;`</ph>의 기본 컬렉션 형식은 <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph>입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The following code example shows how to create a <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> of strings that has a capacity of 1000 and uses a <bpt id="p1">[</bpt>ConcurrentBag<ph id="ph2">&amp;lt;</ph>T<ph id="ph3">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept>:</source>
          <target state="translated">다음 코드 예제에서는 용량이 1000이고 <bpt id="p1">[</bpt>ConcurrentBag<ph id="ph2">&amp;lt;</ph>T<ph id="ph3">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept>를 사용하는 <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> 문자열을 만드는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>IEnumerable Support</source>
          <target state="translated">IEnumerable 지원</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> provides a <ph id="ph2">`GetConsumingEnumerable`</ph> method that enables consumers to use a <ph id="ph3">`foreach`</ph> statement to remove items until the collection is completed, which means it is empty and no more items will be added.</source>
          <target state="translated"><ph id="ph1">`BlockingCollection&lt;T&gt;`</ph>에서는 컬렉션이 완료될 때까지, 즉 컬렉션이 비어 있고 항목이 더 이상 추가되지 않을 때까지 소비자가 <ph id="ph3">`foreach`</ph> 문을 사용하여 항목을 제거할 수 있도록 하는 <ph id="ph2">`GetConsumingEnumerable`</ph> 메서드를 제공합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Use ForEach to Remove Items in a BlockingCollection<ept id="p1">](how-to-use-foreach-to-remove.md)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>방법: ForEach를 사용하여 BlockingCollection 항목 제거<ept id="p1">](how-to-use-foreach-to-remove.md)</ept>를 참조하십시오.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Using Many BlockingCollections As One</source>
          <target state="translated">여러 BlockingCollection을 하나로 사용</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> and use the static methods such as <ph id="ph2">`TakeFromAny`</ph> and <ph id="ph3">`AddToAny`</ph> that will add to or take from any of the collections in the array.</source>
          <target state="translated">소비자에서 여러 컬렉션의 항목을 동시에 가져와야 하는 시나리오의 경우 <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> 배열을 만들고, 배열 내의 컬렉션에 항목을 추가하거나 이 컬렉션으로부터 항목을 가져올 <ph id="ph3">`AddToAny`</ph> 및 <ph id="ph2">`TakeFromAny`</ph>와 같은 정적 메서드를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If one collection is blocking, the method immediately tries another until it finds one that can perform the operation.</source>
          <target state="translated">특정 컬렉션이 차단되는 즉시 메서드에서 작업을 수행할 수 있는 컬렉션을 찾을 때까지 다른 컬렉션에 대한 액세스를 시도합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Use Arrays of Blocking Collections in a Pipeline<ept id="p1">](how-to-use-arrays-of-blockingcollections.md)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>방법: 파이프라인에서 차단 컬렉션 배열 사용<ept id="p1">](how-to-use-arrays-of-blockingcollections.md)</ept>을 참조하십시오.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Collections and Data Structures<ept id="p1">](../index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>컬렉션 및 데이터 구조<ept id="p1">](../index.md)</ept></target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Thread-Safe Collections<ept id="p1">](index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>스레드로부터 안전한 컬렉션<ept id="p1">](index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>