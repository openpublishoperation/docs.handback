<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b752e23f37f83a68ef4a7a97108479f7736d53cd</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\migrating-from-dnx.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c6aafd3ead74fbd4c530d08c20269cec4974ec57</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">defb9cd7a64178a68a21e9fcbf80be48c0ae00d6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Migrating from DNX to .NET Core CLI</source>
          <target state="translated">DNX에서 .NET Core CLI로 마이그레이션</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Migrating from DNX to .NET Core CLI</source>
          <target state="translated">DNX에서 .NET Core CLI로 마이그레이션</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Migrating from DNX to .NET Core CLI</source>
          <target state="translated">DNX에서 .NET Core CLI로 마이그레이션</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">개요</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The RC1 release of .NET Core and ASP.NET Core 1.0 introduced DNX tooling.</source>
          <target state="translated">.NET Core 및 ASP.NET Core 1.0의 RC1 릴리스에서 DNX 도구를 발표했습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The RC2 release of .NET Core and ASP.NET Core 1.0 moved from DNX to the .NET Core CLI.</source>
          <target state="translated">.NET Core 및 ASP.NET Core 1.0의 RC2 릴리스에서 DNX에서 .NET Core CLI로 전환했습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>As a slight refresher, let's recap what DNX was about.</source>
          <target state="translated">가볍게 복습하는 의미에서 DNX에 대해 정리해 보겠습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>DNX was a runtime and a toolset used to build .NET Core and, more specifically, ASP.NET Core 1.0 applications.</source>
          <target state="translated">DNX는 .NET Core, 좀 더 구체적으로 말해서 ASP.NET Core 1.0 응용 프로그램 빌드에 사용된 런타임 및 도구 집합이었습니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It consisted of 3 main pieces:</source>
          <target state="translated">DNX는 3개의 주요 부분으로 구성되었습니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>DNVM - an install script for obtaining DNX</source>
          <target state="translated">DNVM - DNX를 얻기 위한 설치 스크립트</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>DNX (Dotnet Execution Runtime) - the runtime that executes your code</source>
          <target state="translated">DNX(Dotnet 실행 런타임) - 코드를 실행하는 런타임</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>DNU (Dotnet Developer Utility) - tooling for managing dependencies, building and publishing your applications</source>
          <target state="translated">DNU(Dotnet 개발자 유틸리티) - 종속성을 관리하고 응용 프로그램을 빌드 및 게시하기 위한 도구</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>With the introduction of the CLI, all of the above are now part of a single toolset.</source>
          <target state="translated">CLI의 도입에 따라 이제 위의 모든 요소는 단일 도구 집합의 일부입니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>However, since DNX was available in RC1 timeframe, you might have projects that were built using it that you would want to move off to the new CLI tooling.</source>
          <target state="translated">그러나 DNX는 RC1 시기에 사용 가능했으므로 이를 사용해 빌드한 프로젝트가 있고, 새 CLI 도구에서 해당 프로젝트를 이동하고자 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This migration guide will cover the essentials on how to migrate projects off of DNX and onto .NET Core CLI.</source>
          <target state="translated">이 마이그레이션 가이드에서는 DNX에서 .NET Core CLI로 프로젝트를 마이그레이션하는 방법의 필수 사항을 다룹니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>If you are just starting a project on .NET Core from scratch, you can freely skip this document.</source>
          <target state="translated">.NET Core에서 막 프로젝트를 시작하는 경우 이 문서를 건너뛸 수 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Main changes in the tooling</source>
          <target state="translated">도구의 주요 변경 사항</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>There are some general changes in the tooling that should be outlined first.</source>
          <target state="translated">먼저 설명해야 할 몇 가지 일반적인 도구 변경 사항이 있습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>No more DNVM</source>
          <target state="translated">더 이상 DNVM 없음</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>DNVM, short for <bpt id="p1">*</bpt>DotNet Version Manager<ept id="p1">*</ept> was a bash/PowerShell script used to install a DNX on your machine.</source>
          <target state="translated">DNVM(<bpt id="p1">*</bpt>DotNet Version Manager<ept id="p1">*</ept>)은 컴퓨터에 DNX를 설치하는 데 사용된 bash/PowerShell 스크립트였습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>It helped users get the DNX they need from the feed they specified (or default ones) as well as mark a certain DNX "active", which would put it on the $PATH for the given session.</source>
          <target state="translated">DNVM을 통해 사용자는 지정한 피드(또는 기본 피드)에서 필요한 DNX를 가져와 특정 DNX를 "활성"으로 표시하여 특정 세션의 $PATH에 둘 수 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>This would allow you to use the various tools.</source>
          <target state="translated">이렇게 하면 다양한 도구를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>DNVM was discontinued because its feature set was made redundant by changes coming in the .NET Core CLI tools.</source>
          <target state="translated">DNVM은 기능 집합이 .NET Core CLI 도구에 포함된 변경 사항과 중복되므로 단종되었습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The CLI tools come packaged in two main ways, as was explained in the <bpt id="p1">[</bpt>overview document<ept id="p1">](tools/index.md#installation)</ept>:</source>
          <target state="translated"><bpt id="p1">[</bpt>개요 문서<ept id="p1">](tools/index.md#installation)</ept>에 설명된 대로 CLI 도구는 중요한 두 가지 방법으로 패키지됩니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Native installers for a given platform</source>
          <target state="translated">지정된 플랫폼에 대한 기본 설치 관리자</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Install script for other situations (like CI servers)</source>
          <target state="translated">다른 상황(예: CI 서버)에 대한 설치 스크립트</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Given this, the DNVM install features are not needed.</source>
          <target state="translated">이러한 점에서 DNVM 설치 기능이 필요하지 않습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>But what about the runtime selection features?</source>
          <target state="translated">그러나 런타임 선택 기능은 어떤가요?</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You reference a runtime in your <ph id="ph1">`project.json`</ph> by adding a package of a certain version to your dependencies.</source>
          <target state="translated">특정 버전의 패키지를 종속성에 추가하여 <ph id="ph1">`project.json`</ph>에서 런타임을 참조합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>With this change, your application will be able to use the new runtime bits.</source>
          <target state="translated">이 변경으로 응용 프로그램은 새로운 런타임 비트를 사용할 수 있게 됩니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Getting these bits to your machine is the same as with the CLI: you install the runtime via one of the native installers it supports or via its install script.</source>
          <target state="translated">이러한 비트를 컴퓨터로 가져오는 것은 CLI와 마찬가지입니다. 지원되는 기본 설치 관리자 중 하나 또는 설치 스크립트를 통해 런타임을 설치합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Different commands</source>
          <target state="translated">다양한 명령</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you were using DNX, you used some commands from one of its three parts (DNX, DNU or DNVM).</source>
          <target state="translated">DNX를 사용한 경우 세 부분(DNX, DNU 또는 DNVM) 중 하나에서 몇 가지 명령을 사용했습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>With the CLI, some of these commands change, some are not available and some are the same but have slightly different semantics.</source>
          <target state="translated">CLI에서는 이러한 명령 중 몇 개는 변경되고, 일부는 사용할 수 없으며, 일부는 동일하지만 의미 체계가 약간 다릅니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The table below shows the mapping between the DNX/DNU commands and their CLI counterparts.</source>
          <target state="translated">다음 표에서는 DNX/DNU 명령 및 해당 CLI 명령 간의 매핑을 보여줍니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>DNX command</source>
          <target state="translated">DNX 명령</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>CLI command</source>
          <target state="translated">CLI 명령</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>dnx run</source>
          <target state="translated">dnx run</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>dotnet run</source>
          <target state="translated">dotnet run</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Run code from source.</source>
          <target state="translated">소스에서 코드를 실행합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>dnu build</source>
          <target state="translated">dnu build</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>dotnet build</source>
          <target state="translated">dotnet build</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Build an IL binary of your code.</source>
          <target state="translated">코드의 IL 바이너리를 빌드합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>dnu pack</source>
          <target state="translated">dnu pack</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>dotnet pack</source>
          <target state="translated">dotnet pack</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Package up a NuGet package of your code.</source>
          <target state="translated">코드의 NuGet 패키지를 패키지합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>dnx <ph id="ph1">\[</ph>command] (for example, "dnx web")</source>
          <target state="translated">dnx <ph id="ph1">\[</ph>command](예: "dnx web")</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>N/A<ph id="ph1">\*</ph></source>
          <target state="translated">해당 없음<ph id="ph1">\*</ph></target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In DNX world, run a command as defined in the project.json.</source>
          <target state="translated">DNX 세계에서 project.json에 정의된 대로 명령을 실행합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>dnu install</source>
          <target state="translated">dnu install</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>N/A<ph id="ph1">\*</ph></source>
          <target state="translated">해당 없음<ph id="ph1">\*</ph></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>In the DNX world, install a package as a dependency.</source>
          <target state="translated">DNX 세계에서 종속성으로 패키지를 설치합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>dnu restore</source>
          <target state="translated">dnu restore</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>dotnet restore</source>
          <target state="translated">dotnet restore</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Restore dependencies specified in your project.json.</source>
          <target state="translated">Project.json에 지정된 종속성을 복원합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>dnu publish</source>
          <target state="translated">dnu publish</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>dotnet publish</source>
          <target state="translated">dotnet publish</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Publish your application for deployment in one of the three forms (portable, portable with native and standalone).</source>
          <target state="translated">배포할 응용 프로그램을 세 가지 형식(이식 가능, 이식 가능과 네이티브, 독립 실행형) 중 하나로 게시합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>dnu wrap</source>
          <target state="translated">dnu wrap</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>N/A<ph id="ph1">\*</ph></source>
          <target state="translated">해당 없음<ph id="ph1">\*</ph></target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>In DNX world, wrap a project.json in csproj.</source>
          <target state="translated">DNX 세계에서 csproj의 project.json을 래핑합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>dnu commands</source>
          <target state="translated">dnu commands</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>N/A<ph id="ph1">\*</ph></source>
          <target state="translated">해당 없음<ph id="ph1">\*</ph></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>In DNX world, manage the globally installed commands.</source>
          <target state="translated">DNX 세계에서 전역적으로 설치된 명령을 관리합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">\*</ph>) - these features are not supported in the CLI by design.</source>
          <target state="translated">(<ph id="ph1">\*</ph>) - 이 기능은 설계상 CLI에서 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>DNX features that are not supported</source>
          <target state="translated">지원되지 않는 DNX 기능</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>As the table above shows, there are features from the DNX world that we decided not to support in the CLI, at least for the time being.</source>
          <target state="translated">위의 표에서 알 수 있듯이, 적어도 당분간은 CLI에서 지원하지 않기로 한 DNX 세계의 기능이 있습니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>This section will go through the most important ones and outline the rationale behind not supporting them as well as workarounds if you do need them.</source>
          <target state="translated">이 섹션에서는 그러한 기능 중 가장 중요한 것을 살펴보고, 지원 중단 배후의 원리, 그리고 그러한 기능이 필요한 경우의 해결 방법을 간략하게 설명합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Global commands</source>
          <target state="translated">전역 명령</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>DNU came with a concept called "global commands".</source>
          <target state="translated">DNU는 "명령 전역"이라는 개념과 함께 제공되었습니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>These were, essentially, console applications packaged up as NuGet packages with a shell script that would invoke the DNX you specified to run the application.</source>
          <target state="translated">이는 응용 프로그램 실행을 위해 지정한 DNX를 호출하는 셸 스크립트와 함께 NuGet 패키지로 패키지된 콘솔 응용 프로그램이었습니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The CLI does not support this concept.</source>
          <target state="translated">CLI는 이 개념을 지원하지 않습니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>It does, however, support the concept of adding per-project commands that can be invoked using the familiar <ph id="ph1">`dotnet &lt;command&gt;`</ph> syntax.</source>
          <target state="translated">대신 친숙한 <ph id="ph1">`dotnet &lt;command&gt;`</ph> 구문을 사용하여 호출할 수 있는 프로젝트별 명령을 추가하는 개념을 지원합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>More about this can be found in the <bpt id="p1">[</bpt>extensibility overview<ept id="p1">](tools/index.md#extensibility)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>확장성 개요<ept id="p1">](tools/index.md#extensibility)</ept>에서 찾아볼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Installing dependencies</source>
          <target state="translated">종속성 설치</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>As of v1, the .NET Core CLI tools don't have an <ph id="ph1">`install`</ph> command for installing dependencies.</source>
          <target state="translated">v1부터 .NET Core CLI 도구에는 종속성 설치를 위한 <ph id="ph1">`install`</ph> 명령이 없습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>In order to install a package from NuGet, you would need to add it as a dependency to your <ph id="ph1">`project.json`</ph> file and then run <ph id="ph2">`dotnet restore`</ph>.</source>
          <target state="translated">NuGet에서 패키지를 설치하려면 이를 종속성으로 <ph id="ph1">`project.json`</ph> 파일에 추가한 후 <ph id="ph2">`dotnet restore`</ph>를 실행해야 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Running your code</source>
          <target state="translated">코드 실행</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>There are two main ways to run your code.</source>
          <target state="translated">코드를 실행하는 두 가지 중요한 방법이 있습니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>One is from source, with <ph id="ph1">`dotnet run`</ph>.</source>
          <target state="translated">하나는 소스에서 <ph id="ph1">`dotnet run`</ph>으로 실행하는 것입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Unlike <ph id="ph1">`dnx run`</ph>, this will not do any in-memory compilation.</source>
          <target state="translated"><ph id="ph1">`dnx run`</ph>과는 달리, 이 경우 메모리 내 컴파일을 수행하지 않습니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>It will actually invoke <ph id="ph1">`dotnet build`</ph> to build your code and then run the built binary.</source>
          <target state="translated">실제로 <ph id="ph1">`dotnet build`</ph>를 호출하여 코드를 빌드하고 빌드된 바이너리를 실행합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Another way is using the <ph id="ph1">`dotnet`</ph> itself to run your code.</source>
          <target state="translated">또 다른 방법은 <ph id="ph1">`dotnet`</ph> 자체를 사용하여 코드를 실행하는 것입니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>This is done by providing a path to your assembly: <ph id="ph1">`dotnet path/to/an/assembly.dll`</ph>.</source>
          <target state="translated">이는 어셈블리에 경로를 제공하여 수행됩니다(<ph id="ph1">`dotnet path/to/an/assembly.dll`</ph>).</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Migrating your DNX project to .NET Core CLI</source>
          <target state="translated">DNX 프로젝트를 .NET Core CLI로 마이그레이션</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>In addition to using new commands when working with your code, there are three major things left in migrating from DNX:</source>
          <target state="translated">코드로 작업할 때 새 명령을 사용하는 것 외에도 DNX에서 마이그레이션할 때 세 가지 중요한 사항이 남아 있습니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Migrate the <ph id="ph1">`global.json`</ph> file if you have it to be able to use CLI.</source>
          <target state="translated">CLI를 사용할 수 있도록 <ph id="ph1">`global.json`</ph> 파일을 마이그레이션합니다(있는 경우).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Migrating the project file (<ph id="ph1">`project.json`</ph>) itself to the CLI tooling.</source>
          <target state="translated">프로젝트 파일(<ph id="ph1">`project.json`</ph>) 자체를 CLI 도구로 마이그레이션합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Migrating off of any DNX APIs to their BCL counterparts.</source>
          <target state="translated">DNX API를 해당 BCL API로 마이그레이션합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Changing the global.json file</source>
          <target state="translated">Global.json 파일 변경</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`global.json`</ph> file acts like a solution file for both the RC1 and RC2 (or later) projects.</source>
          <target state="translated"><ph id="ph1">`global.json`</ph> 파일은 RC1 및 RC2(또는 그 이상) 프로젝트 모두에 대한 솔루션 파일 역할을 합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>In order for the CLI tools (as well as Visual Studio) to differentiate between RC1 and later versions, they use the <ph id="ph1">`"sdk": { "version" }`</ph> property to make the distinction which project is RC1 or later.</source>
          <target state="translated">Visual Studio는 물론 CLI 도구를 RC1 및 그 이후 버전과 차별화하기 위해, <ph id="ph1">`"sdk": { "version" }`</ph> 속성을 사용하여 프로젝트가 RC1인지 또는 그 이후 버전인지를 구분합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`global.json`</ph> doesn't have this node at all, it is assumed to be the latest.</source>
          <target state="translated"><ph id="ph1">`global.json`</ph>에 이 노드가 없는 경우 최신으로 간주됩니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>In order to update the <ph id="ph1">`global.json`</ph> file, either remove the property or set it to the exact version of the tools that you wish to use, in this case <bpt id="p1">**</bpt>1.0.0-preview2-003121<ept id="p1">**</ept>:</source>
          <target state="translated"><ph id="ph1">`global.json`</ph> 파일을 업데이트하려면 속성을 제거하거나 사용할 정확한 도구 버전으로 설정합니다(이 경우<bpt id="p1">**</bpt>1.0.0-preview2-003121<ept id="p1">**</ept>).</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Migrating the project file</source>
          <target state="translated">프로젝트 파일 마이그레이션</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The CLI and DNX both use the same basic project system based on <ph id="ph1">`project.json`</ph> file.</source>
          <target state="translated">CLI와 DNX는 둘 다 <ph id="ph1">`project.json`</ph> 파일 기반의 동일한 기본 프로젝트 시스템을 사용합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The syntax and the semantics of the project file are pretty much the same, with small differences based on the scenarios.</source>
          <target state="translated">프로젝트 파일의 구문 및 의미 체계는 시나리오에 따른 약간의 차이를 제외하면 상당 부분 동일합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>There are also some changes to the schema which you can see in the <bpt id="p1">[</bpt>schema file<ept id="p1">](http://json.schemastore.org/project)</ept> or in a more friendly <bpt id="p2">[</bpt>project.json reference<ept id="p2">](tools/project-json.md)</ept>.</source>
          <target state="translated">또한 <bpt id="p1">[</bpt>스키마 파일<ept id="p1">](http://json.schemastore.org/project)</ept> 또는 좀 더 친숙한 <bpt id="p2">[</bpt>project.json 참조<ept id="p2">](tools/project-json.md)</ept>에서 볼 수 있는 스키마에 대한 몇 가지 변경 사항이 있습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If you are building a console application, you need to add the following snippet to your project file:</source>
          <target state="translated">콘솔 응용 프로그램을 작성하는 경우 프로젝트 파일에 다음 조각을 추가해야 합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This instructs <ph id="ph1">`dotnet build`</ph> to emit an entry point for your application, effectively making your code runnable.</source>
          <target state="translated">이렇게 하면 <ph id="ph1">`dotnet build`</ph>는 응용 프로그램의 진입점을 내보내서 코드 실행이 효과적으로 수행되도록 합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>If you are building a class library, simply omit the above section.</source>
          <target state="translated">클래스 라이브러리를 빌드하는 경우 위 섹션을 생략하면 됩니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Of course, once you add the above snippet to your <ph id="ph1">`project.json`</ph> file, you need to add a static entry point.</source>
          <target state="translated">물론 위 코드 조각을 <ph id="ph1">`project.json`</ph> 파일에 추가한 후 정적 진입점을 추가해야 합니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>With the move off DNX, the DI services it provided are no longer available and thus this needs to be a basic .NET entry point: <ph id="ph1">`static void Main()`</ph>.</source>
          <target state="translated">DNX에서 나오면 DNX가 지원하는 DI를 더 이상 사용할 수 없으므로 <ph id="ph1">`static void Main()`</ph>이 기본 .NET 진입점이 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If you have a "commands" section in your <ph id="ph1">`project.json`</ph>, you can remove it.</source>
          <target state="translated"><ph id="ph1">`project.json`</ph>에 "commands" 섹션이 있는 경우 이를 제거할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Some of the commands that used to exist as DNU commands, such as Entity Framework CLI commands, are being ported to be per-project extensions to the CLI.</source>
          <target state="translated">DNU 명령으로 사용되었던 명령 중 일부(예: Entity Framework CLI 명령)는 CLI에 프로젝트별 확장으로 이식됩니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If you built your own commands that you are using in your projects, you need to replace them with CLI extensions.</source>
          <target state="translated">프로젝트에서 사용하는 명령을 빌드한 경우 이를 CLI 확장으로 교체해야 합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In this case, the <ph id="ph1">`commands`</ph> node in <ph id="ph2">`project.json`</ph> needs to be replaced by the <ph id="ph3">`tools`</ph> node and it needs to list the tools dependencies as explained in the <bpt id="p1">[</bpt>CLI extensibility section<ept id="p1">](tools/index.md#extensibility)</ept>.</source>
          <target state="translated">이 경우 <ph id="ph2">`project.json`</ph>의 <ph id="ph1">`commands`</ph> 노드를 <ph id="ph3">`tools`</ph> 노드로 교체하고, <bpt id="p1">[</bpt>CLI 확장성 섹션<ept id="p1">](tools/index.md#extensibility)</ept>에 설명된 대로 도구 종속성을 나열해야 합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>After these things are done, you need to decide which type of portability you wish for you app.</source>
          <target state="translated">이러한 작업이 완료되면 어떤 이식성 유형을 앱에 사용할지를 결정해야 합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>With .NET Core, we have invested into providing a spectrum of portability options that you can choose from.</source>
          <target state="translated">.NET Core에서는 선택 가능한 폭넓은 이식성 옵션이 제공됩니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>For instance, you may want to have a fully <bpt id="p1">*</bpt>portable<ept id="p1">*</ept> application or you may want to have a <bpt id="p2">*</bpt>self-contained<ept id="p2">*</ept> application.</source>
          <target state="translated">예를 들어 완전히 <bpt id="p1">*</bpt>이식 가능한<ept id="p1">*</ept> 응용 프로그램을 원할 수도 있고 <bpt id="p2">*</bpt>자체 포함<ept id="p2">*</ept> 응용 프로그램을 원할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The portable application option is more like .NET Framework applications work: it needs a shared component to execute it on the target machine (.NET Core).</source>
          <target state="translated">이식 가능한 응용 프로그램 옵션은 .NET Framework 응용 프로그램 작업과 유사하며, 대상 컴퓨터(.NET Core)에서 실행하기 위한 공유 구성 요소가 필요합니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The self-contained application doesn't require .NET Core to be installed on the target, but you have to produce one application for each OS you wish to support.</source>
          <target state="translated">자체 포함 응용 프로그램의 경우 .NET Core를 대상에 설치할 필요가 없지만, 지원할 각 OS에 대해 하나의 응용 프로그램을 생성해야 합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>These portability types and more are discussed in the <bpt id="p1"> [</bpt>application portability type<ept id="p1">](deploying/index.md)</ept> document.</source>
          <target state="translated">이러한 이식성 형식 등에 대해서는 <bpt id="p1"> [</bpt>응용 프로그램 이식성 유형<ept id="p1">](deploying/index.md)</ept> 문서에서 설명합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Once you make a call on what type of portability you want, you need to change your targeted framework(s).</source>
          <target state="translated">원하는 이식성 형식을 호출하면 대상 프레임워크를 변경해야 합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>If you were writing applications for .NET Core, you were most likely using <ph id="ph1">`dnxcore50`</ph> as  your targeted framework.</source>
          <target state="translated">.NET Core용 응용 프로그램을 작성한 경우 대상 프레임워크로 <ph id="ph1">`dnxcore50`</ph>을 사용할 가능성이 높습니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>With the CLI and the changes that the new <bpt id="p1">[</bpt>.NET Standard Library<ept id="p1">](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md)</ept> brought, the framework needs to be one of the following:</source>
          <target state="translated">새로운 <bpt id="p1">[</bpt>.NET 표준 라이브러리<ept id="p1">](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md)</ept>가 가져온 CLI 및 변경 사항과 함께 프레임워크는 다음 중 하나여야 합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`netcoreapp1.0`</ph> - if you are writing applications on .NET Core (including ASP.NET Core applications)</source>
          <target state="translated"><ph id="ph1">`netcoreapp1.0`</ph>- .NET Core에서 응용 프로그램을 작성하는 경우(ASP.NET Core 응용 프로그램 포함)</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`netstandard1.6`</ph> - if you are writing class libraries for .NET Core</source>
          <target state="translated"><ph id="ph1">`netstandard1.6`</ph>- .NET Core용 클래스 라이브러리를 작성하는 경우</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If you are using other <ph id="ph1">`dnx`</ph> targets, like <ph id="ph2">`dnx451`</ph> you will need to change those as well.</source>
          <target state="translated"><ph id="ph2">`dnx451`</ph> 같은 다른 <ph id="ph1">`dnx`</ph> 대상을 사용 중인 경우에도 역시 변경해야 합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dnx451`</ph> should be changed to <ph id="ph2">`net451`</ph>.</source>
          <target state="translated"><ph id="ph1">`dnx451`</ph>을<ph id="ph2">`net451`</ph> 로 변경해야 합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Please refer to the <bpt id="p1">[</bpt>.NET Standard Library document<ept id="p1">](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md)</ept> for more information.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>.NET 표준 라이브러리 문서<ept id="p1">](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Your <ph id="ph1">`project.json`</ph> is now mostly ready.</source>
          <target state="translated"><ph id="ph1">`project.json`</ph>이 거의 준비되었습니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>You need to go through your dependencies list and update the dependencies to their newer versions, especially if you are using ASP.NET Core dependencies.</source>
          <target state="translated">종속성 목록을 살펴보고, 특히 ASP.NET Core 종속성을 사용하는 경우 종속성을 새 버전으로 업데이트해야 합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>If you were using separate packages for BCL APIs, you can use the runtime package as explained in the <bpt id="p1">[</bpt>application portability type<ept id="p1">](deploying/index.md)</ept> document.</source>
          <target state="translated">별도의 BCL API용 패키지를 사용한 경우 <bpt id="p1">[</bpt>응용 프로그램 이식성 유형<ept id="p1">](deploying/index.md)</ept> 문서에 설명된 대로 런타임 패키지를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Once you are ready, you can try restoring with <ph id="ph1">`dotnet restore`</ph>.</source>
          <target state="translated">준비가 되면 <ph id="ph1">`dotnet restore`</ph>로 복원을 시도할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Depending on the version of your dependencies, you may encounter errors if NuGet cannot resolve the dependencies for one of the targeted frameworks above.</source>
          <target state="translated">종속성의 버전에 따라, NuGet이 위의 대상 프레임워크 중 하나에 대한 종속성을 확인할 수 없는 경우 오류가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>This is a "point-in-time" problem; as time progresses, more and more packages will include support for these frameworks.</source>
          <target state="translated">이는 "시점" 문제입니다. 시간이 지나면서 이러한 프레임워크를 지원하는 패키지가 점점 더 많아질 것입니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For now, if you run into this, you can use the <ph id="ph1">`imports`</ph> statement within the <ph id="ph2">`framework`</ph> node to specify to NuGet that it can restore the packages targeting the framework within the "imports" statement.</source>
          <target state="translated">지금은 <ph id="ph2">`framework`</ph> 노드 내에서 <ph id="ph1">`imports`</ph> 문을 사용하여, 프레임워크를 대상으로 하는 패키지를 복원할 수 있는 NuGet을 "imports" 문 내에 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The restoring errors you get in this case should provide enough information to tell you which frameworks you need to import.</source>
          <target state="translated">이 경우 표시되는 복원 오류는 어떤 프레임워크를 가져와야 하는지에 대한 충분한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>If you are slightly lost or new to this, in general, specifying <ph id="ph1">`dnxcore50`</ph> and <ph id="ph2">`portable-net45+win8`</ph> in the <ph id="ph3">`imports`</ph> statement should do the trick.</source>
          <target state="translated">잘 모르는 경우 일반적으로 <ph id="ph3">`imports`</ph> 문에서 <ph id="ph1">`dnxcore50`</ph> 및 <ph id="ph2">`portable-net45+win8`</ph>을 지정하면 도움이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The JSON snippet below shows how this looks like:</source>
          <target state="translated">다음의 JSON 코드 조각은 이를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Running <ph id="ph1">`dotnet build`</ph> will show any eventual build errors, though there shouldn't be too many of them.</source>
          <target state="translated"><ph id="ph1">`dotnet build`</ph>를 실행하면 너무 많지는 않더라도 궁극적인 빌드 오류가 표시됩니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>After your code is building and running properly, you can test it out with the runner.</source>
          <target state="translated">코드를 빌드하여 적절히 실행한 후에는 Runner로 테스트할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Execute <ph id="ph1">`dotnet &lt;path-to-your-assembly&gt;`</ph> and see it run.</source>
          <target state="translated"><ph id="ph1">`dotnet &lt;path-to-your-assembly&gt;`</ph>를 실행하고 살펴보세요.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>