<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cd47cc351fb926bcf444bdcbd12f3cd61d9fb327</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\quantifiers.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0d3de6defad05a55b446401dfe67d7fc72a1d417</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5afb8011ca24fab1d955719fd22a26c7f8a0645d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Quantifiers in regular expressions</source>
          <target state="translated">정규식의 수량자</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Quantifiers in regular expressions</source>
          <target state="translated">정규식의 수량자</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Quantifiers in regular expressions</source>
          <target state="translated">정규식의 수량자</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found.</source>
          <target state="translated">수량자는 찾을 일치 항목의 입력에 있어야 하는 문자, 그룹 또는 문자 클래스의 인스턴스 수를 지정합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The following table lists the quantifiers supported by .NET.</source>
          <target state="translated">다음 테이블에서는 .NET에서 지원하는 수량자를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Greedy quantifier</source>
          <target state="translated">탐욕적 수량자</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Lazy quantifier</source>
          <target state="translated">게으른 수량자</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt><ph id="ph1">\*</ph>?<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">\*</ph>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Match zero or more times.</source>
          <target state="translated">0번 이상 일치합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>+?<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>+?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Match one or more times.</source>
          <target state="translated">1번 이상 일치합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>?<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>??<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>??<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Match zero or one time.</source>
          <target state="translated">0번 또는&amp;1;번 일치합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}?<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}?<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Match exactly n times.</source>
          <target state="translated">정확히 n번 일치합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}?<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}?<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Match at least n times.</source>
          <target state="translated">적어도 n번 일치합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,<ept id="p3">**</ept><bpt id="p4">_</bpt>m<ept id="p4">_</ept><bpt id="p5">**</bpt>}<ept id="p5">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,<ept id="p3">**</ept><bpt id="p4">_</bpt>m<ept id="p4">_</ept><bpt id="p5">**</bpt>}<ept id="p5">**</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,<ept id="p3">**</ept><bpt id="p4">_</bpt>m<ept id="p4">_</ept><bpt id="p5">**</bpt>}?<ept id="p5">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,<ept id="p3">**</ept><bpt id="p4">_</bpt>m<ept id="p4">_</ept><bpt id="p5">**</bpt>}?<ept id="p5">**</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Match from n to m times.</source>
          <target state="translated">n번에서 m번까지 일치합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The quantities <bpt id="p1">*</bpt>n<ept id="p1">*</ept> and <bpt id="p2">*</bpt>m<ept id="p2">*</ept> are integer constants.</source>
          <target state="translated">수량 <bpt id="p1">*</bpt>n<ept id="p1">*</ept> 및 <bpt id="p2">*</bpt>m<ept id="p2">*</ept>은 정수 상수입니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Ordinarily, quantifiers are greedy; they cause the regular expression engine to match as many occurrences of particular patterns as possible.</source>
          <target state="translated">일반적으로 수량자는 탐욕적입니다. 그러면 최대한의 정규식 엔진이 특정 패턴과 일치하게 됩니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Appending the <ph id="ph1">`?`</ph> character to a quantifier makes it lazy; it causes the regular expression engine to match as few occurrences as possible.</source>
          <target state="translated"><ph id="ph1">`?`</ph> 문자를 수량자에 추가하면 게으른 수량자로 만들 수 있습니다. 그러면 최소한의 정규식 엔진이 일치하게 됩니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For a complete description of the difference between greedy and lazy quantifiers, see the section <bpt id="p1">[</bpt>Greedy and lazy quantifiers<ept id="p1">](#greedy-and-lazy-quantifiers)</ept> later in this topic.</source>
          <target state="translated">탐욕적 수량자와 게으른 수량자 간의 차이에 대한 설명은 이 항목의 뒷부분에 나오는 <bpt id="p1">[</bpt>탐욕적 및 게으른 수량자<ept id="p1">](#greedy-and-lazy-quantifiers)</ept> 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Nesting quantifiers (for example, as the regular expression pattern <ph id="ph1">`(a*)*`</ph> does) can increase the number of comparisons that the regular expression engine must perform, as an exponential function of the number of characters in the input string.</source>
          <target state="translated">예를 들어, 정규식 패턴 <ph id="ph1">`(a*)*`</ph>과 같이 수량자가 중첩되면 정규식 엔진이 입력 문자열에 있는 문자 수의 지 수 함수로 수행해야 하는 비교의 수를 증가시킬 수 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For more information about this behavior and its workarounds, see <bpt id="p1">[</bpt>Backtracking in regular expressions<ept id="p1">](backtracking.md)</ept>.</source>
          <target state="translated">이 동작 및 해결 방법에 대한 자세한 내용은 <bpt id="p1">[</bpt>정규식의 역추적<ept id="p1">](backtracking.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Regular expression quantifiers</source>
          <target state="translated">정규식 수량자</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The following sections list the quantifiers supported by .NET regular expressions.</source>
          <target state="translated">다음 섹션에는 .NET의 정규식에서 지원하는 수량자를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">\*</ph>, +, ?, {, and } characters are encountered in a regular expression pattern, the regular expression engine interprets them as quantifiers or part of quantifier constructs unless they are included in a <bpt id="p1">[</bpt>character class<ept id="p1">](classes.md)</ept>.</source>
          <target state="translated"><ph id="ph1">\*</ph>, +, ?, { 및 } 문자가 정규식 패턴에 나타난 경우 <bpt id="p1">[</bpt>문자 클래스<ept id="p1">](classes.md)</ept>에 포함된 경우가 아니면 정규식 엔진은 수량자 또는 수량자 구조의 일부로 해석합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To interpret these as literal characters outside a character class, you must escape them by preceding them with a backslash.</source>
          <target state="translated">이를 문자 클래스 외부의 리터럴 문자로 해석하려면 앞에 백슬래시를 추가하여 이스케이프해야 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, the string <ph id="ph1">`\*`</ph> in a regular expression pattern is interpreted as a literal asterisk ("*") character.</source>
          <target state="translated">예를 들어 정규식 패턴의 <ph id="ph1">`\*`</ph> 문자열은 리터럴 별표("*") 문자로 해석됩니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Match zero or more times: <ph id="ph1">\*</ph></source>
          <target state="translated">0번 이상 일치: <ph id="ph1">\*</ph></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">\*</ph> quantifier matches the preceding element zero or more times.</source>
          <target state="translated"><ph id="ph1">\*</ph> 수량자는 이전 요소를&amp;0;번 이상 일치시킵니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>It is equivalent to the <bpt id="p1">**</bpt>{0,}<ept id="p1">**</ept> quantifier.</source>
          <target state="translated"><bpt id="p1">**</bpt>{0,}<ept id="p1">**</ept> 수량자와 같습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt><ph id="ph1">\*</ph><ept id="p1">**</ept> is a greedy quantifier whose lazy equivalent is <bpt id="p2">**</bpt><ph id="ph2">\*</ph>?<ept id="p2">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">\*</ph><ept id="p1">**</ept>는 게으른 수량자가 <bpt id="p2">**</bpt><ph id="ph2">\*</ph>?<ept id="p2">**</ept>인 탐욕적 수량자입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The following example illustrates this regular expression.</source>
          <target state="translated">다음 예제에서는 이 정규식을 설명합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Of the nine digits in the input string, five match the pattern and four (<ph id="ph1">`95`</ph>, <ph id="ph2">`929`</ph>, <ph id="ph3">`9129`</ph>, and <ph id="ph4">`9919`</ph>) do not.</source>
          <target state="translated">입력 문자열에서&amp;9;자리 숫자 중에&amp;5;개는 패턴과 일치하고&amp;4;개(<ph id="ph1">`95`</ph>, <ph id="ph2">`929`</ph>, <ph id="ph3">`9129`</ph> 및 <ph id="ph4">`9919`</ph>)는 일치하지 않습니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">단어 경계를 시작합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Match a "9" followed by zero or more "1" characters.</source>
          <target state="translated">뒤에&amp;0;개 이상의 "1" 문자가 있는 "9"를 찾습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Match zero or more "9" characters.</source>
          <target state="translated">0개 이상의 "9" 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>End at a word boundary.</source>
          <target state="translated">단어 경계를 종료합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Match one or more times: +</source>
          <target state="translated">1번 이상 일치: +</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">+</ph><ept id="p1">**</ept> quantifier matches the preceding element one or more times.</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">+</ph><ept id="p1">**</ept> 수량자는 이전 요소를&amp;1;번 이상 일치시킵니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>It is equivalent to <bpt id="p1">**</bpt>{1,}<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>{1,}<ept id="p1">**</ept>과 같습니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt><ph id="ph1">+</ph><ept id="p1">**</ept> is a greedy quantifier whose lazy equivalent is <bpt id="p2">**</bpt>+?<ept id="p2">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">+</ph><ept id="p1">**</ept>은 게으른 수량자가 <bpt id="p2">**</bpt>+?<ept id="p2">**</ept>인 탐욕적 수량자입니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\ban+\w*?\b`</ph> tries to match entire words that begin with the letter <ph id="ph2">`a`</ph> followed by one or more instances of the letter <ph id="ph3">`n`</ph>.</source>
          <target state="translated">예를 들어, 정규식 <ph id="ph1">`\ban+\w*?\b`</ph>은 <ph id="ph3">`n`</ph> 문자의 인스턴스가 하나 이상 뒤에 오는 <ph id="ph2">`a`</ph> 문자로 시작하는 전체 단어를 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The following example illustrates this regular expression.</source>
          <target state="translated">다음 예제에서는 이 정규식을 설명합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The regular expression matches the words <ph id="ph1">`an`</ph>, <ph id="ph2">`annual`</ph>, <ph id="ph3">`announcement`</ph>, and <ph id="ph4">`antique`</ph>, and correctly fails to match <ph id="ph5">`autumn`</ph> and <ph id="ph6">`all`</ph>.</source>
          <target state="translated">정규식은 <ph id="ph1">`an`</ph>, <ph id="ph2">`annual`</ph>, <ph id="ph3">`announcement`</ph> 및 <ph id="ph4">`antique`</ph> 단어를 찾며 <ph id="ph5">`autumn`</ph> 및 <ph id="ph6">`all`</ph> 단어를 찾는 데 실패합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">단어 경계를 시작합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Match an "a" followed by one or more "n" characters.</source>
          <target state="translated">뒤에 하나 이상의 "n" 문자가 있는 "a"를 찾습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Match a word character zero or more times, but as few times as possible.</source>
          <target state="translated">단어 문자와&amp;0;번 이상의 일치하지만 가능한 적은 수로 일치합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>End at a word boundary.</source>
          <target state="translated">단어 경계를 종료합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Match zero or one time: ?</source>
          <target state="translated">0번 또는&amp;1;번 일치: ?</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>?<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>quantifier matches the preceding element zero or one time.</source>
          <target state="translated">수량자는 이전 요소를&amp;0;번 또는&amp;1;번 일치시킵니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>It is equivalent to <bpt id="p1">**</bpt>{0,1}<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>{0,1}<ept id="p1">**</ept>과 같습니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>?<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>is a greedy quantifier whose lazy equivalent is <bpt id="p1">**</bpt>??<ept id="p1">**</ept>.</source>
          <target state="translated">은 게으른 수량자가 <bpt id="p1">**</bpt>??<ept id="p1">**</ept>인 탐욕적 수량자입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\ban?\b`</ph> tries to match entire words that begin with the letter <ph id="ph2">`a`</ph> followed by zero or one instances of the letter <ph id="ph3">`n`</ph>.</source>
          <target state="translated">예를 들어, 정규식 <ph id="ph1">`\ban?\b`</ph>은 <ph id="ph3">`n`</ph> 문자의 인스턴스가&amp;0;개 또는&amp;1;개 뒤에 오는 <ph id="ph2">`a`</ph> 문자로 시작하는 전체 단어를 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In other words, it tries to match the words <ph id="ph1">`a`</ph> and <ph id="ph2">`an`</ph>.</source>
          <target state="translated">즉, 단어 <ph id="ph1">`a`</ph> 및 <ph id="ph2">`an`</ph>를 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following example illustrates this regular expression.</source>
          <target state="translated">다음 예제에서는 이 정규식을 설명합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">단어 경계를 시작합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Match an "a" followed by zero or one "n" character.</source>
          <target state="translated">뒤에&amp;0;개 또는&amp;1;개의 "n" 문자가 있는 "a"를 찾습니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>End at a word boundary.</source>
          <target state="translated">단어 경계를 종료합니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Match exactly n times: {n}</source>
          <target state="translated">정확히 n번 일치: {n}</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> quantifier matches the preceding element exactly <bpt id="p4">*</bpt>n<ept id="p4">*</ept> times, where <bpt id="p5">*</bpt>n<ept id="p5">*</ept> is any integer.</source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> 수량자는 정확하게 <bpt id="p4">*</bpt>n<ept id="p4">*</ept>번 이전 요소와 일치하며 여기서 <bpt id="p5">*</bpt>n<ept id="p5">*</ept>은 정수입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> is a greedy quantifier whose lazy equivalent is <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>}?<ept id="p6">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>은 게으른 수량자가 <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>}?<ept id="p6">**</ept>인 탐욕적 수량자입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b\d+\,\d{3}\b`</ph> tries to match a word boundary followed by one or more decimal digits followed by three decimal digits followed by a word boundary.</source>
          <target state="translated">예를 들어, 정규식 <ph id="ph1">`\b\d+\,\d{3}\b`</ph>는 뒤에 하나 이상의&amp;10;진수 숫자, 세 개의&amp;10;진수 숫자와 단어 경계가 있는 단어 경계를 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following example illustrates this regular expression.</source>
          <target state="translated">다음 예제에서는 이 정규식을 설명합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">단어 경계를 시작합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
          <target state="translated">하나 이상의&amp;10;진수 숫자가 일치하는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Match a comma character.</source>
          <target state="translated">쉼표 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Match three decimal digits.</source>
          <target state="translated">세 개의&amp;10;진수를 찾습니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>End at a word boundary.</source>
          <target state="translated">단어 경계를 종료합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Match at least n times: {n,}</source>
          <target state="translated">적어도 n번 일치: {n,}</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}<ept id="p3">**</ept> quantifier matches the preceding element at least <bpt id="p4">*</bpt>n<ept id="p4">*</ept> times, where <bpt id="p5">*</bpt>n<ept id="p5">*</ept> is any integer.</source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> 수량자는 적어도 <bpt id="p4">*</bpt>n<ept id="p4">*</ept>번 이전 요소와 일치하며 여기서 <bpt id="p5">*</bpt>n<ept id="p5">*</ept>은 정수입니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}<ept id="p3">**</ept> is a greedy quantifier whose lazy equivalent is <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>}?<ept id="p6">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}<ept id="p3">**</ept>은 게으른 수량자가 <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>}?<ept id="p6">**</ept>인 탐욕적 수량자입니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b\d{2,}\b\D+`</ph> tries to match a word boundary followed by at least two digits followed by a word boundary and a non-digit character.</source>
          <target state="translated">예를 들어, 정규식 <ph id="ph1">`\b\d{2,}\b\D+`</ph>는 뒤에 적어도 두 개의 숫자, 단어 경계와 숫자가 아닌 문자가 있는 단어 경계를 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following example illustrates this regular expression.</source>
          <target state="translated">다음 예제에서는 이 정규식을 설명합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The regular expression fails to match the phrase "7 days" because it contains just one decimal digit, but it successfully matches the phrases "10 weeks and 300 years".</source>
          <target state="translated">정규식은 "7일"이라는 구를 찾는 데 실패합니다. 하나의 숫자를 포함하지만 "10주 및 300년"이라는 구와 일치하기 때문입니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">단어 경계를 시작합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Match at least two decimal digits.</source>
          <target state="translated">적어도 두 개의&amp;10;진수를 찾습니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Match a word boundary.</source>
          <target state="translated">단어 경계를 찾습니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Match at least one non-decimal digit.</source>
          <target state="translated">적어도 하나의&amp;10;진수가 아닌 수를 찾습니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Match between n and m times: {n,m}</source>
          <target state="translated">n번에서 m번 사이에 일치: {n, m}</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,<ept id="p3">**</ept><bpt id="p4">_</bpt>m<ept id="p4">_</ept><bpt id="p5">**</bpt>}<ept id="p5">**</ept> quantifier matches the preceding element at least <bpt id="p6">*</bpt>n<ept id="p6">*</ept> times, but no more than <bpt id="p7">*</bpt>m<ept id="p7">*</ept> times, where <bpt id="p8">*</bpt>n<ept id="p8">*</ept> and <bpt id="p9">*</bpt>m<ept id="p9">*</ept> are integers.</source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,<ept id="p3">**</ept><bpt id="p4">_</bpt>m<ept id="p4">_</ept><bpt id="p5">**</bpt>}<ept id="p5">**</ept> 수량자는 이전 요소와 적어도 <bpt id="p6">*</bpt>n<ept id="p6">*</ept>번 일치하지만 <bpt id="p7">*</bpt>m<ept id="p7">*</ept>번보다 많지 않습니다. 여기서 <bpt id="p8">*</bpt>n<ept id="p8">*</ept> 및 <bpt id="p9">*</bpt>m<ept id="p9">*</ept>은 정수입니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,<ept id="p3">**</ept><bpt id="p4">_</bpt>m<ept id="p4">_</ept><bpt id="p5">**</bpt>}<ept id="p5">**</ept> is a greedy quantifier whose lazy equivalent is <bpt id="p6">**</bpt>{<ept id="p6">**</ept><bpt id="p7">_</bpt>n<ept id="p7">_</ept><bpt id="p8">**</bpt>,<ept id="p8">**</ept><bpt id="p9">_</bpt>m<ept id="p9">_</ept><bpt id="p10">**</bpt>}?<ept id="p10">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,<ept id="p3">**</ept><bpt id="p4">_</bpt>m<ept id="p4">_</ept><bpt id="p5">**</bpt>}<ept id="p5">**</ept>은 게으른 수량자가 <bpt id="p6">**</bpt>{<ept id="p6">**</ept><bpt id="p7">_</bpt>n<ept id="p7">_</ept><bpt id="p8">**</bpt>,<ept id="p8">**</ept><bpt id="p9">_</bpt>m<ept id="p9">_</ept><bpt id="p10">**</bpt>}?<ept id="p10">**</ept>인 탐욕적 수량자입니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression <ph id="ph1">`(00\s){2,4}`</ph> tries to match between two and four occurrences of two zero digits followed by a space.</source>
          <target state="translated">다음 예제에서 정규식 <ph id="ph1">`(00\s){2,4}`</ph>은 뒤에 공백이 있는 두 개의 숫자&amp;0;이&amp;2;회에서&amp;4;회 사이에 발생하는 경우를 찾습니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Note that the final portion of the input string includes this pattern five times rather than the maximum of four.</source>
          <target state="translated">입력 문자열의 마지막 부분에는 이 패턴이&amp;5;번이나 포함됩니다(최대&amp;4;번 아님).</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>However, only the initial portion of this substring (up to the space and the fifth pair of zeros) matches the regular expression pattern.</source>
          <target state="translated">그러나 공백 및&amp;0;의 다섯 번째 쌍까지의 하위 문자열의 처음 부분만이 정규식 패턴과 일치합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Match zero or more times (lazy match): <ph id="ph1">\*</ph>?</source>
          <target state="translated">0번 이상 일치(게으른 일치 항목): <ph id="ph1">\*</ph>?</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">\*</ph>?<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">\*</ph>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>quantifier matches the preceding element zero or more times, but as few times as possible.</source>
          <target state="translated">수량자는 이 요소와&amp;0;번 이상 일치하지만 가능한 적은 수로 일치합니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>It is the lazy counterpart of the greedy quantifier <bpt id="p1">**</bpt><ph id="ph1">\*</ph><ept id="p1">**</ept>.</source>
          <target state="translated">탐욕적 수량자 <bpt id="p1">**</bpt><ph id="ph1">\*</ph><ept id="p1">**</ept>의 게으른 수량자입니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression <ph id="ph1">`\b\w*?oo\w*?\b`</ph> matches all words that contain the string <ph id="ph2">`oo`</ph>.</source>
          <target state="translated">다음 예제에서 정규식 <ph id="ph1">`\b\w*?oo\w*?\b`</ph>은 문자열 <ph id="ph2">`oo`</ph>이 포함된 모든 단어를 찾습니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">단어 경계를 시작합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters, but as few characters as possible.</source>
          <target state="translated">0개 이상의 단어 문자(가능한 한 적은 문자)를 찾습니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Match the string "oo".</source>
          <target state="translated">"oo" 문자열을 찾습니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters, but as few characters as possible.</source>
          <target state="translated">0개 이상의 단어 문자(가능한 한 적은 문자)를 찾습니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>End on a word boundary.</source>
          <target state="translated">단어 경계를 종료합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Match one or more times (lazy match): +?</source>
          <target state="translated">0번 이상 일치(게으른 일치 항목): +?</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>+?<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>+?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>quantifier matches the preceding element one or more times, but as few times as possible.</source>
          <target state="translated">수량자는 이 요소와&amp;1;번 이상 일치하지만 가능한 적은 수로 일치합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>It is the lazy counterpart of the greedy quantifier <bpt id="p1">**</bpt><ph id="ph1">+</ph><ept id="p1">**</ept>.</source>
          <target state="translated">탐욕적 수량자 <bpt id="p1">**</bpt><ph id="ph1">+</ph><ept id="p1">**</ept>의 게으른 수량자입니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b\w+?\b`</ph> matches one or more characters separated by word boundaries.</source>
          <target state="translated">예를 들어, 정규식 <ph id="ph1">`\b\w+?\b`</ph>은 단어 경계로 구분된&amp;1;개 이상의 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The following example illustrates this regular expression.</source>
          <target state="translated">다음 예제에서는 이 정규식을 설명합니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Match zero or one time (lazy match): ??</source>
          <target state="translated">0번 또는&amp;1;번 일치(게으른 일치): ??</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>??<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>??<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>quantifier matches the preceding element zero or one time, but as few times as possible.</source>
          <target state="translated">수량자는 이 요소와&amp;0;번 또는&amp;2;번 일치하지만 가능한 적은 수로 일치합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>It is the lazy counterpart of the greedy quantifier <bpt id="p1">**</bpt>?<ept id="p1">**</ept>.</source>
          <target state="translated">탐욕적 수량자 <bpt id="p1">**</bpt>?<ept id="p1">**</ept>의 게으른 수량자입니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`^\s*(System.)??Console.Write(Line)??\(??`</ph> attempts to match the strings "Console.Write" or "Console.WriteLine".</source>
          <target state="translated">예를 들어, 정규식 <ph id="ph1">`^\s*(System.)??Console.Write(Line)??\(??`</ph>은 "Console.Write" 또는 "Console.WriteLine" 문자열을 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The string can also include "System."</source>
          <target state="translated">문자열은 "Console" 앞에 "System."을 포함할 수도 있고</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>before "Console", and it can be followed by an opening parenthesis.</source>
          <target state="translated">문자열 뒤에 여는 괄호가 있을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The string must be at the beginning of a line, although it can be preceded by white space.</source>
          <target state="translated">문자열 앞에는 공백이 있을 수 있지만 줄의 시작 부분에 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The following example illustrates this regular expression.</source>
          <target state="translated">다음 예제에서는 이 정규식을 설명합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Match the start of the input stream.</source>
          <target state="translated">입력 스트림의 시작 부분을 찾습니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">0개 이상의 공백 문자가 일치하는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of the string "System.".</source>
          <target state="translated">"System."이라는&amp;0;개 또는&amp;1;개의 문자열을 찾습니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Match the string "Console.Write".</source>
          <target state="translated">"Console.Write"라는 문자열을 찾습니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of the string "Line".</source>
          <target state="translated">"Line"이라는&amp;0;개 또는&amp;1;개의 문자열을 찾습니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of the opening parenthesis.</source>
          <target state="translated">0개 또는&amp;1;개의 여는 괄호를 찾습니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Match exactly n times (lazy match): {n}?</source>
          <target state="translated">정확히 n번 일치(게으른 일치): {n}?</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}?<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}?<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>quantifier matches the preceding element exactly <bpt id="p1">*</bpt>n<ept id="p1">*</ept> times, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is any integer.</source>
          <target state="translated">수량자는 정확하게 <bpt id="p1">*</bpt>n<ept id="p1">*</ept>번 이전 요소와 일치하며 여기서 <bpt id="p2">*</bpt>n<ept id="p2">*</ept>은 정수입니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>It is the lazy counterpart of the greedy quantifier <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}+<ept id="p3">**</ept>.</source>
          <target state="translated">탐욕적 수량자 <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}+<ept id="p3">**</ept>의 게으른 수량자입니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression <ph id="ph1">`\b(\w{3,}?\.){2}?\w{3,}?\b`</ph> is used to identify a Web site address.</source>
          <target state="translated">다음 예제에서 정규식 <ph id="ph1">`\b(\w{3,}?\.){2}?\w{3,}?\b`</ph>은 웹 사이트 주소를 식별하는 데 사용됩니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Note that it matches "www.microsoft.com" and "msdn.microsoft.com", but does not match "mywebsite" or "mycompany.com".</source>
          <target state="translated">"www.microsoft.com" 및 "msdn.microsoft.com"과 일치하지만 "mywebsite" 또는 "mycompany.com"과 일치하지 않습니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">단어 경계를 시작합니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Match at least 3 word characters, but as few characters as possible, followed by a dot or period character.</source>
          <target state="translated">뒤에 점 또는 마침표 문자가 있는 가능한 적은 수의 최소한 3개의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">이 그룹은 첫 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Match the pattern in the first group two times, but as few times as possible.</source>
          <target state="translated">첫 번째 그룹의 패턴과 두 번 일치하지만 가능한 적은 수로 일치합니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>End the match on a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Match at least n times (lazy match): {n,}?</source>
          <target state="translated">적어도 n번 일치(게으른 일치): {n,}?</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}?<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}?<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>quantifier matches the preceding element at least <bpt id="p1">*</bpt>n<ept id="p1">*</ept> times, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is any integer, but as few times as possible.</source>
          <target state="translated">수량자는 이전 요소와 적어도 <bpt id="p1">*</bpt>n<ept id="p1">*</ept>번 일치하며 여기서 <bpt id="p2">*</bpt>n<ept id="p2">*</ept>은 정수입니다. 가능한 적은 수로 일치합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>It is the lazy counterpart of the greedy quantifier <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}<ept id="p3">**</ept>.</source>
          <target state="translated">탐욕적 수량자 <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}<ept id="p3">**</ept>의 게으른 수량자입니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>See the example for the <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}?<ept id="p3">**</ept></source>
          <target state="translated">설명은 이전 섹션에서 <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}?<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>quantifier in the previous section for an illustration.</source>
          <target state="translated">수량자에 대한 예제를 참조하세요.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The regular expression in that example uses the <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}<ept id="p3">**</ept> quantifier to match a string that has at least three characters followed by a period.</source>
          <target state="translated">해당 예제에서 정규식은 <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,}<ept id="p3">**</ept> 수량자를 사용하여 뒤에 마침표가 있는 적어도&amp;3;개의 문자가 있는 문자열을 찾습니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Match between n and m times (lazy match): {n,m}?</source>
          <target state="translated">n번에서 m번 사이에 일치(게으른 일치): {n,m}?</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,<ept id="p3">**</ept><bpt id="p4">_</bpt>m<ept id="p4">_</ept><bpt id="p5">**</bpt>}?<ept id="p5">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,<ept id="p3">**</ept><bpt id="p4">_</bpt>m<ept id="p4">_</ept><bpt id="p5">**</bpt>}?<ept id="p5">**</ept></target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>quantifier matches the preceding element between <bpt id="p1">*</bpt>n<ept id="p1">*</ept> and <bpt id="p2">*</bpt>m<ept id="p2">*</ept> times, where <bpt id="p3">*</bpt>n<ept id="p3">*</ept> and <bpt id="p4">*</bpt>m<ept id="p4">*</ept> are integers, but as few times as possible.</source>
          <target state="translated">수량자는 이전 요소와 <bpt id="p1">*</bpt>n<ept id="p1">*</ept>번에서 <bpt id="p2">*</bpt>m<ept id="p2">*</ept>번 사이에 일치합니다. 여기서 <bpt id="p3">*</bpt>n<ept id="p3">*</ept> 및 <bpt id="p4">*</bpt>m<ept id="p4">*</ept>은 정수이며 가능한 적은 수로 일치합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>It is the lazy counterpart of the greedy quantifier <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,<ept id="p3">**</ept><bpt id="p4">_</bpt>m<ept id="p4">_</ept><bpt id="p5">**</bpt>}<ept id="p5">**</ept>.</source>
          <target state="translated">탐욕적 수량자 <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>,<ept id="p3">**</ept><bpt id="p4">_</bpt>m<ept id="p4">_</ept><bpt id="p5">**</bpt>}<ept id="p5">**</ept>의 게으른 수량자입니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression <ph id="ph1">`\b[A-Z](\w*\s+){1,10}?[.!?]`</ph> matches sentences that contain between one and ten words.</source>
          <target state="translated">다음 예제에서 정규식 <ph id="ph1">`\b[A-Z](\w*\s+){1,10}?[.!?]`</ph>은 하나에서 열 개 단어 사이를 포함하는 문장을 찾습니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>It matches all the sentences in the input string except for one sentence that contains 18 words.</source>
          <target state="translated">18개의 단어가 포함된 한 문장을 제외하고 입력 문자열에 있는 모든 문장을 찾습니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">단어 경계를 시작합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Match an uppercase character from A to Z.</source>
          <target state="translated">A-Z의 대문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters, followed by one or more white-space characters.</source>
          <target state="translated">뒤에&amp;1;개 이상의 공백 문자가 있는&amp;0;개 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>This is the first capture group.</source>
          <target state="translated">이 그룹은 첫 번째 캡처 그룹입니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Match the previous pattern between 1 and 10 times, but as few times as possible.</source>
          <target state="translated">이전 패턴과 1번에서 10번 사이에 일치하지만 가능한 적은 수로 일치합니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Match any one of the punctuation characters ".", "!", or "?".</source>
          <target state="translated">문장 부호 문자 ".", "!" 또는 "?" 중 하나를 찾습니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Greedy and lazy quantifiers</source>
          <target state="translated">탐욕적 및 게으른 수량자</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>A number of the quantifiers have two versions:</source>
          <target state="translated">여러 수량자에는 두 가지 버전이 있습니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>A greedy version.</source>
          <target state="translated">탐욕적 버전</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>A greedy quantifier tries to match an element as many times as possible.</source>
          <target state="translated">탐욕적 수량자는 요소를 최대한 많이 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>•A non-greedy (or lazy) version.</source>
          <target state="translated">•탐욕적이 아닌(또는 게으른) 버전</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>A non-greedy quantifier tries to match an element as few times as possible.</source>
          <target state="translated">탐욕적이 아닌 수량자는 요소를 최대한 적게 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>You can turn a greedy quantifier into a lazy quantifier by simply adding a <bpt id="p1">**</bpt>?<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>?<ept id="p1">**</ept>를 추가하기만 하면 탐욕적 수량자를 게으른 수량자로 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Consider a simple regular expression that is intended to extract the last four digits from a string of numbers such as a credit card number.</source>
          <target state="translated">신용 카드 번호와 같은 숫자 문자열에서 마지막&amp;4;자리를 추출하기 위한 간단한 정규식을 사용합니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The version of the regular expression that uses the <bpt id="p1">**</bpt><ph id="ph1">\*</ph><ept id="p1">**</ept> greedy quantifier is <ph id="ph2">`\b.*([0-9]{4})\b`</ph>.</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">\*</ph><ept id="p1">**</ept> 탐욕적 수량자를 사용하는 정규식의 버전은 <ph id="ph2">`\b.*([0-9]{4})\b`</ph>입니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>However, if a string contains two numbers, this regular expression matches the last four digits of the second number only, as the following example shows.</source>
          <target state="translated">그러나 문자열이 두 개의 숫자를 포함하는 경우 다음 예제와 같이 정규식은 두 번째 숫자의 마지막&amp;4;자리가 일치합니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The regular expression fails to match the first number because the <bpt id="p1">**</bpt><ph id="ph1">\*</ph><ept id="p1">**</ept> quantifier tries to match the previous element as many times as possible in the entire string, and so it finds its match at the end of the string.</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">\*</ph><ept id="p1">**</ept> 수량자가 문자열의 끝에서 일치 항목을 찾도록 전체 문자열에서 최대한 많은 이전 요소를 일치시키기 때문에 정규식은 첫 번째 숫자를 찾는 데 실패합니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>This is not the desired behavior.</source>
          <target state="translated">이러한 동작이 발생하지 않아야 합니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Instead, you can use the <bpt id="p1">**</bpt><ph id="ph1">\*</ph>?<ept id="p1">**</ept></source>
          <target state="translated">대신 다음 예제와 같이 <bpt id="p1">**</bpt><ph id="ph1">\*</ph>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>lazy quantifier to extract digits from both numbers, as the following example shows.</source>
          <target state="translated">최소 일치 수량자를 사용하여 두 번호에서 숫자를 추출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>In most cases, regular expressions with greedy and lazy quantifiers return the same matches.</source>
          <target state="translated">대부분의 경우 탐욕적 및 게으른 수량자를 포함하는 정규식은 동일한 일치 항목을 반환합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>They most commonly return different results when they are used with the wildcard (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) metacharacter, which matches any character.</source>
          <target state="translated">와일드 카드(<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) 메타문자를 사용할 경우 가장 일반적으로 다른 결과를 반환하며 모든 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Quantifiers and empty matches</source>
          <target state="translated">수량자 및 빈 일치 항목</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The quantifiers <bpt id="p1">**</bpt><ph id="ph1">\*</ph><ept id="p1">**</ept>, <bpt id="p2">**</bpt><ph id="ph2">+</ph><ept id="p2">**</ept>, and <bpt id="p3">**</bpt>{<ept id="p3">**</ept><bpt id="p4">_</bpt>n<ept id="p4">_</ept><bpt id="p5">**</bpt>,<ept id="p5">**</ept><bpt id="p6">_</bpt>m<ept id="p6">_</ept><bpt id="p7">**</bpt>}<ept id="p7">**</ept> and their lazy counterparts never repeat after an empty match when the minimum number of captures has been found.</source>
          <target state="translated">수량자 <bpt id="p1">**</bpt><ph id="ph1">\*</ph><ept id="p1">**</ept>, <bpt id="p2">**</bpt><ph id="ph2">+</ph><ept id="p2">**</ept> 및 <bpt id="p3">**</bpt>{<ept id="p3">**</ept><bpt id="p4">_</bpt>n<ept id="p4">_</ept><bpt id="p5">**</bpt>,<ept id="p5">**</ept><bpt id="p6">_</bpt>m<ept id="p6">_</ept><bpt id="p7">**</bpt>}<ept id="p7">**</ept>과 해당 게으른 수량자는 최소한의 캡처 수를 찾는 경우 빈 일치 항목 후에 반복되지 않습니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>This rule prevents quantifiers from entering infinite loops on empty subexpression matches when the maximum number of possible group captures is infinite or near infinite.</source>
          <target state="translated">가능한 그룹 캡처의 최대 수가 무한 또는 거의 무한인 경우 이 규칙은 수량자가 빈 하위 식을 찾기 위해 무한 루프를 입력하지 않도록 방지합니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>For example, the following code shows the result of a call to the <bpt id="p1">[</bpt>Regex.Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String))</ept> method with the regular expression pattern <ph id="ph1">`(a?)*,`</ph> which matches zero or one "a" character zero or more times.</source>
          <target state="translated">예를 들어 다음 코드는&amp;0;개 또는&amp;1;개의 "a" 문자를&amp;0;번 이상 찾는 정규식 패턴 <ph id="ph1">`(a?)*,`</ph>을 포함한 <bpt id="p1">[</bpt>Regex.Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String))</ept> 메서드에 대한 호출의 결과를 표시합니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Note that the single capturing group captures each "a" as well as <bpt id="p1">[</bpt>String.Empty<ept id="p1">](xref:System.String.Empty)</ept>, but that there is no second empty match, because the first empty match causes the quantifier to stop repeating.</source>
          <target state="translated">단일 캡처링 그룹은 <bpt id="p1">[</bpt>String.Empty<ept id="p1">](xref:System.String.Empty)</ept>뿐만 아니라 "a"를 캡처하지만 첫 번째 빈 일치 항목으로 인해 수량자가 반복을 멈추기 때문에 두 번째 빈 일치 항목이 없습니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>To see the practical difference between a capturing group that defines a minimum and a maximum number of captures and one that defines a fixed number of captures, consider the regular expression patterns <ph id="ph1">`(a\1|(?(1)\1)){0,2}`</ph> and <ph id="ph2">`(a\1|(?(1)\1)){2}`</ph>.</source>
          <target state="translated">캡처의 최소 및 최대 수를 정의하는 캡처링 그룹과 캡처의 고정 수를 정의하는 그룹 사이의 실질적인 차이를 확인하려면 정규식 패턴 <ph id="ph1">`(a\1|(?(1)\1)){0,2}`</ph> 및 <ph id="ph2">`(a\1|(?(1)\1)){2}`</ph>를 사용하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Both regular expressions consist of a single capturing group, which is defined as shown in the following table.</source>
          <target state="translated">두 정규식은 단일 캡처링 그룹으로 구성되며 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Either match "a" along with the value of the first captured group …</source>
          <target state="translated">첫 번째 캡처된 그룹의 값과 함께 "a"를 찾거나…</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>…</source>
          <target state="translated">…</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>or test whether the first captured group has been defined.</source>
          <target state="translated">또는 첫 번째 캡처된 그룹이 정의되어 있는지 여부를 테스트합니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>(Note that the <bpt id="p1">**</bpt>(?(1)<ept id="p1">**</ept> construct does not define a capturing group.)</source>
          <target state="translated"><bpt id="p1">**</bpt>(?(1)<ept id="p1">**</ept> 구문은 캡처링 그룹을 정의하지 않습니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>If the first captured group exists, match its value.</source>
          <target state="translated">첫 번째 캡처된 그룹이 있는 경우 해당 값을 찾습니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>If the group does not exist, the group will match <bpt id="p1">[</bpt>String.Empty<ept id="p1">](xref:System.String.Empty)</ept>.</source>
          <target state="translated">해당 그룹이 존재하지 않는 경우 그룹은 <bpt id="p1">[</bpt>String.Empty<ept id="p1">](xref:System.String.Empty)</ept>를 찾습니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The first regular expression tries to match this pattern between zero and two times; the second, exactly two times.</source>
          <target state="translated">첫 번째 정규식이&amp;0;번과 두 번 사이에 이 패턴을 찾으려 합니다. 두 번째 정규식은 정확히 두 번입니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Because the first pattern reaches its minimum number of captures with its first capture of <bpt id="p1">[</bpt>String.Empty<ept id="p1">](xref:System.String.Empty)</ept>, it never repeats to try to match <ph id="ph1">`a\1;`</ph> the <ph id="ph2">`{0,2}`</ph> quantifier allows only empty matches in the last iteration.</source>
          <target state="translated">첫 번째 패턴이 <bpt id="p1">[</bpt>String.Empty<ept id="p1">](xref:System.String.Empty)</ept>의 첫 번째 캡처를 사용하여 최소의 캡처 수에 도달하기 때문에 <ph id="ph2">`{0,2}`</ph> 수량자가 마지막 반복에서 빈 일치 항목을 허용하는 <ph id="ph1">`a\1;`</ph>를 찾기 위해 반복하지 않습니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>In contrast, the second regular expression does match "a" because it evaluates <ph id="ph1">`a\1`</ph> a second time; the minimum number of iterations, 2, forces the engine to repeat after an empty match.</source>
          <target state="translated">두 번째 정규식이 <ph id="ph1">`a\1`</ph>을 두 번째로 평가하기 때문에 "a"를 찾는 반면 반복의 최소수인 2는 빈 일치 항목 뒤에 엔진이 반복되도록 강제합니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>정규식 언어 - 빠른 참조<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking in regular expressions<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>정규식의 역추적<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>