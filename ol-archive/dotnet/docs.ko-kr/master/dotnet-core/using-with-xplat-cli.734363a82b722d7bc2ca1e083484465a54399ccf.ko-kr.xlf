<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-4a95368" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a5a5039c5043f46772110d6750d04f14a3f43c86</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tutorials\using-with-xplat-cli.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">693292aa347ed708a18d319e406f234106168f5e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">632d1b4ae1ca4415fa1c2bfb557ffea34063abfa</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Getting started with .NET Core on Windows/Linux/macOS using the command line</source>
          <target state="translated">명령줄을 사용하여 Windows/Linux/macOS에서 .NET Core 시작</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Getting started with .NET Core on Windows, Linux, or macOS using the .NET Core command line interface (CLI)</source>
          <target state="translated">CLI(명령줄 인터페이스)를 사용하여 Windows, Linux 또는 macOS에서 .NET Core 시작</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Getting started with .NET Core on Windows/Linux/macOS using the command line</source>
          <target state="translated">명령줄을 사용하여 Windows/Linux/macOS에서 .NET Core 시작</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic applies to .NET Core Tools Preview 2.</source>
          <target state="translated">이 항목은 .NET Core Tools Preview 2에 적용됩니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For the .NET Core Tools Preview 4 version, see the <bpt id="p1">[</bpt>Getting started with .NET Core on Windows/Linux/macOS using the command line (Tooling Preview 4)<ept id="p1">](../preview3/tutorials/using-with-xplat-cli-msbuild.md)</ept> topic.</source>
          <target state="translated">.NET Core Tools Preview 4 버전의 경우 <bpt id="p1">[</bpt>명령줄을 사용하여 Windows/Linux/macOS에서 .NET Core 시작(Tooling Preview 4)<ept id="p1">](../preview3/tutorials/using-with-xplat-cli-msbuild.md)</ept> 항목을 참조하세요.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This guide will show you how to use the .NET Core CLI tooling to build basic cross-platform console apps.</source>
          <target state="translated">이 가이드에서는 .NET Core CLI 도구를 사용하여 플랫폼 간 기본 콘솔 앱을 빌드하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you're unfamiliar with the .NET Core CLI toolset, read <bpt id="p1">[</bpt>the .NET Core SDK overview<ept id="p1">](../sdk.md)</ept>.</source>
          <target state="translated">.NET Core CLI 도구 집합에 익숙하지 않은 경우 <bpt id="p1">[</bpt>.NET Core SDK 개요<ept id="p1">](../sdk.md)</ept>를 읽어 보세요.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">필수 조건</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Before you begin, ensure you have the <bpt id="p1">[</bpt>latest .NET Core CLI tooling<ept id="p1">](https://www.microsoft.com/net/core)</ept>.</source>
          <target state="translated">시작하기 전에 <bpt id="p1">[</bpt>최신 .NET Core CLI 도구<ept id="p1">](https://www.microsoft.com/net/core)</ept>를 가지고 있는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You'll also need a text editor.</source>
          <target state="translated">텍스트 편집기도 필요합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Hello, Console App!</source>
          <target state="translated">Hello, 콘솔 앱!</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Navigate to or create a new folder with a name you like.</source>
          <target state="translated">원하는 이름의 폴더로 이동하거나 폴더를 새로 만듭니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>"Hello" is the name chosen for the sample code, which can be found <bpt id="p1">[</bpt>here<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/Hello)</ept>.</source>
          <target state="translated">"Hello"는 샘플 코드에 대해 선택한 이름으로, <bpt id="p1">[</bpt>여기<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/Hello)</ept>서 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Open up a command prompt and type the following:</source>
          <target state="translated">명령 프롬프트를 열고 다음을 입력합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Let's do a quick walkthrough:</source>
          <target state="translated">이제 간단한 연습을 해보겠습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet new`</ph><ept id="p1">](../tools/dotnet-new.md)</ept> creates an up-to-date <ph id="ph2">`project.json`</ph> file with NuGet dependencies necessary to build a console app.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`dotnet new`</ph><ept id="p1">](../tools/dotnet-new.md)</ept>는 콘솔 앱을 빌드하는 데 필요한 NuGet 종속성이 있는 최신 <ph id="ph2">`project.json`</ph> 파일입니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>It also creates a <ph id="ph1">`Program.cs`</ph>, a basic file containing the entry point for the application.</source>
          <target state="translated">응용 프로그램에 대한 진입점을 포함하는 기본 파일인 <ph id="ph1">`Program.cs`</ph>도 만듭니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`project.json`</ph>:</source>
          <target state="translated"><ph id="ph1">`project.json`</ph>:</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Program.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`Program.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet restore`</ph><ept id="p1">](../tools/dotnet-restore.md)</ept> calls into NuGet to restore the tree of dependencies.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`dotnet restore`</ph><ept id="p1">](../tools/dotnet-restore.md)</ept>는 NuGet을 호출하여 종속성 트리를 복원합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>NuGet analyzes the <ph id="ph1">`project.json`</ph> file, downloads the dependencies stated in the file (or grabs them from a cache on your machine), and writes the <ph id="ph2">`project.lock.json`</ph> file.</source>
          <target state="translated">NuGet은 <ph id="ph1">`project.json`</ph> 파일을 분석하고, 파일에 명시된 종속성을 다운로드하고(또는 컴퓨터의 캐시에서 종속성을 가져오고), <ph id="ph2">`project.lock.json`</ph> 파일을 작성합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`project.lock.json`</ph> file is necessary to be able to compile and run.</source>
          <target state="translated"><ph id="ph1">`project.lock.json`</ph> 파일은 컴파일 및 실행하려면 필요합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`project.lock.json`</ph> file is a persisted and complete set of the graph of NuGet dependencies and other information describing an app.</source>
          <target state="translated"><ph id="ph1">`project.lock.json`</ph> 파일은 NuGet 종속성 및 앱을 설명하는 기타 정보로 구성된 그래프의 지속적이고 전체적인 집합입니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This file is read by other tools, such as <ph id="ph1">`dotnet build`</ph> and <ph id="ph2">`dotnet run`</ph>, enabling them to process the source code with a correct set of NuGet dependencies and binding resolutions.</source>
          <target state="translated"><ph id="ph1">`dotnet build`</ph> 및 <ph id="ph2">`dotnet run`</ph> 같은 다른 도구에서는 이 파일을 읽고, NuGet 종속성 및 바인딩 확인의 올바른 집합으로 소스 코드를 처리합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet run`</ph><ept id="p1">](../tools/dotnet-run.md)</ept> calls <ph id="ph2">`dotnet build`</ph> to ensure that the build targets have been built, and then calls <ph id="ph3">`dotnet &lt;assembly.dll&gt;`</ph> to run the target application.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`dotnet run`</ph><ept id="p1">](../tools/dotnet-run.md)</ept>은 <ph id="ph2">`dotnet build`</ph>를 호출하여 빌드 대상이 빌드되었는지를 확인하고 <ph id="ph3">`dotnet &lt;assembly.dll&gt;`</ph>을 호출하여 대상 응용 프로그램을 실행합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can also execute <bpt id="p1">[</bpt><ph id="ph1">`dotnet build`</ph><ept id="p1">](../tools/dotnet-build.md)</ept> to compile the code without running the build console applications.</source>
          <target state="translated">또한 <bpt id="p1">[</bpt><ph id="ph1">`dotnet build`</ph><ept id="p1">](../tools/dotnet-build.md)</ept>를 실행하여 빌드 콘솔 응용 프로그램을 실행하지 않고 코드를 컴파일할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Building a self-contained application</source>
          <target state="translated">자체 포함 응용 프로그램 빌드</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Let's try compiling a self-contained application instead of a portable application.</source>
          <target state="translated">이식 가능한 응용 프로그램 대신 자체 포함 응용 프로그램을 컴파일해 보겠습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You can read more about the <bpt id="p1">[</bpt>types of portability in .NET Core<ept id="p1">](../deploying/index.md)</ept> to learn about the different application types, and how they are deployed.</source>
          <target state="translated">서로 다른 응용 프로그램 유형 및 이들의 배포 방법을 알아보려면 <bpt id="p1">[</bpt>.NET Core의 이식성 유형<ept id="p1">](../deploying/index.md)</ept>에 대해 읽어볼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>You need to make some changes to your <ph id="ph1">`project.json`</ph> file to direct the tools to build a self-contained application.</source>
          <target state="translated">도구를 사용하여 자체 포함 응용 프로그램을 빌드하려면 <ph id="ph1">`project.json`</ph> 파일을 일부 변경해야 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>You can see these in the <bpt id="p1">[</bpt>HelloNative<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/HelloNative)</ept> project in the samples directory.</source>
          <target state="translated">샘플 디렉터리의 <bpt id="p1">[</bpt>HelloNative<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/HelloNative)</ept> 프로젝트에서 이 내용을 볼 있습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The first change is to remove the <ph id="ph1">`"type": "platform"`</ph> element from all dependencies.</source>
          <target state="translated">첫 번째 변경 사항은 모든 종속성에서 <ph id="ph1">`"type": "platform"`</ph> 요소를 제거하는 것입니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This project's only dependency so far is <ph id="ph1">`"Microsoft.NETCore.App"`</ph>.</source>
          <target state="translated">지금까지 이 프로젝트의 유일한 종속성은 <ph id="ph1">`"Microsoft.NETCore.App"`</ph>입니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`dependencies`</ph> section should look like this:</source>
          <target state="translated"><ph id="ph1">`dependencies`</ph> 섹션은 다음과 같이 표시됩니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Next, you need to add a <ph id="ph1">`runtimes`</ph> node to specify all the target execution environments.</source>
          <target state="translated">이제 <ph id="ph1">`runtimes`</ph> 노드를 추가하여 모든 대상 실행 환경을 지정해야 합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For example, the following <ph id="ph1">`runtimes`</ph> node instructs the build system to create executables for the 64 bit version of Windows 10 and the 64 bit version of Mac OS X version 10.11.</source>
          <target state="translated">예를 들어, 다음 <ph id="ph1">`runtimes`</ph> 노드는 빌드 시스템에 Windows 10의 64비트 버전 및 Mac OS X 버전 10.11의 64비트 버전에 대한 실행 파일을 만들도록 지시합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The build system will generate native executables for the current environment.</source>
          <target state="translated">빌드 시스템은 현재 환경에 대한 네이티브 실행 파일을 생성합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If you are following these steps on a Windows machine, you'll build a Windows executable.</source>
          <target state="translated">Windows 컴퓨터에서 다음 단계를 따르는 경우 Windows 실행 파일이 빌드됩니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If you are following these steps on a Mac, you'll build the OS X executable.</source>
          <target state="translated">Mac에서 다음 단계를 따르는 경우 OS X 실행 파일이 빌드됩니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>See the full list of supported runtimes in the <bpt id="p1">[</bpt>RID catalog<ept id="p1">](../rid-catalog.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>RID 카탈로그<ept id="p1">](../rid-catalog.md)</ept>에서 지원되는 런타임의 전체 목록을 참조하세요.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>After making those two changes you execute <ph id="ph1">`dotnet restore`</ph>, followed by <ph id="ph2">`dotnet build`</ph> to create the native executable.</source>
          <target state="translated">이러한 두 가지 변경을 수행한 후 <ph id="ph1">`dotnet restore`</ph>, <ph id="ph2">`dotnet build`</ph>를 차례로 실행하여 네이티브 실행 파일을 만듭니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Then, you can run the generated native executable.</source>
          <target state="translated">그런 다음 생성된 네이티브 실행 파일을 실행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The following example shows the commands for Windows.</source>
          <target state="translated">다음 예제에서는 Windows에 대한 명령을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The example shows where the native executable gets generated and assumes that the project directory is named HelloNative.</source>
          <target state="translated">다음 예제는 네이티브 실행 파일이 어디에서 생성되는지를 보여주며, 프로젝트 디렉터리의 이름이 HelloNative라고 가정합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You may notice that the native application takes slightly longer to build, but executes slightly faster.</source>
          <target state="translated">네이티브 응용 프로그램은 빌드 시간은 약간 더 느리지만 실행 시간은 조금 더 빠릅니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This behavior becomes more noticeable as the application grows.</source>
          <target state="translated">응용 프로그램이 커지면 이 동작이 더 분명해집니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The build process generates several more files when your <ph id="ph1">`project.json`</ph> creates a native build.</source>
          <target state="translated"><ph id="ph1">`project.json`</ph>이 네이티브 빌드를 만들 때 빌드 프로세스에서 몇 가지 파일이 더 생성됩니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>These files are created in <ph id="ph1">`bin\Debug\netcoreapp1.0\&lt;platform&gt;`</ph> where <ph id="ph2">`&lt;platform&gt;`</ph> is the RID chosen.</source>
          <target state="translated">이러한 파일은 <ph id="ph1">`bin\Debug\netcoreapp1.0\&lt;platform&gt;`</ph>에 생성되는데, 여기서 <ph id="ph2">`&lt;platform&gt;`</ph>은 선택한 RID입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In addition to the project's <ph id="ph1">`HelloNative.dll`</ph> there is a <ph id="ph2">`HelloNative.exe`</ph> that loads the runtime and starts the application.</source>
          <target state="translated">프로젝트의 <ph id="ph1">`HelloNative.dll`</ph> 외에도 런타임을 로드하고 응용 프로그램을 시작하는 <ph id="ph2">`HelloNative.exe`</ph>가 있습니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Note that the name of the generated application changed because the project directory's name has changed.</source>
          <target state="translated">프로젝트 디렉터리의 이름이 변경되었기 때문에 생성된 응용 프로그램의 이름이 변경되었습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You may want to package this application to execute it on a machine that does not include the .NET runtime.</source>
          <target state="translated">.NET 런타임을 포함하지 않는 컴퓨터에서 실행할 수 있도록 이 응용 프로그램을 패키지할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You do that using the <ph id="ph1">`dotnet publish`</ph> command.</source>
          <target state="translated">이 경우 <ph id="ph1">`dotnet publish`</ph> 명령을 사용하면 됩니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`dotnet publish`</ph> command creates a new subdirectory under the <ph id="ph2">`./bin/Debug/netcoreapp1.0/&lt;platform&gt;`</ph> directory called <ph id="ph3">`publish`</ph>.</source>
          <target state="translated"><ph id="ph1">`dotnet publish`</ph> 명령은 <ph id="ph2">`./bin/Debug/netcoreapp1.0/&lt;platform&gt;`</ph> 디렉터리 아래에 <ph id="ph3">`publish`</ph>라는 새 하위 디렉터리를 만듭니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It copies the executable, all dependent DLLs and the framework to this sub directory.</source>
          <target state="translated">실행 파일, 모든 종속 DLL 및 프레임워크가 이 하위 디렉터리에 복사됩니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can package that directory to another machine (or a container) and execute the application there.</source>
          <target state="translated">해당 디렉터리를 다른 컴퓨터(또는 컨테이너)로 패키지하고 그곳에서 응용 프로그램을 실행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Let's contrast that with the behavior of <ph id="ph1">`dotnet publish`</ph> in the first Hello World sample.</source>
          <target state="translated">이것을 첫 번째 Hello World 샘플에 있는 <ph id="ph1">`dotnet publish`</ph>의 동작과 비교해 보겠습니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>That application is a <bpt id="p1">*</bpt>portable application<ept id="p1">*</ept>, which is the default type of application for .NET Core.</source>
          <target state="translated">해당 응용 프로그램은 .NET Core의 기본 응용 프로그램 형식인 <bpt id="p1">*</bpt>이식 가능한 응용 프로그램<ept id="p1">*</ept>입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A portable application requires that .NET Core is installed on the target machine.</source>
          <target state="translated">이식 가능한 응용 프로그램을 실행하려면 대상 컴퓨터에 .NET Core가 설치되어 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Portable applications can be built on one machine and executed anywhere.</source>
          <target state="translated">이식 가능한 응용 프로그램은 한 컴퓨터에서 빌드하고 어디서나 실행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Native applications must be built separately for each target machine.</source>
          <target state="translated">네이티브 응용 프로그램은 각 대상 컴퓨터에 대해 개별적으로 빌드해야 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dotnet publish`</ph> creates a directory that has the application's DLL, and any dependent dlls that are not part of the platform installation.</source>
          <target state="translated"><ph id="ph1">`dotnet publish`</ph>는 응용 프로그램의 DLL 및 플랫폼 설치에 포함되지 않는 모든 종속 DLL이 있는 디렉터리를 만듭니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Augmenting the program</source>
          <target state="translated">프로그램 보강</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Let's change the file just a little bit.</source>
          <target state="translated">파일을 아주 조금만 변경하겠습니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Fibonacci numbers are fun, so let's try that out (using the native version):</source>
          <target state="translated">피보나치(Fibonacci) 숫자가 흥미로우므로 시도해 보겠습니다(기본 버전 사용).</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Program.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`Program.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>And running the program (assuming you're on Windows, and have changed the project directory name to Fibonacci):</source>
          <target state="translated">프로그램을 실행합니다(플랫폼은 Windows이며 프로젝트 디렉터리 이름을 Fibonacci로 변경한 것으로 가정).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">됐습니다!</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You can augment <ph id="ph1">`Program.cs`</ph> any way you like.</source>
          <target state="translated">원하는 대로 <ph id="ph1">`Program.cs`</ph>를 보강할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Adding some new files</source>
          <target state="translated">몇 가지 새 파일 추가</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Single files are fine for simple one-off programs, but chances are you're going to want to break things out into multiple files if you're building anything which has multiple components.</source>
          <target state="translated">단순한 일회용 프로그램에는 단일 파일도 괜찮지만, 여러 구성 요소가 있는 프로그램을 빌드하는 경우 기능을 여러 파일로 분할해야 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Multiple files are a way to do that.</source>
          <target state="translated">여러 파일은 이런 경우에 사용합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Create a new file and give it a unique namespace:</source>
          <target state="translated">새 파일을 만들고 고유한 네임스페이스를 지정합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Next, include it in your <ph id="ph1">`Program.cs`</ph> file:</source>
          <target state="translated">이런 다음 <ph id="ph1">`Program.cs`</ph> 파일에 포함합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>And finally, you can build it:</source>
          <target state="translated">마지막으로 파일을 빌드할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Now the fun part: making the new file do something!</source>
          <target state="translated">이제부터가 흥미로운 부분입니다. 새 파일로 작업을 수행하는 것입니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Example: A Fibonacci Sequence Generator</source>
          <target state="translated">예제: 피보나치 시퀀스 생성기</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Let's say you want to build off of the previous <bpt id="p1">[</bpt>Fibonacci example<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/Fibonacci)</ept> by caching some Fibonacci values and add some recursive flair.</source>
          <target state="translated">일부 피보나치 값을 캐시하여 이전 <bpt id="p1">[</bpt>피보나치 예제<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/Fibonacci)</ept>에서 빌드하고 약간의 재귀 기능을 추가하려 한다고 가정해 보겠습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Your code for a <bpt id="p1">[</bpt>better Fibonacci example<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/FibonacciBetter)</ept> might look something like this:</source>
          <target state="translated"><bpt id="p1">[</bpt>더 나은 피보나치 예제<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/FibonacciBetter)</ept>에 대한 코드는 다음과 같을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Note that the use of <ph id="ph1">`Dictionary&lt;int, int&gt;`</ph> and <ph id="ph2">`IEnumerable&lt;int&gt;`</ph> means incorporating the <ph id="ph3">`System.Collections`</ph> namespace.</source>
          <target state="translated"><ph id="ph1">`Dictionary&lt;int, int&gt;`</ph> 및 <ph id="ph2">`IEnumerable&lt;int&gt;`</ph>를 사용한다는 것은 <ph id="ph3">`System.Collections`</ph> 네임스페이스를 통합한다는 의미입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Microsoft.NetCore.App`</ph> package is a <bpt id="p1">*</bpt>metapackage<ept id="p1">*</ept> that contains many of the core assemblies from the .NET Framework.</source>
          <target state="translated"><ph id="ph1">`Microsoft.NetCore.App`</ph> 패키지는 .NET Framework의 많은 핵심 어셈블리를 포함하는 <bpt id="p1">*</bpt>메타패키지<ept id="p1">*</ept>입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>By including this metapackage, you've already included the <ph id="ph1">`System.Collections.dll`</ph> assembly as part of your project.</source>
          <target state="translated">이 메타패키지를 포함함으로써 이미 프로젝트의 일부로 <ph id="ph1">`System.Collections.dll`</ph> 어셈블리를 포함한 것입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can verify this by running <ph id="ph1">`dotnet publish`</ph> and examining the files that are part of the installed package.</source>
          <target state="translated"><ph id="ph1">`dotnet publish`</ph>를 실행하고 설치된 패키지의 일부인 파일을 검사하여 이를 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>You'll see <ph id="ph1">`System.Collections.dll`</ph> in the list.</source>
          <target state="translated">목록에 <ph id="ph1">`System.Collections.dll`</ph>이 있습니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Now adjust the <ph id="ph1">`Main()`</ph> method in your <ph id="ph2">`Program.cs`</ph> file as shown below.</source>
          <target state="translated">이제 아래와 같이 <ph id="ph2">`Program.cs`</ph> 파일에서 <ph id="ph1">`Main()`</ph> 메서드를 조정합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The example assumes that <ph id="ph1">`Program.cs`</ph> has a <ph id="ph2">`using System;`</ph> statement.</source>
          <target state="translated">예제에서는 <ph id="ph1">`Program.cs`</ph>에 <ph id="ph2">`using System;`</ph> 문이 있다고 가정합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If you have a <ph id="ph1">`using static System.Console;`</ph> statement, remove <ph id="ph2">`Console.`</ph> from <ph id="ph3">`Console.WriteLine`</ph>.</source>
          <target state="translated"><ph id="ph1">`using static System.Console;`</ph> 문이 있는 경우 <ph id="ph2">`Console.`</ph>을 <ph id="ph3">`Console.WriteLine`</ph>에서 제거합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Finally, run it!</source>
          <target state="translated">마지막으로 실행합니다!</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">됐습니다!</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Using folders to organize code</source>
          <target state="translated">폴더를 사용하여 코드 구성</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Say you wanted to introduce some new types to do work on.</source>
          <target state="translated">작업할 몇 가지 새로운 형식을 도입하려 한다고 가정해 보겠습니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>You can do this by adding more files and making sure to give them namespaces you can include in your <ph id="ph1">`Program.cs`</ph> file.</source>
          <target state="translated">이렇게 하려면 파일을 더 추가하고 <ph id="ph1">`Program.cs`</ph> 파일에 포함할 수 있는 네임스페이스를 부여하면 됩니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This works great when the size of your project is relatively small.</source>
          <target state="translated">프로젝트의 크기가 비교적 작은 경우에는 이 방법이 매우 효과적입니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>However, if you have a larger app with many different data types and potentially multiple layers, you may wish to organize things logically.</source>
          <target state="translated">그러나 다양한 데이터 형식 및 여러 레이어가 포함된 더 큰 앱이 있는 경우 항목을 논리적으로 구성해야 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This is where folders come into play.</source>
          <target state="translated">여기에서 폴더를 생각할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can either follow along with <bpt id="p1">[</bpt>the NewTypes sample project<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/NewTypes)</ept> that this guide covers, or create your own files and folders.</source>
          <target state="translated">이 가이드에서 다루는 <bpt id="p1">[</bpt>NewTypes 샘플 프로젝트<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/NewTypes)</ept>를 따를 수도 있고, 자신의 파일과 폴더를 만들 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>To begin, create a new folder under the root of your project.</source>
          <target state="translated">시작하려면 프로젝트의 루트 아래에 새 폴더를 만듭니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`/Model`</ph> is chosen here.</source>
          <target state="translated"><ph id="ph1">`/Model`</ph>이 여기서 선택되었습니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Now add some new types to the folder:</source>
          <target state="translated">이제 몇 가지 새로운 형식을 폴더에 추가합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Now, just as if they were files in the same directory, give them all the same namespace so you can include them in your <ph id="ph1">`Program.cs`</ph>.</source>
          <target state="translated">이제 마치 이들이 동일한 디렉터리의 파일인 것처럼, <ph id="ph1">`Program.cs`</ph>에 포함할 수 있도록 모든 파일에 동일한 네임스페이스를 부여합니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Example: Pet Types</source>
          <target state="translated">예제: Pet 형식</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This example creates two new types, <ph id="ph1">`Dog`</ph> and <ph id="ph2">`Cat`</ph>, and has them implement an interface, <ph id="ph3">`IPet`</ph>.</source>
          <target state="translated">이 예제에서는 두 개의 새 형식, <ph id="ph1">`Dog`</ph> 및 <ph id="ph2">`Cat`</ph>를 만들고 <ph id="ph3">`IPet`</ph> 인터페이스에서 구현합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Folder Structure:</source>
          <target state="translated">폴더 구조:</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`IPet.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`IPet.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Dog.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`Dog.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Cat.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`Cat.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Program.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`Program.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`project.json`</ph>:</source>
          <target state="translated"><ph id="ph1">`project.json`</ph>:</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>And if you run this:</source>
          <target state="translated">이를 실행하면 다음이 가능합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>New pet types can be added (such as a <ph id="ph1">`Bird`</ph>), extending this project.</source>
          <target state="translated">새로운 pet 형식을 추가하여(예: <ph id="ph1">`Bird`</ph>) 이 프로젝트를 확장할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Testing your Console App</source>
          <target state="translated">콘솔 앱 테스트</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>You'll probably be wanting to test your projects at some point.</source>
          <target state="translated">어떤 지점에 도달하면 프로젝트를 테스트해야 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Here's a good way to do it:</source>
          <target state="translated">이 경우 다음 방법을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Move any source of your existing project into a new <ph id="ph1">`src`</ph> folder.</source>
          <target state="translated">기존 프로젝트의 모든 소스를 새로운 <ph id="ph1">`src`</ph> 폴더로 이동합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Create a <ph id="ph1">`/test`</ph> directory.</source>
          <target state="translated"><ph id="ph1">`/test`</ph> 디렉터리를 만듭니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Create a new <ph id="ph1">`global.json`</ph> file:</source>
          <target state="translated">새 <ph id="ph1">`global.json`</ph> 파일을 만듭니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`global.json`</ph>:</source>
          <target state="translated"><ph id="ph1">`global.json`</ph>:</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>This file tells the build system that this is a multi-project system, which allows it to look for dependencies in more than just the current folder it happens to be executing in.</source>
          <target state="translated">이 파일은 빌드 시스템에 이것이 다중 프로젝트 시스템임을 알립니다. 그러면 빌드 시스템은 현재 실행 중인 폴더 이외의 폴더에서도 종속성을 검색합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>This is important because it allows you to place a dependency on the code under test in your test project.</source>
          <target state="translated">이것이 중요한 이유는 테스트 프로젝트에서 테스트 중인 코드에 종속성을 배치할 수 있기 때문입니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Example: Extending the NewTypes project</source>
          <target state="translated">예제: NewTypes 프로젝트 확장</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Now that the project system is in place, you can create your test project and start writing tests!</source>
          <target state="translated">프로젝트 시스템이 준비되었으므로 이제 테스트 프로젝트를 만들고 테스트 작성을 시작할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>From here on out, this guide will use and extend <bpt id="p1">[</bpt>the sample Types project<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/NewTypes)</ept>.</source>
          <target state="translated">여기서부터 이 가이드는 <bpt id="p1">[</bpt>샘플 Types 프로젝트<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/NewTypes)</ept>를 사용하고 확장합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Additionally, it will use the <bpt id="p1">[</bpt>Xunit<ept id="p1">](https://xunit.github.io/)</ept> test framework.</source>
          <target state="translated">또한 <bpt id="p1">[</bpt>Xunit<ept id="p1">](https://xunit.github.io/)</ept> 테스트 프레임워크를 사용합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Feel free to follow along or create your own multi-project system with tests.</source>
          <target state="translated">이 가이드의 과정을 따라 해도 되고, 테스트와 함께 고유한 다중 프로젝트 시스템을 만들어도 됩니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The whole project structure should look like this:</source>
          <target state="translated">전체 프로젝트 구조는 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>There are two new things to make sure you have in your test project:</source>
          <target state="translated">테스트 프로젝트에 있는지 확인해야 할 두 가지가 있습니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>A correct <ph id="ph1">`project.json`</ph> with the following:</source>
          <target state="translated">다음이 포함된 올바른 <ph id="ph1">`project.json`</ph>:</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>A reference to <ph id="ph1">`xunit`</ph></source>
          <target state="translated">다음에 대한 참조:<ph id="ph1">`xunit`</ph></target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>A reference to <ph id="ph1">`dotnet-test-xunit`</ph></source>
          <target state="translated">다음에 대한 참조:<ph id="ph1">`dotnet-test-xunit`</ph></target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>A reference to the namespace corresponding to the code under test</source>
          <target state="translated">테스트 중인 코드에 해당하는 네임스페이스에 대한 참조</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>An Xunit test class.</source>
          <target state="translated">Xunit 테스트 클래스</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`NewTypesTests/project.json`</ph>:</source>
          <target state="translated"><ph id="ph1">`NewTypesTests/project.json`</ph>:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`PetTests.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`PetTests.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Now you can run tests!</source>
          <target state="translated">이제 테스트를 실행할 수 있습니다!</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt><ph id="ph1">`dotnet test`</ph><ept id="p1">](../tools/dotnet-test.md)</ept> command runs the test runner you have specified in your project.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`dotnet test`</ph><ept id="p1">](../tools/dotnet-test.md)</ept> 명령은 프로젝트에 지정된 Test Runner를 실행합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Make sure you start at the top-level directory.</source>
          <target state="translated">최상위 디렉터리에서 시작해야 합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Output should look like this:</source>
          <target state="translated">출력은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">결론</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Hopefully this guide has helped you learn how to create a .NET Core console app, from the basics all the way up to a multi-project system with unit tests.</source>
          <target state="translated">이 가이드가 기본적인 사항에서 단위 테스트가 포함된 다중 프로젝트 시스템에 이르기까지 .NET Core 콘솔 앱을 만드는 방법을 배우는 데 도움이 되었길 바랍니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The next step is to create awesome console apps of your own!</source>
          <target state="translated">다음 단계는 자신만의 멋진 콘솔 앱을 만드는 것입니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>If a more advanced example of a console app interests you, check out the next tutorial: <bpt id="p1">[</bpt>Using the CLI tools to write console apps: An advanced step-by-step guide<ept id="p1">](cli-console-app-tutorial-advanced.md)</ept>.</source>
          <target state="translated">흥미로운 고급 콘솔 앱의 예제를 보려면 <bpt id="p1">[</bpt>Using the CLI tools to write console apps: An advanced step-by-step guide(CLI 도구를 사용하여 콘솔 앱 작성: 고급 단계별 가이드)<ept id="p1">](cli-console-app-tutorial-advanced.md)</ept> 자습서를 참조하세요.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>