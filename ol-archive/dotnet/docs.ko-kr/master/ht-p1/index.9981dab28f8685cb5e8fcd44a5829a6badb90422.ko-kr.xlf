<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d99d1a68fd6d1daf68670d6d73c07fe1009d92d9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\preview3\deploying\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4a4641c815e8077fe3bdeae0ce40e912fe6dd638</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a6df366e5abab9c044712a56d0bd5a88bbecb430</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core Application Deployment</source>
          <target state="translated">.NET Core 응용 프로그램 배포</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core Application Deployment</source>
          <target state="translated">.NET Core 응용 프로그램 배포</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, .NET Core deployment</source>
          <target state="translated">.NET, .NET Core, .NET Core 배포</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core Application Deployment</source>
          <target state="translated">.NET Core 응용 프로그램 배포</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can create two types of deployments for .NET Core applications:</source>
          <target state="translated">.NET Core 응용 프로그램에 대해 두 가지 유형을 배포를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Framework-dependent deployment.</source>
          <target state="translated">프레임워크 종속 배포.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>As the name implies, framework-dependent deployment (FDD) relies on a shared system-wide version of .NET Core to be present on the target system.</source>
          <target state="translated">이름에서 알 수 있듯이 FDD(프레임워크 종속 배포)는 대상 시스템에 표시하기 위해 .NET Core의 공유 시스템 차원 버전을 사용합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Because .NET Core is already present, your app is also portable between installations of .NET Core.</source>
          <target state="translated">.NET Core가 이미 존재하기 때문에 .NET Core 설치 간에 앱을 이식할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Your app contains only its own code and any third-party dependencies that are outside of the .NET Core libraries.</source>
          <target state="translated">앱은 고유한 코드와 .NET Core 라이브러리 외부에 있는 타사 종속성만 포함합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>FDDs contain .dll files that can be launched by using the <bpt id="p1">[</bpt>dotnet utility<ept id="p1">](../tools/dotnet.md)</ept> from the command line.</source>
          <target state="translated">FDD에는 명령줄에서 <bpt id="p1">[</bpt>dotnet 유틸리티<ept id="p1">](../tools/dotnet.md)</ept>를 사용하여 시작할 수 있는 .dll 파일이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`dotnet app.dll`</ph> runs an application named <ph id="ph2">`app`</ph>.</source>
          <target state="translated">예를 들어 <ph id="ph1">`dotnet app.dll`</ph>은 <ph id="ph2">`app`</ph>이라는 응용 프로그램을 실행합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Self-contained deployment.</source>
          <target state="translated">자체 포함 배포.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Unlike FDD, a self-contained deployment (SCD) does not rely on any shared components to be present on the target system.</source>
          <target state="translated">FDD와 달리 SCD(자체 포함 배포)에서는 대상 시스템에 표시하기 위해 공유 구성 요소를 사용하지 않습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>All components, including both .NET Core libraries and the .NET Core runtime, are included with the application and are isolated from other .NET Core applications.</source>
          <target state="translated">.NET Core 라이브러리 및 .NET Core 런타임을 비롯한 모든 구성 요소가 응용 프로그램과 함께 포함되며 다른 .NET Core 응용 프로그램에서 격리됩니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>SCDs include an executable (such as <ph id="ph1">`app.exe`</ph> on Windows platforms for an application named <ph id="ph2">`app`</ph>), which is  a renamed version of the platform-specific .NET Core host, and a .dll file (such as <ph id="ph3">`app.dll`</ph>), which is the actual application.</source>
          <target state="translated">SCD에는 플랫폼별.NET Core 호스트의 이름이 변경된 버전인 실행 파일(예: Windows 플랫폼에서 <ph id="ph2">`app`</ph>이라는 응용 프로그램에 대한 <ph id="ph1">`app.exe`</ph>)과 실제 응용 프로그램인 .dll 파일(예: <ph id="ph3">`app.dll`</ph>)이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Framework-dependent deployments (FDD)</source>
          <target state="translated">프레임워크 종속 배포(FDD)</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For an FDD, you deploy only your app and any third-party dependencies.</source>
          <target state="translated">FDD에서는 앱과 타사 종속성만 배포합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You do not have to deploy .NET Core, since your app will use the version of .NET Core that's present on the target system.</source>
          <target state="translated">앱에서 대상 시스템에 있는 .NET Core의 버전을 사용하므로 .NET Core를 배포할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This is the default deployment model for .NET Core apps.</source>
          <target state="translated">이 배포는 .NET Core 앱의 기본 배포 모델입니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Why create a framework-dependent deployment?</source>
          <target state="translated">프레임워크 종속 배포를 만드는 이유</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Deploying an FDD has a number of advantages:</source>
          <target state="translated">FDD 배포에는 다음과 같은 여러 가지 장점이 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You do not have to define the target operating systems that your .NET Core app will run on in advance.</source>
          <target state="translated">.NET Core 앱이 실행될 대상 운영 체제를 미리 정의할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Because .NET Core uses a common PE file format for executables and libraries regardless of operating system, .NET Core can execute your app regardless of the underlying operating system.</source>
          <target state="translated">.NET Core는 운영 체제에 관계없이 실행 파일 및 라이브러리에 공용 PE 파일 형식을 사용하므로 기본 운영 체제에 관계없이 앱을 실행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information on the PE file format, see <bpt id="p1">[</bpt>.NET Assembly File Format<ept id="p1">](../../../standard/assembly-format.md)</ept>.</source>
          <target state="translated">PE 파일 형식에 대한 자세한 내용은 <bpt id="p1">[</bpt>.NET 어셈블리 파일 형식<ept id="p1">](../../../standard/assembly-format.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The size of your deployment package is small.</source>
          <target state="translated">배포 패키지의 크기가 작습니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You only have to deploy your app and its dependencies, not .NET Core itself.</source>
          <target state="translated">.NET Core 자체가 아닌 앱과 종속성만 배포해야 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Multiple apps use the same .NET Core installation, which reduces both disk space and memory usage on host systems.</source>
          <target state="translated">여러 앱에서 동일한 .NET Core 설치를 사용하여 호스트 시스템에서 디스크 공간 및 메모리 사용량을 줄일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>There are also a few disadvantages:</source>
          <target state="translated">다음과 같은 몇 가지 단점도 있습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Your app can run only if the version of .NET Core that you target, or a later version, is already installed on the host system.</source>
          <target state="translated">대상으로 지정한 .NET Core의 버전이나 그 이상 버전이 호스트 시스템에 이미 설치된 경우에만 앱이 실행됩니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>It is possible for the .NET Core runtime and libraries to change without your knowledge in future releases.</source>
          <target state="translated">.NET Core 런타임 및 라이브러리가 향후 릴리스에서 사용자 모르게 변경될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In rare cases, this may change the behavior of your app.</source>
          <target state="translated">드문 경우지만 이로 인해 앱의 동작이 변경될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Deploying a framework-dependent deployment</source>
          <target state="translated">프레임워크 종속 배포</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Deploying a framework-dependent deployment with no third-party dependencies simply involves building, testing, and publishing the app.</source>
          <target state="translated">타사 종속성이 없는 프레임워크 종속 배포에는 앱의 빌드, 테스트 및 게시만 포함됩니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A simple example written in C# illustrates the process.</source>
          <target state="translated">C#으로 작성된 간단한 예제에서는 이 프로세스를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The example uses the <bpt id="p1">[</bpt>dotnet utility<ept id="p1">](../tools/dotnet.md)</ept> from the command line; however, you can also use a development environment, such as Visual Studio or Visual Studio Code, to compile, test, and publish the example.</source>
          <target state="translated">이 예제에서는 명령줄에서 <bpt id="p1">[</bpt>dotnet 유틸리티<ept id="p1">](../tools/dotnet.md)</ept>를 사용하지만 Visual Studio나 Visual Studio Code와 같은 개발 환경을 사용하여 예제를 컴파일, 테스트 및 게시할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Create a directory for your project, and from the command line, type <bpt id="p1">[</bpt>dotnet new<ept id="p1">](../tools/dotnet-new.md)</ept> to create a new C# console project.</source>
          <target state="translated">프로젝트에 대한 디렉터리를 만들고 명령줄에서 <bpt id="p1">[</bpt>dotnet new<ept id="p1">](../tools/dotnet-new.md)</ept>를 입력하여 새 C# 콘솔 프로젝트를 만듭니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Open the <ph id="ph1">`Program.cs`</ph> file in an editor, and replace the auto-generated code with the following code.</source>
          <target state="translated">편집기에서 <ph id="ph1">`Program.cs`</ph> 파일을 열고 자동 생성된 코드를 다음 코드로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>It prompts the user to enter text, and then displays the individual words entered by the user.</source>
          <target state="translated">텍스트를 입력하라는 메시지가 표시된 다음 사용자가 입력한 개별 단어가 표시됩니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>It uses the regular expression <ph id="ph1">`\w+`</ph> to separate the words in the input text.</source>
          <target state="translated">정규식 <ph id="ph1">`\w+`</ph>를 사용하여 입력 테스트의 단어를 구분합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Run the <bpt id="p1">[</bpt>dotnet restore<ept id="p1">](../tools/dotnet-restore.md)</ept> command to restore the dependencies specified in your project.</source>
          <target state="translated"><bpt id="p1">[</bpt>dotnet restore<ept id="p1">](../tools/dotnet-restore.md)</ept> 명령을 실행하여 프로젝트에 지정된 종속성을 복원합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Create a debug build of your app by using the <bpt id="p1">[</bpt>dotnet build<ept id="p1">](../tools/dotnet-build.md)</ept> command.</source>
          <target state="translated"><bpt id="p1">[</bpt>dotnet build<ept id="p1">](../tools/dotnet-build.md)</ept> 명령을 사용하여 앱의 디버그 빌드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>After you've debugged and tested the program, you can create the files to be deployed with your app by using the <ph id="ph1">`dotnet publish -f netcoreapp1.0 -c release`</ph> command.</source>
          <target state="translated">프로그램을 디버그하고 테스트한 후에는 <ph id="ph1">`dotnet publish -f netcoreapp1.0 -c release`</ph> 명령을 사용하여 앱과 함께 배포할 파일을 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This creates a release (rather than a debug) version of your app.</source>
          <target state="translated">그러면 앱의 디버그가 아닌 릴리스 버전이 만들어집니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The resulting files are placed in a directory named <ph id="ph1">`publish`</ph> that is in a subdirectory of your project's <ph id="ph2">`.\bin\release\netcoreapp1.0`</ph> subdirectory.</source>
          <target state="translated">결과 파일은 프로젝트 <ph id="ph2">`.\bin\release\netcoreapp1.0`</ph> 하위 디렉터리의 하위 디렉터리에 있는 <ph id="ph1">`publish`</ph>는 디렉터리에 배치됩니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app.</source>
          <target state="translated">게시 프로세스에서는 응용 프로그램의 파일과 함께 앱에 대한 디버깅 정보를 포함하는 프로그램 데이터베이스(.pdb) 파일을 내보냅니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.</source>
          <target state="translated">이 파일은 기본적으로 디버깅 예외에 유용하며 응용 프로그램의 파일과 함께 패키지하지 않도록 선택할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The complete set of application  files can be deployed in any way you'd like.</source>
          <target state="translated">응용 프로그램 파일의 전체 집합은 원하는 방식으로 배포할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For example, you can package them in a zip file, use a simple <ph id="ph1">`copy`</ph> command, or deploy them with any installation package of your choice.</source>
          <target state="translated">예를 들어 zip 파일로 패키지하거나, 간단한 <ph id="ph1">`copy`</ph> 명령을 사용하여 선택한 설치 패키지와 함께 배포할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>In addition to the application binaries, the installer should also either bundle the shared framework installer or check for it as a prerequisite as part of the application installation.</source>
          <target state="translated">설치 관리자는 응용 프로그램 이진 외에도 공유 프레임워크 설치 관리자를 번들로 제공하거나 응용 프로그램 설치의 일부로 필수 조건을 확인해야 합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Installation of the shared framework requires Administrator/root access since it is machine-wide.</source>
          <target state="translated">공유 프레임워크 설치는 시스템 수준이므로 관리자/루트 액세스 권한이 필요합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Deploying a framework-dependent deployment with third-party dependencies</source>
          <target state="translated">타사 종속성이 있는 프레임워크 종속 배포</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Deploying a framework-dependent deployment with one or more third-party dependencies involves three additional steps before you can run the <ph id="ph1">`dotnet restore`</ph> command:</source>
          <target state="translated">하나 이상의 타사 종속성이 있는 프레임워크 종속 배포에는 <ph id="ph1">`dotnet restore`</ph> 명령을 실행하기 전에 세 가지 추가 단계가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Add references to any third-party libraries to the <ph id="ph1">`&lt;ItemGroup&gt;`</ph> section of your <ph id="ph2">`csproj`</ph> file.</source>
          <target state="translated">모든 타사 라이브러리에 대한 참조를 <ph id="ph2">`csproj`</ph> 파일의 <ph id="ph1">`&lt;ItemGroup&gt;`</ph> 섹션에 추가합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The following  <ph id="ph1">`&lt;ItemGroup&gt;`</ph> section shows the <ph id="ph2">`&lt;ItemGroup&gt;`</ph> containing the dependencies in the default project with Json.NET as a third-party library.</source>
          <target state="translated">다음 <ph id="ph1">`&lt;ItemGroup&gt;`</ph> 섹션은 타사 라이브러리로 Json.NET을 사용하여 기본 프로젝트에 종속성을 포함하는 <ph id="ph2">`&lt;ItemGroup&gt;`</ph>을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Note that the SDK dependency remains in the above example.</source>
          <target state="translated">위의 예제에서는 SDK 종속성이 그대로 유지됩니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This is by design, since this depdendency is required to restore all the needed targets to allow the command line tools to function.</source>
          <target state="translated">이 종속성은 명령줄 도구가 작동하는 데 필요한 대상을 모두 복원하는 데 필요하므로 정상적인 현상입니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If you haven't already, download the NuGet package containing the third-party dependency.</source>
          <target state="translated">타사 종속성을 포함하는 NuGet 패키지를 아직 다운로드하지 않은 경우 다운로드합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>To download the package, execute the <ph id="ph1">`dotnet restore`</ph> command after adding the dependency.</source>
          <target state="translated">패키지를 다운로드하려면 종속성을 추가한 후 <ph id="ph1">`dotnet restore`</ph> 명령을 실행합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Because the dependency is resolved out of the local NuGet cache at publish time, it must be available on your system.</source>
          <target state="translated">종속성은 게시 시간에 로컬 NuGet 캐시에서 확인되므로 시스템에서 사용할 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Note that a framework-dependent deployment with third-party dependencies will only be as portable as its third-party dependencies.</source>
          <target state="translated">타사 종속성이 있는 프레임워크 종속 배포는 타사 종속성만큼만 이식 가능합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For example, if a third-party library only supports macOS, the app will not be portable to Windows systems.</source>
          <target state="translated">예를 들어 타사 라이브러리에서 macOS를 지원하는 경우 Windows 시스템에 앱을 이식할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This can happen if the third-party dependency itself depends on native code.</source>
          <target state="translated">이러한 현상은 타사 종속성 자체가 네이티브 코드에 종속된 경우에 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A good example of this is Kestrel server.</source>
          <target state="translated">좋은 예로 Kestrel 서버가 있습니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>When an FDD is created for an application with this kind of third-party dependency, the published output will contain a folder for each <bpt id="p1">[</bpt>Runtime Identifier (RID)<ept id="p1">](../../rid-catalog.md#what-are-rids)</ept> that the native dependency supports (and that exists in its NuGet package).</source>
          <target state="translated">이런 종류의 타사 종속성이 있는 응용 프로그램에 대해 FDD를 만들면 게시된 출력에는 기본 종속성에서 지원하고 NuGet 패키지에 있는 각 <bpt id="p1">[</bpt>RID(런타임 식별자)<ept id="p1">](../../rid-catalog.md#what-are-rids)</ept>에 대한 폴더가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Self-contained deployments (SCD)</source>
          <target state="translated">자체 포함 배포(SCD)</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For a self-contained deployment, you deploy not only your app and any third-party dependencies, but the version of .NET Core that you build your app with.</source>
          <target state="translated">자체 포함 배포에서는 앱과 타사 종속성뿐만 아니라 앱을 빌드하는 데 사용한 .NET Core의 버전도 배포합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Creating an SCD does not, however, include the <bpt id="p1">[</bpt>native dependencies of .NET Core<ept id="p1">](https://github.com/dotnet/core/blob/master/Documentation/prereqs.md)</ept> itself on various platforms (for example, OpenSSL on macOS) so these need to be installed before running the application.</source>
          <target state="translated">그러나 SCD 만들기에서는 <bpt id="p1">[</bpt>.NET Core의 기본 종속성<ept id="p1">](https://github.com/dotnet/core/blob/master/Documentation/prereqs.md)</ept> 자체를 다양한 플랫폼(예: macOS의 OpenSSL)에 포함하지 않으므로 응용 프로그램을 실행하기 전에 설치할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Why deploy a Self-contained deployment?</source>
          <target state="translated">자체 포함 배포를 배포하는 이유</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Deploying a Self-contained deployment has two major advantages:</source>
          <target state="translated">자체 포함 배포를 배포하면 다음과 같은 두 가지 주요 장점이 있습니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>You have sole control of the version of .NET Core that is deployed with your app.</source>
          <target state="translated">앱과 함께 배포되는 .NET Core 버전을 유일하게 제어할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>.NET Core can be serviced only by you.</source>
          <target state="translated">.NET Core만 제공할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>You can be assured that the target system can run your .NET Core app, since you're providing the version of .NET Core that it will run on.</source>
          <target state="translated">앱이 실행될 .NET Core 버전을 제공하므로 대상 시스템에서 .NET Core 앱을 실행할 수 있다고 보장할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It also has a number of disadvantages:</source>
          <target state="translated">다음과 같은 여러 가지 단점도 있습니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Because .NET Core is included in your deployment package, you must select the target platforms for which you build deployment packages in advance.</source>
          <target state="translated">.NET Core가 배포 패키지에 포함되므로 배포 패키지를 빌드할 대상 플랫폼을 미리 선택합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The size of your deployment package is relatively large, since you have to include .NET Core as well as your app and its third-party dependencies.</source>
          <target state="translated">.NET Core뿐만 아니라 앱과 해당 타사 종속성도 포함해야 하므로 배포 패키지의 크기가 상대적으로 큽니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Deploying numerous self-contained .NET Core apps to a system can consume significant amounts of disk space, since each app duplicates .NET Core files.</source>
          <target state="translated">다양한 자체 포함 .NET Core 앱을 시스템에 배포하면 각 앱에서 .NET Core 파일을 중복하므로 엄청나게 많은 디스크 공간을 사용합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="simpleSelf"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Deploying a simple self-contained deployment</source>
          <target state="translated"><bpt id="p1">&lt;a name="simpleSelf"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> 간단한 자체 포함 배포</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Deploying a self-contained deployment with no third-party dependencies involves creating the project, modifying the csproj file, building, testing, and publishing the app.</source>
          <target state="translated">타사 종속성이 없는 자체 포함 배포에는 프로젝트 만들기, csproj 파일 수정, 앱 빌드, 테스트 및 수정이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>A simple example written in C# illustrates the process.</source>
          <target state="translated">C#으로 작성된 간단한 예제에서는 이 프로세스를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The example uses the <ph id="ph1">`dotnet`</ph> utility from the command line; however, you can also use a development environment, such as Visual Studio or Visual Studio Code, to compile, test, and publish the example.</source>
          <target state="translated">이 예제에서는 명령줄에서 <ph id="ph1">`dotnet`</ph> 유틸리티를 사용하지만 Visual Studio나 Visual Studio Code와 같은 개발 환경을 사용하여 예제를 컴파일, 테스트 및 게시할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Create a directory for your project, and from the command line, type <ph id="ph1">`dotnet new`</ph> to create a new C# console project.</source>
          <target state="translated">프로젝트에 대한 디렉터리를 만들고 명령줄에서 <ph id="ph1">`dotnet new`</ph>를 입력하여 새 C# 콘솔 프로젝트를 만듭니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Open the <ph id="ph1">`Program.cs`</ph> file in an editor, and replace the auto-generated code with the following code.</source>
          <target state="translated">편집기에서 <ph id="ph1">`Program.cs`</ph> 파일을 열고 자동 생성된 코드를 다음 코드로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>It prompts the user to enter text, and then displays the individual words entered by the user.</source>
          <target state="translated">텍스트를 입력하라는 메시지가 표시된 다음 사용자가 입력한 개별 단어가 표시됩니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>It uses the regular expression <ph id="ph1">`\w+`</ph> to separate the words in the input text.</source>
          <target state="translated">정규식 <ph id="ph1">`\w+`</ph>를 사용하여 입력 테스트의 단어를 구분합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Create a <ph id="ph1">`&lt;RuntimeIdentifiers&gt;`</ph> tag under the <ph id="ph2">`&lt;PropertyGroup&gt;`</ph> section in your <ph id="ph3">`csproj`</ph> file that defines the platforms your app targets, and specify the runtime identifier of each platform that you target.</source>
          <target state="translated"><ph id="ph3">`csproj`</ph> 파일의 <ph id="ph2">`&lt;PropertyGroup&gt;`</ph> 섹션에서 앱의 대상 플랫폼을 정의하는 <ph id="ph1">`&lt;RuntimeIdentifiers&gt;`</ph> 태그를 만들고 대상으로 지정한 각 플랫폼의 런타임 식별자를 지정합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime IDentifier catalog<ept id="p1">](../../rid-catalog.md)</ept> for a list of runtime identifiers.</source>
          <target state="translated">런타임 식별자 목록은 <bpt id="p1">[</bpt>런타임 식별자 카탈로그<ept id="p1">](../../rid-catalog.md)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>For example, the following <ph id="ph1">`runtimes`</ph> section indicates that the app runs on 64-bit Windows 10 operating systems and the 64-bit OS X Version 10.11 operating system.</source>
          <target state="translated">예를 들어 다음 <ph id="ph1">`runtimes`</ph> 섹션은 앱이 64비트 Windows 10 운영 체제 및 64비트 OS X 버전 10.11 운영 체제에서 실행됨을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Note that you also need to add a semicolon to separate the RIDs.</source>
          <target state="translated">RID를 구분하려면 세미콜론도 추가해야 합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Also, please note that the <ph id="ph1">`&lt;RuntimeIdentifier&gt;`</ph> element can go into any <ph id="ph2">`&lt;PropertyGroup&gt;`</ph> that you have in your <ph id="ph3">`csproj`</ph> file.</source>
          <target state="translated">또한 <ph id="ph1">`&lt;RuntimeIdentifier&gt;`</ph> 요소는 <ph id="ph3">`csproj`</ph> 파일에 있는 <ph id="ph2">`&lt;PropertyGroup&gt;`</ph>으로 이동합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>A complete sample <ph id="ph1">`csproj`</ph> file appears later in this section.</source>
          <target state="translated">전체 샘플 <ph id="ph1">`csproj`</ph> 파일은 이 섹션의 뒷부분에 나옵니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Run the <ph id="ph1">`dotnet restore`</ph> command to restore the dependencies specified in your project.</source>
          <target state="translated"><ph id="ph1">`dotnet restore`</ph> 명령을 실행하여 프로젝트에 지정된 종속성을 복원합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Create debug builds of your app on each of the target platforms by using the <ph id="ph1">`dotnet build`</ph> command.</source>
          <target state="translated">각 대상 플랫폼에서 <ph id="ph1">`dotnet build`</ph> 명령을 사용하여 앱의 디버그 빌드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Unless you specify the runtime identifier you'd like to build, the <ph id="ph1">`dotnet build`</ph> command creates a build only for the current system's runtime ID.</source>
          <target state="translated">빌드하려는 런타임 식별자를 지정하지 않으면 <ph id="ph1">`dotnet build`</ph> 명령은 현재 시스템의 런타임 ID에 대한 빌드만 만듭니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>You can build your app for both target platforms with the commands:</source>
          <target state="translated">다음 명령을 사용하여 두 대상 플랫폼에 대한 앱을 빌드할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The debug builds of your app for each platform will be found in the project's <ph id="ph1">`.\bin\Debug\netcoreapp1.0\&lt;runtime_identifier&gt;`</ph> subdirectory.</source>
          <target state="translated">각 플랫폼에 대한 앱의 디버그 빌드는 프로젝트의 <ph id="ph1">`.\bin\Debug\netcoreapp1.0\&lt;runtime_identifier&gt;`</ph> 하위 디렉터리에 있습니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>After you've debugged and tested the program, you can create the files to be deployed with your app for each platform that it targets by using the <ph id="ph1">`dotnet publish`</ph> command for both target platforms as follows:</source>
          <target state="translated">프로그램을 디버그하고 테스트한 후에는 다음과 같이 두 대상 플랫폼에 <ph id="ph1">`dotnet publish`</ph> 명령을 사용하여 각 대상 플랫폼에 대해 앱과 함께 배포할 파일을 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This creates a release (rather than a debug) version of your app for each target platform.</source>
          <target state="translated">그러면 각 대상 플랫폼에 대해 앱의 디버그가 아닌 릴리스 버전이 만들어집니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The resulting files are placed in a subdirectory named <ph id="ph1">`publish`</ph> that is in a subdirectory of your project's <ph id="ph2">`.\bin\release\netcoreapp1.0\&lt;runtime_identifier&gt;`</ph> subdirectory.</source>
          <target state="translated">결과 파일은 프로젝트 <ph id="ph2">`.\bin\release\netcoreapp1.0\&lt;runtime_identifier&gt;`</ph> 하위 디렉터리의 하위 디렉터리에 있는 <ph id="ph1">`publish`</ph>라는 하위 디렉터리에 배치됩니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Note that each subdirectory contains the complete set of files (both your app files and all .NET Core files) needed to launch your app.</source>
          <target state="translated">각 하위 디렉터리에는 앱을 시작하는 데 필요한 전체 파일 집합(앱 파일 및 모든 .NET Core 파일)이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app.</source>
          <target state="translated">게시 프로세스에서는 응용 프로그램의 파일과 함께 앱에 대한 디버깅 정보를 포함하는 프로그램 데이터베이스(.pdb) 파일을 내보냅니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.</source>
          <target state="translated">이 파일은 기본적으로 디버깅 예외에 유용하며 응용 프로그램의 파일과 함께 패키지하지 않도록 선택할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The published files can be deployed in any way you'd like.</source>
          <target state="translated">게시된 파일은 원하는 방식으로 배포할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For example, you can package them in a zip file, use a simple <ph id="ph1">`copy`</ph> command, or deploy them with any installation package of your choice.</source>
          <target state="translated">예를 들어 zip 파일로 패키지하거나, 간단한 <ph id="ph1">`copy`</ph> 명령을 사용하여 선택한 설치 패키지와 함께 배포할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The following is the complete <ph id="ph1">`csproj`</ph> file for this project.</source>
          <target state="translated">다음은 이 프로젝트에 대한 전체 <ph id="ph1">`csproj`</ph> 파일입니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Deploying a self-contained deployment with third-party dependencies</source>
          <target state="translated">타사 종속성이 있는 자체 포함 배포</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Deploying a self-contained deployment with one or more third-party dependencies involves adding the third party dependency:</source>
          <target state="translated">하나 이상의 타사 종속성이 있는 자체 포함 배포에는 타사 종속성 추가가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Add references to any third-party libraries to the <ph id="ph1">`&lt;ItemGroup&gt;`</ph> section of your <ph id="ph2">`csproj`</ph> file.</source>
          <target state="translated">모든 타사 라이브러리에 대한 참조를 <ph id="ph2">`csproj`</ph> 파일의 <ph id="ph1">`&lt;ItemGroup&gt;`</ph> 섹션에 추가합니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The following  <ph id="ph1">`&lt;ItemGroup&gt;`</ph> section uses Json.NET as a third-party library.</source>
          <target state="translated">다음 <ph id="ph1">`&lt;ItemGroup&gt;`</ph> 섹션에서는 Json.NET을 타사 라이브러리로 사용합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If you haven't already, download the NuGet package containing the third-party dependency to your system.</source>
          <target state="translated">타사 종속성을 포함하는 NuGet 패키지를 시스템에 아직 다운로드하지 않은 경우 다운로드합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>To make the dependency available to your app, execute the <ph id="ph1">`dotnet restore`</ph> command after adding the dependency.</source>
          <target state="translated">앱에서 종속성을 사용할 수 있도록 하려면 종속성을 추가한 후 <ph id="ph1">`dotnet restore`</ph> 명령을 실행합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Because the dependency is resolved out of the local NuGet cache at publish time, it must be available on your system.</source>
          <target state="translated">종속성은 게시 시간에 로컬 NuGet 캐시에서 확인되므로 시스템에서 사용할 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The following is the complete csproj file for this project:</source>
          <target state="translated">다음은 이 프로젝트에 대한 전체 csproj 파일입니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>When you deploy your application, any third-party dependencies used in your app are also contained with your application files.</source>
          <target state="translated">응용 프로그램을 배포하면 앱에서 사용된 타사 종속성도 응용 프로그램 파일에 포함됩니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Third-party libraries do not already have to be present on the system on which the app is running.</source>
          <target state="translated">타사 라이브러리는 앱이 실행되는 시스템에 없어도 됩니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Note that you can only deploy a self-contained deployment with a third-party library to platforms supported by that library.</source>
          <target state="translated">타사 라이브러리가 있는 자체 포함 배포는 해당 라이브러리에서 지원하는 플랫폼에만 배포할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This is similar to having third-party dependencies with native dependencies in your framework-dependent deployment.</source>
          <target state="translated">이 배포는 기본 종속성과 함께 타사 종속성이 있는 프레임워크 종속 배포와 유사합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Deploying a self-contained deployment with a smaller footprint</source>
          <target state="translated">공간이 더 작은 자체 포함 배포</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>If the availability of adequate storage space on target systems is likely to be an issue, you can reduce the overall footprint of your app by excluding some system components.</source>
          <target state="translated">대상 시스템에서 적절한 저장소 공간의 가용성이 문제가 될 경우 일부 시스템 구성 요소를 제외하여 앱의 전체 공간을 줄일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>To do this, you explicitly define the .NET Core components that your app includes in your csproj file.</source>
          <target state="translated">전체 공간을 줄이기 위해 csproj 파일에서 앱이 포함하는 .NET Core 구성 요소를 명시적으로 정의합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>To create a self-contained deployment with a smaller footprint, start by following the first two steps for creating a self-contained deployment.</source>
          <target state="translated">공간이 더 작은 자체 포함 배포를 만들려면 자체 포함 배포를 만드는 처음 두 단계를 수행하여 시작합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Once you've run the <ph id="ph1">`dotnet new`</ph> command and added the C# source code to your app, do the following:</source>
          <target state="translated"><ph id="ph1">`dotnet new`</ph> 명령을 실행하고 C# 소스 코드를 앱에 추가했으면 다음을 수행합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Open the <ph id="ph1">`csproj`</ph> file and replace the <ph id="ph2">`frameworks`</ph> section with the following:</source>
          <target state="translated"><ph id="ph1">`csproj`</ph> 파일을 열고 <ph id="ph2">`frameworks`</ph> 섹션을 다음으로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>This operation indicates that, instead of using the entire <ph id="ph1">`netcoreapp1.0`</ph> framework, which includes .NET Core CLR, the .NET Core Library, and a number of other system components, our app uses only the .NET Standard Library.</source>
          <target state="translated">.NET Core CLR, .NET Core 라이브러리 및 여러 가지 기타 시스템 구성 요소를 포함하는 전체 <ph id="ph1">`netcoreapp1.0`</ph> 프레임워크를 사용하는 대신 앱이 .NET 표준 라이브러리를 사용함을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Replace the <ph id="ph1">`dependencies`</ph> section with the following:</source>
          <target state="translated"><ph id="ph1">`dependencies`</ph> 섹션을 다음으로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>This defines the system components used by our app.</source>
          <target state="translated">앱에서 사용하는 시스템 구성 요소를 정의합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The system components packaged with our app include the .NET Standard Library, the .NET Core runtime, and the .NET Core host.</source>
          <target state="translated">앱과 함께 패키지되는 시스템 구성 요소에는 .NET 표준 라이브러리, .NET Core 런타임 및 .NET Core 호스트가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>This produces a self-contained deployment with a smaller footprint.</source>
          <target state="translated">그러면 공간이 더 작은 자체 포함 배포가 생성됩니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>As you did in the <bpt id="p1">[</bpt>Deploying a simple self-contained deployment<ept id="p1">](#simpleSelf)</ept> example, create a <ph id="ph1">`&lt;RuntimeIdentifiers&gt;`</ph> element within a <ph id="ph2">`&lt;PropertyGroup&gt;`</ph> in your <ph id="ph3">`csproj`</ph> file that defines the platforms your app targets and specify the runtime identifier of each platform that you target.</source>
          <target state="translated"><bpt id="p1">[</bpt>간단한 자체 포함 배포<ept id="p1">](#simpleSelf)</ept>에서처럼 <ph id="ph3">`csproj`</ph> 파일의 <ph id="ph2">`&lt;PropertyGroup&gt;`</ph>에서 앱의 대상 플랫폼을 정의하는 <ph id="ph1">`&lt;RuntimeIdentifiers&gt;`</ph> 요소를 만들고 대상으로 지정한 각 플랫폼의 런타임 식별자를 지정합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime IDentifier catalog<ept id="p1">](../../rid-catalog.md)</ept> for a list of runtime identifiers.</source>
          <target state="translated">런타임 식별자 목록은 <bpt id="p1">[</bpt>런타임 식별자 카탈로그<ept id="p1">](../../rid-catalog.md)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For example, the following example indicates that the app runs on 64-bit Windows 10 operating systems and the 64-bit OS X Version 10.11 operating system.</source>
          <target state="translated">예를 들어 다음 예에서는 앱이 64비트 Windows 10 운영 체제 및 64비트 OS X 버전 10.11 운영 체제에서 실행됨을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>A complete sample <ph id="ph1">`csproj`</ph> file appears later in this section.</source>
          <target state="translated">전체 샘플 <ph id="ph1">`csproj`</ph> 파일은 이 섹션의 뒷부분에 나옵니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Run the <ph id="ph1">`dotnet restore`</ph> command to restore the dependencies specified in your project.</source>
          <target state="translated"><ph id="ph1">`dotnet restore`</ph> 명령을 실행하여 프로젝트에 지정된 종속성을 복원합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Create debug builds of your app on each of the target platforms by using the <ph id="ph1">`dotnet build`</ph> command.</source>
          <target state="translated">각 대상 플랫폼에서 <ph id="ph1">`dotnet build`</ph> 명령을 사용하여 앱의 디버그 빌드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Unless you specify the runtime identifier you'd like to build, the <ph id="ph1">`dotnet build`</ph> command creates a build only for the current system's runtime ID.</source>
          <target state="translated">빌드하려는 런타임 식별자를 지정하지 않으면 <ph id="ph1">`dotnet build`</ph> 명령은 현재 시스템의 런타임 ID에 대한 빌드만 만듭니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>You can build your app for both target platforms with the commands:</source>
          <target state="translated">다음 명령을 사용하여 두 대상 플랫폼에 대한 앱을 빌드할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>After you've debugged and tested the program, you can create the files to be deployed with your app for each platform that it targets by using the <ph id="ph1">`dotnet publish`</ph> command for both target platforms as follows:</source>
          <target state="translated">프로그램을 디버그하고 테스트한 후에는 다음과 같이 두 대상 플랫폼에 <ph id="ph1">`dotnet publish`</ph> 명령을 사용하여 각 대상 플랫폼에 대해 앱과 함께 배포할 파일을 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>This creates a release (rather than a debug) version of your app for each target platform.</source>
          <target state="translated">그러면 각 대상 플랫폼에 대해 앱의 디버그가 아닌 릴리스 버전이 만들어집니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The resulting files are placed in a subdirectory named <ph id="ph1">`publish`</ph> that is in a subdirectory of your project's <ph id="ph2">`.\bin\release\netstandard1.6\&lt;runtime_identifier&gt;`</ph> subdirectory.</source>
          <target state="translated">결과 파일은 프로젝트 <ph id="ph2">`.\bin\release\netstandard1.6\&lt;runtime_identifier&gt;`</ph> 하위 디렉터리의 하위 디렉터리에 있는 <ph id="ph1">`publish`</ph>라는 하위 디렉터리에 배치됩니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Note that each subdirectory contains the complete set of files (both your app files and all .NET Core files) needed to launch your app.</source>
          <target state="translated">각 하위 디렉터리에는 앱을 시작하는 데 필요한 전체 파일 집합(앱 파일 및 모든 .NET Core 파일)이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app.</source>
          <target state="translated">게시 프로세스에서는 응용 프로그램의 파일과 함께 앱에 대한 디버깅 정보를 포함하는 프로그램 데이터베이스(.pdb) 파일을 내보냅니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.</source>
          <target state="translated">이 파일은 기본적으로 디버깅 예외에 유용하며 응용 프로그램의 파일과 함께 패키지하지 않도록 선택할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The published files can be deployed in any way you'd like.</source>
          <target state="translated">게시된 파일은 원하는 방식으로 배포할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>For example, you can package them in a zip file, use a simple <ph id="ph1">`copy`</ph> command, or deploy them with any installation package of your choice.</source>
          <target state="translated">예를 들어 zip 파일로 패키지하거나, 간단한 <ph id="ph1">`copy`</ph> 명령을 사용하여 선택한 설치 패키지와 함께 배포할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The following is the complete <ph id="ph1">`csproj`</ph> file for this project.</source>
          <target state="translated">다음은 이 프로젝트에 대한 전체 <ph id="ph1">`csproj`</ph> 파일입니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>