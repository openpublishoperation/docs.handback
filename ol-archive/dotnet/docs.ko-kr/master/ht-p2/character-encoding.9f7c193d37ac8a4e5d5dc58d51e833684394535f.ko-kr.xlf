<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e72540726bdd1b3624064c7388e58d80320c5831</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\character-encoding.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b73b5b21b030d4950c1041bdd0f07aeb8388b963</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b3b23336c2f6d3d51c94110149950c68c41b93a0</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Character encoding in .NET</source>
          <target state="translated">.NET의 문자 인코딩</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Character encoding in .NET</source>
          <target state="translated">.NET의 문자 인코딩</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Character encoding in .NET</source>
          <target state="translated">.NET의 문자 인코딩</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Characters are abstract entities that can be represented in many different ways.</source>
          <target state="translated">문자는 다양한 방법으로 표현할 수 있는 추상 엔터티입니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>A character encoding is a system that pairs each character in a supported character set with some value that represents that character.</source>
          <target state="translated">문자 인코딩은 지원되는 문자 집합의 각 문자와 해당 문자를 나타내는 일부 값의 쌍을 만드는 시스템입니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, Morse code is a character encoding that pairs each character in the Roman alphabet with a pattern of dots and dashes that are suitable for transmission over telegraph lines.</source>
          <target state="translated">예를 들어 모르스 부호는 로마 알파벳의 각 문자와 전화선을 통한 전송에 적합한 점과 대시 패턴의 쌍을 만드는 문자 인코딩입니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A character encoding for computers pairs each character in a supported character set with a numeric value that represents that character.</source>
          <target state="translated">컴퓨터의 문자 인코딩은 지원되는 문자 집합의 각 문자와 해당 문자를 나타내는 숫자 값의 쌍을 만듭니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A character encoding has two distinct components:</source>
          <target state="translated">문자 인코딩에는 다음 두 가지 구성 요소가 있습니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>An encoder, which translates a sequence of characters into a sequence of numeric values (bytes).</source>
          <target state="translated">인코더 - 문자 시퀀스를 숫자 값(바이트) 시퀀스로 변환합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>A decoder, which translates a sequence of bytes into a sequence of characters.</source>
          <target state="translated">디코더 - 바이트 시퀀스를 문자 시퀀스로 변환합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Character encoding describes the rules by which an encoder and a decoder operate.</source>
          <target state="translated">문자 인코딩은 인코더와 디코더가 작동하는 규칙을 설명합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> class describes the rules for encoding to, and decoding from, 8-bit Unicode Transformation Format (UTF-8), which uses one to four bytes to represent a single Unicode character.</source>
          <target state="translated">예를 들어 <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> 클래스는 1~4바이트를 사용하여 단일 유니코드 문자를 나타내는 UTF-8(8비트 유니코드 변환 형식)로 인코드 및 디코드하는 규칙을 설명합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Encoding and decoding can also include validation.</source>
          <target state="translated">인코딩 및 디코딩에 유효성 검사가 포함될 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> class checks all surrogates to make sure they constitute valid surrogate pairs.</source>
          <target state="translated">예를 들어 <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> 클래스는 모든 서로게이트를 검사하여 유효한 서로게이트 쌍을 구성하는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>(A surrogate pair consists of a character with a code point that ranges from U+D800 to U+DBFF followed by a character with a code point that ranges from U+DC00 to U+DFFF.) A fallback strategy determines how an encoder handles invalid characters or how a decoder handles invalid bytes.</source>
          <target state="translated">서로게이트 쌍은 코드 포인트가 U+D800에서 U+DBFF 사이의 범위인 문자와 코드 포인트가 U+DC00에서 U+DFFF 사이의 범위인 문자가 이 순서로 결합되어 구성됩니다. 대체(fallback) 전략은 인코더에서 잘못된 문자를 처리하는 방법 또는 디코더에서 잘못된 바이트를 처리하는 방법을 결정합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The .NET encoding classes provide a way to store and convert character data.</source>
          <target state="translated">.NET 인코딩 클래스는 문자 데이터를 저장 및 변환하는 방법을 제공합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>They should not be used to store binary data in string form.</source>
          <target state="translated">이진 데이터를 문자열 형식으로 저장하는 데 사용하면 안 됩니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Depending on the encoding used, converting binary data to string format with the encoding classes can introduce unexpected behavior and produce inaccurate or corrupted data.</source>
          <target state="translated">사용되는 인코딩에 따라 인코딩 클래스를 통해 이진 데이터를 문자열로 변환할 때 예기치 못한 동작이 발생하고 부정확하거나 손상된 데이터가 생성될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To convert binary data to a string form, use the <bpt id="p1">[</bpt>Convert.ToBase64String<ept id="p1">](xref:System.Convert.ToBase64String(System.Byte[]))</ept> method.</source>
          <target state="translated">이진 데이터를 문자열 형식으로 변환하려면 <bpt id="p1">[</bpt>Convert.ToBase64String<ept id="p1">](xref:System.Convert.ToBase64String(System.Byte[]))</ept> 메서드를 사용합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>.NET uses the UTF-16 encoding (represented by the <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> class) to represent characters and strings.</source>
          <target state="translated">.NET에서는 UTF-16 인코딩(<bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> 클래스로 표시)을 사용하여 문자와 문자열을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Applications that target the common language runtime use encoders to map Unicode character representations supported by the common language runtime to other encoding schemes.</source>
          <target state="translated">공용 언어 런타임을 대상으로 하는 응용 프로그램은 인코더를 사용하여 공용 언어 런타임에서 지원하는 유니코드 문자 표현을 다른 인코딩 체계에 매핑합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>They use decoders to map characters from non-Unicode encodings to Unicode.</source>
          <target state="translated">디코더를 사용하여 문자를 비유니코드 인코딩에서 유니코드로 매핑합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This topic consists of the following sections:</source>
          <target state="translated">이 항목은 다음 섹션으로 구성되어 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Encodings in .NET<ept id="p1">](#encodings-in-net)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>.NET의 인코딩<ept id="p1">](#encodings-in-net)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Selecting an encoding class<ept id="p1">](#selecting-an-encoding-class)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>인코딩 클래스 선택<ept id="p1">](#selecting-an-encoding-class)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using an encoding object<ept id="p1">](#using-an-encoding-object)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>인코딩 개체 사용<ept id="p1">](#using-an-encoding-object)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Choosing a fallback strategy<ept id="p1">](#choosing-a-fallback-strategy)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>대체(fallback) 전략 선택<ept id="p1">](#choosing-a-fallback-strategy)</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>사용자 지정 대체(fallback) 전략 구현<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Encodings in .NET</source>
          <target state="translated">.NET의 인코딩</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>All character encoding classes in .NET inherit from the <bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> class, which is an abstract class that defines the functionality common to all character encodings.</source>
          <target state="translated">.NET의 모든 문자 인코딩 클래스는 모든 문자 인코딩에 공통된 기능을 정의하는 추상 클래스인 <bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> 클래스에서 상속받습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>To access the individual encoding objects implemented in .NET, do the following:</source>
          <target state="translated">.NET에서 구현된 개별 인코딩 개체에 액세스하려면 다음을 수행합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Use the static properties of the <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> class, which return objects that represent the standard character encodings available in .NET (ASCII, UTF-7, UTF-8, UTF-16, and UTF-32).</source>
          <target state="translated">.NET에서 사용할 수 있는 표준 문자 인코딩(ASCII, UTF-7, UTF-8, UTF-16 및 UTF-32)을 나타내는 개체를 반환하는 <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> 클래스의 정적 속성을 사용합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>Encoding.Unicode<ept id="p1">](xref:System.Text.Encoding.Unicode)</ept> property returns a <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept> object.</source>
          <target state="translated">예를 들어 <bpt id="p1">[</bpt>Encoding.Unicode<ept id="p1">](xref:System.Text.Encoding.Unicode)</ept> 속성은 <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Each object uses replacement fallback to handle strings that it cannot encode and bytes that it cannot decode.</source>
          <target state="translated">각 개체는 교체 대체(fallback)를 사용하여 인코딩할 수 없는 문자열과 디코딩할 수 없는 바이트를 처리합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Replacement fallback<ept id="p1">](#replacement-fallback)</ept> section.)</source>
          <target state="translated">(자세한 내용은 <bpt id="p1">[</bpt>교체 대체(fallback)<ept id="p1">](#replacement-fallback)</ept> 섹션을 참조하세요.)</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Call the encoding's class constructor.</source>
          <target state="translated">인코딩의 클래스 생성자를 호출합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Objects for the ASCII, UTF-7, UTF-8, UTF-16, and UTF-32 encodings can be instantiated in this way.</source>
          <target state="translated">이런 방식으로 ASCII, UTF-7, UTF-8, UTF-16 및 UTF-32 인코딩에 대한 개체를 인스턴스화할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>By default, each object uses replacement fallback to handle strings that it cannot encode and bytes that it cannot decode, but you can specify that an exception should be thrown instead.</source>
          <target state="translated">기본적으로 각 개체는 교체 대체(fallback)를 사용하여 인코딩할 수 없는 문자열과 디코딩할 수 없는 바이트를 처리하지만 대신 예외가 발생하도록 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Replacement fallback<ept id="p1">](#replacement-fallback)</ept> and <bpt id="p2">[</bpt>Exception fallback<ept id="p2">](#exception-fallback)</ept> sections.)</source>
          <target state="translated">(자세한 내용은 <bpt id="p1">[</bpt>교체 대체(fallback)<ept id="p1">](#replacement-fallback)</ept> 및 <bpt id="p2">[</bpt>예외 대체(fallback)<ept id="p2">](#exception-fallback)</ept> 섹션을 참조하세요.)</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">[</bpt>Encoding.Encoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> constructor and pass it an integer that represents the encoding.</source>
          <target state="translated"><bpt id="p1">[</bpt>Encoding.Encoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> 생성자를 호출하고 인코딩을 나타내는 정수를 전달합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Standard encoding objects use replacement fallback, and code page and double-byte character set (DBCS) encoding objects use best-fit fallback to handle strings that they cannot encode and bytes that they cannot decode.</source>
          <target state="translated">표준 인코딩 개체는 교체 대체(fallback)를 사용하고, 코드 페이지와 DBCS(더블바이트 문자 집합) 인코딩 개체는 최적 맞춤 대체(fallback)를 사용하여 인코딩할 수 없는 문자열과 디코딩할 수 없는 바이트를 처리합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Best-Fit fallback<ept id="p1">](#best-fit-fallback)</ept> section.)</source>
          <target state="translated">(자세한 내용은 <bpt id="p1">[</bpt>자동 맞춤 대체(fallback)<ept id="p1">](#best-fit-fallback)</ept> 섹션을 참조하세요.)</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">[</bpt>Encoding.GetEncoding<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> method, which returns any standard, code page, or DBCS encoding available in .NET.</source>
          <target state="translated">.NET에서 사용할 수 있는 표준, 코드 페이지 또는 DBCS 인코딩을 반환하는 <bpt id="p1">[</bpt>Encoding.GetEncoding<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> 메서드를 호출합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Overloads let you specify a fallback object for both the encoder and the decoder.</source>
          <target state="translated">오버로드를 통해 인코더와 디코더 둘 다에 대체(fallback) 개체를 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The Unicode Standard assigns a code point (a number) and a name to each character in every supported script.</source>
          <target state="translated">유니코드 표준은 지원되는 모든 스크립트의 각 문자에 코드 포인트(숫자)와 이름을 할당합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For example, the character "A" is represented by the code point U+0041 and the name "LATIN CAPITAL LETTER A".</source>
          <target state="translated">예를 들어 "A" 문자는 코드 포인트 U+0041 및 이름 "LATIN CAPITAL LETTER A"로 표시됩니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The Unicode Transformation Format (UTF) encodings define ways to encode that code point into a sequence of one or more bytes.</source>
          <target state="translated">UTF(유니코드 변환 형식) 인코딩은 코드 포인트를 하나 이상의 바이트 시퀀스로 인코딩하는 방법을 정의합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A Unicode encoding scheme simplifies world-ready application development because it allows characters from any character set to be represented in a single encoding.</source>
          <target state="translated">유니코드 인코딩 체계를 사용하면 모든 문자 집합의 문자를 단일 인코딩으로 나타낼 수 있으므로 국제 응용 프로그램 개발이 간소화됩니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Application developers no longer have to keep track of the encoding scheme that was used to produce characters for a specific language or writing system, and data can be shared among systems internationally without being corrupted.</source>
          <target state="translated">응용 프로그램 개발자가 더 이상 특정 언어나 쓰기 시스템을 위한 문자를 생성하는 데 사용된 인코딩 체계를 추적할 필요가 없으며 손상 없이 전 세계 시스템 간에 데이터를 공유할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>.NET supports three encodings defined by the Unicode standard: UTF-8, UTF-16, and UTF-32.</source>
          <target state="translated">.NET에서는 유니코드 표준에서 정의된 세 가지 인코딩인 UTF-8, UTF-16 및 UTF-32를 지원합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For more information, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode<ept id="p1">](http://www.unicode.org/)</ept> home page.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>유니코드<ept id="p1">](http://www.unicode.org/)</ept> 홈페이지에서 유니코드 표준을 참조하세요.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>.NET supports the character encoding systems listed in the following table.</source>
          <target state="translated">.NET에서는 다음 표에 나열된 문자 인코딩 시스템을 지원합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">인코딩</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">클래스</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Advantages/disadvantages</source>
          <target state="translated">장점/단점</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept></target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Encodes a limited range of characters by using the lower seven bits of a byte.</source>
          <target state="translated">바이트의 하위 7비트를 사용하여 제한된 범위의 문자를 인코딩합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Because this encoding only supports character values from U+0000 through U+007F, in most cases it is inadequate for internationalized applications.</source>
          <target state="translated">이 인코딩은 U+0000에서 U+007F 사이의 문자 값만 지원하므로 대부분의 경우 국제화된 응용 프로그램에는 적합하지 않습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UTF7Encoding<ept id="p1">](xref:System.Text.UTF7Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UTF7Encoding<ept id="p1">](xref:System.Text.UTF7Encoding)</ept></target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Represents characters as sequences of 7-bit ASCII characters.</source>
          <target state="translated">7비트 ASCII 문자 시퀀스로 문자를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Non-ASCII Unicode characters are represented by an escape sequence of ASCII characters.</source>
          <target state="translated">비 ASCII 유니코드 문자는 ASCII 문자의 이스케이프 시퀀스로 표시됩니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>UTF-7 supports protocols such as e-mail and newsgroup protocols.</source>
          <target state="translated">UTF-7은 전자 메일 및 뉴스 그룹 프로토콜과 같은 프로토콜을 지원합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>However, UTF-7 is not particularly secure or robust.</source>
          <target state="translated">그러나 UTF-7은 특별히 안전하거나 강력하지 않습니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In some cases, changing one bit can radically alter the interpretation of an entire UTF-7 string.</source>
          <target state="translated">경우에 따라 1비트를 변경해도 전체 UTF-7 문자열의 해석이 완전히 바뀔 수 있습니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In other cases, different UTF-7 strings can encode the same text.</source>
          <target state="translated">다른 UTF-7 문자열이 동일한 텍스트를 인코딩할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For sequences that include non-ASCII characters, UTF-7 requires more space than UTF-8, and encoding/decoding is slower.</source>
          <target state="translated">비 ASCII 문자를 포함하는 시퀀스의 경우 UTF-7에서 UTF-8보다 많은 공간이 필요하며 인코딩/디코딩 속도가 느려집니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Consequently, you should use UTF-8 instead of UTF-7 if possible.</source>
          <target state="translated">따라서 가능하면 UTF-7 대신 UTF-8을 사용해야 합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a sequence of one to four bytes.</source>
          <target state="translated">각 유니코드 코드 포인트를 1-4바이트의 시퀀스로 나타냅니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>UTF-8 supports 8-bit data sizes and works well with many existing operating systems.</source>
          <target state="translated">UTF-8은 8비트 데이터 크기를 지원하며 기존의 많은 운영 체제에서 제대로 작동합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For the ASCII range of characters, UTF-8 is identical to ASCII encoding and allows a broader set of characters.</source>
          <target state="translated">ASCII 문자 범위의 경우 UTF-8은 ASCII 인코딩과 동일하며 광범위한 문자 집합을 허용합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, for Chinese-Japanese-Korean (CJK) scripts, UTF-8 can require three bytes for each character, and can potentially cause larger data sizes than UTF-16.</source>
          <target state="translated">그러나 CJK(중국어-일본어-한국어) 스크립트의 경우 UTF-8에서 각 문자에 대해 3바이트를 요구할 수 있으며 데이터 크기가 UTF-16보다 커질 수 있습니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Note that sometimes the amount of ASCII data, such as HTML tags, justifies the increased size for the CJK range.</source>
          <target state="translated">때로는 HTML 태그와 같은 ASCII 데이터의 양이 CJK 범위의 크기 증가와 관련이 있습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a sequence of one or two 16-bit integers.</source>
          <target state="translated">각 유니코드 코드 포인트를 한두 개의 16비트 정수 시퀀스로 나타냅니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Most common Unicode characters require only one UTF-16 code point, although Unicode supplementary characters (U+10000 and greater) require two UTF-16 surrogate code points.</source>
          <target state="translated">가장 일반적인 유니코드 문자에는 UTF-16 코드 포인트 한 개만 있으면 됩니다. 단, 유니코드 보조 문자(U+10000 이상)에는 UTF-16 서로게이트 코드 포인트 두 개가 필요합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Both little-endian and big-endian byte orders are supported.</source>
          <target state="translated">little-endian 및 big-endian 바이트 순서가 둘 다 지원됩니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>UTF-16 encoding is used by the common language runtime to represent Char and String values, and it is used by the Windows operating system to represent WCHAR values.</source>
          <target state="translated">UTF-16 인코딩은 공용 언어 런타임에서 Char 및 String 값을 나타내는 데 사용되며 Windows 운영 체제에서 WCHAR 값을 나타내는 데 사용됩니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a 32-bit integer.</source>
          <target state="translated">각 유니코드 코드 포인트를 32비트 정수 한 개로 나타냅니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Both little-endian and big-endian byte orders are supported.</source>
          <target state="translated">little-endian 및 big-endian 바이트 순서가 둘 다 지원됩니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>UTF-32 encoding is used when applications want to avoid the surrogate code point behavior of UTF-16 encoding on operating systems for which encoded space is too important.</source>
          <target state="translated">UTF-32 인코딩은 인코딩된 공간이 너무 중요한 운영 체제에서 응용 프로그램이 UTF-16 인코딩의 서로게이트 코드 포인트 동작을 방지하려는 경우에 사용됩니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Single glyphs rendered on a display can still be encoded with more than one UTF-32 character.</source>
          <target state="translated">디스플레이에 렌더링되는 단일 문자 모양은 여전히 둘 이상의 UTF-32 문자로 인코딩될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>These encodings enable you to work with Unicode characters as well as with encodings that are most commonly used in legacy applications.</source>
          <target state="translated">이러한 인코딩을 통해 유니코드 문자는 물론 레거시 응용 프로그램에서 가장 일반적으로 사용되는 인코딩으로 작업할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>In addition, you can create a custom encoding by defining a class that derives from <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> and overriding its members.</source>
          <target state="translated">또한 <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept>에서 파생되는 클래스를 정의하고 해당 멤버를 재정의하여 사용자 지정 인코딩을 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>By default, .NET Core does not make available any code page encodings other than code page 28591 and the Unicode encodings, such as UTF-8 and UTF-16.</source>
          <target state="translated">기본적으로 .NET Core에서는 코드 페이지 28591 이외의 코드 페이지 인코딩 및 유니코드 인코딩(예: UTF-8 및 UTF-16)을 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>However, you can add the code page encodings found in standard Windows apps that target the .NET Framework to your app.</source>
          <target state="translated">그러나 .NET Framework를 대상으로 하는 표준 Windows 앱에 있는 코드 페이지 인코딩을 해당 앱에 추가할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For complete information, see the <bpt id="p1">[</bpt>EncodingProvider<ept id="p1">](xref:System.Text.EncodingProvider)</ept> topic.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>EncodingProvider<ept id="p1">](xref:System.Text.EncodingProvider)</ept> 항목을 참조하세요.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Selecting an Encoding class</source>
          <target state="translated">인코딩 클래스 선택</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If you have the opportunity to choose the encoding to be used by your application, you should use a Unicode encoding, preferably either <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> or <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>.</source>
          <target state="translated">응용 프로그램에서 사용할 인코딩을 선택할 수 있는 경우 유니코드 인코딩인 <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> 또는 <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>을 사용해야 합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>(.NET also supports a third Unicode encoding, <bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept>.)</source>
          <target state="translated">.NET에서는 세 번째 유니코드 인코딩인 <bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept>도 지원합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If you are planning to use an ASCII encoding (<bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>), choose <bpt id="p2">[</bpt>UTF8Encoding<ept id="p2">](xref:System.Text.UTF8Encoding)</ept> instead.</source>
          <target state="translated">ASCII 인코딩(<bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>)을 사용하려는 경우 <bpt id="p2">[</bpt>UTF8Encoding<ept id="p2">](xref:System.Text.UTF8Encoding)</ept>을 대신 선택합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The two encodings are identical for the ASCII character set, but <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> has the following advantages:</source>
          <target state="translated">ASCII 문자 집합의 경우 두 인코딩이 동일하지만 <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>에는 다음과 같은 이점이 있습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>It can represent every Unicode character, whereas <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> supports only the Unicode character values between U+0000 and U+007F.</source>
          <target state="translated"><bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>은 U+0000에서 U+007F 사이의 유니코드 문자 값만 지원하는 반면, 모든 유니코드 문자를 나타낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>It provides error detection and better security.</source>
          <target state="translated">오류 검색 및 향상된 보안을 제공합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>It has been tuned to be as fast as possible and should be faster than any other encoding.</source>
          <target state="translated">최대한 빠르도록 조정되었으며 다른 인코딩보다 더 빨라야 합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Even for content that is entirely ASCII, operations performed with <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> are faster than operations performed with <bpt id="p2">[</bpt>ASCIIEncoding<ept id="p2">](xref:System.Text.ASCIIEncoding)</ept>.</source>
          <target state="translated">완전히 ASCII인 콘텐츠의 경우에도 <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>으로 수행된 작업이 <bpt id="p2">[</bpt>ASCIIEncoding<ept id="p2">](xref:System.Text.ASCIIEncoding)</ept>으로 수행된 작업보다 더 빠릅니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>You should consider using <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> only for legacy applications.</source>
          <target state="translated"><bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>은 레거시 응용 프로그램에만 사용해야 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>However, even for legacy applications, <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> might be a better choice for the following reasons (assuming default settings):</source>
          <target state="translated">그러나 레거시 응용 프로그램의 경우에도 다음과 같은 이유로 <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>이 더 적합할 수 있습니다(기본 설정 가정).</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If your application has content that is not strictly ASCII and encodes it with <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>, each non-ASCII character encodes as a question mark (?).</source>
          <target state="translated">응용 프로그램에 엄격하게 ASCII가 아닌 콘텐츠가 있고 <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>으로 인코드하는 경우 각각의 비 ASCII 문자가 물음표(?)로 인코드됩니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If the application then decodes this data, the information is lost.</source>
          <target state="translated">그런 후에 응용 프로그램에서 이 데이터를 디코딩하면 정보가 손실됩니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If your application has content that is not strictly ASCII and encodes it with <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>, the result seems unintelligible if interpreted as ASCII.</source>
          <target state="translated">응용 프로그램에 엄격하게 ASCII가 아닌 콘텐츠가 있고 <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>으로 인코드하는 경우 결과를 ASCII로 해석하면 인식할 수 없는 것처럼 보입니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>However, if the application then uses a UTF-8 decoder to decode this data, the data performs a round trip successfully.</source>
          <target state="translated">그러나 응용 프로그램이 UTF-8 디코더를 사용하여 이 데이터를 디코딩하면 데이터가 성공적으로 라운드트립을 수행합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In a web application, characters sent to the client in response to a web request should reflect the encoding used on the client.</source>
          <target state="translated">웹 응용 프로그램에서는 웹 요청에 대한 응답으로 클라이언트에 전송되는 문자가 클라이언트에서 사용되는 인코딩을 반영해야 합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In most cases, you should set the <bpt id="p1">[</bpt>HttpResponse.ContentEncoding<ept id="p1">](xref:System.Net.HttpResponseHeader.ContentEncoding)</ept> property to the value returned by the <bpt id="p2">[</bpt>HttpRequestHeader.ContentEncoding<ept id="p2">](xref:System.Net.HttpRequestHeader.ContentEncoding)</ept> property to display text in the encoding that the user expects.</source>
          <target state="translated">대부분의 경우 사용자에게 필요한 인코딩으로 텍스트를 표시하기 위해 <bpt id="p1">[</bpt>HttpResponse.ContentEncoding<ept id="p1">](xref:System.Net.HttpResponseHeader.ContentEncoding)</ept> 속성을 <bpt id="p2">[</bpt>HttpRequestHeader.ContentEncoding<ept id="p2">](xref:System.Net.HttpRequestHeader.ContentEncoding)</ept> 속성에서 반환된 값으로 설정해야 합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Using an encoding object</source>
          <target state="translated">인코딩 개체 사용</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>An encoder converts a string of characters (most commonly, Unicode characters) to its numeric (byte) equivalent.</source>
          <target state="translated">인코더는 문자의 문자열(가장 일반적으로 유니코드 문자)을 해당 숫자(바이트)로 변환합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For example, you might use an ASCII encoder to convert Unicode characters to ASCII so that they can be displayed at the console.</source>
          <target state="translated">예를 들어 콘솔에 표시될 수 있도록 ASCII 인코더를 사용하여 유니코드 문자를 ASCII로 변환할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>To perform the conversion, you call the <bpt id="p1">[</bpt>Encoding.GetBytes<ept id="p1">](xref:System.Text.Encoding.GetBytes(System.Char[]))</ept> method.</source>
          <target state="translated">변환을 수행하려면 <bpt id="p1">[</bpt>Encoding.GetBytes<ept id="p1">](xref:System.Text.Encoding.GetBytes(System.Char[]))</ept> 메서드를 호출합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>If you want to determine how many bytes are needed to store the encoded characters before performing the encoding, you can call the <bpt id="p1">[</bpt>GetByteCount<ept id="p1">](xref:System.Text.Encoding.GetByteCount(System.Char[]))</ept> method.</source>
          <target state="translated">인코딩을 수행하기 전에 인코딩된 문자를 저장하는 데 필요한 바이트 수를 확인하려는 경우 <bpt id="p1">[</bpt>GetByteCount<ept id="p1">](xref:System.Text.Encoding.GetByteCount(System.Char[]))</ept> 메서드를 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following example uses a single byte array to encode strings in two separate operations.</source>
          <target state="translated">다음 예제에서는 싱글바이트 배열을 사용하여 두 개의 별도 작업에서 문자열을 인코딩합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It maintains an index that indicates the starting position in the byte array for the next set of ASCII-encoded bytes.</source>
          <target state="translated">바이트 배열에서 ASCII로 인코딩된 다음 바이트 집합의 시작 위치를 나타내는 인덱스를 유지 관리합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It calls the <bpt id="p1">[</bpt>ASCIIEncoding.GetByteCount(String)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetByteCount(System.String))</ept> method to ensure that the byte array is large enough to accommodate the encoded string.</source>
          <target state="translated"><bpt id="p1">[</bpt>ASCIIEncoding.GetByteCount(String)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetByteCount(System.String))</ept> 메서드를 호출하여 바이트 배열이 인코드된 문자열을 포함하기에 충분히 큰지 확인합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>It then calls the <bpt id="p1">[</bpt>ASCIIEncoding.GetBytes(String, Int32, Int32, Byte[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32))</ept> method to encode the characters in the string.</source>
          <target state="translated">그런 다음 <bpt id="p1">[</bpt>ASCIIEncoding.GetBytes(String, Int32, Int32, Byte[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32))</ept> 메서드를 호출하여 문자열의 문자를 인코드합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>A decoder converts a byte array that reflects a particular character encoding into a set of characters, either in a character array or in a string.</source>
          <target state="translated">디코더는 특정 문자 인코딩을 반영하는 바이트 배열을 문자 배열 또는 문자열의 문자 집합으로 변환합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>To decode a byte array into a character array, you call the <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> method.</source>
          <target state="translated">바이트 배열을 문자 배열로 디코드하려면 <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> 메서드를 호출합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>To decode a byte array into a string, you call the <bpt id="p1">[</bpt>GetString<ept id="p1">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept> method.</source>
          <target state="translated">바이트 배열을 문자열로 디코드하려면 <bpt id="p1">[</bpt>GetString<ept id="p1">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept> 메서드를 호출합니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If you want to determine how many characters are needed to store the decoded bytes before performing the decoding, you can call the <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> method.</source>
          <target state="translated">디코딩을 수행하기 전에 디코드된 바이트를 저장하는 데 필요한 문자 수를 확인하려는 경우 <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> 메서드를 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The following example encodes three strings and then decodes them into a single array of characters.</source>
          <target state="translated">다음 예제에서는 세 개의 문자열을 인코딩한 후 단일 문자 배열로 디코딩합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>It maintains an index that indicates the starting position in the character array for the next set of decoded characters.</source>
          <target state="translated">문자 배열에서 디코딩된 다음 문자 집합의 시작 위치를 나타내는 인덱스를 유지 관리합니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>It calls the <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> method to ensure that the character array is large enough to accommodate all the decoded characters.</source>
          <target state="translated"><bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> 메서드를 호출하여 문자 배열이 디코드된 모든 문자를 포함하기에 충분히 큰지 확인합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>It then calls the <bpt id="p1">[</bpt>ASCIIEncoding.GetChars(Byte[], Int32, Int32, Char[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> method to decode the byte array.</source>
          <target state="translated">그런 다음 <bpt id="p1">[</bpt>ASCIIEncoding.GetChars(Byte[], Int32, Int32, Char[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> 메서드를 호출하여 바이트 배열을 디코드합니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The encoding and decoding methods of a class derived from <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> are designed to work on a complete set of data; that is, all the data to be encoded or decoded is supplied in a single method call.</source>
          <target state="translated"><bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept>에서 파생된 클래스의 인코딩 및 디코딩 메서드는 전체 데이터 집합에서 작동하도록 설계되었습니다. 즉, 인코드 또는 디코드할 모든 데이터가 단일 메서드 호출에서 제공됩니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>However, in some cases, data is available in a stream, and the data to be encoded or decoded may be available only from separate read operations.</source>
          <target state="translated">그러나 스트림으로 데이터가 제공되고, 인코딩 또는 디코딩할 데이터를 별도의 읽기 작업에서만 사용할 수 있는 경우도 있습니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>This requires the encoding or decoding operation to remember any saved state from its previous invocation.</source>
          <target state="translated">이 경우 인코딩 또는 디코딩 작업이 이전 호출에서 저장된 상태를 기억해야 합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Methods of classes derived from <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> and <bpt id="p2">[</bpt>Decoder<ept id="p2">](xref:System.Text.Decoder)</ept> are able to handle encoding and decoding operations that span multiple method calls.</source>
          <target state="translated"><bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> 및 <bpt id="p2">[</bpt>Decoder<ept id="p2">](xref:System.Text.Decoder)</ept>에서 파생된 클래스의 메서드는 여러 메서드 호출에 걸쳐 있는 인코딩 및 디코딩 작업을 처리할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> object for a particular encoding is available from that encoding's <bpt id="p2">[</bpt>Encoding.GetEncoder<ept id="p2">](xref:System.Text.Encoding.GetEncoder)</ept> property.</source>
          <target state="translated">특정 인코딩에 대한 <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> 개체는 해당 인코딩의 <bpt id="p2">[</bpt>Encoding.GetEncoder<ept id="p2">](xref:System.Text.Encoding.GetEncoder)</ept> 속성에서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> object for a particular encoding is available from that encoding's <bpt id="p2">[</bpt>Encoding.GetDecoder<ept id="p2">](xref:System.Text.Encoding.GetDecoder)</ept> property.</source>
          <target state="translated">특정 인코딩에 대한 <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> 개체는 해당 인코딩의 <bpt id="p2">[</bpt>Encoding.GetDecoder<ept id="p2">](xref:System.Text.Encoding.GetDecoder)</ept> 속성에서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For decoding operations, note that classes derived from <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> include a <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> method, but they do not have a method that corresponds to <bpt id="p3">[</bpt>Encoding.GetString<ept id="p3">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept>.</source>
          <target state="translated">디코딩 작업의 경우 <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept>에서 파생된 클래스에 <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> 메서드가 포함되어 있지만 <bpt id="p3">[</bpt>Encoding.GetString<ept id="p3">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept>에 해당하는 메서드가 없습니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between using the <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> and <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> methods for decoding a Unicode byte array.</source>
          <target state="translated">다음 예제에서는 유니코드 바이트 배열 디코드에 <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> 및 <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> 메서드를 사용할 경우의 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The example encodes a string that contains some Unicode characters to a file, and then uses the two decoding methods to decode them ten bytes at a time.</source>
          <target state="translated">이 예제에서는 일부 유니코드 문자를 포함하는 문자열을 파일로 인코딩한 다음 두 개의 디코딩 메서드를 사용하여 한 번에 10바이트씩 디코딩합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Because a surrogate pair occurs in the tenth and eleventh bytes, it is decoded in separate method calls.</source>
          <target state="translated">10번째 및 11번째 바이트에서 서로게이트 쌍이 발생하기 때문에 별도 메서드 호출에서 디코딩됩니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>As the output shows, the <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> method is not able to correctly decode the bytes and instead replaces them with U+FFFD (REPLACEMENT CHARACTER).</source>
          <target state="translated">출력에서 볼 수 있듯이 <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> 메서드는 바이트를 올바르게 디코드할 수 없으며, 대신 U+FFFD(REPLACEMENT CHARACTER)로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>On the other hand, the <bpt id="p1">[</bpt>Decoder.GetChars<ept id="p1">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> method is able to successfully decode the byte array to get the original string.</source>
          <target state="translated">반면, <bpt id="p1">[</bpt>Decoder.GetChars<ept id="p1">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> 메서드는 바이트 배열을 성공적으로 디코드하여 원래 문자열을 가져올 수 있습니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Choosing a fallback strategy</source>
          <target state="translated">대체(fallback) 전략 선택</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>When a method tries to encode or decode a character but no mapping exists, it must implement a fallback strategy that determines how the failed mapping should be handled.</source>
          <target state="translated">메서드가 문자를 인코딩 또는 디코딩하려고 하는데 매핑이 없는 경우 실패한 매핑의 처리 방법을 결정하는 대체(fallback) 전략을 구현해야 합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>There are three types of fallback strategies:</source>
          <target state="translated">다음 세 가지 유형의 대체 (fallback) 전략이 있습니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Best-fit fallback</source>
          <target state="translated">자동 맞춤 대체(fallback)</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Replacement fallback</source>
          <target state="translated">교체 대체(fallback)</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Exception fallback</source>
          <target state="translated">예외 대체(fallback)</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The most common problems in encoding operations occur when a Unicode character cannot be mapped to a particular code page encoding.</source>
          <target state="translated">인코딩 작업의 가장 일반적인 문제는 유니코드 문자를 특정 코드 페이지 인코딩에 매핑할 수 없는 경우에 발생합니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The most common problems in decoding operations occur when invalid byte sequences cannot be translated into valid Unicode characters.</source>
          <target state="translated">디코딩 작업의 가장 일반적인 문제는 잘못된 바이트 시퀀스를 유효한 유니코드 문자로 변환할 수 없는 경우에 발생합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>For these reasons, you should know which fallback strategy a particular encoding object uses.</source>
          <target state="translated">이러한 이유로 특정 인코딩 개체에서 사용하는 대체(fallback) 전략을 알고 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should specify the fallback strategy used by an encoding object when you instantiate the object.</source>
          <target state="translated">가능하면 개체를 인스턴스화할 때 인코딩 개체에서 사용할 대체(fallback) 전략을 지정해야 합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Best-fit fallback</source>
          <target state="translated">최적 대체(fallback)</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>When a character does not have an exact match in the target encoding, the encoder can try to map it to a similar character.</source>
          <target state="translated">대상 인코딩에 문자와 정확히 일치하는 항목이 없을 경우 인코더가 유사한 문자에 매핑하려고 시도할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>(Best-fit fallback is mostly an encoding rather than a decoding issue.</source>
          <target state="translated">최적 대체(fallback)는 주로 디코딩 문제가 아니라 인코딩 문제입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>There are very few code pages that contain characters that cannot be successfully mapped to Unicode.) Best-fit fallback is the default for code page and double-byte character set encodings that are retrieved by the <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> and <bpt id="p2">[</bpt>Encoding.GetEncoding(String)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.String))</ept> overloads.</source>
          <target state="translated">성공적으로 유니코드에 매핑할 수 없는 문자가 포함된 코드 페이지는 거의 없습니다. 최적 대체(fallback)는 <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> 및 <bpt id="p2">[</bpt>Encoding.GetEncoding(String)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.String))</ept> 오버로드를 통해 검색된 코드 페이지 및 더블바이트 문자 집합 인코딩의 기본값입니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>In theory, the Unicode encoding classes provided in .NET (<bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>, <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>, and <bpt id="p3">[</bpt>UTF32Encoding<ept id="p3">](xref:System.Text.UTF32Encoding)</ept>) support every character in every character set, so they can be used to eliminate best-fit fallback issues.</source>
          <target state="translated">이론적으로 .NET에서 제공되는 유니코드 인코딩 클래스(<bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>, <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept> 및 <bpt id="p3">[</bpt>UTF32Encoding<ept id="p3">](xref:System.Text.UTF32Encoding)</ept>)는 모든 문자 집합의 모든 문자를 지원하므로 최적 대체(fallback) 문제를 제거하는 데 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Best-fit strategies vary for different code pages, and they are not documented in detail.</source>
          <target state="translated">최적 전략은 코드 페이지마다 다르며 자세히 문서화되지 않습니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>For example, for some code pages, full-width Latin characters map to the more common half-width Latin characters.</source>
          <target state="translated">예를 들어 일부 코드 페이지에서는 전자 라틴 문자가 더 일반적인 반자 라틴 문자에 매핑됩니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>For other code pages, this mapping is not made.</source>
          <target state="translated">다른 코드 페이지에서는 이 매핑이 수행되지 않습니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Even under an aggressive best-fit strategy, there is no imaginable fit for some characters in some encodings.</source>
          <target state="translated">적극적인 최적 전략에서도 일부 인코딩의 일부 문자는 상상할 수 있는 최적 항목이 없습니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example, a Chinese ideograph has no reasonable mapping to code page 1252.</source>
          <target state="translated">예를 들어 중국어 표의 문자에는 코드 페이지 1252에 적합한 매핑이 없습니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>In this case, a replacement string is used.</source>
          <target state="translated">이 경우 대체 문자열이 사용됩니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>By default, this string is just a single QUESTION MARK (U+003F).</source>
          <target state="translated">기본적으로 이 문자열은 단일 QUESTION MARK(U+003F)입니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The following example uses code page 1252 (the Windows code page for Western European languages) to illustrate best-fit mapping and its drawbacks.</source>
          <target state="translated">다음 예제에서는 코드 페이지 1252(서유럽 언어에 대한 Windows 코드 페이지)를 사용하여 최적 매핑과 해당 결점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> method is used to retrieve an encoding object for code page 1252.</source>
          <target state="translated"><bpt id="p1">[</bpt>Encoding.GetEncoding(Int32<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> 메서드는 코드 페이지 1252에 대한 인코딩 개체를 검색하는 데 사용됩니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>By default, it uses a best-fit mapping for Unicode characters that it does not support.</source>
          <target state="translated">기본적으로 지원하지 않는 유니코드 문자에 대해 최적 매핑을 사용합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The example instantiates a string that contains three non-ASCII characters - CIRCLED LATIN CAPITAL LETTER S (U+24C8), SUPERSCRIPT FIVE (U+2075), and INFINITY (U+221E) - separated by spaces.</source>
          <target state="translated">이 예제에서는 CIRCLED LATIN CAPITAL LETTER S(U+24C8), SUPERSCRIPT FIVE(U+2075) 및 INFINITY(U+221E)라는 3개의 비 ASCII 문자가 공백으로 구분되어 포함된 문자열을 인스턴스화합니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, when the string is encoded, the three original non-space characters are replaced by QUESTION MARK (U+003F), DIGIT FIVE (U+0035), and DIGIT EIGHT (U+0038).</source>
          <target state="translated">예제의 출력에서 볼 수 있듯이, 문자열을 인코딩할 때 공백이 아닌 원래 문자 3자가 QUESTION MARK(U+003F), DIGIT FIVE(U+0035) 및 DIGIT EIGHT(U+0038)으로 대체됩니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>DIGIT EIGHT is a particularly poor replacement for the unsupported INFINITY character, and QUESTION MARK indicates that no mapping was available for the original character.</source>
          <target state="translated">DIGIT EIGHT은 지원되지 않는 INFINITY 문자에 대한 특히 부적절한 대체이고, QUESTION MARK는 원래 문자에 사용할 수 있는 매핑이 없음을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Best-fit mapping is the default behavior for an <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> object that encodes Unicode data into code page data, and there are legacy applications that rely on this behavior.</source>
          <target state="translated">최적 매핑은 유니코드 데이터를 코드 페이지 데이터로 인코드하는 <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> 개체의 기본 동작이며, 이 동작을 사용하는 레거시 응용 프로그램이 있습니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>However, most new applications should avoid best-fit behavior for security reasons.</source>
          <target state="translated">그러나 대부분의 새 응용 프로그램은 보안상의 이유로 최적 동작을 피해야 합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For example, applications should not put a domain name through a best-fit encoding.</source>
          <target state="translated">예를 들어 응용 프로그램에서 최적 인코딩을 통해 도메인 이름을 넣으면 안 됩니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>You can also implement a custom best-fit fallback mapping for an encoding.</source>
          <target state="translated">인코딩에 대한 사용자 지정 최적 대체(fallback) 매핑을 구현할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> section.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>사용자 지정 대체(fallback) 전략 구현<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>If best-fit fallback is the default for an encoding object, you can choose another fallback strategy when you retrieve an <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> object by calling the <bpt id="p2">[</bpt>Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> or <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> overload.</source>
          <target state="translated">최적 대체(fallback)가 인코딩 개체에 대한 기본값인 경우 <bpt id="p2">[</bpt>Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> 또는 <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> 오버로드를 호출하여 <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> 개체를 검색할 때 다른 대체(fallback) 전략을 선택할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The following section includes an example that replaces each character that cannot be mapped to code page 1252 with an asterisk (<ph id="ph1">\*</ph>).</source>
          <target state="translated">다음 섹션에는 코드 페이지 1252로 매핑할 수 없는 각 문자를 별표(<ph id="ph1">\*</ph>)로 대체하는 예제가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Replacement fallback</source>
          <target state="translated">교체 대체(fallback)</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>When a character does not have an exact match in the target scheme, but there is no appropriate character that it can be mapped to, the application can specify a replacement character or string.</source>
          <target state="translated">대상 구성표에 문자와 정확히 일치하는 항목이 없고 매핑할 수 있는 적절한 문자가 없는 경우 응용 프로그램에서 대체 문자 또는 문자열을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>This is the default behavior for the Unicode decoder, which replaces any two-byte sequence that it cannot decode with REPLACEMENT_CHARACTER (U+FFFD).</source>
          <target state="translated">이는 유니코드 디코더의 기본 동작으로, 디코딩할 수 없는 모든 2바이트 시퀀스를 REPLACEMENT_CHARACTER(U+FFFD)로 대체합니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>It is also the default behavior of the <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> class, which replaces each character that it cannot encode or decode with a question mark.</source>
          <target state="translated"><bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> 클래스의 기본 동작이기도 하며, 인코드 또는 디코드할 수 없는 각 문자를 물음표로 대체합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The following example illustrates character replacement for the Unicode string from the previous example.</source>
          <target state="translated">다음 예제에서는 이전 예제의 유니코드 문자열에 대한 문자 대체를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>As the output shows, each character that cannot be decoded into an ASCII byte value is replaced by 0x3F, which is the ASCII code for a question mark.</source>
          <target state="translated">출력에서 볼 수 있듯이, ASCII 바이트 값으로 디코딩할 수 없는 각 문자는 물음표의 ASCII 코드인 0x3F로 대체됩니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>.NET includes the <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> and <bpt id="p2">[</bpt>DecoderReplacementFallback<ept id="p2">](xref:System.Text.DecoderReplacementFallback)</ept> classes, which substitute a replacement string if a character does not map exactly in an encoding or decoding operation.</source>
          <target state="translated">.NET에는 문자가 인코딩 또는 디코딩 작업에서 정확히 매핑되지 않는 경우 대체 문자열로 바꾸는 <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> 및 <bpt id="p2">[</bpt>DecoderReplacementFallback<ept id="p2">](xref:System.Text.DecoderReplacementFallback)</ept> 클래스가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>By default, this replacement string is a question mark, but you can call a class constructor overload to choose a different string.</source>
          <target state="translated">기본적으로 이 대체 문자열은 물음표지만 클래스 생성자 오버로드를 호출하여 다른 문자열을 선택할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Typically, the replacement string is a single character, although this is not a requirement.</source>
          <target state="translated">요구 사항은 아니지만 일반적으로 대체 문자열은 단일 문자입니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The following example changes the behavior of the code page 1252 encoder by instantiating an <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> object that uses an asterisk (<ph id="ph1">\*</ph>) as a replacement string.</source>
          <target state="translated">다음 예제에서는 별표(<ph id="ph1">\*</ph>)를 사용하는 <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> 개체를 대체 문자열로 인스턴스화하여 코드 페이지 1252 인코더의 동작을 변경합니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>You can also implement a replacement class for an encoding.</source>
          <target state="translated">인코딩에 대한 대체 클래스를 구현할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> section.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>사용자 지정 대체(fallback) 전략 구현<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>In addition to QUESTION MARK (U+003F), the Unicode REPLACEMENT CHARACTER (U+FFFD) is commonly used as a replacement string, particularly when decoding byte sequences that cannot be successfully translated into Unicode characters.</source>
          <target state="translated">QUESTION MARK(U+003F) 외에도 일반적으로 유니코드 REPLACEMENT CHARACTER(U+FFFD)가 대체 문자열로 사용됩니다. 특히 유니코드 문자로 변환할 수 없는 바이트 시퀀스를 디코딩하는 경우에 해당합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>However, you are free to choose any replacement string, and it can contain multiple characters.</source>
          <target state="translated">그러나 자유롭게 대체 문자열을 선택할 수 있으며 여러 문자를 포함할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Exception fallback</source>
          <target state="translated">예외 대체(fallback)</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Instead of providing a best-fit fallback or a replacement string, an encoder can throw an <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> if it is unable to encode a set of characters, and a decoder can throw a <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> if it is unable to decode a byte array.</source>
          <target state="translated">최적 대체(fallback) 또는 대체 문자열을 제공하는 대신 인코더는 문자 집합을 인코드할 수 없는 경우 <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept>을 throw하고, 디코더는 바이트 배열을 디코드할 수 없는 경우 <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept>을 throw할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>To throw an exception in encoding and decoding operations, you supply an <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> object and a <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> object, respectively, to the <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> method.</source>
          <target state="translated">인코딩 및 디코딩 작업에서 예외를 throw하기 위해 각각 <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> 개체와 <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> 개체를 <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> 메서드에 제공합니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The following example illustrates exception fallback with the ASCIIEncoding class.</source>
          <target state="translated">다음 예제에서는 ASCIIEncoding 클래스를 사용한 예외 대체(fallback)를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>You can also implement a custom exception handler for an encoding operation.</source>
          <target state="translated">인코딩 작업에 대한 사용자 지정 예외 처리기를 구현할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> section.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>사용자 지정 대체(fallback) 전략 구현<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> and <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> objects provide the following information about the condition that caused the exception:</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> 및 <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> 개체는 예외를 발생시킨 조건에 대한 다음 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> object includes an <bpt id="p2">[</bpt>IsUnknownSurrogate<ept id="p2">](xref:System.Text.EncoderFallbackException.IsUnknownSurrogate)</ept> method, which indicates whether the character or characters that cannot be encoded represent an unknown surrogate pair (in which case, the method returns <ph id="ph1">`true`</ph>) or an unknown single character (in which case, the method returns <ph id="ph2">`false`</ph>).</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> 개체에는 인코드할 수 없는 문자가 알 수 없는 서로게이트 쌍을 나타내는지(이 경우 메서드에서 <ph id="ph1">`true`</ph>가 반환됨) 또는 알 수 없는 단일 문자를 나타내는지(이 경우 메서드에서 <ph id="ph2">`false`</ph>가 반환됨)를 표시하는 <bpt id="p2">[</bpt>IsUnknownSurrogate<ept id="p2">](xref:System.Text.EncoderFallbackException.IsUnknownSurrogate)</ept> 메서드가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The characters in the surrogate pair are available from the <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknownHigh<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknownHigh)</ept> and <bpt id="p2">[</bpt>EncoderFallbackException.CharUnknownLow<ept id="p2">](xref:System.Text.EncoderFallbackException.CharUnknownLow)</ept> properties.</source>
          <target state="translated">서로게이트 쌍의 문자는 <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknownHigh<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknownHigh)</ept> 및 <bpt id="p2">[</bpt>EncoderFallbackException.CharUnknownLow<ept id="p2">](xref:System.Text.EncoderFallbackException.CharUnknownLow)</ept> 속성에서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The unknown single character is available from the <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknown<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknown)</ept> property.</source>
          <target state="translated">알 수 없는 단일 문자는 <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknown<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknown)</ept> 속성에서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackException.Index<ept id="p1">](xref:System.Text.EncoderFallbackException.Index)</ept> property indicates the position in the string at which the first character that could not be encoded was found.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackException.Index<ept id="p1">](xref:System.Text.EncoderFallbackException.Index)</ept> 속성은 인코드할 수 없는 첫 번째 문자가 발견된 문자열의 위치를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>DecoderFallbackException<ept id="p1">](xref:System.Text.DecoderFallbackException)</ept> object includes a <bpt id="p2">[</bpt>BytesUnknown<ept id="p2">](xref:System.Text.DecoderFallbackException.BytesUnknown)</ept> property that returns an array of bytes that cannot be decoded.</source>
          <target state="translated"><bpt id="p1">[</bpt>DecoderFallbackException<ept id="p1">](xref:System.Text.DecoderFallbackException)</ept> 개체에는 디코드할 수 없는 바이트 배열을 반환하는 <bpt id="p2">[</bpt>BytesUnknown<ept id="p2">](xref:System.Text.DecoderFallbackException.BytesUnknown)</ept> 속성이 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>DecoderFallbackException.Index<ept id="p1">](xref:System.Text.DecoderFallbackException.Index)</ept> property indicates the starting position of the unknown bytes.</source>
          <target state="translated"><bpt id="p1">[</bpt>DecoderFallbackException.Index<ept id="p1">](xref:System.Text.DecoderFallbackException.Index)</ept> 속성은 알 수 없는 바이트의 시작 위치를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Although the <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> and <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> objects provide adequate diagnostic information about the exception, they do not provide access to the encoding or decoding buffer.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> 및 <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> 개체는 예외에 대한 적절한 진단 정보를 제공하지만 인코딩 또는 디코딩 버퍼에 대한 액세스는 제공하지 않습니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Therefore, they do not allow invalid data to be replaced or corrected within the encoding or decoding method.</source>
          <target state="translated">따라서 인코딩 또는 디코딩 메서드 내에서 잘못된 데이터를 바꾸거나 수정할 수 있도록 허용하지 않습니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Implementing a custom fallback strategy</source>
          <target state="translated">사용자 지정 대체(fallback) 전략 구현</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>In addition to the best-fit mapping that is implemented internally by code pages, .NET includes the following classes for implementing a fallback strategy:</source>
          <target state="translated">코드 페이지에서 내부적으로 구현되는 최적 매핑 외에도 .NET에는 대체(fallback) 전략을 구현하기 위한 다음과 같은 클래스가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> and <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> to replace characters in encoding operations.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> 및 <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept>를 사용하여 인코딩 작업에서 문자를 바꿉니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>DecoderReplacementFallback<ept id="p1">](xref:System.Text.DecoderReplacementFallback)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> to replace characters in decoding operations.</source>
          <target state="translated"><bpt id="p1">[</bpt>DecoderReplacementFallback<ept id="p1">](xref:System.Text.DecoderReplacementFallback)</ept> 및 <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept>를 사용하여 디코딩 작업에서 문자를 바꿉니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>EncoderExceptionFallback<ept id="p1">](xref:System.Text.EncoderExceptionFallback)</ept> and <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> to throw an <bpt id="p3">[</bpt>EncoderFallbackException<ept id="p3">](xref:System.Text.EncoderFallbackException)</ept> when a character cannot be encoded.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderExceptionFallback<ept id="p1">](xref:System.Text.EncoderExceptionFallback)</ept> 및 <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept>를 사용하여 문자를 인코드할 수 없는 경우 <bpt id="p3">[</bpt>EncoderFallbackException<ept id="p3">](xref:System.Text.EncoderFallbackException)</ept>을 throw합니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>DecoderExceptionFallback<ept id="p1">](xref:System.Text.DecoderExceptionFallback)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> to throw a <bpt id="p3">[</bpt>DecoderFallbackException<ept id="p3">](xref:System.Text.DecoderFallbackException)</ept> when a character cannot be decoded.</source>
          <target state="translated"><bpt id="p1">[</bpt>DecoderExceptionFallback<ept id="p1">](xref:System.Text.DecoderExceptionFallback)</ept> 및 <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept>를 사용하여 문자를 디코드할 수 없는 경우 <bpt id="p3">[</bpt>DecoderFallbackException<ept id="p3">](xref:System.Text.DecoderFallbackException)</ept>을 throw합니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>In addition, you can implement a custom solution that uses best-fit fallback, replacement fallback, or exception fallback, by following these steps:</source>
          <target state="translated">또한 다음 단계를 수행하여 최적 대체(fallback), 교체 대체(fallback) 또는 예외 대체(fallback)를 사용하는 사용자 지정 솔루션을 구현할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Derive a class from <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> for decoding operations.</source>
          <target state="translated">인코딩 작업의 경우 <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept>에서 클래스를 파생시키고, 디코딩 작업의 경우 <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept>에서 클래스를 파생시킵니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Derive a class from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> for decoding operations.</source>
          <target state="translated">인코딩 작업의 경우 <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>에서 클래스를 파생시키고, 디코딩 작업의 경우 <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept>에서 클래스를 파생시킵니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>For exception fallback, if the predefined <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> and <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> classes do not meet your needs, derive a class from an exception object such as <bpt id="p3">[</bpt>Exception<ept id="p3">](xref:System.Exception)</ept> or <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept>.</source>
          <target state="translated">예외 대체(fallback)의 경우 미리 정의된 <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> 및 <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> 클래스가 요구를 충족하지 않는 경우 <bpt id="p3">[</bpt>Exception<ept id="p3">](xref:System.Exception)</ept> 또는 <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept>과 같은 예외 개체에서 클래스를 파생시킵니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Deriving from EncoderFallback or DecoderFallback</source>
          <target state="translated">EncoderFallback 또는 DecoderFallback에서 파생</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>To implement a custom fallback solution, you must create a class that inherits from <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> for decoding operations.</source>
          <target state="translated">사용자 지정 대체(fallback) 솔루션을 구현하려면 인코딩 작업의 경우 <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept>에서 상속받고 디코딩 작업의 경우 <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept>에서 상속받는 클래스를 만들어야 합니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Instances of these classes are passed to the <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> method and serve as the intermediary between the encoding class and the fallback implementation.</source>
          <target state="translated">이러한 클래스의 인스턴스는 <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> 메서드에 전달되며 인코딩 클래스와 대체(fallback) 구현 간의 중개자 역할을 합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>When you create a custom fallback solution for an encoder or decoder, you must implement the following members:</source>
          <target state="translated">인코더 또는 디코더에 대한 사용자 지정 대체(fallback) 솔루션을 만드는 경우 다음과 같은 멤버를 구현해야 합니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallback.MaxCharCount<ept id="p1">](xref:System.Text.EncoderFallback.MaxCharCount)</ept> or <bpt id="p2">[</bpt>DecoderFallback.MaxCharCount<ept id="p2">](xref:System.Text.DecoderFallback.MaxCharCount)</ept> property, which returns the maximum possible number of characters that the best-fit, replacement, or exception fallback can return to replace a single character.</source>
          <target state="translated">최적, 교체 또는 예외 대체(fallback)가 단일 문자를 대체하기 위해 반환할 수 있는 최대 문자 수를 반환하는 <bpt id="p1">[</bpt>EncoderFallback.MaxCharCount<ept id="p1">](xref:System.Text.EncoderFallback.MaxCharCount)</ept> 또는 <bpt id="p2">[</bpt>DecoderFallback.MaxCharCount<ept id="p2">](xref:System.Text.DecoderFallback.MaxCharCount)</ept> 속성.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>For a custom exception fallback, its value is zero.</source>
          <target state="translated">사용자 지정 예외 대체(fallback)의 경우 해당 값은 0입니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> or <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> method, which returns your custom <bpt id="p3">[</bpt>EncoderFallbackBuffer<ept id="p3">](xref:System.Text.EncoderFallbackBuffer)</ept> or <bpt id="p4">[</bpt>DecoderFallbackBuffer<ept id="p4">](xref:System.Text.DecoderFallbackBuffer)</ept> implementation.</source>
          <target state="translated">사용자 지정 <bpt id="p3">[</bpt>EncoderFallbackBuffer<ept id="p3">](xref:System.Text.EncoderFallbackBuffer)</ept> 또는 <bpt id="p4">[</bpt>DecoderFallbackBuffer<ept id="p4">](xref:System.Text.DecoderFallbackBuffer)</ept> 구현을 반환하는 <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> 또는 <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> 메서드.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The method is called by the encoder when it encounters the first character that it is unable to successfully encode, or by the decoder when it encounters the first byte that it is unable to successfully decode.</source>
          <target state="translated">메서드는 성공적으로 인코딩할 수 없는 첫 번째 문자를 발견할 때 인코더에 의해 호출되거나 성공적으로 디코딩할 수 없는 첫 번째 바이트를 발견할 때 디코더에 의해 호출됩니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Deriving from EncoderFallbackBuffer or DecoderFallbackBuffer</source>
          <target state="translated">EncoderFallbackBuffer 또는 DecoderFallbackBuffer에서 파생</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>To implement a custom fallback solution, you must also create a class that inherits from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> for decoding operations.</source>
          <target state="translated">사용자 지정 대체(fallback) 솔루션을 구현하려면 인코딩 작업의 경우 <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>에서 상속받고 디코딩 작업의 경우 <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept>에서 상속받는 클래스도 만들어야 합니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Instances of these classes are returned by the <ph id="ph1">`CreateFallbackBuffer`</ph> method of the <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> and <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> classes.</source>
          <target state="translated">이러한 클래스의 인스턴스는 <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> 및 <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> 클래스의 <ph id="ph1">`CreateFallbackBuffer`</ph> 메서드에서 반환됩니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> method is called by the encoder when it encounters the first character that it is not able to encode, and the <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> method is called by the decoder when it encounters one or more bytes that it is not able to decode.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> 메서드는 인코드할 수 없는 첫 번째 문자를 발견할 때 인코더에 의해 호출되고, <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> 메서드는 디코드할 수 없는 바이트를 하나 이상 발견할 때 디코더에 의해 호출됩니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> classes provide the fallback implementation.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> 및 <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> 클래스는 대체 (fallback) 구현을 제공합니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Each instance represents a buffer that contains the fallback characters that will replace the character that cannot be encoded or the byte sequence that cannot be decoded.</source>
          <target state="translated">각 인스턴스는 인코딩할 수 없는 문자 또는 디코딩할 수 없는 바이트를 대체하는 대체(fallback) 문자가 포함된 버퍼를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>When you create a custom fallback solution for an encoder or decoder, you must implement the following members:</source>
          <target state="translated">인코더 또는 디코더에 대한 사용자 지정 대체(fallback) 솔루션을 만드는 경우 다음과 같은 멤버를 구현해야 합니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.%23ctor)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> method.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.%23ctor)</ept> 또는 <bpt id="p2">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> 메서드.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Char,System.Int32))</ept> is called by the encoder to provide the fallback buffer with information about the character that it cannot encode.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Char,System.Int32))</ept>은 인코드할 수 없는 문자 정보를 대체(fallback) 버퍼에 제공하기 위해 인코더에서 호출됩니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Because the character to be encoded may be a surrogate pair, this method is overloaded.</source>
          <target state="translated">인코딩할 문자가 서로게이트 쌍일 수 있으므로 이 메서드는 오버로드됩니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>One overload is passed the character to be encoded and its index in the string.</source>
          <target state="translated">하나의 오버로드에는 인코딩할 문자 및 문자열에서 해당 인덱스가 전달됩니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The second overload is passed the high and low surrogate along with its index in the string.</source>
          <target state="translated">두 번째 오버로드에는 상위 및 하위 서로게이트와 문자열에서 해당 인덱스가 전달됩니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> method is called by the decoder to provide the fallback buffer with information about the bytes that it cannot decode.</source>
          <target state="translated"><bpt id="p1">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> 메서드는 디코드할 수 없는 바이트 정보를 대체(fallback) 버퍼에 제공하기 위해 디코더에서 호출됩니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>This method is passed an array of bytes that it cannot decode, along with the index of the first byte.</source>
          <target state="translated">이 메서드에는 디코딩할 수 없는 바이트 배열 및 첫 번째 바이트의 인덱스가 전달됩니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The fallback method should return <ph id="ph1">`true`</ph> if the fallback buffer can supply a best-fit or replacement character or characters; otherwise, it should return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">대체(fallback) 버퍼가 최적 또는 교체 문자를 제공할 수 있는 경우 대체(fallback) 메서드에서 <ph id="ph1">`true`</ph>를 반환해야 하고, 그러지 않으면 <ph id="ph2">`false`</ph>를 반환해야 합니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>For an exception fallback, the fallback method should throw an exception.</source>
          <target state="translated">예외 대체(fallback)의 경우 대체(fallback) 메서드에서 예외를 발생시켜야 합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.GetNextChar<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.GetNextChar)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.GetNextChar<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.GetNextChar)</ept> method, which is called repeatedly by the encoder or decoder to get the next character from the fallback buffer.</source>
          <target state="translated">인코더 또는 디코더가 대체(fallback) 버퍼에서 다음 문자를 가져오기 위해 반복적으로 호출하는 <bpt id="p1">[</bpt>EncoderFallbackBuffer.GetNextChar<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.GetNextChar)</ept> 또는 <bpt id="p2">[</bpt>DecoderFallbackBuffer.GetNextChar<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.GetNextChar)</ept> 메서드.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>When all fallback characters have been returned, the method should return U+0000.</source>
          <target state="translated">모든 대체(fallback) 문자가 반환되고 나면 메서드에서 U+0000을 반환해야 합니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.Remaining<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Remaining)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.Remaining<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Remaining)</ept> property, which returns the number of characters remaining in the fallback buffer.</source>
          <target state="translated">대체(fallback) 버퍼에 남아 있는 문자 수를 반환하는 <bpt id="p1">[</bpt>EncoderFallbackBuffer.Remaining<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Remaining)</ept> 또는 <bpt id="p2">[</bpt>DecoderFallbackBuffer.Remaining<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Remaining)</ept> 속성</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.MovePrevious<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.MovePrevious)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.MovePrevious<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.MovePrevious)</ept> method, which moves the current position in the fallback buffer to the previous character.</source>
          <target state="translated">대체(fallback) 버퍼의 현재 위치를 이전 문자로 이동하는 <bpt id="p1">[</bpt>EncoderFallbackBuffer.MovePrevious<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.MovePrevious)</ept> 또는 <bpt id="p2">[</bpt>DecoderFallbackBuffer.MovePrevious<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.MovePrevious)</ept> 메서드</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.Reset<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Reset)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.Reset<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Reset)</ept> method, which reinitializes the fallback buffer.</source>
          <target state="translated">대체(fallback) 버퍼를 다시 초기화하는 <bpt id="p1">[</bpt>EncoderFallbackBuffer.Reset<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Reset)</ept> 또는 <bpt id="p2">[</bpt>DecoderFallbackBuffer.Reset<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Reset)</ept> 메서드</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>If the fallback implementation is a best-fit fallback or a replacement fallback, the classes derived from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> also maintain two private instance fields: the exact number of characters in the buffer; and the index of the next character in the buffer to return.</source>
          <target state="translated">대체(fallback) 구현이 최적 대체(fallback) 또는 교체 대체(fallback)인 경우 <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> 및 <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept>에서 파생된 클래스가 두 개의 전용 인스턴스 필드(버퍼의 정확한 문자 수 및 버퍼에서 반환할 다음 문자의 인덱스)도 유지 관리합니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>An EncoderFallback example</source>
          <target state="translated">EncoderFallback 예제</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>An earlier example used replacement fallback to replace Unicode characters that did not correspond to ASCII characters with an asterisk (<ph id="ph1">\*</ph>).</source>
          <target state="translated">이전 예제에서는 교체 대체(fallback)를 사용하여 ASCII 문자에 응답하지 않은 유니코드 문자를 별표(<ph id="ph1">\*</ph>)로 대체했습니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The following example uses a custom best-fit fallback implementation instead to provide a better mapping of non-ASCII characters.</source>
          <target state="translated">다음 예제에서는 사용자 지정 최적 대체(fallback) 구현을 대신 사용하여 보다 효과적인 비 ASCII 문자 매핑을 제공합니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The following code defines a class named <ph id="ph1">`CustomMapper`</ph> that is derived from <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> to handle the best-fit mapping of non-ASCII characters.</source>
          <target state="translated">다음 코드에서는 비 ASCII 문자의 최적 매핑을 처리하기 위해 <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept>에서 파생된 <ph id="ph1">`CustomMapper`</ph>라는 클래스를 정의합니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`CreateFallbackBuffer`</ph> method returns a <ph id="ph2">`CustomMapperFallbackBuffer`</ph> object, which provides the <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> implementation.</source>
          <target state="translated">해당 <ph id="ph1">`CreateFallbackBuffer`</ph> 메서드는 <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> 구현을 제공하는 <ph id="ph2">`CustomMapperFallbackBuffer`</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CustomMapper`</ph> class uses a <bpt id="p1">[</bpt>Dictionary<ph id="ph2">&amp;lt;</ph>TKey, TValue<ph id="ph3">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.Dictionary%602)</ept> object to store the mappings of unsupported Unicode characters (the key value) and their corresponding 8-bit characters (which are stored in two consecutive bytes in a 64-bit integer).</source>
          <target state="translated"><ph id="ph1">`CustomMapper`</ph> 클래스는 <bpt id="p1">[</bpt>Dictionary<ph id="ph2">&amp;lt;</ph>TKey, TValue<ph id="ph3">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.Dictionary%602)</ept> 개체를 사용하여 지원되지 않는 유니코드 문자(키 값) 및 해당 8비트 문자(64비트 정수에서는 연속된 2바이트에 저장됨)의 매핑을 저장합니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>To make this mapping available to the fallback buffer, the <ph id="ph1">`CustomMapper`</ph> instance is passed as a parameter to the <ph id="ph2">`CustomMapperFallbackBuffer`</ph> class constructor.</source>
          <target state="translated">대체(fallback) 버퍼에서 이 매핑을 사용할 수 있도록 <ph id="ph1">`CustomMapper`</ph> 인스턴스가 <ph id="ph2">`CustomMapperFallbackBuffer`</ph> 클래스 생성자에 매개 변수로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Because the longest mapping is the string "INF" for the Unicode character U+221E, the <ph id="ph1">`MaxCharCount`</ph> property returns 3.</source>
          <target state="translated">가장 긴 매핑은 유니코드 문자 U+221E에 해당하는 문자열 "INF"이므로 <ph id="ph1">`MaxCharCount`</ph> 속성은 3을 반환합니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The following code defines the <ph id="ph1">`CustomMapperFallbackBuffer`</ph> class, which is derived from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>.</source>
          <target state="translated">다음 코드에서는 <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>에서 파생된 <ph id="ph1">`CustomMapperFallbackBuffer`</ph> 클래스를 정의합니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The dictionary that contains best-fit mappings and that is defined in the <ph id="ph1">`CustomMapper`</ph> instance is available from its class constructor.</source>
          <target state="translated">최적 매핑을 포함하며 <ph id="ph1">`CustomMapper`</ph> 인스턴스에서 정의된 사전은 해당 클래스 생성자에서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`Fallback`</ph> method returns <ph id="ph2">`true`</ph> if any of the Unicode characters that the ASCII encoder cannot encode are defined in the mapping dictionary; otherwise, it returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">ASCII 인코더가 인코딩할 수 없는 유니코드 문자가 매핑 사전에 정의된 경우 해당 <ph id="ph1">`Fallback`</ph> 메서드가 <ph id="ph2">`true`</ph>를 반환하고, 그러지 않으면 <ph id="ph3">`false`</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>For each fallback, the private <ph id="ph1">`count`</ph> variable indicates the number of characters that remain to be returned, and the private <ph id="ph2">`index`</ph> variable indicates the position in the string buffer, <ph id="ph3">`charsToReturn`</ph>, of the next character to return.</source>
          <target state="translated">각 대체(fallback)에서 private <ph id="ph1">`count`</ph> 변수는 반환해야 하는 남은 문자 수를 나타내고, private <ph id="ph2">`index`</ph> 변수는 문자열 버퍼 <ph id="ph3">`charsToReturn`</ph>에서 반환할 다음 문자의 위치를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The following code then instantiates the <ph id="ph1">`CustomMapper`</ph> object and passes an instance of it to the <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> method.</source>
          <target state="translated">다음 코드는 <ph id="ph1">`CustomMapper`</ph> 개체를 인스턴스화하고 해당 인스턴스를 <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> 메서드에 전달합니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The output indicates that the best-fit fallback implementation successfully handles the three non-ASCII characters in the original string.</source>
          <target state="translated">출력은 최적 대체(fallback) 구현에서 원래 문자열에 있는 3자의 비 ASCII 문자를 성공적으로 처리했음을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.Encoder<ept id="p1">](xref:System.Text.Encoder)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.Encoder<ept id="p1">](xref:System.Text.Encoder)</ept></target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept></target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.Decoder<ept id="p1">](xref:System.Text.Decoder)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.Decoder<ept id="p1">](xref:System.Text.Decoder)</ept></target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.DecoderFallback<ept id="p1">](xref:System.Text.DecoderFallback)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.DecoderFallback<ept id="p1">](xref:System.Text.DecoderFallback)</ept></target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>