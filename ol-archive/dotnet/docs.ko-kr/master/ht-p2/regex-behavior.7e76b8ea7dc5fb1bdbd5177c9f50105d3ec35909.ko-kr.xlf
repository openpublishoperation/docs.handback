<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b217b59874ceafbb0e5e410878cc434974c5a863</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\regex-behavior.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4487a8a5971b0098f55c989ab3c345500350eaad</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">60535d382114cc1115acfe7627c2b5711cc18ad0</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Details of regular expression behavior</source>
          <target state="translated">정규식 동작 정보</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Details of regular expression behavior</source>
          <target state="translated">정규식 동작 정보</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Details of regular expression behavior</source>
          <target state="translated">정규식 동작 정보</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The .NET regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</source>
          <target state="translated">.NET 정규식 엔진은 Perl, Python, Emacs 및 Tcl에서 사용하는 것과 같은 기존의 NFA(Nondeterministic Finite Automaton) 엔진을 통합하는 역추적 정규식 일치 도구입니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</source>
          <target state="translated">이를 통해 해당 awk, egrep 또는 lex와 같은 빠르지만 제한적인 순수 정규식 DFA(Deterministic Finite Automaton) 엔진과 구분합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This also distinguishes it from standardized, but slower, POSIX NFAs.</source>
          <target state="translated">또한 표준화되지만 느린 POSIX NFA과도 구분합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The following section describes the three types of regular expression engines, and explains why regular expressions in .NET are implemented by using a traditional NFA engine.</source>
          <target state="translated">다음 섹션에서는 세 가지 유형의 정규식 엔진을 설명하고 기존 NFA 엔진을 사용하여 .NET의 정규식을 구현하는 이유를 설명합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Benefits of the NFA Engine</source>
          <target state="translated">NFA 엔진의 이점</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When DFA engines perform pattern matching, their processing order is driven by the input string.</source>
          <target state="translated">DFA 엔진에서 패턴 일치를 수행하는 경우 해당 처리 순서는 입력 문자열에 의해 결정됩니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</source>
          <target state="translated">엔진은 입력 문자열의 처음부터 시작해서 순차적으로 다음 문자가 정규식 패턴과 일치하는지 여부를 확인합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>They can guarantee to match the longest string possible.</source>
          <target state="translated">가능한 가장 긴 문자열을 찾도록 보장할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Because they never test the same character twice, DFA engines do not support backtracking.</source>
          <target state="translated">동일한 문자를 두 번 테스트하지 않기 때문에 DFA 엔진은 역추적을 지원하지 않습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</source>
          <target state="translated">그러나 DFA 엔진에 유한 상태만 포함되기 때문에 역참조를 사용하는 패턴과 일치하지 않으며 명시적 확장을 생성하지 않기 때문에 하위 식을 캡처할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</source>
          <target state="translated">DFA 엔진과 달리 기존의 NFA 엔진이 패턴 일치를 수행할 경우 해당 처리 순서는 정규식 패턴에 의해 결정됩니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</source>
          <target state="translated">특정 언어 요소를 처리하는 경우와 같이 엔진은 탐욕적 일치를 사용합니다. 즉, 가능한 한 입력 문자열의 수만큼 찾습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>But it also saves its state after successfully matching a subexpression.</source>
          <target state="translated">하지만 성공적으로 하위 식을 찾은 후에 해당 상태를 저장하기도 합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If a match eventually fails, the engine can return to a saved state so it can try additional matches.</source>
          <target state="translated">일치에 결국 실패하면 엔진이 추가 일치를 시도할 수 있도록 저장된 상태로 돌아갈 수 있습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as backtracking.</source>
          <target state="translated">정규식에서 이후 언어 요소가 일치할 수 있도록 성공적인 하위 식 찾기를 포기하는 이 프로세스를 역추적이라고 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</source>
          <target state="translated">NFA 엔진은 역추적을 사용하여 특정 순서에 따라 정규식에서 가능한 모든 확장을 테스트하고 첫 번째 일치 항목을 수락합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</source>
          <target state="translated">기존의 NFA 엔진이 성공적으로 일치를 수행하기 위해 정규식의 특정 확장을 구성하기 때문에 하위 식 일치 및 일치 역참조를 캡처할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</source>
          <target state="translated">그러나 기존의 NFA가 역추적하기 때문에 다른 경로를 통해 그 상태가 된 경우 여러 번 동일한 상태가 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>As a result, it can run exponentially slowly in the worst case.</source>
          <target state="translated">결과적으로 최악의 경우 상당히 느리게 실행될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</source>
          <target state="translated">기존 NFA 엔진이 발견한 첫 번째 이치를 수용하기 때문에 다른 일치 항목(더 긴 일치일 가능성이 높음)도 밝히지 않은 상태로 둘 수 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</source>
          <target state="translated">POSIX NFA 엔진은 가장 긴 일치 항목을 발견했다고 보장할 수 있을 때까지 역추적을 계속한다는 점을 제외하면 기존의 NFA 엔진과 같습니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</source>
          <target state="translated">결과적으로 POSIX NFA 엔진은 기존 NFA 엔진보다 느립니다. 따라서 POSIX NFA 엔진을 사용하는 경우 역추적 검사의 순서를 변경하여 긴 일치 항목보다 짧은 일치 항목을 우선할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</source>
          <target state="translated">기존의 NFA 엔진은 DFA 또는 POSIX NFA 엔진보다 일치하는 문자열을 효율적으로 제어하기 때문에 프로그래머로부터 선호되었습니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</source>
          <target state="translated">최악의 경우 실행 속도가 느려질 수 있지만 모호성을 줄이고 역추적을 제한하는 패턴을 사용하여 선형 또는 다항 시간에서 일치 항목을 찾도록 조정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well-written and avoids cases in which backtracking degrades performance exponentially.</source>
          <target state="translated">즉, NFA 엔진은 강력함과 유연성을 제공하는 대신 성능이 떨어지지만 대부분의 경우에 정규식을 잘 작성하여 역추적이 성능을 기하급수적으로 저하시키지 않도록 방지한다면 사용 가능한 적절한 성능을 제공합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see <bpt id="p1">[</bpt>Backtracking in Regular Expressions<ept id="p1">](backtracking.md)</ept>.</source>
          <target state="translated">과도한 역추적으로 인해 발생한 성능 저하 및 이를 해결하는 정규식을 만드는 방법에 대한 자세한 내용은 <bpt id="p1">[</bpt>정규식의 역추적<ept id="p1">](backtracking.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>.NET Framework Engine Capabilities</source>
          <target state="translated">.NET Framework 엔진 기능</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>To take advantage of the benefits of a traditional NFA engine, the .NET regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</source>
          <target state="translated">기존 NFA 엔진의 이점을 누리려면 .NET 정규식 엔진에는 프로그래머가 역추적 엔진을 조정할 수 있는 일련의 구문이 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>These constructs can be used to find matches faster or to favor specific expansions over others.</source>
          <target state="translated">이러한 구문을 사용하여 일치 항목을 빠르게 찾거나 다른 일치 항목에 대한 특정 확장을 우선할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Other features of the .NET regular expression engine include the following:</source>
          <target state="translated">.NET 정규식 엔진의 다른 기능은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Lazy quantifiers</source>
          <target state="translated">게으른 수량자</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Lazy quantifiers: <bpt id="p1">**</bpt>??<ept id="p1">**</ept>, <bpt id="p2">__</bpt>*?<ept id="p2">__</ept>, <bpt id="p3">**</bpt>+?<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,<ept id="p6">**</ept><bpt id="p7">_</bpt>m<ept id="p7">_</ept><bpt id="p8">**</bpt>}?<ept id="p8">**</ept>.</source>
          <target state="translated">게으른 수량자: <bpt id="p1">**</bpt>??<ept id="p1">**</ept>, <bpt id="p2">__</bpt>*?<ept id="p2">__</ept>, <bpt id="p3">**</bpt>+?<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,<ept id="p6">**</ept><bpt id="p7">_</bpt>m<ept id="p7">_</ept><bpt id="p8">**</bpt>}?<ept id="p8">**</ept>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>These constructs tell the backtracking engine to search the minimum number of repetitions first.</source>
          <target state="translated">이러한 구문은 역추적 엔진이 최소 반복 횟수를 먼저 검색하도록 지시합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</source>
          <target state="translated">반면, 일반적인 탐욕적 수량자는 먼저 최대 반복 횟수를 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between the two.</source>
          <target state="translated">다음 예제에서는 둘 사이의 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</source>
          <target state="translated">정규식은 숫자로 끝나는 문장을 찾고 캡처링 그룹은 해당 숫자를 추출하려고 합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`.+(\d+)\.`</ph> includes the greedy quantifier <ph id="ph2">`.+`</ph>, which causes the regular expression engine to capture only the last digit of the number.</source>
          <target state="translated">정규식 <ph id="ph1">`.+(\d+)\.`</ph>은 탐욕적 수량자 <ph id="ph2">`.+`</ph>를 포함하며 이로 인해 정규식 엔진은 번호의 마지막 숫자만 캡처하게 됩니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In contrast, the regular expression <ph id="ph1">`.+?(\d+)\.`</ph> includes the lazy quantifier <ph id="ph2">`.+?`</ph>, which causes the regular expression engine to capture the entire number.</source>
          <target state="translated">반대로 정규식 <ph id="ph1">`.+?(\d+)\.`</ph>은 게으른 수량자 <ph id="ph2">`.+?`</ph>를 포함하며 이로 인해 정규식 엔진은 전체 번호를 캡처하게 됩니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The greedy and lazy versions of this regular expression are defined as shown in the following table.</source>
          <target state="translated">이 정규식의 탐욕적 버전과 게으른 버전은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`.+`</ph> (greedy quantifier)</source>
          <target state="translated"><ph id="ph1">`.+`</ph>(탐욕적 수량자)</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Match at least one occurrence of any character.</source>
          <target state="translated">적어도 한 번 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</source>
          <target state="translated">그러면 정규식 엔진이 전체 문자열을 검색하고 필요한 패턴의 나머지 부분을 찾는 데 필요한 역추적을 수행합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`.+?`</ph> (lazy quantifier)</source>
          <target state="translated"><ph id="ph1">`.+?`</ph>(게으른 수량자)</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Match at least one occurrence of any character, but match as few as possible.</source>
          <target state="translated">적어도 한 번 문자를 찾지만 가능한 한 적게 일치합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Match at least one numeric character, and assign it to the first capturing group.</source>
          <target state="translated">적어도 하나의 숫자 문자를 찾아 첫 번째 캡처링 그룹에 할당합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Match a period.</source>
          <target state="translated">마침표를 찾습니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For more information about lazy quantifiers, see <bpt id="p1">[</bpt>Quantifiers in regular expressions<ept id="p1">](quantifiers.md)</ept>.</source>
          <target state="translated">게으른 수량자에 대한 자세한 내용은 <bpt id="p1">[</bpt>정규식의 수량자<ept id="p1">](quantifiers.md)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Positive lookahead</source>
          <target state="translated">긍정 lookahead</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Positive lookahead: <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">긍정 lookahead: <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</source>
          <target state="translated">이 기능을 사용하면 역추적 검사 엔진이 하위 식을 찾은 후에 텍스트의 동일한 지점으로 돌아오게 합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</source>
          <target state="translated">동일한 위치에서 시작하는 여러 패턴을 확인하여 전체 텍스트를 검색하는 데 유용합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</source>
          <target state="translated">이를 통해 엔진은 찾은 텍스트에 부분 문자열을 포함하지 않고 부분 문자열이 일치 항목의 끝에 존재하는지 확인할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</source>
          <target state="translated">다음 예제에서는 긍정 lookahead를 사용하여 문장 부호 기호가 뒤에 오지 않는 문장에 있는 단어를 추출합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b[A-Z]+\b(?=\P{P})`</ph> is defined as shown in the following table.</source>
          <target state="translated"><ph id="ph1">`\b[A-Z]+\b(?=\P{P})`</ph> 정규식은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">무늬</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Match any alphabetic character one or more times.</source>
          <target state="translated">알파벳 임의의 문자를 1회 이상 찾습니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option, the comparison is case-insensitive.</source>
          <target state="translated"><bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> 메서드가 <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> 옵션으로 호출되지 때문에 비교는 대소문자를 구분합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Look ahead to determine whether the next character is a punctuation symbol.</source>
          <target state="translated">다음 문자가 문장 부호 기호인지 확인하기 위해 앞을 살펴봅니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If it is not, the match succeeds.</source>
          <target state="translated">그렇지 않은 경우 일치가 성공합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For more information about positive lookahead assertions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">긍정 lookahead 어설션에 대한 자세한 내용은 <bpt id="p1">[</bpt>정규식의 그룹화 구문<ept id="p1">](grouping.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Negative lookahead</source>
          <target state="translated">부정 lookahead</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Negative lookahead: <bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">부정 lookahead: <bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This feature adds the ability to match an expression only if a subexpression fails to match.</source>
          <target state="translated">이 기능은 하위 식이 일치에 실패하는 경우 식을 찾는 기능을 추가합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</source>
          <target state="translated">이 기능은 정리 작업에 특히 유용합니다. 포함해야 하는 사례에 대한 식보다 제거해야 하는 경우에 대한 식을 제공하는 것이 더 간단하기 때문입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For example, it is difficult to write an expression for words that do not begin with "non".</source>
          <target state="translated">예를 들어 "non"으로 시작하지 않는 단어에 대한 식을 작성하기가 어렵습니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The following example uses negative lookahead to exclude them.</source>
          <target state="translated">다음 예제에서는 부정 lookahead를 사용하여 파일을 제외합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(?!non)\w+\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\b(?!non)\w+\b`</ph>는 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Look ahead to ensure that the current string does not begin with "non".</source>
          <target state="translated">현재 문자열이 "non"으로 시작하지 않으면 조회합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>If it does, the match fails.</source>
          <target state="translated">그렇지 않으면 검색이 실패합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For more information about negative lookahead assertions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">부정 lookahead 어설션에 대한 자세한 내용은 <bpt id="p1">[</bpt>정규식의 그룹화 구문<ept id="p1">](grouping.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Conditional evaluation</source>
          <target state="translated">조건부 평가</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Conditional evaluation: <bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept>&amp;#124;<bpt id="p5">_</bpt>no<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> and<bpt id="p7">**</bpt>(?(<ept id="p7">**</ept><bpt id="p8">_</bpt>name<ept id="p8">_</ept><bpt id="p9">**</bpt>)<ept id="p9">**</ept><bpt id="p10">_</bpt>yes<ept id="p10">_</ept>&amp;#124;<bpt id="p11">_</bpt>no<ept id="p11">_</ept><bpt id="p12">**</bpt>)<ept id="p12">**</ept>, where <bpt id="p13">*</bpt>expression<ept id="p13">*</ept> is a subexpression to match, <bpt id="p14">*</bpt>name<ept id="p14">*</ept> is the name of a capturing group, <bpt id="p15">*</bpt>yes<ept id="p15">*</ept> is the string to match if <bpt id="p16">*</bpt>expression<ept id="p16">*</ept> is matched or <bpt id="p17">*</bpt>name<ept id="p17">*</ept> is a valid, non-empty captured group, and <bpt id="p18">*</bpt>no<ept id="p18">*</ept> is the subexpression to match if <bpt id="p19">*</bpt>expression<ept id="p19">*</ept> is not matched or <bpt id="p20">*</bpt>name<ept id="p20">*</ept> is not a valid, non-empty captured group.</source>
          <target state="translated">조건부 평가: <bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept>&amp;#124;<bpt id="p5">_</bpt>no<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> and<bpt id="p7">**</bpt>(?(<ept id="p7">**</ept><bpt id="p8">_</bpt>name<ept id="p8">_</ept><bpt id="p9">**</bpt>)<ept id="p9">**</ept><bpt id="p10">_</bpt>yes<ept id="p10">_</ept>&amp;#124;<bpt id="p11">_</bpt>no<ept id="p11">_</ept><bpt id="p12">**</bpt>)<ept id="p12">**</ept> 여기서 <bpt id="p13">*</bpt>expression<ept id="p13">*</ept>은 일치시킬 하위 식이고 <bpt id="p14">*</bpt>name<ept id="p14">*</ept>은 캡처링 그룹의 이름이며 <bpt id="p15">*</bpt>yes<ept id="p15">*</ept>는 <bpt id="p16">*</bpt>expression<ept id="p16">*</ept>이 일치하거나 <bpt id="p17">*</bpt>name<ept id="p17">*</ept>이 비어 있지 않은 유효한 캡처된 그룹인 경우 일치시킬 문자열이며 <bpt id="p18">*</bpt>no<ept id="p18">*</ept>는 <bpt id="p19">*</bpt>expression<ept id="p19">*</ept>이 일치하지 않거나 <bpt id="p20">*</bpt>name<ept id="p20">*</ept>이 비어 있지 않은 유효한 캡처된 그룹이 아닌 경우 일치시킬 하위 식입니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</source>
          <target state="translated">엔진은 이 기능을 통해 이전 하위 식이 일치 결과 및 너비 0인 어설션 결과에 따라 둘 이상의 대체 패턴을 사용하여 검색할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</source>
          <target state="translated">따라서 이전 하위 식이 일치하는지 여부에 따라 하위 식을 찾도록 허용하는 더 강력한 형식의 역참조가 가능합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The regular expression in the following example matches paragraphs that are intended for both public and internal use.</source>
          <target state="translated">다음 예제의 정규식은 공용으로 사용하고 내부적으로 사용하려는 단락을 모두 찾습니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Paragraphs intended only for internal use begin with a <ph id="ph1">`&lt;PRIVATE&gt;`</ph> tag.</source>
          <target state="translated">내부적으로 사용하려는 단락은 <ph id="ph1">`&lt;PRIVATE&gt;`</ph> 태그로 시작합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^(?&lt;Pvt&gt;\&lt;PRIVATE\&gt;\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$`</ph> uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`^(?&lt;Pvt&gt;\&lt;PRIVATE\&gt;\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$`</ph>은 조건부 평가를 사용하여 공용으로 사용하고 내부적으로 사용하려는 단락의 콘텐츠를 별도의 캡처링 그룹에 할당합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>These paragraphs can then be handled differently.</source>
          <target state="translated">이러한 단락은 다르게 처리될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of a line.</source>
          <target state="translated">줄의 시작 부분에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of the string <ph id="ph1">`&lt;PRIVATE&gt;`</ph> followed by a white-space character.</source>
          <target state="translated">0개 또는 1개의 뒤에 공백 문자가 있는 <ph id="ph1">`&lt;PRIVATE&gt;`</ph> 문자열을 찾습니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Assign the match to a capturing group named Pvt.</source>
          <target state="translated">Pvt로 명명된 캡처링 그룹에 일치 항목을 할당합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Pvt`</ph> capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</source>
          <target state="translated"><ph id="ph1">`Pvt`</ph> 캡처링 그룹이 있는 경우 뒤에 0개 이상의 문장 구분 기호와 하나의 공백 문자가 오는 하나 이상의 단어 문자를 한 번 이상 찾습니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Assign the substring to the first capturing group.</source>
          <target state="translated">첫 번째 캡처링 그룹에 부분 문자열을 할당합니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Pvt`</ph> capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</source>
          <target state="translated"><ph id="ph1">`Pvt`</ph> 캡처링 그룹이 없는 경우 뒤에 0개 이상의 문장 구분 기호와 하나의 공백 문자가 오는 하나 이상의 단어 문자를 한 번 이상 찾습니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Assign the substring to the third capturing group.</source>
          <target state="translated">세 번째 캡처링 그룹에 부분 문자열을 할당합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Match the end of a line or the end of the string.</source>
          <target state="translated">줄의 끝 또는 문자열의 끝을 찾습니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>For more information about conditional evaluation, see <bpt id="p1">[</bpt>Alternation constructs in regular expressions<ept id="p1">](alternation.md)</ept>.</source>
          <target state="translated">조건부 평가에 대한 자세한 내용은 <bpt id="p1">[</bpt>정규식의 교체 구문<ept id="p1">](alternation.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Balancing group definitions</source>
          <target state="translated">균형 조정 그룹 정의</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Balancing group definitions: <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name1-name2<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</source>
          <target state="translated">균형 조정 그룹 정의: <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name1-name2<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</source>
          <target state="translated">정규식 엔진은 이 기능을 통해 괄호 또는 열고 닫는 대괄호와 같은 중첩된 구문을 추적할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>For an example, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">예제는 <bpt id="p1">[</bpt>정규식의 그룹화 구문<ept id="p1">](grouping.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpressions</source>
          <target state="translated">역추적하지 않는 하위 식</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpressions (also known as greedy subexpressions): <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">역추적하지 않는 하위 식(최대 일치 표현하위 식): <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</source>
          <target state="translated">식이 보유한 독립 항목을 실행하는 것처럼 역추적 엔진은 이 기능을 통해 하위 식이 보유한 첫 번째 일치 항목만을 찾는다고 보장할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</source>
          <target state="translated">이 생성자를 사용하지 않는 경우 더 큰 식의 역추적 검색은 하위 식의 동작을 변경할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`(a+)\w`</ph> matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the <ph id="ph2">`\w`</ph> language element and is not included in the captured group.</source>
          <target state="translated">예를 들어 정규식 <ph id="ph1">`(a+)\w`</ph>이 "a" 문자의 시퀀스를 따르는 단어 문자와 함께 하나 이상의 "a" 문자를 찾고 "a" 문자의 시퀀스를 첫 번째 캡처 그룹에 할당합니다. 하지만 입력 문자열의 마지막 문자가 "a"인 경우 <ph id="ph2">`\w`</ph> 언어 요소에 의해 찾게 되며 캡처된 그룹에 포함되지 않습니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`((?&gt;a+))\w`</ph> prevents this behavior.</source>
          <target state="translated">정규식 <ph id="ph1">`((?&gt;a+))\w`</ph>은 이러한 동작을 방지합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</source>
          <target state="translated">연속되는 모든 "a" 문자를 역추적하지 않고 찾기 때문에 첫 번째 캡처링 그룹에는 연속되는 모든 "a" 문자가 있습니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>If the "a" characters are not followed by at least one more character other than "a", the match fails.</source>
          <target state="translated">"a" 문자의 뒤에 "a" 이외의 문자가 적어도 하나 이상 있지 않으면 검색에 실패합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For more information about nonbacktracking subexpressions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">역추적하지 않는 하위 식에 대한 자세한 내용은 <bpt id="p1">[</bpt>정규식의 그룹화 구문<ept id="p1">](grouping.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Right-to-left matching</source>
          <target state="translated">오른쪽에서 왼쪽 찾기</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Right-to-left matching, which is specified by supplying the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option to a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static instance matching method.</source>
          <target state="translated">오른쪽에서 왼쪽 찾기는 <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> 옵션을 <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 클래스 생성자 또는 고정 인스턴스 일치 메서드에 제공하여 지정됩니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</source>
          <target state="translated">이 기능은 왼쪽에서 오른쪽이 아닌 오른쪽에서 왼쪽으로 찾는 경우에 유용하고 패턴의 왼쪽이 아닌 패턴의 오른쪽 부분에서 찾기를 시작하는 경우 효율적입니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</source>
          <target state="translated">다음 예제와 같이 오른쪽에서 왼쪽 찾기를 사용하면 탐욕적 수량자의 동작을 변경할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The example conducts two searches for a sentence that ends in a number.</source>
          <target state="translated">예제에서는 숫자로 끝나는 문장에 대해 두 개의 검색을 수행합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The left-to-right search that uses the greedy quantifier <ph id="ph1">`+`</ph> matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</source>
          <target state="translated">오른쪽에서 왼쪽 검색이 6자리 모두와 일치하는 반면 탐욕적 수량자를 사용하는 왼쪽에서 오른쪽 검색 <ph id="ph1">`+`</ph>은 문장에서 6자리 중 하나와 일치합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>For an description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</source>
          <target state="translated">정규식 패턴에 대한 설명은 이 섹션 앞부분의 게으른 수량자를 보여 주는 예제를 참조하세요.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>For more information about right-to-left matching, see <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">오른쪽에서 왼쪽 찾기에 대한 자세한 내용은 <bpt id="p1">[</bpt>정규식 옵션<ept id="p1">](options.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Positive and negative lookbehind</source>
          <target state="translated">긍정 및 부정 lookbehind</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Positive and negative lookbehind: <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> for positive lookbehind, and <bpt id="p4">**</bpt>(?&lt;!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> for negative lookbehind.</source>
          <target state="translated">긍정 및 부정 lookbehind: 긍정 lookbehind의 경우 <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>, 부정 lookbehind의 경우 <bpt id="p4">**</bpt>(?&lt;!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>This feature is similar to lookahead, which is discussed earlier in this topic.</source>
          <target state="translated">이 기능은 이 항목의 앞부분에서 설명한 lookahead와 비슷합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</source>
          <target state="translated">정규식 엔진을 사용하면 오른쪽에서 왼쪽 찾기를 완료할 수 있기 때문에 정규식은 무제한 lookbehind를 허용합니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</source>
          <target state="translated">긍정 및 부정 lookbehind는 중첩된 하위 식이 외부 식의 상위 집합인 경우 중첩된 수량자를 방지하는 데도 사용될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Regular expressions with such nested quantifiers often offer poor performance.</source>
          <target state="translated">이러한 중첩된 수량자가 있는 정규식은 종종 성능이 저하됩니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</source>
          <target state="translated">예를 들어 다음 예제에서는 문자열이 영숫자 문자로 시작하고 끝나고 문자열의 다른 문자가 큰 하위 집합 중 하나임을 확인합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>It forms a portion of the regular expression used to validate e-mail addresses; for more information, see <bpt id="p1">[</bpt>How to: Verify that Strings Are in Valid Email Format<ept id="p1">](verify-format.md)</ept>.</source>
          <target state="translated">이 식은 전자 메일 주소의 유효성을 검사하는 데 사용되는 정규식의 일부를 형성합니다. 자세한 내용은 <bpt id="p1">[</bpt>방법: 문자열이 올바른 전자 메일 서식인지 확인<ept id="p1">](verify-format.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^[A-Z0-9]([-!#$%&amp;'.*+/=?^`</ph>{}|~\w])*(?&lt;=[A-Z0-9])$` is defined as shown in the following table.</source>
          <target state="translated">정규식 <ph id="ph1">`^[A-Z0-9]([-!#$%&amp;'.*+/=?^`</ph>{}|~\w])*(?&lt;=[A-Z0-9])$`는 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">문자열의 시작 부분에서 검색을 시작합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Match any numeric or alphanumeric character.</source>
          <target state="translated">숫자 또는 영숫자 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>(The comparison is case-insensitive.)</source>
          <target state="translated">비교는 대소문자를 구분하지 않습니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`([-!#$%&amp;'.*+/=?^`</ph>{}&amp;#124;~\w])*`</source>
          <target state="translated"><ph id="ph1">`([-!#$%&amp;'.*+/=?^`</ph>{}&amp;#124;~\w])*`</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of any word character, or any of the following characters: -, !, #, $, %, &amp;, ', ., *, +, /, =, ?, ^, `, {, }, &amp;#124;, or ~.</source>
          <target state="translated">단어 문자 또는 -, !, #, $, %, &amp;, ', ., *, +, /, =, ?, ^, `, {, }, &amp;#124;이나 ~의 문자로 구성된 0개 이상의 일치 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Look behind to the previous character, which must be numeric or alphanumeric.</source>
          <target state="translated">영숫자만 또는 숫자여야 하는 이전 문자를 확인합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>(The comparison is case-insensitive.)</source>
          <target state="translated">비교는 대소문자를 구분하지 않습니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>End the match at the end of the string.</source>
          <target state="translated">문자열의 끝 부분에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>For more information about positive and negative lookbehind, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">긍정 및 부정 lookbehind에 대한 자세한 내용은 <bpt id="p1">[</bpt>정규식의 그룹화 구문<ept id="p1">](grouping.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Related Topics</source>
          <target state="translated">관련 항목</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">제목</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>역추적<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Provides information about how regular expression backtracking branches to find alternative matches.</source>
          <target state="translated">대체 일치 항목을 찾는 정규식 역추적 분기에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Compilation and reuse<ept id="p1">](compilation.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>컴파일 및 다시 사용<ept id="p1">](compilation.md)</ept></target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Provides information about compiling and reusing regular expressions to increase performance.</source>
          <target state="translated">성능 향상을 위해 정규식을 컴파일하고 다시 사용하는 방법에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Thread safety<ept id="p1">](thread-safety.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>스레드로부터의 안전성<ept id="p1">](thread-safety.md)</ept></target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</source>
          <target state="translated">정규식 스레드로부터의 안전성에 대한 정보를 제공하고 정규식 개체에 대한 액세스를 동기화해야 하는 경우를 설명합니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET regular expressions<ept id="p1">](regular-expressions.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>.NET 정규식<ept id="p1">](regular-expressions.md)</ept></target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Provides an overview of the programming language aspect of regular expressions.</source>
          <target state="translated">정규식의 프로그래밍 언어 측면에 대한 개요를 제공합니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The regular expression Object Model<ept id="p1">](object-model.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>정규식 개체 모델<ept id="p1">](object-model.md)</ept></target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Provides information and code examples illustrating how to use the regular expression classes.</source>
          <target state="translated">정규식 클래스를 사용하는 방법을 보여 주는 코드 예제 및 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression examples<ept id="p1">](regex-examples.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>정규식 예제<ept id="p1">](regex-examples.md)</ept></target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Contains code examples that illustrate the use of regular expressions in common applications.</source>
          <target state="translated">일반적인 응용 프로그램에서 정규식 사용을 보여 주는 코드 예제를 포함합니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>정규식 언어 - 빠른 참조<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</source>
          <target state="translated">정규식을 정의하는 데 사용할 수 있는 문자, 연산자 및 생성자 집합에 대한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">참조</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.RegularExpressions<ept id="p1">](xref:System.Text.RegularExpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.RegularExpressions<ept id="p1">](xref:System.Text.RegularExpressions)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>