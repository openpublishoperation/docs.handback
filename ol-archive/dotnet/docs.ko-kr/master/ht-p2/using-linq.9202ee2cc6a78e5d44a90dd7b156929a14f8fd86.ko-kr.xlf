<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4cb0c523a31faf319c1e07ceaa8a8122d3046be8</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\using-linq.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">37f7c80da13d49cc162ccaef9fa38e94e54530a1</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">036db4d6dd6488c1992a03d72dae7e9f4504a8ef</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>LINQ (Language Integrated Query)</source>
          <target state="translated">LINQ(Language-Integrated Query)</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>LINQ (Language Integrated Query)</source>
          <target state="translated">LINQ(Language-Integrated Query)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>LINQ (Language Integrated Query)</source>
          <target state="translated">LINQ(Language-Integrated Query)</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>What is it?</source>
          <target state="translated">LINQ란?</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>LINQ provides language-level querying capabilities and a <bpt id="p1">[</bpt>higher-order function<ept id="p1">](https://en.wikipedia.org/wiki/Higher-order_function)</ept> API to C# and VB as a way to write expressive, declarative code.</source>
          <target state="translated">LINQ는 표현력 있는 선언형 코드를 작성하는 한 가지 방법으로 <bpt id="p1">[</bpt>고차 함수<ept id="p1">](https://en.wikipedia.org/wiki/Higher-order_function)</ept> API와 언어 수준 쿼리 기능을 C# 및 VB에 제공합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Language-level query syntax:</source>
          <target state="translated">언어 수준 쿼리 구문:</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Same example using the <ph id="ph1">`IEnumerable&lt;T&gt;`</ph> API:</source>
          <target state="translated"><ph id="ph1">`IEnumerable&lt;T&gt;`</ph> API를 사용한 동일한 예제:</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>LINQ is Expressive</source>
          <target state="translated">LINQ의 뛰어난 표현력</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Imagine you have a list of pets, but want to convert it into a dictionary where you can access a pet directly by its <ph id="ph1">`RFID`</ph> value.</source>
          <target state="translated">애완 동물 목록이 있고, 해당 <ph id="ph1">`RFID`</ph> 값으로 애완 동물에 직접 액세스할 수 있는 사전으로 이 목록을 변환하려 한다고 가정해봅시다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Traditional imperative code:</source>
          <target state="translated">기존의 명령형 코드:</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The intention behind the code is not to create a new <ph id="ph1">`Dictionary&lt;int, Pet&gt;`</ph> and add to it via a loop, it is to convert an existing list into a dictionary!</source>
          <target state="translated">코드의 숨은 의도는 새 <ph id="ph1">`Dictionary&lt;int, Pet&gt;`</ph>을 만들고 루프를 통해 사전에 추가하는 것이 아니라 기존 목록을 사전으로 변환하는 것입니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>LINQ preserves the intention whereas the imperative code does not.</source>
          <target state="translated">LINQ는 이 의도를 유지하지만 명령형 코드는 유지하지 않습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Equivalent LINQ expression:</source>
          <target state="translated">해당되는 LINQ 식:</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The code using LINQ is valuable because it evens the playing field between intent and code when reasoning as a programmer.</source>
          <target state="translated">LINQ를 사용하는 코드는 프로그래머로 추론할 때 의도와 코드를 일치시키기 때문에 유용합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Another bonus is code brevity.</source>
          <target state="translated">그 외에도 코드가 간소화되는 이점이 있습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Imagine reducing large portions of a codebase by 1/3 as done above.</source>
          <target state="translated">위와 같이 코드베이스의 상당 부분이 1/3만큼 줄어든다고 상상해 보세요.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Pretty sweet deal, right?</source>
          <target state="translated">멋지지 않나요?</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>LINQ Providers Simplify Data Access</source>
          <target state="translated">데이터 액세스를 간소화하는 LINQ 공급자</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For a significant chunk of software out in the wild, everything revolves around dealing with data from some source (Databases, JSON, XML, etc).</source>
          <target state="translated">소프트웨어의 상당 부분은 실생활에서 일부 소스(데이터베이스, JSON, XML 등)의 데이터를 처리하면서 발전합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Often this involves learning a new API for each data source, which can be annoying.</source>
          <target state="translated">이 과정에서 각 데이터 소스에 대한 새로운 API를 학습해야 하며, 이는 꽤 번거로울 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>LINQ simplifies this by abstracting common elements of data access into a query syntax which looks the same no matter which data source you pick.</source>
          <target state="translated">LINQ는 데이터 액세스의 공통 요소를 선택한 데이터 소스에 관계없이 동일하게 표시되는 쿼리 구문으로 추상화하여 이 과정을 간소화합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consider the following: finding all XML elements with a specific attribute value.</source>
          <target state="translated">특정 특성 값을 가진 모든 XML 요소를 찾는다고 가정해봅시다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Writing code to manually traverse the XML document to perform this task would be far more challenging.</source>
          <target state="translated">이 작업을 수행하기 위해 수동으로 XML 문서를 트래버스하는 코드를 작성하는 것이 훨씬 더 어려울 것입니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Interacting with XML isn’t the only thing you can do with LINQ Providers.</source>
          <target state="translated">XML 조작이 LINQ 공급자로 수행할 수 있는 유일한 작업은 아닙니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Linq to SQL<ept id="p1">](https://msdn.microsoft.com/library/bb386976.aspx)</ept> is a fairly bare-bones Object-Relational Mapper (ORM) for an MSSQL Server Database.</source>
          <target state="translated"><bpt id="p1">[</bpt>LINQ to SQL<ept id="p1">](https://msdn.microsoft.com/library/bb386976.aspx)</ept>은 MSSQL Server Database에 대한 기본적인 ORM(개체 관계형 매퍼)입니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>JSON.NET<ept id="p1">](http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm)</ept> library provides efficient JSON Document traversal via LINQ.</source>
          <target state="translated"><bpt id="p1">[</bpt>JSON.NET<ept id="p1">](http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm)</ept> 라이브러리는 LINQ를 통한 효율적인 JSON 문서 통과 기능을 제공합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Furthermore, if there isn’t a library which does what you need, you can also <bpt id="p1">[</bpt>write your own LINQ Provider<ept id="p1">](https://msdn.microsoft.com/library/Bb546158.aspx)</ept>!</source>
          <target state="translated">또한 필요한 작업을 수행하는 라이브러리가 없을 경우 <bpt id="p1">[</bpt>고유한 LINQ 공급자를 작성<ept id="p1">](https://msdn.microsoft.com/library/Bb546158.aspx)</ept>할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Why Use the Query Syntax?</source>
          <target state="translated">왜 쿼리 구문을 사용하나요?</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This is a question which often comes up.</source>
          <target state="translated">자주 제기되는 질문입니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>After all, this,</source>
          <target state="translated">결국,</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>is a lot more concise than this:</source>
          <target state="translated">위 코드가 아래 코드보다 훨씬 더 간결합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Isn’t the API syntax just a more concise way to do the query syntax?</source>
          <target state="translated">API 구문이 쿼리 구문보다 더 간결한 방법이 아닌가요?</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">아니요.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The query syntax allows for the use the <bpt id="p1">**</bpt>let<ept id="p1">**</ept> clause, which allows you to introduce and bind a variable within the scope of the expression, using it in subsequent pieces of the expression.</source>
          <target state="translated">쿼리 구문에서는 <bpt id="p1">**</bpt>let<ept id="p1">**</ept> 절을 사용할 수 있습니다. 이 절을 통해 식 범위 내에서 변수를 도입 및 바인딩하고 식의 후속 부분에서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Reproducing the same code with only the API syntax can be done, but will most likely lead to code which is hard to read.</source>
          <target state="translated">API 구문만 사용하여 동일한 코드를 재현할 수도 있지만 읽기 어려운 코드가 될 가능성이 큽니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>So this begs the question, <bpt id="p1">**</bpt>should you just use the query syntax?<ept id="p1">**</ept></source>
          <target state="translated">따라서 <bpt id="p1">**</bpt>쿼리 구문을 사용해야 하나요?<ept id="p1">**</ept>란 질문을 하게 됩니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The answer to this question is <bpt id="p1">**</bpt>yes<ept id="p1">**</ept> if...</source>
          <target state="translated">다음과 같은 경우 이 질문에 대한 대답은 <bpt id="p1">**</bpt>예<ept id="p1">**</ept>입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Your existing codebase already uses the query syntax</source>
          <target state="translated">기존 코드베이스에서 이미 쿼리 구문을 사용하는 경우</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You need to scope variables within your queries due to complexity</source>
          <target state="translated">복잡성으로 인해 쿼리 내에서 변수 범위를 지정해야 하는 경우</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>You prefer the query syntax and it won’t distract from your codebase</source>
          <target state="translated">쿼리 구문을 선호하며 코드베이스에 방해가 되지 않는 경우</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The answer to this question is <bpt id="p1">**</bpt>no<ept id="p1">**</ept> if...</source>
          <target state="translated">다음과 같은 경우 이 질문에 대한 대답은 <bpt id="p1">**</bpt>아니요<ept id="p1">**</ept>입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Your existing codebase already uses the API syntax</source>
          <target state="translated">기존 코드베이스에서 이미 API 구문을 사용하는 경우</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You have no need to scope variables within your queries</source>
          <target state="translated">쿼리 내에서 변수 범위를 지정할 필요가 없는 경우</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You prefer the API syntax and it won’t distract from your codebase</source>
          <target state="translated">API 구문을 선호하며 코드베이스에 방해가 되지 않는 경우</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Essential Samples</source>
          <target state="translated">필수 샘플</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For a truly comprehensive list of LINQ samples, visit <bpt id="p1">[</bpt>101 LINQ Samples<ept id="p1">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept>.</source>
          <target state="translated">LINQ 샘플의 포괄적인 목록은 <bpt id="p1">[</bpt>101 LINQ 샘플<ept id="p1">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The following is a quick demonstration of some of the essential pieces of LINQ.</source>
          <target state="translated">다음은 일부 LINQ 핵심 부분의 간단한 데모입니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This is in no way comprehensive, as LINQ provides significantly more functionality than what is showcased here.</source>
          <target state="translated">LINQ는 여기에 설명된 것보다 훨씬 더 많은 기능을 제공하기 때문에 포괄적인 목록은 아닙니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The bread and butter - <ph id="ph1">`Where`</ph>, <ph id="ph2">`Select`</ph>, and <ph id="ph3">`Aggregate`</ph>:</source>
          <target state="translated">가장 중요한 요소 - <ph id="ph1">`Where`</ph>, <ph id="ph2">`Select`</ph> 및 <ph id="ph3">`Aggregate`</ph>:</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Flattening a list of lists:</source>
          <target state="translated">목록의 목록 평면화:</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Union between two sets (with custom comparator):</source>
          <target state="translated">두 집합 간의 합집합(사용자 지정 비교 연산자 사용):</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Intersection between two sets:</source>
          <target state="translated">두 집합 간의 교집합:</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Ordering:</source>
          <target state="translated">순서:</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Finally, a more advanced sample: determining if the values of the properties of two instances of the same type are equal (Borrowed and modified from <bpt id="p1">[</bpt>this StackOverflow post<ept id="p1">](http://stackoverflow.com/a/844855)</ept>):</source>
          <target state="translated">마지막으로, 고급 샘플: 동일한 형식을 가진 두 인스턴스의 속성 값이 같은지 확인(<bpt id="p1">[</bpt>이 StackOverflow 게시물<ept id="p1">](http://stackoverflow.com/a/844855)</ept>에서 가져와 수정함):</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>PLINQ</source>
          <target state="translated">PLINQ</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>PLINQ, or Parallel LINQ, is a parallel execution engine for LINQ expressions.</source>
          <target state="translated">PLINQ 또는 병렬 LINQ는 LINQ 식에 대한 병렬 실행 엔진입니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In other words, a regular LINQ expressions can be trivially parallelized across any number of threads.</source>
          <target state="translated">즉, 여러 스레드 간에 LINQ 정규식을 일반적으로 병렬화할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This is accomplished via a call to <ph id="ph1">`AsParallel()`</ph> preceding the expression.</source>
          <target state="translated">이 작업은 식 앞의 <ph id="ph1">`AsParallel()`</ph> 호출을 통해 수행됩니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">다음을 살펴보세요.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This code will partition <ph id="ph1">`facebookUsers`</ph> across system threads as necessary, sum up the total likes on each thread in parallel, sum the results computed by each thread, and project that result into a nice string.</source>
          <target state="translated">이 코드는 필요에 따라 시스템 스레드 간에 <ph id="ph1">`facebookUsers`</ph>를 분할하고, 각 스레드의 총계를 병렬로 합산한 다음, 각 스레드에서 계산된 결과를 합산하고 그 결과를 멋진 문자열로 프로젝션합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In diagram form:</source>
          <target state="translated">다이어그램 형식:</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>PLINQ diagram</source>
          <target state="translated">PLINQ 다이어그램</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Parallelizable CPU-bound jobs which can be easily expressed via LINQ (in other words, are pure functions and have no side effects) are a great candidate for PLINQ.</source>
          <target state="translated">LINQ를 통해 쉽게 표현될 수 있는 병렬화 가능한 CPU 바인딩된 작업(즉, 순수 함수이며 부작용 없음)에 PLINQ를 사용하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For jobs which <bpt id="p1">_</bpt>do<ept id="p1">_</ept> have a side effect, consider using the <bpt id="p2">[</bpt>Task Parallel Library<ept id="p2">](https://msdn.microsoft.com/library/dd460717.aspx)</ept>.</source>
          <target state="translated">부작용이 <bpt id="p1">_</bpt>있는<ept id="p1">_</ept> 작업의 경우 <bpt id="p2">[</bpt>작업 병렬 라이브러리<ept id="p2">](https://msdn.microsoft.com/library/dd460717.aspx)</ept>를 사용하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Further Resources:</source>
          <target state="translated">추가 리소스:</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>101 LINQ Samples<ept id="p1">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>101 LINQ 샘플<ept id="p1">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Linqpad<ept id="p1">](https://www.linqpad.net/)</ept>, a playground environment and Database querying engine for C#/F#/VB</source>
          <target state="translated"><bpt id="p1">[</bpt>Linqpad<ept id="p1">](https://www.linqpad.net/)</ept>, 실습 환경 및 C#/F#/VB에 대한 데이터베이스 쿼리 엔진</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>EduLinq<ept id="p1">](http://codeblog.jonskeet.uk/2011/02/23/reimplementing-linq-to-objects-part-45-conclusion-and-list-of-posts/)</ept>, an e-book for learning how LINQ-to-objects is implemented</source>
          <target state="translated"><bpt id="p1">[</bpt>EduLinq<ept id="p1">](http://codeblog.jonskeet.uk/2011/02/23/reimplementing-linq-to-objects-part-45-conclusion-and-list-of-posts/)</ept>, LINQ-to-objects 구현 방법 학습을 위한 전자책</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>