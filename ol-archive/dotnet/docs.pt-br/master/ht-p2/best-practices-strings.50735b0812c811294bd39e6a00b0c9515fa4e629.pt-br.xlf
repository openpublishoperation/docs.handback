<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3efd30bade564fe1b7dbf93237a9ff40c58c5f1e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\best-practices-strings.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e466b1fa40bcf6a82fdf2349f2b6346dd591d696</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">32d24a667cd981642c7344e4a4899a410e95b9f2</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Best practices for using strings</source>
          <target state="translated">Práticas recomendadas para o uso de cadeias de caracteres</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Best practices for using strings</source>
          <target state="translated">Práticas recomendadas para o uso de cadeias de caracteres</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Best practices for using strings</source>
          <target state="translated">Práticas recomendadas para o uso de cadeias de caracteres</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>.NET provides extensive support for developing localized and globalized applications, and makes it easy to apply the conventions of either the current culture or a specific culture when performing common operations such as sorting and displaying strings.</source>
          <target state="translated">O .NET dá um amplo suporte para desenvolvimento de aplicativos localizados e globalizados e torna mais fácil aplicar as convenções da cultura atual ou de uma cultura específica ao executar operações comuns, como a classificação e a exibição cadeias de caracteres.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>But sorting or comparing strings is not always a culture-sensitive operation.</source>
          <target state="translated">Mas a classificação ou a comparação de cadeias de caracteres nem sempre é uma operação que leva em conta a cultura.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, strings that are used internally by an application typically should be handled identically across all cultures.</source>
          <target state="translated">Por exemplo, cadeias de caracteres que são usadas internamente por um aplicativo normalmente devem ser manipuladas de maneira idêntica em todas as culturas.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When culturally independent string data, such as XML tags, HTML tags, user names, file paths, and the names of system objects, are interpreted as if they were culture-sensitive, application code can be subject to subtle bugs, poor performance, and, in some cases, security issues.</source>
          <target state="translated">Quando os dados de cadeias de caracteres culturalmente independentes, como marcações XML, marcações HTML, nomes de usuário, caminhos de arquivo e nomes de objetos do sistema, são interpretados como se levassem em conta a cultura, o código do aplicativo pode estar sujeito a bugs sutis, desempenho ruim e, em alguns casos, problemas de segurança.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This article examines the string sorting, comparison, and casing methods in .NET, presents recommendations for selecting an appropriate string-handling method, and provides additional information about string-handling methods.</source>
          <target state="translated">Este artigo examina os métodos de classificação, comparação e o uso de maiúsculas e minúsculas de cadeias de caracteres no .NET, apresenta recomendações para a seleção de um método de manipulação de cadeia de caracteres adequado e fornece informações adicionais sobre os métodos de manipulação de cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It also examines how formatted data, such as numeric data and date and time data, is handled for display and for storage.</source>
          <target state="translated">Ela também examina como os dados formatados, como dados numéricos e dados de data e hora, são manipulados para exibição e armazenamento.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This article contains the following sections:</source>
          <target state="translated">Este artigo contém as seguintes seções:</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Recommendations for string usage<ept id="p1">](#recommendations-for-string-usage)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recomendações para uso da cadeia de caracteres<ept id="p1">](#recommendations-for-string-usage)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Specifying string comparisons explicitly<ept id="p1">](#specifying-string-comparisons-explicitly)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Especificação explícita de comparações da cadeia de caracteres<ept id="p1">](#specifying-string-comparisons-explicitly)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The details of string comparison<ept id="p1">](#the-details-of-string-comparison)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Os detalhes da comparação de cadeia de caracteres<ept id="p1">](#the-details-of-string-comparison)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Choosing a StringComparison member for your method call<ept id="p1">](#choosing-a-stringcomparison-member-for-your-method-call)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Escolha de um membro StringComparison para a chamada de método<ept id="p1">](#choosing-a-stringcomparison-member-for-your-method-call)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Common string comparison methods<ept id="p1">](#common-string-comparison-methods)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Métodos comuns de comparação da cadeia de caracteres<ept id="p1">](#common-string-comparison-methods)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Methods that perform string comparison indirectly<ept id="p1">](#methods-that-perform-string-comparison-indirectly)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Métodos que realizam comparação indireta de cadeia de caracteres<ept id="p1">](#methods-that-perform-string-comparison-indirectly)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Displaying and persisting formatted data<ept id="p1">](#displaying-and-persisting-formatted-data)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Exibição e persistência de dados formatados<ept id="p1">](#displaying-and-persisting-formatted-data)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Recommendations for string usage</source>
          <target state="translated">Recomendações para uso da cadeia de caracteres</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>When you develop with .NET, follow these simple recommendations when you use strings:</source>
          <target state="translated">Ao desenvolver com o .NET, siga estas recomendações simples quando usar cadeias de caracteres:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Use overloads that explicitly specify the string comparison rules for string operations.</source>
          <target state="translated">Use sobrecargas que especificam explicitamente as regras de comparação de cadeias de caracteres para operações de cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Typically, this involves calling a method overload that has a parameter of type <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</source>
          <target state="translated">Normalmente, isso envolve chamar uma sobrecarga de método que tem um parâmetro do tipo <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> or <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> for comparisons as your safe default for culture-agnostic string matching.</source>
          <target state="translated">Use <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> ou <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> para comparações como seu padrão seguro para a correspondência de cadeia de caracteres independente de cultura.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Use comparisons with <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> or <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> for better performance.</source>
          <target state="translated">Use comparações com <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> ou <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> para melhorar o desempenho.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Use string operations that are based on <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept> when you display output to the user.</source>
          <target state="translated">Use operações de cadeia de caracteres que se baseiam em <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept> ao exibir a saída para o usuário.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Use the non-linguistic <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> or <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> values instead of string operations based on <bpt id="p3">[</bpt>CultureInfo.InvariantCulture<ept id="p3">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> when the comparison is linguistically irrelevant (symbolic, for example).</source>
          <target state="translated">Use valores <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> ou <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> não linguísticos em vez de operações de cadeias de caracteres com base em <bpt id="p3">[</bpt>CultureInfo.InvariantCulture<ept id="p3">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> quando a comparação for linguisticamente irrelevante (simbólica, por exemplo).</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>String.ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> method instead of the <bpt id="p2">[</bpt>String.ToLowerInvariant<ept id="p2">](xref:System.String.ToLowerInvariant)</ept> method when you normalize strings for comparison.</source>
          <target state="translated">Use o método <bpt id="p1">[</bpt>String.ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> em vez do método <bpt id="p2">[</bpt>String.ToLowerInvariant<ept id="p2">](xref:System.String.ToLowerInvariant)</ept> ao normalizar cadeias de caracteres para comparação.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Use an overload of the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Equals`</ph> method to test whether two strings are equal.</source>
          <target state="translated">Use uma sobrecarga do método <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Equals`</ph> para testar se duas cadeias de caracteres são iguais.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Use an overload of the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> and <bpt id="p2">[</bpt>String.CompareTo<ept id="p2">](xref:System.String.CompareTo(System.String))</ept> methods to sort strings, not to check for equality.</source>
          <target state="translated">Use uma sobrecarga dos métodos <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> e <bpt id="p2">[</bpt>String.CompareTo<ept id="p2">](xref:System.String.CompareTo(System.String))</ept> para classificar as cadeias de caracteres, não para verificar a igualdade.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Use culture-sensitive formatting to display non-string data, such as numbers and dates, in a user interface.</source>
          <target state="translated">Use a formatação que leva em conta a cultura para exibir dados que não são de cadeias de caracteres, como números e datas, em uma interface do usuário.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Use formatting with the invariant culture to persist non-string data in string form.</source>
          <target state="translated">Use a formatação com a cultura invariável para persistir os dados que não são de cadeias de caracteres no formato de cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Avoid the following practices when you use strings:</source>
          <target state="translated">Evite as práticas a seguir ao usar cadeias de caracteres:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Do not use overloads that do not explicitly or implicitly specify the string comparison rules for string operations.</source>
          <target state="translated">Não use sobrecargas que não especificam explicita ou implicitamente as regras de comparação de cadeias de caracteres para operações de cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Do not use an overload of the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> or <bpt id="p2">[</bpt>String.CompareTo<ept id="p2">](xref:System.String.CompareTo(System.String))</ept> methods and test for a return value of zero to determine whether two strings are equal.</source>
          <target state="translated">Não use uma sobrecarga dos métodos <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> ou <bpt id="p2">[</bpt>String.CompareTo<ept id="p2">](xref:System.String.CompareTo(System.String))</ept> e teste para um valor retornado de zero para determinar se duas cadeias de caracteres são iguais.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Do not use culture-sensitive formatting to persist numeric data or date and time data in string form.</source>
          <target state="translated">Não use a formatação que leva em conta a cultura para persistir dados numéricos ou dados de data e hora no formato de cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Specifying string comparisons explicitly</source>
          <target state="translated">Especificação explícita de comparações da cadeia de caracteres</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Most of the string manipulation methods in .NET are overloaded.</source>
          <target state="translated">A maioria dos métodos de manipulação de cadeia de caracteres no .NET é sobrecarregada.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Typically, one or more overloads accept default settings, whereas others accept no defaults and instead define the precise way in which strings are to be compared or manipulated.</source>
          <target state="translated">Normalmente, uma ou mais sobrecargas aceitam as configurações padrão, enquanto outras não aceitam nenhum padrão e definem a maneira exata em que as cadeias de caracteres devem ser comparadas ou manipuladas.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Most of the methods that do not rely on defaults include a parameter of type <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>, which is an enumeration that explicitly specifies rules for string comparison by culture and case.</source>
          <target state="translated">A maioria dos métodos que não dependem de padrões inclui um parâmetro do tipo <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>, que é uma enumeração que especifica explicitamente as regras de comparação de cadeia de caracteres por cultura e maiúsculas e minúsculas.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The following table describes the <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> enumeration members.</source>
          <target state="translated">A tabela a seguir descreve os membros de enumeração de <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>StringComparison member</source>
          <target state="translated">Membro de StringComparison</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept></target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Performs a case-sensitive comparison using the current culture.</source>
          <target state="translated">Executa uma comparação que diferencia maiúsculas de minúsculas usando a cultura atual.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CurrentCultureIgnoreCase<ept id="p1">](xref:System.StringComparison.CurrentCultureIgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>CurrentCultureIgnoreCase<ept id="p1">](xref:System.StringComparison.CurrentCultureIgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Performs a case-insensitive comparison using the current culture.</source>
          <target state="translated">Executa uma comparação que não diferencia maiúsculas de minúsculas usando a cultura atual.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Performs an ordinal comparison.</source>
          <target state="translated">Executa uma comparação ordinal.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Performs a case-insensitive ordinal comparison.</source>
          <target state="translated">Executa uma comparação ordinal que não diferencia maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> method, which returns the index of a substring in a <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> object that matches either a character or a string, has nine overloads:</source>
          <target state="translated">Por exemplo, o método <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph>, que retorna um índice de uma subcadeia de caracteres em um objeto <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> que corresponde a um caractere ou cadeia de caracteres, tem nove sobrecargas:</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IndexOf(Char)<ept id="p1">](xref:System.String.IndexOf(System.Char))</ept>, <bpt id="p2">[</bpt>IndexOf(Char, Int32)<ept id="p2">](xref:System.String.IndexOf(System.Char,System.Int32))</ept>, and <bpt id="p3">[</bpt>IndexOf(Char, Int32, Int32)<ept id="p3">](xref:System.String.IndexOf(System.Char,System.Int32,System.Int32))</ept>, which by default perform an ordinal (case-sensitive and culture-insensitive) search for a character in the string.</source>
          <target state="translated"><bpt id="p1">[</bpt>IndexOf(Char)<ept id="p1">](xref:System.String.IndexOf(System.Char))</ept>, <bpt id="p2">[</bpt>IndexOf(Char, Int32)<ept id="p2">](xref:System.String.IndexOf(System.Char,System.Int32))</ept> e <bpt id="p3">[</bpt>IndexOf(Char, Int32, Int32)<ept id="p3">](xref:System.String.IndexOf(System.Char,System.Int32,System.Int32))</ept>, que por padrão executam uma pesquisa ordinal (diferencia maiúsculas de minúsculas e não leva em consideração a cultura) para um caractere na cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IndexOf(String)<ept id="p1">](xref:System.String.IndexOf(System.String))</ept>, <bpt id="p2">[</bpt>IndexOf(String, Int32)<ept id="p2">](xref:System.String.IndexOf(System.String,System.Int32))</ept>, and <bpt id="p3">[</bpt>IndexOf(String, Int32, Int32)<ept id="p3">](xref:System.String.IndexOf(System.String,System.Int32,System.Int32))</ept>, which by default perform a case-sensitive and culture-sensitive search for a substring in the string.</source>
          <target state="translated"><bpt id="p1">[</bpt>IndexOf(String)<ept id="p1">](xref:System.String.IndexOf(System.String))</ept>, <bpt id="p2">[</bpt>IndexOf(String, Int32)<ept id="p2">](xref:System.String.IndexOf(System.String,System.Int32))</ept> e <bpt id="p3">[</bpt>IndexOf(String, Int32, Int32)<ept id="p3">](xref:System.String.IndexOf(System.String,System.Int32,System.Int32))</ept>, que por padrão executam uma pesquisa que diferencia maiúsculas de minúsculas e leva em consideração a cultura para uma subcadeia de caracteres na cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IndexOf(String, StringComparison)<ept id="p1">](xref:System.String.IndexOf(System.String,System.StringComparison))</ept>, <bpt id="p2">[</bpt>IndexOf(String, Int32, StringComparison)<ept id="p2">](xref:System.String.IndexOf(System.String,System.Int32,System.StringComparison))</ept>, and <bpt id="p3">[</bpt>IndexOf(String, Int32, Int32, StringComparison)<ept id="p3">](xref:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison))</ept>, which include a parameter of type StringComparison that allows the form of the comparison to be specified.</source>
          <target state="translated"><bpt id="p1">[</bpt>IndexOf(String, StringComparison)<ept id="p1">](xref:System.String.IndexOf(System.String,System.StringComparison))</ept>, <bpt id="p2">[</bpt>IndexOf(String, Int32, StringComparison)<ept id="p2">](xref:System.String.IndexOf(System.String,System.Int32,System.StringComparison))</ept> e <bpt id="p3">[</bpt>IndexOf(String, Int32, Int32, StringComparison)<ept id="p3">](xref:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison))</ept>, que incluem um parâmetro de tipo StringComparison que permite que a forma de comparação seja especificada.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>We recommend that you select an overload that does not use default values, for the following reasons:</source>
          <target state="translated">É recomendável que você selecione uma sobrecarga que não usa valores padrão, pelos seguintes motivos:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Some overloads with default parameters (those that search for a <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept> in the string instance) perform an ordinal comparison, whereas others (those that search for a string in the string instance) are culture-sensitive.</source>
          <target state="translated">Algumas sobrecargas com parâmetros padrão (aqueles que pesquisam um <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept> na instância de cadeia de caracteres) realizam uma comparação ordinal, enquanto outras (aquelas que pesquisam uma cadeia de caracteres na instância de cadeia de caracteres) levam em consideração a cultura.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It is difficult to remember which method uses which default value, and easy to confuse the overloads.</source>
          <target state="translated">É difícil lembrar qual método usa o valor padrão e é fácil confundir as sobrecargas.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The intent of the code that relies on default values for method calls is not clear.</source>
          <target state="translated">A intenção do código que depende de valores padrão para chamadas de método não é clara.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In the following example, which relies on defaults, it is difficult to know whether the developer actually intended an ordinal or a linguistic comparison of two strings, or whether a case difference between <ph id="ph1">`protocol`</ph> and "http" might cause the test for equality to return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">No exemplo a seguir, que se baseia em padrões, é difícil saber se o desenvolvedor realmente planejava uma comparação ordinal ou linguística de duas cadeias de caracteres ou se uma diferença entre maiúsculas e minúsculas entre <ph id="ph1">`protocol`</ph> e “http” pode fazer com que o teste de igualdade retorne <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you call a method that does not rely on defaults, because it makes the intent of the code unambiguous.</source>
          <target state="translated">Em geral, é recomendável que você chame um método que não se baseie em padrões, pois ele torna a intenção do código clara.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This, in turn, makes the code more readable and easier to debug and maintain.</source>
          <target state="translated">Isso, por sua vez, torna o código mais legível e fácil de depurar e manter.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The following example addresses the questions raised about the previous example.</source>
          <target state="translated">O exemplo a seguir aborda as questões levantadas sobre o exemplo anterior.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>It makes it clear that ordinal comparison is used and that differences in case are ignored.</source>
          <target state="translated">Ele deixa claro que a comparação ordinal é usada e que as diferenças de maiúsculas e minúsculas são ignoradas.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The details of string comparison</source>
          <target state="translated">Os detalhes da comparação de cadeia de caracteres</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>String comparison is the heart of many string-related operations, particularly sorting and testing for equality.</source>
          <target state="translated">A comparação de cadeia de caracteres é o centro de muitas operações relacionadas à cadeia de caracteres, especialmente a classificação e teste de igualdade.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Strings sort in a determined order: If "my" appears before "string" in a sorted list of strings, "my" must compare less than or equal to "string".</source>
          <target state="translated">As cadeias de caracteres são classificadas em uma determinada ordem: se “my” aparece antes de “string” em uma lista classificada de cadeias de caracteres, “my” deve comparar menos que ou igual a “string”.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Additionally, comparison implicitly defines equality.</source>
          <target state="translated">Além disso, a comparação define implicitamente a igualdade.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The comparison operation returns zero for strings it deems equal.</source>
          <target state="translated">A operação de comparação retorna zero para cadeias de caracteres que considerar iguais.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A good interpretation is that neither string is less than the other.</source>
          <target state="translated">Uma boa interpretação é que nenhuma cadeia de caracteres é menor que a outra.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Most meaningful operations involving strings include one or both of these procedures: comparing with another string, and executing a well-defined sort operation.</source>
          <target state="translated">Operações mais significativas envolvendo cadeias de caracteres incluem um ou ambos destes procedimentos: comparação com outra cadeia de caracteres e execução de uma operação de classificação bem definida.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>However, evaluating two strings for equality or sort order does not yield a single, correct result; the outcome depends on the criteria used to compare the strings.</source>
          <target state="translated">No entanto, avaliar duas cadeias de caracteres quanto à igualdade ou ordem de classificação não gera um único resultado correto, o resultado depende dos critérios usados para comparar as cadeias de caracteres.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>In particular, string comparisons that are ordinal or that are based on the casing and sorting conventions of the current culture or the invariant culture (a locale-agnostic culture based on the English language) may produce different results.</source>
          <target state="translated">Em particular, as comparações de cadeia de caracteres ordinais ou baseadas no uso de maiúsculas e minúsculas e convenções classificação da cultura atual ou da cultura invariável (uma cultura independente de localidade com base no idioma inglês) podem gerar resultados diferentes.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>String comparisons that use the current culture</source>
          <target state="translated">Comparações de cadeia de caracteres que usam a cultura atual</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>One criterion involves using the conventions of the current culture when comparing strings.</source>
          <target state="translated">Um critério envolve o uso das convenções da cultura atual ao comparar cadeias de caracteres.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Comparisons that are based on the current culture use the thread's current culture or locale.</source>
          <target state="translated">As comparações que se baseiam na cultura atual usam a localidade ou a cultura atual do thread.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You should always use comparisons that are based on the current culture when data is linguistically relevant, and when it reflects culture-sensitive user interaction.</source>
          <target state="translated">Você deve sempre usar comparações que se baseiam na cultura atual quando os dados forem linguisticamente relevantes e quando eles refletirem a interação do usuário que leva em conta a cultura.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, comparison and casing behavior in .NET changes when the culture changes.</source>
          <target state="translated">No entanto, o comportamento da comparação e do uso de maiúsculas e minúsculas no .NET muda quando a cultura muda.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This happens when an application executes on a computer that has a different culture than the computer on which the application was developed, or when the executing thread changes its culture.</source>
          <target state="translated">Isso acontece quando um aplicativo é executado em um computador que tem uma cultura diferente do computador em que o aplicativo foi desenvolvido ou quando o thread em execução muda sua cultura.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This behavior is intentional, but it remains non-obvious to many developers.</source>
          <target state="translated">Esse comportamento é intencional, mas permanece não óbvio para muitos desenvolvedores.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following example illustrates differences in sort order between the U.S. English ("en-US") and Swedish ("sv-SE") cultures.</source>
          <target state="translated">O exemplo a seguir ilustra as diferenças na ordem de classificação entre as culturas de inglês dos EUA ("en-US") e sueco ("sv-SE").</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Note that the words "ångström", "Windows", and "Visual Studio" appear in different positions in the sorted string arrays.</source>
          <target state="translated">Observe que as palavras "ångström", "Windows" e "Visual Studio" aparecem em posições diferentes nas matrizes de cadeias de caracteres classificadas.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Case-insensitive comparisons that use the current culture are the same as culture-sensitive comparisons, except that they ignore case as dictated by the thread's current culture.</source>
          <target state="translated">As comparações que não diferenciam maiúsculas de minúsculas que usam a cultura atual são iguais às comparações que levam em conta a cultura, exceto que elas ignoram as maiúsculas e minúsculas conforme determinado pela cultura atual do thread.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This behavior may manifest itself in sort orders as well.</source>
          <target state="translated">Esse comportamento pode se manifestar em ordens de classificação também.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Comparisons that use current culture semantics are the default for the following methods:</source>
          <target state="translated">As comparações que usam a semântica de cultura atual são o padrão para os seguintes métodos:</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> overloads that do not include a <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> parameter.</source>
          <target state="translated">Sobrecargas <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> que não incluem um parâmetro <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String.CompareTo<ept id="p1">](xref:System.String.CompareTo(System.String))</ept> overloads.</source>
          <target state="translated">Sobrecargas <bpt id="p1">[</bpt>String.CompareTo<ept id="p1">](xref:System.String.CompareTo(System.String))</ept>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The default <bpt id="p1">[</bpt>String.StartsWith(String)<ept id="p1">](xref:System.String.StartsWith(System.String))</ept> method.</source>
          <target state="translated">O método <bpt id="p1">[</bpt>String.StartsWith(String)<ept id="p1">](xref:System.String.StartsWith(System.String))</ept> padrão.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The default <bpt id="p1">[</bpt>String.EndsWith(String)<ept id="p1">](xref:System.String.EndsWith(System.String))</ept> method.</source>
          <target state="translated">O método <bpt id="p1">[</bpt>String.EndsWith(String)<ept id="p1">](xref:System.String.EndsWith(System.String))</ept> padrão.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> overloads that accept a <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> as a search parameter and that do not have a <bpt id="p3">[</bpt>StringComparison<ept id="p3">](xref:System.StringComparison)</ept> parameter.</source>
          <target state="translated">Sobrecargas <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> que aceitam uma <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> como um parâmetro de pesquisa e que não têm um parâmetro <bpt id="p3">[</bpt>StringComparison<ept id="p3">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`LastIndexOf`</ph> overloads that accept a <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> as a search parameter and that do not have a <bpt id="p3">[</bpt>StringComparison<ept id="p3">](xref:System.StringComparison)</ept> parameter.</source>
          <target state="translated">Sobrecargas <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`LastIndexOf`</ph> que aceitam uma <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> como um parâmetro de pesquisa e que não têm um parâmetro <bpt id="p3">[</bpt>StringComparison<ept id="p3">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>In any case, we recommend that you call an overload that has a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> parameter to make the intent of the method call clear.</source>
          <target state="translated">Em qualquer caso, é recomendável que você chame uma sobrecarga que tenha um parâmetro <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> para deixar a intenção da chamada do método clara.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Subtle and not so subtle bugs can emerge when non-linguistic string data is interpreted linguistically, or when string data from a particular culture is interpreted using the conventions of another culture.</source>
          <target state="translated">Bugs sutis e não tão sutis podem surgir quando dados de cadeias de caracteres não linguísticas são interpretados linguisticamente ou quando os dados da cadeia de caracteres de uma cultura específica são interpretados usando as convenções de outra cultura.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The canonical example is the Turkish-I problem.</source>
          <target state="translated">O exemplo canônico é o problema do I turco.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For nearly all Latin alphabets, including U.S. English, the character "i" (\u0069) is the lowercase version of the character "I" (\u0049).</source>
          <target state="translated">Para quase todos os alfabetos latinos, incluindo o do inglês dos EUA, o caractere "i" (\u0069) é a versão em letra minúscula do caractere "I" (\u0049).</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This casing rule quickly becomes the default for someone programming in such a culture.</source>
          <target state="translated">Essa regra de maiúsculas e minúsculas rapidamente se torna o padrão para alguém programando em tal cultura.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>However, the Turkish ("tr-TR") alphabet includes an "I with a dot" character "İ" (\u0130), which is the capital version of "i".</source>
          <target state="translated">No entanto, o alfabeto turco ("tr-TR") inclui um caractere "I com um ponto", "İ" (\u0130), que é a versão maiúscula de "i".</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Turkish also includes a lowercase "i without a dot" character, "ı" (\u0131), which capitalizes to "I".</source>
          <target state="translated">O turco também inclui um caractere minúsculo "i sem um ponto", "ı" (\u0131), que em maiúscula é “I”.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This behavior occurs in the Azerbaijani ("az") culture as well.</source>
          <target state="translated">Esse comportamento também ocorre na cultura azerbaidjana ("az").</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Therefore, assumptions made about capitalizing "i" or lowercasing "I" are not valid among all cultures.</source>
          <target state="translated">Portanto, as suposições feitas sobre a colocação do "i" em maiúscula ou do "I" em minúscula não são válidas entre todas as culturas.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>If you use the default overloads for string comparison routines, they will be subject to variance between cultures.</source>
          <target state="translated">Se você usar as sobrecargas padrão para rotinas de comparação de cadeias de caracteres, elas estarão sujeitas à variação entre culturas.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If the data to be compared is non-linguistic, using the default overloads can produce undesirable results, as the following attempt to perform a case-insensitive comparison of the strings "file" and "FILE" illustrates.</source>
          <target state="translated">Se os dados a serem comparados são forem linguísticos, o uso das sobrecargas padrão pode gerar resultados indesejáveis, como a tentativa a seguir de realizar uma comparação que não diferencia maiúsculas de minúsculas das cadeias de caracteres “file” e “FILE” ilustra.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This comparison could cause significant problems if the culture is inadvertently used in security-sensitive settings, as in the following example.</source>
          <target state="translated">Essa comparação pode causar problemas significativos se a cultura for usada inadvertidamente nas configurações sensíveis à segurança, como no exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>A method call such as <ph id="ph1">`IsFileURI("file:")`</ph> returns <ph id="ph2">`true`</ph> if the current culture is U.S. English, but <ph id="ph3">`false`</ph> if the current culture is Turkish.</source>
          <target state="translated">Uma chamada de método, como <ph id="ph1">`IsFileURI("file:")`</ph> retorna <ph id="ph2">`true`</ph> se a cultura atual for inglês dos EUA, mas <ph id="ph3">`false`</ph> se a cultura atual for turco.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Thus, on Turkish systems, someone could circumvent security measures that block access to case-insensitive URIs that begin with "FILE:".</source>
          <target state="translated">Assim, em sistemas turcos, alguém poderia driblar as medidas de segurança que bloqueiam o acesso a URIs que não diferenciam maiúsculas de minúsculas que começam com “FILE:”.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>In this case, because "file:" is meant to be interpreted as a non-linguistic, culture-insensitive identifier, the code should instead be written as shown in the following example.</source>
          <target state="translated">Nesse caso, como "file:" deve ser interpretado como um identificador não linguístico que não leva em conta a cultura, o código deveria ser escrito como mostrado no exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Ordinal String Operations</source>
          <target state="translated">Operações Ordinais da Cadeia de Caracteres</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Specifying the <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> or <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> value in a method call signifies a non-linguistic comparison in which the features of natural languages are ignored.</source>
          <target state="translated">Especificar o valor <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> ou <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> em uma chamada de método significa uma comparação não linguística em que as funcionalidades de idiomas naturais são ignoradas.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Methods that are invoked with these <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> values base string operation decisions on simple byte comparisons instead of casing or equivalence tables that are parameterized by culture.</source>
          <target state="translated">Os métodos que são invocados com esses valores de <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> baseiam as decisões de operação da cadeia de caracteres em comparações de byte simples em vez de no uso de maiúsculas e minúsculas ou tabelas de equivalência que são parametrizadas pela cultura.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In most cases, this approach best fits the intended interpretation of strings while making code faster and more reliable.</source>
          <target state="translated">Na maioria dos casos, essa abordagem se adapta melhor à interpretação pretendida de cadeias de caracteres, enquanto torna o código mais rápido e confiável.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Ordinal comparisons are string comparisons in which each byte of each string is compared without linguistic interpretation; for example, "windows" does not match "Windows".</source>
          <target state="translated">Comparações ordinais são comparações de cadeia de caracteres nas quais cada byte de cada cadeia de caracteres é comparado sem a interpretação linguística, por exemplo, “windows” não corresponde a “Windows”.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Use this comparison when the context dictates that strings should be matched exactly or demands conservative matching policy.</source>
          <target state="translated">Use essa comparação quando o contexto determinar que as cadeias de caracteres devem corresponder exatamente ou exigir uma política de correspondência conservadora.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Additionally, ordinal comparison is the fastest comparison operation because it applies no linguistic rules when determining a result.</source>
          <target state="translated">Além disso, a comparação ordinal é a operação de comparação mais rápida porque ela não aplica nenhuma regra linguística ao determinar um resultado.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Strings in .NET can contain embedded null characters.</source>
          <target state="translated">As cadeias de caracteres no .NET podem conter caracteres nulos inseridos.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>One of the clearest differences between ordinal and culture-sensitive comparison (including comparisons that use the invariant culture) concerns the handling of embedded null characters in a string.</source>
          <target state="translated">Uma das diferenças mais clara entre a comparação ordinal e a que leva em conta a cultura (incluindo comparações que usam a cultura invariável) diz respeito à manipulação de caracteres nulos inseridos em uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>These characters are ignored when you use the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> and <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph2">`Equals`</ph> methods to perform culture-sensitive comparisons (including comparisons that use the invariant culture).</source>
          <target state="translated">Esses caracteres são ignorados quando você usa os métodos <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> e <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph2">`Equals`</ph> para realizar comparações que levam em conta a cultura (incluindo comparações que usam a cultura invariável).</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>As a result, in culture-sensitive comparisons, strings that contain embedded null characters can be considered equal to strings that do not.</source>
          <target state="translated">Como resultado, em comparações que levam em conta a cultura, cadeias de caracteres que contêm caracteres nulos inseridos podem ser consideradas iguais a cadeias de caracteres que não contêm.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Although string comparison methods disregard embedded null characters, string search methods such as <bpt id="p1">[</bpt>String.Contains<ept id="p1">](xref:System.String.Contains(System.String))</ept>, <bpt id="p2">[</bpt>String.EndsWith<ept id="p2">](xref:System.String.EndsWith(System.String))</ept>, <bpt id="p3">[</bpt>String.IndexOf<ept id="p3">](xref:System.String.IndexOf(System.Char))</ept>, <bpt id="p4">[</bpt>String.LastIndexOf<ept id="p4">](xref:System.String.LastIndexOf(System.String))</ept>, and <bpt id="p5">[</bpt>String.StartsWith<ept id="p5">](xref:System.String.StartsWith(System.String))</ept> do not.</source>
          <target state="translated">Embora os métodos de comparação de cadeia de caracteres ignorem caracteres nulos inseridos, os métodos de pesquisa de cadeia de caracteres como <bpt id="p1">[</bpt>String.Contains<ept id="p1">](xref:System.String.Contains(System.String))</ept>, <bpt id="p2">[</bpt>String.EndsWith<ept id="p2">](xref:System.String.EndsWith(System.String))</ept>, <bpt id="p3">[</bpt>String.IndexOf<ept id="p3">](xref:System.String.IndexOf(System.Char))</ept>, <bpt id="p4">[</bpt>String.LastIndexOf<ept id="p4">](xref:System.String.LastIndexOf(System.String))</ept> e <bpt id="p5">[</bpt>String.StartsWith<ept id="p5">](xref:System.String.StartsWith(System.String))</ept> não.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following example performs a culture-sensitive comparison of the string "Aa" with a similar string that contains several embedded null characters between "A" and "a", and shows how the two strings are considered equal.</source>
          <target state="translated">O exemplo a seguir executa uma comparação que leva em conta a cultura da cadeia de caracteres "Aa" com uma cadeia de caracteres semelhante que contém vários caracteres nulos inseridos entre "A" e "a" e mostra como as duas cadeias de caracteres são consideradas iguais.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>However, the strings are not considered equal when you use ordinal comparison, as the following example shows.</source>
          <target state="translated">No entanto, as cadeias de caracteres não são consideradas iguais ao usar a comparação ordinal, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Case-insensitive ordinal comparisons are the next most conservative approach.</source>
          <target state="translated">As comparações ordinais que não diferenciam maiúsculas de minúsculas são a próxima abordagem conservadora.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>These comparisons ignore most casing; for example, "windows" matches "Windows".</source>
          <target state="translated">Essas comparações ignoram a maioria das maiúsculas e minúsculas, por exemplo, "windows" corresponde a "Windows".</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>When dealing with ASCII characters, this policy is equivalent to <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>, except that it ignores the usual ASCII casing.</source>
          <target state="translated">Ao lidar com caracteres ASCII, essa política é equivalente a <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>, exceto que ela ignora as maiúsculas e minúsculas de ASCII normais.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Therefore, any character in [A, Z] (\u0041-\u005A) matches the corresponding character in [a,z] (\u0061-\007A).</source>
          <target state="translated">Portanto, qualquer caractere em [A, Z] (\u0041-\u005A) corresponde ao caractere correspondente em [a,z] (\u0061-\007A).</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Casing outside the ASCII range uses the invariant culture's tables.</source>
          <target state="translated">As maiúsculas e minúsculas fora do intervalo de ASCII usam as tabelas de cultura invariável.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Therefore, the following comparison:</source>
          <target state="translated">Portanto, a comparação a seguir:</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>is equivalent to (but faster than) this comparison:</source>
          <target state="translated">é equivalente a (mas mais rápida do que) esta comparação:</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>These comparisons are still very fast.</source>
          <target state="translated">Essas comparações ainda são muito rápidas.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Both <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> and <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> use the binary values directly, and are best suited for matching.</source>
          <target state="translated">Ambas <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> e <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> usam os valores binários diretamente e são mais adequadas para correspondência.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>When you are not sure about your comparison settings, use one of these two values.</source>
          <target state="translated">Quando você não tiver certeza sobre as configurações de comparação, use um destes dois valores.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>However, because they perform a byte-by-byte comparison, they do not sort by a linguistic sort order (like an English dictionary) but by a binary sort order.</source>
          <target state="translated">No entanto, como elas executam uma comparação byte por byte, elas não classificam por uma ordem de classificação linguística (como um dicionário de inglês), mas por ordem de classificação binária.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The results may look odd in most contexts if displayed to users.</source>
          <target state="translated">Os resultados podem parecer estranhos na maioria dos contextos se exibido aos usuários.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Ordinal semantics are the default for <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Equals`</ph> overloads that do not include a <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> argument (including the equality operator).</source>
          <target state="translated">A semântica ordinal é o padrão para sobrecargas <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Equals`</ph> que não incluem um argumento <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> (incluindo o operador de igualdade).</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>In any case, we recommend that you call an overload that has a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> parameter.</source>
          <target state="translated">Em qualquer caso, é recomendável que você chame uma sobrecarga que tenha um parâmetro <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>String operations that use the invariant culture</source>
          <target state="translated">Operações da cadeia de caracteres que usam a cultura invariável</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Comparisons with the invariant culture use the <bpt id="p1">[</bpt>CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> property returned by the static <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> property.</source>
          <target state="translated">As comparações com a cultura invariável usam a propriedade <bpt id="p1">[</bpt>CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> retornada pela propriedade <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> estática.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>This behavior is the same on all systems; it translates any characters outside its range into what it believes are equivalent invariant characters.</source>
          <target state="translated">Esse comportamento é o mesmo em todos os sistemas, ele converte qualquer caractere fora de seu intervalo no que ele acredita que sejam caracteres invariáveis equivalentes.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>This policy can be useful for maintaining one set of string behavior across cultures, but it often provides unexpected results.</source>
          <target state="translated">Essa política pode ser útil para manter um conjunto de comportamentos de cadeia de caracteres entre culturas, mas geralmente fornece resultados inesperados.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Case-insensitive comparisons with the invariant culture use the static <bpt id="p1">[</bpt>CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> property returned by the static <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> property for comparison information as well.</source>
          <target state="translated">As comparações que não diferenciam maiúsculas de minúsculas com a cultura invariável usam a propriedade <bpt id="p1">[</bpt>CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> estática retornada pela propriedade <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> estática para informações de comparação também.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Any case differences among these translated characters are ignored.</source>
          <target state="translated">As diferenças de maiúsculas e minúsculas entre esses caracteres convertidos são ignoradas.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>CultureInfo.InvariantCulture<ept id="p1">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> object makes a <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> method interpret certain sets of characters as equivalent.</source>
          <target state="translated">O objeto <bpt id="p1">[</bpt>CultureInfo.InvariantCulture<ept id="p1">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> objeto faz um método <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> interpretar determinados conjuntos de caracteres como equivalentes.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For example, the following equivalence is valid under the invariant culture:</source>
          <target state="translated">Por exemplo, a equivalência a seguir é válida na cultura invariável:</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>InvariantCulture: a + ̊ = å</source>
          <target state="translated">InvariantCulture: a + ̊ = å</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The latin small lette A character "a" (\u0061), when it is next to the combining ring above character "+ " ̊" (\u030a), is interpreted as the latin small letter A with ring above character "å" (\u00e5).</source>
          <target state="translated">O caractere da letra A minúscula latina “a” (\u0061), quando ele está próximo ao caractere de anel superior combinável "+ " ̊" (\u030a), é interpretado como a letra A minúscula latina com o caractere de anel superior "å" (\u00e5).</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>As the following example shows, this behavior differs from ordinal comparison.</source>
          <target state="translated">Como mostra o exemplo a seguir, esse comportamento é diferente da comparação ordinal.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>When interpreting file names, cookies, or anything else where a combination such as "å" can appear, ordinal comparisons still offer the most transparent and fitting behavior.</source>
          <target state="translated">Ao interpretar nomes de arquivo, cookies ou qualquer outro elemento em que uma combinação como "å" pode aparecer, as comparações ordinais ainda oferecem o comportamento mais transparente e adequado.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>On balance, the invariant culture has very few properties that make it useful for comparison.</source>
          <target state="translated">De forma geral, a cultura invariável tem muito poucas propriedades que a tornam útil para comparação.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>It does comparison in a linguistically relevant manner, which prevents it from guaranteeing full symbolic equivalence, but it is not the choice for display in any culture.</source>
          <target state="translated">Ela faz a comparação de maneira linguisticamente relevante, o que impede que ela garanta a equivalência simbólica total, mas não é a opção de exibição em nenhuma cultura.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>For example, if a large data file that contains a list of sorted identifiers for display accompanies an application, adding to this list would require an insertion with invariant-style sorting.</source>
          <target state="translated">Por exemplo, se um arquivo de dados grande que contém uma lista de identificadores classificados para exibição acompanha um aplicativo, a adição a essa lista exige uma inserção com a inserção de estilo invariável.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Choosing a StringComparison member for your method call</source>
          <target state="translated">Escolha de um membro StringComparison para a chamada de método</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The following table outlines the mapping from semantic string context to a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> enumeration member.</source>
          <target state="translated">A tabela a seguir descreve o mapeamento do contexto semântico da cadeia de caracteres para um membro de enumeração <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Data</source>
          <target state="translated">Dados</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Comportamento</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Corresponding System.StringComparison value</source>
          <target state="translated">Valor de System.StringComparison correspondente</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Case-sensitive internal identifiers, case-sensitive identifiers in standards such as XML and HTTP, or case-sensitive security-related settings.</source>
          <target state="translated">Identificadores internos que diferenciam maiúsculas de minúsculas, identificadores que diferenciam maiúsculas de minúsculas em padrões, como XML e HTTP ou configurações relacionadas à segurança que diferenciam maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>A non-linguistic identifier, where bytes match exactly.</source>
          <target state="translated">Um identificador não linguístico, em que bytes correspondem exatamente.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept></target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Case-insensitive internal identifiers, case-insensitive identifiers in standards such as XML and HTTP, file paths, registry keys and values, environment variables, resource identifiers (for example, handle names), or case-insensitive security-related settings.</source>
          <target state="translated">Identificadores internos que não diferenciam maiúsculas de minúsculas, identificadores que não diferenciam maiúsculas de minúsculas em padrões, como XML e HTTP, caminhos de arquivo, valores e chave de Registro, variáveis do ambiente, identificadores de recurso (por exemplo nomes de identificador) ou configurações relacionadas à segurança que não diferenciam maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>A non-linguistic identifier, where case is irrelevant.</source>
          <target state="translated">Um identificador não linguístico, em que as maiúsculas e minúsculas são irrelevantes.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Data displayed to the user or most user input.</source>
          <target state="translated">Dados exibidos para o usuário ou para a maioria das entradas do usuário.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Data that requires local linguistic customs.</source>
          <target state="translated">Dados que exigem os costumes linguísticos locais.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept> or <bpt id="p2">[</bpt>CurrentCultureIgnoreCase<ept id="p2">](xref:System.StringComparison.CurrentCultureIgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept> ou <bpt id="p2">[</bpt>CurrentCultureIgnoreCase<ept id="p2">](xref:System.StringComparison.CurrentCultureIgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Common string comparison methods</source>
          <target state="translated">Métodos comuns de comparação da cadeia de caracteres</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The following sections describe the methods that are most commonly used for string comparison.</source>
          <target state="translated">As seções a seguir descrevem os métodos que são mais comumente usados para a comparação de cadeias de caracteres.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>String.Compare</source>
          <target state="translated">String.Compare</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interpretação padrão: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>As the operation most central to string interpretation, all instances of these method calls should be examined to determine whether strings should be interpreted according to the current culture, or dissociated from the culture (symbolically).</source>
          <target state="translated">Como a operação mais central da interpretação de cadeia de caracteres, todas as instâncias de chamadas desse método devem ser examinadas para determinar se as cadeias de caracteres devem ser interpretadas de acordo com a cultura atual ou dissociadas da cultura (simbolicamente).</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Typically, it is the latter, and a <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> comparison should be used instead.</source>
          <target state="translated">Normalmente, é o último e uma comparação de <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> deve ser usada.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>System.Globalization.CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> class, which is returned by the <bpt id="p2">[</bpt>CultureInfo.CompareInfo<ept id="p2">](xref:System.Globalization.CultureInfo.CompareInfo)</ept> property, also includes a <bpt id="p3">[</bpt>Compare<ept id="p3">](xref:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32,System.Globalization.CompareOptions))</ept> method that provides a large number of matching options (ordinal, ignoring white space, ignoring kana type, and so on) by means of the <bpt id="p4">[</bpt>CompareOptions<ept id="p4">](xref:System.Globalization.CompareOptions)</ept> flag enumeration.</source>
          <target state="translated">A classe <bpt id="p1">[</bpt>System.Globalization.CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept>, que é retornada pela propriedade <bpt id="p2">[</bpt>CultureInfo.CompareInfo<ept id="p2">](xref:System.Globalization.CultureInfo.CompareInfo)</ept>, também inclui um método <bpt id="p3">[</bpt>Compare<ept id="p3">](xref:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32,System.Globalization.CompareOptions))</ept> que fornece um grande número de opções de correspondência (ordinal, ignorando os espaços em branco, ignorando o tipo kana e assim por diante) por meio da enumeração de sinalizador <bpt id="p4">[</bpt>CompareOptions<ept id="p4">](xref:System.Globalization.CompareOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>String.CompareTo</source>
          <target state="translated">String.CompareTo</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interpretação padrão: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>This method does not currently offer an overload that specifies a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> type.</source>
          <target state="translated">Esse método no momento não oferece uma sobrecarga que especifica um tipo <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>It is usually possible to convert this method to the recommended <bpt id="p1">[</bpt>String.Compare(String, String, StringComparison)<ept id="p1">](xref:System.String.Compare(System.String,System.String,System.StringComparison))</ept> form.</source>
          <target state="translated">Normalmente é possível converter esse método para o formato <bpt id="p1">[</bpt>String.Compare(String, String, StringComparison)<ept id="p1">](xref:System.String.Compare(System.String,System.String,System.StringComparison))</ept> recomendado.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Types that implement the <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> and <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept> interfaces implement this method.</source>
          <target state="translated">Os tipos que implementam as interfaces <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> e <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept> implementam esse método.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Because it does not offer the option of a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> parameter, implementing types often let the user specify a <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> in their constructor.</source>
          <target state="translated">Como ele não oferece a opção de um parâmetro <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>, os tipos de implementação geralmente permitem que o usuário especifique um <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> em seu construtor.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`FileName`</ph> class whose class constructor includes a <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> parameter.</source>
          <target state="translated">O exemplo a seguir define uma classe <ph id="ph1">`FileName`</ph> cujo construtor de classe inclui um parâmetro <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is then used in the <ph id="ph1">`FileName.CompareTo`</ph> method.</source>
          <target state="translated">Esse objeto <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> é então usado no método <ph id="ph1">`FileName.CompareTo`</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>String.Equals</source>
          <target state="translated">String.Equals</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>.</source>
          <target state="translated">Interpretação padrão: <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> class lets you test for equality by calling either the static or instance <ph id="ph1">`Equals`</ph> method overloads, or by using the static equality operator.</source>
          <target state="translated">A classe <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> permite que você teste a igualdade chamando as sobrecargas do método <ph id="ph1">`Equals`</ph> ou estáticas ou usando o operador de igualdade estático.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The overloads and operator use ordinal comparison by default.</source>
          <target state="translated">O operador e as sobrecargas utilizam a comparação ordinal por padrão.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>However, we still recommend that you call an overload that explicitly specifies the <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> type even if you want to perform an ordinal comparison; this makes it easier to search code for a certain string interpretation.</source>
          <target state="translated">No entanto, ainda é recomendável que você chame uma sobrecarga que especifique explicitamente o tipo <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> mesmo se você desejar executar uma comparação ordinal. Isso facilita a pesquisa de código para uma determinada interpretação da cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>String.ToUpper and String.ToLower</source>
          <target state="translated">String.ToUpper e String.ToLower</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interpretação padrão: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>You should be careful when you use these methods, because forcing a string to a uppercase or lowercase is often used as a small normalization for comparing strings regardless of case.</source>
          <target state="translated">Você deve ter cuidado ao usar esses métodos, pois forçar uma cadeia de caracteres para maiúsculas ou minúsculas normalmente é usado como uma normalização pequena para comparar cadeias de caracteres independentemente de maiúsculas e minúsculas.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>If so, consider using a case-insensitive comparison.</source>
          <target state="translated">Nesse caso, considere o uso de uma comparação que não diferencie maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>String.ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> and <bpt id="p2">[</bpt>String.ToLowerInvariant<ept id="p2">](xref:System.String.ToLowerInvariant)</ept> methods are also available.</source>
          <target state="translated">Os métodos <bpt id="p1">[</bpt>String.ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> e <bpt id="p2">[</bpt>String.ToLowerInvariant<ept id="p2">](xref:System.String.ToLowerInvariant)</ept> também estão disponíveis.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> is the standard way to normalize case.</source>
          <target state="translated"><bpt id="p1">[</bpt>ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> é o modo padrão de normalizar as maiúsculas e minúsculas.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Comparisons made using <bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> are behaviorally the composition of two calls: calling <bpt id="p2">[</bpt>ToUpperInvariant<ept id="p2">](xref:System.String.ToUpperInvariant)</ept> on both string arguments, and doing a comparison using <bpt id="p3">[</bpt>StringComparison.Ordinal<ept id="p3">](xref:System.StringComparison.Ordinal)</ept>.</source>
          <target state="translated">Comparações feitas usando <bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> são comportamentalmente a composição de duas chamadas: chamar <bpt id="p2">[</bpt>ToUpperInvariant<ept id="p2">](xref:System.String.ToUpperInvariant)</ept> nos dois argumentos da cadeia de caracteres e fazer uma comparação usando <bpt id="p3">[</bpt>StringComparison.Ordinal<ept id="p3">](xref:System.StringComparison.Ordinal)</ept>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Overloads are also available for converting to uppercase and lowercase in a specific culture, by passing a <bpt id="p1">[</bpt>CultureInfo<ept id="p1">](xref:System.Globalization.CultureInfo)</ept> object that represents that culture to the method.</source>
          <target state="translated">Também há sobrecargas disponíveis para converter para maiúsculas e minúsculas em uma cultura específica, passando um objeto <bpt id="p1">[</bpt>CultureInfo<ept id="p1">](xref:System.Globalization.CultureInfo)</ept> que representa aquela cultura para o método.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Char.ToUpper and Char.ToLower</source>
          <target state="translated">Char.ToUpper e Char.ToLower</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interpretação padrão: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>These methods work similarly to the <bpt id="p1">[</bpt>String.ToUpper<ept id="p1">](xref:System.String.ToUpper)</ept> and <bpt id="p2">[</bpt>String.ToLower<ept id="p2">](xref:System.String.ToLower)</ept> methods described in the previous section.</source>
          <target state="translated">Esses métodos funcionam de forma semelhante aos métodos <bpt id="p1">[</bpt>String.ToUpper<ept id="p1">](xref:System.String.ToUpper)</ept> e <bpt id="p2">[</bpt>String.ToLower<ept id="p2">](xref:System.String.ToLower)</ept> descritos na seção anterior.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>String.StartsWith and String.EndsWith</source>
          <target state="translated">String.StartsWith e String.EndsWith</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interpretação padrão: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>By default, both of these methods perform a culture-sensitive comparison.</source>
          <target state="translated">Por padrão, esses dois métodos executam uma comparação que leva em conta a cultura.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>String.IndexOf and String.LastIndexOf</source>
          <target state="translated">String.IndexOf e String.LastIndexOf</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interpretação padrão: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>There is a lack of consistency in how the default overloads of these methods perform comparisons.</source>
          <target state="translated">Há uma falta de consistência em como as sobrecargas padrão desses métodos realizam comparações.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>All <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> and <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph2">`LastIndexOf`</ph> methods that include a <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept> parameter perform an ordinal comparison, but the default <bpt id="p4">[</bpt>String<ept id="p4">](xref:System.String)</ept> <ph id="ph3">`IndexOf`</ph> and [String<ph id="ph4">`](xref:System.String) `</ph>LastIndexOf` methods that include a <bpt id="p5">[</bpt>String<ept id="p5">](xref:System.String)</ept> parameter perform a culture-sensitive comparison.</source>
          <target state="translated">Todos os métodos <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> e <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph2">`LastIndexOf`</ph> que incluem um parâmetro <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept> realizam uma comparação ordinal, mas os métodos <bpt id="p4">[</bpt>String<ept id="p4">](xref:System.String)</ept> <ph id="ph3">`IndexOf`</ph> e [String<ph id="ph4">`](xref:System.String) `</ph>LastIndexOf` padrão que incluem um parâmetro <bpt id="p5">[</bpt>String<ept id="p5">](xref:System.String)</ept> realizam uma comparação que leva em conta a cultura.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>If you call <ph id="ph1">` `</ph>IndexOf<ph id="ph2">` or `</ph>LastIndexOf` method and pass it a string to locate in the current instance, we recommend that you call an overload that explicitly specifies the <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> type.</source>
          <target state="translated">Se você chamar o método <ph id="ph1">` `</ph>IndexOf<ph id="ph2">` or `</ph>LastIndexOf` e passar a ele uma cadeia de caracteres para localizar na instância atual, é recomendável que você chame uma sobrecarga que especifique explicitamente o tipo <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The overloads that include a <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept> argument do not allow you to specify a <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> type.</source>
          <target state="translated">As sobrecargas que incluem um argumento <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept> não permitem que você especifique um tipo <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Methods that perform string comparison indirectly</source>
          <target state="translated">Métodos que realizam comparação indireta de cadeia de caracteres</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Some non-string methods that have string comparison as a central operation use the <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> type.</source>
          <target state="translated">Alguns métodos que não de cadeias de caracteres que têm a comparação de cadeia de caracteres como uma operação central usam o tipo <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> class includes four static properties that return <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> instances whose <ph id="ph1">`Compare`</ph> methods perform the following types of string comparisons:</source>
          <target state="translated">A classe <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> inclui quatro propriedades estáticas que retornam instâncias <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> cujos métodos <ph id="ph1">`Compare`</ph> realizam os seguintes tipos de comparações de cadeias de caracteres:</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Culture-sensitive string comparisons using the current culture.</source>
          <target state="translated">Comparações de cadeias de caracteres que levam em conta a cultura usando a cultura atual.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is returned by the <bpt id="p2">[</bpt>StringComparer.CurrentCulture<ept id="p2">](xref:System.StringComparer.CurrentCulture)</ept> property.</source>
          <target state="translated">Esse objeto <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> é retornado pela propriedade <bpt id="p2">[</bpt>StringComparer.CurrentCulture<ept id="p2">](xref:System.StringComparer.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Case-insensitive comparisons using the current culture.</source>
          <target state="translated">Comparações que não diferenciam maiúsculas de minúsculas usando a cultura atual.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is returned by the <bpt id="p2">[</bpt>StringComparer.CurrentCultureIgnoreCase<ept id="p2">](xref:System.StringComparer.CurrentCultureIgnoreCase)</ept> property.</source>
          <target state="translated">Esse objeto <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> é retornado pela propriedade <bpt id="p2">[</bpt>StringComparer.CurrentCultureIgnoreCase<ept id="p2">](xref:System.StringComparer.CurrentCultureIgnoreCase)</ept>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Ordinal comparison.</source>
          <target state="translated">Comparação ordinal.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is returned by the <bpt id="p2">[</bpt>StringComparer.Ordinal<ept id="p2">](xref:System.StringComparer.Ordinal)</ept> property.</source>
          <target state="translated">Esse objeto <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> é retornado pela propriedade <bpt id="p2">[</bpt>StringComparer.Ordinal<ept id="p2">](xref:System.StringComparer.Ordinal)</ept>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Case-insensitive ordinal comparison.</source>
          <target state="translated">Comparação ordinal que não diferencia maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is returned by the <bpt id="p2">[</bpt>StringComparer.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparer.OrdinalIgnoreCase)</ept> property.</source>
          <target state="translated">Esse objeto <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> é retornado pela propriedade <bpt id="p2">[</bpt>StringComparer.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparer.OrdinalIgnoreCase)</ept>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Array.Sort and Array.BinarySearch</source>
          <target state="translated">Array.Sort e Array.BinarySearch</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">Interpretação padrão: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>When you store any data in a collection, or read persisted data from a file or database into a collection, switching the current culture can invalidate the invariants in the collection.</source>
          <target state="translated">Ao armazenar quaisquer dados em uma coleção ou ler dados persistentes de um arquivo ou banco de dados em uma coleção, alternar a cultura atual pode invalidar as invariáveis na coleção.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Array.BinarySearch<ept id="p1">](xref:System.Array.BinarySearch(System.Array,System.Object))</ept> method assumes that the elements in the array to be searched are already sorted.</source>
          <target state="translated">O método <bpt id="p1">[</bpt>Array.BinarySearch<ept id="p1">](xref:System.Array.BinarySearch(System.Array,System.Object))</ept> assume que os elementos na matriz a serem pesquisados já estão classificados.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>To sort any string element in the array, the <bpt id="p1">[</bpt>Array.Sort<ept id="p1">](xref:System.Array.Sort(System.Array))</ept> method calls the [String] <ph id="ph1">`Compare`</ph> method to order individual elements.</source>
          <target state="translated">Para classificar qualquer elemento de cadeia de caracteres na matriz, o método <bpt id="p1">[</bpt>Array.Sort<ept id="p1">](xref:System.Array.Sort(System.Array))</ept> chama o método [String] <ph id="ph1">`Compare`</ph> para ordenar os elementos individuais.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Using a culture-sensitive comparer can be dangerous if the culture changes between the time that the array is sorted and its contents are searched.</source>
          <target state="translated">Usar um comparador que leva em conta a cultura pode ser perigoso se a cultura mudar entre o momento em que a matriz é ordenada e que seu conteúdo é pesquisado.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>For example, in the following code, storage and retrieval operate on the comparer that is provided implicitly by the <ph id="ph1">`Thread.CurrentThread.CurrentCulture`</ph> property.</source>
          <target state="translated">Por exemplo, no código a seguir, o armazenamento e a recuperação operam no comparador que é fornecido implicitamente pela propriedade <ph id="ph1">`Thread.CurrentThread.CurrentCulture`</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>If the culture can change between the calls to <ph id="ph1">`StoreNames`</ph> and <ph id="ph2">`DoesNameExist`</ph>, and especially if the array contents are persisted somewhere between the two method calls, the binary search may fail.</source>
          <target state="translated">Se a cultura puder mudar entre as chamadas para <ph id="ph1">`StoreNames`</ph> e <ph id="ph2">`DoesNameExist`</ph>, e especialmente se os conteúdos da matriz forem mantidos em algum lugar entre as duas chamadas de método, a pesquisa binária poderá falhar.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>A recommended variation appears in the following example, which uses the same ordinal (culture-insensitive) comparison method both to sort and to search the array.</source>
          <target state="translated">Uma variação recomendada é exibida no exemplo a seguir, que usa o mesmo método de comparação (que não leva em conta a cultura) ordinal para classificar e pesquisar a matriz.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The change code is reflected in the lines labeled <ph id="ph1">`Line A`</ph> and <ph id="ph2">`Line B`</ph> in the two examples.</source>
          <target state="translated">O código de alteração é refletido nas linhas rotuladas como <ph id="ph1">`Line A`</ph> e <ph id="ph2">`Line B`</ph> nos dois exemplos.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>If this data is persisted and moved across cultures, and sorting is used to present this data to the user, you might consider using <ph id="ph1">`StringComparison.InvariantCulture`</ph>, which operates linguistically for better user output but is unaffected by changes in culture.</source>
          <target state="translated">Se esses dados forem mantidos e movidos entre as culturas e a classificação for usada para apresentar esses dados para o usuário, você pode considerar usar <ph id="ph1">`StringComparison.InvariantCulture`</ph>, que opera linguisticamente para a melhor saída do usuário, mas não é afetado pelas alterações na cultura.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The following example modifies the two previous examples to use the invariant culture for sorting and searching the array.</source>
          <target state="translated">O exemplo a seguir modifica os dois exemplos anteriores para usar a cultura invariável para classificar e pesquisar a matriz.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Collections Example: Hashtable Constructor</source>
          <target state="translated">Exemplo de Coleções: Construtor da Tabela de Hash</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Hashing strings provides a second example of an operation that is affected by the way in which strings are compared.</source>
          <target state="translated">As cadeias de caracteres de hash fornecem um segundo exemplo de uma operação que é afetada pela maneira como as cadeias de caracteres são comparadas.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following example instantiates a <bpt id="p1">[</bpt>Hashtable<ept id="p1">](xref:System.Collections.Hashtable)</ept> object by passing it the <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> object that is returned by the <bpt id="p3">[</bpt>StringComparer.OrdinalIgnoreCase<ept id="p3">](xref:System.StringComparer.OrdinalIgnoreCase)</ept> property.</source>
          <target state="translated">O exemplo a seguir instancia um objeto <bpt id="p1">[</bpt>Hashtable<ept id="p1">](xref:System.Collections.Hashtable)</ept> passando para ele o objeto <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> que é retornado pela propriedade <bpt id="p3">[</bpt>StringComparer.OrdinalIgnoreCase<ept id="p3">](xref:System.StringComparer.OrdinalIgnoreCase)</ept>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Because a class <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> that is derived from <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> implements the <bpt id="p3">[</bpt>IEqualityComparer<ept id="p3">](xref:System.Collections.IEqualityComparer)</ept> interface, its <bpt id="p4">[</bpt>GetHashCode<ept id="p4">](xref:System.Collections.IEqualityComparer)</ept> method is used to compute the hash code of strings in the hash table.</source>
          <target state="translated">Como uma classe <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> que é derivada de <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> implementa a interface <bpt id="p3">[</bpt>IEqualityComparer<ept id="p3">](xref:System.Collections.IEqualityComparer)</ept>, seu método <bpt id="p4">[</bpt>GetHashCode<ept id="p4">](xref:System.Collections.IEqualityComparer)</ept> é usado para calcular o código hash das cadeias de caracteres na tabela de hash.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Displaying and persisting formatted data</source>
          <target state="translated">Exibição e persistência de dados formatados</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>When you display non-string data such as numbers and dates and times to users, format them by using the user's cultural settings.</source>
          <target state="translated">Quando você exibir dados que não são de cadeias de caracteres como números e datas e horas para os usuários, formate-os usando as configurações culturais do usuário.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>By default, the <bpt id="p1">[</bpt>String.Format<ept id="p1">](xref:System.String.Format(System.IFormatProvider,System.String,System.Object))</ept> method and the <ph id="ph1">`ToString`</ph> methods of the numeric types and the date and time types use the current thread culture for formatting operations.</source>
          <target state="translated">Por padrão, o método <bpt id="p1">[</bpt>String.Format<ept id="p1">](xref:System.String.Format(System.IFormatProvider,System.String,System.Object))</ept> e os métodos <ph id="ph1">`ToString`</ph> dos tipos numéricos e dos tipos de data e hora usam a cultura do thread atual para as operações de formatação.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>To explicitly specify that the formatting method should use the current culture, you can call an overload of a formatting method that has a provider parameter, such as <bpt id="p1">[</bpt>String.Format(IFormatProvider, String, Object[])<ept id="p1">](xref:System.String.Format(System.IFormatProvider,System.String,System.Object))</ept> or <bpt id="p2">[</bpt>DateTime.ToString(IFormatProvider)<ept id="p2">](xref:System.DateTime.ToString(System.IFormatProvider))</ept>, and pass it the <bpt id="p3">[</bpt>CultureInfo.CurrentCulture<ept id="p3">](xref:System.Globalization.CultureInfo.CurrentCulture)</ept> property.</source>
          <target state="translated">Para especificar explicitamente que o método de formatação deve usar a cultura atual, você pode chamar uma sobrecarga de um método de formatação que tenha um parâmetro de provedor, como <bpt id="p1">[</bpt>String.Format(IFormatProvider, String, Object[])<ept id="p1">](xref:System.String.Format(System.IFormatProvider,System.String,System.Object))</ept> ou <bpt id="p2">[</bpt>DateTime.ToString(IFormatProvider)<ept id="p2">](xref:System.DateTime.ToString(System.IFormatProvider))</ept> e passar para ela a propriedade <bpt id="p3">[</bpt>CultureInfo.CurrentCulture<ept id="p3">](xref:System.Globalization.CultureInfo.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>You can persist non-string data either as binary data or as formatted data.</source>
          <target state="translated">Você pode manter os dados que não são de cadeias de caracteres como dados binários ou como dados formatados.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>If you choose to save it as formatted data, you should call a formatting method overload that includes a <bpt id="p1">*</bpt>provider<ept id="p1">*</ept> parameter and pass it the <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> property.</source>
          <target state="translated">Se optar por salvá-los como dados formatados, você deve chamar uma sobrecarga de método de formatação que inclua um parâmetro <bpt id="p1">*</bpt>provider<ept id="p1">*</ept> e passar para ele a propriedade <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The invariant culture provides a consistent format for formatted data that is independent of culture and machine.</source>
          <target state="translated">A cultura invariável fornece um formato consistente para os dados formatados que é independente da cultura e do computador.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>In contrast, persisting data that is formatted by using cultures other than the invariant culture has a number of limitations:</source>
          <target state="translated">Em contraste, dados persistentes que são formatados usando culturas diferentes da cultura invariável têm várias limitações:</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The data is likely to be unusable if it is retrieved on a system that has a different culture, or if the user of the current system changes the current culture and tries to retrieve the data.</source>
          <target state="translated">É provável que os dados não sejam utilizáveis se forem recuperados em um sistema que tem uma cultura diferente ou se o usuário do sistema atual alterar a cultura atual e tentar recuperar os dados.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The properties of a culture on a specific computer can differ from standard values.</source>
          <target state="translated">As propriedades de uma cultura em um computador específico podem ser diferentes dos valores padrão.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>At any time, a user can customize culture-sensitive display settings.</source>
          <target state="translated">A qualquer momento, um usuário pode personalizar as configurações de exibição que levam em conta a cultura.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Because of this, formatted data that is saved on a system may not be readable after the user customizes cultural settings.</source>
          <target state="translated">Devido a isso, os dados formatados que são salvos em um sistema podem não ser legíveis após o usuário personalizar as configurações culturais.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The portability of formatted data across computers is likely to be even more limited.</source>
          <target state="translated">É provável que a portabilidade dos dados formatados entre computadores seja ainda mais limitada.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>International, regional, or national standards that govern the formatting of numbers or dates and times change over time, and these changes are incorporated into operating system updates.</source>
          <target state="translated">Os padrões internacionais, regionais ou nacionais que controlam a formatação de números ou datas e horas são alterados ao longo do tempo e essas alterações são incorporadas nas atualizações do sistema operacional.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>When formatting conventions change, data that was formatted by using the previous conventions may become unreadable.</source>
          <target state="translated">Quando as convenções de formatação mudam, os dados que foram formatados usando as convenções anteriores podem se tornar ilegíveis.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The following example illustrates the limited portability that results from using culture-sensitive formatting to persist data.</source>
          <target state="translated">O exemplo a seguir ilustra a portabilidade limitada resultante do uso da formatação que leva em conta a cultura para manter os dados.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The example saves an array of date and time values to a file.</source>
          <target state="translated">O exemplo salva uma matriz de valores de data e hora em um arquivo.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>These are formatted by using the conventions of the English (United States) culture.</source>
          <target state="translated">Eles são formatados usando as convenções da cultura do inglês (Estados Unidos).</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>After the application changes the current thread culture to French (Switzerland), it tries to read the saved values by using the formatting conventions of the current culture.</source>
          <target state="translated">Depois que o aplicativo altera a cultura do thread atual para francês (Suíça), ele tenta ler os valores salvos usando as convenções de formatação da cultura atual.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The attempt to read two of the data items throws a <bpt id="p1">[</bpt>FormatException<ept id="p1">](xref:System.FormatException)</ept> exception, and the array of dates now contains two incorrect elements that are equal to <bpt id="p2">[</bpt>MinValue<ept id="p2">](xref:System.DateTime.MinValue)</ept>.</source>
          <target state="translated">A tentativa de ler dois dos itens de dados gera uma exceção <bpt id="p1">[</bpt>FormatException<ept id="p1">](xref:System.FormatException)</ept> e a matriz de datas agora contém dois elementos incorretos que são iguais a <bpt id="p2">[</bpt>MinValue<ept id="p2">](xref:System.DateTime.MinValue)</ept>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>However, if you replace the <bpt id="p1">[</bpt>CultureInfo.CurrentCulture<ept id="p1">](xref:System.Globalization.CultureInfo.CurrentCulture)</ept> property with <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> in the calls to <bpt id="p3">[</bpt>DateTime.ToString(String, IFormatProvider)<ept id="p3">](xref:System.DateTime.ToString(System.String,System.IFormatProvider))</ept> and <bpt id="p4">[</bpt>DateTime.Parse(String, IFormatProvider)<ept id="p4">](xref:System.DateTime.Parse(System.String,System.IFormatProvider))</ept>, the persisted date and time data is successfully restored, as the following output shows.</source>
          <target state="translated">No entanto, se você substituir a propriedade <bpt id="p1">[</bpt>CultureInfo.CurrentCulture<ept id="p1">](xref:System.Globalization.CultureInfo.CurrentCulture)</ept> por <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> nas chamadas para <bpt id="p3">[</bpt>DateTime.ToString(String, IFormatProvider)<ept id="p3">](xref:System.DateTime.ToString(System.String,System.IFormatProvider))</ept> e <bpt id="p4">[</bpt>DateTime.Parse(String, IFormatProvider)<ept id="p4">](xref:System.DateTime.Parse(System.String,System.IFormatProvider))</ept>, os dados de data e hora mantidos serão restaurados com êxito, como a saída a seguir mostra.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Consulte também</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Manipulating strings<ept id="p1">](manipulating-strings.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Manipulação de cadeias de caracteres<ept id="p1">](manipulating-strings.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>