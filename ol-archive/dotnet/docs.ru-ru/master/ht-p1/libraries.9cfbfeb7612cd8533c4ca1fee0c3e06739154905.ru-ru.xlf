<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">de44f103bef6006dd1a952c48c1e172f6277a95b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tutorials\libraries.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6f2b04e8d5c448a63da146c4d53652c491dd6280</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc2affac42c561e4630e4e5f6d52ededbb77a46e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Developing Libraries with Cross Platform Tools</source>
          <target state="translated">Разработка библиотек с помощью кроссплатформенных средств</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Developing Libraries with Cross Platform Tools</source>
          <target state="translated">Разработка библиотек с помощью кроссплатформенных средств</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Developing Libraries with Cross Platform Tools</source>
          <target state="translated">Разработка библиотек с помощью кроссплатформенных средств</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Some details are subject to change as the toolchain evolves.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Некоторые сведения могут меняться по мере развития цепочки инструментов.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This article covers how to write libraries for .NET using cross-platform CLI tools.</source>
          <target state="translated">В этой статье рассматривается создание библиотек для .NET с помощью кроссплатформенных средств интерфейса командной строки (CLI).</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The CLI provides an efficient and low-level experience that works across any supported OS.</source>
          <target state="translated">CLI предоставляет эффективный и низкоуровневый интерфейс, работающий в любых поддерживаемых операционных системах.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You can still build libraries with Visual Studio, and if that is your preferred experience <bpt id="p1">[</bpt>refer to the Visual Studio guide<ept id="p1">](libraries-with-vs.md)</ept>.</source>
          <target state="translated">Вы по-прежнему можете создавать библиотеки с помощью Visual Studio. Если вы предпочитаете такой способ, обратитесь к <bpt id="p1">[</bpt>руководству по Visual Studio<ept id="p1">](libraries-with-vs.md)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">Предварительные требования</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You need <bpt id="p1">[</bpt>the .NET Core SDK and CLI<ept id="p1">](https://www.microsoft.com/net/core)</ept> installed on your machine.</source>
          <target state="translated">На компьютере должны быть установлены <bpt id="p1">[</bpt>пакет SDK и интерфейс CLI для .NET Core <ept id="p1">](https://www.microsoft.com/net/core)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For the sections of this document dealing with .NET Framework versions or Portable Class Libraries (PCL), you need the <bpt id="p1">[</bpt>.NET Framework<ept id="p1">](http://getdotnet.azurewebsites.net/)</ept> installed on a Windows machine.</source>
          <target state="translated">Для разделов этого документа, касающихся версий .NET Framework или переносимых библиотек классов (PCL), необходима платформа <bpt id="p1">[</bpt>.NET Framework<ept id="p1">](http://getdotnet.azurewebsites.net/)</ept>, установленная на компьютере с Windows.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Additionally, if you wish to support older .NET Framework targets, you need to install targeting/developer packs for older framework versions from the <bpt id="p1">[</bpt>.NET target platforms page<ept id="p1">](http://getdotnet.azurewebsites.net/target-dotnet-platforms.html)</ept>.</source>
          <target state="translated">Кроме того, если необходимо поддерживать целевые платформы .NET Framework предыдущих версий, требуется установить пакеты нацеливания и пакеты для разработчиков, предназначенные для предыдущих версий платформы, со <bpt id="p1">[</bpt>страницы целевых платформ .NET<ept id="p1">](http://getdotnet.azurewebsites.net/target-dotnet-platforms.html)</ept>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Refer to this table:</source>
          <target state="translated">См. таблицу ниже.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>.NET Framework Version</source>
          <target state="translated">Версия платформы .NET Framework</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>What to download</source>
          <target state="translated">Скачиваемые компоненты</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>4.6.1</source>
          <target state="translated">4.6.1</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.6.1 Targeting Pack</source>
          <target state="translated">.NET Framework 4.6.1 Targeting Pack</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>4.6</source>
          <target state="translated">4.6</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.6 Targeting Pack</source>
          <target state="translated">.NET Framework 4.6 Targeting Pack</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>4.5.2</source>
          <target state="translated">4.5.2</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.5.2 Developer Pack</source>
          <target state="translated">.NET Framework 4.5.2 Developer Pack</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>4.5.1</source>
          <target state="translated">4.5.1</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.5.1 Developer Pack</source>
          <target state="translated">.NET Framework 4.5.1 Developer Pack</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>4.5</source>
          <target state="translated">4.5</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Windows Software Development Kit for Windows 8</source>
          <target state="translated">Пакет средств разработки программного обеспечения Windows для Windows 8</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>4.0</source>
          <target state="translated">4.0</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Windows SDK for Windows 7 and .NET Framework 4</source>
          <target state="translated">Пакет SDK для Windows 7 и .NET Framework 4</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>2.0, 3.0, and 3.5</source>
          <target state="translated">2.0, 3.0 и 3.5</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>.NET Framework 3.5 SP1 Runtime (or Windows 8+ version)</source>
          <target state="translated">Среда выполнения .NET Framework 3.5 с пакетом обновления 1 (SP1) (либо версия для Windows 8 или более поздняя)</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>How to target the .NET Standard</source>
          <target state="translated">Нацеливание на .NET Standard</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If you're not quite familiar with the .NET Standard, refer to <bpt id="p1">[</bpt>the .NET Standard Library<ept id="p1">](../../standard/library.md)</ept> to learn more.</source>
          <target state="translated">Если вы плохо знакомы с платформой .NET Standard, дополнительные сведения можно получить в разделе <bpt id="p1">[</bpt>Библиотека .NET Standard<ept id="p1">](../../standard/library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In that article, there is a table which maps .NET Standard versions to various implementations:</source>
          <target state="translated">В этом разделе есть таблица, в которой версии .NET Standard сопоставляются с различными реализациями:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Platform Name</source>
          <target state="translated">Имя платформы</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>.NET Standard</source>
          <target state="translated">.NET Standard</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>netstandard</source>
          <target state="translated">netstandard</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>1.0</source>
          <target state="translated">1,0</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>1.1</source>
          <target state="translated">1.1</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>1.2</source>
          <target state="translated">1.2</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>1.3</source>
          <target state="translated">1.3</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>1.4</source>
          <target state="translated">1.4</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>1.5</source>
          <target state="translated">1.5</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>1.6</source>
          <target state="translated">1.6</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>.NET Core</source>
          <target state="translated">.NET Core</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>netcoreapp</source>
          <target state="translated">netcoreapp</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>1.0</source>
          <target state="translated">1,0</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>.NET Framework</source>
          <target state="translated">.NET Framework</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>net</source>
          <target state="translated">net</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>4.5</source>
          <target state="translated">4.5</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>4.5.1</source>
          <target state="translated">4.5.1</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>4.6</source>
          <target state="translated">4.6</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>4.6.1</source>
          <target state="translated">4.6.1</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>4.6.2</source>
          <target state="translated">4.6.2</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>4.6.3</source>
          <target state="translated">4.6.3</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Mono/Xamarin Platforms</source>
          <target state="translated">Платформы Mono и Xamarin</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Universal Windows Platform</source>
          <target state="translated">Универсальная платформа Windows </target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>uap</source>
          <target state="translated">uap</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>10.0</source>
          <target state="translated">10.0</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>win</source>
          <target state="translated">win</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>8.0</source>
          <target state="translated">8.0</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>8.1</source>
          <target state="translated">8.1</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Windows Phone</source>
          <target state="translated">Windows Phone</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>wpa</source>
          <target state="translated">wpa</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>8.1</source>
          <target state="translated">8.1</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Windows Phone Silverlight</source>
          <target state="translated">Windows Phone Silverlight</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>wp</source>
          <target state="translated">wp</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>8.0</source>
          <target state="translated">8.0</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Here's what this table means for the purposes of creating a library:</source>
          <target state="translated">Вот что значит эта таблица в контексте создания библиотеки:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The version of the .NET Platform Standard you pick will be a tradeoff between access to the newest APIs and ability to target more .NET platforms and Framework versions.</source>
          <target state="translated">При выборе версии платформы .NET Standard необходимо найти компромисс между доступом к новейшим интерфейсам API и возможностью нацеливания на большее количество платформ и версий .NET.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>You control the range of targetable platforms and versions by picking a version of <ph id="ph1">`netstandardX.X`</ph> (Where <ph id="ph2">`X.X`</ph> is a version number) and adding it to your <ph id="ph3">`project.json`</ph> file.</source>
          <target state="translated">Диапазон поддерживаемых платформ и версий определяется выбранной версией <ph id="ph1">`netstandardX.X`</ph> (где <ph id="ph2">`X.X`</ph> — это номер версии), которая добавляется в файл <ph id="ph3">`project.json`</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Additionally, the corresponding <bpt id="p1">[</bpt>NuGet package to depend on<ept id="p1">](https://www.nuget.org/packages/NETStandard.Library/)</ept> is <ph id="ph1">`NETStandard.Library`</ph> version <ph id="ph2">`1.6.0`</ph>.</source>
          <target state="translated">Кроме того, соответствующий <bpt id="p1">[</bpt>зависимый пакет NuGet<ept id="p1">](https://www.nuget.org/packages/NETStandard.Library/)</ept> — <ph id="ph1">`NETStandard.Library`</ph> версии <ph id="ph2">`1.6.0`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Although there's nothing preventing you from depending on <ph id="ph1">`Microsoft.NETCore.App`</ph> like with console apps, it's generally not recommended.</source>
          <target state="translated">Хотя ничто не мешает вам использовать <ph id="ph1">`Microsoft.NETCore.App`</ph>, как в случае с консольными приложениями, как правило, делать это не рекомендуется.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>If you need APIs from a package not specified in <ph id="ph1">`NETStandard.Library`</ph>, you can always specify that package in addition to <ph id="ph2">`NETStandard.Library`</ph> in the <ph id="ph3">`dependencies`</ph> section of your <ph id="ph4">`project.json`</ph> file.</source>
          <target state="translated">Если вам нужны интерфейсы API из пакета, который не указан в <ph id="ph1">`NETStandard.Library`</ph>, вы всегда можете указать его в дополнение к <ph id="ph2">`NETStandard.Library`</ph> в разделе <ph id="ph3">`dependencies`</ph> файла <ph id="ph4">`project.json`</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You have three primary options when targeting the .NET Standard, depending on your needs.</source>
          <target state="translated">При нацеливании на платформу .NET Standard есть три основных варианта, выбор которых зависит от ваших потребностей.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can use the latest version of the .NET Standard - <ph id="ph1">`netstandard1.6`</ph> - which is for when you want access to the most APIs and don't mind if you have less reach across implementations.</source>
          <target state="translated">Можно использовать последнюю версию .NET Standard (<ph id="ph1">`netstandard1.6`</ph>), если вам нужен доступ к большинству интерфейсов API, а охват максимально возможного количества реализаций не важен.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can use a lower version of the .NET Standard to target earlier .NET implementations.</source>
          <target state="translated">Вы можете использовать более раннюю версию .NET Standard для нацеливания на более ранние реализации .NET</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The cost here is not having access to some of the latest APIs.</source>
          <target state="translated">за счет отсутствия доступа к некоторым новейшим интерфейсам API.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For example, if you wanted to have guaranteed compatibility with .NET Framework 4.6 and higher, you would pick <ph id="ph1">`netstandard1.3`</ph>:</source>
          <target state="translated">Например, если требуется гарантированная совместимость с .NET Framework 4.6 и более поздними версиями, следует выбрать <ph id="ph1">`netstandard1.3`</ph>:</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>.NET Standard versions are backward compatible.</source>
          <target state="translated">Версии .NET Standard обладают обратной совместимостью.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>That means that <ph id="ph1">`netstandard1.0`</ph> libraries run on <ph id="ph2">`netstandard1.1`</ph> platforms and higher.</source>
          <target state="translated">Это означает, что библиотеки <ph id="ph1">`netstandard1.0`</ph> выполняются на платформах <ph id="ph2">`netstandard1.1`</ph> и более поздних версий.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>However, there is no forward compatibility - lower .NET Standard platforms cannot reference higher ones.</source>
          <target state="translated">Однако прямой совместимости нет: более ранние платформы .NET Standard не могут ссылаться на более поздние.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This means that <ph id="ph1">`netstandard1.0`</ph> libraries cannot reference libraries targeting <ph id="ph2">`netstandard1.1`</ph> or higher.</source>
          <target state="translated">Это значит, что библиотеки <ph id="ph1">`netstandard1.0`</ph> не могут ссылаться на библиотеки, предназначенные для <ph id="ph2">`netstandard1.1`</ph> или более поздних версий.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Select the Standard version that has the right mix of APIs and platform support for your needs.</source>
          <target state="translated">Выберите версию Standard, которая предоставляет подходящее сочетание интерфейсов API и поддерживаемых платформ для ваших потребностей.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>If you want to target the .NET Framework versions 4.0 or below, or you wish to use an API available in the .NET Framework but not in the .NET Standard (for example, <ph id="ph1">`System.Drawing`</ph>), read the following sections and learn how to multitarget.</source>
          <target state="translated">Если требуется нацеливание на .NET Framework версии 4.0 или более ранней или использование интерфейса API, доступного в .NET Framework, но не в .NET Standard (например, <ph id="ph1">`System.Drawing`</ph>), прочитайте следующие подразделы, чтобы узнать, как осуществляется настройка для разных версий.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>How to target the .NET Framework</source>
          <target state="translated">Нацеливание на .NET Framework</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>These instructions assume you have the .NET Framework installed on your machine.</source>
          <target state="translated">В этих инструкциях предполагается, что на компьютере установлена платформа .NET Framework.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Refer to the <bpt id="p1">[</bpt>Prerequisites<ept id="p1">](#prerequisites)</ept> to get dependencies installed.</source>
          <target state="translated">Чтобы установить зависимости, обратитесь к разделу <bpt id="p1">[</bpt>Предварительные требования<ept id="p1">](#prerequisites)</ept>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Keep in mind that some of the .NET Framework versions used here are no longer in support.</source>
          <target state="translated">Имейте в виду, что некоторые используемые здесь версии .NET Framework больше не поддерживаются.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Refer to the <bpt id="p1">[</bpt>.NET Framework Support Lifecycle Policy FAQ<ept id="p1">](https://support.microsoft.com/gp/framework_faq/en-us)</ept> about unsupported versions.</source>
          <target state="translated">Сведения о неподдерживаемых версиях см. в статье <bpt id="p1">[</bpt>Вопросы и ответы о политике по срокам поддержки Microsoft .NET Framework<ept id="p1">](https://support.microsoft.com/gp/framework_faq/en-us)</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>If you want to reach the maximum number of developers and projects, use the .NET Framework 4 as your baseline target.</source>
          <target state="translated">Чтобы охватить максимальное количество разработчиков и проектов, используйте .NET Framework 4 в качестве базовой целевой платформы.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To target the .NET Framework, you will need to begin by using the correct Target Framework Moniker (TFM) that corresponds to the .NET Framework version you wish to support.</source>
          <target state="translated">Для нацеливания на .NET Framework сначала необходимо использовать моникер целевой платформы (TFM), соответствующий версии .NET Framework, которая должна поддерживаться.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For example, here's how you would write a library which targets the .NET Framework 4:</source>
          <target state="translated">Например, вот как создать библиотеку, предназначенную для .NET Framework 4:</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">Вот и все!</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Although this compiled only for the .NET Framework 4, you can use the library on newer versions of the .NET Framework.</source>
          <target state="translated">Хотя эта библиотека компилируется только для .NET Framework 4, ее можно использовать в более поздних версиях .NET Framework.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>How to target a Portable Class Library (PCL)</source>
          <target state="translated">Нацеливание на переносимую библиотеку классов (PCL)</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>These instructions assume you have the .NET Framework installed on your machine.</source>
          <target state="translated">В этих инструкциях предполагается, что на компьютере установлена платформа .NET Framework.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Refer to the <bpt id="p1">[</bpt>Prerequisites<ept id="p1">](#prerequisites)</ept> to get dependencies installed.</source>
          <target state="translated">Чтобы установить зависимости, обратитесь к разделу <bpt id="p1">[</bpt>Предварительные требования<ept id="p1">](#prerequisites)</ept>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Targeting a PCL profile is a bit trickier than targeting .NET Standard or the .NET Framework.</source>
          <target state="translated">Нацеливание на библиотеку PCL немного сложнее, чем на платформу .NET Standard или .NET Framework.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For starters, <bpt id="p1">[</bpt>reference this list of PCL profiles<ept id="p1">](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview)</ept> to find the NuGet target which corresponds to the PCL profile you are targeting.</source>
          <target state="translated">Начинающие могут обратиться к <bpt id="p1">[</bpt>списку профилей PCL<ept id="p1">](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview)</ept>, чтобы найти целевой пакет NuGet, соответствующий нужному профилю PCL.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Then, you need to do the following:</source>
          <target state="translated">Затем необходимо выполнить указанные ниже действия:</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Create a new entry under <ph id="ph1">`frameworks`</ph> in your <ph id="ph2">`project.json`</ph>, named <ph id="ph3">`.NETPortable,Version=v{version},Profile=Profile{profile}`</ph>, where <ph id="ph4">`{version}`</ph> and <ph id="ph5">`{profile}`</ph> correspond to a PCL version number and Profile number, respectively.</source>
          <target state="translated">В разделе <ph id="ph1">`frameworks`</ph> файла <ph id="ph2">`project.json`</ph> создайте запись с именем <ph id="ph3">`.NETPortable,Version=v{version},Profile=Profile{profile}`</ph>, где <ph id="ph4">`{version}`</ph> и <ph id="ph5">`{profile}`</ph> — это номера версии и профиля PCL соответственно.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In this new entry, list every single assembly used for that target under a <ph id="ph1">`frameworkAssemblies`</ph> entry.</source>
          <target state="translated">В этой новой записи укажите каждую сборку, используемую для данной целевой платформы, в записи <ph id="ph1">`frameworkAssemblies`</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This includes <ph id="ph1">`mscorlib`</ph>, <ph id="ph2">`System`</ph>, and <ph id="ph3">`System.Core`</ph>.</source>
          <target state="translated">Эти сборки включают <ph id="ph1">`mscorlib`</ph>, <ph id="ph2">`System`</ph> и <ph id="ph3">`System.Core`</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If you are multitargeting (see the next section), you must explicitly list dependencies for each target under their target entries.</source>
          <target state="translated">При настройке для различных версий (см. следующий раздел) необходимо явным образом перечислить зависимости для каждой целевой платформы в соответствующих записях.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>You won't be able to use a global <ph id="ph1">`dependencies`</ph> entry anymore.</source>
          <target state="translated">Вы больше не сможете использовать глобальную запись <ph id="ph1">`dependencies`</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The following is an example targeting PCL Profile 328.</source>
          <target state="translated">Ниже приведен пример нацеливания на профиль PCL 328.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Profile 328 supports: .NET Standard 1.4, .NET Framework 4, Windows 8, Windows Phone 8.1, Windows Phone Silverlight 8.1, and Silverlight 5.</source>
          <target state="translated">Профиль 328 поддерживает: .NET Standard 1.4, .NET Framework 4, Windows 8, Windows Phone 8.1, Windows Phone Silverlight 8.1 и Silverlight 5.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>When you build a project that includes PCL Profile 328 as a framework in the <bpt id="p1">*</bpt>project.json<ept id="p1">*</ept> file, it will have this subfolder in the <bpt id="p2">*</bpt>/bin/debug<ept id="p2">*</ept> folder:</source>
          <target state="translated">При сборке проекта, включающего профиль PCL 328 в качестве платформы в файле <bpt id="p1">*</bpt>project.json<ept id="p1">*</ept>, в папке <bpt id="p2">*</bpt>/bin/debug<ept id="p2">*</ept> должна быть следующая вложенная папка:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>This folder contains the <ph id="ph1">`.dll`</ph> files necessary to run your library.</source>
          <target state="translated">Эта папка содержит файлы <ph id="ph1">`.dll`</ph>, необходимые для выполнения библиотеки.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>How to Multitarget</source>
          <target state="translated">Настройка для различных версий</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The following instructions assume you have the .NET Framework installed on your machine.</source>
          <target state="translated">В приведенных ниже инструкциях предполагается, что на компьютере установлена платформа .NET Framework.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Refer to the <bpt id="p1">[</bpt>Prerequisites<ept id="p1">](#prerequisites)</ept> section to learn which dependencies you need to install and where to download them from.</source>
          <target state="translated">Сведения о зависимостях, которые необходимо установить, и о том, где их можно скачать, см. в разделе <bpt id="p1">[</bpt>Предварительные требования<ept id="p1">](#prerequisites)</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>You may need to target older versions of the .NET Framework when your project supports both the .NET Framework and .NET Core.</source>
          <target state="translated">Если проект поддерживает как .NET Framework, так и .NET Core, может потребоваться нацеливание на более старые версии .NET Framework.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>In this scenario, if you want to use newer APIs and language constructs for the newer targets, use <ph id="ph1">`#if`</ph> directives in your code.</source>
          <target state="translated">В такой ситуации, если вам нужно применять более новые интерфейсы API и языковые конструкции для новых целевых платформ, используйте директивы <ph id="ph1">`#if`</ph> в коде.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>You also might need to add different packages and dependencies in your <ph id="ph1">`project.json file`</ph> for each platform you're targeting to include the different APIs needed for each case.</source>
          <target state="translated">Кроме того, может потребоваться добавить разные пакеты и зависимости в файл <ph id="ph1">`project.json file`</ph> для каждой целевой платформы, чтобы включить различные интерфейсы API, необходимые в каждом случае.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a library that performs networking operations over HTTP.</source>
          <target state="translated">Предположим, имеется библиотека, выполняющая сетевые операции по протоколу HTTP.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>For .NET Standard and the .NET Framework versions 4.5 or higher, you can use the <ph id="ph1">`HttpClient`</ph> class from the <ph id="ph2">`System.Net.Http`</ph> namespace.</source>
          <target state="translated">Для .NET Standard и .NET Framework версии 4.5 или более поздней можно использовать класс <ph id="ph1">`HttpClient`</ph> из пространства имен <ph id="ph2">`System.Net.Http`</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>However, earlier versions of the .NET Framework don't have the <ph id="ph1">`HttpClient`</ph> class, so you could use the <ph id="ph2">`WebClient`</ph> class from the <ph id="ph3">`System.Net`</ph> namespace for those instead.</source>
          <target state="translated">Однако в более ранних версиях .NET Framework нет класса <ph id="ph1">`HttpClient`</ph>, поэтому вместо него можно использовать класс <ph id="ph2">`WebClient`</ph> из пространства имен <ph id="ph3">`System.Net`</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>So, the <ph id="ph1">`project.json`</ph> file could look like this:</source>
          <target state="translated">Файл <ph id="ph1">`project.json`</ph> мог бы выглядеть следующим образом.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Note that the .NET Framework assemblies need to be referenced explicitly in the <ph id="ph1">`net40`</ph> and <ph id="ph2">`net452`</ph> target, and NuGet references are also explicitly listed in the <ph id="ph3">`netstandard1.6`</ph> target.</source>
          <target state="translated">Обратите внимание на то, что на сборки .NET Framework необходимо ссылаться явным образом для целевых платформ <ph id="ph1">`net40`</ph> и <ph id="ph2">`net452`</ph>, а ссылки на пакеты NuGet также указываются явным образом для целевой платформы <ph id="ph3">`netstandard1.6`</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>This is required in multitargeting scenarios.</source>
          <target state="translated">Это обязательное требование в сценариях настройки для различных систем.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Next, the <ph id="ph1">`using`</ph> statements in your source file can be adjusted like this:</source>
          <target state="translated">Далее операторы <ph id="ph1">`using`</ph> в файле исходного кода можно изменить следующим образом:</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The build system is aware of the following preprocessor symbols used in <ph id="ph1">`#if`</ph> directives:</source>
          <target state="translated">Система сборки распознает следующие символы препроцессора, используемые в директивах <ph id="ph1">`#if`</ph>:</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>And in the middle of the source, you can use <ph id="ph1">`#if`</ph> directives to use those libraries conditionally.</source>
          <target state="translated">В середине исходного кода можно применять директивы <ph id="ph1">`#if`</ph> для условного использования библиотек.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Пример:</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>When you build a project that includes <ph id="ph1">`net40`</ph>, <ph id="ph2">`net45`</ph>, and <ph id="ph3">`netstandard1.6`</ph> as frameworks in the <bpt id="p1">*</bpt>project.json<ept id="p1">*</ept> file, it will have these subfolders in the <bpt id="p2">*</bpt>/bin/debug<ept id="p2">*</ept> folder:</source>
          <target state="translated">При сборке проекта, включающего профиль <ph id="ph1">`net40`</ph>, <ph id="ph2">`net45`</ph> и <ph id="ph3">`netstandard1.6`</ph> в качестве платформ в файле <bpt id="p1">*</bpt>project.json<ept id="p1">*</ept>, в папке <bpt id="p2">*</bpt>/bin/debug<ept id="p2">*</ept> должны быть следующие вложенные папки:</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>But What about Multitargeting with Portable Class Libraries?</source>
          <target state="translated">Настройка для различных версий в случае с переносимыми библиотеками классов</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>If you want to cross-compile with a PCL target, you must add a build definition in your <ph id="ph1">`project.json`</ph> file under <ph id="ph2">`buildOptions`</ph> in your PCL target.</source>
          <target state="translated">Для кроссплатформенной компиляции с PCL в качестве целевой платформы необходимо добавить определение сборки в файл <ph id="ph1">`project.json`</ph> в разделе <ph id="ph2">`buildOptions`</ph> целевой библиотеки PCL.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>You can then use <ph id="ph1">`#if`</ph> directives in the source which use the build definition as a preprocessor symbol.</source>
          <target state="translated">Затем можно применять директивы <ph id="ph1">`#if`</ph> в исходном коде, которые используют определение сборки в качестве символа препроцессора.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>For example, if you want to target <bpt id="p1">[</bpt>PCL profile 328<ept id="p1">](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview)</ept> (The .NET Framework 4, Windows 8, Windows Phone Silverlight 8, Windows Phone 8.1, Silverlight 5), you could to refer to it to as "PORTABLE328" when cross-compiling.</source>
          <target state="translated">Например, для нацеливания на <bpt id="p1">[</bpt>профиль PCL 328<ept id="p1">](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview)</ept> (.NET Framework 4, Windows 8, Windows Phone Silverlight 8, Windows Phone 8.1, Silverlight 5) при кроссплатформенной компиляции можно сослаться на него как PORTABLE328.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Simply add it to the <ph id="ph1">`project.json`</ph> file as a <ph id="ph2">`buildOptions`</ph> attribute:</source>
          <target state="translated">Просто добавьте его в файл <ph id="ph1">`project.json`</ph> в виде атрибута <ph id="ph2">`buildOptions`</ph>:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Now you can conditionally compile against that target:</source>
          <target state="translated">Теперь можно выполнить условную компиляцию для целевой платформы:</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`PORTABLE328`</ph> is now recognized by the compiler, the PCL Profile 328 library generated by a compiler will not include <ph id="ph2">`System.Net.Http`</ph> or <ph id="ph3">`System.Threading.Tasks`</ph>.</source>
          <target state="translated">Так как <ph id="ph1">`PORTABLE328`</ph> теперь распознается компилятором, библиотека профиля PCL 328, созданная компилятором, не будет включать <ph id="ph2">`System.Net.Http`</ph> или <ph id="ph3">`System.Threading.Tasks`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>When you build a project that includes PCL Profile 328 and <ph id="ph1">`netstandard1.6`</ph> as frameworks in the <bpt id="p1">*</bpt>project.json<ept id="p1">*</ept> file, it will have these subfolders in the <bpt id="p2">*</bpt>/bin/debug<ept id="p2">*</ept> folder:</source>
          <target state="translated">При сборке проекта, включающего профиль PCL 328 и <ph id="ph1">`netstandard1.6`</ph> в качестве платформ в файле <bpt id="p1">*</bpt>project.json<ept id="p1">*</ept>, в папке <bpt id="p2">*</bpt>/bin/debug<ept id="p2">*</ept> будут следующие вложенные папки:</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>How to use native dependencies</source>
          <target state="translated">Использование зависимостей в машинном коде</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>You may wish to write a library which depends on a native <ph id="ph1">`.dll`</ph> file.</source>
          <target state="translated">Вам может потребоваться создать библиотеку, которая зависит от файла <ph id="ph1">`.dll`</ph> в машинном коде.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>If you're writing such a library, you have have two options:</source>
          <target state="translated">При создании такой библиотеки есть два варианта:</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Reference the native <ph id="ph1">`.dll`</ph> directly in your <ph id="ph2">`project.json`</ph>.</source>
          <target state="translated">сошлитесь на библиотеку <ph id="ph1">`.dll`</ph> в машинном коде непосредственно в файле <ph id="ph2">`project.json`</ph>;</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Package that <ph id="ph1">`.dll`</ph> into its own NuGet package and depend on that package.</source>
          <target state="translated">упакуйте библиотеку <ph id="ph1">`.dll`</ph> в собственный пакет NuGet а затем установите зависимость от него.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For the first option, you'll need to include the following in your <ph id="ph1">`project.json`</ph> file:</source>
          <target state="translated">В первом случае в файл <ph id="ph1">`project.json`</ph> необходимо включить следующее:</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Setting <ph id="ph1">`allowUnsafe`</ph> to <ph id="ph2">`true`</ph> in a <ph id="ph3">`buildOptions`</ph> section.</source>
          <target state="translated">задать для <ph id="ph1">`allowUnsafe`</ph> значение <ph id="ph2">`true`</ph> в разделе <ph id="ph3">`buildOptions`</ph>;</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Specifying a <bpt id="p1">[</bpt>Runtime Identifier (RID)<ept id="p1">](../rid-catalog.md)</ept> in a <ph id="ph1">`runtimes`</ph> section.</source>
          <target state="translated">указать <bpt id="p1">[</bpt>идентификатор среды выполнения (RID)<ept id="p1">](../rid-catalog.md)</ept> в разделе <ph id="ph1">`runtimes`</ph>;</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Specifying the path to the native <ph id="ph1">`.dll`</ph> file(s) that you are referencing.</source>
          <target state="translated">указать путь на файлы <ph id="ph1">`.dll`</ph> в машинном коде, ссылки на которые задаются.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Here's an example <ph id="ph1">`project.json`</ph> for a native <ph id="ph2">`.dll`</ph> file in the root directory of the project which runs on Windows:</source>
          <target state="translated">Вот пример файла <ph id="ph1">`project.json`</ph> для файла <ph id="ph2">`.dll`</ph> в машинном коде в корневом каталоге проекта, выполняющегося в Windows:</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>If you're distributing your library as a package, it's recommended that you place the <ph id="ph1">`.dll`</ph> file at the root level of your project.</source>
          <target state="translated">Если вы распространяете библиотеку в виде пакета, файл <ph id="ph1">`.dll`</ph> рекомендуется размещать на корневом уровне проекта.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For the second option, you'll need to build a NuGet package out of your <ph id="ph1">`.dll`</ph> file(s), host on a NuGet or MyGet feed, and depend on it directly.</source>
          <target state="translated">Во втором случае вам необходимо выполнить сборку пакета NuGet на основе файлов <ph id="ph1">`.dll`</ph>, разместите его в канале NuGet или MyGet, а затем напрямую установите зависимость от него.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>You'll still need to set <ph id="ph1">`allowUnsafe`</ph> to <ph id="ph2">`true`</ph> in the <ph id="ph3">`buildOptions`</ph> section of your <ph id="ph4">`project.json`</ph>.</source>
          <target state="translated">Вам по-прежнему необходимо задать для <ph id="ph1">`allowUnsafe`</ph> значение <ph id="ph2">`true`</ph> в разделе <ph id="ph3">`buildOptions`</ph> файла <ph id="ph4">`project.json`</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Here's an example (assuming <ph id="ph1">`MyNativeLib`</ph> is a Nuget package at version <ph id="ph2">`1.2.0`</ph>):</source>
          <target state="translated">Ниже приведен пример (предполагается, что <ph id="ph1">`MyNativeLib`</ph> — это пакет Nuget версии <ph id="ph2">`1.2.0`</ph>).</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>To see an example of packaging up cross-platform native binaries, check out the <bpt id="p1">[</bpt>ASP.NET Libuv Package<ept id="p1">](https://github.com/aspnet/libuv-package)</ept> and the <bpt id="p2">[</bpt>corresponding reference in KestrelHttpServer<ept id="p2">](https://github.com/aspnet/KestrelHttpServer/blob/1.0.0/src/Microsoft.AspNetCore.Server.Kestrel/project.json#L19)</ept>.</source>
          <target state="translated">Пример упаковки кроссплатформенных двоичных файлов в машинном коде см. на странице <bpt id="p1">[</bpt>Пакет Libuv для ASP.NET<ept id="p1">](https://github.com/aspnet/libuv-package)</ept> и в <bpt id="p2">[</bpt>соответствующей справке в KestrelHttpServer<ept id="p2">](https://github.com/aspnet/KestrelHttpServer/blob/1.0.0/src/Microsoft.AspNetCore.Server.Kestrel/project.json#L19)</ept>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>How to test libraries on .NET Core</source>
          <target state="translated">Тестирование библиотек в .NET Core</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>It's important to be able to test across platforms.</source>
          <target state="translated">Необходимо иметь возможность тестирования проектов на различных платформах.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>It's easiest to use <bpt id="p1">[</bpt>xUnit<ept id="p1">](http://xunit.github.io/)</ept>, which is also the testing tool used by .NET Core projects.</source>
          <target state="translated">Проще всего применять средство тестирования <bpt id="p1">[</bpt>xUnit<ept id="p1">](http://xunit.github.io/)</ept>, которое также используется проектами .NET Core.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>How you set up your solution with test projects will depend on the <bpt id="p1">[</bpt>structure of your solution<ept id="p1">](#structuring-a-solution)</ept>.</source>
          <target state="translated">Настройка тестовых проектов для решения зависит от <bpt id="p1">[</bpt>его структуры<ept id="p1">](#structuring-a-solution)</ept>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The following example assumes that all source projects are under a top-level <ph id="ph1">`/src`</ph> folder and all test projects are under a top-level <ph id="ph2">`/test`</ph> folder.</source>
          <target state="translated">В приведенном ниже примере предполагается, что все исходные проекты находятся в папке <ph id="ph1">`/src`</ph> верхнего уровня, а все тестовые проекты — в папке <ph id="ph2">`/test`</ph> верхнего уровня.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Ensure you have a <ph id="ph1">`global.json`</ph> file at the solution level which understands where the test projects are:</source>
          <target state="translated">Файл <ph id="ph1">`global.json`</ph> должен находиться на уровне решения, на котором известно, где находятся тестовые проекты:</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Your solution folder structure should then look like this:</source>
          <target state="translated">Структура папок решения должна выглядеть следующим образом.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Create a new test project by creating a project folder under your <ph id="ph1">`/test`</ph> folder, and a <ph id="ph2">`project.json`</ph> file in the new project folder.</source>
          <target state="translated">Создайте тестовый проект, создав папку проекта в папке <ph id="ph1">`/test`</ph> и файл <ph id="ph2">`project.json`</ph> в новой папке проекта.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>To create the <ph id="ph1">`project.json`</ph> file you can run the <ph id="ph2">`dotnet new`</ph> command and modify the <ph id="ph3">`project.json`</ph> file afterwards.</source>
          <target state="translated">Вы можете создать файл <ph id="ph1">`project.json`</ph>, выполнив команду <ph id="ph2">`dotnet new`</ph>, и изменить файл <ph id="ph3">`project.json`</ph> впоследствии.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The file should have the following:</source>
          <target state="translated">Файл должен содержать следующее:</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`netcoreapp1.0`</ph> listed as the only entry under <ph id="ph2">`frameworks`</ph>.</source>
          <target state="translated"><ph id="ph1">`netcoreapp1.0`</ph>в качестве единственной записи в разделе <ph id="ph2">`frameworks`</ph>;</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>A reference to <ph id="ph1">`Microsoft.NETCore.App`</ph> version <ph id="ph2">`1.0.0`</ph>.</source>
          <target state="translated">ссылка на <ph id="ph1">`Microsoft.NETCore.App`</ph> версии <ph id="ph2">`1.0.0`</ph>;</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>A reference to xUnit version <ph id="ph1">`2.2.0-beta2-build3300`</ph>.</source>
          <target state="translated">ссылка на xUnit версии <ph id="ph1">`2.2.0-beta2-build3300`</ph>;</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>A reference to <ph id="ph1">`dotnet-test-xunit`</ph> version <ph id="ph2">`2.2.0-preview2-build1029`</ph></source>
          <target state="translated">ссылка на <ph id="ph1">`dotnet-test-xunit`</ph>версию <ph id="ph2">`2.2.0-preview2-build1029`</ph>;</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>A project reference to the library being tested.</source>
          <target state="translated">ссылка проекта на тестируемую библиотеку;</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The entry <ph id="ph1">`"testRunner":"xunit"`</ph>.</source>
          <target state="translated">запись <ph id="ph1">`"testRunner":"xunit"`</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Here's an example (<ph id="ph1">`LibraryUnderTest`</ph> version <ph id="ph2">`1.0.0`</ph> is the library being tested):</source>
          <target state="translated">Вот пример (тестируется библиотека <ph id="ph1">`LibraryUnderTest`</ph> версии <ph id="ph2">`1.0.0`</ph>):</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Restore packages by running <ph id="ph1">`dotnet restore`</ph>.</source>
          <target state="translated">Восстановите пакеты, выполнив команду <ph id="ph1">`dotnet restore`</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>You should do this at the solution level if you haven't restored packages yet.</source>
          <target state="translated">Если вы еще не восстановили пакеты, это следует сделать на уровне решения.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Navigate to your test project and run tests with <ph id="ph1">`dotnet test`</ph>:</source>
          <target state="translated">Перейдите к тестовому проекту и выполните тесты с помощью команды <ph id="ph1">`dotnet test`</ph>:</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">Вот и все!</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>You can now test your library across all platforms using command line tools.</source>
          <target state="translated">Теперь вы можете протестировать библиотеку для всех платформ с помощью средств командной строки.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>To continue testing now that you have everything set up, testing your library is very simple:</source>
          <target state="translated">Теперь, когда все настроено, протестировать библиотеку очень легко:</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Make changes to your library.</source>
          <target state="translated">Внесите изменения в библиотеку.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Run tests from the command line, in your test directory, with <ph id="ph1">`dotnet test`</ph> command.</source>
          <target state="translated">Выполните тесты в тестовом каталоге из командной строки с помощью команды <ph id="ph1">`dotnet test`</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Your code will be automatically rebuilt when you invoke <ph id="ph1">`dotnet test`</ph> command.</source>
          <target state="translated">При вызове команды <ph id="ph1">`dotnet test`</ph> будет автоматически выполнена повторная сборка кода.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Just remember to run <ph id="ph1">`dotnet restore`</ph> from the command line any time you add a new dependency and you'll be good to go!</source>
          <target state="translated">Не забывайте выполнять команду <ph id="ph1">`dotnet restore`</ph> из командной строки каждый раз при добавлении новой зависимости.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>How to use multiple projects</source>
          <target state="translated">Использование нескольких проектов</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>A common need for larger libraries is to place functionality in different projects.</source>
          <target state="translated">В случае с более крупными библиотеками, как правило, требуется реализовывать функциональность в разных проектах.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Imagine you wished to build a library which could be consumed in idiomatic C# and F#.</source>
          <target state="translated">Представим, что необходимо создать библиотеку, которую можно использовать в идиоматичном коде на языках C# и F#.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>That would mean that consumers of your library consume them in ways which are natural to C# or F#.</source>
          <target state="translated">Это означает, что библиотека будет использоваться способами, естественными для языков C# и F#.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>For example, in C# you might consume the library like this:</source>
          <target state="translated">Например, в C# можно использовать библиотеку следующим образом:</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>In F#, it might look like this:</source>
          <target state="translated">В F# это может выглядеть так.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Consumption scenarios like this mean that the APIs being accessed have to have a different structure for C# and F#.</source>
          <target state="translated">Подобные сценарии использования предполагают, что интерфейсы API, к которым осуществляется доступ, должны иметь разную структуру для C# и F#.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>A common approach to accomplishing this is to factor all of the logic of a library into a core project, with C# and F# projects defining the API layers that call into that core project.</source>
          <target state="translated">Стандартным подходом к решению этой задачи является факторинг всей логики библиотеки в базовом проекте и определение в проектах C# и F# уровней API, которые вызывают этот базовый проект.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The rest of the section will use the following names:</source>
          <target state="translated">Далее в этом разделе будут использоваться следующие имена:</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AwesomeLibrary.Core<ept id="p1">**</ept> - A core project which contains all logic for the library</source>
          <target state="translated"><bpt id="p1">**</bpt>AwesomeLibrary.Core<ept id="p1">**</ept> — базовый проект, содержащий всю логику библиотеки;</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AwesomeLibrary.CSharp<ept id="p1">**</ept> - A project with public APIs intended for consumption in C</source>
          <target state="translated"><bpt id="p1">**</bpt>AwesomeLibrary.CSharp<ept id="p1">**</ept> — проект с открытыми интерфейсами API, предназначенными для использования в коде на языке C;</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AwesomeLibrary.FSharp<ept id="p1">**</ept> - A project with public APIs intended for consumption in F</source>
          <target state="translated"><bpt id="p1">**</bpt>AwesomeLibrary.FSharp<ept id="p1">**</ept> — проект с открытыми интерфейсами API, предназначенными для использования в коде на языке F.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Project-to-project referencing</source>
          <target state="translated">Ссылки проектов на проекты</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The best way to reference a project is to do the following:</source>
          <target state="translated">Для ссылки на проект лучше всего использовать указанный ниже способ:</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Make sure the project you wish to reference has a good name for its containing folder on disk.</source>
          <target state="translated">Убедитесь в том, что проект, на который необходимо сослаться, имеет подходящее имя для содержащей его папки на диске.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>This will be the name used to reference your project.</source>
          <target state="translated">Это имя будет применяться для ссылки на проект.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Reference the name from (1) in the <ph id="ph1">`project.json`</ph> file of the consuming project specifying <ph id="ph2">`"target":"project"`</ph>.</source>
          <target state="translated">Сошлитесь на имя из (1) в файле <ph id="ph1">`project.json`</ph> исходного проекта, указав <ph id="ph2">`"target":"project"`</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`project.json`</ph> files for both <bpt id="p1">**</bpt>AwesomeLibrary.CSharp<ept id="p1">**</ept> and <bpt id="p2">**</bpt>AwesomeLibrary.FSharp<ept id="p2">**</ept> now need to reference <bpt id="p3">**</bpt>AwesomeLibrary.Core<ept id="p3">**</ept> as a <ph id="ph2">`project`</ph> target.</source>
          <target state="translated">Файлы <ph id="ph1">`project.json`</ph> проектов <bpt id="p1">**</bpt>AwesomeLibrary.CSharp<ept id="p1">**</ept> и <bpt id="p2">**</bpt>AwesomeLibrary.FSharp<ept id="p2">**</ept> теперь должны ссылаться на <bpt id="p3">**</bpt>AwesomeLibrary.Core<ept id="p3">**</ept> в качестве целевого проекта <ph id="ph2">`project`</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>If you aren't multitargeting, you can use the global <ph id="ph1">`dependencies`</ph> entry:</source>
          <target state="translated">Если настройка для различных версий не производится, можно использовать глобальную запись <ph id="ph1">`dependencies`</ph>:</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>If you are multitargeting, you may not be able to use a global <ph id="ph1">`dependencies`</ph> entry and may have to reference <bpt id="p1">**</bpt>AwesomeLibrary.Core<ept id="p1">**</ept> in a target-level <ph id="ph2">`dependencies`</ph> entry.</source>
          <target state="translated">Если настройка для различных версий производится, использование глобальной записи <ph id="ph1">`dependencies`</ph> может быть невозможным. В этом случае необходимо сослаться на <bpt id="p1">**</bpt>AwesomeLibrary.Core<ept id="p1">**</ept> в целевой записи <ph id="ph2">`dependencies`</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>For example, if you were targeting <ph id="ph1">`netstandard1.6`</ph>, you could do so like this:</source>
          <target state="translated">Например, при нацеливании на <ph id="ph1">`netstandard1.6`</ph> это можно сделать следующим образом:</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Structuring a Solution</source>
          <target state="translated">Структурирование решения</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Another important aspect of multi-project solutions is establishing a good overall project structure.</source>
          <target state="translated">Еще один важный аспект решений с несколькими проектами — правильное формирование общей структуры.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>To structure a multi-project library, you must use top-level <ph id="ph1">`/src`</ph> and <ph id="ph2">`/test`</ph> folders:</source>
          <target state="translated">Чтобы структурировать библиотеку из нескольких проектов, необходимо использовать папки <ph id="ph1">`/src`</ph> и <ph id="ph2">`/test`</ph> верхнего уровня:</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`global.json`</ph> file for this solution would look like this:</source>
          <target state="translated">Файл <ph id="ph1">`global.json`</ph> для этого решения будет выглядеть следующим образом.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>This approach follows the same pattern established by project templates in the <ph id="ph1">`dotnet new`</ph> command establish, where all projects are placed under a <ph id="ph2">`/src`</ph> directory and all tests are placed under a <ph id="ph3">`/test`</ph> directory.</source>
          <target state="translated">При таком подходе применяется структура, аналогичная той, что создается при выполнении команды <ph id="ph1">`dotnet new`</ph>: все проекты помещаются в каталог <ph id="ph2">`/src`</ph>, а все тесты — в каталог <ph id="ph3">`/test`</ph>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Here's how you could restore packages, build, and test your entire project:</source>
          <target state="translated">Вот как можно восстановить пакеты, выполнить сборку и протестировать весь проект:</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">Вот и все!</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>