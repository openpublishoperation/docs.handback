<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6536a608a4ee1bb10f41907a28114193a300a52c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\async-in-depth.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4a59cc5bc6b7d68b057f06623b3cc2f09799a72f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0300c978d5652352126d5e8e8e0c9370ad283890</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Async in depth</source>
          <target state="translated">Подробный обзор асинхронного программирования</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>In-depth explanation of how asynchronous code works in .NET</source>
          <target state="translated">Подробное описание работы асинхронного кода в .NET</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, .NET Standard</source>
          <target state="translated">.NET, .NET Core, .NET Standard</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Async in depth</source>
          <target state="translated">Подробный обзор асинхронного программирования</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</source>
          <target state="translated">Писать асинхронный код, связанный с операциями ввода-вывода и задействованием ЦП, очень просто с помощью асинхронной модели .NET на базе класса Task.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The model is exposed by the <ph id="ph1">`Task`</ph> and <ph id="ph2">`Task&lt;T&gt;`</ph> types and the <ph id="ph3">`async`</ph> and <ph id="ph4">`await`</ph> language keywords.</source>
          <target state="translated">Эта модель основывается на типах <ph id="ph1">`Task`</ph> и <ph id="ph2">`Task&lt;T&gt;`</ph> и ключевых словах языка <ph id="ph3">`async`</ph> и <ph id="ph4">`await`</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This article explains how to use .NET async and provides insight into the async framework used under the covers.</source>
          <target state="translated">В этой статье описывается использование асинхронного кода в .NET и объясняется базовая асинхронная платформа.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Task and Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph></source>
          <target state="translated">Task и Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Tasks are constructs used to implement what is known as the <bpt id="p1">[</bpt>Promise Model of Concurrency<ept id="p1">](https://en.wikipedia.org/wiki/Futures_and_promises)</ept>.</source>
          <target state="translated">Task (задача) — это конструкции, реализующие <bpt id="p1">[</bpt>модель параллельной обработки на основе обещаний (Promise)<ept id="p1">](https://en.wikipedia.org/wiki/Futures_and_promises)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</source>
          <target state="translated">Если в двух словах, они "обещают", что работа будет выполнена позже, позволяя взаимодействовать с помощью обещания с чистым API.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task`</ph> represents a single operation which does not return a value.</source>
          <target state="translated"><ph id="ph1">`Task`</ph> представляет одну операцию, которая не возвращает значение.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task&lt;T&gt;`</ph> represents a single operation which returns a value of type <ph id="ph2">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Task&lt;T&gt;`</ph> представляет одну операцию, которая возвращает значение типа <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It’s important to reason about tasks as abstractions of work happening asynchronously, and <bpt id="p1">*</bpt>not<ept id="p1">*</ept> an abstraction over threading.</source>
          <target state="translated">Важно рассматривать задачи как абстракции асинхронных операций, но <bpt id="p1">*</bpt>не<ept id="p1">*</ept> как абстракции поверх потоков.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</source>
          <target state="translated">По умолчанию задачи выполняются в текущем потоке и при необходимости делегируют работу операционной системе.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Optionally, tasks can be be explicitly requested to run on a separate thread via the <ph id="ph1">`Task.Run`</ph> API.</source>
          <target state="translated">Либо для задач может явно запрашиваться запуск в отдельном потоке через API <ph id="ph1">`Task.Run`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of <ph id="ph1">`Task&lt;T&gt;`</ph>) of a task.</source>
          <target state="translated">Задачи предоставляют протокол API для мониторинга, ожидания и доступа к результирующему значению (в случае <ph id="ph1">`Task&lt;T&gt;`</ph>) задачи.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Language integration, with the <ph id="ph1">`await`</ph> keyword, provides a higher-level abstraction for using tasks.</source>
          <target state="translated">Интеграция с языком через ключевое слово <ph id="ph1">`await`</ph> обеспечивает абстракцию более высокого уровня для использования задач.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Using <ph id="ph1">`await`</ph> allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</source>
          <target state="translated">Использование <ph id="ph1">`await`</ph> позволяет приложению или службе выполнять полезную работу во время выполнения задачи за счет передачи управления вызывающему объекту задачи до ее завершения.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</source>
          <target state="translated">В коде не нужно использовать обратные вызовы или события для продолжения выполнения после завершения задачи.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The language and task API integration does that for you.</source>
          <target state="translated">Это берут на себя язык и интеграцию API-интерфейса задач.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If you’re using <ph id="ph1">`Task&lt;T&gt;`</ph>, the <ph id="ph2">`await`</ph> keyword will additionally “unwrap” the value returned when the Task is complete.</source>
          <target state="translated">Если вы используете <ph id="ph1">`Task&lt;T&gt;`</ph>, ключевое слово <ph id="ph2">`await`</ph> будет дополнительно "разворачивать" значение, возвращаемое после завершения Task.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The details of how this works are explained further below.</source>
          <target state="translated">Ниже приводится подробное описание того, как это работает.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can learn more about tasks and the different ways to interact with them in the <bpt id="p1">[</bpt>Task-based Asynchronous Pattern (TAP) Article<ept id="p1">](https://msdn.microsoft.com/library/hh873175.aspx)</ept>.</source>
          <target state="translated">Дополнительные сведения о задачах и разных способах взаимодействия с ними см. в статье <bpt id="p1">[</bpt>Асинхронный шаблон, основанный на задачах (TAP)<ept id="p1">](https://msdn.microsoft.com/library/hh873175.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Deeper Dive into Tasks for an I/O-Bound Operation</source>
          <target state="translated">Подробный обзор задач, связанных с операциями ввода-вывода</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following section describes a 10,000 foot view of what happens with a typical async I/O call.</source>
          <target state="translated">В следующем разделе приводится общее описание того, что происходит с обычным асинхронным вызовом ввода-вывода.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Let's start with a couple examples.</source>
          <target state="translated">Начнем с нескольких примеров.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The first example calls an async method and returns an active task, likely yet to complete.</source>
          <target state="translated">В первом примере вызывается асинхронный метод и возвращается активная задача, которая, вероятно, еще не завершилась.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The second example adds the use of he <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords to operate on the task.</source>
          <target state="translated">Во втором примере для работы с задачей добавляются ключевые слова <ph id="ph1">`async`</ph> и <ph id="ph2">`await`</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The call to <ph id="ph1">`GetStringAsync()`</ph> calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</source>
          <target state="translated">Вызов <ph id="ph1">`GetStringAsync()`</ph> обращается к библиотекам .NET более низкого уровня (возможно с вызовом других асинхронных методов), пока не достигнет вызова взаимодействия P/Invoke собственной сетевой библиотеки.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The native library may subsequently call into a System API call (such as <ph id="ph1">`write()`</ph> to a socket on Linux).</source>
          <target state="translated">Собственная библиотека может впоследствии воспользоваться вызовом API System (например, выполнить запись <ph id="ph1">`write()`</ph> в сокет в системе Linux).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A task object will be created at the native/managed boundary, possibly using <bpt id="p1">[</bpt>TaskCompletionSource<ept id="p1">](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))</ept>.</source>
          <target state="translated">Объект задачи будут создан на собственной/управляемой границе, возможно, с использованием <bpt id="p1">[</bpt>TaskCompletionSource<ept id="p1">](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))</ept>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</source>
          <target state="translated">Объект задачи будет передаваться вверх через уровни, возможно, с некоторой обработкой или напрямую, и в результате возвратится к исходному вызывающему объекту.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In the second example above, a <ph id="ph1">`Task&lt;T&gt;`</ph> object will be returned from <ph id="ph2">`GetStringAsync`</ph>.</source>
          <target state="translated">Во втором примере выше объект <ph id="ph1">`Task&lt;T&gt;`</ph> будет возвращен из <ph id="ph2">`GetStringAsync`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The use of the <ph id="ph1">`await`</ph> keyword causes the method to return a newly created task object.</source>
          <target state="translated">Использование ключевого слова <ph id="ph1">`await`</ph> предписывает методу возвратить только что созданный объект задачи.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Control returns to the caller from this location in the <ph id="ph1">`GetFirstCharactersCountAsync`</ph> method.</source>
          <target state="translated">Управление возвращается вызывающему объекту из этого места в методе <ph id="ph1">`GetFirstCharactersCountAsync`</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The methods and properties of the <bpt id="p1">[</bpt>Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Threading.Tasks.Task%601)</ept> object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</source>
          <target state="translated">Методы и свойства объекта <bpt id="p1">[</bpt>Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Threading.Tasks.Task%601)</ept> позволяют вызывающим объектам отслеживать ход выполнения задачи, которая завершится после выполнения оставшегося кода в GetFirstCharactersCountAsync.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as <ph id="ph1">`/net`</ph> in the Linux Kernel).</source>
          <target state="translated">После вызова API System запрос оказывается в пространстве ядра и доходит до сетевой подсистемы операционной системы (например, до <ph id="ph1">`/net`</ph> в Linux).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Here the OS will handle the networking request <bpt id="p1">*</bpt>asynchronously<ept id="p1">*</ept>.</source>
          <target state="translated">На этом этапе ОС обрабатывает сетевой запрос <bpt id="p1">*</bpt>асинхронно<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and <bpt id="p1">*</bpt>then<ept id="p1">*</ept> a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</source>
          <target state="translated">Детали могут отличаться в зависимости от используемой операционной системы (вызов драйвера устройства может быть запланирован как сигнал, возвращаемый в среду выполнения, либо сначала выполняется вызов драйвера устройства, а <bpt id="p1">*</bpt>затем<ept id="p1">*</ept> возвращается сигнал), но в конечном счете среда выполнения будет проинформирована о том, что идет выполнение сетевого запроса.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</source>
          <target state="translated">В это время драйвер устройства может находиться в одном из трех состояний: работа запланирована, работа выполняется, работа завершена (запрос уже отправлен обратно), но так как все это происходит асинхронно, драйвер устройства может сразу же приступать к выполнению других задач.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</source>
          <target state="translated">Например, в Windows поток операционной системы направляет вызов к драйверу сетевого устройства и запрашивает у него выполнение сетевой операции через пакет запроса прерывания (IRP), который представляет собой операцию.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</source>
          <target state="translated">Драйвер устройства получает IRP, делает вызов к сети, помечает IRP как "ожидающий" и возвращает управление операционной системе.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</source>
          <target state="translated">Так как поток ОС теперь знает, что запрос является "ожидающим", ему больше нечего делать в рамках этого задания и он "возвращается" обратно, где его можно использовать в других целях.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</source>
          <target state="translated">Когда запрос выполнен и данные возвращаются через драйвер устройства, поток с помощью прерывания уведомляет ЦП о получении новых данных.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</source>
          <target state="translated">Обработка этого прерывания зависит от операционной системы, но в конечном счете данные будут передаваться в ОС, пока не достигнут вызова системного взаимодействия (например, в Linux обработчик прерываний зарезервирует нижнюю половину IRQ для асинхронной передачи данных через ОС).</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Note that this <bpt id="p1">*</bpt>also<ept id="p1">*</ept> happens asynchronously!</source>
          <target state="translated">Обратите внимание, что это <bpt id="p1">*</bpt>также<ept id="p1">*</ept> происходит асинхронно.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The result is queued up until the next available thread is able execute the async method and "unwrap" the result of the completed task.</source>
          <target state="translated">Результат помещается в очередь, пока следующий доступный поток не сможет выполнить асинхронный метод и "развернуть" результат завершенной задачи.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Throughout this entire process, a key takeaway is that <bpt id="p1">**</bpt>no thread is dedicated to running the task<ept id="p1">**</ept>.</source>
          <target state="translated">На протяжении всего процесса ключевым моментом является то, что <bpt id="p1">**</bpt>ни один поток не выделяется для выполнения задачи<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Although work is executed in some context (i.e. the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to <bpt id="p1">*</bpt>waiting<ept id="p1">*</ept> for data from the request to come back.</source>
          <target state="translated">Несмотря на то, что работа выполняется в некотором контексте (т. е. ОС нужно передать данные в драйвер устройства и ответить на прерывание), никакой поток специально не выделяется для <bpt id="p1">*</bpt>ожидания<ept id="p1">*</ept> возвращения данных из запроса.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</source>
          <target state="translated">Это позволяет системе выполнять гораздо больший объем работы, а не ждать завершения какого-либо вызова операции ввода-вывода.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</source>
          <target state="translated">Несмотря на то, что вышесказанное может показаться довольно масштабным процессом, если его оценивать по общему времени исполнения, это считанные мгновения по сравнению с временем, которое тратится на фактические процедуры ввода-вывода.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Although not at all precise, a potential timeline for such a call would look like this:</source>
          <target state="translated">График выполнения такого вызова, без претензии на точность, может выглядеть следующим образом:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>0-1————————————————————————————————————————————————–2-3</source>
          <target state="translated">0-1————————————————————————————————————————————————–2-3</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Time spent from points <ph id="ph1">`0`</ph> to <ph id="ph2">`1`</ph> is everything up until an async method yields control to its caller.</source>
          <target state="translated">Время между точками <ph id="ph1">`0`</ph> и <ph id="ph2">`1`</ph> — это все, что происходит до того, как асинхронный метод передает управление вызывающему его объекту.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Time spent from points <ph id="ph1">`1`</ph> to <ph id="ph2">`2`</ph> is the time spent on I/O, with no CPU cost.</source>
          <target state="translated">Время между точками <ph id="ph1">`1`</ph> и <ph id="ph2">`2`</ph> — это время, которое тратится на операции ввода-вывода без участия ЦП.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Finally, time spent from points <ph id="ph1">`2`</ph> to <ph id="ph2">`3`</ph> is passing control back (and potentially a value) to the async method, at which point it is executing again.</source>
          <target state="translated">Наконец, время между точками <ph id="ph1">`2`</ph> и <ph id="ph2">`3`</ph> — это время на передачу назад управления (и, возможно, значения) асинхронному методу, когда он начинает выполняться снова.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>What does this mean for a server scenario?</source>
          <target state="translated">Что это означает для сервера?</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This model works well with a typical server scenario workload.</source>
          <target state="translated">Эта модель хорошо подходит для типовых рабочих нагрузок на сервере.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</source>
          <target state="translated">Поскольку потоков, выделенных для блокировки незавершенных задач, нет, пул потоков на сервере может обрабатывать намного большее количество веб-запросов.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Consider two servers: one that runs async code, and one that does not.</source>
          <target state="translated">Рассмотрим два сервера: один выполняет асинхронный код, а второй нет.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For the purpose of this example, each server only has 5 threads available to service requests.</source>
          <target state="translated">В данном примере на каждом сервере есть только 5 потоков, доступных для обслуживания запросов.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Note that these numbers are imaginarily small and serve only in a demonstrative context.</source>
          <target state="translated">Обратите внимание, что эти числа не имеют никакого отношения к реальным цифрам в жизни и используются только в качестве примера.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Assume both servers receive 6 concurrent requests.</source>
          <target state="translated">Предположим, что оба сервера получили 6 параллельных запросов.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Each request performs an I/O operation.</source>
          <target state="translated">В каждом запросе выполняется операция ввода-вывода.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The server <bpt id="p1">*</bpt>without<ept id="p1">*</ept> async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</source>
          <target state="translated">Сервер <bpt id="p1">*</bpt>без<ept id="p1">*</ept> асинхронного кода должен поставить в очередь 6-й запрос, пока один из 5 потоков не завершит работу, связанную с вводом-выводом, и не возвратит ответ.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</source>
          <target state="translated">После поступления 20-го запроса работа сервера может начать замедляться, поскольку очередь становится слишком длинной.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The server <bpt id="p1">*</bpt>with<ept id="p1">*</ept> async code running on it still queues up the 6th request, but because it uses <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph>, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</source>
          <target state="translated">Сервер <bpt id="p1">*</bpt>с<ept id="p1">*</ept> асинхронным кодом также помещает 6-й запрос в очередь, но так как он использует <ph id="ph1">`async`</ph> и <ph id="ph2">`await`</ph>, каждый из его потоков освобождается при начале работы подсистемы ввода-вывода, а не после завершения такой работы.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</source>
          <target state="translated">К моменту поступления 20-го запроса очередь входящих запросов будет гораздо меньше (если в ней вообще что-либо будет), а сервер будет работать как и прежде.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Although this is a contrived example, it works in a very similar fashion in the real world.</source>
          <target state="translated">Хотя этот пример и вымышленный, в реальном мире все происходит примерно так же.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In fact, you can expect a server to be able to handle an order of magnitude more requests using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> than if it were dedicating a thread for each request it receives.</source>
          <target state="translated">Фактически можно ожидать, что сервер сможет обрабатывать на порядок больше запросов при использовании <ph id="ph1">`async`</ph> и <ph id="ph2">`await`</ph>, в отличие от стратегии с выделением потока для каждого поступающего запроса.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>What does this mean for client scenario?</source>
          <target state="translated">Что это означает для клиента?</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The biggest gain for using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> for a client app is an increase in responsiveness.</source>
          <target state="translated">Важнейшим преимуществом использования <ph id="ph1">`async`</ph> и <ph id="ph2">`await`</ph> для клиента является повышение скорости реагирования.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph>.</source>
          <target state="translated">Несмотря на то, что приложение можно сделать более отзывчивым за счет создания потоков вручную, процедура создания потока — это дорогостоящая операция по сравнению с использованием <ph id="ph1">`async`</ph> и <ph id="ph2">`await`</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</source>
          <target state="translated">Это особенно актуально, например, для мобильных игр, где воздействие на поток пользовательского интерфейса минимально, а скорость ввода-вывода имеет решающее значение.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</source>
          <target state="translated">Что еще важнее, поскольку работа, связанная с вводом-выводом, практически не задействует ресурсов ЦП, выделение целого потока ЦП для выполнения мизерной нагрузки является крайне неэффективным использованием ресурсов.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with <ph id="ph1">`async`</ph> methods, and does not require extra work (such as calling a thread-safe delegate).</source>
          <target state="translated">Кроме того, направление работы в поток пользовательского интерфейса (например, обновление пользовательского интерфейса) с помощью методов <ph id="ph1">`async`</ph> реализуется очень просто и не требует дополнительных усилий (например, вызова потокобезопасного делегата).</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Deeper Dive into Task and Task<ph id="ph1">&lt;T&gt;</ph> for a CPU-Bound Operation</source>
          <target state="translated">Подробный обзор Task и Task<ph id="ph1">&lt;T&gt;</ph> для операций, связанных с ЦП</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>CPU-bound <ph id="ph1">`async`</ph> code is a bit different than I/O-bound <ph id="ph2">`async`</ph> code.</source>
          <target state="translated">Код <ph id="ph1">`async`</ph>, связанный с использованием ЦП, немного отличается от кода <ph id="ph2">`async`</ph>, связанного с операциями ввода-вывода.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</source>
          <target state="translated">Поскольку работа выполняется на ЦП, невозможно избежать выделения потока для вычислений.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The use of <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</source>
          <target state="translated">Использование <ph id="ph1">`async`</ph> и <ph id="ph2">`await`</ph> предоставляет чистый способ взаимодействия с фоновым потоком и позволяет объекту, вызвавшему асинхронный метод, по-прежнему реагировать на новые запросы.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Note that this does not provide any protection for shared data.</source>
          <target state="translated">Обратите внимание, что это не обеспечивает защиту общих данных.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If you are using shared data, you will still need to apply an appropriate synchronization strategy.</source>
          <target state="translated">Если вы используете общие данные, все равно потребуется применять соответствующую стратегию синхронизации.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Here's a 10,000 foot view of a CPU-bound async call:</source>
          <target state="translated">Ниже приводится общий обзор асинхронного вызова, связанного с ЦП:</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CalculateResult()`</ph> executes on the thread it was called on.</source>
          <target state="translated"><ph id="ph1">`CalculateResult()`</ph> выполняется в потоке, в котором он вызывался.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When it calls <ph id="ph1">`Task.Run`</ph>, it queues the expensive CPU-bound operation, <ph id="ph2">`DoExpensiveCalculation()`</ph>, on the thread pool and receives a <ph id="ph3">`Task&lt;int&gt;`</ph> handle.</source>
          <target state="translated">Когда он вызывает <ph id="ph1">`Task.Run`</ph>, он помещает дорогостоящую операцию, связанную с ЦП, <ph id="ph2">`DoExpensiveCalculation()`</ph>, в очередь пула потоков и получает дескриптор <ph id="ph3">`Task&lt;int&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`DoExpensiveCalculation()`</ph> is eventually run concurrently on the next available thread, likely on another CPU core.</source>
          <target state="translated"><ph id="ph1">`DoExpensiveCalculation()`</ph> в конечном счете выполняется параллельно в следующем доступном потоке, скорее всего, на другом ядре ЦП.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>It's possible to do concurrent work while <ph id="ph1">`DoExpensiveCalculation()`</ph> is busy on another thread, because the thread which called <ph id="ph2">`CalculateResult()`</ph> is still executing.</source>
          <target state="translated">Пока <ph id="ph1">`DoExpensiveCalculation()`</ph> выполняется в другом потоке, можно выполнять параллельные операции, так как поток, вызвавший <ph id="ph2">`CalculateResult()`</ph>, по-прежнему выполняется.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Once <ph id="ph1">`await`</ph> is encountered, the execution of <ph id="ph2">`CalculateResult()`</ph> is yielded to its caller, allowing other work to be done with the current thread while <ph id="ph3">`DoExpensiveCalculation()`</ph> is churning out a result.</source>
          <target state="translated">При появлении <ph id="ph1">`await`</ph> выполнение <ph id="ph2">`CalculateResult()`</ph> передается вызвавшему объекту, что позволяет выполнить другую работу в параллельном потоке, пока <ph id="ph3">`DoExpensiveCalculation()`</ph> формирует результат.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Once it has finished, the result is queued up to run on the main thread.</source>
          <target state="translated">После завершения его работы результат передается в очередь для использования в основном потоке.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Eventually, the main thread will return to executing <ph id="ph1">`CalculateResult()`</ph>, at which point it will have the result of <ph id="ph2">`DoExpensiveCalculation()`</ph>.</source>
          <target state="translated">В конечном счете основной поток вернется к выполнению <ph id="ph1">`CalculateResult()`</ph>, при этом у него будет результат <ph id="ph2">`DoExpensiveCalculation()`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Why does async help here?</source>
          <target state="translated">Что здесь дает асинхронный режим?</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> are the best practice managing CPU-bound work when you need responsiveness.</source>
          <target state="translated"><ph id="ph1">`async`</ph> и <ph id="ph2">`await`</ph> рекомендуется использовать для действий, связанных с ЦП, когда необходима быстрая скорость реагирования.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>There are multiple patterns for using async with CPU-bound work.</source>
          <target state="translated">Существуют разные модели использования асинхронного кода для работы, связанной с ЦП.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>It's important to note that there is a small cost to using async and it's not recommended for tight loops.</source>
          <target state="translated">Важно отметить, что использование асинхронного кода приводит к небольшим затратам и не рекомендуется для непрерывных циклов.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>It's up to you to determine how you write your code around this new capability.</source>
          <target state="translated">Решать, как использовать эту новую возможность в своем коде, предстоит вам.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>