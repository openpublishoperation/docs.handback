<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">21672e28d0e76b98f6dac698096fccb2ce4edd03</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\options.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e7ed328ee4fc3ad1c060537e6e61b2ccbfdca11</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">23d388f8fdf51663297ee81b7fb936708875c16b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">Параметры регулярных выражений</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">Параметры регулярных выражений</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">Параметры регулярных выражений</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</source>
          <target state="translated">По умолчанию при сравнении входной строки с любыми литералами в шаблоне регулярного выражения учитывается регистр, пробел в шаблоне интерпретируется как литерал, а захватываемые группы в регулярном выражении именуются как явно, так и неявно.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</source>
          <target state="translated">Вы можете изменить эти и некоторые другие аспекты поведения регулярного выражения по умолчанию с помощью параметров регулярного выражения.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern matching method as a <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> enumeration value.</source>
          <target state="translated">Эти параметры, которые представлены в следующей таблице, могут быть указаны как часть шаблона регулярного выражения или переданы конструктору класса <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> или статичному методу сопоставления шаблона как значение перечисления <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>RegexOptions member</source>
          <target state="translated">Член RegexOptions</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Inline character</source>
          <target state="translated">Встроенный символ</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Effect</source>
          <target state="translated">Действие</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Недоступно</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Use default behavior.</source>
          <target state="translated">Использовать поведение по умолчанию.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Default options<ept id="p1">](#default-options)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Параметры по умолчанию<ept id="p1">](#default-options)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>i<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>i<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Use case-insensitive matching.</source>
          <target state="translated">Использовать соответствие без учета регистра.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Case-insensitive matching<ept id="p1">](#case-insensitive-matching)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Сопоставление без учета регистра<ept id="p1">](#case-insensitive-matching)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>m<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Use multiline mode, where <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> match the beginning and end of each line (instead of the beginning and end of the input string).</source>
          <target state="translated">Использовать многострочный режим, где <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> и <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> соответствуют началу и концу строки текста (а не началу и концу входной строки).</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Multiline mode<ept id="p1">](#multiline-mode)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Многострочный режим<ept id="p1">](#multiline-mode)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>s<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>s<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Use single-line mode, where the period (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) matches every character (instead of every character except <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>).</source>
          <target state="translated">Использовать однострочный режим, где точка (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) соответствует любому символу (а не каждому символу, кроме <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Single-line mode<ept id="p1">](#single-line-mode)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Однострочный режим<ept id="p1">](#single-line-mode)</ept>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>n<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>n<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Do not capture unnamed groups.</source>
          <target state="translated">Не захватывать неименованные группы.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The only valid captures are explicitly named or numbered groups of the form <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</source>
          <target state="translated">Единственные допустимые захваты — это явно именованные или нумерованные группы в формате <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Explicit captures only<ept id="p1">](#explicit-captures-only)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Только явные захваты<ept id="p1">](#explicit-captures-only)</ept>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Недоступно</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Compile the regular expression to an assembly.</source>
          <target state="translated">Скомпилировать регулярное выражение в сборку.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Compiled regular expressions<ept id="p1">](#compiled-regular-expressions)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Скомпилированные регулярные выражения<ept id="p1">](#compiled-regular-expressions)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>x<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>x<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Exclude unescaped white space from the pattern, and enable comments after a number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>).</source>
          <target state="translated">Исключить неэкранированные пробелы из шаблона и включить комментарии после символа решетки (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>).</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Ignore white space<ept id="p1">](#ignore-white-space)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Пропуск пробелов<ept id="p1">](#ignore-white-space)</ept>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Недоступно</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Change the search direction.</source>
          <target state="translated">Изменить направление поиска.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Search moves from right to left instead of from left to right.</source>
          <target state="translated">Поиск идет справа налево, а не слева направо.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Right-to-left mode<ept id="p1">](#right-to-left-mode)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Режим "справа налево"<ept id="p1">](#right-to-left-mode)</ept>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Недоступно</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Enable ECMAScript-compliant behavior for the expression.</source>
          <target state="translated">Включить поведение, совместимое с ECMAScript, для выражения.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>ECMAScript matching behavior<ept id="p1">](#ecmascript-matching-behavior)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Поведение сопоставления ECMAScript<ept id="p1">](#ecmascript-matching-behavior)</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Недоступно</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Ignore cultural differences in language.</source>
          <target state="translated">Игнорировать различия региональных параметров в языке.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Comparison using the invariant culture<ept id="p1">](#comparison-using-the-invariant-culture)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Сравнение с использованием инвариантных региональных параметров<ept id="p1">](#comparison-using-the-invariant-culture)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Specifying the options</source>
          <target state="translated">Указание параметров</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You can specify options for regular expressions in one of three ways:</source>
          <target state="translated">Параметры регулярных выражений можно указать одним из трех способов:</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter of a <bpt id="p2">[</bpt>System.Text.RegularExpressions.Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor such as <bpt id="p3">[</bpt>Regex.Regex(String, RegexOptions)<ept id="p3">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions))</ept> or static (Shared in Visual Basic) pattern-matching method, such as  <bpt id="p4">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</source>
          <target state="translated">В параметре <bpt id="p1">*</bpt>options<ept id="p1">*</ept> конструктора класса <bpt id="p2">[</bpt>System.Text.RegularExpressions.Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept>, такого как <bpt id="p3">[</bpt>Regex.Regex(String, RegexOptions)<ept id="p3">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions))</ept>, или статического метода сопоставления шаблона (Shared в Visual Basic), такого как <bpt id="p4">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter is a bitwise OR combination of <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> enumerated values.</source>
          <target state="translated">Параметр <bpt id="p1">*</bpt>options<ept id="p1">*</ept> — побитовое сочетание OR значений перечисления <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>When options are supplied to a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> instance by using the <bpt id="p2">*</bpt>options<ept id="p2">*</ept> parameter of a class constructor, the options are are assigned to the <bpt id="p3">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property.</source>
          <target state="translated">Когда параметры передаются экземпляру <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> с помощью параметра <bpt id="p2">*</bpt>options<ept id="p2">*</ept> конструктора класса, они присваиваются свойству <bpt id="p3">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>However, the <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property does not reflect inline options in the regular expression pattern itself.</source>
          <target state="translated">Однако свойство <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> не отражает встроенные параметры в самом шаблоне регулярного выражения.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">Ниже приведен пример.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter of the <bpt id="p2">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">В нем параметр <bpt id="p1">*</bpt>options<ept id="p1">*</ept> метода <bpt id="p2">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> используется для включения сопоставления без учета регистра и пропуска пробелов при определении слов, начинающихся с буквы "d".</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>By applying inline options in a regular expression pattern with the syntax <bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept>.</source>
          <target state="translated">Применяя встроенные параметры в шаблоне регулярного выражения с помощью синтаксиса <bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</source>
          <target state="translated">Параметр применяется к шаблону от точки, в которой определен параметр, и действует либо до конца шаблона, либо до точки, в которой другая конструкция отменяет параметр.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Note that the <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> instance does not reflect these inline options.</source>
          <target state="translated">Обратите внимание, что свойство <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> экземпляра <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> не отражает этих встроенных параметров.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Miscellaneous constructs in regular expressions<ept id="p1">](miscellaneous.md)</ept> topic.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Другие конструкции в регулярных выражениях<ept id="p1">](miscellaneous.md)</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">Ниже приведен пример.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">В нем встроенные параметры используются для включения сопоставления без учета регистра и пропуска пробелов при определении слов, начинающихся с буквы "d".</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>By applying inline options in a particular grouping construct in a regular expression pattern with the syntax <bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">Применяя встроенные параметры в определенной конструкции группировки в шаблоне регулярного выражения с помощью синтаксиса <bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</source>
          <target state="translated">Если знак перед наборов параметров отсутствует, он включается. Если перед набором параметров есть знак минуса, набор отключается.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>(<bpt id="p1">**</bpt>?<ept id="p1">**</ept></source>
          <target state="translated">(<bpt id="p1">**</bpt>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</source>
          <target state="translated">— это фиксированная часть синтаксиса языковой конструкции, необходимая, если параметры включаются или отключаются.) Этот параметр применяется только к данной группе.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Конструкции группировки в регулярных выражениях<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">Ниже приведен пример.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">В нем встроенные параметры в конструкции группировки используются для включения сопоставления без учета регистра и пропуска пробелов при определении слов, начинающихся с буквы "d".</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>If options are specified inline, a minus sign (-) before an option or set of options turns off those options.</source>
          <target state="translated">Если параметры указываются в строке, знак минуса (-) перед параметром или набором параметров отключает соответствующие параметры.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For example, the inline construct <bpt id="p1">**</bpt>(?ix-ms)<ept id="p1">**</ept> turns on the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> and <bpt id="p3">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> options and turns off the <bpt id="p4">[</bpt>RegexOptions.Multiline<ept id="p4">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> and <bpt id="p5">[</bpt>RegexOptions.Singleline<ept id="p5">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> options.</source>
          <target state="translated">Например, встроенная конструкция <bpt id="p1">**</bpt>(? ix-ms)<ept id="p1">**</ept> включает параметры <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> и <bpt id="p3">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> и отключает параметры <bpt id="p4">[</bpt>RegexOptions.Multiline<ept id="p4">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> и <bpt id="p5">[</bpt>RegexOptions.Singleline<ept id="p5">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>All regular expression options are turned off by default.</source>
          <target state="translated">Все параметры регулярного выражения по умолчанию отключены.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If the regular expression options specified in the options parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</source>
          <target state="translated">Если параметры регулярного выражения, указанные в параметре options конструктора или вызове метода, конфликтуют со встроенными параметрами в шаблоне регулярного выражения, используются последние.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The following five regular expression options can be set both with the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter and inline:</source>
          <target state="translated">Следующие пять параметров регулярного выражения можно задавать одновременно в параметре <bpt id="p1">*</bpt>options<ept id="p1">*</ept> и в строке:</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The following five regular expression options can be set using the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter but cannot be set inline:</source>
          <target state="translated">Следующие пять параметров регулярного выражения можно задавать в параметре <bpt id="p1">*</bpt>options<ept id="p1">*</ept>, но не в строке:</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Determining the options</source>
          <target state="translated">Определение параметров</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can determine which options were provided to a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object when it was instantiated by retrieving the value of the read-only <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> property.</source>
          <target state="translated">Вы можете определить, какие параметры были предоставлены объекту <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> при создании его экземпляра, получив значение свойства <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> только для чтения.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To test for the presence of any option except <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, perform an AND operation with the value of the <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> property and the <bpt id="p3">[</bpt>RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> value in which you are interested.</source>
          <target state="translated">Чтобы проверить наличие любого параметра, кроме <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, выполните операцию AND со значением свойства <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> и значением <bpt id="p3">[</bpt>RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept>, которое вас интересует.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Then test whether the result equals that <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> value.</source>
          <target state="translated">Затем проверьте, равен ли результат значению <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The following example tests whether the <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option has been set.</source>
          <target state="translated">Следующий пример проверяет, задан ли параметр <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>To test for <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, determine whether the value of the <bpt id="p2">[</bpt>RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property is equal to <bpt id="p3">[</bpt>RegexOptions.None<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, as the following example illustrates.</source>
          <target state="translated">Чтобы проверить наличие параметра <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, определите, равно ли значение свойства <bpt id="p2">[</bpt>RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> значению <bpt id="p3">[</bpt>RegexOptions.None<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following sections list the options supported by regular expression in  .NET.</source>
          <target state="translated">В следующих разделах перечислены параметры, поддерживаемые регулярными выражениями платформы .NET.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Default options</source>
          <target state="translated">Параметры по умолчанию</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</source>
          <target state="translated">Параметр <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> указывает, что ни один параметр не задан, а механизм регулярных выражений использует поведение по умолчанию.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This includes the following:</source>
          <target state="translated">Это поведение характеризуется следующим образом.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</source>
          <target state="translated">Шаблон интерпретируется как каноническое, а не регулярное выражение ECMAScript.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is matched in the input string from left to right.</source>
          <target state="translated">Шаблон регулярного выражения сопоставляется во входной строке слева направо.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Comparisons are case-sensitive.</source>
          <target state="translated">При сравнениях учитывается регистр.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> language elements match the beginning and end of the input string.</source>
          <target state="translated">Языковые элементы <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> и <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> сосуществуют началу и концу входной строки.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>.<ept id="p1">**</ept></source>
          <target state="translated">Языковой элемент <bpt id="p1">**</bpt>.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>language element matches every character except <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</source>
          <target state="translated">соответствует каждому символу, кроме <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Any white space in a regular expression pattern is interpreted as a literal space character.</source>
          <target state="translated">Любой пробел в шаблоне регулярного выражения интерпретируется как пробел-литерал.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The conventions of the current culture are used when comparing the pattern to the input string.</source>
          <target state="translated">При сравнении шаблона со входной строкой используются соглашения текущих региональных параметров.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Capturing groups in the regular expression pattern are implicit as well as explicit.</source>
          <target state="translated">Захватываемые группы в шаблоне регулярного выражения являются неявными и явными.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option has no inline equivalent.</source>
          <target state="translated">Параметр <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> не имеет эквивалента среди встроенных параметров.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</source>
          <target state="translated">Если параметры регулярного выражения применяются в строке, поведение по умолчанию восстанавливается для каждого параметра, за счет отключения того или иного параметра.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`(?i)`</ph> turns on case-insensitive comparison, and <ph id="ph2">`(?-i)`</ph> restores the default case-sensitive comparison.</source>
          <target state="translated">Например, <ph id="ph1">`(?i)`</ph> включает сравнение без учета регистра, а <ph id="ph2">`(?-i)`</ph> восстанавливает учет регистра при сравнении.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</source>
          <target state="translated">Так как параметр <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> представляет поведение механизма регулярных выражений по умолчанию, он редко явно указывается в вызове метода.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>A constructor or static pattern-matching method without an options parameter is called instead.</source>
          <target state="translated">Вместо этого вызывается конструктор или статичный метод сопоставления шаблона без параметра options.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Case-insensitive matching</source>
          <target state="translated">Сопоставление без учета регистра</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option, or the <bpt id="p2">**</bpt>i<ept id="p2">**</ept> inline option, provides case-insensitive matching.</source>
          <target state="translated">Параметр <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> или встроенный параметр <bpt id="p2">**</bpt>i<ept id="p2">**</ept> обеспечивает сопоставление без учета регистра.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>By default, the casing conventions of the current culture are used.</source>
          <target state="translated">По умолчанию используются соглашения о регистре текущих региональных параметров.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression pattern, <ph id="ph1">`\bthe\w*\b`</ph>, that matches all words starting with "the".</source>
          <target state="translated">Следующий пример определяет шаблон регулярного выражения, <ph id="ph1">`\bthe\w*\b`</ph>, который сопоставляет все слова, начинающиеся со строки "the".</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Because the first call to the Match method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</source>
          <target state="translated">Так как первый вызов метода Match использует сравнение с учетом регистра по умолчанию, в выходных данных указывается, что строка "The" в начале предложения не была сопоставлена.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It is matched when the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with options set to <bpt id="p2">[</bpt>IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>.</source>
          <target state="translated">Она выделяется, если метод <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> вызывается с параметром options, имеющим значение <bpt id="p2">[</bpt>IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The following example modifies the regular expression pattern from the previous example to use inline options instead of the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter to provide case-insensitive comparison.</source>
          <target state="translated">В следующем примере показано изменение шаблона регулярного выражения из предыдущего примера для использования встроенных параметров вместо параметра <bpt id="p1">*</bpt>options<ept id="p1">*</ept>, чтобы включить сравнение без учета регистра.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</source>
          <target state="translated">Первый шаблон определяет параметр отключения учета регистра в конструкции группировки, которая применяется только к букве "t" в строке "the".</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</source>
          <target state="translated">Так как конструкция указана в начале шаблона, второй шаблон применяет параметр учета регистра ко всему регулярному выражению.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Multiline mode</source>
          <target state="translated">Многострочный режим</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, or the <bpt id="p2">**</bpt>m<ept id="p2">**</ept> inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</source>
          <target state="translated">Параметр <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> или встроенный параметр <bpt id="p2">**</bpt>m<ept id="p2">**</ept> позволяет механизму регулярных выражений обрабатывать входную строку, которая состоит из нескольких строк.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It changes the interpretation of the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</source>
          <target state="translated">Он изменяет интерпретацию языковых элементов <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> и <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept>, чтобы они сопоставляли начало и конец строки текста, а не начало и строки входной строки.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>By default, <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> matches only the end of the input string.</source>
          <target state="translated">По умолчанию <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> сопоставляет конец входной строки.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>If you specify the <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, it matches either the newline character <bpt id="p2">**</bpt>(\n)<ept id="p2">**</ept> or the end of the input string.</source>
          <target state="translated">Если указать параметр <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>, он сопоставляет символ новой строки (<bpt id="p2">**</bpt>(\n)<ept id="p2">**</ept>) или конец входной строки.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>It does not, however, match the carriage return/line feed character combination.</source>
          <target state="translated">Однако он не сопоставляет комбинацию символов возврата каретки и перевода строки.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>To successfully match them, use the subexpression <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> instead of just <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>.</source>
          <target state="translated">Для их успешного сопоставления используйте часть выражения <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> вместо <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The following example extracts bowlers names and scores and adds them to a <bpt id="p1">[</bpt>SortedList<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.SortedList%602)</ept> collection that sorts them in descending order.</source>
          <target state="translated">В следующем примере извлекаются имена и баллы игроков в боулинг и добавляются в коллекцию <bpt id="p1">[</bpt>SortedList<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.SortedList%602)</ept>, где они сортируются по убыванию.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> method is called twice.</source>
          <target state="translated">Метод <bpt id="p1">[</bpt>Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> вызывается два раза.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>In the first method call, the regular expression is <ph id="ph1">`^(\w+)\s(\d+)$`</ph> and no options are set.</source>
          <target state="translated">В первом вызове метода используется регулярное выражение <ph id="ph1">`^(\w+)\s(\d+)$`</ph>, параметры не заданы.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</source>
          <target state="translated">Как видно в результатах, совпадения не найдены, так как механизм регулярных выражений не может сопоставить входной шаблон с началом и концом входной строки.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>In the second method call, the regular expression is changed to <ph id="ph1">`^(\w+)\s(\d+)\r?$`</ph> and the options are set to <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</source>
          <target state="translated">Во втором вызове метода регулярное выражение меняется на <ph id="ph1">`^(\w+)\s(\d+)\r?$`</ph> и задаются параметры <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</source>
          <target state="translated">Как видно в результатах, имена и баллы успешно сопоставляются, а баллы отображаются по убыванию.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^(\w+)\s(\d+)\r*$`</ph> is defined as shown in the following table.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`^(\w+)\s(\d+)\r*$`</ph> определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Begin at the start of the line.</source>
          <target state="translated">Начало с первого символа строки.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Это первая группа записи.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Соответствует пробелу.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Совпадение с одной или несколькими десятичными цифрами.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">Это вторая группа записи.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Match zero or one carriage return character.</source>
          <target state="translated">Сопоставление нуля или одного символа возврата каретки.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>End at the end of the line.</source>
          <target state="translated">Окончание в конце строки.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous one, except that it uses the inline option <bpt id="p1">**</bpt>(?m)<ept id="p1">**</ept> to set the multiline option.</source>
          <target state="translated">Следующий пример аналогичен предыдущему, но он использует встроенный параметр <bpt id="p1">**</bpt>(?m)<ept id="p1">**</ept> для включения многострочного режима.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Single-line mode</source>
          <target state="translated">Однострочный режим</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option, or the s inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</source>
          <target state="translated">Параметр <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> или встроенный параметр s позволяет механизму регулярных выражений обрабатывать входную строку так, будто она состоит из одной строки.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>It does this by changing the behavior of the period (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) language element so that it matches every character, instead of matching every character except for the newline character <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> or \u000A.</source>
          <target state="translated">Для этого поведение языкового элемента <bpt id="p1">**</bpt>.<ept id="p1">**</ept> меняется так, чтобы он сопоставлял каждый символ, а не каждый символ кроме символа новой строки <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> или \u000A.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The following example illustrates how the behavior of the .</source>
          <target state="translated">В следующем примере показано различное поведение языкового элемента "."</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>language element changes when you use the <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option.</source>
          <target state="translated">при использовании параметра <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^.+`</ph> starts at the beginning of the string and matches every character.</source>
          <target state="translated">Регулярное выражение <ph id="ph1">`^.+`</ph> начинается с начала строки и соответствует любому знаку.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, <bpt id="p1">**</bpt>\r<ept id="p1">**</ept> or \u000D, but it does not match <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</source>
          <target state="translated">По умолчанию соответствие заканчивается в конце первой строки; шаблон регулярного выражения соответствует символу возврата каретки <bpt id="p1">**</bpt>\r<ept id="p1">**</ept> или \u000D, но не соответствует <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option interprets the entire input string as a single line, it matches every character in the input string, including <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</source>
          <target state="translated">Поскольку параметр <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> интерпретирует всю входную строку как единую строку, он сопоставляет каждый символ в строке ввода, включая <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous one, except that it uses the inline option <bpt id="p1">**</bpt>(?s)<ept id="p1">**</ept> to enable single-line mode.</source>
          <target state="translated">Следующий пример аналогичен предыдущему, но он использует встроенный параметр <bpt id="p1">**</bpt>(?s)<ept id="p1">**</ept> для включения однострочного режима.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Explicit captures only</source>
          <target state="translated">Только явные захваты</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</source>
          <target state="translated">По умолчанию захватываемые группы определяются с помощью круглых скобок в шаблоне регулярного выражения.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Named groups are assigned a name or number by the <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> language option, whereas unnamed groups are accessible by index.</source>
          <target state="translated">Именованным группам назначается имя или номер с помощью параметра <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>, а именованные группы доступны по индексу.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object, unnamed groups precede named groups.</source>
          <target state="translated">В объекте <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> неименованные группы идут перед именованными.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</source>
          <target state="translated">Конструкции группировки часто используются только для применения квантификаторов к нескольким языковым элементам, а захваченные подстроки не представляют интереса.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>For example, if the following regular expression:</source>
          <target state="translated">Например, если следующее регулярное выражение,</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> object) is of interest.</source>
          <target state="translated">предназначено только для извлечения предложений, которые оканчиваются на точку, восклицательный или вопросительный знак из документа, и только полученное предложение (в объекте <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept>) представляет интерес,</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The individual words in the collection are not.</source>
          <target state="translated">а отдельные слова в коллекции — нет.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collection objects.</source>
          <target state="translated">Захватываемые группы, которые не используются в последствии, могут потреблять много ресурсов, так как механизм регулярных выражений должен заполнить объекты <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> и <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> коллекции.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>As an alternative, you can use either the <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option or the <bpt id="p2">**</bpt>n<ept id="p2">**</ept> inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the <bpt id="p3">**</bpt>(?&lt;<ept id="p3">**</ept><bpt id="p4">_</bpt>name<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">&gt;</ph><ept id="p5">**</ept> <bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept> construct.</source>
          <target state="translated">В качестве альтернативы можно использовать параметр <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> или встроенный параметр <bpt id="p2">**</bpt>n<ept id="p2">**</ept>, чтобы указать, что только допустимые выделения являются явно именованными или нумерованными группами, обозначенными конструкцией <bpt id="p3">**</bpt>(?&lt;<ept id="p3">**</ept><bpt id="p4">_</bpt>name<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">&gt;</ph><ept id="p5">**</ept> <bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The following example displays information about the matches returned by the <ph id="ph1">`\b\(?((\w+),?\s?)+[\.!?]\)?`</ph> regular expression pattern when the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept> method is called with and without the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">Следующий пример отображает сведения о сопоставлениях, возвращаемых шаблоном регулярного выражения <ph id="ph1">`\b\(?((\w+),?\s?)+[\.!?]\)?`</ph>, если метод <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept> вызывается с параметром <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> или без него.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>As the output from the first method call shows, the regular expression engine fully populates the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collection objects with information about captured substrings.</source>
          <target state="translated">Как видно в результатах выполнения первого вызова метода, механизм регулярных выражений полностью заполняет объекты коллекции <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> и <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> данными о захваченных подстроках.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Because the second method is called with options set to <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>, it does not capture information on groups.</source>
          <target state="translated">Так как второй метод вызывается с параметром options, для которого задано значение <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>, он не записывает информацию о группах.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b\(?((?&gt;\w+),?\s?)+[\.!?]\)?`</ph> is defined as shown in the following table.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\b\(?((?&gt;\w+),?\s?)+[\.!?]\)?`</ph> определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Begin at a word boundary.</source>
          <target state="translated">Начало на границе слова.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrences of the opening parenthesis ("(").</source>
          <target state="translated">Сопоставляется ноль или один экземпляр открывающих круглых скобок ("(").</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Match one or more word characters, followed by zero or one commas.</source>
          <target state="translated">Сопоставляется один или несколько словообразующих символов, за которыми следует ноль или одна запятая.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Do not backtrack when matching word characters.</source>
          <target state="translated">При сопоставлении словообразующих символов обратный поиск не применяется.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space characters.</source>
          <target state="translated">Совпадение с нулем или одним символом пробела.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</source>
          <target state="translated">Один или несколько раз выделяет комбинацию из одного или нескольких символов, нуля или одной запятой, нуля или одного пробела.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</source>
          <target state="translated">Сопоставляются любые из трех знаков пунктуации, за которыми следует ноль или одна закрывающая круглая скобка (")").</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>You can also use the <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> inline element to suppress automatic captures.</source>
          <target state="translated">Вы также можете использовать встроенный элемент <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept>, чтобы отключить автоматическое выделение.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous regular expression pattern to use the <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> inline element instead of the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">Следующий пример изменяет предыдущий шаблон регулярного выражения, чтобы использовать встроенный элемент <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> вместо параметра <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Finally, you can use the inline group element <bpt id="p1">**</bpt>(?n:)<ept id="p1">**</ept> to suppress automatic captures on a group-by-group basis.</source>
          <target state="translated">Наконец, вы можете использовать встроенный элемент группы <bpt id="p1">**</bpt>(?n:)<ept id="p1">**</ept>, чтобы отключить автоматическое выделение для отдельных групп.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous pattern to suppress unnamed captures in the outer group, <ph id="ph1">`((?&gt;\w+),?\s?)`</ph>.</source>
          <target state="translated">Следующий пример изменяет предыдущий шаблон, чтобы отключить неименованные выделения во внешней группе, <ph id="ph1">`((?&gt;\w+),?\s?)`</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Note that this suppresses unnamed captures in the inner group as well.</source>
          <target state="translated">Обратите внимание, что при этом подавляются неименованные выделения и во внутренней группе.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Compiled regular expressions</source>
          <target state="translated">Скомпилированные регулярные выражения</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>By default, regular expressions in .NET are interpreted.</source>
          <target state="translated">По умолчанию регулярные выражения в .NET интерпретируются.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>When a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated or a static <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</source>
          <target state="translated">Когда создается экземпляр объекта <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> или вызывается статичный метод <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept>, шаблон регулярного выражения преобразуется в набор настраиваемых кодов операций, а интерпретатор использует их для выполнения регулярного выражения.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</source>
          <target state="translated">С этим связан компромисс: затраты на инициализацию механизма регулярных выражений уменьшаются за счет производительности во время выполнения.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You can use compiled instead of interpreted regular expressions by using the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option.</source>
          <target state="translated">Вместо интерпретируемых регулярных выражений можно использовать скомпилированные регулярные выражения, указав параметр <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</source>
          <target state="translated">В этом случае при передаче шаблона механизму регулярных выражений он разбивается на набор кодов операций и преобразуется в инструкции MSIL, которые можно передать напрямую среде CLR.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Compiled regular expressions maximize run-time performance at the expense of initialization time.</source>
          <target state="translated">Скомпилированные регулярные выражения повышают производительность во время выполнения, но за счет более длительной инициализации.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>A regular expression can be compiled only by supplying the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or a static pattern-matching method.</source>
          <target state="translated">Чтобы скомпилировать регулярное выражение, необходимо передать значение <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> параметру options конструктора класса <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> или статичного метода сопоставления шаблона.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">Этот параметр не может быть указан как встроенный.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>You can use compiled regular expressions in calls to both static and instance regular expressions.</source>
          <target state="translated">Вы можете использовать скомпилированные регулярные выражения в вызовах статичных регулярных выражений и регулярных выражений экземпляров.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>In static regular expressions, the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option is passed to the options parameter of the regular expression pattern-matching method.</source>
          <target state="translated">В статичных регулярных выражениях параметр <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> передается в параметр options метода сопоставления шаблона регулярного выражения.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>In instance regular expressions, it is passed to the options parameter of the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor.</source>
          <target state="translated">В регулярных выражениях экземпляра он передается в параметр options конструктора класса <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>In both cases, it results in enhanced performance.</source>
          <target state="translated">В обоих случаях это повышает производительность.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>However, this improvement in performance occurs only under the following conditions:</source>
          <target state="translated">Однако такой рост производительности возможен только в следующих условиях:</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</source>
          <target state="translated">Объект <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>, представляющий определенное регулярное выражение, используется в нескольких вызовах методов сопоставления шаблона регулярного выражения.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is not allowed to go out of scope, so it can be reused.</source>
          <target state="translated">Объект <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> не может выходить за область применения, поэтому его можно использовать повторно.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>A static regular expression is used in multiple calls to regular expression pattern-matching methods.</source>
          <target state="translated">Статичное регулярное выражение используется в нескольких вызовах методов сопоставления шаблона регулярного выражения.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</source>
          <target state="translated">(Рост производительности возможен, так как регулярные выражения, используемые в вызовах статичных методов, кэшируются механизмом регулярных выражений.)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Ignore white space</source>
          <target state="translated">Пропуск пробелов</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</source>
          <target state="translated">По умолчанию пробел в шаблоне регулярного выражения учитывается. Он заставляет механизм регулярных выражений сопоставлять символ пробела во входной строке.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Because of this, the regular expression <ph id="ph1">`"\b\w+\s"`</ph> and <ph id="ph2">`"\b\w+ "`</ph> are roughly equivalent regular expressions.</source>
          <target state="translated">Из-за этого регулярные выражения <ph id="ph1">`"\b\w+\s"`</ph> и <ph id="ph2">`"\b\w+ "`</ph> практически аналогичны.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>In addition, when the number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</source>
          <target state="translated">Кроме того, если в шаблоне регулярного выражения найден символ решетки (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>), он интерпретируется как литерал, который необходимо сопоставить.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option, or the <bpt id="p2">**</bpt>x<ept id="p2">**</ept> inline option, changes this default behavior as follows:</source>
          <target state="translated">Параметр <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> или встроенный параметр <bpt id="p2">**</bpt>x<ept id="p2">**</ept> меняет такое поведение по умолчанию следующим образом.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Unescaped white space in the regular expression pattern is ignored.</source>
          <target state="translated">Неэкранированный пробел в шаблоне регулярного выражения игнорируется.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>To be part of a regular expression pattern, white-space characters must be escaped (for example, as <bpt id="p1">**</bpt>\s<ept id="p1">**</ept> or "*<bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept> ").</source>
          <target state="translated">Чтобы включить пробелы в шаблон регулярного выражения, их необходимо экранировать (например, как <bpt id="p1">**</bpt>\s<ept id="p1">**</ept> или "*<bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept> ").</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) is interpreted as the beginning of a comment, rather than as a literal character.</source>
          <target state="translated">Символ решетки (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) интерпретируется как начало комментария, а не литерал.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>All text in the regular expression pattern from the <bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept> character to the end of the string is interpreted as a comment.</source>
          <target state="translated">Весь текст в шаблоне регулярного выражения с символа <bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept> до конца строки интерпретируется как комментарий.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>However, in the following cases, white space characters in a regular expression aren't ignored, even if you use the <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option:</source>
          <target state="translated">Однако в следующих случаях пробелы в регулярном выражении не игнорируются, даже если указан параметр <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>White space within a character class is always interpreted literally.</source>
          <target state="translated">Пробел в классе символов всегда интерпретируется как литерал.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`[ .,;:]`</ph> matches any single white-space character, period, comma, semicolon, or colon.</source>
          <target state="translated">Например, шаблон регулярного выражения <ph id="ph1">`[ .,;:]`</ph> сопоставляет любой отдельный символ пробела, точки, запятой, точки с запятой и двоеточия.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>White space isn't allowed within a bracketed quantifier, such as <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,}<ept id="p6">**</ept>, and <bpt id="p7">**</bpt>{<ept id="p7">**</ept><bpt id="p8">_</bpt>n<ept id="p8">_</ept><bpt id="p9">**</bpt>,<ept id="p9">**</ept><bpt id="p10">_</bpt>m<ept id="p10">_</ept><bpt id="p11">**</bpt>}<ept id="p11">**</ept>.</source>
          <target state="translated">Пробел не допускается в квантификаторах, окруженных квадратными скобками, например в <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,}<ept id="p6">**</ept> и <bpt id="p7">**</bpt>{<ept id="p7">**</ept><bpt id="p8">_</bpt>n<ept id="p8">_</ept><bpt id="p9">**</bpt>,<ept id="p9">**</ept><bpt id="p10">_</bpt>m<ept id="p10">_</ept><bpt id="p11">**</bpt>}<ept id="p11">**</ept>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <bpt id="p1">**</bpt>\d{1. 3}<ept id="p1">**</ept> fails to match any sequences of digits from one to three digits because it contains a white-space character.</source>
          <target state="translated">Например, шаблон регулярного выражения <bpt id="p1">**</bpt>\d{1. 3}<ept id="p1">**</ept> не сопоставляет последовательности цифр из одной до трех цифр, так как он содержит пробел.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>White space isn't allowed within a character sequence that introduces a language element.</source>
          <target state="translated">Пробел не допускается в последовательности символов, предоставляющей языковой элемент.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Пример:</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The language element <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> represents a noncapturing group, and the <bpt id="p4">**</bpt>(?:<ept id="p4">**</ept> portion of the element can't have embedded spaces.</source>
          <target state="translated">Языковой элемент <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> представляет незахватываемую группу, а часть <bpt id="p4">**</bpt>(?:<ept id="p4">**</ept> не может содержать пробелы.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The pattern <bpt id="p1">**</bpt>(? :<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> throws an <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept> at run time because the regular expression engine can't parse the pattern, and the pattern <bpt id="p5">**</bpt>(? :<ept id="p5">**</ept><bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept>  fails to match <bpt id="p8">*</bpt>subexpression<ept id="p8">*</ept>.</source>
          <target state="translated">Шаблон <bpt id="p1">**</bpt>(? :<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> вызывает исключение <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept> во время выполнения, так как механизм регулярных выражений не может проанализировать шаблон, а шаблону <bpt id="p5">**</bpt>(? :<ept id="p5">**</ept><bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept> не удается сопоставить <bpt id="p8">*</bpt>subexpression<ept id="p8">*</ept>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The language element <bpt id="p1">**</bpt>\p{<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, which represents a Unicode category or named block, can't include embedded spaces in the <bpt id="p4">**</bpt>\p{<ept id="p4">**</ept> portion of the element.</source>
          <target state="translated">Языковой элемент <bpt id="p1">**</bpt>\p{<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, представляющий категорию Юникода или именованный блок, не может содержать пробелы в части <bpt id="p4">**</bpt>\p{<ept id="p4">**</ept>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>If you do include a white space, the element throws an <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept> at run time.</source>
          <target state="translated">Если все-таки добавить пробел, элемент вызовет исключение <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept> во время выполнения.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</source>
          <target state="translated">Включение этого параметра позволяет упростить регулярные выражения, синтаксический анализ и понимание которых зачастую вызывают затруднения.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>It improves readability, and makes it possible to document a regular expression.</source>
          <target state="translated">Это улучшает читаемость и позволяет документировать регулярное выражение.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The following example defines the following regular expression pattern:</source>
          <target state="translated">В этом примере определяется следующий шаблон регулярного выражения:</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\b \(? ( (?&gt;\w+) ,?\s? )+ [\.!?] \)? # Matches an entire sentence`</ph>.</source>
          <target state="translated"><ph id="ph1">`\b \(? ( (?&gt;\w+) ,?\s? )+ [\.!?] \)? # Matches an entire sentence`</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>This pattern is similar to the pattern defined in the <bpt id="p1">[</bpt>Explicit captures only<ept id="p1">](#explicit-captures-only)</ept> section, except that it uses the <bpt id="p2">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option to ignore pattern white space.</source>
          <target state="translated">Этот шаблон похож на тот, что был определен в разделе <bpt id="p1">[</bpt>Только явные захваты<ept id="p1">](#explicit-captures-only)</ept>, но в нем используется параметр <bpt id="p2">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> для пропуска пробелов в шаблоне.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following example uses the inline option <bpt id="p1">**</bpt>(?x)<ept id="p1">**</ept> to ignore pattern white space.</source>
          <target state="translated">Следующий пример использует встроенный параметр <bpt id="p1">**</bpt>(?x)<ept id="p1">**</ept> для пропуска пробелов.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Right-to-left mode</source>
          <target state="translated">Режим "справа налево"</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine searches from left to right.</source>
          <target state="translated">По умолчанию механизм регулярных выражений выполняет поиска слева направо.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>You can reverse the search direction by using the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option.</source>
          <target state="translated">Направление поиска можно изменить с помощью параметра <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The search automatically begins at the last character position of the string.</source>
          <target state="translated">Поиск автоматически будет начинаться с последнего символа строки.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>For pattern-matching methods that include a starting position parameter, such as <bpt id="p1">[</bpt>Regex.Match(String, Int32)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept>, the starting position is the index of the rightmost character position at which the search is to begin.</source>
          <target state="translated">Для методов сопоставления шаблона с параметром начальной позиции, таких как <bpt id="p1">[</bpt>Regex.Match(String, Int32)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept>, начальная позиция — это индекс самого правого символа, с которого начинается поиск.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Right-to-left pattern mode is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">Чтобы включить режим "справа налево", необходимо передать значение <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> параметру options конструктора класса <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> или статичного метода сопоставления шаблона.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">Этот параметр не может быть указан как встроенный.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</source>
          <target state="translated">Параметр <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> меняет только направление поиска, а не интерпретирует шаблон регулярного выражения справа налево.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\bb\w+\s`</ph> matches words that begin with the letter "b" and are followed by a white-space character.</source>
          <target state="translated">Например, регулярное выражение <ph id="ph1">`\bb\w+\s`</ph> сопоставляет слова, которые начинаются с буквы "b" и за которыми следует пробел.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>In the following example, the input string consists of three words that include one or more "b" characters.</source>
          <target state="translated">В следующем примере входная строка состоит из трех слов, которые содержат одну или несколько букв "b".</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</source>
          <target state="translated">Первое слово начинается с "b", второе заканчивается на "b", а в третьем буква "b" находится в середине слова.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, only the first word matches the regular expression pattern.</source>
          <target state="translated">Как видно из результата примера, только первое слово соответствует шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Also note that the lookahead assertion (the <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element) and the lookbehind assertion (the <bpt id="p4">**</bpt>(?&lt;<ept id="p4">**</ept><ph id="ph2">=</ph><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> language element) do not change direction.</source>
          <target state="translated">Кроме того, обратите внимание, что утверждение просмотра вперед (языковой элемент <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>) и утверждение просмотра назад (языковой элемент <bpt id="p4">**</bpt>(?&lt;<ept id="p4">**</ept><ph id="ph2">=</ph><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept>) не меняют направление поиска.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The lookahead assertions look to the right; the lookbehind assertions look to the left.</source>
          <target state="translated">Утверждения просмотра вперед выполняют поиск вправо, а утверждения просмотра назад — влево.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`(?&lt;=\d{1,2}\s)\w+,?\s\d{4}`</ph> uses the lookbehind assertion to test for a date that precedes a month name.</source>
          <target state="translated">Например, регулярное выражение <ph id="ph1">`(?&lt;=\d{1,2}\s)\w+,?\s\d{4}`</ph> использует утверждения просмотра назад для проверки наличия даты, перед которой идет название месяца.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The regular expression then matches the month and the year.</source>
          <target state="translated">Затем регулярное выражение сопоставляет месяц и год.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>For information on lookahead and lookbehind assertsions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Информацию об утверждениях поиска вперед и назад см. в статье <bpt id="p1">[</bpt>Конструкции группировки в регулярных выражениях<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">Шаблон регулярного выражения определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The beginning of the match must be preceded by one or two decimal digits followed by a space.</source>
          <target state="translated">Слева от начала сопоставления должна идти одна или две десятичных цифры, за которыми следует пробел.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Match zero or one comma characters.</source>
          <target state="translated">Выделяется ноль или один символ запятой.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Соответствует пробелу.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Match four decimal digits.</source>
          <target state="translated">Выделяются 4 десятичные цифры.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>ECMAScript matching behavior</source>
          <target state="translated">Поведение сопоставления ECMAScript</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</source>
          <target state="translated">По умолчанию механизм регулярных выражений использует каноническое поведение при сопоставлении шаблона регулярного выражения с входным текстом.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> option.</source>
          <target state="translated">Но вы можете использовать поведение сопоставления ECMAScript, указав параметр <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>ECMAScript-compliant behavior is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">Чтобы включить поведение ECMAScript, необходимо передать значение <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> параметру options конструктора класса <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> или статичного метода сопоставления шаблона.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">Этот параметр не может быть указан как встроенный.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> option can be combined only with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> and <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> options.</source>
          <target state="translated">Параметр <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> можно использоваться только вместе с параметрами <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> и <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>The use of any other option in a regular expression results in an <bpt id="p1">[</bpt>ArgumentOutOfRangeException<ept id="p1">](xref:System.ArgumentOutOfRangeException)</ept>.</source>
          <target state="translated">При использовании других параметров в регулярном выражении возникает исключение <bpt id="p1">[</bpt>ArgumentOutOfRangeException<ept id="p1">](xref:System.ArgumentOutOfRangeException)</ept>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</source>
          <target state="translated">Поведение регулярных выражений ECMAScript и канонических регулярных выражений отличается в трех аспектах: синтаксис класса символов, ссылающиеся на себя захватываемые группы и интерпретация восьмеричных значений и обратных ссылок.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Character class syntax.</source>
          <target state="translated">Синтаксис класса символов.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</source>
          <target state="translated">Так как канонические регулярные выражения поддерживают Юникод, а ECMAScript — нет, синтаксис классов символов в ECMAScript более ограничен, а некоторые языковые элементы класса символов обладают другим значением.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>For example, ECMAScript does not support language elements such as the Unicode category or block elements <bpt id="p1">*</bpt>\p<ept id="p1">*</ept> and <bpt id="p2">**</bpt>\P<ept id="p2">**</ept>.</source>
          <target state="translated">Например, ECMAScript не поддерживает такие языковые элементы, как категория Юникода или элементы блока <bpt id="p1">*</bpt>\p<ept id="p1">*</ept> и <bpt id="p2">**</bpt>\P<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Similarly, the <bpt id="p1">**</bpt>\w<ept id="p1">**</ept> element, which matches a word character, is equivalent to the <bpt id="p2">**</bpt>[a-zA-Z_0-9]<ept id="p2">**</ept> character class when using ECMAScript and <bpt id="p3">**</bpt>[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]<ept id="p3">**</ept> when using canonical behavior.</source>
          <target state="translated">Аналогичным образом элемент <bpt id="p1">**</bpt>\w<ept id="p1">**</ept>, который сопоставляет словообразующее слово, эквивалентен классу символов <bpt id="p2">**</bpt>[a–zA–Z_0–9]<ept id="p2">**</ept> при использовании ECMAScript и <bpt id="p3">**</bpt>[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]<ept id="p3">**</ept> при использовании канонического поведения.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Character classes in regular expressions<ept id="p1">](classes.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в статье <bpt id="p1">[</bpt>Классы символов в регулярных выражениях<ept id="p1">](classes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between canonical and ECMAScript pattern matching.</source>
          <target state="translated">Следующий пример иллюстрирует разницу между каноническим сопоставлением шаблона и ECMAScript.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>It defines a regular expression, <ph id="ph1">`\b(\w+\s*)+`</ph>, that matches words followed by white-space characters.</source>
          <target state="translated">В нем определяется регулярное выражение, <ph id="ph1">`\b(\w+\s*)+`</ph>, сопоставляющее слова, за которыми следуют пробелы.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</source>
          <target state="translated">Входные данные состоят из двух строк, одна из которых использует латиницу, а другая — кириллицу.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>As the output shows, the call to the <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</source>
          <target state="translated">Как видно из результата, при вызове метода <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>, использующего сопоставление ECMAScript, не удается сопоставить слова на кириллице, а при вызове метода, использующего каноническое сопоставление — удается.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Self-referencing capturing groups.</source>
          <target state="translated">Ссылающиеся на себя захватываемые группы</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>A regular expression capture class with a backreference to itself must be updated with each capture iteration.</source>
          <target state="translated">Класс захвата регулярного выражения с обратной ссылкой на себя необходимо обновлять после каждой итерации выделения.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>As the following example shows, this feature enables the regular expression <ph id="ph1">`((a+)(\1) ?)+`</ph> to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</source>
          <target state="translated">Как показано в следующем примере, это позволяет регулярному выражению <ph id="ph1">`((a+)(\1) ?)+`</ph> сопоставить входную строку " aa aaaa aaaaaa " при использовании ECMAScript, но не канонического сопоставления.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>For more information about string comparisons that are case-sensitive and that use the invariant culture, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](best-practices.md)</ept>.</source>
          <target state="translated">Подробнее о сравнении строк с учетом регистра и использовании инвариантных региональных параметров см. в разделе <bpt id="p1">[</bpt>Рекомендации по использованию строк в .NET<ept id="p1">](best-practices.md)</ept>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Instead of using the case-insensitive comparisons of the current culture, you can specify the <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> option to ignore cultural differences in language and to use the conventions of the invariant culture.</source>
          <target state="translated">Вместо использования сравнений без учета регистра текущих региональных параметров можно указать параметр <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept>, чтобы игнорировать региональные отличия в языке и использовать соглашения инвариантных региональных параметров.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Comparison using the invariant culture is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">Чтобы включить сравнение с использованием инвариантных региональных параметров, необходимо передать значение <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> параметру options конструктора класса <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> или статичного метода сопоставления шаблона.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">Этот параметр не может быть указан как встроенный.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The following example is identical to the previous example, except that the static <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with options that include <bpt id="p2">[</bpt>RegexOptions.CultureInvariant<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept>.</source>
          <target state="translated">Следующий пример идентичен предыдущему, но в нем статичный метод <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> вызывается с параметрами, содержащими <bpt id="p2">[</bpt>RegexOptions.CultureInvariant<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</source>
          <target state="translated">Даже если в качестве региональных параметров выбрано "Турецкий (Турция)", механизм регулярных выражений сможет успешно сопоставить строки "FILE" и "file" и заблокировать доступ к файлу.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">См. также</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Элементы языка регулярных выражений — краткий справочник<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>