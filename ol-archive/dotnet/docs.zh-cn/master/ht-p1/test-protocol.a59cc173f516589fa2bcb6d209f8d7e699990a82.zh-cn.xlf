<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a35385cbb08614493fdcfc74504b00178dc532ea</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tools\test-protocol.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">571f9ba49be9fc4a0d1dd23f2457b2087630460a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc71dad02f1e86873b9019185f14ff3375d92ce9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">.NET Core CLI 测试通信协议</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">.NET Core CLI 测试通信协议</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">.NET Core CLI 测试通信协议</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">介绍</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Anytime you pass a port to dotnet test, the command will run in design time.</source>
          <target state="translated">每次将端口传递给 dotnet 测试时，命令将在设计时运行。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>That means that dotnet test will connect to that port using TCP and will then exchange an established set of messages with whatever else is connected to that port.</source>
          <target state="translated">这意味着 dotnet 测试将使用 TCP 连接到该端口，然后与连接到此端口的其他任何内容交换一组已确定的消息。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When this happens, the runner also receives a new port that dotnet test will use to communicate with it.</source>
          <target state="translated">发生这种情况时，运行程序还会收到 dotnet 测试将用于与其通信的新端口。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The reason why the runner also uses TCP to communicate with dotnet test is because in design mode, it is not sufficient to just output results to the console.</source>
          <target state="translated">运行程序也使用 TCP 与 dotnet 测试通信的原因是因为，在设计模式中，仅将结果输出到控制台是不够的。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The command needs to send the adapter structure messages containing the results of the test execution.</source>
          <target state="translated">命令需要发送包含测试执行结果的适配器结构消息。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Communication protocol at design time.</source>
          <target state="translated">设计时的通信协议。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Because during design time, dotnet test connects to a port when it starts up, the adapter needs to be listening on that port otherwise dotnet test will fail.</source>
          <target state="translated">由于在设计时期间，dotnet 测试在启动时会连接到某个端口，因此适配器需要侦听此端口，否则 dotnet 测试将失败。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>We did it like this so that the adapter could reserve all the ports it needs by binding and listening to them before dotnet test ran and tried to get ports for the runner.</source>
          <target state="translated">这样一来，适配器可通过在 dotnet 测试运行和尝试获取运行程序的端口前绑定和侦听这些端口，保留它所需的所有端口。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Once dotnet test starts, it sends a TestSession.Connected message to the adapter indicating that it is ready to receive messages.</source>
          <target state="translated">dotnet 测试启动后，将向适配器发送 TestSession.Connected 消息，指示它已准备好接收消息。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>It is possible to send an optional <bpt id="p1">[</bpt>version check<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept> message with the adapter version of the protocol in it.</source>
          <target state="translated">可以在发送可选<bpt id="p1">[</bpt>版本检查<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept>消息时，随附协议的适配器版本。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Dotnet test will send back the version of the protocol that it supports.</source>
          <target state="translated">Dotnet 测试将发送回其支持的协议版本。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>All messages have the format described here: <bpt id="p1">[</bpt>Message.cs<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>.</source>
          <target state="translated">所有消息都采用此处所述的格式：<bpt id="p1">[</bpt>Message.cs<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The payload formats for each message is described in links to the classes used to serialize/deserialize the information in the description of the protocol.</source>
          <target state="translated">每条消息的有效负载格式在指向用于序列化/反序列化协议描述中信息的类的链接中有所介绍。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Test Execution</source>
          <target state="translated">测试执行</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Test Execution</source>
          <target state="translated">测试执行</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>After the optional version check, the adapter sends a TestExecution.GetTestRunnerProcessStartInfo, with the <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> it wants to execute inside of it.</source>
          <target state="translated">可选版本检查后，适配器会发送 TestExecution.GetTestRunnerProcessStartInfo，内含适配器希望在其中执行的<bpt id="p1">[</bpt>测试<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept>。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Dotnet test sends back a FileName and Arguments inside a <bpt id="p1">[</bpt>TestStartInfo<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.DotNet.Tools.Test/TestStartInfo.cs)</ept> payload that the adapter can use to start the runner.</source>
          <target state="translated">Dotnet 测试会在适配器可用于启动运行程序的 <bpt id="p1">[</bpt>TestStartInfo<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.DotNet.Tools.Test/TestStartInfo.cs)</ept> 有效负载内发送回文件名和参数。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In the past, we would send the list of tests to run as part of that argument, but we were actually going over the command line size limit for some test projects.</source>
          <target state="translated">过去，我们会发送测试列表作为参数的一部分进行运行，但对某些测试项目来说，我们实际上要超过了命令行大小限制。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>As part of the arguments, we send a port that the runner should connect to and for executing tests, a --wait-command flag, that indicates that the runner should connect to the port and wait for commands, instead of going ahead and executing the tests.</source>
          <target state="translated">作为参数的一部分，我们会发送运行程序应连接的端口，而对于执行测试，会发送一个 --wait-command 标志，指示运行程序应连接到端口并等待命令，而不是继续执行测试。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>At this point, the adapter can launch the runner (and attach to it for debugging if it chooses to).</source>
          <target state="translated">此时，适配器可以启动运行程序（并附加到运行程序进行调试，如果选择这样做的话）。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Once the runner starts, it sends dotnet test a TestRunner.WaitCommand message that indicates it is ready to receive commands, at which point dotnet test sends a TestRunner.Execute with the list of <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> to run.</source>
          <target state="translated">运行程序启动后，会向 dotnet 测试发送 TestRunner.WaitCommand 消息，指示它已准备好接收命令，此时 dotnet 测试会发送 TestRunner.Execute，随附要运行的<bpt id="p1">[</bpt>测试<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept>列表。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This bypasses the command line size limit described above.</source>
          <target state="translated">这将绕过上述的命令行大小限制。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The runner then sends dotnet test (and it passes forward to the adapter) a TestExecution.TestStarted for each tests as they start with the <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> information inside of it.</source>
          <target state="translated">启动时，运行程序会向 dotnet 测试发送用于每个测试的 TestExecution.TestStarted（dotnet 测试再传递到适配器），其中随附<bpt id="p1">[</bpt>测试<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept>信息。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The runner also sends dotnet test (and it forwards to the adapter) a TestExecution.TestResult for each test with the <bpt id="p1">[</bpt>individual result<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept> of the test.</source>
          <target state="translated">运行程序也会向 dotnet 测试发送用于每个测试的 TestExecution.TestResult（dotnet 测试再转发到适配器），随附测试的<bpt id="p1">[</bpt>各个结果<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept>。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>After all tests finish, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestExecution.Completed to the adapter.</source>
          <target state="translated">所有测试完成后，运行程序将向 dotnet 测试发送 TestRunner.Completed 消息，dotnet 测试再将该消息作为 TestExecution.Completed 发送到适配器。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.</source>
          <target state="translated">适配器完成操作后，会向 dotnet 测试发送 TestSession.Terminate，这将关闭 dotnet 测试。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Test discovery</source>
          <target state="translated">测试发现</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Test discovery</source>
          <target state="translated">测试发现</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>After the optional version check, the adapter sends a TestDiscovery.Start message.</source>
          <target state="translated">可选版本检查后，适配器发送 TestDiscovery.Start 消息。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Because in this case, the adapter does not need to attach to the process, dotnet test will start the runner itself.</source>
          <target state="translated">因为在这种情况下，适配器并不需要附加到进程，dotnet 测试将自己启动运行程序。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Also, since there is no long list of arguments to be passed to the runner, no --wait-command flag is needed to be passed to the runner.</source>
          <target state="translated">此外，由于没有要传递到运行程序的参数长列表，因此无需将 --wait-command 标志传递到运行程序。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>dotnet test only passes a --list argument to the runner, which means the runner should not run the tests, just list them.</source>
          <target state="translated">dotnet 测试仅将 --list 参数传递到运行程序，这意味着运行程序不应运行测试，而应仅列出测试。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The runner then sends dotnet test (and it passes forward to the adapter) a TestDiscovery.TestFound for each <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> found.</source>
          <target state="translated">然后，运行程序向 dotnet 测试发送用于每个找到的<bpt id="p1">[</bpt>测试<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept>的 TestDiscovery.TestFound（dotnet 测试再传递到适配器）。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>After all tests are discovered, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestDiscovery.Completed to the adapter.</source>
          <target state="translated">发现所有测试后，运行程序将向 dotnet 测试发送 TestRunner.Completed 消息，dotnet 测试再将该消息作为 TestDiscovery.Completed 发送到适配器。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.</source>
          <target state="translated">适配器完成操作后，会向 dotnet 测试发送 TestSession.Terminate，这将关闭 dotnet 测试。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>