<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fd610bdba56679dd522149d8e91dc91858c7f7ed</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\docker\console.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02fa0bc4ba65f75936d48f81291b670aaf3252bd</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">162574602fe8f99a96301753884af51f1a88574c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Running Console applications in Docker</source>
          <target state="translated">在 Docker 中运行控制台应用程序</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn how to take an existing .NET Framework console application and run it in a Windows Docker container.</source>
          <target state="translated">了解如何利用现有 .NET Framework 控制台应用程序并在 Windows Docker 容器中运行该程序。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, Container, Console, Applications</source>
          <target state="translated">.NET, 容器, 控制台, 应用程序</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Running console applications in Windows containers</source>
          <target state="translated">在 Windows 容器中运行控制台应用程序</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Console applications are used for many purposes; from simple querying of a status to long running document image processing tasks.</source>
          <target state="translated">控制台应用程序具有多种用途；从简单的状态查询到长时间运行的文档图像处理任务。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In any case, the ability to start up and scale these applications are met with limitations of hardware acquisitions, startup times or running multiple instances.</source>
          <target state="translated">在任何情况下，启动和缩放这些应用程序的能力始终在硬件购置、启动时间或运行多个实例方面受限。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Moving your console applications to use Docker and Windows Server containers allows for starting these applications from a clean state, enabling them to perform the operation and then shutdown cleanly.</source>
          <target state="translated">通过移动控制台应用程序以使用 Docker 和 Windows Server 容器，可以从干净状态启动这些应用程序，使其执行操作，然后完全关闭该程序。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This topic will show the steps needed to move a console application to a Windows based container and start it using a PowerShell script.</source>
          <target state="translated">本主题将演示将控制台应用程序移动到基于 Windows 的容器并使用 PowerShell 脚本启动该程序所需的步骤。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The sample console application is a simple example which takes an argument, a question in this case, and returns a random answer.</source>
          <target state="translated">本示例控制台应用程序是一个简单示例，其中具有一个参数、一个此情况下的问题，并返回随机答案。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This could take a <ph id="ph1">`customer_id`</ph> and process their taxes, or create a thumbnail for an <ph id="ph2">`image_url`</ph> argument.</source>
          <target state="translated">这可能需要 <ph id="ph1">`customer_id`</ph> 并处理他们的税款，或创建 <ph id="ph2">`image_url`</ph> 参数的缩略图。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In addition to the answer, the <ph id="ph1">`Environment.MachineName`</ph> has been added to the response to show the difference between running the application locally and in a Windows container.</source>
          <target state="translated">除答案外，已将 <ph id="ph1">`Environment.MachineName`</ph> 添加到响应中，以显示在本地与在 Windows 容器中运行该应用程序的区别。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>When running the application locally, your local machine name should be returned and when running in a Windows Container; the container session id is returned.</source>
          <target state="translated">本地运行应用程序时，会返回本地计算机名称；在 Windows 容器中运行该应用程序时，则会返回容器会话 ID。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The complete example is available in the <bpt id="p1">[</bpt>dotnet/core-docs repository on GitHub<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/framework/docker/ConsoleRandomAnswerGenerator)</ept>.</source>
          <target state="translated">可在 <bpt id="p1">[</bpt>GitHub 上的 dotnet/core-docs 存储库中<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/framework/docker/ConsoleRandomAnswerGenerator)</ept>找到完整示例。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You need to be familiar with some Docker terms before you begin working on moving your application to a container.</source>
          <target state="translated">开始着手将应用程序移动到容器之前，需要熟悉某些 Docker 术语。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>Docker image<ept id="p1">*</ept> is a read-only template that defines the environment for a running container, including the operating system (OS), system components, and application(s).</source>
          <target state="translated">Docker 映像是用于定义运行中容器的环境（包括操作系统 (OS)、系统组件和应用程序）的只读模板。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>One important feature of Docker images is that images are composed from a base image.</source>
          <target state="translated">Docker 映像的一个重要特性是映像由基本映像组合而成。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Each new image adds a small set of features to an existing image.</source>
          <target state="translated">每个新映像均会向现有映像添加小部分功能。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>Docker container<ept id="p1">*</ept> is a running instance of an image.</source>
          <target state="translated">Docker 容器是映像的运行实例。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You scale an application by running the same image in many containers.</source>
          <target state="translated">通过在多个容器中运行同一映像来缩放应用程序。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Conceptually, this is similar to running the same application in multiple hosts.</source>
          <target state="translated">从概念上讲，这类似于在多个主机中运行同一应用程序。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You can learn more about the Docker architecture by reading the <bpt id="p1">[</bpt>Docker Overview<ept id="p1">](https://docs.docker.com/engine/understanding-docker/)</ept> on the Docker site.</source>
          <target state="translated">有关 Docker 体系结构的详细信息，请参阅 Docker 站点上的 <bpt id="p1">[</bpt>Docker 概述<ept id="p1">](https://docs.docker.com/engine/understanding-docker/)</ept>。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Moving your console application is a matter of a few steps.</source>
          <target state="translated">移动控制台应用程序只需几个步骤。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Build the application<ept id="p1">](#building-the-application)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>生成应用程序<ept id="p1">](#building-the-application)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Creating a Dockerfile for the image<ept id="p1">](#creating-the-dockerfile)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>创建映像的 Dockerfile<ept id="p1">](#creating-the-dockerfile)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Process to build and run the Docker container<ept id="p1">](#creating-the-image)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>生成并运行 Docker 容器的过程<ept id="p1">](#creating-the-image)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">先决条件</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Windows containers are supported on <bpt id="p1">[</bpt>Windows 10 Anniversary Update<ept id="p1">](https://www.microsoft.com/en-us/software-download/windows10/)</ept> or <bpt id="p2">[</bpt>Windows Server 2016<ept id="p2">](https://www.microsoft.com/en-us/cloud-platform/windows-server)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Windows 10 周年更新<ept id="p1">](https://www.microsoft.com/en-us/software-download/windows10/)</ept> 或 <bpt id="p2">[</bpt>Windows Server 2016<ept id="p2">](https://www.microsoft.com/en-us/cloud-platform/windows-server)</ept> 支持 Windows 容器。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you are using Windows Server 2016, you must enable containers manually since the Docker for Windows installer will not enable the feature.</source>
          <target state="translated">如果使用 Windows Server 2016，则需手动启用容器，因为 Docker for Windows 安装程序不会启用该功能。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Make sure all updates have run for the OS and then follow the instructions from the <bpt id="p1">[</bpt>Container Host Deployment<ept id="p1">](https://msdn.microsoft.com/en-us/virtualization/windowscontainers/deployment/deployment)</ept> article to install the containers and Docker features.</source>
          <target state="translated">请确保已为操作系统运行所有更新，然后按照<bpt id="p1">[</bpt>容器主机部署<ept id="p1">](https://msdn.microsoft.com/en-us/virtualization/windowscontainers/deployment/deployment)</ept>文章中的说明来安装容器和 Docker 功能。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You need to have Docker for Windows, version 1.12 Beta 26 or higher to support Windows containers.</source>
          <target state="translated">需要安装 Docker for Windows 1.12 Beta 26 版或更高版本才能支持 Windows 容器。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>By default, Docker enables Linux based containers; switch to Windows containers by right clicking the Docker icon in the system tray and select <bpt id="p1">**</bpt>Switch to Windows containers<ept id="p1">**</ept>.</source>
          <target state="translated">默认情况下，Docker 支持将基于 Linux 的容器切换到 Windows 容器，通过右键单击系统托盘中的 Docker 图标，然后选择“切换到 Windows 容器”。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Docker will run the process to change and a restart may be required.</source>
          <target state="translated">Docker 将运行该过程进行更改，且可能需要重启。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Windows-Containers</source>
          <target state="translated">Windows 容器</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Building the application</source>
          <target state="translated">生成应用程序</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Typically console applications are distributed through an installer, FTP, or File Share deployment.</source>
          <target state="translated">通常，通过安装程序、FTP 或文件共享部署分配控制台应用程序。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>When deploying to a container, the assets need to be compiled and staged to a location that can be used when the Docker image is created.</source>
          <target state="translated">部署到容器时，需要编译资产并将其暂存到创建 Docker 映像时可以使用的位置。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In <bpt id="p1">*</bpt>build.ps1<ept id="p1">*</ept>, the script uses <bpt id="p2">[</bpt>MSBuild<ept id="p2">](https://msdn.microsoft.com/en-us/library/dd393574.aspx)</ept> to compile the application to complete the task of building the assets.</source>
          <target state="translated">在 <bpt id="p1">*</bpt>build.ps1<ept id="p1">*</ept> 中，脚本使用 <bpt id="p2">[</bpt>MSBuild<ept id="p2">](https://msdn.microsoft.com/en-us/library/dd393574.aspx)</ept> 编译应用程序以完成生成资产的任务。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>There are a few parameters passed to MSBuild to finalize the needed assets.</source>
          <target state="translated">有几个传递到 MSBuild 来完成所需资产的参数。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The name of the project file or solution to be compiled, the location for the output and finally the configuration (Release or Debug).</source>
          <target state="translated">要编译的项目文件或解决方案的名称、输出位置，最后是配置（版本或调试）。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the call to <ph id="ph1">`Invoke-MSBuild`</ph> the <ph id="ph2">`OutputPath`</ph> is set to <bpt id="p1">**</bpt>publish<ept id="p1">**</ept> and  <ph id="ph3">`Configuration`</ph> set to <bpt id="p2">**</bpt>Release<ept id="p2">**</ept>.</source>
          <target state="translated">在对 <ph id="ph1">`Invoke-MSBuild`</ph> 的调用中，将 <ph id="ph2">`OutputPath`</ph> 设置为 <bpt id="p1">**</bpt>Publish<ept id="p1">**</ept>，<ph id="ph3">`Configuration`</ph> 设置为 <bpt id="p2">**</bpt>Release<ept id="p2">**</ept>。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Creating the Dockerfile</source>
          <target state="translated">创建 Dockerfile</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The base image used for a console .NET Framework application is <ph id="ph1">`microsoft/windowsservercore`</ph>, publicly available on <bpt id="p1">[</bpt>Docker Hub<ept id="p1">](https://hub.docker.com/r/microsoft/windowsservercore/)</ept>.</source>
          <target state="translated">用于控制台 .NET Framework 应用程序的基本映像是 <bpt id="p1">[</bpt>Docker 中心<ept id="p1">](https://hub.docker.com/r/microsoft/windowsservercore/)</ept>上正式推出的 <ph id="ph1">`microsoft/windowsservercore`</ph>。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The base image contains a minimal installation of Windows Server 2016, .NET Framework 4.6.2 and serves as the base OS image for Windows Containers.</source>
          <target state="translated">该基本映像包含 Windows Server 2016、.NET Framework 4.6.2 的最小安装，并充当 Windows 容器的基本 OS 映像。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The first line in the Dockerfile designates the base image using the <bpt id="p1">[</bpt><ph id="ph1">`FROM`</ph><ept id="p1">](https://docs.docker.com/engine/reference/builder/#/from)</ept> instruction.</source>
          <target state="translated">Dockerfile 中的首行使用 <bpt id="p1">[</bpt><ph id="ph1">`FROM`</ph><ept id="p1">](https://docs.docker.com/engine/reference/builder/#/from)</ept> 指令指定基本映像。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Next, <bpt id="p1">[</bpt><ph id="ph1">`ADD`</ph><ept id="p1">](https://docs.docker.com/engine/reference/builder/#/add)</ept> in the file copies the application assets from the <bpt id="p2">**</bpt>publish<ept id="p2">**</ept> folder to root folder of the container and last; setting the <bpt id="p3">[</bpt><ph id="ph2">`ENTRYPOINT`</ph><ept id="p3">](https://docs.docker.com/engine/reference/builder/#/entrypoint)</ept> of the image states that this is the command or application that will run when the container starts.</source>
          <target state="translated">接下来，文件中的 <bpt id="p1">[</bpt><ph id="ph1">`ADD`</ph><ept id="p1">](https://docs.docker.com/engine/reference/builder/#/add)</ept> 将应用程序资产从 <bpt id="p2">**</bpt>publish<ept id="p2">**</ept> 文件夹复制到容器的根文件夹；最后，设置映像的 <bpt id="p3">[</bpt><ph id="ph2">`ENTRYPOINT`</ph><ept id="p3">](https://docs.docker.com/engine/reference/builder/#/entrypoint)</ept>，表明这是将在容器启动时运行的命令或应用程序。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Creating the image</source>
          <target state="translated">创建映像</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>In order to create the Docker image, the following code is added to the <bpt id="p1">*</bpt>build.ps1<ept id="p1">*</ept> script.</source>
          <target state="translated">为创建 Docker 映像，将以下代码添加到 <bpt id="p1">*</bpt>build.ps1<ept id="p1">*</ept> 脚本。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>When the script is run, the <ph id="ph1">`console-random-answer-generator`</ph> image is created using the assets compiled from MSBuild defined in the <bpt id="p1">[</bpt>Building the application<ept id="p1">](#building-the-application)</ept> section.</source>
          <target state="translated">运行脚本时，使用从 MSBuild（在<bpt id="p1">[</bpt>生成应用程序<ept id="p1">](#building-the-application)</ept>部分定义）编译的资产创建 <ph id="ph1">`console-random-answer-generator`</ph> 映像。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Run the script using <ph id="ph1">`.\build.ps1`</ph> from the PowerShell command prompt.</source>
          <target state="translated">使用 PowerShell 命令提示符中的 <ph id="ph1">`.\build.ps1`</ph> 运行该脚本。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>When the build is complete, using the <ph id="ph1">`docker images`</ph> command from a command line or PowerShell prompt; you'll see that the image is created and ready to be run.</source>
          <target state="translated">生成完成后，使用命令行或 PowerShell 提示符中的 <ph id="ph1">`docker images`</ph> 命令，可以看到已创建该映像并可随时运行。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Running the container</source>
          <target state="translated">运行容器</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can start the container from the command line using the Docker commands.</source>
          <target state="translated">可以使用 Docker 命令从命令行启动该容器。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The output is</source>
          <target state="translated">输出为</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If you run the <ph id="ph1">`docker ps -a`</ph> command from PowerShell, you can see that the container still exists.</source>
          <target state="translated">如果从 PowerShell 运行 <ph id="ph1">`docker ps -a`</ph> 命令，则可以看到该容器仍然存在。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The STATUS column shows at "About a minute ago", the application was complete and could be shut down.</source>
          <target state="translated">STATUS 列显示“大约 1 分钟前”，已完成并可关闭该应用程序。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If the command was run a hundred times, there would be a hundred containers left static with no work to do.</source>
          <target state="translated">如果该命令运行了一百次，则会存在一百个无工作的静态容器。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the beginning scenario the ideal operation was to do the work and shutdown or cleanup.</source>
          <target state="translated">开始时，理想操作是完成工作并关闭或清理程序。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>To accomplish that workflow, adding the <ph id="ph1">`--rm`</ph> option to the <ph id="ph2">`docker run`</ph> command will remove the container as soon as the <ph id="ph3">`Exited`</ph> signal is received.</source>
          <target state="translated">若要完成该工作流，将 <ph id="ph1">`--rm`</ph> 选项添加到 <ph id="ph2">`docker run`</ph> 命令会在收到 <ph id="ph3">`Exited`</ph> 信号后立即删除该容器。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Running the command with this option and then looking at the output of <ph id="ph1">`docker ps -a`</ph> command; notice that the container id (the <ph id="ph2">`Environment.MachineName`</ph>) is not in the list.</source>
          <target state="translated">运行带有此选项的命令，然后查看 <ph id="ph1">`docker ps -a`</ph> 命令的输出；请注意，容器 ID (<ph id="ph2">`Environment.MachineName`</ph>) 不在列表中。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Running the container using PowerShell</source>
          <target state="translated">使用 PowerShell 运行容器</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>In the sample project files there is also a <bpt id="p1">*</bpt>run.ps1<ept id="p1">*</ept> which is an example of how to use PowerShell to run the application accepting the arguments.</source>
          <target state="translated">示例项目文件中还包含 <bpt id="p1">*</bpt>run.ps1<ept id="p1">*</ept>，这是如何使用 PowerShell 来运行接受参数的应用程序的示例。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>To run, open PowerShell and use the following command:</source>
          <target state="translated">若要运行，请打开 PowerShell，然后使用以下命令：</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">摘要</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Just by adding a Dockerfile and publishing the application, you can containerize your .NET Framework console applications and now take the advantage of running multiple instances, clean start and stop and more Windows Server 2016 capabilities without making any changes to the application code at all.</source>
          <target state="translated">无需对应用程序代码进行任何更改，只需通过添加 Dockerfile 并发布应用程序，即可容器化 .NET Framework 控制台应用程序、立即利用运行多个实例的优势、洁净启动和停止，以及使用更多 Windows Server 2016 功能。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>