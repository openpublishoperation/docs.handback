<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6aa304f5c4ed400faddd3869006cdd011aa06466</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\grouping.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2017a86039e285c3f7e84539ab1e03b25993ee39</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7faad857c3326bcbf1815b67708e4e9622566dc1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">正则表达式中的分组构造</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">正则表达式中的分组构造</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET、.NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">正则表达式中的分组构造</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</source>
          <target state="translated">分组构造描述了正则表达式的子表达式，用于捕获输入字符串的子字符串。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can use grouping constructs to do the following:</source>
          <target state="translated">你可以使用分组构造来完成下列任务：</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Match a subexpression that is repeated in the input string.</source>
          <target state="translated">匹配输入字符串中重复的子表达式。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Apply a quantifier to a subexpression that has multiple regular expression language elements.</source>
          <target state="translated">将限定符应用于拥有多个正则表达式语言元素的子表达式。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more information about quantifiers, see <bpt id="p1">[</bpt>Quantifiers in regular expressions<ept id="p1">](quantifiers.md)</ept>.</source>
          <target state="translated">有关限定符的更多信息，请参见<bpt id="p1">[</bpt>正则表达式中的限定符<ept id="p1">](quantifiers.md)</ept>。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Include a subexpression in the string that is returned by the <bpt id="p1">[</bpt>Regex.Replace<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> and <bpt id="p2">[</bpt>Match.Result<ept id="p2">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> methods.</source>
          <target state="translated">包括由 <bpt id="p1">[</bpt>Regex.Replace<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> 和 <bpt id="p2">[</bpt>Match.Result<ept id="p2">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> 方法返回的字符串的子表达式。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Retrieve individual subexpressions from the <bpt id="p1">[</bpt>Match.Groups<ept id="p1">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property and process them separately from the matched text as a whole.</source>
          <target state="translated">从 <bpt id="p1">[</bpt>Match.Groups<ept id="p1">](xref:System.Text.RegularExpressions.Match.Groups)</ept> 属性中检索各个子表达式，并分别从匹配的文本作为一个整体处理它们。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following table lists the grouping constructs supported by .NET regular expression engine and indicates whether they are capturing or non-capturing.</source>
          <target state="translated">下表列出了受 .NET 正则表达式引擎支持的分组构造，并指示它们是捕获还是非捕获。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Grouping construct</source>
          <target state="translated">分组构造</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Capturing or noncapturing</source>
          <target state="translated">捕获或非捕获</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Matched subexpressions<ept id="p1">](#matched-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>匹配的子表达式<ept id="p1">](#matched-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">捕获</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Named matched subexpressions<ept id="p1">](#named-matched-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>命名匹配的子表达式<ept id="p1">](#named-matched-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">捕获</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Balancing group definitions<ept id="p1">](#balancing-group-definitions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>平衡组定义<ept id="p1">](#balancing-group-definitions)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">捕获</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Noncapturing groups<ept id="p1">](#noncapturing-groups)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>非捕获组<ept id="p1">](#noncapturing-groups)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非捕获</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Group options<ept id="p1">](#group-options)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>组选项<ept id="p1">](#group-options)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非捕获</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width positive lookahead assertions<ept id="p1">](#zero-width-positive-lookahead-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>零宽度正预测先行断言<ept id="p1">](#zero-width-positive-lookahead-assertions)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非捕获</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width negative lookahead assertions<ept id="p1">](#zero-width-negative-lookahead-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>零宽度负预测先行断言<ept id="p1">](#zero-width-negative-lookahead-assertions)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非捕获</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width positive lookbehind assertions<ept id="p1">](#zero-width-positive-lookbehind-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>零宽度正回顾后发断言<ept id="p1">](#zero-width-positive-lookbehind-assertions)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非捕获</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width negative lookbehind assertions<ept id="p1">](#zero-width-negative-lookbehind-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>零宽度负回顾后发断言<ept id="p1">](#zero-width-negative-lookbehind-assertions)</ept></target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非捕获</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nonbacktracking subexpressions<ept id="p1">](#nonbacktracking-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>非回溯子表达式<ept id="p1">](#nonbacktracking-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非捕获</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For information on groups and the regular expression object model, see <bpt id="p1">[</bpt>Grouping Constructs and Regular Expression Objects<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>.</source>
          <target state="translated">有关组和正则表达式对象模型的信息，请参见<bpt id="p1">[</bpt>分组构造和正则表达式对象<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Matched subexpressions</source>
          <target state="translated">匹配的子表达式</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following grouping construct captures a matched subexpression:</source>
          <target state="translated">以下分组构造捕获匹配的子表达式：</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">其中 subexpression 为任何有效正则表达式模式。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</source>
          <target state="translated">使用括号的捕获按正则表达式中左括号的顺序从一开始从左到右自动编号。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The capture that is numbered zero is the text matched by the entire regular expression pattern.</source>
          <target state="translated">捕获元素编号为零的捕获是由整个正则表达式模式匹配的文本。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>By default, the (subexpression) language element captures the matched subexpression.</source>
          <target state="translated">默认情况下，(subexpression) 语言元素捕获匹配的子表达式。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>But if the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression (see Group options later in this topic), the matched subexpression is not captured.</source>
          <target state="translated">但是，如果正则表达式模式匹配方法的 RegexOptions 参数包含 RegexOptions.ExplicitCapture 标志，或者如果 n 选项应用于此子表达式（参见本主题后面的“组选项”），则不会捕获匹配的子表达式。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can access captured groups in four ways:</source>
          <target state="translated">可以四种方法访问捕获的组：</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>By using the backreference construct within the regular expression.</source>
          <target state="translated">通过使用正则表达式中的反向引用构造。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept>, where <ept id="p1">*</ept>number* is the ordinal number of the captured subexpression.</source>
          <target state="translated">使用语法 <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept> 在同一正则表达式中引用匹配的子表达式，其中 number<ept id="p1">*</ept>* 是捕获的表达式的初始数字。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>By using the named backreference construct within the regular expression.</source>
          <target state="translated">通过使用正则表达式中的命名的反向引用构造。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, where <bpt id="p4">*</bpt>name<ept id="p4">*</ept> is the name of a capturing group, or <bpt id="p5">**</bpt>\k<ept id="p5">**</ept><bpt id="p6">_</bpt>&lt;number<ept id="p6">_</ept><bpt id="p7">**</bpt><ph id="ph2">&gt;</ph><ept id="p7">**</ept>, where <bpt id="p8">*</bpt>number<ept id="p8">*</ept> is the ordinal number of a capturing group.</source>
          <target state="translated">匹配的子表达式在相同的正则表达式中引用，方法是使用语法 <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>，其中 name 是捕获组的名称，或使用 <bpt id="p5">**</bpt>\k<ept id="p5">**</ept><bpt id="p6">_</bpt>&lt;number<ept id="p6">_</ept><bpt id="p7">**</bpt><ph id="ph2">&gt;</ph><ept id="p7">**</ept>，其中 number 是捕获组的初始数字。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A capturing group has a default name that is identical to its ordinal number.</source>
          <target state="translated">捕获组具有与其原始编号相同的默认名称。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For more information, see Grouping constructs and regular expression objects later in this topic.</source>
          <target state="translated">有关更多信息，请参见本主题后面的“分组构造和正则表达式对象”。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> replacement sequence in a <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p5">*</bpt>number<ept id="p5">*</ept> is the ordinal number of the captured subexpression.</source>
          <target state="translated">通过使用 <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> 或 <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> 方法调用中的 <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> 替换序列，其中 number 为捕获的子表达式的序号。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Programmatically, by using the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">以编程方式使用 <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> 属性返回的 <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 对象。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The member at position zero in the collection represents the entire regular expression match.</source>
          <target state="translated">集合中位置零上的成员表示正则表达式匹配。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Each subsequent member represents a matched subexpression.</source>
          <target state="translated">每个后续成员表示匹配的子表达式。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Grouping Constructs and Regular Expression Objects<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept> section.</source>
          <target state="translated">有关更多信息，请参见<bpt id="p1">[</bpt>分组构造和正则表达式对象<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>部分。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that identifies duplicated words in text.</source>
          <target state="translated">以下示例阐释表示文本中重复单词的正则表达式。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</source>
          <target state="translated">正则表达式模式的两个捕获组表示重复的单词的两个实例。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The second instance is captured to report its starting position in the input string.</source>
          <target state="translated">捕获第二个实例，以报告它在输入字符串的起始位置。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is the following:</source>
          <target state="translated">正则表达式模式为：</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">下表演示了如何解释正则表达式模式。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">匹配一个或多个单词字符。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">这是第一个捕获组。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">与空白字符匹配。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Match the string in the first captured group.</source>
          <target state="translated">与第一个捕获组捕获中的字符串匹配。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">这是第二个捕获组。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the <ph id="ph1">`Match.Index`</ph> property.</source>
          <target state="translated">该示例将其指定到捕获组上，以便重复单词的开始位置可从 <ph id="ph1">`Match.Index`</ph> 属性检测。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Match a non-word character, including white space and punctuation.</source>
          <target state="translated">匹配包括空格和标点符号的一个非单词字符。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</source>
          <target state="translated">这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Named matched subexpressions</source>
          <target state="translated">命名匹配的子表达式</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following grouping construct captures a matched subexpression and lets you access it by name or by number:</source>
          <target state="translated">以下分组构造捕获匹配的子表达式，并允许你按名称或编号访问它：</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">或：</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is a valid group name, and <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">其中 name 是有效的组名称，而 subexpression 是任何有效的正则表达式模式。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>name<ept id="p1">*</ept> must not contain any punctuation characters and cannot begin with a number.</source>
          <target state="translated">name 不得包含任何标点符号字符，并且不能以数字开头。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> parameter of a regular expression pattern matching method includes the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> flag, or if the <bpt id="p3">**</bpt>n<ept id="p3">**</ept> option is applied to this subexpression (see <bpt id="p4">[</bpt>Group options<ept id="p4">](#group-options)</ept> later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</source>
          <target state="translated">如果正则表达式模式匹配方法的 <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 参数包含 <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> 标志，或者如果 <bpt id="p3">**</bpt>n<ept id="p3">**</ept> 选项应用于此子表达式（参见本主题后面的<bpt id="p4">[</bpt>组选项<ept id="p4">](#group-options)</ept>），则捕获子表达式的唯一方法就是显式命名捕获组。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can access named captured groups in the following ways:</source>
          <target state="translated">可用以下方式访问已命名的捕获组：</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>By using the named backreference construct within the regular expression.</source>
          <target state="translated">通过使用正则表达式中的命名的反向引用构造。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, where <bpt id="p4">*</bpt>name<ept id="p4">*</ept> is the name of the captured subexpression.</source>
          <target state="translated">使用语法 <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> 在同一正则表达式中引用匹配的子表达式，其中 name 是捕获子表达式的名称。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>By using the backreference construct within the regular expression.</source>
          <target state="translated">通过使用正则表达式中的反向引用构造。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept>, where <ept id="p1">*</ept>number* is the ordinal number of the captured subexpression.</source>
          <target state="translated">使用语法 <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept> 在同一正则表达式中引用匹配的子表达式，其中 number<ept id="p1">*</ept>* 是捕获的表达式的初始数字。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</source>
          <target state="translated">已命名的匹配子表达式在匹配子表达式后从左到右连续编号。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt>${<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> replacement sequence in a <bpt id="p4">[</bpt>Regex.Replace<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p5">[</bpt>Match.Result<ept id="p5">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p6">*</bpt>name<ept id="p6">*</ept> is the name of the captured subexpression.</source>
          <target state="translated">通过使用 <bpt id="p4">[</bpt>Regex.Replace<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> 或 <bpt id="p5">[</bpt>Match.Result<ept id="p5">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> 方法调用中的 <bpt id="p1">**</bpt>${<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> 替换序列，其中 name 为捕获的子表达式的名称。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> replacement sequence in a <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p5">*</bpt>number<ept id="p5">*</ept> is the ordinal number of the captured subexpression.</source>
          <target state="translated">通过使用 <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> 或 <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> 方法调用中的 <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> 替换序列，其中 number 为捕获的子表达式的序号。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Programmatically, by using the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">以编程方式使用 <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> 属性返回的 <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 对象。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The member at position zero in the collection represents the entire regular expression match.</source>
          <target state="translated">集合中位置零上的成员表示正则表达式匹配。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Each subsequent member represents a matched subexpression.</source>
          <target state="translated">每个后续成员表示匹配的子表达式。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Named captured groups are stored in the collection after numbered captured groups.</source>
          <target state="translated">已命名的捕获组在集合中存储在已编号的捕获组后面。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Programmatically, by providing the subexpression name to the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object's indexer  (in C#) or to its Item property (in Visual Basic).</source>
          <target state="translated">以编程方式，通过将子表达式名称提供至 <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 对象的索引器（在 C# 中），或者提供至其 Item 属性（在 Visual Basic 中）。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</source>
          <target state="translated">简单的正则表达式模式会阐释如何编号（未命名），并且可以以编程方式或通过正则表达式语言语法引用已命名的组。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`((?&lt;One&gt;abc)\d+)?(?&lt;Two&gt;xyz)(.*)`</ph> produces the following capturing groups by number and by name.</source>
          <target state="translated">正则表达式 <ph id="ph1">`((?&lt;One&gt;abc)\d+)?(?&lt;Two&gt;xyz)(.*)`</ph> 按编号和名称产生下列捕获组。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The first capturing group (number 0) always refers to the entire pattern.</source>
          <target state="translated">编号为 0 的第一个捕获组总是指整个模式。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">数字</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">名称</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>0 (default name)</source>
          <target state="translated">0（默认名称）</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>1 (default name)</source>
          <target state="translated">1（默认名称）</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>2 (default name)</source>
          <target state="translated">2（默认名称）</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>One</source>
          <target state="translated">一</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Two</source>
          <target state="translated">二</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</source>
          <target state="translated">下面的示例阐释了一个正则表达式，标识出重复的单词和紧随每个重复的单词的单词。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The regular expression pattern defines two named subexpressions: <ph id="ph1">`duplicateWord`</ph>, which represents the duplicated word; and <ph id="ph2">`nextWord`</ph>, which represents the word that follows the duplicated word.</source>
          <target state="translated">正则表达式模式定义了两个命名的子表达式：<ph id="ph1">`duplicateWord`</ph>，它表示重复的单词；和 <ph id="ph2">`nextWord`</ph>，它表示后面跟随重复单词的单词。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is as follows:</source>
          <target state="translated">正则表达式模式按如下方式定义：</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression is interpreted.</source>
          <target state="translated">下表演示了正则表达式的含义。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">匹配一个或多个单词字符。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`duplicateWord`</ph>.</source>
          <target state="translated">命名此捕获组 <ph id="ph1">`duplicateWord`</ph>。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">与空白字符匹配。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Match the string from the captured group that is named <ph id="ph1">`duplicateWord`</ph>.</source>
          <target state="translated">匹配名为 <ph id="ph1">`duplicateWord`</ph> 的捕获的组。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match a non-word character, including white space and punctuation.</source>
          <target state="translated">匹配包括空格和标点符号的一个非单词字符。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</source>
          <target state="translated">这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">匹配一个或多个单词字符。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`nextWord`</ph>.</source>
          <target state="translated">命名此捕获组 <ph id="ph1">`nextWord`</ph>。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Note that a group name can be repeated in a regular expression.</source>
          <target state="translated">请注意可在正则表达式中重复组名。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>For example, it is possible for more than one group to be named <ph id="ph1">`digit`</ph>, as the following example illustrates.</source>
          <target state="translated">例如，可将多个组命名为 <ph id="ph1">`digit`</ph>，如下面的示例所示。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>In the case of duplicate names, the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object is determined by the last successful capture in the input string.</source>
          <target state="translated">在名称重复的情况下，<bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 对象的值由输入字符串中最后一个成功的捕获确定。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>In addition, the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> is populated with information about each capture just as it would be if the group name was not duplicated.</source>
          <target state="translated">此外，如果组名不重复，则使用有关每个捕获的信息填充 <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept>。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression <ph id="ph1">`\D+(?&lt;digit&gt;\d+)\D+(?&lt;digit&gt;\d+)?`</ph> includes two occurrences of a group named <ph id="ph2">`digit`</ph>.</source>
          <target state="translated">在下面的示例中，正则表达式 <ph id="ph1">`\D+(?&lt;digit&gt;\d+)\D+(?&lt;digit&gt;\d+)?`</ph> 中两次出现了名为 <ph id="ph2">`digit`</ph> 的组。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The first <ph id="ph1">`digit`</ph> named group captures one or more digit characters.</source>
          <target state="translated">第一个名为 <ph id="ph1">`digit`</ph> 的组捕获一个或多个数字字符。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The second <ph id="ph1">`digit`</ph> named group captures either zero or one occurrence of one or more digit characters.</source>
          <target state="translated">第二个名为 <ph id="ph1">`digit`</ph> 的组捕获一个或多个数字字符的零个或一个匹配项。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object.</source>
          <target state="translated">如示例的输出所示，如果第二个捕获组成功匹配文本，则文本的值定义 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 对象的值。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object.</source>
          <target state="translated">如果第二个捕获组无法不匹配输入字符串，则最后一个成功匹配的值定义 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 对象的值。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression is interpreted.</source>
          <target state="translated">下表演示了正则表达式的含义。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">说明</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Match one or more non-decimal digit characters.</source>
          <target state="translated">匹配一个或多个非十进制数字字符。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digit characters.</source>
          <target state="translated">匹配一个或多个十进制数字字符。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Assign the match to the <ph id="ph1">`digit`</ph> named group.</source>
          <target state="translated">将匹配分配到 <ph id="ph1">`digit`</ph> 命名组。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Match one or more non-decimal digit characters.</source>
          <target state="translated">匹配一个或多个非十进制数字字符。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of one or more decimal digit characters.</source>
          <target state="translated">匹配一个或多个十进制数字字符的零个或一个匹配项。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Assign the match to the <ph id="ph1">`digit`</ph> named group.</source>
          <target state="translated">将匹配分配到 <ph id="ph1">`digit`</ph> 命名组。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Balancing group definitions</source>
          <target state="translated">平衡组定义</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</source>
          <target state="translated">平衡组定义将删除以前定义的组和存储的定义，并在当前组中存储以前定义的组和当前组之间的间隔。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>This grouping construct has the following format:</source>
          <target state="translated">此分组构造具有以下格式：</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">或：</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> is the current group (optional), <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> is a previously defined group, and <bpt id="p3">*</bpt>subexpression<ept id="p3">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">name1 位置是当前的组（可选），name2 是一个以前定义的组，而 subexpression 是任何有效的正则表达式模式。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The balancing group definition deletes the definition of <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> and stores the interval between <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> and <bpt id="p3">*</bpt>name1<ept id="p3">*</ept> in <bpt id="p4">*</bpt>name1<ept id="p4">*</ept>.</source>
          <target state="translated">平衡组定义删除 name2 的定义并在 name1 中保存 name2 和 name1 之间的间隔。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>If no <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> group is defined, the match backtracks.</source>
          <target state="translated">如果未定义 name2 组，则匹配将回溯。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Because deleting the last definition of <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> reveals the previous definition of <bpt id="p2">*</bpt>name2<ept id="p2">*</ept>, this construct lets you use the stack of captures for group <bpt id="p3">*</bpt>name2<ept id="p3">*</ept> as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</source>
          <target state="translated">由于删除 name2 的最后一个定义会显示 name2 以前的定义，因此该构造允许将 name2 组的捕获堆栈用作计数器，用于跟踪嵌套构造（如括号或者左括号和右括号）。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The balancing group definition uses <bpt id="p1">*</bpt>name2<ept id="p1">*</ept>as a stack.</source>
          <target state="translated">平衡组定义将 name2 作为堆栈使用。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The beginning character of each nested construct is placed in the group and in its <bpt id="p1">[</bpt>Group.Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collection.</source>
          <target state="translated">将每个嵌套构造的开头字符放在组中，并放在其 <bpt id="p1">[</bpt>Group.Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> 集合中。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>When the closing character is matched, its corresponding opening character is removed from the group, and the <bpt id="p1">[</bpt>Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collection is decreased by one.</source>
          <target state="translated">当匹配结束字符时，从组中删除其相应的开始字符，并且 <bpt id="p1">[</bpt>Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> 集合减少 1。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>After the opening and closing characters of all nested constructs have been matched, <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> is empty.</source>
          <target state="translated">所有嵌套构造的开始和结束字符匹配完后，name1 为空。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</source>
          <target state="translated">通过修改下面示例中的正则表达式来使用合适的嵌套构造的开始和结束字符后，你可以用它来处理多数嵌套构造，如数学表达式或包括多个嵌套方法调用的程序代码行。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The following example uses a balancing group definition to match left and right angle brackets (&lt;&gt;) in an input string.</source>
          <target state="translated">下面的示例使用平衡组定义匹配输入字符串中的左右尖括号 (&lt;&gt;)。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The example defines two named groups, <ph id="ph1">`Open`</ph> and <ph id="ph2">`Close`</ph>, that are used like a stack to track matching pairs of angle brackets.</source>
          <target state="translated">该示例定义两个已命名的组，<ph id="ph1">`Open`</ph> 和 <ph id="ph2">`Close`</ph>，用作堆栈来跟踪配对的尖括号。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Each captured left angle bracket is pushed into the capture collection of the <ph id="ph1">`Open`</ph> group, and each captured right angle bracket is pushed into the capture collection of the <ph id="ph2">`Close`</ph> group.</source>
          <target state="translated">将每个已捕获的左尖括号推入到 <ph id="ph1">`Open`</ph> 组的捕获集合，而将每个已捕获的右尖括号推入到 <ph id="ph2">`Close`</ph> 组的捕获集合。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</source>
          <target state="translated">平衡组定义确保每个左尖括号都有一个匹配的右尖角括号。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>If there is not, the final subpattern, <ph id="ph1">`(?(Open)(?!))`</ph>, is evaluated only if the <ph id="ph2">`Open`</ph> group is not empty (and, therefore, if all nested constructs have not been closed).</source>
          <target state="translated">如果没有，则仅会在 <ph id="ph1">`(?(Open)(?!))`</ph> 组不为空的情况下计算最终子模式 <ph id="ph2">`Open`</ph> 的值（因此，如果所有嵌套构造尚未关闭）。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>If the final subpattern is evaluated, the match fails, because the <ph id="ph1">`(?!)`</ph> subpattern is a zero-width negative lookahead assertion that always fails.</source>
          <target state="translated">如果计算了最终子模式的值，则匹配将失败，因为 <ph id="ph1">`(?!)`</ph> 子模式是始终失败的零宽度负预测先行断言。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is:</source>
          <target state="translated">正则表达式模式为：</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The regular expression is interpreted as follows:</source>
          <target state="translated">正则表达式按如下方式解释：</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Begin at the start of the string.</source>
          <target state="translated">从字符串的开头部分开始。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Match zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">匹配零个或多个不是左侧或右侧角度方括号的字符。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Match a left angle bracket and assign it to a group named <ph id="ph1">`Open`</ph>.</source>
          <target state="translated">匹配左尖括号并分配给名为 <ph id="ph1">`Open`</ph> 的组。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Match zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">匹配零个或多个不是左侧或右侧角度方括号的字符。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">匹配跟在非左尖括号或非右尖括号的零个或多个字符后面的一个或多个左尖括号匹配项。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">这是第二个捕获组。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Match a right angle bracket, assign the substring between the <ph id="ph1">`Open`</ph> group and the current group to the <ph id="ph2">`Close`</ph> group, and delete the definition of the <ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">匹配右尖括号，将 <ph id="ph1">`Open`</ph> 组和当前组分配给 <ph id="ph2">`Close`</ph> 组并删除 <ph id="ph3">`Open`</ph> 组的定义。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of any character that is neither a left nor a right angle bracket.</source>
          <target state="translated">匹配非左尖括号或非右尖括号的任何字符的零个或多个匹配项。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</source>
          <target state="translated">匹配跟在零后面或跟在非左尖括号或非右尖括号的多个字符后面的一个或多个右尖括号匹配项。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>When matching the right angle bracket, assign the substring between the <ph id="ph1">`Open`</ph> group and the current group to the <ph id="ph2">`Close`</ph> group, and delete the definition of the<ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">在匹配右尖括号时，将 <ph id="ph1">`Open`</ph> 组和当前组分配给 <ph id="ph2">`Close`</ph> 组并删除 <ph id="ph3">`Open`</ph> 组的定义。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>This is the third capturing group.</source>
          <target state="translated">这是第三个捕获组。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</source>
          <target state="translated">匹配零个或多个下列模式的匹配项：一个或多个左尖括号匹配项，后跟零个或多个非尖括号字符，后跟一个或多个右尖括号的匹配项，后跟零个或多个非尖括号的匹配项。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>When matching the right angle bracket, delete the definition of the <ph id="ph1">`Open`</ph> group, and assign the substring between the <ph id="ph2">`Open`</ph> group and the current group to the <ph id="ph3">`Close`</ph> group.</source>
          <target state="translated">在匹配右尖括号时，删除 <ph id="ph1">`Open`</ph> 组的定义，并将 <ph id="ph2">`Open`</ph> 组和当前组之间的子字符串分配给 <ph id="ph3">`Close`</ph> 组。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">这是第一个捕获组。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Open`</ph> group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</source>
          <target state="translated">如果 <ph id="ph1">`Open`</ph> 组存在，并可以匹配空字符串，则放弃匹配，但不前移字符串中的正则表达式引擎的位置。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>This is a zero-width negative lookahead assertion.</source>
          <target state="translated">这是零宽度负预测先行断言。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Because an empty string is always implicitly present in an input string, this match always fails.</source>
          <target state="translated">因为空字符串总是隐式地存在于输入字符串中，所以此匹配始终失败。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Failure of this match indicates that the angle brackets are not balanced.</source>
          <target state="translated">此匹配的失败表示尖括号不平衡。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Match the end of the input string.</source>
          <target state="translated">匹配输入字符串的末尾部分。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The final subexpression, <ph id="ph1">`(?(Open)(?!))`</ph>, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</source>
          <target state="translated">最终子表达式 <ph id="ph1">`(?(Open)(?!))`</ph>，指示是否正确平衡输入字符串中的嵌套构造（例如，是否每个左尖括号由右键括号匹配）。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>It uses conditional matching based on a valid captured group; for more information, see <bpt id="p1">[</bpt>Alternation constructs in regular expressions<ept id="p1">](alternation.md)</ept>.</source>
          <target state="translated">它使用基于有效捕获组的条件匹配；有关更多信息，请参见<bpt id="p1">[</bpt>正则表达式中的替换构造<ept id="p1">](alternation.md)</ept>。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Open`</ph> group is defined, the regular expression engine attempts to match the subexpression <ph id="ph2">`(?!)`</ph> in the input string.</source>
          <target state="translated">如果定义了 <ph id="ph1">`Open`</ph> 组，则正则表达式引擎会尝试匹配输入字符串中的子表达式 <ph id="ph2">`(?!)`</ph>。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group should be defined only if nesting constructs are unbalanced.</source>
          <target state="translated">仅当嵌套构造不均衡时，才应该定义 <ph id="ph1">`Open`</ph> 组。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</source>
          <target state="translated">因此，要在输入字符串中匹配的模式应该是一个始终导致匹配失败的模式。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In this case, <ph id="ph1">`(?!)`</ph> is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</source>
          <target state="translated">在此情况下，<ph id="ph1">`(?!)`</ph> 是始终失败的零宽度负预测先行断言，因为空字符串总是隐式地存在于输入字符串中的下一个位置。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>In the example, the regular expression engine evaluates the input string "<ph id="ph1">&lt;abc&gt;</ph>&lt;mno<ph id="ph2">&lt;xyz&gt;</ph>&gt;" as shown in the following table.</source>
          <target state="translated">在此示例中，正则表达式引擎评估输入字符串“<ph id="ph1">&lt;abc&gt;</ph>&lt;mno<ph id="ph2">&lt;xyz&gt;</ph>&gt;”，如下表所示。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Step</source>
          <target state="translated">步骤</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">结果</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Starts the match at the beginning of the input string</source>
          <target state="translated">从输入字符串的开头部分开始匹配。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters before the left angle bracket;finds no matches.</source>
          <target state="translated">查找左尖括号之前的非尖括号字符；未找到匹配项。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;abc&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">匹配“<ph id="ph1">&lt;abc&gt;</ph>”中的左尖括号并将它分配给 <ph id="ph2">`Open`</ph> 组。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Matches "abc".</source>
          <target state="translated">与“abc”匹配。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="translated">5</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>"&lt;abc" is the value of the second captured group.</source>
          <target state="translated">“&lt;abc”是第二个捕获组的值。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">输入字符串中的下一个字符不是左尖括号，因此正则表达式引擎不会循环回到 <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>6</source>
          <target state="translated">6</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Matches the right angle bracket in "<ph id="ph1">&lt;abc&gt;</ph>", assigns "abc", which is the substring between the <ph id="ph2">`Open`</ph> group and the right angle bracket, to the <ph id="ph3">`Close`</ph> group, and deletes the current value ("&lt;") of the <ph id="ph4">`Open`</ph> group, leaving it empty.</source>
          <target state="translated">匹配“<ph id="ph1">&lt;abc&gt;</ph>”中的右尖括号，将“abc”（<ph id="ph2">`Open`</ph> 组和右尖括号之间的子字符串）分配给 <ph id="ph3">`Close`</ph> 组并删除 <ph id="ph4">`Open`</ph> 组的当前值（“&lt;”）。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>7</source>
          <target state="translated">7</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters after the right angle bracket; finds no matches.</source>
          <target state="translated">查找右尖括号之后的非尖括号字符；未找到匹配项。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>8</source>
          <target state="translated">8</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">第三个捕获组的值是“&gt;”。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">输入字符串中的下一个字符不是右尖括号，因此正则表达式引擎不会循环回到 <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>9</source>
          <target state="translated">9</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The value of the first captured group is "<ph id="ph1">&lt;abc&gt;</ph>".</source>
          <target state="translated">第一个捕获组的值是“<ph id="ph1">&lt;abc&gt;</ph>”。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The next character in the input string is a left angle bracket, so the regular expression engine loops back to the <ph id="ph1">`(((?'Open'&lt;)`</ph> subpattern.</source>
          <target state="translated">输入字符串中的下一个字符是左尖括号，因此正则表达式引擎会循环回到 <ph id="ph1">`(((?'Open'&lt;)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>10</source>
          <target state="translated">10</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;mno&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">匹配“<ph id="ph1">&lt;mno&gt;</ph>”中的左尖括号并将它分配给 <ph id="ph2">`Open`</ph> 组。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`Group.Captures`</ph> collection now has a single value, "&lt;".</source>
          <target state="translated">其 <ph id="ph1">`Group.Captures`</ph> 集合现在具有单个值“&lt;”。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>11</source>
          <target state="translated">11</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Matches "mno".</source>
          <target state="translated">与“mno”匹配。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>12</source>
          <target state="translated">12</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>"&lt;mno" is the value of the second captured group.</source>
          <target state="translated">“&lt;mno”是第二个捕获组的值。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The next character in the input string is an left angle bracket, so the regular expression engine loops back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">输入字符串中的下一个字符是左尖括号，因此正则表达式引擎会循环回到 <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>13</source>
          <target state="translated">13</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;xyz&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">匹配“<ph id="ph1">&lt;xyz&gt;</ph>”中的左尖括号并将它分配给 <ph id="ph2">`Open`</ph> 组。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Group.Captures`</ph> collection of the <ph id="ph2">`Open`</ph> group now includes two captures: the left angle bracket from "<ph id="ph3">&lt;mno&gt;</ph>", and the left angle bracket from "<ph id="ph4">&lt;xyz&gt;</ph>".</source>
          <target state="translated">
          <ph id="ph1">`Group.Captures`</ph> 组的 <ph id="ph2">`Open`</ph> 集合现在包括两个捕获：“<ph id="ph3">&lt;mno&gt;</ph>”中的左尖括号和“<ph id="ph4">&lt;xyz&gt;</ph>”中的左尖括号。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Matches "xyz".</source>
          <target state="translated">与“xyz”匹配。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>"&lt;xyz" is the value of the second captured group.</source>
          <target state="translated">“&lt;xyz”是第二个捕获组的值。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">输入字符串中的下一个字符不是左尖括号，因此正则表达式引擎不会循环回到 <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Matches the right angle bracket in "<ph id="ph1">&lt;xyz&gt;</ph>".</source>
          <target state="translated">匹配“<ph id="ph1">&lt;xyz&gt;</ph>”中的右尖括号。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>"xyz", assigns the substring between the <ph id="ph1">`Open`</ph> group and the right angle bracket to the <ph id="ph2">`Close`</ph> group, and deletes the current value of the <ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">“xyz”将 <ph id="ph1">`Open`</ph> 组合右尖括号之间的子字符串分配给 <ph id="ph2">`Close`</ph> 组，并删除 <ph id="ph3">`Open`</ph> 组的当前值。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The value of the previous capture (the left angle bracket in "<ph id="ph1">&lt;mno&gt;</ph>") becomes the current value of the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">前一个捕获的值（“<ph id="ph1">&lt;mno&gt;</ph>”中的左尖括号）成为 <ph id="ph2">`Open`</ph> 组的当前值。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Captures`</ph> collection of the <ph id="ph2">`Open`</ph> group now includes a single capture, the left angle bracket from "<ph id="ph3">&lt;xyz&gt;</ph>".</source>
          <target state="translated"><ph id="ph2">`Open`</ph> 组的 <ph id="ph1">`Captures`</ph> 集合现在包括单个捕获，即“<ph id="ph3">&lt;xyz&gt;</ph>”中的左尖括号。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters; finds no matches.</source>
          <target state="translated">查找非尖括号字符；未找到匹配项。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">第三个捕获组的值是“&gt;”。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The next character in the input string is a right angle bracket, so the regular expression engine loops back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">输入字符串中的下一个字符是右尖括号，因此正则表达式引擎会循环回到 <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Matches the final right angle bracket in "xyz&gt;&gt;", assigns "mno<ph id="ph1">&lt;xyz&gt;</ph>" (the substring between the <ph id="ph2">`Open`</ph> group and the right angle bracket) to the <ph id="ph3">`Close`</ph> group, and deletes the current value of the <ph id="ph4">`Open`</ph> group.</source>
          <target state="translated">匹配“xyz&gt;&gt;”中的最后右尖括号，将“mno<ph id="ph1">&lt;xyz&gt;</ph>”（<ph id="ph2">`Open`</ph> 组和右尖括号之间的子字符串）分配给 <ph id="ph3">`Close`</ph> 组并删除 <ph id="ph4">`Open`</ph> 组的当前值。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group is now empty.</source>
          <target state="translated"><ph id="ph1">`Open`</ph> 组现在为空。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>20</source>
          <target state="translated">20</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters; finds no matches.</source>
          <target state="translated">查找非尖括号字符；未找到匹配项。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>21</source>
          <target state="translated">21</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">第三个捕获组的值是“&gt;”。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">输入字符串中的下一个字符不是右尖括号，因此正则表达式引擎不会循环回到 <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>22</source>
          <target state="translated">22</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The value of the first captured group is "&lt;mno<ph id="ph1">&lt;xyz&gt;</ph>&gt;".</source>
          <target state="translated">第一个捕获组的值是“&lt;mno<ph id="ph1">&lt;xyz&gt;</ph>&gt;”。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(((?'Open'&lt;)`</ph> subpattern.</source>
          <target state="translated">输入字符串中的下一个字符不是左尖括号，因此正则表达式引擎不会循环回到 <ph id="ph1">`(((?'Open'&lt;)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>23</source>
          <target state="translated">23</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group is not defined, so no match is attempted.</source>
          <target state="translated"><ph id="ph1">`Open`</ph> 组是未定义的，因此没有尝试匹配。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>24</source>
          <target state="translated">24</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Matches the end of the input string.</source>
          <target state="translated">匹配输入字符串的末尾部分。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Noncapturing groups</source>
          <target state="translated">非捕获组</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The following grouping construct does not capture the substring that is matched by a subexpression:</source>
          <target state="translated">以下分组构造不会捕获由子表达式匹配的子字符串：</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">其中 subexpression 为任何有效正则表达式模式。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</source>
          <target state="translated">当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
          <target state="translated">如果正则表达式包含嵌套的分组构造，则外部非捕获组构造不适用于内部嵌套组构造。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that includes noncapturing groups.</source>
          <target state="translated">下面的示例阐释包括非捕获组的正则表达式。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Note that the output does not include any captured groups.</source>
          <target state="translated">请注意输出不包含任何已捕获的组。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`(?:\b(?:\w+)\W*)+\.`</ph> matches a sentence that is terminated by a period.</source>
          <target state="translated">正则表达式 <ph id="ph1">`(?:\b(?:\w+)\W*)+\.`</ph> 匹配由句号终止的语句。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</source>
          <target state="translated">因为正则表达式重点介绍句子，而不是个别单词，所以分组构造以独占方式用作限定符。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">正则表达式模式可以解释为下表中所示内容。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">在单词边界处开始匹配。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">匹配一个或多个单词字符。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Do not assign the matched text to a captured group.</source>
          <target state="translated">不将匹配的文本分配给捕获的组。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Match zero or more non-word characters.</source>
          <target state="translated">匹配零个或多个非单词字符。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</source>
          <target state="translated">一次或多次匹配跟在零个或多个非单词字符后面以单词边界开头的一个或多个单词字符的模式。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Do not assign the matched text to a captured group.</source>
          <target state="translated">不将匹配的文本分配给捕获的组。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Match a period.</source>
          <target state="translated">匹配句点。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Group options</source>
          <target state="translated">组选项</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The following grouping construct applies or disables the specified options within a subexpression:</source>
          <target state="translated">以下分组构造应用或禁用子表达式中指定的选项：</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">其中 subexpression 为任何有效正则表达式模式。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`(?i-s:)`</ph> turns on case insensitivity and disables single-line mode.</source>
          <target state="translated">例如，<ph id="ph1">`(?i-s:)`</ph> 将打开不区分大小写并禁用单行模式。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>For more information about the inline options you can specify, see <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">有关可以指定的内联选项的更多信息，请参见<bpt id="p1">[</bpt>正则表达式选项<ept id="p1">](options.md)</ept>。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>You can specify options that apply to an entire regular expression rather than a subexpression by using a <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or a static method.</source>
          <target state="translated">可以指定将应用于整个正则表达式，而不是子表达式的选项，方法是使用 <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 类构造函数或静态方法。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>You can also specify inline options that apply after a specific point in a regular expression by using the <ph id="ph1">`(?imnsx-imnsx)`</ph> language construct.</source>
          <target state="translated">也可指定在正则表达式特定点后使用的内联选项，方法是使用 <ph id="ph1">`(?imnsx-imnsx)`</ph> 语言构造。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The group options construct is not a capturing group.</source>
          <target state="translated">组的选项构造并非捕获组。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>That is, although any portion of a string that is captured by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is included in the match, it is not included in a captured group nor used to populate the <bpt id="p2">[</bpt>GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object.</source>
          <target state="translated">即尽管 subexpression捕获的字符串的任意部分包含在匹配中，但不会包含在捕获的组中也不会用于填充 <bpt id="p2">[</bpt>GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 对象。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b(?ix: d \w+)\s `</ph>in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern whitespace in identifying all words that begin with the letter "d".</source>
          <target state="translated">例如，以下示例中的正则表达式 <ph id="ph1">`\b(?ix: d \w+)\s `</ph> 使用分组构造中的内联选项，以启用不区分大小写的匹配和在识别所有以字母“d”开头的单词时忽略模式空白。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>The regular expression is defined as shown in the following table.</source>
          <target state="translated">该正则表达式的定义如下表所示。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">在单词边界处开始匹配。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</source>
          <target state="translated">使用不区分大小写的匹配并忽略此模式中的白色空间，匹配后跟一个或多个单词字符的“d”。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">与空白字符匹配。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookahead assertions</source>
          <target state="translated">零宽度正预测先行断言</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width positive lookahead assertion:</source>
          <target state="translated">以下分组构造定义零宽度正预测先行断言：</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><bpt id="p3">__</bpt>)<ept id="p3">__</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><bpt id="p3">__</bpt>)<ept id="p3">__</ept></target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">其中 subexpression 为任何正则表达式模式。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>For a match to be successful, the input string must match the regular expression pattern in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, although the matched substring is not included in the match result.</source>
          <target state="translated">若要成功匹配，则输入字符串必须匹配 subexpression 中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookahead assertion does not backtrack.</source>
          <target state="translated">零宽度正预测先行断言不会回溯。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</source>
          <target state="translated">通常，零宽度正预测先行断言是在正则表达式模式的末尾找到的。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</source>
          <target state="translated">它定义了一个子字符串，该子字符串必须出现在匹配字符串的末尾但又不能包含在匹配结果中。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>It is also useful for preventing excessive backtracking.</source>
          <target state="translated">还有助于防止过度回溯。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</source>
          <target state="translated">可使用零宽度正预测先行断言来确保特定捕获组以与专为该捕获组定义的模式的子集相匹配的文本开始。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</source>
          <target state="translated">例如，如果捕获组与连续单词字符相匹配，可以使用零宽度正预测先行断言要求第一个字符是按字母顺序排列的大写字符。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</source>
          <target state="translated">下面的示例使用零宽度正预测先行断言，以匹配输入字符串中谓词“is”前的单词。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>The regular expression \b\w+(?=\sis\b) is interpreted as shown in the following table.</source>
          <target state="translated">正则表达式 \b\w+(?=\sis\b) 可以解释为下表中所示内容。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">在单词边界处开始匹配。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">匹配一个或多个单词字符。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</source>
          <target state="translated">确定单词字符是否后接空白字符和字符串“is”，其在单词边界处结束。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>If so, the match is successful.</source>
          <target state="translated">如果如此，则匹配成功。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookahead assertions</source>
          <target state="translated">零宽度负预测先行断言</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width negative lookahead assertion:</source>
          <target state="translated">以下分组构造定义零宽度负预测先行断言：</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">其中 subexpression 为任何正则表达式模式。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For the match to be successful, the input string must not match the regular expression pattern in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, although the matched string is not included in the match result.</source>
          <target state="translated">若要成功匹配，则输入字符串不得匹配 subexpression 中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</source>
          <target state="translated">零宽度负预测先行断言通常用在正则表达式的开头或结尾。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</source>
          <target state="translated">正则表达式的开头可以定义当其定义了要被匹配的相似但更常规的模式时，不应被匹配的特定模式。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>In this case, it is often used to limit backtracking.</source>
          <target state="translated">在这种情况下，它通常用于限制回溯。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
          <target state="translated">正则表达式的末尾可以定义不能出现在匹配项末尾处的子表达式。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</source>
          <target state="translated">下面的示例定义了正则表达式匹配，其在正则表达式的开头使用零宽度预测先行断言，以匹配未以“un”开头的单词。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The regular expression \b(?!un)\w+\b is interpreted as shown in the following table.</source>
          <target state="translated">正则表达式 \b(?!un)\w+\b 可以解释为下表中所示内容。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">在单词边界处开始匹配。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Determine whether the next two characters are "un".</source>
          <target state="translated">确定接下来的两个的字符是否为“un”。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>If they are not, a match is possible.</source>
          <target state="translated">如果没有，则可能匹配。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">匹配一个或多个单词字符。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">在单词边界处结束匹配。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</source>
          <target state="translated">下面的示例定义了正则表达式匹配，其在正则表达式的末尾使用零宽度预测先行断言，以匹配未以标点字符结束的单词。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b\w+\b(?!\p{P})`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">正则表达式 <ph id="ph1">`\b\w+\b(?!\p{P})`</ph> 可以解释为下表中所示内容。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">在单词边界处开始匹配。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">匹配一个或多个单词字符。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">在单词边界处结束匹配。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</source>
          <target state="translated">如果下个字符不是一个标点符号（如句点或逗号），则匹配成功。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions</source>
          <target state="translated">零宽度正回顾后发断言</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width positive lookbehind assertion:</source>
          <target state="translated">以下分组构造定义零宽度正回顾后发断言：</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;=<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;=<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">其中 subexpression 为任何正则表达式模式。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>For a match to be successful, <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> must occur at the input string to the left of the current position, although subexpression is not included in the match result.</source>
          <target state="translated">若要成功匹配，则 subexpression 不得在输入字符串当前位置左侧出现，尽管 subexpression 未包含在匹配结果中。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookbehind assertion does not backtrack.</source>
          <target state="translated">零宽度正回顾后发断言不会回溯。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</source>
          <target state="translated">零宽度正预测后发断言通常在正则表达式的开头使用。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
          <target state="translated">它们定义的模式是一个匹配的前提条件，但它不是匹配结果的一部分。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</source>
          <target state="translated">例如，下面的示例匹配二十一世纪年份的最后两个数字（也就是说，数字“20”要在匹配的字符串之前）。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(?&lt;=\b20)\d{2}\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">正则表达式模式 <ph id="ph1">`(?&lt;=\b20)\d{2}\b`</ph> 的含义如下表所示。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>Match two decimal digits.</source>
          <target state="translated">匹配两个十进制数字。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</source>
          <target state="translated">如果两个十进制数字的字边界以小数位数“20”开头，则继续匹配。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">在单词边界处结束匹配。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</source>
          <target state="translated">零宽度正回顾后发断言还用于在捕获组中的最后一个或多个字符不得为与该捕获组的正则表达式模式相匹配的字符的子集时限制回溯。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</source>
          <target state="translated">例如，如果组捕获所有的连续单词字符，可以使用零宽度正回顾后发断言要求最后一个字符时按字母顺序的。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind assertions</source>
          <target state="translated">零宽度负回顾后发断言</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width negative lookbehind assertion:</source>
          <target state="translated">以下组构造定义零宽度负回顾后发断言：</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">其中 subexpression 为任何正则表达式模式。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>For a match to be successful, <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> must not occur at the input string to the left of the current position.</source>
          <target state="translated">若要成功匹配，则 subexpression 不得在输入字符串当前位置的左侧出现。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>However, any substring that does not match subexpression is not included in the match result.</source>
          <target state="translated">但是，任何不匹配 subexpression 的子字符串不包含在匹配结果中。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</source>
          <target state="translated">零宽度负回顾后发断言通常在正则表达式的开头使用。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>The pattern that they define precludes a match in the string that follows.</source>
          <target state="translated">它们定义的模式预先排除在后面的字符串中的匹配项。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</source>
          <target state="translated">它们还用于在捕获组中的最后一个或多个字符不得为与该捕获组的正则表达式模式相匹配的其中一个或多个字符时限制回溯。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (_).</source>
          <target state="translated">例如，如果如果组捕获了所有的连续单词字符，可以使用零宽度正回顾后发断言要求最后一个字符不是下划线 (_)。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</source>
          <target state="translated">下面的示例匹配除周末之外的一周的任何一天（也就是星期六和星期日都没有）。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(?&lt;!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">正则表达式模式 <ph id="ph1">`(?&lt;!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b`</ph> 的含义如下表所示。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">在单词边界处开始匹配。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a white-space character.</source>
          <target state="translated">匹配一个或多个后跟空白字符的单词字符。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Match either one or two decimal digits followed by a white-space character and a comma.</source>
          <target state="translated">匹配空白字符和逗号后面的一个或两个十进制数字。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Match four decimal digits, and end the match at a word boundary.</source>
          <target state="translated">匹配四个十进制数字并在单词边界处结束匹配。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>`(?&lt;!(Saturday</source>
          <target state="translated">`(?&lt;!(Saturday</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Sunday) )`</source>
          <target state="translated">Sunday) )`</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</source>
          <target state="translated">如果匹配以字符串“星期六”或者“星期日”开头，后跟一个空格，则匹配成功。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpressions</source>
          <target state="translated">非回溯子表达式</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</source>
          <target state="translated">以下分组构造表示非回溯子表达式（也称为一个“贪婪”子表达式）：</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">其中 subexpression 为任何正则表达式模式。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</source>
          <target state="translated">通常，如果正则表达式包含一个可选或可替代匹配模式并且备选不成功的话，正则表达式引擎可以在多个方向上分支以将输入的字符串与某种模式进行匹配。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</source>
          <target state="translated">如果未找到使用第一个分支的匹配项，则正则表达式引擎可以备份或回溯到使用第一个匹配项的点并尝试使用第二个分支的匹配项。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>This process can continue until all branches have been tried.</source>
          <target state="translated">此过程可继续进行，直到尝试所有分支。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language construct disables backtracking.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> 语言构造禁用回溯。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>The regular expression engine will match as many characters in the input string as it can.</source>
          <target state="translated">正则表达式引擎将在输入字符串中匹配尽可能多的字符。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>When no further match is possible, it will not backtrack to attempt alternate pattern matches.</source>
          <target state="translated">在没有任何进一步匹配可用时，它将不回溯以尝试备用模式匹配。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</source>
          <target state="translated">（也就是说，该子表达式仅与可由该子表达式单独匹配的字符串匹配；子表达式不会尝试与基于该子表达式的字符串和任何该子表达式之后的子表达式匹配。）</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>This option is recommended if you know that backtracking will not succeed.</source>
          <target state="translated">如果你知道回溯不会成功，则建议使用此选项。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>Preventing the regular expression engine from performing unnecessary searching improves performance.</source>
          <target state="translated">防止正则表达式引擎执行不需要的搜索可以提高性能。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</source>
          <target state="translated">下面的示例阐释非回溯子表达式如何修改模式匹配的结果。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</source>
          <target state="translated">回溯正则表达式成功匹配一系列重复字符，在字边界上其后为相同字符，但非回溯正则表达式不会匹配。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>The nonbacktracking regular expression <ph id="ph1">`(?&gt;(\w)\1+).\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">非回溯正则表达式 <ph id="ph1">`(?&gt;(\w)\1+).\b`</ph> 的定义如下表所示。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Match a single word character and assign it to the first capturing group.</source>
          <target state="translated">匹配单个单词字符，并将其分配给第一捕获组。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Match the value of the first captured substring one or more times.</source>
          <target state="translated">一次或多次匹配的第一个捕获子字符串的值。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>Match any character.</source>
          <target state="translated">匹配任意字符。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>End the match on a word boundary.</source>
          <target state="translated">在单词边界处结束匹配。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</source>
          <target state="translated">匹配一个重复的单词字符的一个或多个匹配项，但不执行回溯以匹配在单词边界上的最后一个字符。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Grouping constructs and regular expression objects</source>
          <target state="translated">分组构造和正则表达式对象</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Substrings that are matched by a regular expression capturing group are represented by <bpt id="p1">[</bpt>System.Text.RegularExpressions.Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects, which can be retrieved from the <bpt id="p2">[</bpt>System.Text.RegularExpressions.GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object that is returned by the <bpt id="p3">[</bpt>Match.Groups<ept id="p3">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">正则表达式捕获组匹配的子字符串由 <bpt id="p1">[</bpt>System.Text.RegularExpressions.Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 对象表示，该对象可以从 <bpt id="p3">[</bpt>Match.Groups<ept id="p3">](xref:System.Text.RegularExpressions.Match.Groups)</ept> 属性返回的 <bpt id="p2">[</bpt>System.Text.RegularExpressions.GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 对象进行检索。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object is populated as follows:</source>
          <target state="translated">填充 <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 对象，如下所示：</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>The first <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object in the collection (the object at index zero) represents the entire match.</source>
          <target state="translated">集合中的第一个 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 对象（位于索引零的对象）表示整个匹配。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>The next set of <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects represent unnamed (numbered) capturing groups.</source>
          <target state="translated">下一组 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 对象表示未命名（编号）的捕获组。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>They appear in the order in which they are defined in the regular expression, from left to right.</source>
          <target state="translated">它们以在正则表达式中定义的顺序出现，从左至右。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</source>
          <target state="translated">这些组的索引值范围从 1 到集合中未命名捕获组的数目。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>(The index of a particular group is equivalent to its numbered backreference.</source>
          <target state="translated">（特定组索引等效于其带编号的反向引用。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>For more information about backreferences, see <bpt id="p1">[</bpt>Backreference constructs in regular expressions<ept id="p1">](backreference.md)</ept></source>
          <target state="translated">有关反向引用的更多信息，请参见<bpt id="p1">[</bpt>正则表达式中的反向引用构造<ept id="p1">](backreference.md)</ept></target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>The final set of <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects represent named capturing groups.</source>
          <target state="translated">最后的 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 对象组表示命名的捕获组。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>They appear in the order in which they are defined in the regular expression, from left to right.</source>
          <target state="translated">它们以在正则表达式中定义的顺序出现，从左至右。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</source>
          <target state="translated">第一个名为捕获组的索引值是一个大于最后一个未命名的捕获组的索引。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</source>
          <target state="translated">如果正则表达式中没有未命名捕获组，则第一个命名的捕获组的索引值为 1。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>If you apply a quantifier to a capturing group, the corresponding <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object's <bpt id="p2">[</bpt>Capture.Value<ept id="p2">](xref:System.Text.RegularExpressions.Capture.Value)</ept>, <bpt id="p3">[</bpt>Capture.Index<ept id="p3">](xref:System.Text.RegularExpressions.Capture.Index)</ept>, and <bpt id="p4">[</bpt>Capture.Length<ept id="p4">](xref:System.Text.RegularExpressions.Capture.Length)</ept> properties reflect the last substring that is captured by a capturing group.</source>
          <target state="translated">如果将限定符应用于捕获组，则对应的 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 对象的 <bpt id="p2">[</bpt>Capture.Value<ept id="p2">](xref:System.Text.RegularExpressions.Capture.Value)</ept>、<bpt id="p3">[</bpt>Capture.Index<ept id="p3">](xref:System.Text.RegularExpressions.Capture.Index)</ept> 和 <bpt id="p4">[</bpt>Capture.Length<ept id="p4">](xref:System.Text.RegularExpressions.Capture.Length)</ept> 属性反映捕获组捕获的最后一个子字符串。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object that is returned by the <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property.</source>
          <target state="translated">可以检索一整组子字符串，其是按组捕获的并具有来自 <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> 对象的限定符，其由 <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> 属性返回。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>The following example clarifies the relationship between the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> and <bpt id="p2">[</bpt>Capture<ept id="p2">](xref:System.Text.RegularExpressions.Capture)</ept> objects.</source>
          <target state="translated">下面的示例阐释 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 和 <bpt id="p2">[</bpt>Capture<ept id="p2">](xref:System.Text.RegularExpressions.Capture)</ept> 对象之间的关系。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(\w+)\W+)+`</ph> extracts individual words from a string.</source>
          <target state="translated">正则表达式模式 <ph id="ph1">`\b(\w+)\W+)+`</ph> 从字符串提取各个单词。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
          <target state="translated">其定义如下表所示。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">在单词边界处开始匹配。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">匹配一个或多个单词字符。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Together, these characters form a word.</source>
          <target state="translated">这些字符一起构成一个单词。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">这是第二个捕获组。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>Match one or more non-word characters.</source>
          <target state="translated">匹配一个或多个非单词字符。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</source>
          <target state="translated">一次或多次匹配跟在一个或多个非单词字符后面的一个或多个单词字符的模式。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">这是第一个捕获组。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The first capturing group matches each word of the sentence.</source>
          <target state="translated">第一个捕获组匹配句子的每个单词。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>The second capturing group matches each word along with the punctuation and white space that follow the word.</source>
          <target state="translated">第二个捕获组匹配每个单词，连同标点符号和该单词后的空白区域。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object whose index is 2 provides information about the text matched by the second capturing group.</source>
          <target state="translated"><bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 对象的索引是 2，提供了有关由第二个捕获组匹配的文本的信息。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The complete set of words captured by the capturing group are available from the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object returned by the <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property.</source>
          <target state="translated">可从 <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> 对象获取捕获组捕获的整组单词，该对象由 <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> 属性返回。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">另请参阅</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>正则表达式语言 - 快速参考<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking in regular expressions<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>正则表达式中的回溯<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>