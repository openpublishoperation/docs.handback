<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d6fdf23898cacc7ce569f868b3a31b71eff5c716</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\backreference.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6628804140049da2a1904cb6c8399e1d5cba1252</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cac0dac93dabde40c1dcb18f3523884b61422107</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Backreference constructs in regular expressions</source>
          <target state="translated">規則運算式中的反向參考建構</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Backreference constructs in regular expressions</source>
          <target state="translated">規則運算式中的反向參考建構</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Backreference constructs in regular expressions</source>
          <target state="translated">規則運算式中的反向參考建構</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Backreferences provide a convenient way to identify a repeated character or substring within a string.</source>
          <target state="translated">反向參考提供便利的方式來識別字串內的重複字元或子字串。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, if the input string contains multiple occurrences of an arbitrary substring, you can match the first occurrence with a capturing group, and then use a backreference to match subsequent occurrences of the substring.</source>
          <target state="translated">例如，如果輸入字串包含多次出現的任意子字串，您可以比對第一個出現的子字串與擷取的群組，接著使用反向參考來比對隨後出現的子字串。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A separate syntax is used to refer to named and numbered capturing groups in replacement strings.</source>
          <target state="translated">對於取代字串中的具名和編號擷取群組，會使用不同的語法來參考。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Substitutions in regular expressions<ept id="p1">](substitutions.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式中的替代項目<ept id="p1">](substitutions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>.NET defines separate language elements to refer to numbered and named capturing groups.</source>
          <target state="translated">.NET 會定義個別的語言項目，以參考編號和具名擷取群組。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For more information about capturing groups, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">如需擷取群組的詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式中的群組建構<ept id="p1">](grouping.md)</ept>。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Numbered Backreferences</source>
          <target state="translated">編號反向參考</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A numbered backreference uses the following syntax:</source>
          <target state="translated">編號反向參考會使用下列語法：</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><ph id="ph1">*</ph><bpt id="p1">*</bpt><ph id="ph2">\*</ph><ept id="p1">*</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept></source>
          <target state="translated"><ph id="ph1">*</ph><bpt id="p1">*</bpt><ph id="ph2">\*</ph><ept id="p1">*</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>number<ept id="p1">*</ept> is the ordinal position of the capturing group in the regular expression.</source>
          <target state="translated">其中 <bpt id="p1">*</bpt>number<ept id="p1">*</ept> 是規則運算式中的擷取群組序數位置。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`\4`</ph> matches the contents of the fourth capturing group.</source>
          <target state="translated">例如，<ph id="ph1">`\4`</ph> 會比對第四個擷取群組的內容。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>number<ept id="p1">*</ept> is not defined in the regular expression pattern, a parsing error occurs, and the regular expression engine throws an <bpt id="p2">[</bpt>ArgumentException<ept id="p2">](xref:System.ArgumentException)</ept>.</source>
          <target state="translated">如果在規則運算式模式中未定義 <bpt id="p1">*</bpt>number<ept id="p1">*</ept>，便會發生剖析錯誤，而且規則運算式引擎會擲回 <bpt id="p2">[</bpt>ArgumentException<ept id="p2">](xref:System.ArgumentException)</ept>。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b(\w+)\s\1`</ph> is valid, because <ph id="ph2">`(\w+)`</ph> is the first and only capturing group in the expression.</source>
          <target state="translated">例如，規則運算式 <ph id="ph1">`\b(\w+)\s\1`</ph> 有效，因為 <ph id="ph2">`(\w+)`</ph> 是運算式中第一個和唯一的擷取群組。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>On the other hand, <ph id="ph1">`\b(\w+)\s\2`</ph> is invalid and throws an argument exception, because there is no capturing group numbered <ph id="ph2">`\2`</ph>.</source>
          <target state="translated">另一方面，<ph id="ph1">`\b(\w+)\s\2`</ph> 無效並擲回引數例外狀況，因為沒有編號為 <ph id="ph2">`\2`</ph> 的擷取群組。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Note the ambiguity between octal escape codes (such as <ph id="ph1">`\16`</ph>) and *<bpt id="p1">*</bpt><ph id="ph2">\*</ph><ept id="p1">*</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> backreferences that use the same notation.</source>
          <target state="translated">請注意八進位逸出字碼 (例如 <ph id="ph1">`\16`</ph>) 與使用相同標記法之 *<bpt id="p1">*</bpt><ph id="ph2">\*</ph><ept id="p1">*</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept>反向參考間的不明確。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This ambiguity is resolved as follows:</source>
          <target state="translated">這個模棱兩可的情況已解決，如下所示：</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The expressions <ph id="ph1">`\1`</ph> through <ph id="ph2">`\9`</ph> are always interpreted as backreferences, and not as octal codes.</source>
          <target state="translated">運算式 <ph id="ph1">`\1`</ph> 到 <ph id="ph2">`\9`</ph> 一律會解譯為反向參考，而不是八進位字碼。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>If the first digit of a multidigit expression is 8 or 9 (such as <ph id="ph1">`\80`</ph> or <ph id="ph2">`\91`</ph>), the expression as interpreted as a literal.</source>
          <target state="translated">如果多位數運算式的第一個數字是 8 或 9 (例如 <ph id="ph1">`\80`</ph> 或 <ph id="ph2">`\91`</ph>)，該運算式會解譯為常值。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Expressions from <ph id="ph1">`\10`</ph> and greater are considered backreferences if there is a backreference corresponding to that number; otherwise, they are interpreted as octal codes.</source>
          <target state="translated">從 <ph id="ph1">`\10`</ph> 到更大值的運算式會視為反向參考 (如果有對應至該數字的反向參考)，否則會解譯為八進位字碼。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If a regular expression contains a backreference to an undefined group number, a parsing error occurs, and the regular expression engine throws an <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept>.</source>
          <target state="translated">如果規則運算式包含未定義之群組號碼的反向參考，便會發生剖析錯誤，而且規則運算式引擎會擲回 <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept>。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If the ambiguity is a problem, you can use the <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> notation, which is unambiguous and cannot be confused with octal character codes.</source>
          <target state="translated">如果有不明確的問題，您可以使用 <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> 標記法，這樣就不會不明確，而且不會與八進位字元碼混淆。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Similarly, hexadecimal codes such as <ph id="ph1">`\xdd`</ph> are unambiguous and cannot be confused with backreferences.</source>
          <target state="translated">同樣地，十六進位字碼 (例如 <ph id="ph1">`\xdd`</ph>) 不會不明確，而且不會與反向參考混淆。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The following example finds doubled word characters in a string.</source>
          <target state="translated">下列範例會在字串中尋找雙字組字元。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>It defines a regular expression, <ph id="ph1">`(\w)\1,`</ph> which consists of the following elements.</source>
          <target state="translated">它會定義由下列項目組成的規則運算式 <ph id="ph1">`(\w)\1,`</ph>。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Element</source>
          <target state="translated">項目</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Match a word character and assign it to the first capturing group.</source>
          <target state="translated">比對文字字元，並將其指派給第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Match the next character that is the same as the value of the first capturing group.</source>
          <target state="translated">比對與第一個擷取群組之值相同的下一個字元。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Named Backreferences</source>
          <target state="translated">具名反向參考</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A named backreference is defined by using the following syntax:</source>
          <target state="translated">具名反向參考是使用下列語法來定義：</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">或：</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\k'<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>'<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\k'<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>'<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is the name of a capturing group defined in the regular expression pattern.</source>
          <target state="translated">其中 <bpt id="p1">*</bpt>name<ept id="p1">*</ept> 是規則運算式模式中所定義之擷取群組的名稱。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is not defined in the regular expression pattern, a parsing error occurs, and the regular expression engine throws an <bpt id="p2">[</bpt>ArgumentException<ept id="p2">](xref:System.ArgumentException)</ept>.</source>
          <target state="translated">如果在規則運算式模式中未定義 <bpt id="p1">*</bpt>name<ept id="p1">*</ept>，便會發生剖析錯誤，而且規則運算式引擎會擲回 <bpt id="p2">[</bpt>ArgumentException<ept id="p2">](xref:System.ArgumentException)</ept>。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The following example finds doubled word characters in a string.</source>
          <target state="translated">下列範例會在字串中尋找雙字組字元。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>It defines a regular expression, <ph id="ph1">`(?&lt;char&gt;\w)\k&lt;char&gt;`</ph>, which consists of the following elements.</source>
          <target state="translated">它會定義由下列項目組成的規則運算式 <ph id="ph1">`(?&lt;char&gt;\w)\k&lt;char&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Element</source>
          <target state="translated">項目</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Match a word character and assign it to a capturing group named char.</source>
          <target state="translated">比對文字字元，並將其指派給名為 char 的擷取群組。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Match the next character that is the same as the value of the char capturing group.</source>
          <target state="translated">比對與 char 擷取群組之值相同的下一個字元。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Note that <bpt id="p1">*</bpt>name<ept id="p1">*</ept> can also be the string representation of a number.</source>
          <target state="translated">請注意，<bpt id="p1">*</bpt>name<ept id="p1">*</ept> 也可以是數字的字串表示。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For example, the following example uses the regular expression <ph id="ph1">`(?&lt;2&gt;\w)\k&lt;2&gt;`</ph> to find doubled word characters in a string.</source>
          <target state="translated">例如，下列範例會使用規則運算式 <ph id="ph1">`(?&lt;2&gt;\w)\k&lt;2&gt;`</ph> 來尋找字串中的雙字組字元。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>What Backreferences Match</source>
          <target state="translated">反向參考比對的項目</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A backreference refers to the most recent definition of a group (the definition most immediately to the left, when matching left to right).</source>
          <target state="translated">反向參考會參考群組最近使用的定義 (由左至右比對時，最接近左邊的定義)。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>When a group makes multiple captures, a backreference refers to the most recent capture.</source>
          <target state="translated">當群組進行多個擷取時，反向參考會參考最近發生的擷取。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The following example includes a regular expression pattern, <ph id="ph1">`(?&lt;1&gt;a)(?&lt;1&gt;\1b)*`</ph>, which redefines the \1 named group.</source>
          <target state="translated">下列範例包含規則運算式模式 <ph id="ph1">`(?&lt;1&gt;a)(?&lt;1&gt;\1b)*`</ph>，此模式可重新定義 \1 具名群組。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following table describes each pattern in the regular expression.</source>
          <target state="translated">下表說明規則運算式中的每個模式。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Match the character "a" and assign the result to the capturing group named 1.</source>
          <target state="translated">比對字元 "a"，並將結果指派給名為 1 的擷取群組。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Match 0 or 1 occurrence of the group named 1 along with a "b", and assign the result to the capturing group named 1.</source>
          <target state="translated">比對出現 0 或 1 次的群組 1b，並將結果指派給名為 1 的擷取群組。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In comparing the regular expression with the input string ("aababb"), the regular expression engine performs the following operations:</source>
          <target state="translated">在比較規則運算式與輸入字串 ("aababb") 時，規則運算式引擎會執行下列作業：</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>It starts at the beginning of the string, and successfully matches "a" with the expression <ph id="ph1">`(?&lt;1&gt;a)`</ph>.</source>
          <target state="translated">它會從該字串的開頭開始，並且成功地比對 "a" 與運算式 <ph id="ph1">`(?&lt;1&gt;a)`</ph>。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The value of the 1 group is now "a".</source>
          <target state="translated">1 群組的值現在是 "a"。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It advances to the second character, and successfully matches the string "ab" with the expression <ph id="ph1">`\1b`</ph>, or "ab".</source>
          <target state="translated">它會前進到第二個字元，並且成功地比對字串 "ab" 與運算式 <ph id="ph1">`\1b`</ph>，或是 "ab"。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>It then assigns the result, "ab" to <ph id="ph1">`\1`</ph>.</source>
          <target state="translated">然後它會將結果 "ab" 指派給 <ph id="ph1">`\1`</ph>。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>It advances to the fourth character.</source>
          <target state="translated">它會前進到第四個字元。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The expression <ph id="ph1">`(?&lt;1&gt;\1b)`</ph> is to be matched zero or more times, so it successfully matches the string "abb" with the expression <ph id="ph2">`\1b`</ph>.</source>
          <target state="translated">運算式 <ph id="ph1">`(?&lt;1&gt;\1b)`</ph> 要比對零次以上，才算成功地比對字串 "abb" 與運算式 <ph id="ph2">`\1b`</ph>。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>It assigns the result, "abb", back to <ph id="ph1">`\1`</ph>.</source>
          <target state="translated">然後它會將結果 "abb" 指派回到 <ph id="ph1">`\1`</ph>。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In this example, <ph id="ph1">\*</ph> is a looping quantifier -- it is evaluated repeatedly until the regular expression engine cannot match the pattern it defines.</source>
          <target state="translated">在此範例中，<ph id="ph1">\*</ph> 是迴圈數量詞，它會重複評估直到規則運算式引擎無法符合其所定義的模式為止。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Looping quantifiers do not clear group definitions.</source>
          <target state="translated">迴圈數量詞並不會清除群組定義。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>If a group has not captured any substrings, a backreference to that group is undefined and never matches.</source>
          <target state="translated">如果群組沒有擷取任何子字串，該群組的反向參考會是未定義的，而且永遠不會進行比對。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>This is illustrated by the regular expression pattern <ph id="ph1">`\b(\p{Lu}{2})(\d{2})?(\p{Lu}{2})\b,`</ph> which is defined as follows:</source>
          <target state="translated">這由定義如下的規則運算式模式 <ph id="ph1">`\b(\p{Lu}{2})(\d{2})?(\p{Lu}{2})\b,`</ph> 說明：</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Begin the match on a word boundary.</source>
          <target state="translated">開始字邊界比對。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Match two uppercase letters.</source>
          <target state="translated">比對兩個大寫字母。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">這是第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of two decimal digits.</source>
          <target state="translated">比對出現零次或一次的兩個十進位數字。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">這是第二個擷取群組。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Match two uppercase letters.</source>
          <target state="translated">比對兩個大寫字母。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This is the third capturing group.</source>
          <target state="translated">這是第三個擷取群組。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>End the match on a word boundary.</source>
          <target state="translated">結束字邊界比對。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>An input string can match this regular expression even if the two decimal digits that are defined by the second capturing group are not present.</source>
          <target state="translated">輸入字串可以符合這個規則運算式，即使不存在第二個擷取群組所定義的兩個十進位數字亦然。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following example shows that even though the match is successful, an empty capturing group is found between two successful capturing groups.</source>
          <target state="translated">下列範例顯示即使比對成功，仍會在兩個成功的擷取群組之間找到空的擷取群組。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">另請參閱</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>規則運算式語言 - 快速參考<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>