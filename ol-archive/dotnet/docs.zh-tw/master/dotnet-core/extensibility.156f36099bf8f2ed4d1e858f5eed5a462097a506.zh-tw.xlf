<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-4a95368" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7df8b8bd4ae96a344b279a2673906962beaf29a4</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\preview3\tools\extensibility.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b9b9e19d016b2cc173e1211366b205f79fe40af</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b327a2008c99637d8b87e520b68bad5ec4849bf1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model | Microsoft Docs</source>
          <target state="translated">.NET Core CLI 擴充性模型 | Microsoft Docs</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">.NET Core CLI 擴充性模型</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>CLI, extensibility, custom commands, .NET Core</source>
          <target state="translated">CLI, 擴充性, 自訂命令, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model (Tooling Preview 4)</source>
          <target state="translated">.NET Core CLI 擴充性模型 (工具 Preview 4)</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic applies to Visual Studio 2017 RC - .NET Core Tools Preview 4.</source>
          <target state="translated">此主題適用於 Visual Studio 2017 RC - .NET Core 工具 Preview 4。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For the .NET Core Tools Preview 2 version, see the <bpt id="p1">[</bpt>.NET Core CLI extensibility model<ept id="p1">](../../tools/dotnet-test.md)</ept> topic.</source>
          <target state="translated">.NET Core 工具 Preview 2 版本，請參閱 <bpt id="p1">[</bpt>.NET Core CLI 擴充性模型<ept id="p1">](../../tools/dotnet-test.md)</ept>主題。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">概觀</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This document will cover the main ways how to extend the CLI tools and explain the scenarios that drive each of them.</source>
          <target state="translated">本文件將涵蓋如何擴充 CLI 工具的主要方法，並說明驅動所有項目的案例。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>It will the outline how to consume the tools as well as provide short notes on how to build both types of tools.</source>
          <target state="translated">它將會概述如何使用這些工具，以及提供如何建置這兩種工具的簡短附註。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>How to extend CLI tools</source>
          <target state="translated">如何擴充 CLI 工具</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The Preview 4 CLI tools can be extended in three main ways:</source>
          <target state="translated">Preview 4 CLI 工具可以三種主要方式擴充：</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Via NuGet packages on a per-project basis</source>
          <target state="translated">透過個別專案的 NuGet 套件</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Via NuGet packages with custom targets</source>
          <target state="translated">透過具有自訂目標的 NuGet 套件</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Via the system's PATH</source>
          <target state="translated">透過系統的 PATH</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The three extensibility mechanisms outlined above are not exclusive; you can use all or just one or combine them.</source>
          <target state="translated">上述三種擴充機制並不互斥；您可以全部使用、使用其中一個，或者混合使用。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Which one to pick depends largely on what is the goal you are trying to achieve with your extension.</source>
          <target state="translated">選擇哪一個主要取決於您嘗試使用擴充功能達成的目標。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Per-project based extensibility</source>
          <target state="translated">個別專案擴充性</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Per-project tools are <bpt id="p1">[</bpt>framework-dependented deployments<ept id="p1">](../deploying/index.md)</ept> that are distributed as NuGet packages.</source>
          <target state="translated">每個專案的工具都是以 NuGet 套件形式散發的<bpt id="p1">[</bpt>架構相依部署<ept id="p1">](../deploying/index.md)</ept>。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Tools are only available in the context of the project that references them and for which they are restored; invocation outside of the context of the project (for example, outside of the directory that contains the project) will fail as the command will not be able to be found.</source>
          <target state="translated">工具僅適用於參考它們以及還原它們的專案內容；因為將會找不到命令，所以專案內容外部的叫用 (例如，包含專案的目錄外部) 會失敗。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>These tools are perfect for build servers, since nothing outside of the project file is needed.</source>
          <target state="translated">這些工具非常適合做為組建伺服器，因為不需要專案檔以外的任何項目。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The build process runs restore for the project it builds and tools will be available.</source>
          <target state="translated">建置流程會執行所建置專案的還原，並且可以使用這些工具。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Language projects, such as F#, are also in this category; after all, each project can only be written in one specific language.</source>
          <target state="translated">語言專案 (例如 F#) 也在這個分類中；畢竟，每個專案都只能以一種特定語言撰寫。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Finally, this extensibility model provides support for creation of tools that need access to the built output of the project.</source>
          <target state="translated">最後，這個擴充性模型支援建立存取專案的已建置輸出所需的工具。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For instance, various Razor view tools in <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC applications fall into this category.</source>
          <target state="translated">例如，<bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC 應用程式中的各種 Razor 檢視工具都會落入這個分類。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Consuming per-project tools</source>
          <target state="translated">使用個別專案工具</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Consuming these tools requires you to add a <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element for each tool you want to use to your project file.</source>
          <target state="translated">使用這些工具，需要您針對希望用在專案檔的各個工具新增 <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> 元素。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Inside the <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element, you reference the package in which the tool resides and you specify the version you need.</source>
          <target state="translated">在 <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> 元素內部，您會參考工具所在的套件，並指定您需要的版本。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>After running <ph id="ph1">`dotnet restore`</ph>, the tool and its dependencies are restored.</source>
          <target state="translated">執行 <ph id="ph1">`dotnet restore`</ph> 之後，會還原工具和其相依性。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For tools that need to load the build output of the project for execution, there is usually another dependency which is listed under the regular dependencies in the project file.</source>
          <target state="translated">針對需要載入專案建置輸出來執行的工具，通常在專案檔中的一般相依性下方會列出另一個相依性。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Since the Preview 4 version of the CLI uses MSBuild as its build engine, it is recommended that these parts of the tool be written as custom MSBuild targets and tasks since that way they can take part in the overall build process.</source>
          <target state="translated">因為 CLI 的 Preview 4 版本使用 MSBuild 作為其建置引擎，建議您將工具的這些部分撰寫為自訂的 MSBuild 目標與工作，如此一來它們就可以參與整體的建置程序。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Also, they can get any and all data easily that is produced via the build, for example the location of the output files, the current configuration being built etc. All of this information in Preview 4 becomes a set of MSBuild properties that can be read from any target.</source>
          <target state="translated">此外，它們可以輕鬆取得透過建置所產生的任何與全部資料，例如輸出檔的位置、目前正在建置的設定等。Preview 4 中的此資訊全部會變成一組可從任何目標讀取的 MSBuild 屬性。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>We will see how to add a custom target using NuGet later in this document.</source>
          <target state="translated">我們稍後會在此文件中說明如何使用 NuGet 新增自訂目標。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Let's review an example of adding a simple tools-only tool to a simple project.</source>
          <target state="translated">讓我們檢閱在簡單專案中新增僅限簡單工具的工具的範例。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Given an example command called <ph id="ph1">`dotnet-api-search`</ph> that allows you to search through the NuGet packages for the specified API, here is a console application's project file that uses that tool:</source>
          <target state="translated">假設有一個稱為 <ph id="ph1">`dotnet-api-search`</ph> 的範例命令可讓您搜尋 NuGet 套件以尋找指定的 API，則以下是使用該工具的主控台應用程式專案檔：</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element is structured in a similar way as the <ph id="ph2">`&lt;PackageReference&gt;`</ph> element.</source>
          <target state="translated"><ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> 元素會以類似於 <ph id="ph2">`&lt;PackageReference&gt;`</ph> 元素的方式結構化。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>It needs the package ID of the package containing the tool and its version at the very least.</source>
          <target state="translated">它需要最少包含工具和其版本的套件的套件識別項。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Building tools</source>
          <target state="translated">建置工具</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>As mentioned, tools are just portable console applications.</source>
          <target state="translated">如前所述，工具只是可攜式主控台應用程式。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You would build one as you would build any console application.</source>
          <target state="translated">在建置任何主控台應用程式時會建立一個。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>After you build it, you would use <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> command to create a NuGet package (nupkg) that contains your code, information about its dependencies and so on.</source>
          <target state="translated">在您建立它之後，將使用 <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> 命令來建立包含您程式碼、其相依性相關資訊等的 NuGet 套件 (nupkg)。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The package name can be whatever the author wants, but the application inside, the actual tool binary, has to conform to the convention of <ph id="ph1">`dotnet-&lt;command&gt;`</ph> in order for <ph id="ph2">`dotnet`</ph> to be able to invoke it.</source>
          <target state="translated">套件名稱可以是作者想要的任何名稱，但在應用程式內，實際工具二進位檔必須符合 <ph id="ph1">`dotnet-&lt;command&gt;`</ph> 的慣例，<ph id="ph2">`dotnet`</ph> 才能叫用它。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In Preview 4 bits, the <ph id="ph1">`dotnet pack`</ph> command will not pack the <ph id="ph2">`runtimeconfig.json`</ph> file that is needed to run the tool.</source>
          <target state="translated">在 Preview 4 中，<ph id="ph1">`dotnet pack`</ph> 命令不會封裝執行工具所需的 <ph id="ph2">`runtimeconfig.json`</ph> 檔案。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In order to package this file, you have two options:</source>
          <target state="translated">為了封裝這個檔案，您有兩個選項︰</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Create a <ph id="ph1">`nuspec`</ph> file and use <ph id="ph2">`dotnet nuget pack`</ph> command newly available to Preview 4 CLI to include the file</source>
          <target state="translated">建立 <ph id="ph1">`nuspec`</ph> 檔案，並使用 Preview 4 CLI 中新加入的 <ph id="ph2">`dotnet nuget pack`</ph> 命令來包含該檔案</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Use the new <ph id="ph1">`&lt;Content&gt;`</ph> element in an <ph id="ph2">`&lt;ItemGroup&gt;`</ph> in your project file to include the file manually</source>
          <target state="translated">使用您專案檔內 <ph id="ph2">`&lt;ItemGroup&gt;`</ph> 中的新 <ph id="ph1">`&lt;Content&gt;`</ph> 元素來手動包含該檔案</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Working with nuspec files is beyond the scope of this article, however you can find a lot of good information in the <bpt id="p1">[</bpt>official NuGet docs<ept id="p1">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#the-role-and-structure-of-the-nuspec-file)</ept>.</source>
          <target state="translated">使用 nuspec 檔案已超出此文章的範圍，不過您可以在<bpt id="p1">[</bpt>官方 NuGet 文件<ept id="p1">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#the-role-and-structure-of-the-nuspec-file)</ept>中找到許多很棒的資訊。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If you decide on the second approach, you can see the example <ph id="ph1">`csproj`</ph> file and how it is configured below:</source>
          <target state="translated">如果您決定使用第二種方式，您可以查看下方的範例 <ph id="ph1">`csproj`</ph> 檔案，以及設定方式：</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">`&lt;ItemGroup&gt;`</ph> instructs the <ph id="ph2">`dotnet pack`</ph> command to pack any <ph id="ph3">`runtimeconfig.json`</ph> files in the build output directory (designated by the <ph id="ph4">`$(OutputPath)`</ph> variable) and place it into the <ph id="ph5">`lib`</ph> folder for the built target framework.</source>
          <target state="translated">這個 <ph id="ph1">`&lt;ItemGroup&gt;`</ph> 會指示 <ph id="ph2">`dotnet pack`</ph> 命令將任何 <ph id="ph3">`runtimeconfig.json`</ph> 檔案封裝在建置輸出目錄 (由 <ph id="ph4">`$(OutputPath)`</ph> 變數所指定) 中，並將它放入建置目標架構的 <ph id="ph5">`lib`</ph> 資料夾中。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The built target framework is designated similarly to the output path by using a MSBuild property.</source>
          <target state="translated">建置目標架構是使用 MSBuild 屬性，以類似輸出路徑的方式指定。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>After this is set, the resulting tool nupkg file will contain all that is needed for running the tool.</source>
          <target state="translated">設定之後，所產生的工具 nupkg 檔案會包含執行工具所需的所有項目。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Since tools are portable applications, the user consuming the tool has to have the version of the .NET Core libraries that the tool was built against in order to run the tool.</source>
          <target state="translated">因為工具是可攜式應用程式，所以使用工具的使用者必須具有用來建置工具的 .NET Core 程式庫版本，才能執行工具。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Any other dependency that the tool uses and that is not contained within the .NET Core libraries is restored and placed in the NuGet cache.</source>
          <target state="translated">工具所使用以及 .NET Core 程式庫內未包含的任何其他相依性都會進行還原並放到 NuGet 快取中。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The entire tool is, therefore, run using the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache.</source>
          <target state="translated">因此，會使用 .NET Core 程式庫中的組件以及 NuGet 快取中的組件來執行整個工具。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>These kind of tools have a dependency graph that is completely separate from the dependency graph of the project that uses them.</source>
          <target state="translated">這類工具的相依性圖形必須與使用這些工具之專案的相依性圖形完全分開。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The restore process will first restore the project's dependencies, and will then restore each of the tools and their dependencies.</source>
          <target state="translated">還原程序會先還原專案的相依性，接著還原每個工具和其相依性。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can find richer examples and different combinations of this in the <bpt id="p1">[</bpt>.NET Core CLI repo<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.</source>
          <target state="translated">您可以在 <bpt id="p1">[</bpt>.NET Core CLI 存放庫<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>中找到更多範例和這類不同的組合。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You can also see the <bpt id="p1">[</bpt>implementation of tools used<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> in the same repo.</source>
          <target state="translated">您也可以在相同的存放庫中查看<bpt id="p1">[</bpt>所使用工具的實作<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept>。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Custom targets</source>
          <target state="translated">自訂目標</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>NuGet has had the capability to package custom MSBuild target and props files for a while now and you can find the official documentation on this on the <bpt id="p1">[</bpt>NuGet documentation site<ept id="p1">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>.</source>
          <target state="translated">NuGet 現在已具備封裝自訂 MSBuild 目標和 props 檔案的功能，您可以在 <bpt id="p1">[</bpt>NuGet 文件網站<ept id="p1">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>上找到相關的官方文件。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>With the move in the CLI to using MSBuild, the same mechanism of extensibility applies to .NET Core projects.</source>
          <target state="translated">隨著在 CLI 中改為使用 MSBuild，相同的擴充機制也適用於 .NET Core 專案。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You would use this type of extensiblity when you want to extend the build process or when you want to access any of the artifacts in the build process, such as generated files or inspect the configuration under which the build is invoked etc.</source>
          <target state="translated">當您想要擴充建置程序或者想要在建置程序中存取任何構件 (例如產生的檔案或檢查呼叫建置的組態等)，您可以使用這種類型的擴充性。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The sample target's project file is included below for reference.</source>
          <target state="translated">下面包含範例目標的專案檔，以供參考。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>It shows how to use the new <ph id="ph1">`csproj`</ph> syntax for instructing <ph id="ph2">`dotnet pack`</ph> command what to package to place the targets files as well as assemblies into the <ph id="ph3">`build`</ph> folder inside the package.</source>
          <target state="translated">它示範如何使用新的 <ph id="ph1">`csproj`</ph> 語法來指示 <ph id="ph2">`dotnet pack`</ph> 命令要封裝的項目，以將目標檔案以及組件放入套件內的 <ph id="ph3">`build`</ph> 資料夾。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Take note of the <ph id="ph1">`&lt;ItemGroup&gt;`</ph> below that has the <ph id="ph2">`Label`</ph> property set to "dotnet pack instructions".</source>
          <target state="translated">請記錄下面將 <ph id="ph2">`Label`</ph> 屬性設定為「dotnet 組件指示」的 <ph id="ph1">`&lt;ItemGroup&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Consuming custom targets is done by providing a <ph id="ph1">`&lt;PackageReference&gt;`</ph> that points to the package and its version inside the project that is being extended.</source>
          <target state="translated">取用自訂目標的方式是提供 <ph id="ph1">`&lt;PackageReference&gt;`</ph>，它必須指向套件以及其在要擴充之專案中的版本。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Unlike the tools, the custom targets package does get included into the consuming project's dependency closure.</source>
          <target state="translated">與其他工具不同，自訂目標套件會被包含到取用自訂目標之專案的相依性閉包 (Closure) 中。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Using the custom target depends solely on how you configure it.</source>
          <target state="translated">使用自訂目標取決於您的設定方式。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Since it is the usual MSBuild target, it can depend on a given target, run after another target and can also be manually invoked using the <ph id="ph1">`dotnet msbuild /t:&lt;target-name&gt;`</ph> command.</source>
          <target state="translated">因為它是一般的 MSBuild 目標，它可以依存在給定的目標上、在另一個目標之後執行，也可以使用 <ph id="ph1">`dotnet msbuild /t:&lt;target-name&gt;`</ph> 命令手動叫用。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>However, if you wish to provide a better user experience to your users, you can combine per-project tools and custom targets.</source>
          <target state="translated">不過，如果您希望為您的使用者提供更好的使用者體驗，您可以結合每個專案工具和自訂目標。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In this scenario, the per-project tool would essentially just accept whatever needed parameters and would translate that into the required <ph id="ph1">`dotnet msbuild`</ph> invocation that would execute the target.</source>
          <target state="translated">在此案例中，每個專案工具基本上會只接受任何需要的參數，且會將參數轉譯為將執行目標的必要 <ph id="ph1">`dotnet msbuild`</ph> 引動過程。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>You can see a sample of this kind of sinergy on the <bpt id="p1">[</bpt>MVP Summit 2016 Hackathon samples<ept id="p1">](https://github.com/dotnet/MVPSummitHackathon2016)</ept> repo in the <bpt id="p2">[</bpt><ph id="ph1">`dotnet-packer`</ph><ept id="p2">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept> project.</source>
          <target state="translated">您可以在 <bpt id="p2">[</bpt><ph id="ph1">`dotnet-packer`</ph><ept id="p2">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept> 專案中的 <bpt id="p1">[</bpt>MVP Summit 2016 Hackathon 範例<ept id="p1">](https://github.com/dotnet/MVPSummitHackathon2016)</ept>存放庫查看此類型協同作用的範例。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility</source>
          <target state="translated">PATH 擴充性</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more than a single project.</source>
          <target state="translated">PATH 擴充性通常用於開發電腦，而在開發電腦中，您需要有概念上涵蓋多個單一專案的工具。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The main drawback of this extensions mechanism is that it is tied to the machine where the tool exists.</source>
          <target state="translated">這個擴充功能機制的主要缺點是繫結至工具所在的電腦。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If you need it on another machine, you would have to deploy it.</source>
          <target state="translated">如果您需要在另一部電腦上使用它，則必須部署它。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>This pattern of CLI toolset extensibility is very simple.</source>
          <target state="translated">這種模式的 CLI 工具組擴充性十分簡單。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>As covered in the <bpt id="p1">[</bpt>.NET Core CLI overview<ept id="p1">](index.md)</ept>, <ph id="ph1">`dotnet`</ph> driver can run any command that is named after the <ph id="ph2">`dotnet-&lt;command&gt;`</ph> convention.</source>
          <target state="translated">如 <bpt id="p1">[</bpt>.NET Core CLI 概觀<ept id="p1">](index.md)</ept>中所涵蓋，<ph id="ph1">`dotnet`</ph> 驅動程式可以執行任何在 <ph id="ph2">`dotnet-&lt;command&gt;`</ph> 慣例後面命名的命令。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The default resolution logic will first probe several locations and will finally fall to the system PATH.</source>
          <target state="translated">預設解析邏輯會先探查數個位置，最後再轉到系統 PATH。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>If the requested command exists in the system PATH and is a binary that can be invoked, <ph id="ph1">`dotnet`</ph> driver will invoke it.</source>
          <target state="translated">如果要求的命令存在於系統 PATH 中，而且是可叫用的二進位檔，<ph id="ph1">`dotnet`</ph> 驅動程式將會叫用它。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The binary can be pretty much anything that the operating system can execute.</source>
          <target state="translated">二進位檔幾乎是作業系統可以執行的任何項目。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>On Unix systems, this means anything that has the execute bit set via <ph id="ph1">`chmod +x`</ph>.</source>
          <target state="translated">在 Unix 系統上，這表示任何透過 <ph id="ph1">`chmod +x`</ph> 設定執行位元的項目。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>On Windows it means anything that Windows knows how to run.</source>
          <target state="translated">在 Windows 上，這表示 Windows 知道如何執行的任何項目。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>As an example, let's take a look at a very simple implementation of a <ph id="ph1">`dotnet clean`</ph> command.</source>
          <target state="translated">例如，讓我們查看十分簡單的 <ph id="ph1">`dotnet clean`</ph> 命令實作。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>We will use <ph id="ph1">`bash`</ph> to implement this command.</source>
          <target state="translated">我們將使用 <ph id="ph1">`bash`</ph> 來實作這個命令。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The command will simply delete the <ph id="ph1">`bin/`</ph> and <ph id="ph2">`obj/`</ph> directories in the current directory.</source>
          <target state="translated">這個命令只會刪除目前目錄中的 <ph id="ph1">`bin/`</ph> 和 <ph id="ph2">`obj/`</ph> 目錄。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`--lock`</ph> argument is passed to it, it will also delete <ph id="ph2">`project.lock.json`</ph> file.</source>
          <target state="translated">如果將 <ph id="ph1">`--lock`</ph> 引數傳遞給它，則也會刪除 <ph id="ph2">`project.lock.json`</ph> 檔案。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The entirety of the command is given below.</source>
          <target state="translated">這個命令的全部內容如下。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>On macOS, we can save this script as <ph id="ph1">`dotnet-clean`</ph> and set its executable bit with <ph id="ph2">`chmod +x dotnet-clean`</ph>.</source>
          <target state="translated">在 macOS 上，我們可以將這個指令碼儲存為 <ph id="ph1">`dotnet-clean`</ph>，並使用 <ph id="ph2">`chmod +x dotnet-clean`</ph> 設定其可執行位元。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>We can then create a symbolic link to it in <ph id="ph1">`/usr/local/bin`</ph> using the command <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph>.</source>
          <target state="translated">我們接著可以使用 <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph> 命令，以在 <ph id="ph1">`/usr/local/bin`</ph> 中建立其符號連結。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>This will make it possible to invoke the clean command using the <ph id="ph1">`dotnet clean`</ph> syntax.</source>
          <target state="translated">這可能會使用 <ph id="ph1">`dotnet clean`</ph> 語法來叫用 clean 命令。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can test this by creating an app, running <ph id="ph1">`dotnet build`</ph> on it and then running <ph id="ph2">`dotnet clean`</ph>.</source>
          <target state="translated">測試方式是建立應用程式，並在其上執行 <ph id="ph1">`dotnet build`</ph>，然後執行 <ph id="ph2">`dotnet clean`</ph>。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">結論</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The .NET Core CLI tools allow three main extensibility points.</source>
          <target state="translated">.NET Core CLI 工具允許三個主要擴充點。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The per-project tools are contained within the project's context, but they allow easy installation through restoration.</source>
          <target state="translated">個別專案工具都包含在專案內容內，但允許透過還原輕鬆地進行安裝。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Custom targets allow you to easily extend the build process with custom tasks.</source>
          <target state="translated">自訂目標可讓您輕鬆地透過自訂工作擴充建置程序。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>PATH-based tools are good for general, cross-project tools that are usable on a single machine.</source>
          <target state="translated">PATH 工具適用於可在單一電腦上使用的一般跨專案工具。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>