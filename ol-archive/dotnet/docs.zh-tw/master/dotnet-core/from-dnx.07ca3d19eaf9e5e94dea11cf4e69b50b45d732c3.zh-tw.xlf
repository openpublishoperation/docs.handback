<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b5c25fc" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a6f90a43b5f129cd246546f2cc36c4b97c3fb15c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\migration\from-dnx.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">350ee53eb42f71d91a5034ee067d335c3c0951d5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bb09ce27a57b2b0da0acab7b6e684be07e054378</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Migrating from DNX to .NET Core CLI</source>
          <target state="translated">從 DNX 移轉到 .NET Core CLI</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Migrating from DNX to .NET Core CLI</source>
          <target state="translated">從 DNX 移轉到 .NET Core CLI</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Migrating from DNX to .NET Core CLI (project.json)</source>
          <target state="translated">從 DNX 移轉到 .NET Core CLI (project.json)</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">概觀</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The RC1 release of .NET Core and ASP.NET Core 1.0 introduced DNX tooling.</source>
          <target state="translated">.NET Core 的 RC1 版本與 ASP.NET Core 1.0 引進了 DNX 工具。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The RC2 release of .NET Core and ASP.NET Core 1.0 moved from DNX to the .NET Core CLI.</source>
          <target state="translated">.NET Core 的 RC2 版本與 ASP.NET Core 1.0 則從 DNX 進展到了 .NET Core CLI。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>As a slight refresher, let's recap what DNX was about.</source>
          <target state="translated">現在，讓我們稍微複習一下什麼是 DNX。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>DNX was a runtime and a toolset used to build .NET Core and, more specifically, ASP.NET Core 1.0 applications.</source>
          <target state="translated">DNX 是一種執行階段和工具組，可用來建置 .NET Core 和 ASP.NET Core 1.0 應用程式。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It consisted of 3 main pieces:</source>
          <target state="translated">它由 3 個主要部分所組成：</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>DNVM - an install script for obtaining DNX</source>
          <target state="translated">DNVM - 可取得 DNX 的安裝指令碼</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>DNX (Dotnet Execution Runtime) - the runtime that executes your code</source>
          <target state="translated">DNX (Dotnet 執行階段) - 執行程式碼的執行階段</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>DNU (Dotnet Developer Utility) - tooling for managing dependencies, building and publishing your applications</source>
          <target state="translated">DNU (Dotnet 開發人員公用程式) - 可管理相依性、建置並發佈應用程式的工具</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>With the introduction of the CLI, all of the above are now part of a single toolset.</source>
          <target state="translated">現在，引進 CLI 之後，單一工具組即包含上述所有項目。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>However, since DNX was available in RC1 timeframe, you might have projects that were built using it that you would want to move off to the new CLI tooling.</source>
          <target state="translated">不過，由於 DNX 是在 RC1 時間範圍內可供使用，因此您可能會想將使用它所建置的專案移出至新的 CLI 工具。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This migration guide will cover the essentials on how to migrate projects off of DNX and onto .NET Core CLI.</source>
          <target state="translated">本移轉指南說明如何將專案從 DNX 移轉至 .NET Core CLI 的基本資訊。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>If you are just starting a project on .NET Core from scratch, you can freely skip this document.</source>
          <target state="translated">如果您一開始就是從 .NET Core 開始專案，可放心略過這份文件。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Main changes in the tooling</source>
          <target state="translated">工具的主要變更</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>There are some general changes in the tooling that should be outlined first.</source>
          <target state="translated">首先，我們必須先概述這項工具的幾個一般變更。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>No more DNVM</source>
          <target state="translated">不再有 DNVM</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>DNVM, short for <bpt id="p1">*</bpt>DotNet Version Manager<ept id="p1">*</ept> was a bash/PowerShell script used to install a DNX on your machine.</source>
          <target state="translated">DNVM 是「DotNet 版本管理員」的簡稱，其為一種可用來在電腦上安裝 DNX 的 Bash/PowerShell 指令碼。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>It helped users get the DNX they need from the feed they specified (or default ones) as well as mark a certain DNX "active", which would put it on the $PATH for the given session.</source>
          <target state="translated">它可幫助使用者從其指定的摘要 (或預設摘要) 取得所需的 DNX，並將特定 DNX 標示為「作用中」，以將它放在指定工作階段的 $PATH 中。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>This would allow you to use the various tools.</source>
          <target state="translated">這樣一來，您就可以使用各種工具。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>DNVM was discontinued because its feature set was made redundant by changes coming in the .NET Core CLI tools.</source>
          <target state="translated">DNVM 已停用，因為其功能集與 .NET Core CLI 工具引入的變更重複。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The CLI tools come packaged in two main ways:</source>
          <target state="translated">CLI 工具已透過兩種主要方式進行封裝：</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Native installers for a given platform</source>
          <target state="translated">適用於指定平台的原生安裝程式</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Install script for other situations (like CI servers)</source>
          <target state="translated">適用於其他情況的安裝指令碼 (例如 CI 伺服器)</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Given this, the DNVM install features are not needed.</source>
          <target state="translated">基於此，即不需要 DNVM 安裝功能。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>But what about the runtime selection features?</source>
          <target state="translated">那麼執行階段選取功能呢？</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You reference a runtime in your <ph id="ph1">`project.json`</ph> by adding a package of a certain version to your dependencies.</source>
          <target state="translated">您可在相依性中新增特定版本的套件，以參考 <ph id="ph1">`project.json`</ph> 中的執行階段。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>With this change, your application will be able to use the new runtime bits.</source>
          <target state="translated">這項變更可讓您的應用程式使用新的執行階段位元。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Getting these bits to your machine is the same as with the CLI: you install the runtime via one of the native installers it supports or via its install script.</source>
          <target state="translated">若要讓您的電腦具有這些位元，其方式與 CLI 相同︰您可透過執行階段支援的其中一個原生安裝程式，或是執行階段的安裝指令碼，來安裝執行階段。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Different commands</source>
          <target state="translated">不同的命令</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you were using DNX, you used some commands from one of its three parts (DNX, DNU or DNVM).</source>
          <target state="translated">如果您以前使用 DNX，您應該從其中的三個組件之一 (DNX、DNU 或 DNVM) 使用過一些命令。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>With the CLI, some of these commands change, some are not available and some are the same but have slightly different semantics.</source>
          <target state="translated">使用 CLI 時，其中某些命令已變更，某些可能無法使用，某些雖然相同但有稍微不同的語意。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The table below shows the mapping between the DNX/DNU commands and their CLI counterparts.</source>
          <target state="translated">下表顯示 DNX/DNU 命令和 CLI 對應項目之間的對應。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>DNX command</source>
          <target state="translated">DNX 命令</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>CLI command</source>
          <target state="translated">CLI 命令</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>dnx run</source>
          <target state="translated">dnx run</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>dotnet run</source>
          <target state="translated">dotnet run</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Run code from source.</source>
          <target state="translated">從來源執行程式碼。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>dnu build</source>
          <target state="translated">dnu build</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>dotnet build</source>
          <target state="translated">dotnet build</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Build an IL binary of your code.</source>
          <target state="translated">建置您程式碼的 IL 二進位檔。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>dnu pack</source>
          <target state="translated">dnu pack</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>dotnet pack</source>
          <target state="translated">dotnet pack</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Package up a NuGet package of your code.</source>
          <target state="translated">封裝您程式碼的 NuGet 套件。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>dnx <ph id="ph1">\[</ph>command] (for example, "dnx web")</source>
          <target state="translated">dnx <ph id="ph1">\[</ph>command] (例如 "dnx web")</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>N/A<ph id="ph1">\*</ph></source>
          <target state="translated">N/A<ph id="ph1">\*</ph></target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In DNX world, run a command as defined in the project.json.</source>
          <target state="translated">在 DNX 環境中，依據 project.json 的定義來執行命令。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>dnu install</source>
          <target state="translated">dnu install</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>N/A<ph id="ph1">\*</ph></source>
          <target state="translated">N/A<ph id="ph1">\*</ph></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>In the DNX world, install a package as a dependency.</source>
          <target state="translated">在 DNX 環境中，將套件安裝為相依性。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>dnu restore</source>
          <target state="translated">dnu restore</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>dotnet restore</source>
          <target state="translated">dotnet restore</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Restore dependencies specified in your project.json.</source>
          <target state="translated">還原您在 project.json 中指定的相依性。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>dnu publish</source>
          <target state="translated">dnu publish</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>dotnet publish</source>
          <target state="translated">dotnet publish</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Publish your application for deployment in one of the three forms (portable, portable with native and standalone).</source>
          <target state="translated">在可攜式、原生可攜式與獨立式這三種形式中，以其中一種方式來發佈要部署的應用程式。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>dnu wrap</source>
          <target state="translated">dnu wrap</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>N/A<ph id="ph1">\*</ph></source>
          <target state="translated">N/A<ph id="ph1">\*</ph></target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>In DNX world, wrap a project.json in csproj.</source>
          <target state="translated">在 DNX 環境中，將 project.json 包裝在 csproj 中。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>dnu commands</source>
          <target state="translated">dnu 命令</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>N/A<ph id="ph1">\*</ph></source>
          <target state="translated">N/A<ph id="ph1">\*</ph></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>In DNX world, manage the globally installed commands.</source>
          <target state="translated">在 DNX 環境中，管理已全域安裝的命令。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">\*</ph>) - these features are not supported in the CLI by design.</source>
          <target state="translated">(<ph id="ph1">\*</ph>) - CLI 的設計並不支援這些功能。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>DNX features that are not supported</source>
          <target state="translated">不支援的 DNX 功能</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>As the table above shows, there are features from the DNX world that we decided not to support in the CLI, at least for the time being.</source>
          <target state="translated">如上表所示，我們決定 CLI 目前不再支援 DNX 環境的部分功能。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>This section will go through the most important ones and outline the rationale behind not supporting them as well as workarounds if you do need them.</source>
          <target state="translated">本節會探討其中最重要的功能，並簡述不支援的理由，以及在您需要使用這些功能時的因應措施。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Global commands</source>
          <target state="translated">全域命令</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>DNU came with a concept called "global commands".</source>
          <target state="translated">DNU 具有「全域命令」的概念。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>These were, essentially, console applications packaged up as NuGet packages with a shell script that would invoke the DNX you specified to run the application.</source>
          <target state="translated">基本上，這當中包括封裝為 NuGet 套件的主控台應用程式，以及可叫用您指定要執行應用程式之 DNX 的殼層指令碼。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The CLI does not support this concept.</source>
          <target state="translated">CLI 不支援此概念。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>It does, however, support the concept of adding per-project commands that can be invoked using the familiar <ph id="ph1">`dotnet &lt;command&gt;`</ph> syntax.</source>
          <target state="translated">不過，它支援新增個別專案命令的概念；您可使用熟悉的 <ph id="ph1">`dotnet &lt;command&gt;`</ph> 語法叫用這些命令。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>More about this can be found in the <bpt id="p1">[</bpt>extensibility overview<ept id="p1">](../tools/index.md#extensibility)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>擴充性概觀<ept id="p1">](../tools/index.md#extensibility)</ept>。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Installing dependencies</source>
          <target state="translated">安裝相依性</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>As of v1, the .NET Core CLI tools don't have an <ph id="ph1">`install`</ph> command for installing dependencies.</source>
          <target state="translated">截至 v1 為止，.NET Core CLI 工具都沒有可安裝相依性的 <ph id="ph1">`install`</ph> 命令。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>In order to install a package from NuGet, you would need to add it as a dependency to your <ph id="ph1">`project.json`</ph> file and then run <ph id="ph2">`dotnet restore`</ph>.</source>
          <target state="translated">若要從 NuGet 安裝套件，您必須將它以相依性形式新增至 <ph id="ph1">`project.json`</ph> 檔，然後執行 <ph id="ph2">`dotnet restore`</ph>。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Running your code</source>
          <target state="translated">執行您的程式碼</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>There are two main ways to run your code.</source>
          <target state="translated">有以下兩種執行程式碼的主要方式。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>One is from source, with <ph id="ph1">`dotnet run`</ph>.</source>
          <target state="translated">一個是使用 <ph id="ph1">`dotnet run`</ph>，從來源執行。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Unlike <ph id="ph1">`dnx run`</ph>, this will not do any in-memory compilation.</source>
          <target state="translated">不同於 <ph id="ph1">`dnx run`</ph>，這麼做並不會執行任何記憶體中編譯。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>It will actually invoke <ph id="ph1">`dotnet build`</ph> to build your code and then run the built binary.</source>
          <target state="translated">實際上，它會叫用 <ph id="ph1">`dotnet build`</ph> 以建置您的程式碼，然後執行建置的二進位檔。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Another way is using the <ph id="ph1">`dotnet`</ph> itself to run your code.</source>
          <target state="translated">另一個方法是使用 <ph id="ph1">`dotnet`</ph> 本身來執行您的程式碼。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>This is done by providing a path to your assembly: <ph id="ph1">`dotnet path/to/an/assembly.dll`</ph>.</source>
          <target state="translated">此作業是藉由提供組件的路徑來完成：<ph id="ph1">`dotnet path/to/an/assembly.dll`</ph>。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Migrating your DNX project to .NET Core CLI</source>
          <target state="translated">將 DNX 專案移轉至 .NET Core CLI</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>In addition to using new commands when working with your code, there are three major things left in migrating from DNX:</source>
          <target state="translated">處理程式碼時，除了要使用新的命令之外，還有下列三個主要項目要從 DNX 移轉過來：</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Migrate the <ph id="ph1">`global.json`</ph> file if you have it to be able to use CLI.</source>
          <target state="translated">如果您已經可以使用 CLI，請移轉 <ph id="ph1">`global.json`</ph> 檔案。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Migrating the project file (<ph id="ph1">`project.json`</ph>) itself to the CLI tooling.</source>
          <target state="translated">將專案檔 (<ph id="ph1">`project.json`</ph>) 本身移轉至 CLI 工具。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Migrating off of any DNX APIs to their BCL counterparts.</source>
          <target state="translated">將任何 DNX API 移轉至其 BCL 對應項目。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Changing the global.json file</source>
          <target state="translated">變更 global.json 檔案</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`global.json`</ph> file acts like a solution file for both the RC1 and RC2 (or later) projects.</source>
          <target state="translated"><ph id="ph1">`global.json`</ph> 檔案的作用如同 RC1 和 RC2 (或更新版本) 專案的方案檔。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>In order for the CLI tools (as well as Visual Studio) to differentiate between RC1 and later versions, they use the <ph id="ph1">`"sdk": { "version" }`</ph> property to make the distinction which project is RC1 or later.</source>
          <target state="translated">為了讓 CLI 工具 (以及 Visual Studio) 區分 RC1 與更新版本的差異，該工具會使用 <ph id="ph1">`"sdk": { "version" }`</ph> 屬性來區分哪些專案是 RC1 或更新版本。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`global.json`</ph> doesn't have this node at all, it is assumed to be the latest.</source>
          <target state="translated">如果 <ph id="ph1">`global.json`</ph> 完全沒有這個節點，就會假設其為最新版本。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>In order to update the <ph id="ph1">`global.json`</ph> file, either remove the property or set it to the exact version of the tools that you wish to use, in this case <bpt id="p1">**</bpt>1.0.0-preview2-003121<ept id="p1">**</ept>:</source>
          <target state="translated">若要更新 <ph id="ph1">`global.json`</ph> 檔案，可移除該屬性或將它設為您想要使用之工具的正確版本，在此案例中為 <bpt id="p1">**</bpt>1.0.0-preview2-003121<ept id="p1">**</ept>：</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Migrating the project file</source>
          <target state="translated">移轉專案檔</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The CLI and DNX both use the same basic project system based on <ph id="ph1">`project.json`</ph> file.</source>
          <target state="translated">CLI 和 DNX 都使用以 <ph id="ph1">`project.json`</ph> 檔案為基礎的相同基本專案系統。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The syntax and the semantics of the project file are pretty much the same, with small differences based on the scenarios.</source>
          <target state="translated">專案檔語法和語意基本上維持不變，僅有不同案例的小差異。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>There are also some changes to the schema which you can see in the <bpt id="p1">[</bpt>schema file<ept id="p1">](http://json.schemastore.org/project)</ept> or in a more friendly <bpt id="p2">[</bpt>project.json reference<ept id="p2">](../tools/project-json.md)</ept>.</source>
          <target state="translated">結構描述也有一些變更；您可在<bpt id="p1">[</bpt>結構描述檔案<ept id="p1">](http://json.schemastore.org/project)</ept>或更易記的 <bpt id="p2">[</bpt>project.json 參考<ept id="p2">](../tools/project-json.md)</ept>中查看這些變更。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If you are building a console application, you need to add the following snippet to your project file:</source>
          <target state="translated">如果您要建置主控台應用程式，則需要將下列程式碼片段新增至您的專案檔：</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This instructs <ph id="ph1">`dotnet build`</ph> to emit an entry point for your application, effectively making your code runnable.</source>
          <target state="translated">這麼做會指示 <ph id="ph1">`dotnet build`</ph> 針對您的應用程式發出進入點，以讓程式碼可有效執行。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>If you are building a class library, simply omit the above section.</source>
          <target state="translated">如果您要建置類別庫，只要省略上一節即可。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Of course, once you add the above snippet to your <ph id="ph1">`project.json`</ph> file, you need to add a static entry point.</source>
          <target state="translated">當然，一旦將上述程式碼片段新增至 <ph id="ph1">`project.json`</ph> 檔案之後，您必須新增靜態進入點。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>With the move off DNX, the DI services it provided are no longer available and thus this needs to be a basic .NET entry point: <ph id="ph1">`static void Main()`</ph>.</source>
          <target state="translated">移出 DNX 時，它所提供的 DI 服務便無法再使用，因此進入點必須是基本 .NET 進入點：<ph id="ph1">`static void Main()`</ph>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If you have a "commands" section in your <ph id="ph1">`project.json`</ph>, you can remove it.</source>
          <target state="translated">如果您的 <ph id="ph1">`project.json`</ph> 中有「命令」區段，您可以將它移除。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Some of the commands that used to exist as DNU commands, such as Entity Framework CLI commands, are being ported to be per-project extensions to the CLI.</source>
          <target state="translated">如果某些命令原本是以 DNU 命令的形式存在 (例如 Entity Framework CLI 命令)，則這些命令會以每個專案擴充功能的形式移植至 CLI。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If you built your own commands that you are using in your projects, you need to replace them with CLI extensions.</source>
          <target state="translated">如果您要自行建立命令以在專案中使用，則需要將其取代為 CLI 擴充功能。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In this case, the <ph id="ph1">`commands`</ph> node in <ph id="ph2">`project.json`</ph> needs to be replaced by the <ph id="ph3">`tools`</ph> node and it needs to list the tools dependencies as explained in the <bpt id="p1">[</bpt>CLI extensibility section<ept id="p1">](../tools/index.md#extensibility)</ept>.</source>
          <target state="translated">在此情況下，必須將 <ph id="ph2">`project.json`</ph> 中的 <ph id="ph1">`commands`</ph> 節點取代為 <ph id="ph3">`tools`</ph> 節點，而且它必須列出工具相依性 (如 <bpt id="p1">[</bpt>CLI 擴充性區段<ept id="p1">](../tools/index.md#extensibility)</ept>中所述)。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>After these things are done, you need to decide which type of portability you wish for you app.</source>
          <target state="translated">完成這些作業之後，您必須決定應用程式要具備哪種類型的可攜性。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>With .NET Core, we have invested into providing a spectrum of portability options that you can choose from.</source>
          <target state="translated">我們對 .NET Core 所提供的可攜性選項範圍投注不少心力，以供您選擇。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>For instance, you may want to have a fully <bpt id="p1">*</bpt>portable<ept id="p1">*</ept> application or you may want to have a <bpt id="p2">*</bpt>self-contained<ept id="p2">*</ept> application.</source>
          <target state="translated">比方說，您可能需要完全<bpt id="p1">*</bpt>可攜式<ept id="p1">*</ept>的應用程式，或希望擁有<bpt id="p2">*</bpt>獨立<ept id="p2">*</ept>的應用程式。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The portable application option is more like .NET Framework applications work: it needs a shared component to execute it on the target machine (.NET Core).</source>
          <target state="translated">可攜式應用程式選項很像 .NET Framework 應用程式的運作方式：它需要共用元件以在目標電腦 (.NET Core) 上執行。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The self-contained application doesn't require .NET Core to be installed on the target, but you have to produce one application for each OS you wish to support.</source>
          <target state="translated">獨立的應用程式不需要在目標上安裝 .NET Core，但是您必須為每個想要支援的作業系統產生一個應用程式。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>These portability types and more are discussed in the <bpt id="p1"> [</bpt>application portability type<ept id="p1">](../deploying/index.md)</ept> document.</source>
          <target state="translated">bpt id="p1" xmlns="urn:oasis:names:tc:xliff:document:1.2"&gt; [&lt;/bpt&gt;應用程式可攜性類型<ept id="p1">](../deploying/index.md)</ept>文件中會說明這些可攜性類型等相關資訊。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Once you make a call on what type of portability you want, you need to change your targeted framework(s).</source>
          <target state="translated">一旦您決定要使用何種可攜性類型時，即需要變更目標架構。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>If you were writing applications for .NET Core, you were most likely using <ph id="ph1">`dnxcore50`</ph> as  your targeted framework.</source>
          <target state="translated">如果您撰寫過 .NET Core 的應用程式，您很可能會使用 <ph id="ph1">`dnxcore50`</ph> 做為目標架構。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>With the CLI and the changes that the new <bpt id="p1">[</bpt>.NET Standard Library<ept id="p1">](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md)</ept> brought, the framework needs to be one of the following:</source>
          <target state="translated">若要使用 CLI 以及新 <bpt id="p1">[</bpt>.NET 標準程式庫<ept id="p1">](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md)</ept>帶來的變更 ，架構必須是下列其中之一：</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`netcoreapp1.0`</ph> - if you are writing applications on .NET Core (including ASP.NET Core applications)</source>
          <target state="translated"><ph id="ph1">`netcoreapp1.0`</ph>- 如果您要撰寫的應用程式在 .NET Core (包括 ASP.NET Core 應用程式) 上</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`netstandard1.6`</ph> - if you are writing class libraries for .NET Core</source>
          <target state="translated"><ph id="ph1">`netstandard1.6`</ph>- 如果您要撰寫 .NET Core 的類別庫</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If you are using other <ph id="ph1">`dnx`</ph> targets, like <ph id="ph2">`dnx451`</ph> you will need to change those as well.</source>
          <target state="translated">如果您使用其他 <ph id="ph1">`dnx`</ph> 目標 (例如 <ph id="ph2">`dnx451`</ph>)，也必須變更這些項目。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dnx451`</ph> should be changed to <ph id="ph2">`net451`</ph>.</source>
          <target state="translated"><ph id="ph2">`net451`</ph>應變更為 <ph id="ph1">`dnx451`</ph>。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Please refer to the <bpt id="p1">[</bpt>.NET Standard Library document<ept id="p1">](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md)</ept> for more information.</source>
          <target state="translated">如需詳細資訊，請參閱 <bpt id="p1">[</bpt>.NET 標準程式庫文件<ept id="p1">](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md)</ept>。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Your <ph id="ph1">`project.json`</ph> is now mostly ready.</source>
          <target state="translated">您的 <ph id="ph1">`project.json`</ph> 現已大致就緒。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>You need to go through your dependencies list and update the dependencies to their newer versions, especially if you are using ASP.NET Core dependencies.</source>
          <target state="translated">接著，您必須檢查相依性清單，並將相依性更新為較新版本；如果您是使用 ASP.NET Core 相依性的話，更應注意這項作業。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>If you were using separate packages for BCL APIs, you can use the runtime package as explained in the <bpt id="p1">[</bpt>application portability type<ept id="p1">](../deploying/index.md)</ept> document.</source>
          <target state="translated">如果您之前針對 BCL API 使用不同的套件，則可以使用<bpt id="p1">[</bpt>應用程式可攜性類型<ept id="p1">](../deploying/index.md)</ept>文件中所述的執行階段套件。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Once you are ready, you can try restoring with <ph id="ph1">`dotnet restore`</ph>.</source>
          <target state="translated">準備好後，您可以嘗試使用 <ph id="ph1">`dotnet restore`</ph> 進行還原。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Depending on the version of your dependencies, you may encounter errors if NuGet cannot resolve the dependencies for one of the targeted frameworks above.</source>
          <target state="translated">根據您的相依性版本而定，如果 NuGet 無法解析上述其中一個目標架構的相依性，就可能會發生錯誤。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>This is a "point-in-time" problem; as time progresses, more and more packages will include support for these frameworks.</source>
          <target state="translated">這是「時間點」的問題，因為隨著時間過去，會有越來越多套件支援這些架構。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For now, if you run into this, you can use the <ph id="ph1">`imports`</ph> statement within the <ph id="ph2">`framework`</ph> node to specify to NuGet that it can restore the packages targeting the framework within the "imports" statement.</source>
          <target state="translated">目前來看，如果您遇到這個問題，可以使用 <ph id="ph2">`framework`</ph> 節點內的 <ph id="ph1">`imports`</ph> 陳述式，指定 NuGet 可以還原目標為 "imports" 陳述式內之架構的套件。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The restoring errors you get in this case should provide enough information to tell you which frameworks you need to import.</source>
          <target state="translated">在此情況下取得的還原錯誤應具有足夠資訊，可讓您知道需要匯入哪些架構。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>If you are slightly lost or new to this, in general, specifying <ph id="ph1">`dnxcore50`</ph> and <ph id="ph2">`portable-net45+win8`</ph> in the <ph id="ph3">`imports`</ph> statement should do the trick.</source>
          <target state="translated">如果您有點跟不上或對這方面不太熟悉，一般來說，只要在 <ph id="ph3">`imports`</ph> 陳述式中指定 <ph id="ph1">`dnxcore50`</ph> 和 <ph id="ph2">`portable-net45+win8`</ph> 就可以達到目的。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The JSON snippet below shows how this looks like:</source>
          <target state="translated">下列 JSON 程式碼片段會示範這個過程：</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Running <ph id="ph1">`dotnet build`</ph> will show any eventual build errors, though there shouldn't be too many of them.</source>
          <target state="translated">執行 <ph id="ph1">`dotnet build`</ph> 時，會將任何最終建置錯誤顯示出來，但不應該有太多錯誤。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>After your code is building and running properly, you can test it out with the runner.</source>
          <target state="translated">建置好程式碼並順利執行後，您可以再使用執行器測試一下。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Execute <ph id="ph1">`dotnet &lt;path-to-your-assembly&gt;`</ph> and see it run.</source>
          <target state="translated">執行 <ph id="ph1">`dotnet &lt;path-to-your-assembly&gt;`</ph>，並查看其執行狀況。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
