<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6080f5fa12a2391dd138828e0afc2219f1e3a11b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\character-encoding.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b73b5b21b030d4950c1041bdd0f07aeb8388b963</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b89d9393d89c8fce047b1cd8084fad9c34b4671d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Character encoding in .NET</source>
          <target state="translated">.NET 中的字元編碼</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Character encoding in .NET</source>
          <target state="translated">.NET 中的字元編碼</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Character encoding in .NET</source>
          <target state="translated">.NET 中的字元編碼</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Characters are abstract entities that can be represented in many different ways.</source>
          <target state="translated">字元是可以用許多不同的方式來表示的抽象實體。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>A character encoding is a system that pairs each character in a supported character set with some value that represents that character.</source>
          <target state="translated">字元編碼是一套系統，可將所支援之字元集中的每個字元與代表該字元的特定值配對。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, Morse code is a character encoding that pairs each character in the Roman alphabet with a pattern of dots and dashes that are suitable for transmission over telegraph lines.</source>
          <target state="translated">例如，摩斯密碼就是一種字元編碼，可將羅馬字母中的每個字元與適合透過電報線路傳輸的點和虛線圖樣配對。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A character encoding for computers pairs each character in a supported character set with a numeric value that represents that character.</source>
          <target state="translated">電腦的字元編碼可將所支援之字元集中的每個字元與代表該字元的數值配對。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A character encoding has two distinct components:</source>
          <target state="translated">字元編碼包含兩個不同的元件：</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>An encoder, which translates a sequence of characters into a sequence of numeric values (bytes).</source>
          <target state="translated">編碼器，可將字元序列轉譯成數值 (位元組) 序列。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>A decoder, which translates a sequence of bytes into a sequence of characters.</source>
          <target state="translated">解碼器，可將位元組序列轉譯成字元序列。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Character encoding describes the rules by which an encoder and a decoder operate.</source>
          <target state="translated">字元編碼描述編碼器和解碼器運作時所依據的規則。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> class describes the rules for encoding to, and decoding from, 8-bit Unicode Transformation Format (UTF-8), which uses one to four bytes to represent a single Unicode character.</source>
          <target state="translated">例如，<bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> 類別描述編碼和解碼 8 位元 Unicode 轉換格式 (UTF-8) 的規則，該格式使用一到四個位元組來表示單一 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Encoding and decoding can also include validation.</source>
          <target state="translated">編碼和解碼也可包含驗證。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> class checks all surrogates to make sure they constitute valid surrogate pairs.</source>
          <target state="translated">例如，<bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> 類別會檢查所有 Surrogate，確定它們是由有效的 Surrogate 字組所組成。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>(A surrogate pair consists of a character with a code point that ranges from U+D800 to U+DBFF followed by a character with a code point that ranges from U+DC00 to U+DFFF.) A fallback strategy determines how an encoder handles invalid characters or how a decoder handles invalid bytes.</source>
          <target state="translated">(Surrogate 字組是由包含範圍從 U+D800 到 U+DBFF 之字碼指標的字元，後面接著包含範圍從 U+DC00 到 U+DFFF 之字碼指標的字元所組成)。後援策略決定編碼器如何處理無效的字元，或解碼器如何處理無效的位元組。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The .NET encoding classes provide a way to store and convert character data.</source>
          <target state="translated">.NET 編碼類別提供儲存和轉換字元資料的方法。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>They should not be used to store binary data in string form.</source>
          <target state="translated">這些類別不應用來儲存字串格式的二進位資料。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Depending on the encoding used, converting binary data to string format with the encoding classes can introduce unexpected behavior and produce inaccurate or corrupted data.</source>
          <target state="translated">根據使用的編碼方式，使用編碼類別將二進位資料轉換成字串格式可能會導致未預期的行為，並且產生不正確或損毀的資料。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To convert binary data to a string form, use the <bpt id="p1">[</bpt>Convert.ToBase64String<ept id="p1">](xref:System.Convert.ToBase64String(System.Byte[]))</ept> method.</source>
          <target state="translated">若要將二進位資料轉換成字串格式，請使用 <bpt id="p1">[</bpt>Convert.ToBase64String<ept id="p1">](xref:System.Convert.ToBase64String(System.Byte[]))</ept> 方法。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>.NET uses the UTF-16 encoding (represented by the <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> class) to represent characters and strings.</source>
          <target state="translated">.NET 使用 UTF-16 編碼 (以 <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> 類別表示) 來表示字元和字串。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Applications that target the common language runtime use encoders to map Unicode character representations supported by the common language runtime to other encoding schemes.</source>
          <target state="translated">以 Common Language Runtime 為目標的應用程式使用編碼器將 Common Language Runtime 所支援的 Unicode 字元表示對應至其他編碼配置，</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>They use decoders to map characters from non-Unicode encodings to Unicode.</source>
          <target state="translated">並使用解碼器將非 Unicode 編碼的字元對應至 Unicode。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This topic consists of the following sections:</source>
          <target state="translated">本主題包含下列章節：</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Encodings in .NET<ept id="p1">](#encodings-in-net)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>.NET 中的編碼<ept id="p1">](#encodings-in-net)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Selecting an encoding class<ept id="p1">](#selecting-an-encoding-class)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>選取編碼類別<ept id="p1">](#selecting-an-encoding-class)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using an encoding object<ept id="p1">](#using-an-encoding-object)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>使用編碼物件<ept id="p1">](#using-an-encoding-object)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Choosing a fallback strategy<ept id="p1">](#choosing-a-fallback-strategy)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>選擇後援策略<ept id="p1">](#choosing-a-fallback-strategy)</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>實作自訂後援策略<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Encodings in .NET</source>
          <target state="translated">.NET 中的編碼</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>All character encoding classes in .NET inherit from the <bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> class, which is an abstract class that defines the functionality common to all character encodings.</source>
          <target state="translated">.NET 中的所有字元編碼類別都會繼承自 <bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> 類別，這是定義所有字元編碼共通功能的抽象類別。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>To access the individual encoding objects implemented in .NET, do the following:</source>
          <target state="translated">若要存取 .NET 中實作的個別編碼物件，請執行下列作業：</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Use the static properties of the <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> class, which return objects that represent the standard character encodings available in .NET (ASCII, UTF-7, UTF-8, UTF-16, and UTF-32).</source>
          <target state="translated">使用 <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> 類別的靜態屬性，這些屬性會傳回代表 .NET 中可用之標準字元編碼 (ASCII、UTF-7、UTF-8、UTF-16 和 UTF-32) 的物件。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>Encoding.Unicode<ept id="p1">](xref:System.Text.Encoding.Unicode)</ept> property returns a <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept> object.</source>
          <target state="translated">例如，<bpt id="p1">[</bpt>Encoding.Unicode<ept id="p1">](xref:System.Text.Encoding.Unicode)</ept> 屬性會傳回 <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept> 物件。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Each object uses replacement fallback to handle strings that it cannot encode and bytes that it cannot decode.</source>
          <target state="translated">每個物件會使用取代後援，來處理無法編碼的字串和無法解碼的位元組 </target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Replacement fallback<ept id="p1">](#replacement-fallback)</ept> section.)</source>
          <target state="translated">(如需詳細資訊，請參閱<bpt id="p1">[</bpt>取代後援<ept id="p1">](#replacement-fallback)</ept>一節)。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Call the encoding's class constructor.</source>
          <target state="translated">呼叫編碼的類別建構函式。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Objects for the ASCII, UTF-7, UTF-8, UTF-16, and UTF-32 encodings can be instantiated in this way.</source>
          <target state="translated">ASCII、UTF-7、UTF-8、UTF-16 和 UTF-32 編碼的物件可以透過這種方式執行個體化。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>By default, each object uses replacement fallback to handle strings that it cannot encode and bytes that it cannot decode, but you can specify that an exception should be thrown instead.</source>
          <target state="translated">每個物件預設會使用取代後援，來處理無法編碼的字串和無法解碼的位元組，不過您可以指定改為擲回例外狀況 </target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Replacement fallback<ept id="p1">](#replacement-fallback)</ept> and <bpt id="p2">[</bpt>Exception fallback<ept id="p2">](#exception-fallback)</ept> sections.)</source>
          <target state="translated">(如需詳細資訊，請參閱<bpt id="p1">[</bpt>取代後援<ept id="p1">](#replacement-fallback)</ept>及<bpt id="p2">[</bpt>例外狀況後援<ept id="p2">](#exception-fallback)</ept>兩節)。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">[</bpt>Encoding.Encoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> constructor and pass it an integer that represents the encoding.</source>
          <target state="translated">呼叫 <bpt id="p1">[</bpt>Encoding.Encoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> 建構函式，並將代表編碼的整數傳遞給該建構函式。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Standard encoding objects use replacement fallback, and code page and double-byte character set (DBCS) encoding objects use best-fit fallback to handle strings that they cannot encode and bytes that they cannot decode.</source>
          <target state="translated">標準編碼物件使用取代後援，來處理無法編碼的字串和無法解碼的位元組，而字碼頁和雙位元組字元集 (DBCS) 編碼物件則是使用自動調整後援 </target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Best-Fit fallback<ept id="p1">](#best-fit-fallback)</ept> section.)</source>
          <target state="translated">(如需詳細資訊，請參閱<bpt id="p1">[</bpt>自動調整後援<ept id="p1">](#best-fit-fallback)</ept>一節)。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">[</bpt>Encoding.GetEncoding<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> method, which returns any standard, code page, or DBCS encoding available in .NET.</source>
          <target state="translated">呼叫 <bpt id="p1">[</bpt>Encoding.GetEncoding<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> 方法，這個方法會傳回 .NET 中可用的任何標準、字碼頁或 DBCS 編碼。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Overloads let you specify a fallback object for both the encoder and the decoder.</source>
          <target state="translated">多載可讓您同時為編碼器和解碼器指定後援物件。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The Unicode Standard assigns a code point (a number) and a name to each character in every supported script.</source>
          <target state="translated">Unicode 標準會對每個受支援字集中的每個字元，指派一個字碼指標 (數字) 和一個名稱。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For example, the character "A" is represented by the code point U+0041 and the name "LATIN CAPITAL LETTER A".</source>
          <target state="translated">例如，字元 "A" 是由字碼指標 U+0041 和名稱 "LATIN CAPITAL LETTER A" 來表示。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The Unicode Transformation Format (UTF) encodings define ways to encode that code point into a sequence of one or more bytes.</source>
          <target state="translated">Unicode 轉換格式 (UTF) 編碼定義將字碼指標編碼為一或多個位元組序列的方式。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A Unicode encoding scheme simplifies world-ready application development because it allows characters from any character set to be represented in a single encoding.</source>
          <target state="translated">Unicode 編碼配置簡化全球化應用程式的開發作業，因為它能夠以單一編碼表示任何字元集的字元。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Application developers no longer have to keep track of the encoding scheme that was used to produce characters for a specific language or writing system, and data can be shared among systems internationally without being corrupted.</source>
          <target state="translated">應用程式開發人員不再需要追蹤用來產生特定語言或書寫系統字元的編碼配置，同時資料可在各國系統之間共用，而不會損毀。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>.NET supports three encodings defined by the Unicode standard: UTF-8, UTF-16, and UTF-32.</source>
          <target state="translated">.NET 支援由 Unicode 標準定義的三種編碼：UTF-8、UTF-16 和 UTF-32。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For more information, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode<ept id="p1">](http://www.unicode.org/)</ept> home page.</source>
          <target state="translated">如需詳細資訊，請參閱 <bpt id="p1">[</bpt>Unicode<ept id="p1">](http://www.unicode.org/)</ept> 首頁的＜Unicode Standard＞。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>.NET supports the character encoding systems listed in the following table.</source>
          <target state="translated">.NET 支援下表所列的字元編碼系統。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">編碼</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">類別</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Advantages/disadvantages</source>
          <target state="translated">優點/缺點</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept></target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Encodes a limited range of characters by using the lower seven bits of a byte.</source>
          <target state="translated">使用位元組較低的七個位元編碼有限範圍的字元。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Because this encoding only supports character values from U+0000 through U+007F, in most cases it is inadequate for internationalized applications.</source>
          <target state="translated">由於這個編碼僅支援 U+0000 到 U+007F 之間的字元值，因此大部分的情況下並不適用於國際化的應用程式。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UTF7Encoding<ept id="p1">](xref:System.Text.UTF7Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UTF7Encoding<ept id="p1">](xref:System.Text.UTF7Encoding)</ept></target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Represents characters as sequences of 7-bit ASCII characters.</source>
          <target state="translated">以 7 位元 ASCII 字元序列表示字元。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Non-ASCII Unicode characters are represented by an escape sequence of ASCII characters.</source>
          <target state="translated">非 ASCII 的 Unicode 字元則以 ASCII 字元的逸出序列表示。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>UTF-7 supports protocols such as e-mail and newsgroup protocols.</source>
          <target state="translated">UTF-7 支援通訊協定，例如電子郵件和新聞群組通訊協定。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>However, UTF-7 is not particularly secure or robust.</source>
          <target state="translated">不過，UTF-7 並沒有特別安全或穩固。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In some cases, changing one bit can radically alter the interpretation of an entire UTF-7 string.</source>
          <target state="translated">在某些情況下，變更一個位元便可能會徹底改變整個 UTF-7 字串的解譯。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In other cases, different UTF-7 strings can encode the same text.</source>
          <target state="translated">而在其他情況下，不同的 UTF-7 字串可能會編碼為相同的文字。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For sequences that include non-ASCII characters, UTF-7 requires more space than UTF-8, and encoding/decoding is slower.</source>
          <target state="translated">對於包含非 ASCII 字元的序列而言，UTF-7 比 UTF-8 需要更多空間，而且編碼/解碼的速度比較慢。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Consequently, you should use UTF-8 instead of UTF-7 if possible.</source>
          <target state="translated">因此，您應該盡可能使用 UTF-8，而不是 UTF-7。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a sequence of one to four bytes.</source>
          <target state="translated">以一到四個位元組的序列表示每個 Unicode 字碼指標。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>UTF-8 supports 8-bit data sizes and works well with many existing operating systems.</source>
          <target state="translated">UTF-8 支援 8 位元的資料大小，而且適用於許多現有的作業系統。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For the ASCII range of characters, UTF-8 is identical to ASCII encoding and allows a broader set of characters.</source>
          <target state="translated">對於 ASCII 字元範圍而言，UTF-8 與 ASCII 編碼完全相同，而且允許範圍更廣的字元集。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, for Chinese-Japanese-Korean (CJK) scripts, UTF-8 can require three bytes for each character, and can potentially cause larger data sizes than UTF-16.</source>
          <target state="translated">不過，針對中日韓 (CJK) 字集，UTF-8 可能要求每個字元需有三個位元組，而且造成的資料大小可能比 UTF-16 還大。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Note that sometimes the amount of ASCII data, such as HTML tags, justifies the increased size for the CJK range.</source>
          <target state="translated">請注意，ASCII 資料量 (例如 HTML 標記) 有時可能是 CJK 範圍大小增加的原因。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a sequence of one or two 16-bit integers.</source>
          <target state="translated">以一個或兩個 16 位元整數的序列表示每個 Unicode 字碼指標。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Most common Unicode characters require only one UTF-16 code point, although Unicode supplementary characters (U+10000 and greater) require two UTF-16 surrogate code points.</source>
          <target state="translated">雖然 Unicode 補充字元 (U+10000 及以上) 需要兩個 UTF-16 Surrogate 字碼指標，但最常用的 Unicode 字元只需要一個 UTF-16 字碼指標。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Both little-endian and big-endian byte orders are supported.</source>
          <target state="translated">同時支援位元組由小到大和位元組由大到小的位元組順序。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>UTF-16 encoding is used by the common language runtime to represent Char and String values, and it is used by the Windows operating system to represent WCHAR values.</source>
          <target state="translated">Common Language Runtime 會使用 UTF-16 編碼表示 Char 和 String 值，而 Windows 作業系統會使用該編碼表示 WCHAR 值。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a 32-bit integer.</source>
          <target state="translated">以 32 位元整數表示每個 Unicode 字碼指標。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Both little-endian and big-endian byte orders are supported.</source>
          <target state="translated">同時支援位元組由小到大和位元組由大到小的位元組順序。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>UTF-32 encoding is used when applications want to avoid the surrogate code point behavior of UTF-16 encoding on operating systems for which encoded space is too important.</source>
          <target state="translated">當編碼空間對作業系統十分重要，而應用程式想要在作業系統上避免 UTF-16 編碼的 Surrogate 字碼指標行為時，可以使用 UTF-32 編碼。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Single glyphs rendered on a display can still be encoded with more than one UTF-32 character.</source>
          <target state="translated">畫面上呈現的單一字符仍然可以使用一個以上的 UTF-32 字元編碼。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>These encodings enable you to work with Unicode characters as well as with encodings that are most commonly used in legacy applications.</source>
          <target state="translated">這些編碼可讓您處理 Unicode 字元，以及舊版應用程式中最常用的編碼。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>In addition, you can create a custom encoding by defining a class that derives from <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> and overriding its members.</source>
          <target state="translated">此外，您可以藉由定義衍生自 <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> 的類別及覆寫其成員，來建立自訂編碼。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>By default, .NET Core does not make available any code page encodings other than code page 28591 and the Unicode encodings, such as UTF-8 and UTF-16.</source>
          <target state="translated">根據預設，除了字碼頁 28591 以及UTF-8 和 UTF-16 等 Unicode 編碼之外，.NET Core 不會提供任何字碼頁編碼。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>However, you can add the code page encodings found in standard Windows apps that target the .NET Framework to your app.</source>
          <target state="translated">不過，您可以將在以 .NET Framework 為目標的標準 Windows 應用程式中找到的字碼頁編碼，加入您的應用程式。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For complete information, see the <bpt id="p1">[</bpt>EncodingProvider<ept id="p1">](xref:System.Text.EncodingProvider)</ept> topic.</source>
          <target state="translated">如需完整資訊，請參閱 <bpt id="p1">[</bpt>EncodingProvider<ept id="p1">](xref:System.Text.EncodingProvider)</ept> 主題。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Selecting an Encoding class</source>
          <target state="translated">選取編碼類別</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If you have the opportunity to choose the encoding to be used by your application, you should use a Unicode encoding, preferably either <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> or <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>.</source>
          <target state="translated">如果您有機會選擇應用程式使用的編碼，則應該使用 Unicode 編碼，最好是 <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> 或 <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept></target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>(.NET also supports a third Unicode encoding, <bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept>.)</source>
          <target state="translated">(.NET 也支援第三種 Unicode 編碼 <bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept>)。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If you are planning to use an ASCII encoding (<bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>), choose <bpt id="p2">[</bpt>UTF8Encoding<ept id="p2">](xref:System.Text.UTF8Encoding)</ept> instead.</source>
          <target state="translated">如果您打算使用 ASCII 編碼 (<bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>)，請改為選擇 <bpt id="p2">[</bpt>UTF8Encoding<ept id="p2">](xref:System.Text.UTF8Encoding)</ept>。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The two encodings are identical for the ASCII character set, but <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> has the following advantages:</source>
          <target state="translated">這兩種編碼對於 ASCII 字元集而言完全相同，但是 <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> 具有下列優點：</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>It can represent every Unicode character, whereas <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> supports only the Unicode character values between U+0000 and U+007F.</source>
          <target state="translated">它可以表示每個 Unicode 字元，而 <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> 只支援 U+0000 與 U+007F 之間的 Unicode 字元值。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>It provides error detection and better security.</source>
          <target state="translated">它提供錯誤偵測且具有較佳的安全性。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>It has been tuned to be as fast as possible and should be faster than any other encoding.</source>
          <target state="translated">它已調整成其可能的最快速度，因此在速度上應該會超過其他任何編碼。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Even for content that is entirely ASCII, operations performed with <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> are faster than operations performed with <bpt id="p2">[</bpt>ASCIIEncoding<ept id="p2">](xref:System.Text.ASCIIEncoding)</ept>.</source>
          <target state="translated">即使為全部都是 ASCII 的內容，使用 <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> 執行的作業也會快過使用 <bpt id="p2">[</bpt>ASCIIEncoding<ept id="p2">](xref:System.Text.ASCIIEncoding)</ept> 執行的作業。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>You should consider using <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> only for legacy applications.</source>
          <target state="translated">您應該考慮只對舊版應用程式使用 <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>However, even for legacy applications, <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> might be a better choice for the following reasons (assuming default settings):</source>
          <target state="translated">不過，即使是舊版應用程式，<bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> 仍然可能是較佳的選擇，原因如下 (假設使用預設值)：</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If your application has content that is not strictly ASCII and encodes it with <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>, each non-ASCII character encodes as a question mark (?).</source>
          <target state="translated">如果您的應用程式具有的內容不完全是 ASCII，而且使用 <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> 編碼該內容，則每個非 ASCII 字元都會編碼為問號 (?)。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If the application then decodes this data, the information is lost.</source>
          <target state="translated">如果應用程式接著解碼這份資料，資訊就會遺失。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If your application has content that is not strictly ASCII and encodes it with <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>, the result seems unintelligible if interpreted as ASCII.</source>
          <target state="translated">如果應用程式具有的內容不完全是 ASCII，而且使用 <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> 編碼該內容，將結果解譯為 ASCII 會難以理解。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>However, if the application then uses a UTF-8 decoder to decode this data, the data performs a round trip successfully.</source>
          <target state="translated">不過，如果應用程式接著使用 UTF-8 解碼器來解碼這份資料，則該資料會成功地執行來回轉換。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In a web application, characters sent to the client in response to a web request should reflect the encoding used on the client.</source>
          <target state="translated">在 Web 應用程式中，傳送至用戶端以回應 Web 要求的字元應該反映用戶端上使用的編碼。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In most cases, you should set the <bpt id="p1">[</bpt>HttpResponse.ContentEncoding<ept id="p1">](xref:System.Net.HttpResponseHeader.ContentEncoding)</ept> property to the value returned by the <bpt id="p2">[</bpt>HttpRequestHeader.ContentEncoding<ept id="p2">](xref:System.Net.HttpRequestHeader.ContentEncoding)</ept> property to display text in the encoding that the user expects.</source>
          <target state="translated">在大部分情況下，您應該將 <bpt id="p1">[</bpt>HttpResponse.ContentEncoding<ept id="p1">](xref:System.Net.HttpResponseHeader.ContentEncoding)</ept> 屬性設定為 <bpt id="p2">[</bpt>HttpRequestHeader.ContentEncoding<ept id="p2">](xref:System.Net.HttpRequestHeader.ContentEncoding)</ept> 屬性所傳回的值，以便以使用者預期的編碼來顯示文字。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Using an encoding object</source>
          <target state="translated">使用編碼物件</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>An encoder converts a string of characters (most commonly, Unicode characters) to its numeric (byte) equivalent.</source>
          <target state="translated">編碼器會將字元字串 (最常見為 Unicode 字元) 轉換成其對等數值 (位元組)。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For example, you might use an ASCII encoder to convert Unicode characters to ASCII so that they can be displayed at the console.</source>
          <target state="translated">例如，您可能使用 ASCII 編碼器將 Unicode 字元轉換成 ASCII，以便在主控台上顯示。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>To perform the conversion, you call the <bpt id="p1">[</bpt>Encoding.GetBytes<ept id="p1">](xref:System.Text.Encoding.GetBytes(System.Char[]))</ept> method.</source>
          <target state="translated">若要執行轉換，請呼叫 <bpt id="p1">[</bpt>Encoding.GetBytes<ept id="p1">](xref:System.Text.Encoding.GetBytes(System.Char[]))</ept> 方法。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>If you want to determine how many bytes are needed to store the encoded characters before performing the encoding, you can call the <bpt id="p1">[</bpt>GetByteCount<ept id="p1">](xref:System.Text.Encoding.GetByteCount(System.Char[]))</ept> method.</source>
          <target state="translated">如果您想要在執行編碼之前判斷儲存編碼的字元需要多少個位元組，可以呼叫 <bpt id="p1">[</bpt>GetByteCount<ept id="p1">](xref:System.Text.Encoding.GetByteCount(System.Char[]))</ept> 方法。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following example uses a single byte array to encode strings in two separate operations.</source>
          <target state="translated">下列範例會在兩項不同的作業中使用單一位元組陣列編碼字串。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It maintains an index that indicates the starting position in the byte array for the next set of ASCII-encoded bytes.</source>
          <target state="translated">它會保留一個索引，指出下一組 ASCII 編碼位元組在位元組陣列中的開始位置。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It calls the <bpt id="p1">[</bpt>ASCIIEncoding.GetByteCount(String)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetByteCount(System.String))</ept> method to ensure that the byte array is large enough to accommodate the encoded string.</source>
          <target state="translated">它會呼叫 <bpt id="p1">[</bpt>ASCIIEncoding.GetByteCount(String)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetByteCount(System.String))</ept> 方法，確保位元組陣列的大小夠大，足以容納編碼的字串。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>It then calls the <bpt id="p1">[</bpt>ASCIIEncoding.GetBytes(String, Int32, Int32, Byte[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32))</ept> method to encode the characters in the string.</source>
          <target state="translated">然後它會呼叫 <bpt id="p1">[</bpt>ASCIIEncoding.GetBytes(String, Int32, Int32, Byte[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32))</ept> 方法來編碼字串中的字元。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>A decoder converts a byte array that reflects a particular character encoding into a set of characters, either in a character array or in a string.</source>
          <target state="translated">解碼器會將反映特定字元編碼的位元組陣列轉換成字元陣列或字串中的字元集。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>To decode a byte array into a character array, you call the <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> method.</source>
          <target state="translated">若要將位元組陣列解碼為字元陣列，請呼叫 <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> 方法。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>To decode a byte array into a string, you call the <bpt id="p1">[</bpt>GetString<ept id="p1">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept> method.</source>
          <target state="translated">若要將位元組陣列解碼為字串，請呼叫 <bpt id="p1">[</bpt>GetString<ept id="p1">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept> 方法。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If you want to determine how many characters are needed to store the decoded bytes before performing the decoding, you can call the <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> method.</source>
          <target state="translated">如果您想要在執行解碼之前判斷儲存解碼的位元組需要多少個字元，可以呼叫 <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> 方法。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The following example encodes three strings and then decodes them into a single array of characters.</source>
          <target state="translated">下列範例會編碼三個字串，然後將這些字串解碼為單一字元陣列。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>It maintains an index that indicates the starting position in the character array for the next set of decoded characters.</source>
          <target state="translated">它會保留一個索引，指出下一組解碼的字元在字元陣列中的開始位置。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>It calls the <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> method to ensure that the character array is large enough to accommodate all the decoded characters.</source>
          <target state="translated">它會呼叫 <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> 方法，確保字元陣列的大小夠大，足以容納所有解碼的字元。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>It then calls the <bpt id="p1">[</bpt>ASCIIEncoding.GetChars(Byte[], Int32, Int32, Char[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> method to decode the byte array.</source>
          <target state="translated">然後它會呼叫 <bpt id="p1">[</bpt>ASCIIEncoding.GetChars(Byte[], Int32, Int32, Char[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> 方法來解碼位元組陣列。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The encoding and decoding methods of a class derived from <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> are designed to work on a complete set of data; that is, all the data to be encoded or decoded is supplied in a single method call.</source>
          <target state="translated">衍生自 <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> 之類別的編碼和解碼方法設計成可處理一組完整的資料；也就是說，單一方法呼叫中會提供所有要編碼或解碼的資料。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>However, in some cases, data is available in a stream, and the data to be encoded or decoded may be available only from separate read operations.</source>
          <target state="translated">不過，在某些情況下，資料是以資料流提供，因此只能從個別讀取作業取得要編碼或解碼的資料。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>This requires the encoding or decoding operation to remember any saved state from its previous invocation.</source>
          <target state="translated">因此，編碼或解碼作業必須記住之前叫用時的任何儲存狀態。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Methods of classes derived from <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> and <bpt id="p2">[</bpt>Decoder<ept id="p2">](xref:System.Text.Decoder)</ept> are able to handle encoding and decoding operations that span multiple method calls.</source>
          <target state="translated">衍生自 <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> 和 <bpt id="p2">[</bpt>Decoder<ept id="p2">](xref:System.Text.Decoder)</ept> 之類別的方法能夠處理橫跨多個方法呼叫的編碼和解碼作業。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> object for a particular encoding is available from that encoding's <bpt id="p2">[</bpt>Encoding.GetEncoder<ept id="p2">](xref:System.Text.Encoding.GetEncoder)</ept> property.</source>
          <target state="translated">特定編碼的 <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> 物件可從該編碼的 <bpt id="p2">[</bpt>Encoding.GetEncoder<ept id="p2">](xref:System.Text.Encoding.GetEncoder)</ept> 屬性取得。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> object for a particular encoding is available from that encoding's <bpt id="p2">[</bpt>Encoding.GetDecoder<ept id="p2">](xref:System.Text.Encoding.GetDecoder)</ept> property.</source>
          <target state="translated">特定編碼的 <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> 物件可從該編碼的 <bpt id="p2">[</bpt>Encoding.GetDecoder<ept id="p2">](xref:System.Text.Encoding.GetDecoder)</ept> 屬性取得。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For decoding operations, note that classes derived from <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> include a <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> method, but they do not have a method that corresponds to <bpt id="p3">[</bpt>Encoding.GetString<ept id="p3">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept>.</source>
          <target state="translated">若為解碼作業，請注意衍生自 <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> 的類別包含 <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> 方法，但是沒有對應至 <bpt id="p3">[</bpt>Encoding.GetString<ept id="p3">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept> 的方法。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between using the <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> and <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> methods for decoding a Unicode byte array.</source>
          <target state="translated">下列範例說明使用 <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> 和 <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> 方法解碼 Unicode 位元組陣列的差異。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The example encodes a string that contains some Unicode characters to a file, and then uses the two decoding methods to decode them ten bytes at a time.</source>
          <target state="translated">這個範例會將包含某些 Unicode 字元的字串編碼為檔案，然後使用這兩種解碼方法進行解碼，且一次解碼十個位元組。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Because a surrogate pair occurs in the tenth and eleventh bytes, it is decoded in separate method calls.</source>
          <target state="translated">由於 Surrogate 字組會在第十個和第十一個位元組發生，因此會在不同的方法呼叫中另外解碼。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>As the output shows, the <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> method is not able to correctly decode the bytes and instead replaces them with U+FFFD (REPLACEMENT CHARACTER).</source>
          <target state="translated">如輸出所示，<bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> 方法無法正確解碼位元組，而是將它們取代為 U+FFFD (REPLACEMENT CHARACTER)。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>On the other hand, the <bpt id="p1">[</bpt>Decoder.GetChars<ept id="p1">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> method is able to successfully decode the byte array to get the original string.</source>
          <target state="translated">另一方面，<bpt id="p1">[</bpt>Decoder.GetChars<ept id="p1">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> 方法能夠成功解碼位元組陣列並取得原始字串。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Choosing a fallback strategy</source>
          <target state="translated">選擇後援策略</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>When a method tries to encode or decode a character but no mapping exists, it must implement a fallback strategy that determines how the failed mapping should be handled.</source>
          <target state="translated">當某個方法嘗試編碼或解碼字元，但是沒有任何對應存在時，它就必須實作後援策略，以決定應該如何處理失敗的對應。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>There are three types of fallback strategies:</source>
          <target state="translated">後援策略有三種類型：</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Best-fit fallback</source>
          <target state="translated">自動調整後援</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Replacement fallback</source>
          <target state="translated">取代後援</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Exception fallback</source>
          <target state="translated">例外狀況後援</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The most common problems in encoding operations occur when a Unicode character cannot be mapped to a particular code page encoding.</source>
          <target state="translated">編碼作業最常在 Unicode 字元無法對應至特定字碼頁編碼時發生問題。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The most common problems in decoding operations occur when invalid byte sequences cannot be translated into valid Unicode characters.</source>
          <target state="translated">解碼作業最常在無效的位元組序列無法轉譯為有效的 Unicode 字元時發生問題。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>For these reasons, you should know which fallback strategy a particular encoding object uses.</source>
          <target state="translated">因此，您應該知道特定編碼物件所使用的後援策略。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should specify the fallback strategy used by an encoding object when you instantiate the object.</source>
          <target state="translated">您應該在執行個體化編碼物件時，盡可能指定該物件所使用的後援策略。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Best-fit fallback</source>
          <target state="translated">自動調整後援</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>When a character does not have an exact match in the target encoding, the encoder can try to map it to a similar character.</source>
          <target state="translated">當字元在目標編碼中沒有完全相符的字元時，編碼器可以嘗試將該字元對應至類似的字元</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>(Best-fit fallback is mostly an encoding rather than a decoding issue.</source>
          <target state="translated">(自動調整後援大部分是針對編碼問題，而不是針對解碼問題。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>There are very few code pages that contain characters that cannot be successfully mapped to Unicode.) Best-fit fallback is the default for code page and double-byte character set encodings that are retrieved by the <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> and <bpt id="p2">[</bpt>Encoding.GetEncoding(String)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.String))</ept> overloads.</source>
          <target state="translated">很少有字碼頁包含無法成功對應至 Unicode 的字元)。自動調整後援是 <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> 和 <bpt id="p2">[</bpt>Encoding.GetEncoding(String)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.String))</ept> 多載所擷取之字碼頁和雙位元組字元集編碼的預設值。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>In theory, the Unicode encoding classes provided in .NET (<bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>, <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>, and <bpt id="p3">[</bpt>UTF32Encoding<ept id="p3">](xref:System.Text.UTF32Encoding)</ept>) support every character in every character set, so they can be used to eliminate best-fit fallback issues.</source>
          <target state="translated">理論上，.NET 中提供的 Unicode 編碼類別 (<bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>、<bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept> 和 <bpt id="p3">[</bpt>UTF32Encoding<ept id="p3">](xref:System.Text.UTF32Encoding)</ept>) 支援每個字元集中的每個字元，因此這些類別可以用來解決自動調整後援的問題。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Best-fit strategies vary for different code pages, and they are not documented in detail.</source>
          <target state="translated">自動調整策略會因不同的字碼頁而異，並且沒有詳細的說明。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>For example, for some code pages, full-width Latin characters map to the more common half-width Latin characters.</source>
          <target state="translated">例如，某些字碼頁的全形拉丁字元會對應至更常見的半形拉丁字元。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>For other code pages, this mapping is not made.</source>
          <target state="translated">至於其他字碼頁，則不會進行這項對應。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Even under an aggressive best-fit strategy, there is no imaginable fit for some characters in some encodings.</source>
          <target state="translated">即使有主動的自動調整策略，還是會有些字元在特定編碼中沒有適當的對應。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example, a Chinese ideograph has no reasonable mapping to code page 1252.</source>
          <target state="translated">例如，中文表意字元在字碼頁 1252 中便沒有適當的對應。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>In this case, a replacement string is used.</source>
          <target state="translated">在這種情況下，會使用取代字串。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>By default, this string is just a single QUESTION MARK (U+003F).</source>
          <target state="translated">根據預設，這個字串只是單一 QUESTION MARK (U+003F)。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The following example uses code page 1252 (the Windows code page for Western European languages) to illustrate best-fit mapping and its drawbacks.</source>
          <target state="translated">下列範例會使用字碼頁 1252 (西歐語言的 Windows 字碼頁) 說明自動調整對應及其缺點。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> method is used to retrieve an encoding object for code page 1252.</source>
          <target state="translated"><bpt id="p1">[</bpt>Encoding.GetEncoding(Int32<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> 方法可用來為字碼頁 1252 擷取編碼物件。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>By default, it uses a best-fit mapping for Unicode characters that it does not support.</source>
          <target state="translated">根據預設，它會針對不支援的 Unicode 字元使用自動調整對應。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The example instantiates a string that contains three non-ASCII characters - CIRCLED LATIN CAPITAL LETTER S (U+24C8), SUPERSCRIPT FIVE (U+2075), and INFINITY (U+221E) - separated by spaces.</source>
          <target state="translated">這個範例會執行個體化包含三個非 ASCII 字元的字串：CIRCLED LATIN CAPITAL LETTER S (U+24C8)、SUPERSCRIPT FIVE (U+2075) 和 INFINITY (U+221E) (以空格分隔)。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, when the string is encoded, the three original non-space characters are replaced by QUESTION MARK (U+003F), DIGIT FIVE (U+0035), and DIGIT EIGHT (U+0038).</source>
          <target state="translated">如範例的輸出所示，編碼字串時，這三個原始非空格字元會被 QUESTION MARK (U+003F)、DIGIT FIVE (U+0035) 和 DIGIT EIGHT (U+0038) 取代。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>DIGIT EIGHT is a particularly poor replacement for the unsupported INFINITY character, and QUESTION MARK indicates that no mapping was available for the original character.</source>
          <target state="translated">DIGIT EIGHT 對於不支援的 INFINITY 字元來說，是相當差的取代，QUESTION MARK 則表示沒有可供原始字元使用的對應。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Best-fit mapping is the default behavior for an <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> object that encodes Unicode data into code page data, and there are legacy applications that rely on this behavior.</source>
          <target state="translated">自動調整對應是 <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> 物件的預設行為，可將 Unicode 資料編碼為字碼頁資料，有些舊版應用程式需要這個行為。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>However, most new applications should avoid best-fit behavior for security reasons.</source>
          <target state="translated">不過，基於安全性理由，大多數的新應用程式都應該避免自動調整行為。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For example, applications should not put a domain name through a best-fit encoding.</source>
          <target state="translated">例如，應用程式不應該透過自動調整編碼方式放入定義域名稱。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>You can also implement a custom best-fit fallback mapping for an encoding.</source>
          <target state="translated">您也可以實作編碼的自訂自動調整後援對應。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> section.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>實作自訂後援策略<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept>一節。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>If best-fit fallback is the default for an encoding object, you can choose another fallback strategy when you retrieve an <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> object by calling the <bpt id="p2">[</bpt>Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> or <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> overload.</source>
          <target state="translated">如果自動調整後援是編碼物件的預設值，則當您藉由呼叫 <bpt id="p2">[</bpt>Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> 或 <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> 多載擷取 <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> 物件時，可以選擇其他後援策略。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The following section includes an example that replaces each character that cannot be mapped to code page 1252 with an asterisk (<ph id="ph1">\*</ph>).</source>
          <target state="translated">下節範例會以星號 (<ph id="ph1">\*</ph>)取代每一個 對應到字碼頁 1252 的字元。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Replacement fallback</source>
          <target state="translated">取代後援</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>When a character does not have an exact match in the target scheme, but there is no appropriate character that it can be mapped to, the application can specify a replacement character or string.</source>
          <target state="translated">當字元在目標配置中沒有完全相符的字元，但是沒有可以對應的適當字元時，應用程式就可以指定取代字元或字串。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>This is the default behavior for the Unicode decoder, which replaces any two-byte sequence that it cannot decode with REPLACEMENT_CHARACTER (U+FFFD).</source>
          <target state="translated">這是 Unicode 解碼器的預設行為，該行為會將任何無法解碼的兩個位元組序列取代為 REPLACEMENT_CHARACTER (U+FFFD)。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>It is also the default behavior of the <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> class, which replaces each character that it cannot encode or decode with a question mark.</source>
          <target state="translated">它也是 <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> 類別的預設行為，該行為會將任何無法編碼或解碼的每個字元取代為問號。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The following example illustrates character replacement for the Unicode string from the previous example.</source>
          <target state="translated">下列範例說明前一個範例中 Unicode 字串的字元取代。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>As the output shows, each character that cannot be decoded into an ASCII byte value is replaced by 0x3F, which is the ASCII code for a question mark.</source>
          <target state="translated">如輸出所示，每個無法解碼為 ASCII 位元組值的字元都會以 0x3F 取代，也就是以問號取代 ASCII 碼。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>.NET includes the <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> and <bpt id="p2">[</bpt>DecoderReplacementFallback<ept id="p2">](xref:System.Text.DecoderReplacementFallback)</ept> classes, which substitute a replacement string if a character does not map exactly in an encoding or decoding operation.</source>
          <target state="translated">.NET 包含 <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> 和 <bpt id="p2">[</bpt>DecoderReplacementFallback<ept id="p2">](xref:System.Text.DecoderReplacementFallback)</ept> 類別，這兩個類別會在字元無法於編碼或解碼作業中精確對應時替代取代字串。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>By default, this replacement string is a question mark, but you can call a class constructor overload to choose a different string.</source>
          <target state="translated">根據預設，這個取代字串會是一個問號，但是您可以呼叫類別建構函式多載，以便選擇不同的字串。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Typically, the replacement string is a single character, although this is not a requirement.</source>
          <target state="translated">取代字串通常 (但不一定) 是單一字元。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The following example changes the behavior of the code page 1252 encoder by instantiating an <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> object that uses an asterisk (<ph id="ph1">\*</ph>) as a replacement string.</source>
          <target state="translated">下列範例會具現化使用星號 (<ph id="ph1">\*</ph>) 作為取代字串的 <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> 物件，變更字碼頁 1252 編碼器的行為。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>You can also implement a replacement class for an encoding.</source>
          <target state="translated">您也可以實作編碼的取代類別。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> section.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>實作自訂後援策略<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept>一節。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>In addition to QUESTION MARK (U+003F), the Unicode REPLACEMENT CHARACTER (U+FFFD) is commonly used as a replacement string, particularly when decoding byte sequences that cannot be successfully translated into Unicode characters.</source>
          <target state="translated">除了 QUESTION MARK (U+003F) 之外，還常使用 Unicode REPLACEMENT CHARACTER (U+FFFD) 做為取代字串，特別是當解碼無法成功轉譯成 Unicode 字元的位元組序列時。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>However, you are free to choose any replacement string, and it can contain multiple characters.</source>
          <target state="translated">不過，您可以自由選擇任何取代字串，而且該字串可以包含多個字元。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Exception fallback</source>
          <target state="translated">例外狀況後援</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Instead of providing a best-fit fallback or a replacement string, an encoder can throw an <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> if it is unable to encode a set of characters, and a decoder can throw a <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> if it is unable to decode a byte array.</source>
          <target state="translated">編碼器可在無法編碼一組字元時擲回 <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept>，而解碼器可在無法解碼位元組陣列時擲回 <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept>，而不是提供自動調整後援或取代字串。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>To throw an exception in encoding and decoding operations, you supply an <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> object and a <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> object, respectively, to the <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> method.</source>
          <target state="translated">若要在編碼和解碼作業中擲回例外狀況，請將 <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> 物件和 <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> 物件分別提供給 <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> 方法。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The following example illustrates exception fallback with the ASCIIEncoding class.</source>
          <target state="translated">下列範例說明 ASCIIEncoding 類別的例外狀況後援。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>You can also implement a custom exception handler for an encoding operation.</source>
          <target state="translated">您也可以實作編碼作業的自訂例外狀況處理常式。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> section.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>實作自訂後援策略<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept>一節。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> and <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> objects provide the following information about the condition that caused the exception:</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> 和 <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> 物件提供下列造成例外狀況之條件的相關資訊：</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> object includes an <bpt id="p2">[</bpt>IsUnknownSurrogate<ept id="p2">](xref:System.Text.EncoderFallbackException.IsUnknownSurrogate)</ept> method, which indicates whether the character or characters that cannot be encoded represent an unknown surrogate pair (in which case, the method returns <ph id="ph1">`true`</ph>) or an unknown single character (in which case, the method returns <ph id="ph2">`false`</ph>).</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> 物件包含 <bpt id="p2">[</bpt>IsUnknownSurrogate<ept id="p2">](xref:System.Text.EncoderFallbackException.IsUnknownSurrogate)</ept> 方法，這個方法會指出無法編碼的一或多個字元代表未知的 Surrogate 字組 (在這種情況下，方法會傳回 <ph id="ph1">`true`</ph>)，或未知的單一字元 (在這種情況下，方法會傳回 <ph id="ph2">`false`</ph>)。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The characters in the surrogate pair are available from the <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknownHigh<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknownHigh)</ept> and <bpt id="p2">[</bpt>EncoderFallbackException.CharUnknownLow<ept id="p2">](xref:System.Text.EncoderFallbackException.CharUnknownLow)</ept> properties.</source>
          <target state="translated">Surrogate 字組中的字元可從 <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknownHigh<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknownHigh)</ept> 和 <bpt id="p2">[</bpt>EncoderFallbackException.CharUnknownLow<ept id="p2">](xref:System.Text.EncoderFallbackException.CharUnknownLow)</ept> 屬性取得。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The unknown single character is available from the <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknown<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknown)</ept> property.</source>
          <target state="translated">未知的單一字元可從 <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknown<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknown)</ept> 屬性取得。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackException.Index<ept id="p1">](xref:System.Text.EncoderFallbackException.Index)</ept> property indicates the position in the string at which the first character that could not be encoded was found.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackException.Index<ept id="p1">](xref:System.Text.EncoderFallbackException.Index)</ept> 屬性會指出字串中找到第一個無法編碼之字元的位置。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>DecoderFallbackException<ept id="p1">](xref:System.Text.DecoderFallbackException)</ept> object includes a <bpt id="p2">[</bpt>BytesUnknown<ept id="p2">](xref:System.Text.DecoderFallbackException.BytesUnknown)</ept> property that returns an array of bytes that cannot be decoded.</source>
          <target state="translated"><bpt id="p1">[</bpt>DecoderFallbackException<ept id="p1">](xref:System.Text.DecoderFallbackException)</ept> 物件包含 <bpt id="p2">[</bpt>BytesUnknown<ept id="p2">](xref:System.Text.DecoderFallbackException.BytesUnknown)</ept> 屬性，這個屬性會傳回無法解碼的位元組陣列。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>DecoderFallbackException.Index<ept id="p1">](xref:System.Text.DecoderFallbackException.Index)</ept> property indicates the starting position of the unknown bytes.</source>
          <target state="translated"><bpt id="p1">[</bpt>DecoderFallbackException.Index<ept id="p1">](xref:System.Text.DecoderFallbackException.Index)</ept> 屬性會指出未知位元組的開始位置。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Although the <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> and <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> objects provide adequate diagnostic information about the exception, they do not provide access to the encoding or decoding buffer.</source>
          <target state="translated">雖然 <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> 和 <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> 物件提供了有關例外狀況的適當診斷資訊，但是並未提供編碼或解碼緩衝區的存取權。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Therefore, they do not allow invalid data to be replaced or corrected within the encoding or decoding method.</source>
          <target state="translated">因此，這兩個物件不允許在編碼或解碼方法內取代或更正無效的資料。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Implementing a custom fallback strategy</source>
          <target state="translated">實作自訂後援策略</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>In addition to the best-fit mapping that is implemented internally by code pages, .NET includes the following classes for implementing a fallback strategy:</source>
          <target state="translated">除了字碼頁在內部實作的自動調整對應之外，.NET 還包括下列實作後援策略的類別：</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> and <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> to replace characters in encoding operations.</source>
          <target state="translated">使用 <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> 和 <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> 取代編碼作業中的字元。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>DecoderReplacementFallback<ept id="p1">](xref:System.Text.DecoderReplacementFallback)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> to replace characters in decoding operations.</source>
          <target state="translated">使用 <bpt id="p1">[</bpt>DecoderReplacementFallback<ept id="p1">](xref:System.Text.DecoderReplacementFallback)</ept> 和 <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> 取代解碼作業中的字元。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>EncoderExceptionFallback<ept id="p1">](xref:System.Text.EncoderExceptionFallback)</ept> and <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> to throw an <bpt id="p3">[</bpt>EncoderFallbackException<ept id="p3">](xref:System.Text.EncoderFallbackException)</ept> when a character cannot be encoded.</source>
          <target state="translated">在無法編碼字元時，使用 <bpt id="p1">[</bpt>EncoderExceptionFallback<ept id="p1">](xref:System.Text.EncoderExceptionFallback)</ept> 和 <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> 擲回 <bpt id="p3">[</bpt>EncoderFallbackException<ept id="p3">](xref:System.Text.EncoderFallbackException)</ept>。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>DecoderExceptionFallback<ept id="p1">](xref:System.Text.DecoderExceptionFallback)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> to throw a <bpt id="p3">[</bpt>DecoderFallbackException<ept id="p3">](xref:System.Text.DecoderFallbackException)</ept> when a character cannot be decoded.</source>
          <target state="translated">在無法解碼字元時，使用 <bpt id="p1">[</bpt>DecoderExceptionFallback<ept id="p1">](xref:System.Text.DecoderExceptionFallback)</ept> 和 <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> 擲回 <bpt id="p3">[</bpt>DecoderFallbackException<ept id="p3">](xref:System.Text.DecoderFallbackException)</ept>。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>In addition, you can implement a custom solution that uses best-fit fallback, replacement fallback, or exception fallback, by following these steps:</source>
          <target state="translated">此外，您可以執行下列步驟，來實作使用自動調整後援、取代後援或例外狀況後援的自訂方案：</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Derive a class from <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> for decoding operations.</source>
          <target state="translated">針對編碼作業從 <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> 衍生類別，並針對解碼作業從 <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> 衍生類別。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Derive a class from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> for decoding operations.</source>
          <target state="translated">針對編碼作業從 <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> 衍生類別，並針對解碼作業從 <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> 衍生類別。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>For exception fallback, if the predefined <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> and <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> classes do not meet your needs, derive a class from an exception object such as <bpt id="p3">[</bpt>Exception<ept id="p3">](xref:System.Exception)</ept> or <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept>.</source>
          <target state="translated">至於例外狀況後援，如果預先定義的 <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> 和 <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> 類別不符合您的需求，則從例外狀況物件 (例如 <bpt id="p3">[</bpt>Exception<ept id="p3">](xref:System.Exception)</ept> 或 <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept>) 衍生類別。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Deriving from EncoderFallback or DecoderFallback</source>
          <target state="translated">衍生自 EncoderFallback 或 DecoderFallback</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>To implement a custom fallback solution, you must create a class that inherits from <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> for decoding operations.</source>
          <target state="translated">若要實作自訂後援方案，您必須針對編碼作業建立繼承自 <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> 的類別，以及針對解碼作業建立繼承自 <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> 的類別。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Instances of these classes are passed to the <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> method and serve as the intermediary between the encoding class and the fallback implementation.</source>
          <target state="translated">這些類別的執行個體會傳遞給 <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> 方法，並且作為編碼類別和後援實作之間的媒介。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>When you create a custom fallback solution for an encoder or decoder, you must implement the following members:</source>
          <target state="translated">當您針對編碼器或解碼器建立自訂後援方案時，必須實作下列成員：</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallback.MaxCharCount<ept id="p1">](xref:System.Text.EncoderFallback.MaxCharCount)</ept> or <bpt id="p2">[</bpt>DecoderFallback.MaxCharCount<ept id="p2">](xref:System.Text.DecoderFallback.MaxCharCount)</ept> property, which returns the maximum possible number of characters that the best-fit, replacement, or exception fallback can return to replace a single character.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallback.MaxCharCount<ept id="p1">](xref:System.Text.EncoderFallback.MaxCharCount)</ept> 或 <bpt id="p2">[</bpt>DecoderFallback.MaxCharCount<ept id="p2">](xref:System.Text.DecoderFallback.MaxCharCount)</ept> 屬性，這個屬性會傳回自動調整、取代或例外狀況後援可傳回以取代單一字元的最大字元數。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>For a custom exception fallback, its value is zero.</source>
          <target state="translated">若是自訂例外狀況後援，其值為零。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> or <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> method, which returns your custom <bpt id="p3">[</bpt>EncoderFallbackBuffer<ept id="p3">](xref:System.Text.EncoderFallbackBuffer)</ept> or <bpt id="p4">[</bpt>DecoderFallbackBuffer<ept id="p4">](xref:System.Text.DecoderFallbackBuffer)</ept> implementation.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> 或 <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> 方法，這個方法會傳回您自訂的 <bpt id="p3">[</bpt>EncoderFallbackBuffer<ept id="p3">](xref:System.Text.EncoderFallbackBuffer)</ept> 或 <bpt id="p4">[</bpt>DecoderFallbackBuffer<ept id="p4">](xref:System.Text.DecoderFallbackBuffer)</ept> 實作。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The method is called by the encoder when it encounters the first character that it is unable to successfully encode, or by the decoder when it encounters the first byte that it is unable to successfully decode.</source>
          <target state="translated">編碼器會在遇到無法成功編碼的第一個字元時呼叫這個方法，而解碼器會在遇到無法成功解碼的第一個位元組時呼叫這個方法。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Deriving from EncoderFallbackBuffer or DecoderFallbackBuffer</source>
          <target state="translated">衍生自 EncoderFallbackBuffer 或 DecoderFallbackBuffer</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>To implement a custom fallback solution, you must also create a class that inherits from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> for decoding operations.</source>
          <target state="translated">若要實作自訂後援方案，您還必須針對編碼作業建立繼承自 <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> 的類別，以及針對解碼作業建立繼承自 <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> 的類別。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Instances of these classes are returned by the <ph id="ph1">`CreateFallbackBuffer`</ph> method of the <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> and <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> classes.</source>
          <target state="translated">這些類別的執行個體會由 <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> 和 <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> 類別的 <ph id="ph1">`CreateFallbackBuffer`</ph> 方法傳回。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> method is called by the encoder when it encounters the first character that it is not able to encode, and the <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> method is called by the decoder when it encounters one or more bytes that it is not able to decode.</source>
          <target state="translated">編碼器會在遇到無法編碼的第一個字元時呼叫 <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> 方法，而解碼器會在遇到無法解碼的一或多個位元組時呼叫 <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> 方法。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> classes provide the fallback implementation.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> 和 <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> 類別提供後援實作。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Each instance represents a buffer that contains the fallback characters that will replace the character that cannot be encoded or the byte sequence that cannot be decoded.</source>
          <target state="translated">每個執行個體代表包含後援字元的緩衝區，這些後援字元將取代無法編碼的字元或無法解碼的位元組序列。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>When you create a custom fallback solution for an encoder or decoder, you must implement the following members:</source>
          <target state="translated">當您針對編碼器或解碼器建立自訂後援方案時，必須實作下列成員：</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.%23ctor)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> method.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.%23ctor)</ept> 或 <bpt id="p2">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> 方法。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Char,System.Int32))</ept> is called by the encoder to provide the fallback buffer with information about the character that it cannot encode.</source>
          <target state="translated">編碼器會呼叫 <bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Char,System.Int32))</ept> 來提供後援緩衝區，其中包含無法編碼之字元的相關資訊。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Because the character to be encoded may be a surrogate pair, this method is overloaded.</source>
          <target state="translated">由於要編碼的字元可能是 Surrogate 字組，因此這個方法為多載。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>One overload is passed the character to be encoded and its index in the string.</source>
          <target state="translated">其中一個多載會收到傳遞之要編碼的字元，以及其在字串中的索引。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The second overload is passed the high and low surrogate along with its index in the string.</source>
          <target state="translated">第二個多載會收到傳遞的高和低 Surrogate，以及其在字串中的索引。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> method is called by the decoder to provide the fallback buffer with information about the bytes that it cannot decode.</source>
          <target state="translated">解碼器會呼叫 <bpt id="p1">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> 方法來提供後援緩衝區，其中包含無法解碼之位元組的相關資訊。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>This method is passed an array of bytes that it cannot decode, along with the index of the first byte.</source>
          <target state="translated">這個方法會收到傳遞之無法解碼的位元組陣列，以及第一個位元組的索引。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The fallback method should return <ph id="ph1">`true`</ph> if the fallback buffer can supply a best-fit or replacement character or characters; otherwise, it should return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果後援緩衝區可以提供自動調整或一或多個取代字元，則後援方法應該傳回 <ph id="ph1">`true`</ph>，否則應該傳回 <ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>For an exception fallback, the fallback method should throw an exception.</source>
          <target state="translated">若是例外狀況後援，後援方法應該擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.GetNextChar<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.GetNextChar)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.GetNextChar<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.GetNextChar)</ept> method, which is called repeatedly by the encoder or decoder to get the next character from the fallback buffer.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackBuffer.GetNextChar<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.GetNextChar)</ept> 或 <bpt id="p2">[</bpt>DecoderFallbackBuffer.GetNextChar<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.GetNextChar)</ept> 方法，編碼器或解碼器會重複呼叫這個方法，以便從後援緩衝區取得下一個字元。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>When all fallback characters have been returned, the method should return U+0000.</source>
          <target state="translated">當所有後援字元都已傳回時，這個方法應傳回 U+0000。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.Remaining<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Remaining)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.Remaining<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Remaining)</ept> property, which returns the number of characters remaining in the fallback buffer.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackBuffer.Remaining<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Remaining)</ept> 或 <bpt id="p2">[</bpt>DecoderFallbackBuffer.Remaining<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Remaining)</ept> 屬性，這個屬性會傳回後援緩衝區中剩餘的字元數。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.MovePrevious<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.MovePrevious)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.MovePrevious<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.MovePrevious)</ept> method, which moves the current position in the fallback buffer to the previous character.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackBuffer.MovePrevious<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.MovePrevious)</ept> 或 <bpt id="p2">[</bpt>DecoderFallbackBuffer.MovePrevious<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.MovePrevious)</ept> 方法，這個方法會將後援緩衝區中的目前位置移至前一個字元。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.Reset<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Reset)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.Reset<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Reset)</ept> method, which reinitializes the fallback buffer.</source>
          <target state="translated"><bpt id="p1">[</bpt>EncoderFallbackBuffer.Reset<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Reset)</ept> 或 <bpt id="p2">[</bpt>DecoderFallbackBuffer.Reset<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Reset)</ept> 方法，這個方法會重新初始化後援緩衝區。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>If the fallback implementation is a best-fit fallback or a replacement fallback, the classes derived from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> also maintain two private instance fields: the exact number of characters in the buffer; and the index of the next character in the buffer to return.</source>
          <target state="translated">如果後援實作是自動調整後援或取代後援，則衍生自 <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> 和 <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> 的類別還會維護兩個私用執行個體欄位：緩衝區中確實的字元數，以及緩衝區中要傳回之下一個字元的索引。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>An EncoderFallback example</source>
          <target state="translated">EncoderFallback 範例</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>An earlier example used replacement fallback to replace Unicode characters that did not correspond to ASCII characters with an asterisk (<ph id="ph1">\*</ph>).</source>
          <target state="translated">前文中的範例使用了取代後援，以星號 (<ph id="ph1">\*</ph>) 取代無法對應到 ASCII 字元的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The following example uses a custom best-fit fallback implementation instead to provide a better mapping of non-ASCII characters.</source>
          <target state="translated">下列範例使用自訂自動調整後援實作，而不是提供較佳的非 ASCII 字元對應。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The following code defines a class named <ph id="ph1">`CustomMapper`</ph> that is derived from <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> to handle the best-fit mapping of non-ASCII characters.</source>
          <target state="translated">下列程式碼會定義名為 <ph id="ph1">`CustomMapper`</ph> 的類別，該類別衍生自 <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept>，會處理非 ASCII 字元的自動調整對應。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`CreateFallbackBuffer`</ph> method returns a <ph id="ph2">`CustomMapperFallbackBuffer`</ph> object, which provides the <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> implementation.</source>
          <target state="translated">其 <ph id="ph1">`CreateFallbackBuffer`</ph> 方法會傳回提供 <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> 實作的 <ph id="ph2">`CustomMapperFallbackBuffer`</ph> 物件。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CustomMapper`</ph> class uses a <bpt id="p1">[</bpt>Dictionary<ph id="ph2">&amp;lt;</ph>TKey, TValue<ph id="ph3">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.Dictionary%602)</ept> object to store the mappings of unsupported Unicode characters (the key value) and their corresponding 8-bit characters (which are stored in two consecutive bytes in a 64-bit integer).</source>
          <target state="translated"><ph id="ph1">`CustomMapper`</ph> 類別使用 <bpt id="p1">[</bpt>Dictionary<ph id="ph2">&amp;lt;</ph>TKey, TValue<ph id="ph3">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.Dictionary%602)</ept> 物件來儲存不支援的 Unicode 字元對應 (機碼值) 及其對應的 8 位元字元 (儲存在 64 位元整數的兩個連續的位元組中)。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>To make this mapping available to the fallback buffer, the <ph id="ph1">`CustomMapper`</ph> instance is passed as a parameter to the <ph id="ph2">`CustomMapperFallbackBuffer`</ph> class constructor.</source>
          <target state="translated">為了讓後援緩衝區可以使用這項對應，<ph id="ph1">`CustomMapper`</ph> 執行個體會當做參數傳遞給 <ph id="ph2">`CustomMapperFallbackBuffer`</ph> 類別建構函式。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Because the longest mapping is the string "INF" for the Unicode character U+221E, the <ph id="ph1">`MaxCharCount`</ph> property returns 3.</source>
          <target state="translated">由於最長的對應是代表 Unicode 字元 U+221E 的字串 "INF"，因此 <ph id="ph1">`MaxCharCount`</ph> 屬性會傳回 3。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The following code defines the <ph id="ph1">`CustomMapperFallbackBuffer`</ph> class, which is derived from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>.</source>
          <target state="translated">下列程式碼會定義 <ph id="ph1">`CustomMapperFallbackBuffer`</ph> 類別，該類別衍生自 <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The dictionary that contains best-fit mappings and that is defined in the <ph id="ph1">`CustomMapper`</ph> instance is available from its class constructor.</source>
          <target state="translated">包含自動調整對應並在 <ph id="ph1">`CustomMapper`</ph> 執行個體中定義的字典可從其類別建構函式取得。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`Fallback`</ph> method returns <ph id="ph2">`true`</ph> if any of the Unicode characters that the ASCII encoder cannot encode are defined in the mapping dictionary; otherwise, it returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">如果 ASCII 編碼器無法編碼的任何 Unicode 字元是在對應字典中定義，則其 <ph id="ph1">`Fallback`</ph> 方法會傳回 <ph id="ph2">`true`</ph>，否則會傳回 <ph id="ph3">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>For each fallback, the private <ph id="ph1">`count`</ph> variable indicates the number of characters that remain to be returned, and the private <ph id="ph2">`index`</ph> variable indicates the position in the string buffer, <ph id="ph3">`charsToReturn`</ph>, of the next character to return.</source>
          <target state="translated">針對每個後援，私用 <ph id="ph1">`count`</ph> 變數會指出要傳回的剩餘字元數，而私用 <ph id="ph2">`index`</ph> 變數會指出要傳回的下一個字元在字串緩衝區 <ph id="ph3">`charsToReturn`</ph> 中的位置。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The following code then instantiates the <ph id="ph1">`CustomMapper`</ph> object and passes an instance of it to the <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> method.</source>
          <target state="translated">接著，下列程式碼會執行個體化 <ph id="ph1">`CustomMapper`</ph> 物件，並將該物件的執行個體傳遞給 <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> 方法。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The output indicates that the best-fit fallback implementation successfully handles the three non-ASCII characters in the original string.</source>
          <target state="translated">輸出會指出，自動調整後援實作成功處理原始字串中這三個非 ASCII 字元。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">請參閱</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.Encoder<ept id="p1">](xref:System.Text.Encoder)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.Encoder<ept id="p1">](xref:System.Text.Encoder)</ept></target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept></target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.Decoder<ept id="p1">](xref:System.Text.Decoder)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.Decoder<ept id="p1">](xref:System.Text.Decoder)</ept></target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.DecoderFallback<ept id="p1">](xref:System.Text.DecoderFallback)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.DecoderFallback<ept id="p1">](xref:System.Text.DecoderFallback)</ept></target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>