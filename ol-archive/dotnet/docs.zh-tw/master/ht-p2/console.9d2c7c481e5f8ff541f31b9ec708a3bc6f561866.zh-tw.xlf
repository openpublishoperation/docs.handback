<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fd610bdba56679dd522149d8e91dc91858c7f7ed</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\docker\console.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02fa0bc4ba65f75936d48f81291b670aaf3252bd</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">162574602fe8f99a96301753884af51f1a88574c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Running Console applications in Docker</source>
          <target state="translated">在 Docker 中執行主控台應用程式</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn how to take an existing .NET Framework console application and run it in a Windows Docker container.</source>
          <target state="translated">了解如何擷取現有的 .NET Framework 主控台應用程式並在 Windows Docker 容器中執行。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, Container, Console, Applications</source>
          <target state="translated">.NET, 容器, 主控台, 應用程式</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Running console applications in Windows containers</source>
          <target state="translated">在 Windows 容器中執行主控台應用程式</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Console applications are used for many purposes; from simple querying of a status to long running document image processing tasks.</source>
          <target state="translated">主控台應用程式的用途有許多種；從簡單的狀態查詢，到長時間執行的文件影像處理工作。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In any case, the ability to start up and scale these applications are met with limitations of hardware acquisitions, startup times or running multiple instances.</source>
          <target state="translated">在任何情況下，您都可以啟動並調整這些應用程式的規模，但具有硬體取得、啟動時間或執行多個執行個體的限制。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Moving your console applications to use Docker and Windows Server containers allows for starting these applications from a clean state, enabling them to perform the operation and then shutdown cleanly.</source>
          <target state="translated">藉由移動您的主控台應用程式以使用 Docker 和 Windows Server 容器，您就可以從初始狀態啟動這些應用程式，讓這些應用程式執行作業再完全關閉。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This topic will show the steps needed to move a console application to a Windows based container and start it using a PowerShell script.</source>
          <target state="translated">本主題說明將主控台應用程式移至 Windows 容器，再使用 PowerShell 指令碼加以啟動所需的步驟。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The sample console application is a simple example which takes an argument, a question in this case, and returns a random answer.</source>
          <target state="translated">此範例主控台應用程式是接受引數的簡單範例 (在本例中為一個問題)，並傳回隨機答案。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This could take a <ph id="ph1">`customer_id`</ph> and process their taxes, or create a thumbnail for an <ph id="ph2">`image_url`</ph> argument.</source>
          <target state="translated">這可能會擷取 <ph id="ph1">`customer_id`</ph> 並處理其稅金，或建立 <ph id="ph2">`image_url`</ph> 引數的縮圖。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In addition to the answer, the <ph id="ph1">`Environment.MachineName`</ph> has been added to the response to show the difference between running the application locally and in a Windows container.</source>
          <target state="translated">除了答案之外，也已將 <ph id="ph1">`Environment.MachineName`</ph> 加入回應，以顯示在本機執行應用程式與在 Windows 容器中執行應用程式之間的差異。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>When running the application locally, your local machine name should be returned and when running in a Windows Container; the container session id is returned.</source>
          <target state="translated">在本機執行應用程式時，應該傳回您的本機電腦名稱；在 Windows 容器中執行時，則會傳回容器的工作階段識別碼。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The complete example is available in the <bpt id="p1">[</bpt>dotnet/core-docs repository on GitHub<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/framework/docker/ConsoleRandomAnswerGenerator)</ept>.</source>
          <target state="translated">完整範例可在 <bpt id="p1">[</bpt>GitHub 上的 dotnet/core-docs 儲存機制<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/framework/docker/ConsoleRandomAnswerGenerator)</ept>取得。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You need to be familiar with some Docker terms before you begin working on moving your application to a container.</source>
          <target state="translated">您必須先熟悉一些 Docker 術語，才能開始將應用程式移至容器的工作。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>Docker image<ept id="p1">*</ept> is a read-only template that defines the environment for a running container, including the operating system (OS), system components, and application(s).</source>
          <target state="translated">「Docker 映像」是唯讀範本，為執行中容器定義環境，包括作業系統 (OS)、系統元件和應用程式。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>One important feature of Docker images is that images are composed from a base image.</source>
          <target state="translated">Docker 映像的一個重要特性是這些映像會從基礎映像組成。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Each new image adds a small set of features to an existing image.</source>
          <target state="translated">每個新的映像會將一小組功能加入現有的映像。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>Docker container<ept id="p1">*</ept> is a running instance of an image.</source>
          <target state="translated">「Docker 容器」是映像的執行中執行個體。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You scale an application by running the same image in many containers.</source>
          <target state="translated">您可以在許多容器中執行相同的映像，來調整應用程式的規模。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Conceptually, this is similar to running the same application in multiple hosts.</source>
          <target state="translated">就概念而言，這類似於在多部主機中執行相同的應用程式。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You can learn more about the Docker architecture by reading the <bpt id="p1">[</bpt>Docker Overview<ept id="p1">](https://docs.docker.com/engine/understanding-docker/)</ept> on the Docker site.</source>
          <target state="translated">您可以閱讀 Docker 網站上的 <bpt id="p1">[</bpt>Docker Overview<ept id="p1">](https://docs.docker.com/engine/understanding-docker/)</ept>，以深入了解 Docker 架構。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Moving your console application is a matter of a few steps.</source>
          <target state="translated">只需要幾個步驟，就可以移動您的主控台應用程式。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Build the application<ept id="p1">](#building-the-application)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>建置應用程式<ept id="p1">](#building-the-application)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Creating a Dockerfile for the image<ept id="p1">](#creating-the-dockerfile)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>建立映像的 Dockerfile<ept id="p1">](#creating-the-dockerfile)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Process to build and run the Docker container<ept id="p1">](#creating-the-image)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>建置及執行 Docker 容器的程序<ept id="p1">](#creating-the-image)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">必要條件</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Windows containers are supported on <bpt id="p1">[</bpt>Windows 10 Anniversary Update<ept id="p1">](https://www.microsoft.com/en-us/software-download/windows10/)</ept> or <bpt id="p2">[</bpt>Windows Server 2016<ept id="p2">](https://www.microsoft.com/en-us/cloud-platform/windows-server)</ept>.</source>
          <target state="translated">Windows 容器受到 <bpt id="p1">[</bpt>Windows 10 年度更新版<ept id="p1">](https://www.microsoft.com/en-us/software-download/windows10/)</ept>或 <bpt id="p2">[</bpt>Windows Server 2016<ept id="p2">](https://www.microsoft.com/en-us/cloud-platform/windows-server)</ept> 的支援。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you are using Windows Server 2016, you must enable containers manually since the Docker for Windows installer will not enable the feature.</source>
          <target state="translated">如果您使用 Windows Server 2016，您必須手動啟用容器，因為 Docker for Windows 安裝程式不會啟用此功能。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Make sure all updates have run for the OS and then follow the instructions from the <bpt id="p1">[</bpt>Container Host Deployment<ept id="p1">](https://msdn.microsoft.com/en-us/virtualization/windowscontainers/deployment/deployment)</ept> article to install the containers and Docker features.</source>
          <target state="translated">請務必對作業系統執行所有更新，然後遵循<bpt id="p1">[</bpt>容器主機部署<ept id="p1">](https://msdn.microsoft.com/en-us/virtualization/windowscontainers/deployment/deployment)</ept>一文中的指示來安裝容器和 Docker 功能。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You need to have Docker for Windows, version 1.12 Beta 26 or higher to support Windows containers.</source>
          <target state="translated">您需要有 Docker for Windows 1.12 Beta 26 版或更高版本，才能支援 Windows 容器。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>By default, Docker enables Linux based containers; switch to Windows containers by right clicking the Docker icon in the system tray and select <bpt id="p1">**</bpt>Switch to Windows containers<ept id="p1">**</ept>.</source>
          <target state="translated">Docker 預設會啟用 Linux 容器；請以滑鼠右鍵按一下系統匣中的 Docker 圖示，然後選取 [切換至 Windows 容器]，以切換至 Windows 容器。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Docker will run the process to change and a restart may be required.</source>
          <target state="translated">Docker 將會執行變更程序，而且可能需要重新啟動。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Windows-Containers</source>
          <target state="translated">Windows-Containers</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Building the application</source>
          <target state="translated">建置應用程式</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Typically console applications are distributed through an installer, FTP, or File Share deployment.</source>
          <target state="translated">主控台應用程式通常是透過安裝程式、FTP 或檔案共用部署來散發。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>When deploying to a container, the assets need to be compiled and staged to a location that can be used when the Docker image is created.</source>
          <target state="translated">部署至容器時，這些資產必須加以編譯並暫存到建立 Docker 映像時可使用的位置。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In <bpt id="p1">*</bpt>build.ps1<ept id="p1">*</ept>, the script uses <bpt id="p2">[</bpt>MSBuild<ept id="p2">](https://msdn.microsoft.com/en-us/library/dd393574.aspx)</ept> to compile the application to complete the task of building the assets.</source>
          <target state="translated">在 <bpt id="p1">*</bpt>build.ps1<ept id="p1">*</ept> 中，指令碼會使用 <bpt id="p2">[</bpt>MSBuild<ept id="p2">](https://msdn.microsoft.com/en-us/library/dd393574.aspx)</ept> 來編譯應用程式，以完成建立資產的工作。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>There are a few parameters passed to MSBuild to finalize the needed assets.</source>
          <target state="translated">您可以將幾個參數傳遞至 MSBuild，以確定所需的資產。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The name of the project file or solution to be compiled, the location for the output and finally the configuration (Release or Debug).</source>
          <target state="translated">像是要編譯的專案檔或方案名稱，輸出的位置，以及最後的組態 (發行或偵錯)。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the call to <ph id="ph1">`Invoke-MSBuild`</ph> the <ph id="ph2">`OutputPath`</ph> is set to <bpt id="p1">**</bpt>publish<ept id="p1">**</ept> and  <ph id="ph3">`Configuration`</ph> set to <bpt id="p2">**</bpt>Release<ept id="p2">**</ept>.</source>
          <target state="translated">在 <ph id="ph1">`Invoke-MSBuild`</ph> 的呼叫中，<ph id="ph2">`OutputPath`</ph> 會設定為 <bpt id="p1">**</bpt>publish<ept id="p1">**</ept>，而 <ph id="ph3">`Configuration`</ph> 會設定為 [發行]。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Creating the Dockerfile</source>
          <target state="translated">建立 Dockerfile</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The base image used for a console .NET Framework application is <ph id="ph1">`microsoft/windowsservercore`</ph>, publicly available on <bpt id="p1">[</bpt>Docker Hub<ept id="p1">](https://hub.docker.com/r/microsoft/windowsservercore/)</ept>.</source>
          <target state="translated">.NET Framework 主控台應用程式所使用的基礎映像為 <ph id="ph1">`microsoft/windowsservercore`</ph>，會在 <bpt id="p1">[</bpt>Docker Hub<ept id="p1">](https://hub.docker.com/r/microsoft/windowsservercore/)</ept> 上公開提供。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The base image contains a minimal installation of Windows Server 2016, .NET Framework 4.6.2 and serves as the base OS image for Windows Containers.</source>
          <target state="translated">基礎映像包含 Windows Server 2016 的最小安裝 .NET Framework 4.6.2，可作為 Windows 容器的基礎作業系統映像。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The first line in the Dockerfile designates the base image using the <bpt id="p1">[</bpt><ph id="ph1">`FROM`</ph><ept id="p1">](https://docs.docker.com/engine/reference/builder/#/from)</ept> instruction.</source>
          <target state="translated">Docerkfile 中的第一行會使用 <bpt id="p1">[</bpt><ph id="ph1">`FROM`</ph><ept id="p1">](https://docs.docker.com/engine/reference/builder/#/from)</ept> 指令來指定基礎映像。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Next, <bpt id="p1">[</bpt><ph id="ph1">`ADD`</ph><ept id="p1">](https://docs.docker.com/engine/reference/builder/#/add)</ept> in the file copies the application assets from the <bpt id="p2">**</bpt>publish<ept id="p2">**</ept> folder to root folder of the container and last; setting the <bpt id="p3">[</bpt><ph id="ph2">`ENTRYPOINT`</ph><ept id="p3">](https://docs.docker.com/engine/reference/builder/#/entrypoint)</ept> of the image states that this is the command or application that will run when the container starts.</source>
          <target state="translated">接下來，檔案中的 <bpt id="p1">[</bpt><ph id="ph1">`ADD`</ph><ept id="p1">](https://docs.docker.com/engine/reference/builder/#/add)</ept> 會將應用程式資產從 <bpt id="p2">**</bpt>publish<ept id="p2">**</ept> 資料夾複製到容器的根資料夾；最後設定映像狀態的 <bpt id="p3">[</bpt><ph id="ph2">`ENTRYPOINT`</ph><ept id="p3">](https://docs.docker.com/engine/reference/builder/#/entrypoint)</ept>，這是容器啟動時將執行的命令或應用程式。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Creating the image</source>
          <target state="translated">建立映像</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>In order to create the Docker image, the following code is added to the <bpt id="p1">*</bpt>build.ps1<ept id="p1">*</ept> script.</source>
          <target state="translated">若要建立 Docker 映像，請將下列程式碼加入 <bpt id="p1">*</bpt>build.ps1<ept id="p1">*</ept> 指令碼。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>When the script is run, the <ph id="ph1">`console-random-answer-generator`</ph> image is created using the assets compiled from MSBuild defined in the <bpt id="p1">[</bpt>Building the application<ept id="p1">](#building-the-application)</ept> section.</source>
          <target state="translated">執行指令碼時，會使用從 MSBuild 編譯的資產來建立 <ph id="ph1">`console-random-answer-generator`</ph> 映像，如<bpt id="p1">[</bpt>建置應用程式<ept id="p1">](#building-the-application)</ept>一節中所定義。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Run the script using <ph id="ph1">`.\build.ps1`</ph> from the PowerShell command prompt.</source>
          <target state="translated">從 PowerShell 命令提示字元使用 <ph id="ph1">`.\build.ps1`</ph> 來執行指令碼。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>When the build is complete, using the <ph id="ph1">`docker images`</ph> command from a command line or PowerShell prompt; you'll see that the image is created and ready to be run.</source>
          <target state="translated">建置完成時，從命令列或 PowerShell 命令提示字元使用 <ph id="ph1">`docker images`</ph> 命令；您將會看到映像已建立並準備好執行。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Running the container</source>
          <target state="translated">執行容器</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can start the container from the command line using the Docker commands.</source>
          <target state="translated">您可以從命令列使用 Docker 命令來啟動容器。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The output is</source>
          <target state="translated">輸出為</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If you run the <ph id="ph1">`docker ps -a`</ph> command from PowerShell, you can see that the container still exists.</source>
          <target state="translated">如果您從 PowerShell 執行 <ph id="ph1">`docker ps -a`</ph> 命令，您會看到容器仍然存在。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The STATUS column shows at "About a minute ago", the application was complete and could be shut down.</source>
          <target state="translated">[狀態] 欄顯示在「約一分鐘前」，應用程式已完成並可以關閉。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If the command was run a hundred times, there would be a hundred containers left static with no work to do.</source>
          <target state="translated">如果執行此命令一百次，則會有一百個容器保持靜態且沒有可執行的工作。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the beginning scenario the ideal operation was to do the work and shutdown or cleanup.</source>
          <target state="translated">在一開始的案例中，理想作業是執行工作並關閉或清除。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>To accomplish that workflow, adding the <ph id="ph1">`--rm`</ph> option to the <ph id="ph2">`docker run`</ph> command will remove the container as soon as the <ph id="ph3">`Exited`</ph> signal is received.</source>
          <target state="translated">若要完成該工作流程，將 <ph id="ph1">`--rm`</ph> 選項 <ph id="ph2">`docker run`</ph> 加入命令會在收到 <ph id="ph3">`Exited`</ph> 訊號時立即移除容器。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Running the command with this option and then looking at the output of <ph id="ph1">`docker ps -a`</ph> command; notice that the container id (the <ph id="ph2">`Environment.MachineName`</ph>) is not in the list.</source>
          <target state="translated">執行命令並搭配此選項，然後檢視 <ph id="ph1">`docker ps -a`</ph> 命令的輸出；請注意，容器識別碼 (<ph id="ph2">`Environment.MachineName`</ph>) 不在清單中。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Running the container using PowerShell</source>
          <target state="translated">使用 PowerShell 執行容器</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>In the sample project files there is also a <bpt id="p1">*</bpt>run.ps1<ept id="p1">*</ept> which is an example of how to use PowerShell to run the application accepting the arguments.</source>
          <target state="translated">在範例專案檔中，還有 <bpt id="p1">*</bpt>run.ps1<ept id="p1">*</ept>，此範例示範如何使用 PowerShell 來執行接受引數的應用程式。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>To run, open PowerShell and use the following command:</source>
          <target state="translated">若要執行，請開啟 PowerShell 並使用下列命令：</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">總結</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Just by adding a Dockerfile and publishing the application, you can containerize your .NET Framework console applications and now take the advantage of running multiple instances, clean start and stop and more Windows Server 2016 capabilities without making any changes to the application code at all.</source>
          <target state="translated">只要加入 Dockerfile 並發行應用程式，您就可以容器化 .NET Framework 主控台應用程式，並立即利用執行多個執行個體、正常啟動和停止及更多 Windows Server 2016 功能，完全不需要對應用程式程式碼進行任何變更。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>