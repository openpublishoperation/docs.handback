<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05f692a1a58c0c653e14993cafd61a0711ebf9f8</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\collections\threadsafe\when-to-use-a-thread-safe-collection.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">098df41a5c9d3bf053e5ec0a9b66a8b09370dce9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c0d22f0ce489c88a93f20d033de66644d3cf51d7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>When to Use a Thread-Safe Collection</source>
          <target state="translated">使用安全執行緒集合的時機</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>When to Use a Thread-Safe Collection</source>
          <target state="translated">使用安全執行緒集合的時機</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>When to Use a Thread-Safe Collection</source>
          <target state="translated">使用安全執行緒集合的時機</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ConcurrentQueue`</ph>, <ph id="ph2">`ConcurrentStack`</ph>, <ph id="ph3">`ConcurrentDictionary`</ph>, <ph id="ph4">`ConcurrentBag`</ph>, and <ph id="ph5">`BlockingCollection`</ph> collection types are specially designed to support multi-threaded add and remove operations.</source>
          <target state="translated"><ph id="ph1">`ConcurrentQueue`</ph>、<ph id="ph2">`ConcurrentStack`</ph>、<ph id="ph3">`ConcurrentDictionary`</ph>、<ph id="ph4">`ConcurrentBag`</ph> 和 <ph id="ph5">`BlockingCollection`</ph> 集合類型是特別設計來支援多執行緒新增和移除作業。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms.</source>
          <target state="translated">若要達到執行緒安全，這些新的類型會使用各種有效率的鎖定和無鎖定同步處理機制。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Synchronization adds overhead to an operation.</source>
          <target state="translated">同步處理會增加作業的負荷。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</source>
          <target state="translated">負荷量取決於使用的同步處理類型、執行的作業類型，以及其他因素 (例如，嘗試同時存取集合的執行緒數目)。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</source>
          <target state="translated">在某些情況下，同步處理負荷會顯得微不足道，並且在受到外部鎖定保護時，讓多執行緒類型執行速度大幅加快，而且擴充的狀況遠優於其非安全執行緒對等項目。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</source>
          <target state="translated">在其他情況下，負荷可能會讓安全執行緒類型的執行和擴充速度等於甚於比外部鎖定之非安全執行緒版本的類型還要慢。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</source>
          <target state="translated">下列各節所提供的一般指引是有關何時使用安全執行緒集合，與其具有使用者所提供之讀取和寫入作業鎖定的非安全執行緒對等項目。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</source>
          <target state="translated">因為效能可能會因許多因素而不同，所以本指南不是特定的，也不一定適用於所有情況。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</source>
          <target state="translated">如果效能十分重要，則決定要使用之集合類型的最佳方式是根據代表性電腦組態和負載來測量效能。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This document uses the following terms:</source>
          <target state="translated">本範例使用下列詞彙：</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Pure producer-consumer scenario:<ept id="p1">*</ept> Any given thread is either adding or removing elements, but not both.</source>
          <target state="translated"><bpt id="p1">*</bpt>單純生產者-消費者案例︰<ept id="p1">*</ept>任何指定的執行緒都是新增或移除元素，而非同時執行兩項作業。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Mixed producer-consumer scenario:<ept id="p1">*</ept> Any given thread is both adding and removing elements.</source>
          <target state="translated"><bpt id="p1">*</bpt>混合生產者-消費者案例︰<ept id="p1">*</ept>任何指定的執行緒都是新增和移除元素。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Speedup:<ept id="p1">*</ept> Faster algorithmic performance relative to another type in the same scenario.</source>
          <target state="translated"><bpt id="p1">*</bpt>加速︰<ept id="p1">*</ept>相對於相同案例中的另一種類型，具有較快速的演算法效能。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Scalability:<ept id="p1">*</ept> The increase in performance that is proportional to the number of cores on the computer.</source>
          <target state="translated"><bpt id="p1">*</bpt>擴充性：<ept id="p1">*</ept>效能會隨著電腦上的核心數目等比例地增加。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>An algorithm that scales performs faster on eight cores than it does on two cores.</source>
          <target state="translated">在八個核心上進行擴充之演算法的執行速度，比兩個核心還要快。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> vs. Queue<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph></source>
          <target state="translated">ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> 與Queue<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> can offer modest performance benefits over a <bpt id="p2">[</bpt>System.Collections.Generic.Queue<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Queue-1)</ept> that has an external lock.</source>
          <target state="translated">在每個元素的處理時間都很小 (幾個指示) 的單純生產者-消費者案例中，<bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> 可以透過具有外部鎖定的 <bpt id="p2">[</bpt>System.Collections.Generic.Queue<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Queue-1)</ept> 提供適度的效能優點。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In this scenario, <ph id="ph1">`ConcurrentQueue&lt;T&gt;`</ph> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</source>
          <target state="translated">在此案例中，如果一個專用執行緒正在置入佇列，而且一個專用執行緒正在移出佇列，則 <ph id="ph1">`ConcurrentQueue&lt;T&gt;`</ph> 的執行效果最好。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>If you do not enforce this rule, then <ph id="ph1">`Queue&lt;T&gt;`</ph> might even perform slightly faster than <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph> on computers that have multiple cores.</source>
          <target state="translated">如果您未強制執行這項規則，則 <ph id="ph1">`Queue&lt;T&gt;`</ph> 的執行速度甚至會略高於具有多個核心之電腦上的 <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <ph id="ph1">`ConcurrentQueue&lt;T&gt;`</ph>, which then has very good scalability.</source>
          <target state="translated">處理時間約 500 個 FLOPS (浮點作業) 或以上時，雙執行緒規則不適用於 <ph id="ph1">`ConcurrentQueue&lt;T&gt;`</ph>，因此具有極佳的擴充性。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Queue&lt;T&gt;`</ph> does not scale well in this scenario.</source>
          <target state="translated">在此案例中，<ph id="ph1">`Queue&lt;T&gt;`</ph> 不會加以適當調整。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In mixed producer-consumer scenarios, when the processing time is very small, a <ph id="ph1">`Queue&lt;T&gt;`</ph> that has an external lock scales better than <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph> does.</source>
          <target state="translated">在混合生產者-消費者案例中，處理時間很小時，具有外部鎖定的 <ph id="ph1">`Queue&lt;T&gt;`</ph> 所進行的擴充優於 <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>However, when processing time is around 500 FLOPS or more, then the <ph id="ph1">`ConcurrentQueue&lt;T&gt;`</ph> scales better.</source>
          <target state="translated">不過，處理時間大約 500 FLOPS 或以上時，則 <ph id="ph1">`ConcurrentQueue&lt;T&gt;`</ph> 會進行較佳的擴充。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>ConcurrentStack vs. Stack</source>
          <target state="translated">ConcurrentStack 與堆疊</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In pure producer-consumer scenarios, when processing time is very small, then <bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentStack<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> and <bpt id="p2">[</bpt>System.Collections.Generic.Stack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Stack-1)</ept> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</source>
          <target state="translated">在處理時間很小的單純生產者-消費者案例中，<bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentStack<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> 和具有外部鎖定的 <bpt id="p2">[</bpt>System.Collections.Generic.Stack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Stack-1)</ept> 所執行的作業可能會與使用一個專用推送執行緒和一個專用彈出執行緒相同。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>However, as the number of threads increases, both types slow down because of increased contention, and <ph id="ph1">`Stack&lt;T&gt;`</ph> might perform better than <ph id="ph2">`ConcurrentStack&lt;T&gt;`</ph>.</source>
          <target state="translated">不過，執行緒數目增加時，兩種類型都會因競爭增加而變慢，而且 <ph id="ph1">`Stack&lt;T&gt;`</ph> 的執行效果可能會優於 <ph id="ph2">`ConcurrentStack&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</source>
          <target state="translated">處理時間大約 500 FLOPS 或以上時，兩種類型幾乎會以相同的速率進行擴充。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In mixed producer-consumer scenarios, <ph id="ph1">`ConcurrentStack&lt;T&gt;`</ph> is faster for both small and large workloads.</source>
          <target state="translated">在混合生產者-消費者案例中，針對大型和小型工作負載，<ph id="ph1">`ConcurrentStack&lt;T&gt;`</ph> 較為快速。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The use of the <ph id="ph1">`PushRange`</ph> and <ph id="ph2">`TryPopRange`</ph> may greatly speed up access times.</source>
          <target state="translated">使用 <ph id="ph1">`PushRange`</ph> 和 <ph id="ph2">`TryPopRange`</ph> 可能會大幅加速存取時間。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>ConcurrentDictionary vs. Dictionary</source>
          <target state="translated">ConcurrentDictionary 與字典</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In general, use a <bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2)</ept> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</source>
          <target state="translated">一般而言，<bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2)</ept> 是用於同時從多個執行緒新增和更新索引鍵或值時。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>In scenarios that involve frequent updates and relatively few reads, the <ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> generally offers modest benefits.</source>
          <target state="translated">在經常更新且讀取相對較少的情況下，<ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> 一般會提供適度優點。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In scenarios that involve many reads and many updates, the <ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> generally is significantly faster on computers that have any number of cores.</source>
          <target state="translated">在進行許多讀取和更新的情況下，<ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> 在具有任意數目之核心的電腦上明顯較快。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>In scenarios that involve frequent updates, you can increase the degree of concurrency in the <ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> and then measure to see whether performance increases on computers that have more cores.</source>
          <target state="translated">在需要經常更新的情況下，您可以增加 <ph id="ph1">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> 中的並行程度，然後測量以查看具有更多核心之電腦的效能是否增加。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If you change the concurrency level, avoid global operations as much as possible.</source>
          <target state="translated">如果您變更並行層級，請盡可能避免全域作業。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If you are only reading key or values, the <bpt id="p1">[</bpt>System.Collections.Generic.Dictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2)</ept> is faster because no synchronization is required if the dictionary is not being modified by any threads.</source>
          <target state="translated">如果您只是要讀取索引鍵或值，則 <bpt id="p1">[</bpt>System.Collections.Generic.Dictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2)</ept> 的速度會較快，原因是沒有任何執行緒修改字典時就不需要進行同步處理。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>ConcurrentBag</source>
          <target state="translated">ConcurrentBag</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In pure producer-consumer scenarios, <bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentBag<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept> will probably perform more slowly than the other concurrent collection types.</source>
          <target state="translated">在單純生產者-消費者案例中，<bpt id="p1">[</bpt>System.Collections.Concurrent.ConcurrentBag<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept> 的執行速度可能會比其他並行集合類型還要慢。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In mixed producer-consumer scenarios, <ph id="ph1">`ConcurrentBag&lt;T&gt;`</ph> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</source>
          <target state="translated">在混合生產者-消費者案例中，針對大型和小型工作負載，<ph id="ph1">`ConcurrentBag&lt;T&gt;`</ph> 一般都會比任何其他並行集合類型更為快速也更具擴充性。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>BlockingCollection</source>
          <target state="translated">BlockingCollection</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>When bounding and blocking semantics are required, <bpt id="p1">[</bpt>System.Collections.Concurrent.BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> will probably perform faster than any custom implementation.</source>
          <target state="translated">需要界限和封鎖語意時，<bpt id="p1">[</bpt>System.Collections.Concurrent.BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> 的執行速度可能會比任何自訂實作還要快。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>It also supports rich cancellation, enumeration, and exception handling.</source>
          <target state="translated">它也支援大量取消、列舉和例外狀況處理。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">另請參閱</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept></target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Thread-Safe Collections<ept id="p1">](index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>安全執行緒集合<ept id="p1">](index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>