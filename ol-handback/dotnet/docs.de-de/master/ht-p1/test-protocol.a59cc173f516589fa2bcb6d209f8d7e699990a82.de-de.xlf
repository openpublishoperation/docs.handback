<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a35385cbb08614493fdcfc74504b00178dc532ea</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tools\test-protocol.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">571f9ba49be9fc4a0d1dd23f2457b2087630460a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc71dad02f1e86873b9019185f14ff3375d92ce9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">.NET Core-CLI-Testkommunikationsprotokoll</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">.NET Core-CLI-Testkommunikationsprotokoll</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">.NET Core-CLI-Testkommunikationsprotokoll</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Einführung</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Anytime you pass a port to dotnet test, the command will run in design time.</source>
          <target state="translated">Jedes Mal, wenn Sie einen Port an dotnet test übergeben, wird der Befehl in der Entwurfszeit durchgeführt.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>That means that dotnet test will connect to that port using TCP and will then exchange an established set of messages with whatever else is connected to that port.</source>
          <target state="translated">Dies bedeutet, dass dotnet test sich mit diesem Port mithilfe von TCP verbindet, und dann einen eingerichteten Satz an Meldungen mit allem austauchen, was mit diesem Port verbunden ist.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When this happens, the runner also receives a new port that dotnet test will use to communicate with it.</source>
          <target state="translated">In diesem Fall erhält der Runner auch einen neuen Port, der von dotnet test für die Kommunikation verwendet wird.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The reason why the runner also uses TCP to communicate with dotnet test is because in design mode, it is not sufficient to just output results to the console.</source>
          <target state="translated">Der Runner verwendet auch TCP, um mit dotnet test zu kommunizieren, da es im Entwurfsmodus nicht ausreichend ist, die Ergebnisse nur in der Konsole auszugeben.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The command needs to send the adapter structure messages containing the results of the test execution.</source>
          <target state="translated">Der Befehl muss die Adapterstrukturmeldungen senden, die die Ergebnisse der Testausführung enthalten.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Communication protocol at design time.</source>
          <target state="translated">Kommunikationsprotokoll zur Entwurfszeit</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Because during design time, dotnet test connects to a port when it starts up, the adapter needs to be listening on that port otherwise dotnet test will fail.</source>
          <target state="translated">Da dotnet test während der Entwurfszeit beim Starten mit einem Port verbunden ist, muss der Adapter diesen Port abhören, da andernfalls dotnet test fehlschlägt.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>We did it like this so that the adapter could reserve all the ports it needs by binding and listening to them before dotnet test ran and tried to get ports for the runner.</source>
          <target state="translated">Der Adapter kann dadurch alle von ihm benötigten Ports reservieren, indem er sich an sie bindet und sie abhört, bevor dotnet test durchgeführt wurde und versucht hat, die Ports für den Runner zu erhalten.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Once dotnet test starts, it sends a TestSession.Connected message to the adapter indicating that it is ready to receive messages.</source>
          <target state="translated">Wenn dotnet test gestartet wird, wird eine TestSession.Connected-Meldung an den Adapter gesendet, die angibt, dass dotnet test von nun an Meldungen empfangen kann.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>It is possible to send an optional <bpt id="p1">[</bpt>version check<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept> message with the adapter version of the protocol in it.</source>
          <target state="translated">Es ist möglich, eine optionale Meldung zur <bpt id="p1">[</bpt>Versionsprüfung<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept> zu senden, die die Adapterversion des Protokolls enthält.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Dotnet test will send back the version of the protocol that it supports.</source>
          <target state="translated">Dotnet test sendet die Version des Protokolls zurück, die unterstützt wird.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>All messages have the format described here: <bpt id="p1">[</bpt>Message.cs<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>.</source>
          <target state="translated">Alle Meldungen verfügen über das Format, das hier beschrieben wird: <bpt id="p1">[</bpt>Message.cs<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The payload formats for each message is described in links to the classes used to serialize/deserialize the information in the description of the protocol.</source>
          <target state="translated">Die Nutzlastformate für jede Meldung wird in Verknüpfungen zu den Klassen beschrieben, die verwendet werden, um die Informationen in der Beschreibung des Protokolls zu serialisieren/deserialisieren.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Test Execution</source>
          <target state="translated">Testausführung</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Test Execution</source>
          <target state="translated">Testausführung</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>After the optional version check, the adapter sends a TestExecution.GetTestRunnerProcessStartInfo, with the <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> it wants to execute inside of it.</source>
          <target state="translated">Nach der optionalen Versionskontrolle sendet der Adapter eine TestExecution.GetTestRunnerProcessStartInfo zusammen mit dem <bpt id="p1">[</bpt>Test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept>, der darin ausgeführt werden soll.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Dotnet test sends back a FileName and Arguments inside a <bpt id="p1">[</bpt>TestStartInfo<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.DotNet.Tools.Test/TestStartInfo.cs)</ept> payload that the adapter can use to start the runner.</source>
          <target state="translated">Dotnet test sendet einen Dateinamen sowie Argumente innerhalb einer <bpt id="p1">[</bpt>TestStartInfo<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.DotNet.Tools.Test/TestStartInfo.cs)</ept>-Nutzlast, die vom Adapter verwendet werden können, um den Runner zu starten.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In the past, we would send the list of tests to run as part of that argument, but we were actually going over the command line size limit for some test projects.</source>
          <target state="translated">In der Vergangenheit wurde die Liste mit auszuführenden Tests als Teil dieses Arguments versendet, jedoch wurde das Größenlimit der Befehlszeile für einige Testprojekte überschritten.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>As part of the arguments, we send a port that the runner should connect to and for executing tests, a --wait-command flag, that indicates that the runner should connect to the port and wait for commands, instead of going ahead and executing the tests.</source>
          <target state="translated">Als Teil des Arguments senden wir einen Port, mit dem sich der Runner verbinden und Tests ausführen soll und ein -wait-Befehlsflag, das angibt, dass der Runner sich mit dem Port verbinden muss und auf Befehle warten soll, anstatt weiter die Testes auszuführen.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>At this point, the adapter can launch the runner (and attach to it for debugging if it chooses to).</source>
          <target state="translated">Zu diesem Zeitpunkt kann der Adapter den Runner starten (und ihn für das Debuggen anhängen, falls gewünscht).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Once the runner starts, it sends dotnet test a TestRunner.WaitCommand message that indicates it is ready to receive commands, at which point dotnet test sends a TestRunner.Execute with the list of <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> to run.</source>
          <target state="translated">Nachdem der Runner gestartet wurde, wird an dotnet test eine TestRunner.WaitCommand-Meldung gesendet, die angibt, dass nun Befehle empfangen werden können. Dotnet test sendet daraufhin einen TestRunner.Execute-Befehl, zusammen mit einer Liste mit auszuführenden <bpt id="p1">[</bpt>Tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This bypasses the command line size limit described above.</source>
          <target state="translated">Damit wird das oben beschriebene Größenlimit für die Befehlszeile umgangen.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The runner then sends dotnet test (and it passes forward to the adapter) a TestExecution.TestStarted for each tests as they start with the <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> information inside of it.</source>
          <target state="translated">Der Runner sendet dann an dotnet test (was an den Adapter übergeben wird) für jeden Test TestExecution.TestStarted , da jeder Test mit der <bpt id="p1">[</bpt>Test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept>-Information gestartet wird.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The runner also sends dotnet test (and it forwards to the adapter) a TestExecution.TestResult for each test with the <bpt id="p1">[</bpt>individual result<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept> of the test.</source>
          <target state="translated">Der Runner sendet dotnet test außerdem ein TestExecution.TestResult für jeden Test mit dem <bpt id="p1">[</bpt>individuellen Ergebnis<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept> des Test (und dieser leitet es an den Adapter weiter).</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>After all tests finish, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestExecution.Completed to the adapter.</source>
          <target state="translated">Nach dem alle Tests abgeschlossen sind, sendet der Runner eine TestRunner.Completed-Meldung an dotnet test, die dotnet test wiederum als TestExecution.Completed an den Adapter sendet.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.</source>
          <target state="translated">Nachdem der Adapter fertig ist, sendet er TestSession.Terminate an dotnet test, wodurch dotnet test heruntergefahren wird.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Test discovery</source>
          <target state="translated">Testermittlung</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Test discovery</source>
          <target state="translated">Testermittlung</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>After the optional version check, the adapter sends a TestDiscovery.Start message.</source>
          <target state="translated">Nach der optionalen Versionsüberprüfung sendet der Adapter eine TestDiscovery.Start-Meldung.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Because in this case, the adapter does not need to attach to the process, dotnet test will start the runner itself.</source>
          <target state="translated">Da der Adapter in diesem Fall nicht an den Prozess angefügt werden muss, startet dotnet test den Runner selbst.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Also, since there is no long list of arguments to be passed to the runner, no --wait-command flag is needed to be passed to the runner.</source>
          <target state="translated">Da zudem keine lange Liste von Argumenten an den Runner übergeben werden muss, muss kein wait-Befehlsflag an den Runner übergeben werden.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>dotnet test only passes a --list argument to the runner, which means the runner should not run the tests, just list them.</source>
          <target state="translated">Dotnet test übergibt nur ein Listenargument an den Runner, d.h. der Runner sollte die Tests nicht ausführen, sondern nur auflisten.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The runner then sends dotnet test (and it passes forward to the adapter) a TestDiscovery.TestFound for each <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> found.</source>
          <target state="translated">Der Runner sendet dann TestDiscovery.TestFound für jeden gefundenen <bpt id="p1">[</bpt>Test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> an dotnet test (und dieser leitet es an den Adapter weiter).</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>After all tests are discovered, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestDiscovery.Completed to the adapter.</source>
          <target state="translated">Nach dem alle Tests ermittelt sind, sendet der Runner eine TestRunner.Completed-Meldung an dotnet test, die dotnet test wiederum als TestDiscovery.Completed an den Adapter sendet.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.</source>
          <target state="translated">Nachdem der Adapter fertig ist, sendet er TestSession.Terminate an dotnet test, wodurch dotnet test heruntergefahren wird.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>