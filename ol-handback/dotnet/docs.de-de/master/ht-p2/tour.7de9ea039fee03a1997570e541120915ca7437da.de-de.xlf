<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02e2fa22e36fd2f6618527ad3c89cbbd8587dfe2</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\tour.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b5d2ad1e76f36733598999f425a89b00a11b9cd</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">486574494fd69fdc2cf6ac253f6e6e902ee27923</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Tour of .NET</source>
          <target state="translated">Einführung in .NET</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>A guided tour through some of the prominent features of the .NET platform.</source>
          <target state="translated">Eine Einführung in einige der wichtigsten Features der .NET-Plattform.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, Tour, Programming Languages, Unsafe, Memory Management, Type Safety, Async</source>
          <target state="translated">.NET, .NET Core, Einführung, Programmiersprachen, unsicher, Speicherverwaltung, Typsicherheit, asynchron</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Tour of .NET</source>
          <target state="translated">Einführung in .NET</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>.NET is a general purpose development platform.</source>
          <target state="translated">.NET ist eine Entwicklungsplattform für allgemeine Zwecke.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It has several key features, such as multiple programming languages, asynchronous and concurrent programming models, and native interoperability which enable a wide range of scenarios across multiple platforms.</source>
          <target state="translated">Sie bietet mehrere wichtige Features, wie verschiedene Programmiersprachen, asynchrone und gleichzeitige Programmiermodelle und native Interoperabilität. Dadurch wird auf unterschiedlichen Plattformen eine Vielzahl von Szenarien ermöglicht.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This article offers a guided tour through some of the key features of the .NET platform.</source>
          <target state="translated">Dieser Artikel bietet eine Einführung in einige der wichtigsten Features der .NET-Plattform.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>.NET Architectural Components<ept id="p1">](components.md)</ept> to learn about each of the architectural "pieces" of .NET and what they're used for.</source>
          <target state="translated">Unter <bpt id="p1">[</bpt>.NET-Architekturkomponenten<ept id="p1">](components.md)</ept> finden Sie Informationen zu den einzelnen Bestandteilen der Architektur und deren Verwendung.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>How to run the code samples</source>
          <target state="translated">Ausführen der Codebeispiele</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To learn how to set up a development environment to run the code samples, check out <bpt id="p1">[</bpt>Getting Started<ept id="p1">](getting-started.md)</ept>.</source>
          <target state="translated">Informationen zum Einrichten einer Entwicklungsumgebung zum Ausführen der Codebeispiele finden Sie unter <bpt id="p1">[</bpt>Erste Schritte<ept id="p1">](getting-started.md)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can copy and paste code samples from this page into your environment to execute them.</source>
          <target state="translated">Sie können Codebeispiele auf dieser Seite kopieren und zum Ausführen in Ihrer Umgebung einfügen.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In the future, this documentation site will have the ability to run these code samples in your browser.</source>
          <target state="translated">Zukünftig wird diese Dokumentationswebsite die Möglichkeit bieten, diese Codebeispiele in Ihrem Browser auszuführen.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Programming languages</source>
          <target state="translated">Programmiersprachen</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>.NET supports multiple programming languages.</source>
          <target state="translated">.NET unterstützt mehrere Programmiersprachen.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>.NET runtimes implement the <bpt id="p1">[</bpt>Common Language Infrastructure (CLI)<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>, which (among other things) specifies a language-independent runtime and language interoperability.</source>
          <target state="translated">.NET-Runtimes implementieren die <bpt id="p1">[</bpt>Common Language Infrastructure (CLI)<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>, die (unter anderem) eine sprachunabhängige Runtime und Spracheninteroperabilität angibt.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This means that you can choose any .NET language to build apps and services on .NET.</source>
          <target state="translated">Dies bedeutet, dass Sie zum Erstellen von Apps und Diensten in .NET eine beliebige .NET-Sprache auswählen können.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic .NET.</source>
          <target state="translated">Microsoft entwickelt und unterstützt aktiv drei .NET-Sprachen: C#, F# und Visual Basic .NET.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages.</source>
          <target state="translated">C# ist einfach, leistungsstark, typsicher und objektorientiert, behält aber gleichzeitig die Ausdruckskraft und Eleganz der C-Sprachen bei.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Anyone familiar with C and similar languages will find few problems in adapting to C#.</source>
          <target state="translated">Wer sich mit C und ähnlichen Sprachen auskennt, wird wenig Probleme bei der Verwendung von C# haben.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>C# Guide<ept id="p1">](../csharp/index.md)</ept> to learn more about C#.</source>
          <target state="translated">Weitere Informationen zu C# finden Sie im <bpt id="p1">[</bpt>Leitfaden für C#<ept id="p1">](../csharp/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</source>
          <target state="translated">F# ist eine plattformübergreifende, funktionsorientierte Programmiersprache, die auch die herkömmliche und imperative Programmierung unterstützt.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>F# Guide<ept id="p1">](../fsharp/index.md)</ept> to learn more about F#.</source>
          <target state="translated">Weitere Informationen zu F# finden Sie im <bpt id="p1">[</bpt>Leitfaden für F#<ept id="p1">](../fsharp/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.</source>
          <target state="translated">Visual Basic ist eine einfach zu erlernende Sprache, mit der Sie eine Vielzahl von Anwendungen erstellen können, die in .NET ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Automatic memory management</source>
          <target state="translated">Automatische Speicherverwaltung</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>.NET uses <bpt id="p1">[</bpt>garbage collection<ept id="p1">](garbagecollection/index.md)</ept> to provide automatic memory management for programs.</source>
          <target state="translated">.NET verwendet <bpt id="p1">[</bpt>Garbage Collection<ept id="p1">](garbagecollection/index.md)</ept>, um eine automatische Speicherverwaltung für Programme bereitzustellen.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.</source>
          <target state="translated">Der Garbage Collector arbeitet bei der Speicherverwaltung mit dem Prinzip der Verzögerung und gibt dem Anwendungsdurchsatz den Vorzug vor dem sofortigen Erfassen von Arbeitsspeicher.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To learn more about the .NET GC, check out <bpt id="p1">[</bpt>Fundamentals of garbage collection (GC)<ept id="p1">](garbagecollection/fundamentals.md)</ept>.</source>
          <target state="translated">Weitere Informationen zur Garbage Collection in .NET finden Sie unter <bpt id="p1">[</bpt>Grundlagen der Garbage Collection (GC)<ept id="p1">](garbagecollection/fundamentals.md)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following two lines both allocate memory:</source>
          <target state="translated">Die beiden folgenden Zeilen weisen Speicher zu:</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>There is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</source>
          <target state="translated">Es gibt kein entsprechendes Schlüsselwort zum Aufheben der Speicherzuweisung, da diese automatisch erfolgt, wenn der Garbage Collector während seiner geplanten Ausführung Arbeitsspeicher freigibt.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Types within a given scope normally go out of scope once a method completes, at which point they can be collected.</source>
          <target state="translated">Typen in einem bestimmten Bereich verlieren normalerweise ihre Gültigkeit, sobald eine Methode beendet ist. An diesem Punkt können sie gesammelt werden.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the <ph id="ph1">`using`</ph> statement:</source>
          <target state="translated">Mit der <ph id="ph1">`using`</ph>-Anweisung können Sie den Garbage Collector darüber informieren, dass ein bestimmtes Objekt noch vor Beendigung der Methode seine Gültigkeit verliert:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L6-L9)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L6-L9)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Once the <ph id="ph1">`using`</ph> block completes, the GC will know that the <ph id="ph2">`stream`</ph> object in the previous example is free to be collected and its memory reclaimed.</source>
          <target state="translated">Sobald der <ph id="ph1">`using`</ph>-Block beendet ist, weiß der Garbage Collector, dass das <ph id="ph2">`stream`</ph>-Objekt im vorherigen Beispiel gesammelt und der verwendete Speicherplatz freigegeben werden kann.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Rules for this have slightly different semantics in F#.</source>
          <target state="translated">Die Regeln dafür haben in F# eine etwas andere Semantik.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>To learn more about resource management in F#, check out <bpt id="p1">[</bpt>Resource Management: The <ph id="ph1">`use`</ph> Keyword<ept id="p1">](../fsharp/language-reference/resource-management-the-use-keyword.md)</ept></source>
          <target state="translated">Weitere Informationen zur Ressourcenverwaltung in F# finden Sie unter <bpt id="p1">[</bpt>Ressourcenverwaltung: <ph id="ph1">`use`</ph>-Schlüsselwort<ept id="p1">](../fsharp/language-reference/resource-management-the-use-keyword.md)</ept></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>One of the less obvious but quite far-reaching features that a garbage collector enables is memory safety.</source>
          <target state="translated">Eines der weniger offensichtlichen, doch ziemlich weitreichenden Features, die durch den Garbage Collector ermöglicht werden, ist die Speichersicherheit.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).</source>
          <target state="translated">Das unveränderliche Merkmal der Speichersicherheit ist sehr einfach: Ein Programm ist speichersicher, wenn es nur auf Arbeitsspeicher zugreift, der zugewiesen (nicht freigegeben) wurde.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Dangling pointers are always bugs, and tracking them down is often quite difficult.</source>
          <target state="translated">Verbleibende Zeiger sind immer Fehler, und es ist häufig schwierig, sie zu finden.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The .NET runtime provides additional services, to complete the promise of memory safety, not naturally offered by a GC.</source>
          <target state="translated">Die .NET-Runtime bietet zusätzliche Dienste, um die Speichersicherheit zu gewährleisten, die von einem Garbage Collector nicht geboten wird.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>It ensures that programs do not index off the end of an array or accessing a phantom field off the end of an object.</source>
          <target state="translated">Sie stellt sicher, dass Programme keine Indizierung über das Ende eines Arrays hinaus durchführen und nicht auf Phantomfelder hinter dem Ende eines Objekts zugreifen.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following example will throw an exception as a result of memory safety.</source>
          <target state="translated">Das folgende Beispiel löst aufgrund der Speichersicherheit eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L11-L12)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L11-L12)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Type safety</source>
          <target state="translated">Typsicherheit</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Objects are allocated in terms of types.</source>
          <target state="translated">Objekte werden in Form von Typen zugeordnet.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The only operations allowed for a given object, and the memory it consumes, are those of its type.</source>
          <target state="translated">Die einzigen Vorgänge, die für ein bestimmtes Objekt zulässig sind, und der Arbeitsspeicher, den dieses Objekt belegt, gehören zum Typ des Objekts.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dog`</ph> type may have <ph id="ph2">`Jump`</ph> and <ph id="ph3">`WagTail`</ph> methods, but not likely a <ph id="ph4">`SumTotal`</ph> method.</source>
          <target state="translated">Ein <ph id="ph1">`Dog`</ph>-Typ kann <ph id="ph2">`Jump`</ph>- und <ph id="ph3">`WagTail`</ph>-Methoden besitzen, wahrscheinlich aber keine <ph id="ph4">`SumTotal`</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A program can only call the declared methods of a given type.</source>
          <target state="translated">Ein Programm kann nur die deklarierten Methoden eines bestimmten Typs aufrufen.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or <ph id="ph1">`object`</ph>).</source>
          <target state="translated">Alle anderen Aufrufe führen entweder zu einem Fehler während der Kompilierung oder zu einer Laufzeitausnahme (bei Verwendung von dynamischen Features oder <ph id="ph1">`object`</ph>).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>.NET languages are object-oriented, with hierarchies of base and derived classes.</source>
          <target state="translated">.NET-Sprachen sind objektorientiert und arbeiten mit Hierarchien aus Basisklassen und abgeleiteten Klassen.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The .NET runtime will only allow object casts and calls that align with the object hierarchy.</source>
          <target state="translated">Die .NET-Runtime lässt nur Objektumwandlungen und -aufrufe zu, die der Objekthierarchie entsprechen.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Remember that every type defined in any .NET language derives from the base <ph id="ph1">`object`</ph> type.</source>
          <target state="translated">Denken Sie daran, dass jeder in einer .NET-Sprache definierte Typ vom <ph id="ph1">`object`</ph>-Basistyp abgeleitet ist.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</source>
          <target state="translated">Mithilfe der Typsicherheit lässt sich auch eine Kapselung erzwingen, indem die Genauigkeit der Accessorschlüsselwörter garantiert wird.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Accessor keywords are artifacts which control access to members of a given type by other code.</source>
          <target state="translated">Accessorschlüsselwörter sind Artefakte, die den Zugriff auf Member eines bestimmten Typs durch anderen Code steuern.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>These are usually used for various kinds of data within a type that are used to manage its behavior.</source>
          <target state="translated">Diese werden üblicherweise für verschiedene Arten von Daten innerhalb eines Typs verwendet, mit denen das Verhalten des Typs verwaltet wird.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>C#, Visual Basic, and F# support local <bpt id="p1">**</bpt>type inference<ept id="p1">**</ept>.</source>
          <target state="translated">C#, Visual Basic und F# unterstützen einen lokalen <bpt id="p1">**</bpt>Typrückschluss<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side.</source>
          <target state="translated">Typrückschluss bedeutet, dass der Compiler den Typ eines Ausdrucks auf der linken Seite aus dem Ausdruck auf der rechten Seite ableitet.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This doesn't mean that the type safety is broken or avoided.</source>
          <target state="translated">Dies bedeutet nicht, dass die Typsicherheit verletzt oder außer Kraft gesetzt wird.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The resulting type <bpt id="p1">**</bpt>has<ept id="p1">**</ept> a strong type with everything that implies.</source>
          <target state="translated">Der resultierende Typ <bpt id="p1">**</bpt>besitzt<ept id="p1">**</ept> einen starken Typ mit allem, was dies impliziert.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Let's rewrite the first two lines of the previous example to introduce type inference.</source>
          <target state="translated">Wir schreiben die ersten beiden Zeilen des vorherigen Beispiels neu, um einen Typrückschluss einzuführen.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Note that the rest of the example is completely the same.</source>
          <target state="translated">Beachten Sie, dass der Rest des Beispiels vollständig gleich bleibt.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>F# has even further type inference capabilities than method-local type inference found in C# and Visual Basic.</source>
          <target state="translated">F# weist sogar noch weitergehende Funktionen für den Typrückschluss auf als den Typrückschluss innerhalb einer Methode wie in C# und Visual Basic.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>To learn more, check out <bpt id="p1">[</bpt>Type Inference<ept id="p1">](../fsharp/language-reference/type-inference.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Typrückschluss<ept id="p1">](../fsharp/language-reference/type-inference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">Delegaten und Lambdas</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Delegates are like C++ function pointers, with a big difference that they are type safe.</source>
          <target state="translated">Delegaten ähneln C++-Funktionszeigern, mit dem großen Unterschied, dass sie typsicher sind.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>They are a kind of disconnected method within the CLR type system.</source>
          <target state="translated">Sie stellen eine Art separater Methode innerhalb des CLR-Typsystems dar.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Regular methods are attached to a class and only directly callable through static or instance calling conventions.</source>
          <target state="translated">Reguläre Methoden werden an eine Klasse angefügt und können nur über statische oder instanzaufrufende Konventionen direkt aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Delegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.</source>
          <target state="translated">Delegaten werden in verschiedenen APIs und an anderen Stellen in der .NET-Welt verwendet, insbesondere über Lambdaausdrücke, die ein Kernstück von LINQ sind.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept> document.</source>
          <target state="translated">Weitere Informationen hierzu finden Sie im Dokument <bpt id="p1">[</bpt>Delegaten und Lambdas<ept id="p1">](delegates-lambdas.md)</ept>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generika</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Generics are a feature that was added in .NET Framework 2.0.</source>
          <target state="translated">Generika wurden in .NET Framework 2.0 ergänzt.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In short, generics allow the programmer to introduce a "type parameter" when designing their classes, that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</source>
          <target state="translated">Kurz gesagt: Generika ermöglichen dem Programmierer, beim Entwerfen der Klassen einen „Typparameter“ einzuführen, über den der Clientcode (die Benutzer des Typs) den genauen Typ angeben kann, der anstelle des Typparameters verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Generics were added to help programmers implement generic data structures.</source>
          <target state="translated">Generika wurden hinzugefügt, um Programmierer beim Implementieren generischer Datenstrukturen zu unterstützen.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Before their arrival, in order for a, say, <ph id="ph1">`List`</ph> type to be generic, it would have to work with elements that were of type <ph id="ph2">`object`</ph>.</source>
          <target state="translated">Vor der Einführung von Generika mussten Programmierer mit Elementen vom Typ <ph id="ph2">`object`</ph> arbeiten, um z.B. den Typ <ph id="ph1">`List`</ph> generisch zu machen.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This would have various performance as well as semantic problems, not to mention possible subtle runtime errors.</source>
          <target state="translated">Das führte zu verschiedenen Probleme hinsichtlich der Leistung und der Semantik, von möglichen Laufzeitfehlern ganz zu schweigen.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <ph id="ph1">`InvalidCastException`</ph> is thrown on working with the list's members.</source>
          <target state="translated">Die bekannteste Variante solcher Fehler tritt auf, wenn eine Datenstruktur z.B. sowohl ganze Zahlen als auch Zeichenfolgen enthält und beim Arbeiten mit den Members der Liste eine <ph id="ph1">`InvalidCastException`</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following sample shows a basic program running using an instance of <ph id="ph1">@System.Collections.Generic.List%601</ph> types.</source>
          <target state="translated">Das folgende Beispiel zeigt ein einfaches Programm, das unter Verwendung einer Instanz von <ph id="ph1">@System.Collections.Generic.List%601</ph>-Typen ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GenericsShort<ept id="p2">](../../samples/csharp/snippets/tour/GenericsShort.csx)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GenericsShort<ept id="p2">](../../samples/csharp/snippets/tour/GenericsShort.csx)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept> article.</source>
          <target state="translated">Weitere Informationen finden Sie im Artikel <bpt id="p1">[</bpt>Generische Typen (Generika) – Übersicht<ept id="p1">](generics.md)</ept>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Async programming</source>
          <target state="translated">Asynchrone Programmierung</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Async programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs.</source>
          <target state="translated">Die asynchrone Programmierung ist ein erstklassiges Konzept in .NET und bietet Unterstützung für asynchrone Vorgänge während der Laufzeit, in den Frameworkbibliotheken und in den .NET-Sprachkonstrukten.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Internally, they are based off of objects (such as <ph id="ph1">`Task`</ph>) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</source>
          <target state="translated">Intern basiert sie auf Objekten (z.B. <ph id="ph1">`Task`</ph>), die davon profitieren, dass das Betriebssystem E/A-gebundene Jobs so effizient wie möglich ausführt.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To learn more about async programming in .NET, start with the <bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept>.</source>
          <target state="translated">Erste Informationen über die asynchrone Programmierung in .NET finden Sie unter <bpt id="p1">[</bpt>Async (Übersicht)<ept id="p1">](async.md)</ept>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ)</source>
          <target state="translated">Sprachintegrierte Abfrage (Language-Integrated Query, LINQ)</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</source>
          <target state="translated">LINQ ist ein Satz leistungsstarker Features für C# und VB, mit denen Sie einfachen, deklarativen Code für Datenvorgänge schreiben können.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!</source>
          <target state="translated">Die Daten können in vielfältiger Form vorliegen (als In-Memory-Objekte, in einer SQL-Datenbank oder in einem XML-Dokument), aber der LINQ-Code unterscheidet sich in der Regel für die verschiedenen Datenquellen nicht.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>To learn more and see some samples, check out <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</source>
          <target state="translated">Weitere Informationen sowie einige Beispiele finden Sie unter <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">Native Interoperabilität</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Every operating system in current use provides a lot of platform support for various programming tasks.</source>
          <target state="translated">Jedes heute verwendete Betriebssystem stellt Plattformunterstützung für verschiedene Aufgaben der Programmierung bereit.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>.NET provides several ways to tap into those APIs.</source>
          <target state="translated">.NET bietet verschiedene Möglichkeiten, diese APIs zu nutzen.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Collectively, this support is called "native interoperability" and in this section we will take a look at how to access native APIs from managed, .NET code.</source>
          <target state="translated">Diese Unterstützung wird als „native Interoperabilität“ bezeichnet, und in diesem Abschnitt geht es darum, wie mit verwaltetem .NET-Code auf native APIs zugegriffen werden kann.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The main way to do native interoperability is via "platform invoke" or P/Invoke for short.</source>
          <target state="translated">Die wichtigste Methode, um native Interoperabilität zu erreichen, erfolgt über einen Plattformaufruf: „P/Invoke“.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>This support in .NET Core is available across Linux and Windows platforms.</source>
          <target state="translated">Die Unterstützung in .NET Core steht für Linux- und Windows-Plattformen zur Verfügung.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Another, Windows-only way of doing native interoperability is known as "COM interop" which is used to work with <bpt id="p1">[</bpt>COM components<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in managed code.</source>
          <target state="translated">Eine andere, nur unter Windows verfügbare Methode zum Erreichen nativer Interoperabilität wird als „COM interop“ bezeichnet und zur Arbeit mit <bpt id="p1">[</bpt>COM-Komponenten<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in verwaltetem Code verwendet.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>It is built on top of P/Invoke infrastructure, but it works in subtly different ways.</source>
          <target state="translated">Die Methode setzt auf der P/Invoke-Infrastruktur auf, funktioniert jedoch etwas anders.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</source>
          <target state="translated">Der Großteil der Interoperabilitätsunterstützung von Mono (und damit auch von Xamarin) für Java und Objective-C ist gleich aufgebaut, verwendet also die gleichen Prinzipien.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept> document.</source>
          <target state="translated">Weitere Informationen dazu finden Sie im Dokument <bpt id="p1">[</bpt>Native Interoperabilität<ept id="p1">](native-interop.md)</ept>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Unsafe code</source>
          <target state="translated">Unsicherer Code</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The CLR enables the ability to access native memory and do pointer arithmetic via <ph id="ph1">`unsafe`</ph> code.</source>
          <target state="translated">Die CLR ermöglicht die Fähigkeit, über <ph id="ph1">`unsafe`</ph>-Code auf nativen Arbeitsspeicher zuzugreifen und Zeigerarithmetik durchzuführen.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>These operations are needed for certain algorithms and system interoperability.</source>
          <target state="translated">Diese Vorgänge werden für bestimmte Algorithmen sowie für die Systeminteroperabilität benötigt.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm.</source>
          <target state="translated">Unsicherer Code ist zwar leistungsstark, aber von seiner Verwendung wird abgeraten, sofern er nicht für die Interoperabilität mit System-APIs oder zur Implementierung des effizientesten Algorithmus erforderlich ist.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety.</source>
          <target state="translated">Unsicherer Code wird in verschiedenen Umgebungen möglicherweise unterschiedlich ausgeführt und bietet auch nicht die Vorteile von Garbage Collector und Typsicherheit.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.</source>
          <target state="translated">Es wird empfohlen, die Verwendung von unsicherem Code so weit wie möglich eingrenzen und den Code sehr gründlich zu testen.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The following example is a modified version of the <ph id="ph1">`ToString()`</ph> method from the <ph id="ph2">`StringBuilder`</ph> class.</source>
          <target state="translated">Das folgende Beispiel zeigt die geänderte Version der <ph id="ph1">`ToString()`</ph>-Methode aus der <ph id="ph2">`StringBuilder`</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>It illustrates how using <ph id="ph1">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:</source>
          <target state="translated">Es veranschaulicht, wie sich durch Verwendung von <ph id="ph1">`unsafe`</ph>-Code effizient ein Algorithmus implementieren lässt, indem Arbeitsspeicherblöcke direkt verschoben werden:</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Unsafe<ept id="p2">](../../samples/csharp/snippets/tour/Unsafe.csx)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Unsafe<ept id="p2">](../../samples/csharp/snippets/tour/Unsafe.csx)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">Nächste Schritte</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If you're interested in a tour of C# features, check out <bpt id="p1">[</bpt>Tour of C#<ept id="p1">](../csharp/tour-of-csharp/index.md)</ept>.</source>
          <target state="translated">Wenn Sie sich für eine Einführung in die C#-Features interessieren, lesen Sie <bpt id="p1">[</bpt>Einführung in C#<ept id="p1">](../csharp/tour-of-csharp/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If you're interested in a tour of F# features, check out <bpt id="p1">[</bpt>Tour of F#<ept id="p1">](../fsharp/tour.md)</ept>.</source>
          <target state="translated">Wenn Sie sich für eine Einführung in die F#-Features interessieren, lesen Sie <bpt id="p1">[</bpt>Einführung in F#<ept id="p1">](../fsharp/tour.md)</ept>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>If you want to get started with writing code of your own, check out <bpt id="p1">[</bpt>Getting Started<ept id="p1">](getting-started.md)</ept>.</source>
          <target state="translated">Wenn Sie damit beginnen möchten, eigenen Code zu schreiben, lesen Sie <bpt id="p1">[</bpt>Erste Schritte<ept id="p1">](getting-started.md)</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>To learn about important components of .NET, check out <bpt id="p1">[</bpt>.NET Architectural Components<ept id="p1">](components.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu wichtigen Komponenten von .NET finden Sie unter <bpt id="p1">[</bpt>.NET-Architekturkomponenten<ept id="p1">](components.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>