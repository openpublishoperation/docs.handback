<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2ea8e71acf861b93a21296c74254b3ca4d977d0a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\statically-compiled-queries-linq-to-xml.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0ac5864adc213bf982ae36d4d54e3cec6879ef92</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a65720e5d19a88ac6ffec0bb2c1a11a5703a808a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Statically Compiled Queries (LINQ to XML) (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Statisch kompilierte Abfragen (LINQ to XML) (Visual Basic) | Microsoft-Dokumentation</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Statically Compiled Queries (LINQ to XML) (Visual Basic)</source>
          <target state="translated">Statisch kompilierte Abfragen (LINQ to XML) (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>One of the most important performance benefits LINQ to XML, as opposed to &lt;xref:System.Xml.XmlDocument&gt;, is that queries in LINQ to XML are statically compiled, whereas XPath queries must be interpreted at run time.</source>
          <target state="translated">Eine der wichtigsten Leistungsvorteile von LINQ to XML, im Gegensatz zur &lt;xref:System.Xml.XmlDocument&gt;, sind Abfragen in LINQ to XML statisch kompiliert wird, während die XPath-Abfragen zur Laufzeit interpretiert werden müssen.&lt;/xref:System.Xml.XmlDocument&gt;</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This feature is built in to LINQ to XML, so you do not have to perform extra steps to take advantage of it, but it is helpful to understand the distinction when choosing between the two technologies.</source>
          <target state="translated">Diese Funktion ist in LINQ to XML integriert, sodass Sie keine zusätzlichen Schritte ausführen müssen, um diesen Vorteil zu nutzen. Es ist jedoch hilfreich, den Unterschied zu verstehen, wenn Sie eine Auswahl zwischen den beiden Technologien treffen.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic explains the difference.</source>
          <target state="translated">In diesem Thema wird der Unterschied erklärt.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Statically Compiled Queries vs. XPath</source>
          <target state="translated">Statisch kompilierte Abfragen und XPath</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The following example shows how to get the descendant elements with a specified name, and with an attribute with a specified value.</source>
          <target state="translated">Im folgenden Beispiel wird gezeigt, wie Sie die Nachfolgerelemente mit einem bestimmten Namen und mit einem Attribut mit einem bestimmten Wert abrufen können.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The following is the equivalent XPath expression:</source>
          <target state="translated">Hier folgt der entsprechende XPath-Ausdruck:</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The query expression in this example is re-written by the compiler to method-based query syntax.</source>
          <target state="translated">Der Abfrageausdruck in diesem Beispiel wird vom Compiler in eine methodenbasierte Abfragesyntax umgeschrieben.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following example, which is written in method-based query syntax, produces the same results as the previous one:</source>
          <target state="translated">Das folgende in methodenbasierter Abfragesyntax geschriebene Beispiel führt zum selben Ergebnis wie das vorherige Beispiel:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Linq.Enumerable.Where%2A&gt; method is an extension method.</source>
          <target state="translated">Die &lt;xref:System.Linq.Enumerable.Where%2A&gt;Methode ist eine Erweiterungsmethode.&lt;/xref:System.Linq.Enumerable.Where%2A&gt;</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Extension Methods<ept id="p1">](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Erweiterungsmethoden<ept id="p1">](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Because &lt;xref:System.Linq.Enumerable.Where%2A&gt; is an extension method, the query above is compiled as though it were written as follows:</source>
          <target state="translated">Da &lt;xref:System.Linq.Enumerable.Where%2A&gt;ist eine Erweiterungsmethode, die obige Abfrage kompiliert, als wäre es wie folgt geschrieben:&lt;/xref:System.Linq.Enumerable.Where%2A&gt;</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This example produces exactly the same results as the previous two examples.</source>
          <target state="translated">Dieses Beispiel führt zu genau den gleichen Ergebnissen wie die beiden vorherigen Beispiele.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This illustrates the fact that queries are effectively compiled into statically linked method calls.</source>
          <target state="translated">Dies veranschaulicht die Tatsache, dass Abfragen tatsächlich zu statisch verknüpften Methodenaufrufen kompiliert werden.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This, combined with the deferred execution semantics of iterators, improves performance.</source>
          <target state="translated">Hierdurch wird, gemeinsam mit der verzögerten Ausführungssemantik von Iteratoren, die Leistung verbessert.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For more information about the deferred execution semantics of iterators, see <bpt id="p1">[</bpt>Deferred Execution and Lazy Evaluation in LINQ to XML (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu der verzögerten Ausführungssemantik von Iteratoren, finden Sie unter <bpt id="p1">[</bpt>verzögerte Ausführung und verzögerte Auswertung in LINQ to XML (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md)</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>These examples are representative of the code that the compiler might write.</source>
          <target state="translated">Diese Beispiele sind für den Code repräsentativ, der möglicherweise vom Compiler geschrieben wird.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The actual implementation might differ slightly from these examples, but the performance will be the same or similar to these examples.</source>
          <target state="translated">Die tatsächliche Implementierung kann in Details von diesen Beispielen abweichen, die Leistung wird jedoch weitgehend mit der dieser Beispiele übereinstimmen.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Executing XPath Expressions with XmlDocument</source>
          <target state="translated">Ausführen von XPath-Ausdrücken mit XmlDocument</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;xref:System.Xml.XmlDocument&gt; to accomplish the same results as the previous examples:</source>
          <target state="translated">Im folgenden Beispiel wird &lt;xref:System.Xml.XmlDocument&gt;um dieselben Ergebnisse wie in den vorherigen Beispielen:&lt;/xref:System.Xml.XmlDocument&gt;</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This query returns the same output as the examples that use LINQ to XML; the only difference is that LINQ to XML indents the printed XML, whereas &lt;xref:System.Xml.XmlDocument&gt; does not.</source>
          <target state="translated">Diese Abfrage gibt dieselbe Ausgabe wie die Beispiele mit LINQ to XML zurück. der einzige Unterschied ist, dass LINQ to XML das gedruckte XML zieht, während &lt;xref:System.Xml.XmlDocument&gt;nicht.&lt;/xref:System.Xml.XmlDocument&gt;</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>However, the &lt;xref:System.Xml.XmlDocument&gt; approach generally does not perform as well as LINQ to XML, because the &lt;xref:System.Xml.XmlNode.SelectNodes%2A&gt; method must do the following internally every time it is called:</source>
          <target state="translated">Allerdings die &lt;xref:System.Xml.XmlDocument&gt;Ansatz in der Regel ist nicht so gut wie LINQ to XML, da die &lt;xref:System.Xml.XmlNode.SelectNodes%2A&gt;Methode führen die folgenden intern jedes Mal, wenn sie aufgerufen wird:&lt;/xref:System.Xml.XmlNode.SelectNodes%2A&gt; &lt;/xref:System.Xml.XmlDocument&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>It parses the string that contains the XPath expression, breaking the string into tokens.</source>
          <target state="translated">Analysieren der Zeichenfolge, die den XPath-Ausdruck enthält, und Zerlegen der Zeichenfolge in Token.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It validates the tokens to make sure that the XPath expression is valid.</source>
          <target state="translated">Überprüfen der Token, um sicherzustellen, dass der XPath-Ausdruck gültig ist.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>It translates the expression into an internal expression tree.</source>
          <target state="translated">Übersetzen des Ausdrucks in eine interne Ausdrucksstruktur.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>It iterates through the nodes, appropriately selecting the nodes for the result set based on the evaluation of the expression.</source>
          <target state="translated">Durchlaufen der Knoten und entsprechendes Auswählen der Knoten für das Resultset auf Grundlage der Ausdrucksauswertung.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This is significantly more than the work done by the corresponding LINQ to XML query.</source>
          <target state="translated">Dies sind bedeutend mehr Arbeitsschritte als bei einer entsprechenden LINQ to XML-Abfrage.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The specific performance difference varies for different types of queries, but in general LINQ to XML queries do less work, and therefore perform better, than evaluating XPath expressions using &lt;xref:System.Xml.XmlDocument&gt;.</source>
          <target state="translated">Die genauen Leistungsunterschiede variiert für verschiedene Arten von Abfragen, aber im Allgemeinen LINQ to XML-Abfragen jedoch weniger Arbeitsschritte und daher besser als das Auswerten von XPath-Ausdrücken mit &lt;xref:System.Xml.XmlDocument&gt;.&lt;/xref:System.Xml.XmlDocument&gt; ausführen.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Siehe auch</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Performance (LINQ to XML) (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/performance-linq-to-xml.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Leistung (LINQ to XML) (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/performance-linq-to-xml.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>