<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6be672acc84a76106e25b82574acad16beb4a8ac</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\common-type-system.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">81fc97852c7bc728b4f35203efecd3a7cc999d94</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">27ebc9a4a8a31450d653e65ed008ffe096e6a0cc</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Common type system in depth</source>
          <target state="translated">Common Type System en profundidad</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Common type system in depth</source>
          <target state="translated">Common Type System en profundidad</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Common type system in depth</source>
          <target state="translated">Common Type System en profundidad</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections that explore the common type system in depth:</source>
          <target state="translated">Este tema contiene las siguientes secciones que exploran Common Type System en profundidad:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types in .NET<ept id="p1">](#types-in-net)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tipos de .NET<ept id="p1">](#types-in-net)</ept></target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type definitions<ept id="p1">](#type-definitions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Definiciones de tipos<ept id="p1">](#type-definitions)</ept></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type members<ept id="p1">](#type-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Miembros de tipos<ept id="p1">](#type-members)</ept></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Characteristics of type members<ept id="p1">](#characteristics-of-type-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Características de los miembros de tipos<ept id="p1">](#characteristics-of-type-members)</ept></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Types in .NET</source>
          <target state="translated">Tipos de .NET</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>All types in .NET are either value types or reference types.</source>
          <target state="translated">Todos los tipos de .NET son tipos de valor o tipos de referencia.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Value types are data types whose objects are represented by the object's actual value.</source>
          <target state="translated">Los tipos de valor son tipos de datos cuyos objetos se representan mediante el valor real del objeto.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If an instance of a value type is assigned to a variable, that variable is given a fresh copy of the value.</source>
          <target state="translated">Si se asigna una instancia de un tipo de valor a una variable, esa variable obtiene una copia reciente del valor.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Reference types are data types whose objects are represented by a reference (similar to a pointer) to the object's actual value.</source>
          <target state="translated">Los tipos de referencia son tipos de datos cuyos objetos se representan mediante una referencia (similar a un puntero) al valor real del objeto.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If a reference type is assigned to a variable, that variable references (points to) the original value.</source>
          <target state="translated">Si se asigna un tipo de referencia a una variable, esa variable hace referencia (o apunta) al valor original.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>No copy is made.</source>
          <target state="translated">No se realiza ninguna copia.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The common type system in .NET supports the following five categories of types:</source>
          <target state="translated">Common Type System en .NET admite las cinco categorías de tipos siguientes:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Classes<ept id="p1">](#classes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Clases<ept id="p1">](#classes)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Structures<ept id="p1">](#structures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Estructuras<ept id="p1">](#structures)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enumerations<ept id="p1">](#enumerations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Enumeraciones<ept id="p1">](#enumerations)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates<ept id="p1">](#delegates)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Delegados<ept id="p1">](#delegates)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Clases</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A class is a reference type that can be derived directly from another class and that is derived implicitly from <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</source>
          <target state="translated">Una clase es un tipo de referencia que se puede derivar directamente de otra clase y que se deriva implícitamente de <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The class defines the operations that an object (which is an instance of the class) can perform (methods, events, or properties) and the data that the object contains (fields).</source>
          <target state="translated">La clase define las operaciones que un objeto (que es una instancia de la clase) puede realizar (métodos, eventos o propiedades) y los datos que el objeto contiene (campos).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Although a class generally includes both definition and implementation (unlike interfaces, for example, which contain only definition without implementation), it can have one or more members that have no implementation.</source>
          <target state="translated">Aunque una clase suele incluir una definición y una implementación (a diferencia, por ejemplo, de las interfaces, que solo contienen una definición sin implementación), puede tener uno o varios miembros sin implementación.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The following table describes some of the characteristics that a class may have.</source>
          <target state="translated">En la tabla siguiente se describen algunas de las características que una clase puede tener.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Each language that supports the runtime provides a way to indicate that a class or class member has one or more of these characteristics.</source>
          <target state="translated">Cada lenguaje compatible con el motor en tiempo de ejecución proporciona una forma de indicar que una clase o un miembro de clase tiene una o varias de estas características.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>However, individual programming languages that target .NET may not make all these characteristics available.</source>
          <target state="translated">En cambio, puede que no estén disponibles todas estas características en los lenguajes de programación orientados a .NET.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Characteristic</source>
          <target state="translated">Característica</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>sealed</source>
          <target state="translated">sealed</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Specifies that another class cannot be derived from this type.</source>
          <target state="translated">Especifica que no se puede derivar otra clase de este tipo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>implements</source>
          <target state="translated">implementa</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Indicates that the class uses one or more interfaces by providing implementations of interface members.</source>
          <target state="translated">Indica que la clase utiliza una o varias interfaces proporcionando implementaciones de miembros de la interfaz.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>abstract</source>
          <target state="translated">abstract</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Indicates that the class cannot be instantiated.</source>
          <target state="translated">Indica que no se pueden crear instancias de la clase.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>To use it, you must derive another class from it.</source>
          <target state="translated">Para utilizarla se debe derivar de ella otra clase.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>inherits</source>
          <target state="translated">hereda</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Indicates that instances of the class can be used anywhere the base class is specified.</source>
          <target state="translated">Indica que las instancias de la clase se pueden utilizar en cualquier lugar en que se especifique la clase base.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A derived class that inherits from a base class can use the implementation of any public members provided by the base class, or the derived class can override the implementation of the public members with its own implementation.</source>
          <target state="translated">Una clase derivada que hereda de una clase base puede usar la implementación de cualquier miembro público proporcionado por la clase base o la clase derivada puede invalidar la implementación de los miembros públicos con su propia implementación.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>exported or not exported</source>
          <target state="translated">exported o not exported</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Indicates whether a class is visible outside the assembly in which it is defined.</source>
          <target state="translated">Indica si una clase está visible fuera del ensamblado en el que se define.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This characteristic applies only to top-level classes and not to nested classes.</source>
          <target state="translated">Esta característica se aplica únicamente a las clases de nivel superior y no a las clases anidadas.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A class can also be nested in a parent class or structure.</source>
          <target state="translated">Una clase también puede estar anidada en una estructura o clase primaria.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Nested classes also have member characteristics.</source>
          <target state="translated">Las clases anidadas tienen también características de miembro.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Nested types<ept id="p1">](#nested-types)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Tipos anidados<ept id="p1">](#nested-types)</ept>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Class members that have no implementation are abstract members.</source>
          <target state="translated">Los miembros de clase que no tienen implementación son miembros abstractos.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A class that has one or more abstract members is itself abstract; new instances of it cannot be created.</source>
          <target state="translated">Una clase que tiene uno o varios miembros abstractos es abstracta y no se pueden crear nuevas instancias de ella.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Some languages that target the runtime let you mark a class as abstract even if none of its members are abstract.</source>
          <target state="translated">Algunos lenguajes destinados al motor en tiempo de ejecución permiten marcar una clase como abstracta incluso aunque no tenga ningún miembro abstracto.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can use an abstract class when you want to encapsulate a basic set of functionality that derived classes can inherit or override when appropriate.</source>
          <target state="translated">Se puede usar una clase abstracta cuando se desea encapsular un conjunto básico de funcionalidad que las clases derivadas pueden heredar o invalidar según corresponda.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Classes that are not abstract are referred to as concrete classes.</source>
          <target state="translated">Las clases que no son abstractas se conocen como clases concretas.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A class can implement any number of interfaces, but it can inherit from only one base class in addition to <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>, from which all classes inherit implicitly.</source>
          <target state="translated">Una clase puede implementar cualquier número de interfaces, pero puede heredar solo de una clase base además de la clase <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>, de la que heredan implícitamente todas las clases.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>All classes must have at least one constructor, which initializes new instances of the class.</source>
          <target state="translated">Todas las clases deben tener al menos un constructor, que inicializa nuevas instancias de la clase.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you do not explicitly define a constructor, most compilers will automatically provide a default (parameterless) constructor.</source>
          <target state="translated">Si no se define explícitamente un constructor, la mayoría de los compiladores proporcionarán automáticamente un constructor predeterminado (sin parámetros).</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Structures</source>
          <target state="translated">Estructuras</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>A structure is a value type that derives implicitly from <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, which in turn is derived from <bpt id="p2">[</bpt>System.Object<ept id="p2">](xref:System.Object)</ept>.</source>
          <target state="translated">Una estructura es un tipo de valor que se deriva implícitamente de <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, que a su vez se deriva de <bpt id="p2">[</bpt>System.Object<ept id="p2">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A structure is very useful for representing values whose memory requirements are small, and for passing values as by-value parameters to methods that have strongly typed parameters.</source>
          <target state="translated">Una estructura es muy útil para representar valores cuyos requisitos de memoria son reducidos y para pasar valores como parámetros por valor a los métodos que tienen parámetros fuertemente tipados.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In .NET, all primitive data types (<bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>DateTime<ept id="p4">](xref:System.DateTime)</ept>, <bpt id="p5">[</bpt>Decimal<ept id="p5">](xref:System.Decimal)</ept>, <bpt id="p6">[</bpt>Double<ept id="p6">](xref:System.Double)</ept>, <bpt id="p7">[</bpt>Int16<ept id="p7">](xref:System.Int16)</ept>, <bpt id="p8">[</bpt>Int32<ept id="p8">](xref:System.Int32)</ept>, <bpt id="p9">[</bpt>Int64<ept id="p9">](xref:System.Int64)</ept>, <bpt id="p10">[</bpt>SByte<ept id="p10">](xref:System.SByte)</ept>, <bpt id="p11">[</bpt>Single<ept id="p11">](xref:System.Single)</ept>, <bpt id="p12">[</bpt>UInt16<ept id="p12">](xref:System.UInt16)</ept>, <bpt id="p13">[</bpt>UInt32<ept id="p13">](xref:System.UInt32)</ept>, and <bpt id="p14">[</bpt>UInt64<ept id="p14">](xref:System.UInt64)</ept>) are defined as structures.</source>
          <target state="translated">En. NET, todos los tipos de datos primitivos (<bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>DateTime<ept id="p4">](xref:System.DateTime)</ept>, <bpt id="p5">[</bpt>Decimal<ept id="p5">](xref:System.Decimal)</ept>, <bpt id="p6">[</bpt>Double<ept id="p6">](xref:System.Double)</ept>, <bpt id="p7">[</bpt>Int16<ept id="p7">](xref:System.Int16)</ept>, <bpt id="p8">[</bpt>Int32<ept id="p8">](xref:System.Int32)</ept>, <bpt id="p9">[</bpt>Int64<ept id="p9">](xref:System.Int64)</ept>, <bpt id="p10">[</bpt>SByte<ept id="p10">](xref:System.SByte)</ept>, <bpt id="p11">[</bpt>Single<ept id="p11">](xref:System.Single)</ept>, <bpt id="p12">[</bpt>UInt16<ept id="p12">](xref:System.UInt16)</ept>, <bpt id="p13">[</bpt>UInt32<ept id="p13">](xref:System.UInt32)</ept> y <bpt id="p14">[</bpt>UInt64<ept id="p14">](xref:System.UInt64)</ept>) se definen como estructuras.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Like classes, structures define both data (the fields of the structure) and the operations that can be performed on that data (the methods of the structure).</source>
          <target state="translated">Al igual que las clases, las estructuras definen datos (los campos de la estructura) y las operaciones que se pueden realizar con esos datos (los métodos de la estructura).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This means that you can call methods on structures, including the virtual methods defined on the <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> and <bpt id="p2">[</bpt>System.ValueType<ept id="p2">](xref:System.ValueType)</ept> classes, and any methods defined on the value type itself.</source>
          <target state="translated">Esto significa que se puede llamar a los métodos en las estructuras, incluso a los métodos virtuales definidos en las clases <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> y <bpt id="p2">[</bpt>System.ValueType<ept id="p2">](xref:System.ValueType)</ept>, y a cualquier método definido en el propio tipo de valor.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In other words, structures can have fields, properties, and events, as well as static and nonstatic methods.</source>
          <target state="translated">Es decir, las estructuras pueden tener campos, propiedades y eventos, así como métodos estáticos y no estáticos.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You can create instances of structures, pass them as parameters, store them as local variables, or store them in a field of another value type or reference type.</source>
          <target state="translated">Se pueden crear instancias de las estructuras, pasarlas como parámetros, almacenarlas como variables locales o almacenarlas en un campo de otro tipo de valor o tipo de referencia.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Structures can also implement interfaces.</source>
          <target state="translated">Las estructuras también pueden implementar interfaces.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Value types also differ from classes in several respects.</source>
          <target state="translated">Los tipos de valor también difieren de las clases en varios aspectos.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>First, although they implicitly inherit from <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, they cannot directly inherit from any type.</source>
          <target state="translated">En primer lugar, aunque heredan implícitamente de <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, no pueden heredar directamente de ningún tipo.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Similarly, all value types are sealed, which means that no other type can be derived from them.</source>
          <target state="translated">De manera similar, todos los tipos de valor están sellados, lo que quiere decir que de ellos no se puede derivar ningún otro tipo.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>They also do not require constructors.</source>
          <target state="translated">Tampoco necesitan constructores.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For each value type, the common language runtime supplies a corresponding boxed type, which is a class that has the same state and behavior as the value type.</source>
          <target state="translated">Para cada tipo de valor, Common Language Runtime proporciona un tipo correspondiente al que se ha aplicado la conversión boxing, que es una clase que tiene el mismo estado y comportamiento que el tipo de valor.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>An instance of a value type is boxed when it is passed to a method that accepts a parameter of type <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</source>
          <target state="translated">A una instancia de un tipo de valor se le aplica la conversión boxing cuando se pasa a un método que acepta un parámetro de tipo <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>It is unboxed (that is, converted from an instance of a class back to an instance of a value type) when control returns from a method call that accepts a value type as a by-reference parameter.</source>
          <target state="translated">Se le aplica la conversión unboxing (es decir, se vuelve a convertir la instancia de una clase en una instancia de un tipo de valor) cuando se devuelve el control de una llamada a un método que acepta un tipo de valor como parámetro por referencia.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Some languages require that you use special syntax when the boxed type is required; others automatically use the boxed type when it is needed.</source>
          <target state="translated">En el caso de algunos lenguajes, se debe usar una sintaxis especial cuando se necesita el tipo al que se haya aplicado la conversión boxing, mientras que otros emplean el tipo automáticamente cuando es necesario.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>When you define a value type, you are defining both the boxed and the unboxed type.</source>
          <target state="translated">Cuando se define un tipo de valor, se definen los dos tipos: al que se ha aplicado la conversión boxing y al que se ha aplicado la conversión unboxing.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Enumeraciones</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>An enumeration (enum) is a value type that inherits directly from <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept> and that supplies alternate names for the values of an underlying primitive type.</source>
          <target state="translated">Una enumeración (enum) es un tipo de valor que hereda directamente de <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept> y proporciona nombres alternativos para los valores de un tipo primitivo subyacente.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>An enumeration type has a name, an underlying type that must be one of the built-in signed or unsigned integer types (such as <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>, or <bpt id="p3">[</bpt>UInt64<ept id="p3">](xref:System.UInt64)</ept>), and a set of fields.</source>
          <target state="translated">Un tipo de enumeración tiene un nombre, un tipo subyacente que debe ser uno de los tipos de enteros con o sin signo integrados (como <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept> o <bpt id="p3">[</bpt>UInt64<ept id="p3">](xref:System.UInt64)</ept>) y un conjunto de campos.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The fields are static literal fields, each of which represents a constant.</source>
          <target state="translated">Los campos son campos literales estáticos, cada uno de los cuales representa una constante.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The same value can be assigned to multiple fields.</source>
          <target state="translated">El mismo valor se puede asignar a varios campos.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>When this occurs, you must mark one of the values as the primary enumeration value for reflection and string conversion.</source>
          <target state="translated">Cuando esto sucede, se debe marcar uno de los valores como valor de enumeración primario para la reflexión y la conversión de cadenas.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You can assign a value of the underlying type to an enumeration and vice versa (no cast is required by the runtime).</source>
          <target state="translated">Se puede asignar un valor del tipo subyacente a una enumeración y viceversa, y no es necesario que el motor en tiempo de ejecución realice una conversión.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You can create an instance of an enumeration and call the methods of <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept>, as well as any methods defined on the enumeration's underlying type.</source>
          <target state="translated">Se puede crear una instancia de una enumeración y llamar a los métodos de <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept>, además de llamar a cualquier método definido en el tipo subyacente de la enumeración.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>However, some languages might not let you pass an enumeration as a parameter when an instance of the underlying type is required (or vice versa).</source>
          <target state="translated">Sin embargo, algunos lenguajes no permiten pasar una enumeración como parámetro cuando se necesita una instancia del tipo subyacente (o viceversa).</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following additional restrictions apply to enumerations:</source>
          <target state="translated">A las enumeraciones se les aplican las restricciones siguientes:</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>They cannot define their own methods.</source>
          <target state="translated">No pueden definir sus propios métodos.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>They cannot implement interfaces.</source>
          <target state="translated">No pueden implementar interfaces.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>They cannot define properties or events.</source>
          <target state="translated">No pueden definir propiedades ni eventos.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>They cannot be generic, unless they are generic only because they are nested within a generic type.</source>
          <target state="translated">No pueden ser genéricas, a menos que sean genéricas solo porque están anidadas dentro de un tipo genérico.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>That is, an enumeration cannot have type parameters of its own.</source>
          <target state="translated">Es decir, una enumeración no puede tener parámetros de tipo propios.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Nested types (including enumerations) created with C# include the type parameters of all enclosing generic types, and are therefore generic even if they do not have type parameters of their own.</source>
          <target state="translated">Los tipos anidados (incluidas las enumeraciones) creados con C# incluyen los parámetros de tipo de todos los tipos genéricos envolventes, por lo que son genéricos aunque no tengan parámetros de tipo propios.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Type.MakeGenericType<ept id="p1">](xref:System.Type.MakeGenericType(System.Type[]))</ept> reference topic.</source>
          <target state="translated">Para obtener más información, consulte el tema de referencia <bpt id="p1">[</bpt>Type.MakeGenericType<ept id="p1">](xref:System.Type.MakeGenericType(System.Type[]))</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> attribute denotes a special kind of enumeration called a bit field.</source>
          <target state="translated">El atributo <bpt id="p1">[</bpt>FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> indica una clase especial de enumeración denominada campo de bits.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The runtime itself does not distinguish between traditional enumerations and bit fields, but your language might do so.</source>
          <target state="translated">El motor en tiempo de ejecución no distingue entre enumeraciones tradicionales y campos de bits, pero el lenguaje podría hacerlo.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>When this distinction is made, bitwise operators can be used on bit fields, but not on enumerations, to generate unnamed values.</source>
          <target state="translated">Cuando se hace esta distinción, se pueden utilizar operadores bit a bit en estos campos de bits, para generar valores sin nombre, pero no en las enumeraciones.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Enumerations are generally used for lists of unique elements, such as days of the week, country or region names, and so on.</source>
          <target state="translated">Normalmente, las enumeraciones se utilizan para listas de elementos únicos, como los días de la semana, los nombres de países o regiones, etc.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Bit fields are generally used for lists of qualities or quantities that might occur in combination, such as <ph id="ph1">`Red And Big And Fast`</ph>.</source>
          <target state="translated">Los campos de bits se utilizan, en general, para listas de calidades o cantidades que pueden producirse en combinaciones, como <ph id="ph1">`Red And Big And Fast`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following example shows how to use both bit fields and traditional enumerations.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar los campos de bits y las enumeraciones tradicionales.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>An interface defines a contract that specifies a "can do" relationship or a "has a" relationship.</source>
          <target state="translated">Una interfaz define un contrato que especifica una relación de lo que se puede hacer o una relación de lo que se tiene.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Interfaces are often used to implement functionality, such as comparing and sorting (the <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> and <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept> interfaces), testing for equality (the <bpt id="p3">[</bpt>IEquatable<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p3">](xref:System.IEquatable%601)</ept> interface), or enumerating items in a collection (the <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept> and <bpt id="p5">[</bpt>IEnumerable<ph id="ph5">&amp;lt;</ph>T<ph id="ph6">&amp;gt;</ph><ept id="p5">](xref:System.Collections.Generic.IEnumerable%601)</ept> interfaces).</source>
          <target state="translated">Las interfaces se usan a menudo para implementar una funcionalidad, como comparar y ordenar (interfaces <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> e <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept>), comprobar la igualdad (interfaz <bpt id="p3">[</bpt>IEquatable<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p3">](xref:System.IEquatable%601)</ept>) o enumerar los elementos de una colección (interfaces <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept> e <bpt id="p5">[</bpt>IEnumerable<ph id="ph5">&amp;lt;</ph>T<ph id="ph6">&amp;gt;</ph><ept id="p5">](xref:System.Collections.Generic.IEnumerable%601)</ept>).</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Interfaces can have properties, methods, and events, all of which are abstract members; that is, although the interface defines the members and their signatures, it leaves it to the type that implements the interface to define the functionality of each interface member.</source>
          <target state="translated">Las interfaces pueden tener propiedades, métodos y eventos, que son todos miembros abstractos; es decir, aunque la interfaz define los miembros y sus firmas, deja que el tipo encargado de implementar la interfaz defina la funcionalidad de cada miembro de la interfaz.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This means that any class or structure that implements an interface must supply definitions for the abstract members declared in the interface.</source>
          <target state="translated">Esto significa que cualquier clase o estructura que implemente una interfaz debe proporcionar definiciones de los miembros abstractos declarados en la interfaz.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>An interface can require any implementing class or structure to also implement one or more other interfaces.</source>
          <target state="translated">Una interfaz puede necesitar que cualquier clase o estructura que implemente una interfaz implemente también otras interfaces.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to interfaces:</source>
          <target state="translated">A las interfaces se les aplican las restricciones siguientes:</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>An interface can be declared with any accessibility, but interface members must all have public accessibility.</source>
          <target state="translated">Una interfaz se puede declarar con cualquier tipo de accesibilidad, pero los miembros de la interfaz deben tener todos accesibilidad pública.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Interfaces cannot define constructors.</source>
          <target state="translated">Las interfaces no pueden definir constructores</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Interfaces cannot define fields.</source>
          <target state="translated">Las interfaces no pueden definir campos.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Interfaces can define only instance members.</source>
          <target state="translated">Las interfaces solo pueden definir miembros de instancia.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>They cannot define static members.</source>
          <target state="translated">No pueden definir miembros estáticos.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Each language must provide rules for mapping an implementation to the interface that requires the member, because more than one interface can declare a member with the same signature, and these members can have separate implementations.</source>
          <target state="translated">Cada lenguaje debe proporcionar reglas para asignar una implementación a la interfaz que necesita el miembro, ya que varias interfaces pueden declarar un miembro con la misma firma y esos miembros pueden tener implementaciones independientes.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Delegates</source>
          <target state="translated">Delegados</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Delegates are reference types that serve a purpose similar to that of function pointers in C++.</source>
          <target state="translated">Los delegados son tipos de referencia con una finalidad similar a la de los punteros a función de C++.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>They are used for event handlers and callback functions in .NET.</source>
          <target state="translated">Se usan para los controladores de eventos y las funciones de devolución de llamada en .NET.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Unlike function pointers, delegates are secure, verifiable, and type safe.</source>
          <target state="translated">A diferencia de los punteros a función, los delegados son seguros, se pueden comprobar y proporcionan seguridad de tipos.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>A delegate type can represent any instance method or static method that has a compatible signature.</source>
          <target state="translated">Un tipo de delegado puede representar cualquier método de instancia o método estático que tenga una firma compatible.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">Un parámetro de un delegado es compatible con el parámetro correspondiente de un método si el tipo del parámetro del delegado es más restrictivo que el del método, porque así se garantiza que el argumento que se pase al delegado también se podrá pasar de forma segura al método.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">De forma similar, el tipo de valor devuelto de un delegado es compatible con el tipo de valor devuelto de un método si el del método es más restrictivo que el del delegado, porque así se garantiza que el tipo de valor devuelto por el método se puede convertir con seguridad al tipo de valor devuelto del delegado.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For example, a delegate that has a parameter of type <bpt id="p1">[</bpt>IEnumerable<ept id="p1">](xref:System.Collections.IEnumerable)</ept> and a return type of <bpt id="p2">[</bpt>Object<ept id="p2">](xref:System.Object)</ept> can represent a method that has a parameter of type <bpt id="p3">[</bpt>Object<ept id="p3">](xref:System.Object)</ept> and a return value of type <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept>.</source>
          <target state="translated">Por ejemplo, un delegado que tiene un parámetro de tipo <bpt id="p1">[</bpt>IEnumerable<ept id="p1">](xref:System.Collections.IEnumerable)</ept> y un tipo de valor devuelto <bpt id="p2">[</bpt>Object<ept id="p2">](xref:System.Object)</ept> puede representar un método que tiene un parámetro de tipo <bpt id="p3">[</bpt>Object<ept id="p3">](xref:System.Object)</ept> y un valor devuelto de tipo <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>A delegate is said to be bound to the method it represents.</source>
          <target state="translated">Se dice que un delegado está enlazado al método que representa.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In addition to being bound to the method, a delegate can be bound to an object.</source>
          <target state="translated">Además de estar enlazado al método, un delegado puede estar enlazado a un objeto.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The object represents the first parameter of the method, and is passed to the method every time the delegate is invoked.</source>
          <target state="translated">El objeto representa el primer parámetro del método y se pasa al método cada vez que se invoca el delegado.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If the method is an instance method, the bound object is passed as the implicit <ph id="ph1">`this`</ph> parameter (<ph id="ph2">`Me`</ph> in Visual Basic); if the method is static, the object is passed as the first formal parameter of the method, and the delegate signature must match the remaining parameters.</source>
          <target state="translated">Si el método es un método de instancia, el objeto enlazado se pasa como el parámetro <ph id="ph1">`this`</ph> implícito (<ph id="ph2">`Me`</ph> en Visual Basic); si el método es estático, el objeto se pasa como primer parámetro formal del método y la firma del delegado debe coincidir con los parámetros restantes.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>All delegates inherit from <bpt id="p1">[</bpt>System.MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, which inherits from <bpt id="p2">[</bpt>System.Delegate<ept id="p2">](xref:System.Delegate)</ept>.</source>
          <target state="translated">Todos los delegados heredan de <bpt id="p1">[</bpt>System.MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, que hereda de <bpt id="p2">[</bpt>System.Delegate<ept id="p2">](xref:System.Delegate)</ept>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The C# and Visual Basic languages don't allow inheritance from these types.</source>
          <target state="translated">Los lenguajes C# y Visual Basic no permiten que se herede de estos tipos.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Instead, they provide keywords for declaring delegates.</source>
          <target state="translated">En su lugar, proporcionan palabras clave para declarar los delegados.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Because delegates inherit from <bpt id="p1">[</bpt>MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, a delegate has an invocation list, which is a list of methods that the delegate represents and that are executed when the delegate is invoked.</source>
          <target state="translated">Dado que los delegados heredan de <bpt id="p1">[</bpt>MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, un delegado tiene una lista de invocación, que es una lista de métodos que representa el delegado y que se ejecutan cuando se llama al delegado.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>All methods in the list receive the arguments supplied when the delegate is invoked.</source>
          <target state="translated">Todos los métodos de la lista reciben los argumentos proporcionados cuando se invoca al delegado.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The return value is not defined for a delegate that has more than one method in its invocation list, even if the delegate has a return type.</source>
          <target state="translated">El valor devuelto no se define para los delegados que tienen más de un método en su lista de invocación, aunque el delegado tenga un tipo de valor devuelto.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>In many cases, such as with callback methods, a delegate represents only one method, and the only actions you have to take are creating the delegate and invoking it.</source>
          <target state="translated">En muchos casos, como en el de los métodos de devolución de llamada, un delegado solo representa un método y las únicas acciones que se deben llevar a cabo son la creación y la invocación del delegado.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>For delegates that represent multiple methods, .NET provides methods of the <bpt id="p1">[</bpt>Delegate<ept id="p1">](xref:System.Delegate)</ept> and <bpt id="p2">[</bpt>MulticastDelegate<ept id="p2">](xref:System.MulticastDelegate)</ept> delegate classes to support operations such as adding a method to a delegate's invocation list (the <bpt id="p3">[</bpt>Delegate.Combine<ept id="p3">](xref:System.Delegate.Combine(System.Delegate,System.Delegate))</ept> method), removing a method (the <bpt id="p4">[</bpt>Delegate.Remove<ept id="p4">](xref:System.Delegate.Remove(System.Delegate,System.Delegate))</ept> method), and getting the invocation list (the <bpt id="p5">[</bpt>Delegate.GetInvocationList<ept id="p5">](xref:System.Delegate.GetInvocationList)</ept> method).</source>
          <target state="translated">Por lo que se refiere a los delegados que representan varios métodos, .NET proporciona métodos de las clases de delegado <bpt id="p1">[</bpt>Delegate<ept id="p1">](xref:System.Delegate)</ept> y <bpt id="p2">[</bpt>MulticastDelegate<ept id="p2">](xref:System.MulticastDelegate)</ept> para operaciones tales como agregar un método a una lista de invocación del delegado (el método <bpt id="p3">[</bpt>Delegate.Combine<ept id="p3">](xref:System.Delegate.Combine(System.Delegate,System.Delegate))</ept>), quitar un método (el método <bpt id="p4">[</bpt>Delegate.Remove<ept id="p4">](xref:System.Delegate.Remove(System.Delegate,System.Delegate))</ept>) y obtener la lista de invocación (el método <bpt id="p5">[</bpt>Delegate.GetInvocationList<ept id="p5">](xref:System.Delegate.GetInvocationList)</ept>).</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>It is not necessary to use these methods for event-handler delegates in C# or Visual Basic, because these languages provide syntax for adding and removing event handlers.</source>
          <target state="translated">No es preciso usar estos métodos para los delegados de controladores de eventos en C# ni Visual Basic, ya que estos lenguajes proporcionan sintaxis para agregar y quitar controladores de eventos.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Type definitions</source>
          <target state="translated">Definiciones de tipo</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>A type definition includes the following:</source>
          <target state="translated">Una definición de tipo incluye lo siguiente:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Any attributes defined on the type.</source>
          <target state="translated">Los atributos definidos en el tipo.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The type's accessibility (visibility).</source>
          <target state="translated">La accesibilidad del tipo (visibilidad).</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The type's name.</source>
          <target state="translated">El nombre del tipo.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The type's base type.</source>
          <target state="translated">El tipo base del tipo.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Any interfaces implemented by the type.</source>
          <target state="translated">Las interfaces que implementa el tipo.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Definitions for each of the type's members.</source>
          <target state="translated">Las definiciones de todos los miembros del tipo</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Atributos</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Attributes provide additional user-defined metadata.</source>
          <target state="translated">Los atributos proporcionan metadatos adicionales definidos por el usuario .</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Most commonly, they are used to store additional information about a type in its assembly, or to modify the behavior of a type member in either the design-time or run-time environment.</source>
          <target state="translated">Normalmente, se emplean para almacenar información adicional sobre un tipo en su ensamblado o para modificar el comportamiento de un miembro de tipo en tiempo de diseño o en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Attributes are themselves classes that inherit from <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept>.</source>
          <target state="translated">Los atributos son clases que heredan de <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Languages that support the use of attributes each have their own syntax for applying attributes to a language element.</source>
          <target state="translated">Los lenguajes que admiten el uso de atributos tienen su propia sintaxis para aplicar atributos a un elemento del lenguaje.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Attributes can be applied to almost any language element; the specific elements to which an attribute can be applied are defined by the <bpt id="p1">[</bpt>AttributeUsageAttribute<ept id="p1">](xref:System.AttributeUsageAttribute)</ept> that is applied to that attribute class.</source>
          <target state="translated">Los atributos se pueden aplicar a casi cualquier elemento del lenguaje; los elementos específicos a los que se puede aplicar un atributo los define la clase <bpt id="p1">[</bpt>AttributeUsageAttribute<ept id="p1">](xref:System.AttributeUsageAttribute)</ept> aplicada a esa clase de atributos.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Type accessibility</source>
          <target state="translated">Accesibilidad a tipos</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>All types have a modifier that governs their accessibility from other types.</source>
          <target state="translated">Todos los tipos tienen un modificador que rige su accesibilidad desde otros tipos.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following table describes the type accessibilities supported by the runtime.</source>
          <target state="translated">En la tabla siguiente se describen las accesibilidades a tipos que admite el motor en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Accesibilidad</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>public</source>
          <target state="translated">public</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The type is accessible by all assemblies.</source>
          <target state="translated">Todos los ensamblados pueden tener acceso al tipo.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>assembly</source>
          <target state="translated">ensamblado</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The type is accessible only from within its assembly.</source>
          <target state="translated">El tipo sólo es accesible desde su ensamblado.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The accessibility of a nested type depends on its accessibility domain, which is determined by both the declared accessibility of the member and the accessibility domain of the immediately containing type.</source>
          <target state="translated">La accesibilidad de un tipo anidado depende de su dominio de accesibilidad, que viene determinado por la accesibilidad declarada del miembro y el dominio de accesibilidad del tipo contenedor inmediato.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>However, the accessibility domain of a nested type cannot exceed that of the containing type.</source>
          <target state="translated">Sin embargo, el dominio de accesibilidad de un tipo anidado no puede superar al del tipo contenedor.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The accessibility domain of a nested member <ph id="ph1">`M`</ph> declared in a type <ph id="ph2">`T`</ph>within a program <ph id="ph3">`P`</ph> is defined as follows (noting that <ph id="ph4">`M`</ph> might itself be a type):</source>
          <target state="translated">El dominio de accesibilidad de un miembro anidado <ph id="ph1">`M`</ph> declarado en un tipo <ph id="ph2">`T`</ph> dentro de un programa <ph id="ph3">`P`</ph> se define de la manera siguiente (teniendo en cuenta que el propio miembro <ph id="ph4">`M`</ph> puede ser un tipo):</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`public`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the accessibility domain of <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Si la accesibilidad declarada de <ph id="ph1">`M`</ph> es <ph id="ph2">`public`</ph>, el dominio de accesibilidad de <ph id="ph3">`M`</ph> es el dominio de accesibilidad de <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`protected internal`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the intersection of the accessibility domain of <ph id="ph4">`T`</ph> with the program text of <ph id="ph5">`P`</ph> and the program text of any type derived from <ph id="ph6">`T`</ph> declared outside <ph id="ph7">`P`</ph>.</source>
          <target state="translated">Si la accesibilidad declarada de <ph id="ph1">`M`</ph> es <ph id="ph2">`protected internal`</ph>, el dominio de accesibilidad de <ph id="ph3">`M`</ph> es la intersección del dominio de accesibilidad de <ph id="ph4">`T`</ph> con el texto de programa de <ph id="ph5">`P`</ph> y el texto de programa de cualquier tipo derivado de <ph id="ph6">`T`</ph> declarado fuera de <ph id="ph7">`P`</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`protected`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the intersection of the accessibility domain of <ph id="ph4">`T`</ph> with the program text of <ph id="ph5">`T`</ph> and any type derived from <ph id="ph6">`T`</ph>.</source>
          <target state="translated">Si la accesibilidad declarada de <ph id="ph1">`M`</ph> es <ph id="ph2">`protected`</ph>, el dominio de accesibilidad de <ph id="ph3">`M`</ph> es la intersección del dominio de accesibilidad de <ph id="ph4">`T`</ph> con el texto de programa de <ph id="ph5">`T`</ph> y cualquier tipo derivado de <ph id="ph6">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`internal`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the intersection of the accessibility domain of <ph id="ph4">`T`</ph> with the program text of<ph id="ph5">`P`</ph>.</source>
          <target state="translated">Si la accesibilidad declarada de <ph id="ph1">`M`</ph> es <ph id="ph2">`internal`</ph>, el dominio de accesibilidad de <ph id="ph3">`M`</ph> es la intersección del dominio de accesibilidad de <ph id="ph4">`T`</ph> con el texto de programa de <ph id="ph5">`P`</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`private`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the program text of <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Si la accesibilidad declarada de <ph id="ph1">`M`</ph> es <ph id="ph2">`private`</ph>, el dominio de accesibilidad de <ph id="ph3">`M`</ph> es el texto de programa de <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Type names</source>
          <target state="translated">Nombres de tipo</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The common type system imposes only two restrictions on names:</source>
          <target state="translated">El sistema de tipos común sólo impone dos restricciones en los nombres:</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>All names are encoded as strings of Unicode (16-bit) characters.</source>
          <target state="translated">Todos los nombres se codifican como cadenas de caracteres Unicode (de&amp;16; bits).</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Names are not permitted to have an embedded (16-bit) value of 0x0000.</source>
          <target state="translated">Los nombres no pueden tener un valor incrustado (de 16 bits) de 0x0000.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>However, most languages impose additional restrictions on type names.</source>
          <target state="translated">Sin embargo, la mayoría de los lenguajes imponen restricciones adicionales sobre los nombres de tipo.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>All comparisons are done on a byte-by-byte basis, and are therefore case-sensitive and locale-independent.</source>
          <target state="translated">Todas las comparaciones se realizan byte a byte, por lo que distinguen entre mayúsculas y minúsculas y son independientes de la configuración regional.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Although a type might reference types from other modules and assemblies, a type must be fully defined within one .NET module.</source>
          <target state="translated">Aunque un tipo puede hacer referencia a tipos de otros módulos y ensamblados, es preciso que se defina íntegramente en un solo módulo de .NET.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>(Depending on compiler support, however, it can be divided into multiple source code files.) Type names need be unique only within a namespace.</source>
          <target state="translated">(Sin embargo, según la compatibilidad del compilador, se puede dividir en varios archivos de código fuente.) Los nombres de tipo solo tienen que ser únicos dentro de un espacio de nombres.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>To fully identify a type, the type name must be qualified by the namespace that contains the implementation of the type.</source>
          <target state="translated">Para identificar íntegramente un tipo, su nombre debe calificarse con el espacio de nombres que contiene la implementación del tipo.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Base types and interfaces</source>
          <target state="translated">Tipos base e interfaces</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>A type can inherit values and behaviors from another type.</source>
          <target state="translated">Un tipo puede heredar valores y comportamientos de otro.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The common type system does not allow types to inherit from more than one base type.</source>
          <target state="translated">El sistema de tipos común no permite que los tipos hereden de más de un tipo base.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>A type can implement any number of interfaces.</source>
          <target state="translated">Un tipo puede implementar cualquier número de interfaces.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>To implement an interface, a type must implement all the virtual members of that interface.</source>
          <target state="translated">Para implementar una interfaz, un tipo debe implementar todos los miembros virtuales de la interfaz.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>A virtual method can be implemented by a derived type and can be invoked either statically or dynamically.</source>
          <target state="translated">Un tipo derivado puede implementar un método virtual, que se puede invocar estática o dinámicamente.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Type members</source>
          <target state="translated">Miembros de tipos</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The runtime enables you to define members of your type, which specifies the behavior and state of a type.</source>
          <target state="translated">El motor en tiempo de ejecución permite definir miembros de tipos, que especifican el comportamiento y el estado de los tipos.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Type members include the following:</source>
          <target state="translated">Los miembros de tipos incluyen lo siguiente:</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Fields<ept id="p1">](#fields)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Campos<ept id="p1">](#fields)</ept></target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Propiedades<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Methods<ept id="p1">](#methods)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Métodos<ept id="p1">](#methods)</ept></target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Constructors<ept id="p1">](#constructors)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Constructores<ept id="p1">](#constructors)</ept></target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Eventos<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nested types<ept id="p1">](#nested-types)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tipos anidados<ept id="p1">](#nested-types)</ept></target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Campos</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>A field describes and contains part of the type's state.</source>
          <target state="translated">Un campo describe y contiene parte del estado del tipo.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Fields can be of any type supported by the runtime.</source>
          <target state="translated">Los campos pueden ser de cualquier tipo que admita el motor en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Most commonly, fields are either <ph id="ph1">`private`</ph> or <ph id="ph2">`protected`</ph>, so that they are accessible only from within the class or from a derived class.</source>
          <target state="translated">Normalmente, los campos son de tipo <ph id="ph1">`private`</ph> o <ph id="ph2">`protected`</ph>, por lo que son accesibles únicamente desde la clase o desde una clase derivada.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>If the value of a field can be modified from outside its type, a property set accessor is typically used.</source>
          <target state="translated">Si el valor de un campo se puede modificar desde fuera de su tipo, se suele emplear un descriptor de acceso set de una propiedad.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Publicly exposed fields are usually read-only and can be of two types:</source>
          <target state="translated">Los campos expuestos públicamente suelen ser de solo lectura y pueden ser de dos tipos:</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Constants, whose value is assigned at design time.</source>
          <target state="translated">Constantes, cuyo valor se asigna en tiempo de diseño.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>These are static members of a class, although they are not defined using the <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) keyword.</source>
          <target state="translated">Se trata de miembros estáticos de una clase, aunque no se definen mediante la palabra clave <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Read-only variables, whose values can be assigned in the class constructor.</source>
          <target state="translated">Variables de solo lectura, cuyos valores se pueden asignar en el constructor de clase.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The following example illustrates these two usages of read-only fields.</source>
          <target state="translated">En el ejemplo siguiente se muestran estos dos usos de los campos de solo lectura.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Propiedades</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>A property names a value or state of the type and defines methods for getting or setting the property's value.</source>
          <target state="translated">Una propiedad identifica un valor o un estado del tipo y define los métodos para obtener o establecer el valor de la propiedad.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Properties can be primitive types, collections of primitive types, user-defined types, or collections of user-defined types.</source>
          <target state="translated">Las propiedades pueden ser tipos primitivos, colecciones de tipos primitivos, tipos definidos por el usuario o colecciones de tipos definidos por el usuario.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Properties are often used to keep the public interface of a type independent from the type's actual representation.</source>
          <target state="translated">Las propiedades se usan a menudo para que la interfaz pública de un tipo se mantenga independiente de la representación real del tipo.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>This enables properties to reflect values that are not directly stored in the class (for example, when a property returns a computed value) or to perform validation before values are assigned to private fields.</source>
          <target state="translated">De este modo, las propiedades pueden reflejar valores que no están almacenados directamente en la clase (por ejemplo, cuando una propiedad devuelve un valor calculado) o realizar la validación antes de que se asignen valores a campos privados.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The following example illustrates the latter pattern.</source>
          <target state="translated">En el ejemplo siguiente se muestra el último modelo.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>In addition to including the property itself, the Microsoft intermediate language (MSIL) for a type that contains a readable property includes a <ph id="ph1">`get`</ph><bpt id="p1">*</bpt>_propertyname<ept id="p1">*</ept> method, and the MSIL for a type that contains a writable property includes a <ph id="ph2">`set`</ph><bpt id="p2">*</bpt>_propertyname<ept id="p2">*</ept> method.</source>
          <target state="translated">Además de incluir la propiedad propiamente dicha, el Lenguaje Intermedio de Microsoft (MSIL) de un tipo que contiene una propiedad de lectura incluye un método <ph id="ph1">`get`</ph><bpt id="p1">*</bpt>_propertyname<ept id="p1">*</ept> y el lenguaje MSIL de un tipo que contiene una propiedad de escritura incluye un método <ph id="ph2">`set`</ph><bpt id="p2">*</bpt>_propertyname<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Métodos</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>A method describes operations that are available on the type.</source>
          <target state="translated">Un método describe las operaciones que están disponibles en el tipo.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>A method's signature specifies the allowable types of all its parameters and of its return value.</source>
          <target state="translated">La firma de un método especifica los tipos permitidos de todos sus parámetros y de su valor devuelto.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Although most methods define the precise number of parameters required for method calls, some methods support a variable number of parameters.</source>
          <target state="translated">Aunque la mayoría de los métodos definen el número exacto de los parámetros necesarios para las llamadas a métodos, algunos admiten un número de parámetros que es variable.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The final declared parameter of these methods is marked with the <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> attribute.</source>
          <target state="translated">El último parámetro declarado de estos métodos se marca con el atributo <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Language compilers typically provide a keyword, such as <ph id="ph1">`params`</ph> in C# and <ph id="ph2">`ParamArray`</ph> in Visual Basic, that makes explicit use of <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> unnecessary.</source>
          <target state="translated">Normalmente, los compiladores de lenguaje proporcionan una palabra clave, como <ph id="ph1">`params`</ph> en C# y <ph id="ph2">`ParamArray`</ph> en Visual Basic, que hace que sea innecesario el uso explícito de <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructores</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>A constructor is a special kind of method that creates new instances of a class or structure.</source>
          <target state="translated">Un constructor es un tipo de método especial que crea nuevas instancias de una clase o una estructura.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Like any other method, a constructor can include parameters; however, constructors have no return value (that is, they return <ph id="ph1">`void`</ph>).</source>
          <target state="translated">Al igual que cualquier otro método, un constructor puede incluir parámetros; sin embargo, los constructores no tienen ningún valor devuelto (es decir, devuelven <ph id="ph1">`void`</ph>).</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>If the source code for a class does not explicitly define a constructor, the compiler includes a default (parameterless) constructor.</source>
          <target state="translated">Si el código fuente de una clase no define explícitamente un constructor, el compilador incluye un constructor predeterminado (sin parámetros).</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>However, if the source code for a class defines only parameterized constructors, the C# compiler doesn't generate a parameterless constructor.</source>
          <target state="translated">En cambio, si el código fuente de una clase define solo constructores parametrizados, el compilador de C# no genera un constructor sin parámetros.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>If the source code for a structure defines constructors, they must be parameterized; a structure cannot define a default (parameterless) constructor, and compilers do not generate parameterless constructors for structures or other value types.</source>
          <target state="translated">Si el código fuente de una estructura define constructores, estos deben tener parámetros; una estructura no puede definir un constructor predeterminado (sin parámetros) y los compiladores no generan constructores sin parámetros para las estructuras u otros tipos de valor.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>All value types do have an implicit default constructor.</source>
          <target state="translated">Todos los tipos de valor tienen un constructor predeterminado implícito.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>This constructor is implemented by the common language runtime and initializes all fields of the structure to their default values.</source>
          <target state="translated">Common Language Runtime implementa este constructor, que inicializa todos los campos de la estructura en sus valores predeterminados.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Eventos</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>An event defines an incident that can be responded to, and defines methods for subscribing to, unsubscribing from, and raising the event.</source>
          <target state="translated">Un evento define un incidente al que se puede responder, así como los métodos para suscribirse a un evento, anular la suscripción y generar el evento.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Events are often used to inform other types of state changes.</source>
          <target state="translated">Los eventos se usan con frecuencia para informar a otros tipos de cambios de estado.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Nested types</source>
          <target state="translated">Tipos anidados</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>A nested type is a type that is a member of some other type.</source>
          <target state="translated">Un tipo anidado es un tipo que es un miembro de algún otro tipo.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Nested types should be tightly coupled to their containing type and must not be useful as a general-purpose type.</source>
          <target state="translated">Los tipos anidados deben estar estrechamente acoplados a su tipo contenedor y no deben ser útiles como tipos de uso general.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Nested types are useful when the declaring type uses and creates instances of the nested type, and use of the nested type is not exposed in public members.</source>
          <target state="translated">Los tipos anidados son útiles cuando el tipo declarativo utiliza y crea instancias del tipo anidado y el uso de dicho tipo anidado no se expone en miembros públicos.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Nested types are confusing to some developers and should not be publicly visible unless there is a compelling reason for visibility.</source>
          <target state="translated">Los tipos anidados resultan confusos para algunos desarrolladores y no deben estar públicamente visibles a menos que haya una razón de peso.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>In a well-designed library, developers should rarely have to use nested types to instantiate objects or declare variables.</source>
          <target state="translated">En una biblioteca bien diseñada, los desarrolladores rara vez deberían tener que utilizar tipos anidados para crear instancias de objetos o declarar variables.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Characteristics of type members</source>
          <target state="translated">Características de los miembros de tipos</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The common type system allows type members to have a variety of characteristics; however, languages are not required to support all these characteristics.</source>
          <target state="translated">Common Type System permite que los miembros de tipos tengan diversas características; sin embargo, no es necesario que los lenguajes admitan todas estas características.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following table describes member characteristics.</source>
          <target state="translated">En la siguiente tabla se describen las características de los miembros.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Characteristic</source>
          <target state="translated">Característica</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Can apply to</source>
          <target state="translated">Se puede aplicar a</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>abstract</source>
          <target state="translated">abstract</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events</source>
          <target state="translated">Métodos, propiedades y eventos</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The type does not supply the method's implementation.</source>
          <target state="translated">El tipo no proporciona la implementación del método.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Types that inherit or implement abstract methods must supply an implementation for the method.</source>
          <target state="translated">Los tipos que heredan o implementan métodos abstractos deben proporcionar una implementación para el método.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The only exception is when the derived type is itself an abstract type.</source>
          <target state="translated">La única excepción es que el tipo derivado sea un tipo abstracto.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>All abstract methods are virtual.</source>
          <target state="translated">Todos lo métodos abstractos son virtuales.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>private</source>
          <target state="translated">private</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todo</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Accessible only from within the same type as the member, or within a nested type.</source>
          <target state="translated">Solo es accesible desde el mismo tipo que el miembro o desde un tipo anidado.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>family</source>
          <target state="translated">family</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todo</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Accessible from within the same type as the member, and from derived types that inherit from it.</source>
          <target state="translated">Accesible desde el mismo tipo que el miembro y desde tipos derivados que heredan de él.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>assemby</source>
          <target state="translated">assembly</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todo</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Accessible only in the assembly in which the type is defined.</source>
          <target state="translated">Accesible sólo en el ensamblado en que está definido el tipo.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>family and assembly</source>
          <target state="translated">family y assembly</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todo</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Accessible only from types that qualify for both family and assembly access.</source>
          <target state="translated">Accesible sólo desde los tipos que estén calificados para el acceso de familia y ensamblado.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>family or assemby</source>
          <target state="translated">family o assembly</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todo</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Accessible only from types that qualify for either family or assembly access.</source>
          <target state="translated">Accesible sólo desde los tipos que califican el acceso de familia o ensamblado.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>public</source>
          <target state="translated">public</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todo</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Accessible from any type.</source>
          <target state="translated">Accesible desde cualquier tipo.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>final</source>
          <target state="translated">final</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events</source>
          <target state="translated">Métodos, propiedades y eventos</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The virtual method cannot be overridden in a derived type.</source>
          <target state="translated">El método virtual no puede ser reemplazado en un tipo derivado.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>initialize-only</source>
          <target state="translated">initialize-only</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Campos</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The value can only be initialized, and cannot be written after initialization.</source>
          <target state="translated">El valor sólo se puede inicializar y no se puede escribir en él después de la inicialización.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>instance</source>
          <target state="translated">instancia</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Fields, methods, properties, and events</source>
          <target state="translated">Campos, métodos, propiedades y eventos</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>If a member is not marked as <ph id="ph1">`static`</ph> (C#), <ph id="ph2">`Shared`</ph> (Visual Basic), <ph id="ph3">`virtual`</ph> (C#), or <ph id="ph4">`Overridable`</ph> (Visual Basic),  it is an instance member (there is no instance keyword).</source>
          <target state="translated">Si un miembro no está marcado como <ph id="ph1">`static`</ph> (C#), <ph id="ph2">`Shared`</ph> (Visual Basic), <ph id="ph3">`virtual`</ph> (C#) u <ph id="ph4">`Overridable`</ph> (Visual Basic), es un miembro de instancia (no hay palabra clave de la instancia).</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>There will be as many copies of such members in memory as there are objects that use it.</source>
          <target state="translated">En la memoria habrá tantas copias de estos miembros como objetos que los utilicen.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>literal</source>
          <target state="translated">Literal</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Campos</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The value assigned to the field is a fixed value, known at compile time, of a built-in value type.</source>
          <target state="translated">El valor asignado al campo es un valor fijo, conocido en tiempo de compilación, de un tipo de valor integrado.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Literal fields are sometimes referred to as constants.</source>
          <target state="translated">Los campos literales, a veces, se conocen como constantes.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>newslot or override</source>
          <target state="translated">newslot u override</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todo</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Defines how the member interacts with inherited members that have the same signature: <ph id="ph1">`newslot`</ph> hides inherited members that have the same signature; <ph id="ph2">`override`</ph> replaces the definition of an inherited virtual method.</source>
          <target state="translated">Define cómo interactúa el miembro con los miembros heredados que tienen la misma firma: <ph id="ph1">`newslot`</ph> oculta los miembros heredados que tienen la misma firma; <ph id="ph2">`override`</ph> reemplaza la definición de un método virtual heredado.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The default is newslot.</source>
          <target state="translated">El valor predeterminado es newslot.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>static</source>
          <target state="translated">estático</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Fields, methods, properties, and events</source>
          <target state="translated">Campos, métodos, propiedades y eventos</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The member belongs to the type it is defined on, not to a particular instance of the type; the member exists even if an instance of the type is not created, and it is shared among all instances of the type.</source>
          <target state="translated">El miembro pertenece al tipo en que está definido, no a una instancia particular del tipo. El miembro existe incluso si no se ha creado ninguna instancia del tipo y lo comparten todas las instancias del tipo.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>virtual</source>
          <target state="translated">virtual</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events</source>
          <target state="translated">Métodos, propiedades y eventos</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The method can be implemented by a derived type and can be invoked either statically or dynamically.</source>
          <target state="translated">Un tipo derivado puede implementar el método, que se puede invocar estática o dinámicamente.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>If dynamic invocation is used, the type of the instance that makes the call at run time (rather than the type known at compile time) determines which implementation of the method is called.</source>
          <target state="translated">Si se usa la invocación dinámica, el tipo de la instancia que hace la llamada en tiempo de ejecución (en lugar del tipo conocido en tiempo de compilación) determina a qué implementación del método se llama.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>To invoke a virtual method statically, the variable might have to be cast to a type that uses the desired version of the method.</source>
          <target state="translated">Para invocar un método virtual de manera estática, es posible que haya que convertir la variable en un tipo que use la versión deseada del método.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Sobrecarga</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Each type member has a unique signature.</source>
          <target state="translated">Cada miembro de tipo tiene una firma única.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Method signatures consist of the method name and a parameter list (the order and types of the method's arguments).</source>
          <target state="translated">Las firmas de método están formadas por el nombre del método y una lista de parámetros (el orden y los tipos de los argumentos del método).</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Multiple methods with the same name can be defined within a type as long as their signatures differ.</source>
          <target state="translated">Se pueden definir varios métodos con el mismo nombre dentro un tipo, siempre y cuando sus firmas sean distintas.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>When two or more methods with the same name are defined, the method is said to be overloaded.</source>
          <target state="translated">Cuando se definen dos o más métodos con el mismo nombre se dice que el método está sobrecargado.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>For example, in <bpt id="p1">[</bpt>System.Char<ept id="p1">](xref:System.Char)</ept>, the <ph id="ph1">`IsDigit`</ph> method is overloaded.</source>
          <target state="translated">Por ejemplo, en <bpt id="p1">[</bpt>System.Char<ept id="p1">](xref:System.Char)</ept>, se sobrecarga el método <ph id="ph1">`IsDigit`</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>One method takes a <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept>.</source>
          <target state="translated">Un método toma un argumento de tipo <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The other method takes a <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> and an <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>.</source>
          <target state="translated">El otro método toma un argumento de tipo <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> y un argumento de tipo <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>The return type is not considered part of a method's signature.</source>
          <target state="translated">El tipo de valor devuelto no se considera parte de la firma de un método.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>That is, methods cannot be overloaded if they differ only by return type.</source>
          <target state="translated">Es decir, no se pueden sobrecargar los métodos si solo difieren en el tipo de valor devuelto.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Inheriting, overriding, and hiding members</source>
          <target state="translated">Heredar, reemplazar y ocultar miembros</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A derived type inherits all members of its base type; that is, these members are defined on, and available to, the derived type.</source>
          <target state="translated">Un tipo derivado hereda todos los miembros de su tipo base, es decir, estos miembros se definen en el tipo derivado y están disponibles para él.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>The behavior or qualities of inherited members can be modified in two ways:</source>
          <target state="translated">El comportamiento o cualidades de los miembros heredados se puede modificar de dos maneras:</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>A derived type can hide an inherited member by defining a new member with the same signature.</source>
          <target state="translated">Un tipo derivado puede ocultar un miembro heredado definiendo un nuevo miembro con la misma firma.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>This might be done to make a previously public member private or to define new behavior for an inherited method that is marked as <ph id="ph1">`final`</ph>.</source>
          <target state="translated">Esto puede hacerse para convertir un miembro público en privado o para definir un nuevo comportamiento para un método heredado que está marcado como <ph id="ph1">`final`</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>A derived type can override an inherited virtual method.</source>
          <target state="translated">Un tipo derivado puede reemplazar a un método virtual heredado.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The overriding method provides a new definition of the method that will be invoked based on the type of the value at run time rather than the type of the variable known at compile time.</source>
          <target state="translated">El método de reemplazo proporciona una nueva definición del método que se invocará según el tipo del valor en tiempo de ejecución y no el tipo de la variable conocido en tiempo de compilación.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>A method can override a virtual method only if the virtual method is not marked as <ph id="ph1">`final`</ph> and the new method is at least as accessible as the virtual method.</source>
          <target state="translated">Un método puede invalidar un método virtual únicamente si el método virtual no está marcado como <ph id="ph1">`final`</ph> y el nuevo método es, al menos, tan accesible como el método virtual.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Vea también</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type conversion in the .NET Framework<ept id="p1">](type-conversion.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Conversión de tipos en .NET Framework<ept id="p1">](type-conversion.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>