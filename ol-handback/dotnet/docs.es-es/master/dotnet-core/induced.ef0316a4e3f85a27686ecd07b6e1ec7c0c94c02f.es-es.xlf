<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e120ba44f16b7e4c697d94d270b2ddcc9ae83c48</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\garbagecollection\induced.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c04b694d0e7710dabf1c5e6ec1489ad31ccd4ce6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ac8364d8a2c07281efe1a8f69f030ad6d5503aff</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Induced collections</source>
          <target state="translated">Recolecciones inducidas</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Induced collections</source>
          <target state="translated">Recolecciones inducidas</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Induced collections</source>
          <target state="translated">Recolecciones inducidas</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In most cases, the garbage collector can determine the best time to perform a collection, and you should let it run independently.</source>
          <target state="translated">En la mayoría de los casos, el recolector de elementos no utilizados puede determinar cuál es el mejor momento para realizar una recolección y se debe permitir su ejecución de forma independiente.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>There are rare situations when a forced collection might improve your application's performance.</source>
          <target state="translated">Hay ocasiones excepcionales en que una recolección forzada puede mejorar el rendimiento de la aplicación.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>In these cases, you can induce garbage collection by using the <bpt id="p1">[</bpt>GC.Collect<ept id="p1">](xref:System.GC.Collect)</ept> method to force a garbage collection.</source>
          <target state="translated">En estos casos, se puede inducir la recolección de elementos no utilizados usando el método <bpt id="p1">[</bpt>GC.Collect<ept id="p1">](xref:System.GC.Collect)</ept> para forzar una recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>Collect<ept id="p1">](xref:System.GC.Collect)</ept> method when there is a significant reduction in the amount of memory being used at a specific point in your application's code.</source>
          <target state="translated">Use el método <bpt id="p1">[</bpt>Collect<ept id="p1">](xref:System.GC.Collect)</ept> cuando haya una reducción significativa de la cantidad de memoria que se está usando en un punto específico del código de la aplicación.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For example, if your application uses a complex dialog box that has several controls, calling <bpt id="p1">[</bpt>Collect<ept id="p1">](xref:System.GC.Collect)</ept> when the dialog box is closed could improve performance by immediately reclaiming the memory used by the dialog box.</source>
          <target state="translated">Por ejemplo, si la aplicación usa un cuadro de diálogo complejo que tiene varios controles, llamar a <bpt id="p1">[</bpt>Collect<ept id="p1">](xref:System.GC.Collect)</ept> cuando se cierra el cuadro de diálogo podría mejorar el rendimiento porque reclama inmediatamente la memoria que usa este.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Be sure that your application is not inducing garbage collection too frequently, because that can decrease performance if the garbage collector is trying to reclaim objects at non-optimal times.</source>
          <target state="translated">Asegúrese de que la aplicación no induce la recolección de elementos no utilizados con demasiada frecuencia, ya que este hecho puede reducir el rendimiento si el recolector de elementos no utilizados intenta reclamar objetos en el momento inadecuado.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can supply a <bpt id="p1">[</bpt>GCCollectionMode.Optimized<ept id="p1">](xref:System.GCCollectionMode.Optimized)</ept> enumeration value to the <bpt id="p2">[</bpt>Collect<ept id="p2">](xref:System.GC.Collect)</ept> method to collect only when collection would be productive, as discussed in the next section.</source>
          <target state="translated">Puede proporcionar un valor de enumeración <bpt id="p1">[</bpt>GCCollectionMode.Optimized<ept id="p1">](xref:System.GCCollectionMode.Optimized)</ept> al método <bpt id="p2">[</bpt>Collect<ept id="p2">](xref:System.GC.Collect)</ept> para recolectar solo cuando la recolección sea productiva, como se explica en la sección siguiente.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>GC collection mode</source>
          <target state="translated">Modo de colección de GC</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You can use one of the <bpt id="p1">[</bpt>GC.Collect<ept id="p1">](xref:System.GC.Collect)</ept> method overloads that includes a <bpt id="p2">[</bpt>GCCollectionMode<ept id="p2">](xref:System.GCCollectionMode)</ept> value to specify the behavior for a forced collection as follows.</source>
          <target state="translated">Puede usar una de las sobrecargas del método <bpt id="p1">[</bpt>GC.Collect<ept id="p1">](xref:System.GC.Collect)</ept>, que incluye un valor <bpt id="p2">[</bpt>GCCollectionMode<ept id="p2">](xref:System.GCCollectionMode)</ept> para especificar el comportamiento de una recolección forzada, como se indica a continuación.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>GCCollectionMode value</source>
          <target state="translated">Valor GCCollectionMode</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Default<ept id="p1">](xref:System.GCCollectionMode.Default)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Predetermiado<ept id="p1">](xref:System.GCCollectionMode.Default)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Uses the default garbage collection setting for the running version of the .NET Framework.</source>
          <target state="translated">Usa el valor predeterminado de la recolección de elementos no utilizados para la versión de .NET Framework que se está ejecutando.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Forced<ept id="p1">](xref:System.GCCollectionMode.Forced)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Forzado<ept id="p1">](xref:System.GCCollectionMode.Forced)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Forces garbage collection to occur immediately.</source>
          <target state="translated">Obliga a que la recolección de elementos no utilizados se produzca inmediatamente.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling the <bpt id="p1">[</bpt>GC.Collect()<ept id="p1">](xref:System.GC.Collect)</ept> overload.</source>
          <target state="translated">Esto equivale a llamar a la sobrecarga <bpt id="p1">[</bpt>GC.Collect()<ept id="p1">](xref:System.GC.Collect)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>It results in a full blocking collection of all generations.</source>
          <target state="translated">Tiene como consecuencia una recolección completa de bloqueo de todas las generaciones.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You can also compact the large object heap by setting the <bpt id="p1">[</bpt>GCSettings.LargeObjectHeapCompactionMode<ept id="p1">](xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode)</ept> property to <bpt id="p2">[</bpt>GCLargeObjectHeapCompactionMode.CompactOnce<ept id="p2">](xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce)</ept> before forcing an immediate full blocking garbage collection.</source>
          <target state="translated">También puede compactar el montón de objeto grande estableciendo la propiedad <bpt id="p1">[</bpt>GCSettings.LargeObjectHeapCompactionMode<ept id="p1">](xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode)</ept> en <bpt id="p2">[</bpt>GCLargeObjectHeapCompactionMode.CompactOnce<ept id="p2">](xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce)</ept> antes de forzar una recolección de elementos no utilizados de bloqueo completa inmediata.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Optimized<ept id="p1">](xref:System.GCCollectionMode.Optimized)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Optimizado<ept id="p1">](xref:System.GCCollectionMode.Optimized)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Enables the garbage collector to determine whether the current time is optimal to reclaim objects.</source>
          <target state="translated">Permite al recolector de elementos no utilizados determinar si la hora actual es la adecuada para reclamar objetos.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The garbage collector could determine that a collection would not be productive enough to be justified, in which case it will return without reclaiming objects.</source>
          <target state="translated">El recolector de elementos no utilizados puede determinar que una recolección no esté justificada por su insuficiente productividad, en cuyo caso volverá sin reclamar objetos.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Background or blocking collections</source>
          <target state="translated">Colecciones de fondo o de bloqueo</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can call the <bpt id="p1">[</bpt>GC.Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> method overload to specify whether an induced collection is blocking or not.</source>
          <target state="translated">Puede llamar a la sobrecarga del método <bpt id="p1">[</bpt>GC.Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> para especificar si una recolección inducida se está bloqueando o no.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The type of collection performed depends on a combination of the method's <bpt id="p1">*</bpt>mode<ept id="p1">*</ept> and <bpt id="p2">*</bpt>blocking<ept id="p2">*</ept> parameters.</source>
          <target state="translated">El tipo de recolección realizado depende de una combinación de los parámetros <bpt id="p1">*</bpt>mode<ept id="p1">*</ept> y <bpt id="p2">*</bpt>blocking<ept id="p2">*</ept> del método.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>mode<ept id="p1">*</ept> is a member of the <bpt id="p2">[</bpt>GCCollectionMode<ept id="p2">](xref:System.GCCollectionMode)</ept> enumeration, and <bpt id="p3">*</bpt>blocking<ept id="p3">*</ept> is a <bpt id="p4">[</bpt>Boolean<ept id="p4">](xref:System.Boolean)</ept> value.</source>
          <target state="translated"><bpt id="p1">*</bpt>mode<ept id="p1">*</ept> es miembro de la enumeración <bpt id="p2">[</bpt>GCCollectionMode<ept id="p2">](xref:System.GCCollectionMode)</ept> y <bpt id="p3">*</bpt>blocking<ept id="p3">*</ept> es un valor <bpt id="p4">[</bpt>booleano<ept id="p4">](xref:System.Boolean)</ept>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following table summarizes the interaction of the mode and blocking arguments.</source>
          <target state="translated">En la tabla siguiente se resume la interacción de los argumentos mode y blocking.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>mode<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>mode<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>blocking<ept id="p1">*</ept> = true</source>
          <target state="translated"><bpt id="p1">*</bpt>blocking<ept id="p1">*</ept> = true</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>blocking<ept id="p1">*</ept> = false</source>
          <target state="translated"><bpt id="p1">*</bpt>blocking<ept id="p1">*</ept> = false</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Forced<ept id="p1">](xref:System.GCCollectionMode.Forced)</ept> or <bpt id="p2">[</bpt>Default<ept id="p2">](xref:System.GCCollectionMode.Default)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Forzado<ept id="p1">](xref:System.GCCollectionMode.Forced)</ept> o <bpt id="p2">[</bpt>predeterminado<ept id="p2">](xref:System.GCCollectionMode.Default)</ept></target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>A blocking collection is performed as soon as possible.</source>
          <target state="translated">Se realiza una recolección de bloqueo lo antes posible.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>If a background collection is in progress and generation is 0 or 1, the <bpt id="p1">[</bpt>Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> method immediately triggers a blocking collection and returns when the collection is finished.</source>
          <target state="translated">Si una recolección en segundo plano está en curso y la generación es 0 o 1, el método <bpt id="p1">[</bpt>Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> desencadena inmediatamente una recolección de bloqueo y vuelve cuando la recolección finaliza.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If a background collection is in progress and the generation parameter is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</source>
          <target state="translated">Si una recolección en segundo plano está en curso y el parámetro de generación es 2, el método espera hasta que finaliza la recolección en segundo plano, desencadena una generación de bloqueo 2 y luego vuelve.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A collection is performed as soon as possible.</source>
          <target state="translated">Se realiza una recolección lo antes posible.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated">El método <bpt id="p1">[</bpt>Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> solicita una recolección en segundo plano, pero esto no se garantiza; puede que aún se realice una recolección de bloqueo, dependiendo de las circunstancias.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">Si una colección en segundo plano ya está en curso, el método vuelve inmediatamente.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Optimized<ept id="p1">](xref:System.GCCollectionMode.Optimized)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Optimizado<ept id="p1">](xref:System.GCCollectionMode.Optimized)</ept></target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>A blocking collection may be performed, depending on the state of the garbage collector and the generation parameter.</source>
          <target state="translated">Se puede realizar una recolección de bloqueo, dependiendo del estado del recolector de elementos no utilizados y del parámetro de la generación.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">El recolector de elementos no utilizados intenta proporcionar un rendimiento óptimo.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>A collection may be performed, depending on the state of the garbage collector.</source>
          <target state="translated">Se puede realizar una recolección, según el estado del recolector de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated">El método <bpt id="p1">[</bpt>Collect(Int32, GCCollectionMode, Boolean)<ept id="p1">](xref:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean))</ept> solicita una recolección en segundo plano, pero esto no se garantiza; puede que aún se realice una recolección de bloqueo, dependiendo de las circunstancias.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">El recolector de elementos no utilizados intenta proporcionar un rendimiento óptimo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">Si una colección en segundo plano ya está en curso, el método vuelve inmediatamente.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vea también</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Latency modes<ept id="p1">](latency.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Modos de latencia<ept id="p1">](latency.md)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Garbage collection in .NET<ept id="p1">](index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recolección de elementos no utilizados en .NET<ept id="p1">](index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>