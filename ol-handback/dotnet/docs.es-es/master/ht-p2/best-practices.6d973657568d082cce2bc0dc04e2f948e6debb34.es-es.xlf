<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">00c7228c5cb906f41df5e60a318721008ecf0bb7</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\best-practices.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">29a81bfee1bf49fb6b417139448a333398f8a0b0</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">616dc0adea465d5634c737b35d49368088354910</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Best practices for regular expressions</source>
          <target state="translated">Procedimientos recomendados con expresiones regulares</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Best practices for regular expressions</source>
          <target state="translated">Procedimientos recomendados con expresiones regulares</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Best practices for regular expressions</source>
          <target state="translated">Procedimientos recomendados con expresiones regulares</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</source>
          <target state="translated">El motor de expresiones regulares de .NET es una herramienta eficaz y completa que procesa texto basándose en coincidencias de patrones en lugar de comparar y buscar coincidencias con texto literal.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In most cases, it performs pattern matching rapidly and efficiently.</source>
          <target state="translated">En la mayoría de los casos, realiza la coincidencia de modelos de manera rápida y eficaz.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>However, in some cases, the regular expression engine can appear to be very slow.</source>
          <target state="translated">Sin embargo, en algunos casos, puede parecer que el motor de expresiones regulares es muy lento.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</source>
          <target state="translated">En casos extremos, incluso puede parecer que deja de responder mientras procesa una entrada relativamente pequeña a lo largo de las horas o incluso los días.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</source>
          <target state="translated">En este tema se describen algunos de los procedimientos recomendados que los desarrolladores pueden adoptar para garantizar que sus expresiones regulares alcancen un rendimiento óptimo.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It contains the following sections:</source>
          <target state="translated">Contiene las siguientes secciones:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Consider the input source<ept id="p1">](#consider-the-input-source)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Considerar el origen de entrada<ept id="p1">](#consider-the-input-source)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Handle object instantiation appropriately<ept id="p1">](#handle-object-instantiation-appropriately)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Controlar la creación de instancias de objeto correctamente<ept id="p1">](#handle-object-instantiation-appropriately)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Take charge of backtracking<ept id="p1">](#take-charge-of-backtracking)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Controlar el retroceso<ept id="p1">](#take-charge-of-backtracking)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Use time-out values<ept id="p1">](#use-time-out-values)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Usar valores de tiempo de espera<ept id="p1">](#use-time-out-values)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Capture only when necessary<ept id="p1">](#capture-only-when-necessary)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Capturar solo cuando sea necesario<ept id="p1">](#capture-only-when-necessary)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Related topics<ept id="p1">](#related-topics)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Temas relacionados<ept id="p1">](#related-topics)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Consider the input source</source>
          <target state="translated">Considerar el origen de entrada</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In general, regular expressions can accept two types of input: constrained or unconstrained.</source>
          <target state="translated">En general, las expresiones regulares pueden aceptar dos tipos de datos de entrada: restringidos o sin restricciones.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Constrained input is text that originates from a known or reliable source and follows a predefined format.</source>
          <target state="translated">La entrada restringida es texto que se origina en una fuente conocida o confiable y sigue un formato predefinido.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</source>
          <target state="translated">La entrada sin restricciones es texto que se origina en un origen no confiable, como un usuario web, y puede no seguir un formato predefinido o esperado.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Regular expression patterns are typically written to match valid input.</source>
          <target state="translated">Los patrones de expresiones regulares se suelen escribir para buscar coincidencias con entradas válidas.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</source>
          <target state="translated">Es decir, los desarrolladores examinan el texto que desean buscar y escriben un patrón de expresión regular que coincida con él.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</source>
          <target state="translated">A continuación, los desarrolladores determinan si este patrón necesita alguna corrección o algún procesamiento adicional probándolo con varios elementos de entrada válidos.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</source>
          <target state="translated">Cuando el modelo coincide con todas las entradas válidas previstas, se declara que está listo para producción y se puede incluir en una aplicación comercial.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This makes a regular expression pattern suitable for matching constrained input.</source>
          <target state="translated">Esto hace que un patrón de expresión regular sea adecuado para entradas restringidas coincidentes.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>However, it does not make it suitable for matching unconstrained input.</source>
          <target state="translated">Sin embargo, no es adecuado para datos de entrada sin restricciones coincidentes.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</source>
          <target state="translated">Para buscar coincidencias con datos de entrada sin restricciones, una expresión regular debe poder administrar eficazmente tres clases de texto:</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>• Text that matches the regular expression pattern.</source>
          <target state="translated">• Texto que coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>• Text that does not match the regular expression pattern.</source>
          <target state="translated">• Texto que no coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>• Text that nearly matches the regular expression pattern.</source>
          <target state="translated">• Texto que casi coincide con el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The last text type is especially problematic for a regular expression that has been written to handle constrained input.</source>
          <target state="translated">El último tipo de texto es especialmente problemático para una expresión regular que se ha escrito para tratar datos de entrada restringidos.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If that regular expression also relies on extensive <bpt id="p1">[</bpt>backtracking<ept id="p1">](backtracking.md)</ept>, the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</source>
          <target state="translated">Si esa expresión regular también usa mucho <bpt id="p1">[</bpt>retroceso<ept id="p1">](backtracking.md)</ept>, el motor de expresiones regulares puede dedicar una cantidad de tiempo excesiva (en algunos casos, muchas horas o días) procesando texto aparentemente inofensivo.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</source>
          <target state="translated">En el ejemplo siguiente se utiliza una expresión regular que es propensa a un retroceso excesivo y que es probable que rechace direcciones de correo electrónico válidas.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You should not use it in an email validation routine.</source>
          <target state="translated">No debería utilizarse en una rutina de validación de correo electrónico.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you would like a regular expression that validates email addresses, see <bpt id="p1">[</bpt>How to: Verify that strings are in valid email format<ept id="p1">](verify-format.md)</ept>.</source>
          <target state="translated">Si quiere una expresión regular que valide las direcciones de correo electrónico, consulte <bpt id="p1">[</bpt>Cómo: Comprobar si las cadenas tienen un formato de correo electrónico válido<ept id="p1">](verify-format.md)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</source>
          <target state="translated">Por ejemplo, considere una expresión regular de uso muy frecuente pero sumamente problemática para validar el alias de una dirección de correo electrónico.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*$`</ph> is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</source>
          <target state="translated">Se escribe la expresión regular <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*$`</ph> para procesar qué se considera una dirección de correo electrónico válida, que consta de un carácter alfanumérico seguido de cero o más caracteres que pueden ser alfanuméricos, puntos o guiones.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The regular expression must end with an alphanumeric character.</source>
          <target state="translated">La expresión regular debe finalizar con un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</source>
          <target state="translated">Sin embargo, como se muestra en el ejemplo siguiente, aunque esta expresión regular trata la entrada válida fácilmente, su rendimiento es muy ineficaz cuando está procesando datos de entrada casi válidos.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</source>
          <target state="translated">Como muestra el resultado del ejemplo, el motor de expresiones regulares procesa el alias válido de correo electrónico casi en el mismo intervalo de tiempo independientemente de su longitud.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</source>
          <target state="translated">Por otra parte, cuando la dirección de correo electrónico casi válida tiene más de cinco caracteres, el tiempo de procesamiento se duplica aproximadamente por cada carácter de la cadena.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</source>
          <target state="translated">Esto significa que una cadena casi válida de 28 caracteres tardaría más de una hora en procesarse y una cadena casi válida de 33 caracteres tardaría casi un día en procesarse.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</source>
          <target state="translated">Como esta expresión regular se desarrolló teniendo en cuenta solamente el formato de entrada que había que hacer coincidir, no tiene en cuenta los datos de entrada que no coinciden con el patrón.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</source>
          <target state="translated">A su vez, esto puede permitir que unos datos de entrada sin restricciones que casi coinciden con el patrón de expresión regular reduzcan considerablemente el rendimiento.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>To solve this problem, you can do the following:</source>
          <target state="translated">Para resolver este problema, puede hacer lo siguiente:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</source>
          <target state="translated">A la hora de desarrollar un modelo, debe considerar cómo puede afectar el retroceso al rendimiento del motor de expresiones regulares, especialmente si la expresión regular está diseñada para procesar datos de entrada sin restricciones.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Take charge of backtracking<ept id="p1">](#take-charge-of-backtracking)</ept> section.</source>
          <target state="translated">Para obtener más información, consulte la sección <bpt id="p1">[</bpt>Controlar el retroceso<ept id="p1">](#take-charge-of-backtracking)</ept>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</source>
          <target state="translated">Probar exhaustivamente la expresión regular usando datos de entrada no válidos y casi válidos, así como datos de entrada válidos.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>To generate input for a particular regular expression randomly, you can use <bpt id="p1">[</bpt>Rex<ept id="p1">](http://research.microsoft.com/en-us/projects/rex/)</ept>, which is a regular expression exploration tool from Microsoft Research.</source>
          <target state="translated">Para generar de forma aleatoria la entrada para una expresión regular determinada, puede usar <bpt id="p1">[</bpt>Rex<ept id="p1">](http://research.microsoft.com/en-us/projects/rex/)</ept>, que es una herramienta de exploración de expresiones regulares de Microsoft Research.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Handle object instantiation appropriately</source>
          <target state="translated">Controlar la creación de instancias de objeto correctamente</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>At the heart of .NET’s regular expression object model is the <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class, which represents the regular expression engine.</source>
          <target state="translated">El núcleo del modelo de objetos de expresiones regulares de .NET es la clase <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>, que representa el motor de expresiones regulares.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Often, the single greatest factor that affects regular expression performance is the way in which the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> engine is used.</source>
          <target state="translated">A menudo, el mayor factor único que afecta al rendimiento de las expresiones regulares es la manera en que se emplea el motor de <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</source>
          <target state="translated">La definición de una expresión regular implica acoplar estrechamente el motor de expresiones regulares con un patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>That coupling process, whether it involves instantiating a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</source>
          <target state="translated">Ese proceso de acoplamiento es necesariamente costoso, tanto si consiste en crear una instancia de un objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> al pasar a su constructor una expresión regular como en llamar a un método estático al pasarle el patrón de expresión regular junto con la cadena que se va a analizar.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</source>
          <target state="translated">Puede acoplar el motor de expresiones regulares con un determinado patrón de expresión regular y, a continuación, usar el motor para buscar coincidencias con texto de varias maneras:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can call a static pattern-matching method, such as <bpt id="p1">[</bpt>Regex.Match(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String))</ept>.</source>
          <target state="translated">Puede llamar a un método estático de coincidencia de patrones como <bpt id="p1">[</bpt>Regex.Match(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String))</ept>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This does not require instantiation of a regular expression object.</source>
          <target state="translated">Para ello no es necesario crear instancias de un objeto de expresión regular.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You can instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object and call an instance pattern-matching method of an interpreted regular expression.</source>
          <target state="translated">Puede crear instancias de un objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> y llamar a una instancia de un método de coincidencia de patrones de una expresión regular interpretada.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This is the default method for binding the regular expression engine to a regular expression pattern.</source>
          <target state="translated">Este es el método predeterminado para enlazar el motor de expresiones regulares a un patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It results when a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated without an options argument that includes the <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> flag.</source>
          <target state="translated">Se produce cuando se crea una instancia de un objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> sin un argumento de opciones que incluya la marca <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object and call an instance pattern-matching method of a compiled regular expression.</source>
          <target state="translated">Puede crear instancias de un objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> y llamar a una instancia de un método de coincidencia de patrones de una expresión regular compilada.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Regular expression objects represent compiled patterns when a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated with an options argument that includes the <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> flag.</source>
          <target state="translated">Los objetos de expresiones regulares representan patrones compilados cuando se crea una instancia de un objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> con un argumento de opciones que incluye la marca <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</source>
          <target state="translated">El formato de la llamada al método (estático, interpretado o compilado) afecta al rendimiento si la misma expresión regular se usa repetidamente en llamadas a métodos o si una aplicación usa muchos objetos de expresiones regulares.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Static regular expressions</source>
          <target state="translated">Expresiones regulares estáticas</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</source>
          <target state="translated">Se recomienda el uso de métodos de expresiones regulares estáticas como alternativa a crear repetidamente instancias de un objeto de expresión regular con la misma expresión regular.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in instance method calls is cached internally by the regular expression engine.</source>
          <target state="translated">A diferencia de los patrones de expresiones regulares usados por los objetos de expresiones regulares, el motor de expresiones regulares almacena internamente en memoria caché los códigos de operación o el lenguaje intermedio de Microsoft (MSIL) compilado de los modelos empleados en las llamadas al método de instancia.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>For example, you might call a method to validate user input.</source>
          <target state="translated">Por ejemplo, puede llamar a un método para validar la entrada del usuario.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In this example, a method named <ph id="ph1">`IsValidCurrency`</ph> checks whether the user has entered a currency symbol followed by at least one decimal digit.</source>
          <target state="translated">En este ejemplo, un método denominado <ph id="ph1">`IsValidCurrency`</ph> comprueba si el usuario ha escrito un símbolo de moneda seguido al menos de un dígito decimal.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A very inefficient implementation of the <ph id="ph1">`IsValidCurrency`</ph> method is shown in the following example.</source>
          <target state="translated">En el ejemplo siguiente se muestra una implementación muy poco eficaz del método <ph id="ph1">`IsValidCurrency`</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Note that each method call reinstantiates a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object with the same pattern.</source>
          <target state="translated">Tenga en cuenta que cada llamada al método vuelve a crear una instancia de un objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> con el mismo patrón.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</source>
          <target state="translated">Esto, a su vez, significa que el patrón de expresión regular se debe volver a compilar cada vez que se llama al método.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>You should replace this inefficient code with a call to the static <bpt id="p1">[</bpt>Regex.IsMatch(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String))</ept> method.</source>
          <target state="translated">Debe reemplazar este código ineficaz con una llamada al método estático <bpt id="p1">[</bpt>Regex.IsMatch(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String))</ept>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This eliminates the need to instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</source>
          <target state="translated">Esto elimina la necesidad de crear instancias de un objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> cada vez que quiera llamar a un método de coincidencia de patrones y permite que el motor de expresiones regulares recupere una versión compilada de la expresión regular de su memoria caché.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>By default, the last 15 most recently used static regular expression patterns are cached.</source>
          <target state="translated">De forma predeterminada, se almacenan en caché los 15 últimos patrones de expresiones regulares estáticas usados recientemente.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <bpt id="p1">[</bpt>Regex.CacheSize<ept id="p1">](xref:System.Text.RegularExpressions.Regex.CacheSize)</ept> property.</source>
          <target state="translated">En el caso de las aplicaciones que necesitan un mayor número de expresiones regulares estáticas almacenadas en caché, el tamaño de la memoria caché se puede ajustar al establecer la propiedad <bpt id="p1">[</bpt>Regex.CacheSize<ept id="p1">](xref:System.Text.RegularExpressions.Regex.CacheSize)</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\p{Sc}+\s*\d+`</ph> that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</source>
          <target state="translated">La expresión regular <ph id="ph1">`\p{Sc}+\s*\d+`</ph> que se usa en este ejemplo comprueba que la cadena de entrada consta de un símbolo de moneda y al menos un dígito decimal.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The pattern is defined as shown in the following table.</source>
          <target state="translated">El patrón se define como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Match one or more characters in the Unicode Symbol, Currency category.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres de la categoría Símbolo Unicode, Moneda.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">Busca coincidencias con cero o más caracteres de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Buscar coincidencias con uno o más dígitos decimales.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Interpreted vs. compiled regular expressions</source>
          <target state="translated">Expresiones regulares interpretadas y compiladas</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Regular expression patterns that are not bound to the regular expression engine through the specification of the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option are interpreted.</source>
          <target state="translated">Se interpretan los patrones de expresiones regulares que no están enlazados al motor de expresiones regulares mediante la especificación de la opción <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</source>
          <target state="translated">Cuando se crea una instancia de un objeto de expresión regular, el motor de expresiones regulares convierte la expresión regular en un conjunto de códigos de operación.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</source>
          <target state="translated">Cuando se llama a un método de instancia, el compilador JIT ejecuta y convierte a MSIL los códigos de operación.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</source>
          <target state="translated">Del mismo modo, cuando se llama a un método estático de expresión regular y la expresión regular no se encuentra en la memoria caché, el motor de expresiones regulares convierte la expresión regular en un conjunto de códigos de operación y los almacena en memoria caché.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>It then converts these operation codes to MSIL so that the JIT compiler can execute them.</source>
          <target state="translated">A continuación, convierte estos códigos de operación a MSIL para que el compilador JIT pueda ejecutarlos.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Interpreted regular expressions reduce startup time at the cost of slower execution time.</source>
          <target state="translated">Las expresiones regulares interpretadas reducen el tiempo de inicio a costa de un tiempo de ejecución más lento.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</source>
          <target state="translated">Por eso, son más adecuadas cuando la expresión regular se usa en un número reducido de llamadas a métodos o si el número exacto de llamadas a métodos de expresión regular es desconocido pero se espera que sea pequeño.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</source>
          <target state="translated">A medida que aumenta el número de llamadas al método, la mejora de rendimiento del tiempo de inicio reducido queda oscurecida por una velocidad de ejecución más lenta.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Regular expression patterns that are bound to the regular expression engine through the specification of the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option are compiled.</source>
          <target state="translated">Se compilan los patrones de expresiones regulares que están enlazados al motor de expresiones regulares mediante la especificación de la opción <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</source>
          <target state="translated">Esto significa que, cuando se crea una instancia de un objeto de expresión regular, o cuando se llama a un método estático de expresión regular y la expresión regular no se encuentra en la memoria caché, el motor de expresiones regulares convierte la expresión regular a un conjunto intermedio de códigos de operación que, a continuación, convierte a MSIL.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>When a method is called, the JIT compiler executes the MSIL.</source>
          <target state="translated">Cuando se llama a un método, el compilador JIT ejecuta el código MSIL.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</source>
          <target state="translated">A diferencia de las expresiones regulares interpretadas, las expresiones regulares compiladas aumentan el tiempo de inicio pero ejecutan más deprisa los métodos individuales de coincidencia de patrones.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</source>
          <target state="translated">Por tanto, la ventaja de rendimiento resultante de compilar la expresión regular aumenta en proporción al número de métodos de expresiones regulares llamados.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</source>
          <target state="translated">En resumen, se recomienda usar expresiones regulares interpretadas al llamar a métodos de expresión regular con una expresión regular concreta con poca frecuencia relativamente.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</source>
          <target state="translated">Debe usar expresiones regulares compiladas al llamar a métodos de expresión regular con una expresión regular concreta con relativa frecuencia.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</source>
          <target state="translated">Es difícil determinar el umbral exacto en el que las velocidades de ejecución más lentas de las expresiones regulares interpretadas superan las mejoras de su menor tiempo de inicio, o el umbral en el que los tiempos de inicio más lentos de las expresiones regulares compiladas superan las mejoras de sus velocidades de ejecución más rápidas.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</source>
          <target state="translated">Depende de diversos factores, como la complejidad de la expresión regular y los datos específicos que procesa.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <bpt id="p1">[</bpt>Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> class to compare their execution times.</source>
          <target state="translated">Para determinar si las expresiones regulares interpretadas o compiladas ofrecen el mejor rendimiento para el escenario de su aplicación concreta, puede usar la clase <bpt id="p1">[</bpt>Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> para comparar sus tiempos de ejecución.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's The Financier.</source>
          <target state="translated">En el ejemplo siguiente, se compara el rendimiento de las expresiones regulares compiladas e interpretadas al leer las diez primeras frases y al leer todas las frases del texto The Financier de Theodore Dreiser.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</source>
          <target state="translated">Como muestra el resultado del ejemplo, cuando solo se realizan diez llamadas a métodos de coincidencia de expresión regular, una expresión regular interpreta proporciona un rendimiento mejor que una expresión regular compilada.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</source>
          <target state="translated">Sin embargo, una expresión regular compilada ofrece mejor rendimiento cuando se realiza un gran número de llamadas (en este caso, más de 13000).</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The regular expression pattern used in the example, <ph id="ph1">`\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`</ph>, is defined as shown in the following table.</source>
          <target state="translated">El patrón de expresión regular usado en el ejemplo, <ph id="ph1">`\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`</ph>, se define como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>`(\r?\n)</source>
          <target state="translated">`(\r?\n)</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>,?\s)`</source>
          <target state="translated">,?\s)`</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</source>
          <target state="translated">Buscar una coincidencia con cero o un retorno de carro seguido de un carácter de nueva línea, o cero o una coma seguida de un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>`(\w+((\r?\n)</source>
          <target state="translated">`(\w+((\r?\n)</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>,?\s))*`</source>
          <target state="translated">,?\s))*`</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</source>
          <target state="translated">Buscar coincidencias con cero o más apariciones de uno o más caracteres alfabéticos que van seguidos de cero o un retorno de carro y un carácter de nueva línea, o de cero o una coma seguida de un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Match a period, question mark, colon, semicolon, or exclamation point.</source>
          <target state="translated">Buscar una coincidencia con un punto, un signo de interrogación, dos puntos, punto y coma o un signo de exclamación.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Take charge of backtracking</source>
          <target state="translated">Controlar el retroceso</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</source>
          <target state="translated">Normalmente, el motor de expresiones regulares usa la progresión lineal para desplazarse a través de una cadena de entrada y compararla con un patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>However, when indeterminate quantifiers such as <bpt id="p1">__</bpt><ph id="ph1">*</ph><ept id="p1">__</ept>, <bpt id="p2">**</bpt><ph id="ph2">+</ph><ept id="p2">**</ept>, and <bpt id="p3">**</bpt>?<ept id="p3">**</ept></source>
          <target state="translated">En cambio, cuando se usan cuantificadores indeterminados como <bpt id="p1">__</bpt><ph id="ph1">*</ph><ept id="p1">__</ept>, <bpt id="p2">**</bpt><ph id="ph2">+</ph><ept id="p2">**</ept> y <bpt id="p3">**</bpt>?<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</source>
          <target state="translated">en un patrón de expresión regular, el motor de expresiones regulares puede abandonar una parte de las coincidencias parciales correctas y volver a un estado guardado previamente para buscar una coincidencia correcta de todo el patrón.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>This process is known as backtracking.</source>
          <target state="translated">Este proceso se denomina retroceso.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For more information on backtracking, see <bpt id="p1">[</bpt>Details of regular expression behavior<ept id="p1">](regex-behavior.md)</ept> and <bpt id="p2">[</bpt>Backtracking in regular expressions<ept id="p2">](backtracking.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el retroceso, consulte <bpt id="p1">[</bpt>Detalles del comportamiento de expresiones regulares<ept id="p1">](regex-behavior.md)</ept> y <bpt id="p2">[</bpt>Retroceso en expresiones regulares<ept id="p2">](backtracking.md)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Support for backtracking gives regular expressions power and flexibility.</source>
          <target state="translated">La compatibilidad con el retroceso aporta a las expresiones regulares eficacia y flexibilidad.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</source>
          <target state="translated">También deja la responsabilidad de controlar el funcionamiento del motor de expresiones regulares en manos de los desarrolladores de expresiones regulares.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</source>
          <target state="translated">Puesto que los desarrolladores no suelen ser conscientes de esta responsabilidad, su uso incorrecto del retroceso o su dependencia de un retroceso excesivo suele desempeñar el rol más significativo en la degradación del rendimiento de las expresiones regulares.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>In a worst-case scenario, execution time can double for each additional character in the input string.</source>
          <target state="translated">En un escenario de caso peor, el tiempo de ejecución puede duplicarse por cada carácter adicional de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</source>
          <target state="translated">De hecho, usando excesivamente el retroceso, es fácil crear el equivalente en programación de un bucle infinito si la entrada coincide casi con el patrón de expresiones regulares; el motor de expresiones regulares puede tardar horas o incluso días en procesar una cadena de entrada relativamente corta.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</source>
          <target state="translated">A menudo, las aplicaciones sufren una reducción del rendimiento por usar el retroceso a pesar de que el retroceso no es esencial para una coincidencia.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b\p{Lu}\w*\b`</ph> matches all words that begin with an uppercase character, as the following table shows.</source>
          <target state="translated">Por ejemplo, la expresión regular <ph id="ph1">`\b\p{Lu}\w*\b`</ph> busca una coincidencia con todas las palabras que comienzan por un carácter en mayúsculas, como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Match an uppercase character.</source>
          <target state="translated">Busca una coincidencia con un carácter en mayúsculas.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
          <target state="translated">Buscar una coincidencia con cero o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Finalizar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</source>
          <target state="translated">Puesto que un límite de palabra no es igual, o un subconjunto de, que un carácter alfabético, no hay ninguna posibilidad de que el motor de expresiones regulares cruce un límite de palabra cuando busca coincidencias con caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</source>
          <target state="translated">Esto significa que para esta expresión regular, el retroceso nunca puede contribuir al éxito global de cualquier coincidencia; solo puede degradar el rendimiento, ya que se fuerza que el motor de expresiones regulares guarde su estado para cada coincidencia preliminar correcta de un carácter alfabético.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>If you determine that backtracking is not necessary, you can disable it by using the <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element.</source>
          <target state="translated">Si determina que el retroceso no es necesario, puede deshabilitarlo mediante el elemento de lenguaje <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The following example parses an input string by using two regular expressions.</source>
          <target state="translated">En el ejemplo siguiente se analiza una cadena de entrada usando dos expresiones regulares.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The first, <ph id="ph1">`\b\p{Lu}\w*\b`</ph>, relies on backtracking.</source>
          <target state="translated">La primera, <ph id="ph1">`\b\p{Lu}\w*\b`</ph>, se basa en el retroceso.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The second, <ph id="ph1">`\b\p{Lu}(?&gt;\w*)\b`</ph>, disables backtracking.</source>
          <target state="translated">La segunda, <ph id="ph1">`\b\p{Lu}(?&gt;\w*)\b`</ph>, deshabilita el retroceso.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, they both produce the same result.</source>
          <target state="translated">Como muestra el resultado del ejemplo, ambas producen el mismo resultado.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>In many cases, backtracking is essential for matching a regular expression pattern to input text.</source>
          <target state="translated">En muchos casos, el retroceso es esencial para buscar una coincidencia de un patrón de expresión regular con el texto de entrada.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</source>
          <target state="translated">Sin embargo, el retroceso excesivo puede degradar gravemente el rendimiento y dar la impresión de que una aplicación ha dejado de responder.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</source>
          <target state="translated">En concreto, esto ocurre cuando se anidan los cuantificadores y el texto que coincide con la subexpresión externa es un subconjunto del texto que coincide con la subexpresión interna.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</source>
          <target state="translated">Además de evitar el retroceso excesivo, se debe utilizar la característica de tiempo de espera para garantizar que el retroceso excesivo no reduzca gravemente el rendimiento de la expresión regular.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Use time-out values<ept id="p1">](#use-time-out-values)</ept> section.</source>
          <target state="translated">Para obtener más información, consulte la sección <bpt id="p1">[</bpt>Usar valores de tiempo de espera<ept id="p1">](#use-time-out-values)</ept>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$`</ph> is intended to match a part number that consists of at least one alphanumeric character.</source>
          <target state="translated">Por ejemplo, el patrón de expresión regular <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$`</ph> está diseñado para buscar coincidencias con un número de pieza que contiene al menos un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</source>
          <target state="translated">Cualquier carácter adicional puede constar de un carácter alfanumérico, un guión, un carácter de subrayado o un punto, aunque el último carácter debe ser alfanumérico.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>A dollar sign terminates the part number.</source>
          <target state="translated">El número de pieza termina con un signo de dólar.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression <ph id="ph1">`[0-9A-Z]`</ph> is a subset of the subexpression <ph id="ph2">`[-.\w]*`</ph>.</source>
          <target state="translated">En algunos casos, este patrón de expresión regular puede presentar un rendimiento muy deficiente porque los cuantificadores están anidados y porque la subexpresión <ph id="ph1">`[0-9A-Z]`</ph> es un subconjunto de la subexpresión <ph id="ph2">`[-.\w]*`</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</source>
          <target state="translated">En estos casos, puede optimizar el rendimiento de la expresión regular quitando los cuantificadores anidados y reemplazando la subexpresión externa con una aserción de búsqueda anticipada o de búsqueda tardía de ancho cero.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</source>
          <target state="translated">Las aserciones de búsqueda anticipada y de búsqueda tardía son delimitadores; no mueven el puntero en la cadena de entrada, sino que realizan una búsqueda hacia delante o hacia atrás para comprobar si se cumple una condición especificada.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>For example, the part number regular expression can be rewritten as <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])\$$`</ph>.</source>
          <target state="translated">Por ejemplo, la expresión regular de número de pieza se puede volver a escribir como <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])\$$`</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>This regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">Este patrón de expresión regular se define como se muestra en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the input string.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias con el principio de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">Buscar coincidencias de un carácter alfanumérico.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The part number must consist of at least this character.</source>
          <target state="translated">El número de pieza debe constar al menos de este carácter.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of any word character, hyphen, or period.</source>
          <target state="translated">Buscar coincidencias con cero o más apariciones de cualquier carácter alfabético, guión o punto.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`</ph><ph id="ph2">\$</ph>]</source>
          <target state="translated"><ph id="ph1">`</ph><ph id="ph2">\$</ph>]</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Match a dollar sign.</source>
          <target state="translated">Buscar coincidencias con un signo de dólar.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</source>
          <target state="translated">Realizar una búsqueda anticipada del signo de dólar final para asegurarse de que el carácter anterior es alfanumérico.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`$`</ph> End the match at the end of the input string.</source>
          <target state="translated"><ph id="ph1">`$`</ph> Finalizar la búsqueda de coincidencias al final de la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The following example illustrates the use of this regular expression to match an array containing possible part numbers.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de esta expresión regular para encontrar una matriz que contiene los números de pieza posibles.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</source>
          <target state="translated">El lenguaje de expresiones regulares de .NET incluye los elementos del lenguaje siguientes, que puede usar para eliminar cuantificadores anidados.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Construcciones de agrupamiento en expresiones regulares<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Language element</source>
          <target state="translated">Elemento del lenguaje</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookahead.</source>
          <target state="translated">Búsqueda anticipada positiva de ancho cero.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Look ahead of the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> matches the input string.</source>
          <target state="translated">Realizar una búsqueda anticipada de la posición actual para determinar si <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> coincide con la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookahead.</source>
          <target state="translated">Búsqueda anticipada negativa de ancho cero.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Look ahead of the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> does not match the input string.</source>
          <target state="translated">Realizar una búsqueda anticipada de la posición actual para determinar si <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> no coincide con la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind.</source>
          <target state="translated">Búsqueda tardía positiva de ancho cero.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Look behind the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> matches the input string.</source>
          <target state="translated">Realizar una búsqueda tardía de la posición actual para determinar si <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> coincide con la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind.</source>
          <target state="translated">Búsqueda tardía negativa de ancho cero.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Look behind the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> does not match the input string.</source>
          <target state="translated">Realizar una búsqueda tardía de la posición actual para determinar si <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> no coincide con la cadena de entrada.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Use time-out values</source>
          <target state="translated">Usar valores de tiempo de espera</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</source>
          <target state="translated">Si sus expresiones regulares procesan datos de entrada que prácticamente coinciden con el patrón de expresiones regulares, normalmente se puede usar el retroceso excesivo, que afecta enormemente al rendimiento.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</source>
          <target state="translated">Además de analizar cuidadosamente el uso del retroceso y probar la expresión regular en entradas casi coincidentes, debe establecer siempre un valor de tiempo de espera para garantizar que el impacto del retroceso excesivo, si aparece, se reduzca al mínimo.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out.</source>
          <target state="translated">El intervalo de tiempo de espera de la expresión regular define el período de tiempo que el motor de expresiones regulares buscará una coincidencia única antes de que el tiempo se agote.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The default time-out interval is <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept>, which means that the regular expression will not time out.</source>
          <target state="translated">El intervalo de tiempo de espera predeterminado es <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept>, que significa que no se agotará el tiempo de la expresión regular.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You can override this value and define a time-out interval as follows:</source>
          <target state="translated">Puede invalidar este valor y definir un intervalo de tiempo de espera de la siguiente manera:</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>By providing a time-out value when you instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object by calling the <bpt id="p2">[</bpt>Regex(String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> constructor.</source>
          <target state="translated">Al proporcionar un valor de tiempo de espera al crear una instancia del objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> llamando al constructor <bpt id="p2">[</bpt>Regex(String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>By calling a static pattern matching method, such as <bpt id="p1">[</bpt>Regex.Match(String, String, RegexOptions, TimeSpan)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> or <bpt id="p2">[</bpt>Regex.Replace(String, String, String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept>, that includes a <bpt id="p3">*</bpt>matchTimeout<ept id="p3">*</ept> parameter.</source>
          <target state="translated">Al llamar a un método estático de coincidencia de patrones, como <bpt id="p1">[</bpt>Regex.Match(String, String, RegexOptions, TimeSpan)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> o <bpt id="p2">[</bpt>Regex.Replace(String, String, String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept>, que incluya un parámetro <bpt id="p3">*</bpt>matchTimeout<ept id="p3">*</ept>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> exception.</source>
          <target state="translated">Si ha definido un intervalo de tiempo de espera y no se encuentra ninguna coincidencia al final del intervalo, el método de expresiones regulares produce una excepción <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</source>
          <target state="translated">En el controlador de excepciones, puede elegir reintentar la búsqueda de coincidencias con un intervalo de tiempo de espera más largo, abandonar el intento de búsqueda de coincidencias y asumir que no hay ninguna coincidencia o abandonar el intento de búsqueda de coincidencias y registrar la información de excepción para futuros análisis.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`GetWordData`</ph> method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</source>
          <target state="translated">En el ejemplo siguiente se define un método <ph id="ph1">`GetWordData`</ph> que crea una instancia de una expresión regular con un tiempo de espera de 350 milisegundos para calcular el número de palabras y el promedio de caracteres de una palabra en un documento de texto.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is re-instantiated.</source>
          <target state="translated">Si se agota el tiempo de espera de la operación de coincidencia, el intervalo de tiempo de espera aumenta en 350 milisegundos y se vuelve a crear una instancia del objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</source>
          <target state="translated">Si el nuevo intervalo de tiempo de espera es mayor de 1 segundo, el método vuelve a producir la excepción y se la envía al llamador.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Capture only when necessary</source>
          <target state="translated">Capturar solo cuando sea necesario</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</source>
          <target state="translated">Las expresiones regulares de .NET admiten varias construcciones de agrupación, que permiten agrupar un patrón de expresión regular en una o más subexpresiones.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The most commonly used grouping constructs in .NET regular expression language are <bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>, which defines a numbered capturing group, and <bpt id="p4">*</bpt><bpt id="p5">*</bpt>(?&lt;<ept id="p5">*</ept><bpt id="p6">_</bpt>name<ept id="p6">_</ept><ept id="p4">*</ept><bpt id="p7">*</bpt><ph id="ph1">&gt;</ph><ept id="p7">*</ept><bpt id="p8">*</bpt><bpt id="p9">_</bpt>subexpression<ept id="p9">_</ept><ept id="p8">*</ept><bpt id="p10">*</bpt>)<ept id="p10">*</ept>*, which defines a named capturing group.</source>
          <target state="translated">Las construcciones de agrupación que más se usan en el lenguaje de expresiones regulares de .NET son <bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>, que define un grupo de captura numerado, y <bpt id="p4">*</bpt><bpt id="p5">*</bpt>(?&lt;<ept id="p5">*</ept><bpt id="p6">_</bpt>name<ept id="p6">_</ept><ept id="p4">*</ept><bpt id="p7">*</bpt><ph id="ph1">&gt;</ph><ept id="p7">*</ept><bpt id="p8">*</bpt><bpt id="p9">_</bpt>subexpression<ept id="p9">_</ept><ept id="p8">*</ept><bpt id="p10">*</bpt>)<ept id="p10">*</ept>*, que define un grupo de captura con nombre.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</source>
          <target state="translated">Las construcciones de agrupación son esenciales para crear referencias inversas y para definir una subexpresión a la que se aplica un cuantificador.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>However, the use of these language elements has a cost.</source>
          <target state="translated">Sin embargo, el uso de estos elementos de lenguaje tiene un costo.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>They cause the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <bpt id="p3">[</bpt>CaptureCollection<ept id="p3">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object returned by the <bpt id="p4">[</bpt>Group.Captures<ept id="p4">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property of a particular capturing group with multiple <bpt id="p5">[</bpt>Capture<ept id="p5">](xref:System.Text.RegularExpressions.Capture)</ept> objects.</source>
          <target state="translated">Hacen que el objeto <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> devuelto por la propiedad <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> se rellene con las capturas sin nombre o con nombre más recientes, y si una única construcción de agrupación ha capturado varias subcadenas en la cadena de entrada, también rellenan el objeto <bpt id="p3">[</bpt>CaptureCollection<ept id="p3">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> devuelto por la propiedad <bpt id="p4">[</bpt>Group.Captures<ept id="p4">](xref:System.Text.RegularExpressions.Group.Captures)</ept> de un grupo de captura determinado con varios objetos <bpt id="p5">[</bpt>Capture<ept id="p5">](xref:System.Text.RegularExpressions.Capture)</ept>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</source>
          <target state="translated">A menudo, las construcciones de agrupación se usan en una expresión regular solo para poder aplicarles cuantificadores y los grupos capturados por estas subexpresiones no se usan posteriormente.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b(\w+[;,]?\s?)+[.?!]`</ph> is designed to capture an entire sentence.</source>
          <target state="translated">Por ejemplo, la expresión regular <ph id="ph1">`\b(\w+[;,]?\s?)+[.?!]`</ph> está diseñada para capturar una frase completa.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The following table describes the language elements in this regular expression pattern and their effect on the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> object's <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> and <bpt id="p3">[</bpt>Group.Captures<ept id="p3">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collections.</source>
          <target state="translated">En la tabla siguiente, se describen los elementos del lenguaje de este patrón de expresión regular y su efecto sobre las colecciones <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> y <bpt id="p3">[</bpt>Group.Captures<ept id="p3">](xref:System.Text.RegularExpressions.Group.Captures)</ept> del objeto <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modelo</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Iniciar la búsqueda de coincidencias en un límite de palabras.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Buscar coincidencias con uno o más caracteres alfabéticos.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Match zero or one comma or semicolon.</source>
          <target state="translated">Buscar coincidencias con cero o una coma o un punto y coma.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Busca coincidencias con cero o un carácter de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</source>
          <target state="translated">Buscar coincidencias con una o más apariciones de uno o más caracteres alfabéticos seguidos de una coma o un punto y coma opcional, seguido de un carácter opcional de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</source>
          <target state="translated">Esto define al primer grupo de captura, que es necesario para que la combinación de varios caracteres alfabéticos (es decir, una palabra) seguidos de un signo de puntuación opcional se repita hasta que el motor de expresiones regulares llegue al final de una frase.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Match a period, question mark, or exclamation point.</source>
          <target state="translated">Buscar coincidencias con un punto, un signo de interrogación o un signo de exclamación.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>As the following example shows, when a match is found, both the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> objects are populated with captures from the match.</source>
          <target state="translated">Como se muestra en el ejemplo siguiente, cuando se encuentra una coincidencia, los objetos <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> y <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> se rellenan con capturas de la coincidencia.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>In this case, the capturing group <ph id="ph1">`(\w+[;,]?\s?)`</ph> exists so that the <bpt id="p1">**</bpt><ph id="ph2">+</ph><ept id="p1">**</ept> quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</source>
          <target state="translated">En este caso, el grupo de captura <ph id="ph1">`(\w+[;,]?\s?)`</ph> existe para que se le pueda aplicar el cuantificador <bpt id="p1">**</bpt><ph id="ph2">+</ph><ept id="p1">**</ept>, que permite que el patrón de expresión regular coincida con cada palabra de una frase.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Otherwise, it would match the last word in a sentence.</source>
          <target state="translated">De lo contrario, coincidiría con la última palabra de una frase.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</source>
          <target state="translated">Cuando use subexpresiones solo para aplicarles cuantificadores y no le interese el texto capturado, debe deshabilitar las capturas de grupo.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element prevents the group to which it applies from capturing matched substrings.</source>
          <target state="translated">Por ejemplo, el elemento de lenguaje <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> impide al grupo al que se aplica que capture subcadenas coincidentes.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression pattern from the previous example is changed to <ph id="ph1">`\b(?:\w+[;,]?\s?)+[.?!]`</ph>.</source>
          <target state="translated">En el ejemplo siguiente, el patrón de expresión regular del ejemplo anterior se cambia a <ph id="ph1">`\b(?:\w+[;,]?\s?)+[.?!]`</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>As the output shows, it prevents the regular expression engine from populating the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collections.</source>
          <target state="translated">Como muestra el resultado, evita que el motor de expresiones regulares rellene las colecciones <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> y <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>You can disable captures in one of the following ways:</source>
          <target state="translated">Puede deshabilitar las capturas de una de las maneras siguientes:</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element.</source>
          <target state="translated">Use el elemento de lenguaje <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>This element prevents the capture of matched substrings in the group to which it applies.</source>
          <target state="translated">Este elemento impide la captura de subcadenas coincidentes en el grupo al que se aplica.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>It does not disable substring captures in any nested groups.</source>
          <target state="translated">No deshabilita las capturas de subcadenas en ningún grupo anidado.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">Use la opción <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>It disables all unnamed or implicit captures in the regular expression pattern.</source>
          <target state="translated">Deshabilita todas las capturas sin nombre o implícitas en el patrón de expresión regular.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>When you use this option, only substrings that match named groups defined with the <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept><bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> language element can be captured.</source>
          <target state="translated">Cuando se usa esta opción, solo se pueden capturar las subcadenas que coinciden con grupos con nombre definidos con el elemento de lenguaje <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept><bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> flag can be passed to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or to the options parameter of a <bpt id="p3">[</bpt>Regex<ept id="p3">](xref:System.Text.RegularExpressions.Regex)</ept> static matching method.</source>
          <target state="translated">La marca <bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> puede pasarse al parámetro de opciones de un constructor de clase <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> o al parámetro de opciones de un método coincidente estático <bpt id="p3">[</bpt>Regex<ept id="p3">](xref:System.Text.RegularExpressions.Regex)</ept>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>n<ept id="p1">**</ept> option in the <bpt id="p2">**</bpt>(?imnsx)<ept id="p2">**</ept> language element.</source>
          <target state="translated">Use la opción <bpt id="p1">**</bpt>n<ept id="p1">**</ept> del elemento de lenguaje <bpt id="p2">**</bpt>(?imnsx)<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</source>
          <target state="translated">Esta opción deshabilita todas las capturas sin nombre o implícitas desde el punto del patrón de expresión regular en el que aparece el elemento.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Captures are disabled either until the end of the pattern or until the <bpt id="p1">**</bpt>(-n)<ept id="p1">**</ept> option enables unnamed or implicit captures.</source>
          <target state="translated">Las capturas se deshabilitan hasta el final del patrón o hasta que la opción <bpt id="p1">**</bpt>(-n)<ept id="p1">**</ept> habilita las capturas sin nombre o implícitas.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Miscellaneous constructs in regular expressions<ept id="p1">](miscellaneous.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Construcciones misceláneas en expresiones regulares<ept id="p1">](miscellaneous.md)</ept>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>n<ept id="p1">**</ept> option in the <bpt id="p2">**</bpt>(?imnsx:<ept id="p2">**</ept><bpt id="p3">_</bpt>subexpression<ept id="p3">_</ept><bpt id="p4">**</bpt>)<ept id="p4">**</ept> language element.</source>
          <target state="translated">Use la opción <bpt id="p1">**</bpt>n<ept id="p1">**</ept> del elemento de lenguaje <bpt id="p2">**</bpt>(?imnsx:<ept id="p2">**</ept><bpt id="p3">_</bpt>subexpression<ept id="p3">_</ept><bpt id="p4">**</bpt>)<ept id="p4">**</ept>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>This option disables all unnamed or implicit captures in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>.</source>
          <target state="translated">Esta opción deshabilita todas las capturas sin nombre o implícitas en <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Captures by any unnamed or implicit nested capturing groups are disabled as well.</source>
          <target state="translated">Las capturas por grupos de captura anidados sin nombre o implícitos también se deshabilitan.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="translated">Temas relacionados</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Título</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Details of regular expression behavior<ept id="p1">](regex-behavior.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Detalles del comportamiento de expresiones regulares<ept id="p1">](regex-behavior.md)</ept></target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Examines the implementation of the regular expression engine in .NET.</source>
          <target state="translated">Examina la implementación del motor de expresiones regulares de .NET.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</source>
          <target state="translated">El tema se centra en la flexibilidad de las expresiones regulares y explica la responsabilidad del desarrollador para garantizar un funcionamiento eficaz y sólido del motor de expresiones regulares.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking in regular expressions<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Retroceso en expresiones regulares<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</source>
          <target state="translated">Explica qué es el retroceso y cómo afecta al rendimiento de las expresiones regulares, y examine los elementos del lenguaje que proporcionan alternativas al retroceso.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lenguaje de expresiones regulares: referencia rápida<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</source>
          <target state="translated">Describe los elementos del lenguaje de expresiones regulares de .NET y proporciona vínculos a documentación detallada sobre cada elemento del lenguaje.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>