<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">84574006b2e2ccc669fdd83ebfb6eec06b00f041</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\language-reference\error-messages\copying-the-value-of-byref-parameter-back-to-the-matching-argument-narrows.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ff0866c44a9d55824685e5b354178e390469a9d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c692df7cb60942abb4f052b86df555a646810bfa</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Copying the value of &amp;#39;ByRef&amp;#39; parameter &amp;#39;<ph id="ph1">&amp;lt;</ph>parametername<ph id="ph2">&amp;gt;</ph>&amp;#39; back to the matching argument narrows from type &amp;#39;<ph id="ph3">&amp;lt;</ph>typename1<ph id="ph4">&amp;gt;</ph>&amp;#39; to type &amp;#39;<ph id="ph5">&amp;lt;</ph>typename2<ph id="ph6">&amp;gt;</ph>&amp;#39; | Microsoft Docs</source>
          <target state="translated">Copiar el valor del parámetro 'ByRef' '<ph id="ph1">&amp;lt;</ph>parametername<ph id="ph2">&amp;gt;</ph>'en el argumento coincidente restringe del tipo'<ph id="ph3">&amp;lt;</ph>NombreTipo1<ph id="ph4">&amp;gt;</ph>' al tipo'<ph id="ph5">&amp;lt;</ph>en NombreTipo2<ph id="ph6">&amp;gt;</ph>' | Documentos de Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Copying the value of &amp;#39;ByRef&amp;#39; parameter &amp;#39;<ph id="ph1">&amp;lt;</ph>parametername<ph id="ph2">&amp;gt;</ph>&amp;#39; back to the matching argument narrows from type &amp;#39;<ph id="ph3">&amp;lt;</ph>typename1<ph id="ph4">&amp;gt;</ph>&amp;#39; to type &amp;#39;<ph id="ph5">&amp;lt;</ph>typename2<ph id="ph6">&amp;gt;</ph>&amp;#39;</source>
          <target state="translated">Copiar el valor del parámetro 'ByRef' '<ph id="ph1">&amp;lt;</ph>parametername<ph id="ph2">&amp;gt;</ph>'en el argumento coincidente restringe del tipo'<ph id="ph3">&amp;lt;</ph>NombreTipo1<ph id="ph4">&amp;gt;</ph>' al tipo'<ph id="ph5">&amp;lt;</ph>en NombreTipo2<ph id="ph6">&amp;gt;</ph>'</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A procedure is called with an argument that widens to the corresponding parameter type, and the conversion from the parameter to the argument is narrowing.</source>
          <target state="translated">Se llama a un procedimiento con un argumento que se amplía al tipo de parámetro correspondiente, y la conversión del parámetro al argumento es de restricción.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>When you define a class or structure, you can define one or more conversion operators to convert that class or structure type to other types.</source>
          <target state="translated">Al definir una clase o estructura, puede definir uno o varios operadores de conversión para convertir ese tipo de clase o estructura a otros tipos.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can also define reverse conversion operators to convert those other types back to your class or structure type.</source>
          <target state="translated">También puede definir operadores de conversión inversos para convertir esos otros tipos de nuevo a su clase o tipo de estructura.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>When you use your class or structure type in a procedure call, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> can use these conversion operators to convert the type of an argument to the type of its corresponding parameter.</source>
          <target state="translated">Cuando utilice su tipo de clase o estructura en una llamada de procedimiento, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> puede utilizar estos operadores de conversión para convertir el tipo de un argumento al tipo del parámetro correspondiente.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>If you pass the argument <bpt id="p1">[</bpt>ByRef<ept id="p1">](../../../visual-basic/language-reference/modifiers/byref.md)</ept>, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> sometimes copies the argument value into a local variable in the procedure instead of passing a reference.</source>
          <target state="translated">Si se pasa el argumento <bpt id="p1">[</bpt>ByRef<ept id="p1">](../../../visual-basic/language-reference/modifiers/byref.md)</ept>, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> a veces copia el valor del argumento en una variable local en el procedimiento en lugar de pasar una referencia.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In such a case, when the procedure returns, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> must then copy the local variable value back into the argument in the calling code.</source>
          <target state="translated">En tal caso, cuando el procedimiento vuelve, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> , a continuación, debe copiar el valor de la variable local en el argumento en el código de llamada.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>If a <ph id="ph1">`ByRef`</ph> argument value is copied into the procedure and the argument and parameter are of the same type, no conversion is necessary.</source>
          <target state="translated">Si un valor de argumento <ph id="ph1">`ByRef`</ph> se copia en el procedimiento y el argumento y el parámetro son del mismo tipo, no es necesario realizar ninguna conversión.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>But if the types are different, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> must convert in both directions.</source>
          <target state="translated">Pero si los tipos son diferentes, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> debe convertir en ambas direcciones.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If one of the types is your class or structure type, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> must convert it both to and from the other type.</source>
          <target state="translated">Si uno de los tipos es su tipo de clase o estructura, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> debe convertir a y desde el otro tipo.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>If one of these conversions is widening, the reverse conversion might be narrowing.</source>
          <target state="translated">Si una de estas conversiones es de ampliación, la conversión inversa podría ser de restricción.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Error ID:<ept id="p1">**</ept> BC32053</source>
          <target state="translated"><bpt id="p1">**</bpt>Id. de error:<ept id="p1">**</ept> BC32053</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>To correct this error</source>
          <target state="translated">Para corregir este error</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If possible, use a calling argument of the same type as the procedure parameter, so <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> does not need to do any conversion.</source>
          <target state="translated">Si es posible, utilice un argumento de llamada del mismo tipo como el parámetro de procedimiento, por lo que <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> no es necesario realizar ninguna conversión.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>If you need to call the procedure with an argument type different from the parameter type but do not need to return a value into the calling argument, define the parameter to be <bpt id="p1">[</bpt>ByVal<ept id="p1">](../../../visual-basic/language-reference/modifiers/byval.md)</ept> instead of <ph id="ph1">`ByRef`</ph>.</source>
          <target state="translated">Si necesita llamar al procedimiento con un argumento de tipo diferente del tipo de parámetro pero no es necesario devolver un valor al argumento de llamada, defina el parámetro para que sea <bpt id="p1">[</bpt>ByVal<ept id="p1">](../../../visual-basic/language-reference/modifiers/byval.md)</ept> en lugar de <ph id="ph1">`ByRef`</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>If you need to return a value into the calling argument, define the reverse conversion operator as <bpt id="p1">[</bpt>Widening<ept id="p1">](../../../visual-basic/language-reference/modifiers/widening.md)</ept>, if possible.</source>
          <target state="translated">Si necesita devolver un valor al argumento de llamada, defina el operador de conversión inversa como <bpt id="p1">[</bpt>Widening<ept id="p1">](../../../visual-basic/language-reference/modifiers/widening.md)</ept>, si es posible.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vea también</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Procedures<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Procedimientos<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Procedure Parameters and Arguments<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/procedure-parameters-and-arguments.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Argumentos y parámetros de procedimiento<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/procedure-parameters-and-arguments.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Passing Arguments by Value and by Reference<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/passing-arguments-by-value-and-by-reference.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Pasar argumentos por valor y por referencia<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/passing-arguments-by-value-and-by-reference.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Operator Procedures<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/operator-procedures.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Procedimientos de operadores<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/operator-procedures.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Operator Statement<ept id="p1">](../../../visual-basic/language-reference/statements/operator-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Operator (instrucción)<ept id="p1">](../../../visual-basic/language-reference/statements/operator-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Define an Operator<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/how-to-define-an-operator.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Cómo: definir un operador<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/how-to-define-an-operator.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Define a Conversion Operator<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/how-to-define-a-conversion-operator.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Cómo: definir un operador de conversión<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/how-to-define-a-conversion-operator.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Type Conversions in Visual Basic<ept id="p1">](../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Conversiones de tipos en Visual Basic<ept id="p1">](../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Widening and Narrowing Conversions<ept id="p1">](../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Conversiones de ampliación y de restricción<ept id="p1">](../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>