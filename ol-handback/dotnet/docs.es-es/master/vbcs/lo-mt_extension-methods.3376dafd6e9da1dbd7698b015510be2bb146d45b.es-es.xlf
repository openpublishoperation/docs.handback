<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">381fa0db2d92590d23ebd71a7823a8465e94a6e6</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\procedures\extension-methods.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">84bb72899e1213c1873b9817f0c4227980c03199</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56d34f039b1438766543d5745213bed0cee6296d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Extension Methods (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Métodos de extensión (Visual Basic) | Documentos de Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Extension Methods (Visual Basic)</source>
          <target state="translated">Métodos de extensión (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Extension methods enable developers to add custom functionality to data types that are already defined without creating a new derived type.</source>
          <target state="translated">Métodos de extensión permiten a los programadores agregar funcionalidad personalizada a los tipos de datos que ya están definidos sin crear un nuevo tipo derivado.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Extension methods make it possible to write a method that can be called as if it were an instance method of the existing type.</source>
          <target state="translated">Métodos de extensión permiten escribir un método que se puede llamar como si fuera un método de instancia del tipo existente.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Comentarios</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>An extension method can be only a <ph id="ph1">`Sub`</ph> procedure or a <ph id="ph2">`Function`</ph> procedure.</source>
          <target state="translated">Un método de extensión puede ser sólo una <ph id="ph1">`Sub`</ph> procedimiento o una <ph id="ph2">`Function`</ph> procedimiento.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You cannot define an extension property, field, or event.</source>
          <target state="translated">No se puede definir una propiedad de extensión, campo o evento.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>All extension methods must be marked with the extension attribute <ph id="ph1">`&lt;Extension()&gt;`</ph> from the &lt;xref:System.Runtime.CompilerServices?displayProperty=fullName&gt; namespace.</source>
          <target state="translated">Todos los métodos de extensión se deben marcar con el atributo de extensión <ph id="ph1">`&lt;Extension()&gt;`</ph> desde el &lt;xref:System.Runtime.CompilerServices?displayProperty=fullName&gt;espacio de nombres.&lt;/xref:System.Runtime.CompilerServices?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The first parameter in an extension method definition specifies which data type the method extends.</source>
          <target state="translated">El primer parámetro de una definición de método de extensión especifica qué tipo de datos extiende el método.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When the method is run, the first parameter is bound to the instance of the data type that invokes the method.</source>
          <target state="translated">Cuando se ejecuta el método, el primer parámetro se enlaza a la instancia del tipo de datos que invoca el método.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Ejemplo</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`Print`</ph> extension to the &lt;xref:System.String&gt; data type.</source>
          <target state="translated">En el ejemplo siguiente se define un <ph id="ph1">`Print`</ph> extensión a la &lt;xref:System.String&gt;el tipo de datos.&lt;/xref:System.String&gt;</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The method uses <ph id="ph1">`Console.WriteLine`</ph> to display a string.</source>
          <target state="translated">El método usa <ph id="ph1">`Console.WriteLine`</ph> para mostrar una cadena.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The parameter of the <ph id="ph1">`Print`</ph> method, <ph id="ph2">`aString`</ph>, establishes that the method extends the &lt;xref:System.String&gt; class.</source>
          <target state="translated">El parámetro de la <ph id="ph1">`Print`</ph> método <ph id="ph2">`aString`</ph>, Establece que el método extiende la &lt;xref:System.String&gt;clase.&lt;/xref:System.String&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#1<ept id="p2">](./codesnippet/VisualBasic/extension-methods_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>1 VbVbalrExtensionMethods<ept id="p2">](./codesnippet/VisualBasic/extension-methods_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Notice that the extension method definition is marked with the extension attribute <ph id="ph1">`&lt;Extension()&gt;`</ph>.</source>
          <target state="translated">Observe que la definición del método de extensión está marcada con el atributo de extensión <ph id="ph1">`&lt;Extension()&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Marking the module in which the method is defined is optional, but each extension method must be marked.</source>
          <target state="translated">Marcar el módulo en el que se define el método es opcional, pero se debe marcar cada método de extensión.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Runtime.CompilerServices&gt; must be imported in order to access the extension attribute.</source>
          <target state="translated">&lt;xref:System.Runtime.CompilerServices&gt;se debe importar con el fin de obtener acceso al atributo de extensión.&lt;/xref:System.Runtime.CompilerServices&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Extension methods can be declared only within modules.</source>
          <target state="translated">Métodos de extensión se pueden declarar únicamente dentro de los módulos.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Typically, the module in which an extension method is defined is not the same module as the one in which it is called.</source>
          <target state="translated">Normalmente, el módulo en el que se define un método de extensión no es el mismo módulo que la que se llama.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Instead, the module that contains the extension method is imported, if it needs to be, to bring it into scope.</source>
          <target state="translated">En su lugar, se importa el módulo que contiene el método de extensión, si debe ser para poner al alcance.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>After the module that contains <ph id="ph1">`Print`</ph> is in scope, the method can be called as if it were an ordinary instance method that takes no arguments, such as <ph id="ph2">`ToUpper`</ph>:</source>
          <target state="translated">Después del módulo que contiene <ph id="ph1">`Print`</ph> está en el ámbito, el método puede llamarse como si fuera un método de instancia normal que no toma ningún argumento, como <ph id="ph2">`ToUpper`</ph>:</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#2<ept id="p2">](./codesnippet/VisualBasic/extension-methods_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#2;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The next example, <ph id="ph1">`PrintAndPunctuate`</ph>, is also an extension to &lt;xref:System.String&gt;, this time defined with two parameters.</source>
          <target state="translated">El ejemplo siguiente, <ph id="ph1">`PrintAndPunctuate`</ph>, también es una extensión &lt;xref:System.String&gt;, esta vez definida con dos parámetros.&lt;/xref:System.String&gt;</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The first parameter, <ph id="ph1">`aString`</ph>, establishes that the extension method extends &lt;xref:System.String&gt;.</source>
          <target state="translated">El primer parámetro, <ph id="ph1">`aString`</ph>, Establece que el método de extensión extiende &lt;xref:System.String&gt;.&lt;/xref:System.String&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The second parameter, <ph id="ph1">`punc`</ph>, is intended to be a string of punctuation marks that is passed in as an argument when the method is called.</source>
          <target state="translated">El segundo parámetro, <ph id="ph1">`punc`</ph>, está pensado para ser una cadena de signos de puntuación que se pasa como argumento cuando se llama al método.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The method displays the string followed by the punctuation marks.</source>
          <target state="translated">El método muestra la cadena seguida de los signos de puntuación.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#3<ept id="p2">](./codesnippet/VisualBasic/extension-methods_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;3;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The method is called by sending in a string argument for <ph id="ph1">`punc`</ph>: <ph id="ph2">`example.PrintAndPunctuate(".")`</ph></source>
          <target state="translated">Se llama al método enviando un argumento de cadena para <ph id="ph1">`punc`</ph>:<ph id="ph2">`example.PrintAndPunctuate(".")`</ph></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The following example shows <ph id="ph1">`Print`</ph> and <ph id="ph2">`PrintAndPunctuate`</ph> defined and called.</source>
          <target state="translated">El ejemplo siguiente muestra <ph id="ph1">`Print`</ph> y <ph id="ph2">`PrintAndPunctuate`</ph> define y llama.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Runtime.CompilerServices&gt; is imported in the definition module in order to enable access to the extension attribute.</source>
          <target state="translated">&lt;xref:System.Runtime.CompilerServices&gt;se importa en el módulo de definición para permitir el acceso al atributo de extensión.&lt;/xref:System.Runtime.CompilerServices&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Código</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Next, the extension methods are brought into scope and called.</source>
          <target state="translated">A continuación, los métodos de extensión se incluyen en el ámbito y se llama.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comentarios</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>All that is required to be able to run these or similar extension methods is that they be in scope.</source>
          <target state="translated">Todo lo que es necesario para poder ejecutar estas o métodos de extensión similares es que estén en el ámbito.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If the module that contains an extension method is in scope, it is visible in IntelliSense and can be called as if it were an ordinary instance method.</source>
          <target state="translated">Si el módulo que contiene un método de extensión está en ámbito, está visible en IntelliSense y pueden llamarse como si fuera un método de instancia normal.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Notice that when the methods are invoked, no argument is sent in for the first parameter.</source>
          <target state="translated">Observe que cuando se invocan los métodos, se envía ningún argumento para el primer parámetro.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Parameter <ph id="ph1">`aString`</ph> in the previous method definitions is bound to <ph id="ph2">`example`</ph>, the instance of <ph id="ph3">`String`</ph> that calls them.</source>
          <target state="translated">Parámetro <ph id="ph1">`aString`</ph> en el método anterior, las definiciones se enlaza a <ph id="ph2">`example`</ph>, la instancia de <ph id="ph3">`String`</ph> que llama.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The compiler will use <ph id="ph1">`example`</ph> as the argument sent to the first parameter.</source>
          <target state="translated">El compilador usa <ph id="ph1">`example`</ph> como el argumento enviado al primer parámetro.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If an extension method is called for an object that is set to <ph id="ph1">`Nothing`</ph>, the extension method executes.</source>
          <target state="translated">Si se llama a un método de extensión para un objeto que se establece en <ph id="ph1">`Nothing`</ph>, se ejecuta el método de extensión.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This does not apply to ordinary instance methods.</source>
          <target state="translated">No se aplica a los métodos de instancia normales.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can explicitly check for <ph id="ph1">`Nothing`</ph> in the extension method.</source>
          <target state="translated">Puede comprobar explícitamente si <ph id="ph1">`Nothing`</ph> en el método de extensión.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Types That Can Be Extended</source>
          <target state="translated">Tipos que se pueden extender</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can define an extension method on most types that can be represented in a Visual Basic parameter list, including the following:</source>
          <target state="translated">Puede definir un método de extensión en la mayoría de los tipos que se puede representar en una lista de parámetros de Visual Basic, incluidas las siguientes:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Classes (reference types)</source>
          <target state="translated">Clases (tipos de referencia)</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Structures (value types)</source>
          <target state="translated">Estructuras (tipos de valor)</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Delegates</source>
          <target state="translated">Delegados</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>ByRef and ByVal arguments</source>
          <target state="translated">Argumentos ByRef y ByVal</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Generic method parameters</source>
          <target state="translated">Parámetros de método genérico</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Matrices</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Because the first parameter specifies the data type that the extension method extends, it is required and cannot be optional.</source>
          <target state="translated">Dado que el primer parámetro especifica el tipo de datos que el método de extensión extiende, es necesario y no puede ser opcional.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For that reason, <ph id="ph1">`Optional`</ph> parameters and <ph id="ph2">`ParamArray`</ph> parameters cannot be the first parameter in the parameter list.</source>
          <target state="translated">Por ese motivo, <ph id="ph1">`Optional`</ph> parámetros y <ph id="ph2">`ParamArray`</ph> parámetros no pueden ser el primer parámetro de la lista de parámetros.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Extension methods are not considered in late binding.</source>
          <target state="translated">Métodos de extensión no se consideran en el enlace más tarde.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In the following example, the statement <ph id="ph1">`anObject.PrintMe()`</ph> raises a &lt;xref:System.MissingMemberException&gt; exception, the same exception you would see if the second <ph id="ph2">`PrintMe`</ph> extension method definition were deleted.</source>
          <target state="translated">En el ejemplo siguiente, la instrucción <ph id="ph1">`anObject.PrintMe()`</ph> provoca un &lt;xref:System.MissingMemberException&gt;de excepciones, la misma excepción que vería si el segundo <ph id="ph2">`PrintMe`</ph> definición de método de extensión se eliminaron.&lt;/xref:System.MissingMemberException&gt;</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#9<ept id="p2">](./codesnippet/VisualBasic/extension-methods_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#9;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Best Practices</source>
          <target state="translated">Procedimientos recomendados</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Extension methods provide a convenient and powerful way to extend an existing type.</source>
          <target state="translated">Métodos de extensión proporcionan una manera conveniente y eficaz de extender un tipo existente.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>However, to use them successfully, there are some points to consider.</source>
          <target state="translated">Sin embargo, para usarlas correctamente, hay algunos puntos a tener en cuenta.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>These considerations apply mainly to authors of class libraries, but they might affect any application that uses extension methods.</source>
          <target state="translated">Estas consideraciones se aplican principalmente a los autores de bibliotecas de clases, pero podrían afectar a cualquier aplicación que use métodos de extensión.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Most generally, extension methods that you add to types that you do not own are more vulnerable than extension methods added to types that you control.</source>
          <target state="translated">Más en general, los métodos de extensión que agrega a los tipos que no es propietario son más vulnerables que agrega a los tipos que controlan los métodos de extensión.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A number of things can occur in classes you do not own that can interfere with your extension methods.</source>
          <target state="translated">Pueden ocurrir varias cosas en clases que no es propietario que pueden interferir con sus métodos de extensión.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>If any accessible instance member exists that has a signature that is compatible with the arguments in the calling statement, with no narrowing conversions required from argument to parameter, the instance method will be used in preference to any extension method.</source>
          <target state="translated">Si existe cualquier miembro de instancia accesible con una firma que es compatible con los argumentos de la instrucción de llamada con ningún conversiones de restricción necesarias del argumento al parámetro, se utilizará el método de instancia con preferencia a cualquier método de extensión.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Therefore, if an appropriate instance method is added to a class at some point, an existing extension member that you rely on may become inaccessible.</source>
          <target state="translated">Por lo tanto, si un método de instancia adecuado se agrega a una clase en algún momento, un miembro de extensión existente que se basan en puede quedar inaccesible.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The author of an extension method cannot prevent other programmers from writing conflicting extension methods that may have precedence over the original extension.</source>
          <target state="translated">El autor de un método de extensión no puede impedir que otros programadores escribir métodos de extensión en conflicto que pueden tener prioridad sobre la extensión original.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can improve robustness by putting extension methods in their own namespace.</source>
          <target state="translated">Puede mejorar la solidez colocando los métodos de extensión en su propio espacio de nombres.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Consumers of your library can then include a namespace or exclude it, or select among namespaces, separately from the rest of the library.</source>
          <target state="translated">Los consumidores de la biblioteca pueden incluir un espacio de nombres o excluirla o seleccionar uno de los espacios de nombres, por separado del resto de la biblioteca.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>It may be safer to extend interfaces than it is to extend classes, especially if you do not own the interface or class.</source>
          <target state="translated">Puede ser más seguro extender interfaces que es extender clases, sobre todo si no posee la interfaz o clase.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A change in an interface affects every class that implements it.</source>
          <target state="translated">Un cambio en una interfaz afecta a cada clase que lo implementa.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Therefore, the author may be less likely to add or change methods in an interface.</source>
          <target state="translated">Por lo tanto, el autor puede ser menos probable agregar o cambiar los métodos de una interfaz.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>However, if a class implements two interfaces that have extension methods with the same signature, neither extension method is visible.</source>
          <target state="translated">Sin embargo, si una clase implementa dos interfaces que tienen métodos de extensión con la misma firma, ningún método de extensión está visible.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Extend the most specific type you can.</source>
          <target state="translated">Extender el tipo más específico que es posible.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In a hierarchy of types, if you select a type from which many other types are derived, there are layers of possibilities for the introduction of instance methods or other extension methods that might interfere with yours.</source>
          <target state="translated">En una jerarquía de tipos, si selecciona un tipo del que se derivan muchos otros tipos, hay niveles de posibilidades para la introducción de métodos de instancia u otros métodos de extensión que podrían interferir con el suyo.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Extension Methods, Instance Methods, and Properties</source>
          <target state="translated">Métodos de extensión, métodos de instancia y propiedades</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>When an in-scope instance method has a signature that is compatible with the arguments of a calling statement, the instance method is chosen in preference to any extension method.</source>
          <target state="translated">Cuando un método de instancia en el ámbito tiene una firma que es compatible con los argumentos de una instrucción de llamada, se elige el método de instancia con preferencia a cualquier método de extensión.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The instance method has precedence even if the extension method is a better match.</source>
          <target state="translated">El método de instancia tiene prioridad incluso si el método de extensión es una coincidencia mejor.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`ExampleClass`</ph> contains an instance method named <ph id="ph2">`ExampleMethod`</ph> that has one parameter of type <ph id="ph3">`Integer`</ph>.</source>
          <target state="translated">En el ejemplo siguiente, <ph id="ph1">`ExampleClass`</ph> contiene un método de instancia denominado <ph id="ph2">`ExampleMethod`</ph> que tiene un parámetro de tipo <ph id="ph3">`Integer`</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Extension method <ph id="ph1">`ExampleMethod`</ph> extends <ph id="ph2">`ExampleClass`</ph>, and has one parameter of type <ph id="ph3">`Long`</ph>.</source>
          <target state="translated">Método de extensión <ph id="ph1">`ExampleMethod`</ph> extiende <ph id="ph2">`ExampleClass`</ph>, y tiene un parámetro de tipo <ph id="ph3">`Long`</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#4<ept id="p2">](./codesnippet/VisualBasic/extension-methods_5.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods Nº&amp;4;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_5.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The first call to <ph id="ph1">`ExampleMethod`</ph> in the following code calls the extension method, because <ph id="ph2">`arg1`</ph> is <ph id="ph3">`Long`</ph> and is compatible only with the <ph id="ph4">`Long`</ph> parameter in the extension method.</source>
          <target state="translated">La primera llamada a <ph id="ph1">`ExampleMethod`</ph> en el código siguiente llama al método de extensión, porque <ph id="ph2">`arg1`</ph> es <ph id="ph3">`Long`</ph> y sólo es compatible con la <ph id="ph4">`Long`</ph> parámetro en el método de extensión.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The second call to <ph id="ph1">`ExampleMethod`</ph> has an <ph id="ph2">`Integer`</ph> argument, <ph id="ph3">`arg2`</ph>, and it calls the instance method.</source>
          <target state="translated">La segunda llamada a <ph id="ph1">`ExampleMethod`</ph> tiene un <ph id="ph2">`Integer`</ph> argumento, <ph id="ph3">`arg2`</ph>, y llama al método de instancia.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#5<ept id="p2">](./codesnippet/VisualBasic/extension-methods_6.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#5;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_6.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Now reverse the data types of the parameters in the two methods:</source>
          <target state="translated">Ahora invierta los tipos de datos de los parámetros de los dos métodos:</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#6<ept id="p2">](./codesnippet/VisualBasic/extension-methods_7.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods Nº&amp;6;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_7.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>This time the code in <ph id="ph1">`Main`</ph> calls the instance method both times.</source>
          <target state="translated">Esta vez el código en <ph id="ph1">`Main`</ph> llama al método dos veces.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This is because both <ph id="ph1">`arg1`</ph> and <ph id="ph2">`arg2`</ph> have a widening conversion to <ph id="ph3">`Long`</ph>, and the instance method takes precedence over the extension method in both cases.</source>
          <target state="translated">Esto es porque ambos <ph id="ph1">`arg1`</ph> y <ph id="ph2">`arg2`</ph> tiene una conversión de ampliación a <ph id="ph3">`Long`</ph>, y el método de instancia tiene prioridad sobre el método de extensión en ambos casos.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#7<ept id="p2">](./codesnippet/VisualBasic/extension-methods_8.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#7;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_8.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Therefore, an extension method cannot replace an existing instance method.</source>
          <target state="translated">Por lo tanto, un método de extensión no puede reemplazar un método de instancia existente.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>However, when an extension method has the same name as an instance method but the signatures do not conflict, both methods can be accessed.</source>
          <target state="translated">Sin embargo, cuando un método de extensión tiene el mismo nombre que un método de instancia pero las firmas no entran en conflicto, pueden tener acceso ambos métodos.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>For example, if class <ph id="ph1">`ExampleClass`</ph> contains a method named <ph id="ph2">`ExampleMethod`</ph> that takes no arguments, extension methods with the same name but different signatures are permitted, as shown in the following code.</source>
          <target state="translated">Por ejemplo, si clase <ph id="ph1">`ExampleClass`</ph> contiene un método denominado <ph id="ph2">`ExampleMethod`</ph> que toma ningún argumento, los métodos de extensión con el mismo nombre pero firmas diferentes están permitidas, como se muestra en el código siguiente.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#8<ept id="p2">](./codesnippet/VisualBasic/extension-methods_9.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods Nº&amp;8;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_9.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The output from this code is as follows:</source>
          <target state="translated">El resultado de este código es como sigue:</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The situation is simpler with properties: if an extension method has the same name as a property of the class it extends, the extension method is not visible and cannot be accessed.</source>
          <target state="translated">La situación es más fácil con propiedades: si un método de extensión tiene el mismo nombre que una propiedad de la clase que extiende, el método de extensión no está visible y no se tiene acceso.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Extension Method Precedence</source>
          <target state="translated">Prioridad del método de extensión</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>When two extension methods that have identical signatures are in scope and accessible, the one with higher precedence will be invoked.</source>
          <target state="translated">Cuando dos métodos de extensión que tienen firmas idénticas están en el ámbito y son accesibles, se invocará el uno con prioridad más alta.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>An extension method's precedence is based on the mechanism used to bring the method into scope.</source>
          <target state="translated">Prioridad de un método de extensión se basa en el mecanismo utilizado para poner el método en el ámbito.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The following list shows the precedence hierarchy, from highest to lowest.</source>
          <target state="translated">La lista siguiente muestra la jerarquía de prioridad, de mayor a menor.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside the current module.</source>
          <target state="translated">Métodos de extensión definidos dentro del módulo actual.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside data types in the current namespace or any one of its parents, with child namespaces having higher precedence than parent namespaces.</source>
          <target state="translated">Métodos de extensión dentro de datos de tipos definen en el espacio de nombres actual o cualquiera de sus elementos primarios, con espacios de nombres secundarios tener mayor prioridad que los espacios de nombres primario.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside any type imports in the current file.</source>
          <target state="translated">Métodos de extensión definidos dentro de cualquier tipo de importaciones en el archivo actual.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside any namespace imports in the current file.</source>
          <target state="translated">Métodos de extensión definidos dentro de cualquier importación de espacio de nombres en el archivo actual.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside any project-level type imports.</source>
          <target state="translated">Métodos de extensión definidos dentro de cualquier tipo de nivel de proyecto de importación.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside any project-level namespace imports.</source>
          <target state="translated">Métodos de extensión definidos dentro de cualquier importación de espacio de nombres de nivel de proyecto.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If precedence does not resolve the ambiguity, you can use the fully qualified name to specify the method that you are calling.</source>
          <target state="translated">Si la prioridad no resuelve la ambigüedad, puede utilizar el nombre completo para especificar el método al que se llama.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Print`</ph> method in the earlier example is defined in a module named <ph id="ph2">`StringExtensions`</ph>, the fully qualified name is <ph id="ph3">`StringExtensions.Print(example)`</ph> instead of <ph id="ph4">`example.Print()`</ph>.</source>
          <target state="translated">Si el <ph id="ph1">`Print`</ph> método en el ejemplo anterior se define en un módulo denominado <ph id="ph2">`StringExtensions`</ph>, el nombre completo es <ph id="ph3">`StringExtensions.Print(example)`</ph> en lugar de <ph id="ph4">`example.Print()`</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vea también</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Runtime.CompilerServices&gt;</source>
          <target state="translated">&lt;xref:System.Runtime.CompilerServices&gt;&lt;/xref:System.Runtime.CompilerServices&gt;</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Runtime.CompilerServices.ExtensionAttribute&gt;</source>
          <target state="translated">&lt;xref:System.Runtime.CompilerServices.ExtensionAttribute&gt;&lt;/xref:System.Runtime.CompilerServices.ExtensionAttribute&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Extension Methods<ept id="p1">](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Métodos de extensión<ept id="p1">](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Module Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/module-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Module (instrucción)<ept id="p1">](../../../../visual-basic/language-reference/statements/module-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Procedure Parameters and Arguments<ept id="p1">](./procedure-parameters-and-arguments.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Argumentos y parámetros de procedimiento<ept id="p1">](./procedure-parameters-and-arguments.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Optional Parameters<ept id="p1">](./optional-parameters.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Parámetros opcionales<ept id="p1">](./optional-parameters.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Parameter Arrays<ept id="p1">](./parameter-arrays.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Matrices de parámetros<ept id="p1">](./parameter-arrays.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Attributes overview<ept id="p1">](../../../../visual-basic/programming-guide/concepts/attributes/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Información general de atributos<ept id="p1">](../../../../visual-basic/programming-guide/concepts/attributes/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Scope in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Ámbito en Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>