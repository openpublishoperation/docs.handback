<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">52fb60b95b869a79900f84c2a1a7a6151bb5b58f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\programming-with-nodes.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8130e1cf9590c7980123209f85b300f267b7e59b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">25f662c4ac837ff60c67e236762eba69a9dc8aa1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Programming with Nodes (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Programar con nodos (Visual Basic) | Documentos de Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Programming with Nodes (Visual Basic)</source>
          <target state="translated">Programar con nodos (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> developers who need to write programs such as an XML editor, a transform system, or a report writer often need to write programs that work at a finer level of granularity than elements and attributes.</source>
          <target state="translated">Los desarrolladores de <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> que deben escribir programar como un editor de XML, un sistema de transformación o un sistema de escritura de informes a menudo deben escribir programas que funcionan en un nivel de granularidad más fino que los elementos y los atributos.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>They often need to work at the node level, manipulating text nodes, processing instructions, and comments.</source>
          <target state="translated">A menudo deben trabajar en el nivel del nodo, manipulando nodos de texto, procesando instrucciones y comentarios.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic provides some details about programming at the node level.</source>
          <target state="translated">En este tema se proporcionan algunos detalles acerca de la programación en el nivel del nodo.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Node Details</source>
          <target state="translated">Detalles del nodo</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>There are a number of details of programming that a programmer working at the node level should know.</source>
          <target state="translated">Existen varios detalles de programación que un programador que trabaja en el nivel de nodo debe conocer.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Parent Property of Children Nodes of XDocument is Set to Null</source>
          <target state="translated">La propiedad primaria de los nodos secundarios de XDocument está establecida en NULL</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.Linq.XObject.Parent%2A&gt; property contains the parent &lt;xref:System.Xml.Linq.XElement&gt;, not the parent node.</source>
          <target state="translated">El &lt;xref:System.Xml.Linq.XObject.Parent%2A&gt;propiedad contiene el elemento primario &lt;xref:System.Xml.Linq.XElement&gt;, no el nodo primario.&lt;/xref:System.Xml.Linq.XElement&gt; &lt;/xref:System.Xml.Linq.XObject.Parent%2A&gt;</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Child nodes of &lt;xref:System.Xml.Linq.XDocument&gt; have no parent &lt;xref:System.Xml.Linq.XElement&gt;.</source>
          <target state="translated">Nodos secundarios de &lt;xref:System.Xml.Linq.XDocument&gt;tener ningún elemento primario &lt;xref:System.Xml.Linq.XElement&gt;.&lt;/xref:System.Xml.Linq.XElement&gt; &lt;/xref:System.Xml.Linq.XDocument&gt;</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Their parent is the document, so the &lt;xref:System.Xml.Linq.XObject.Parent%2A&gt; property for those nodes is set to null.</source>
          <target state="translated">Su elemento primario es el documento, por lo que la &lt;xref:System.Xml.Linq.XObject.Parent%2A&gt;propiedad para esos nodos se establece en null.&lt;/xref:System.Xml.Linq.XObject.Parent%2A&gt;</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this:</source>
          <target state="translated">En el siguiente ejemplo se muestra esto:</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Adjacent Text Nodes are Possible</source>
          <target state="translated">Los nodos de texto adyacentes son posibles</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In a number of XML programming models, adjacent text nodes are always merged.</source>
          <target state="translated">En varios modelos de programación XML, los nodos de texto adyacente siempre están combinados.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This is sometimes called normalization of text nodes.</source>
          <target state="translated">A veces se denomina normalización de los nodos de texto.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> does not normalize text nodes.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> no normaliza nodos de texto.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you add two text nodes to the same element, it will result in adjacent text nodes.</source>
          <target state="translated">Si agrega dos nodos de texto al mismo elemento, tendrá como resultado nodos de texto adyacentes.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>However, if you add content specified as a string rather than as an &lt;xref:System.Xml.Linq.XText&gt; node, <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> might merge the string with an adjacent text node.</source>
          <target state="translated">Sin embargo, si agrega contenido especificado como una cadena en lugar de como un &lt;xref:System.Xml.Linq.XText&gt;nodo, <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> puede combinar la cadena con un nodo de texto adyacente.&lt;/xref:System.Xml.Linq.XText&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this:</source>
          <target state="translated">En el siguiente ejemplo se muestra esto:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Empty Text Nodes are Possible</source>
          <target state="translated">Los nodos de texto adyacentes vacíos son posibles</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In some XML programming models, text nodes are guaranteed to not contain the empty string.</source>
          <target state="translated">En algunos modelos de programación XML, se garantiza que los nodos de texto no contienen la cadena vacía.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The reasoning is that such a text node has no impact on serialization of the XML.</source>
          <target state="translated">El razonamiento es que ese nodo de texto no tiene ninguna incidencia en la serialización de XML.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>However, for the same reason that adjacent text nodes are possible, if you remove the text from a text node by setting its value to the empty string, the text node itself will not be deleted.</source>
          <target state="translated">No obstante, por la misma razón que los nodos de texto adyacentes son posibles, si quita el texto de un nodo de texto estableciendo su valor en la cadena vacía, el nodo de texto en sí no se eliminará.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>An Empty Text Node Impacts Serialization</source>
          <target state="translated">Un nodo de texto vacío incide sobre la serialización</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If an element contains only a child text node that is empty, it is serialized with the long tag syntax: <ph id="ph1">`&lt;Child&gt;&lt;/Child&gt;`</ph>.</source>
          <target state="translated">Si un elemento contiene solamente un nodo de texto que está vacío, se serializa con la sintaxis de etiqueta larga: <ph id="ph1">`&lt;Child&gt;&lt;/Child&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If an element contains no child nodes whatsoever, it is serialized with the short tag syntax: <ph id="ph1">`&lt;Child /&gt;`</ph>.</source>
          <target state="translated">Si un elemento no contiene ningún nodo secundario, se serializa con la sintaxis de etiqueta corta: <ph id="ph1">`&lt;Child /&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Namespaces are Attributes in the LINQ to XML Tree</source>
          <target state="translated">Los espacios de nombres son atributos en el árbol LINQ to XML</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Even though namespace declarations have identical syntax to attributes, in some programming interfaces, such as XSLT and XPath, namespace declarations are not considered to be attributes.</source>
          <target state="translated">Aunque las declaraciones del espacio de nombres tienen una sintaxis idéntica a los atributos, en algunas interfaces de programación como XSLT y XPath, las declaraciones de espacios de nombres no se consideran atributos.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>However, in <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, namespaces are stored as &lt;xref:System.Xml.Linq.XAttribute&gt; objects in the XML tree.</source>
          <target state="translated">Sin embargo, en <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, espacios de nombres se almacenan como &lt;xref:System.Xml.Linq.XAttribute&gt;objetos en el árbol XML.&lt;/xref:System.Xml.Linq.XAttribute&gt;</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you iterate through the attributes for an element that contains a namespace declaration, you will see the namespace declaration as one of the items in the returned collection.</source>
          <target state="translated">Si recorre en iteración los atributos de un elemento que contiene una declaración de espacio de nombres, verá la declaración de espacio de nombres como uno de los elementos de la recopilación devuelta.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.Linq.XAttribute.IsNamespaceDeclaration%2A&gt; property indicates whether an attribute is a namespace declaration.</source>
          <target state="translated">El &lt;xref:System.Xml.Linq.XAttribute.IsNamespaceDeclaration%2A&gt;propiedad indica si un atributo es una declaración de espacio de nombres.&lt;/xref:System.Xml.Linq.XAttribute.IsNamespaceDeclaration%2A&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>XPath Axis Methods Do Not Return Child White Space of XDocument</source>
          <target state="translated">Los métodos del eje XPath no devuelven un espacio en blanco secundario de XDocument</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> allows for child text nodes of an &lt;xref:System.Xml.Linq.XDocument&gt;, as long as the text nodes contain only white space.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>permite nodos de texto secundarios de un &lt;xref:System.Xml.Linq.XDocument&gt;, siempre y cuando los nodos de texto contengan solamente espacios en blanco.&lt;/xref:System.Xml.Linq.XDocument&gt;</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>However, the XPath object model does not include white space as child nodes of a document, so when you iterate through the children of an &lt;xref:System.Xml.Linq.XDocument&gt; using the &lt;xref:System.Xml.Linq.XContainer.Nodes%2A&gt; axis, white space text nodes will be returned.</source>
          <target state="translated">Sin embargo, el modelo de objetos de XPath no incluye un espacio en blanco como nodos secundarios de un documento, así que cuando recorra en iteración los elementos secundarios de un &lt;xref:System.Xml.Linq.XDocument&gt;con el &lt;xref:System.Xml.Linq.XContainer.Nodes%2A&gt;eje, se devolverán los nodos de texto de espacio en blanco.&lt;/xref:System.Xml.Linq.XContainer.Nodes%2A&gt; &lt;/xref:System.Xml.Linq.XDocument&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>However, when you iterate through the children of an &lt;xref:System.Xml.Linq.XDocument&gt; using the XPath axis methods, white space text nodes will not be returned.</source>
          <target state="translated">Sin embargo, cuando recorra en iteración los elementos secundarios de un &lt;xref:System.Xml.Linq.XDocument&gt;usando los métodos de eje de XPath, no se devolverán los nodos de texto de espacio en blanco.&lt;/xref:System.Xml.Linq.XDocument&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>XDeclaration Objects are not Nodes</source>
          <target state="translated">Los objetos XDeclaration no son nodos</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When you iterate through the children nodes of an &lt;xref:System.Xml.Linq.XDocument&gt;, you will not see the XML declaration object.</source>
          <target state="translated">Cuando recorra en iteración los nodos secundarios de un &lt;xref:System.Xml.Linq.XDocument&gt;, no verá el objeto de declaración XML.&lt;/xref:System.Xml.Linq.XDocument&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>It is a property of the document, not a child node of it.</source>
          <target state="translated">Es una propiedad del documento, no un nodo secundario de él.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vea también</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Advanced LINQ to XML Programming (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Avanzada de LINQ to XML Programming (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>