<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cbab7da8c97ca202f8a4d0a1a65b8fa240cca32d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\covariance-contravariance\variance-in-delegates.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">adc4b7a8e4176173779d75c2feb6b4b977377a41</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5c0afe04633a0673fb5ad45f6775338e0e4e9a81</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Variance in Delegates (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Varianza en delegados (Visual Basic) | Documentos de Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Variance in Delegates (Visual Basic)</source>
          <target state="translated">Varianza en delegados (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET Framework 3.5 introduced variance support for matching method signatures with delegate types in all delegates in C# and Visual Basic.</source>
          <target state="translated">.NET framework 3.5 introdujo la compatibilidad con la varianza para hacer coincidir las firmas de método con tipos de delegado en todos los delegados en C# y Visual Basic.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This means that you can assign to delegates not only methods that have matching signatures, but also methods that return more derived types (covariance) or that accept parameters that have less derived types (contravariance) than that specified by the delegate type.</source>
          <target state="translated">Esto significa que puede asignar a los delegados no sólo los métodos con firmas coincidentes, sino también los métodos que devuelven más derivados de tipos (covarianza) o que aceptan parámetros que tienen tipos menos derivados (contravarianza) que el especificado por el tipo de delegado.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This includes both generic and non-generic delegates.</source>
          <target state="translated">Esto incluye a los delegados genéricos y no genéricos.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, consider the following code, which has two classes and two delegates: generic and non-generic.</source>
          <target state="translated">Por ejemplo, considere el siguiente código, que tiene dos clases y dos delegados: genéricos y no genéricos.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>When you create delegates of the <ph id="ph1">`SampleDelegate`</ph> or <ph id="ph2">`SampleDelegate(Of A, R)`</ph> types, you can assign any one of the following methods to those delegates.</source>
          <target state="translated">Al crear delegados de la <ph id="ph1">`SampleDelegate`</ph> o <ph id="ph2">`SampleDelegate(Of A, R)`</ph> tipos, puede asignar uno de los siguientes métodos a dichos delegados.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The following code example illustrates the implicit conversion between the method signature and the delegate type.</source>
          <target state="translated">En el ejemplo de código siguiente se ilustra la conversión implícita entre la firma del método y el tipo de delegado.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more examples, see <bpt id="p1">[</bpt>Using Variance in Delegates (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-in-delegates.md)</ept> and <bpt id="p2">[</bpt>Using Variance for Func and Action Generic Delegates (Visual Basic)<ept id="p2">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept>.</source>
          <target state="translated">Para obtener más ejemplos, vea <bpt id="p1">[</bpt>utilizar varianza en delegados (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-in-delegates.md)</ept> y <bpt id="p2">[</bpt>Using Variance for Func y Action Generic Delegates (Visual Basic)<ept id="p2">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Variance in Generic Type Parameters</source>
          <target state="translated">Varianza en parámetros de tipo genérico</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In .NET Framework 4 and later you can enable implicit conversion between delegates, so that generic delegates that have different types specified by generic type parameters can be assigned to each other, if the types are inherited from each other as required by variance.</source>
          <target state="translated">En .NET Framework 4 y versiones posteriores puede habilitar la conversión implícita entre los delegados, para que los delegados genéricos con parámetros de tipo genérico especifican tipos distintos pueden asignarse entre sí, si los tipos se hereden entre sí como requiere la varianza.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>To enable implicit conversion, you must explicitly declare generic parameters in a delegate as covariant or contravariant by using the <ph id="ph1">`in`</ph> or <ph id="ph2">`out`</ph> keyword.</source>
          <target state="translated">Para habilitar la conversión implícita, debe declarar explícitamente los parámetros genéricos de un delegado como covariante o contravariante utilizando la <ph id="ph1">`in`</ph> o <ph id="ph2">`out`</ph> (palabra clave).</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The following code example shows how you can create a delegate that has a covariant generic type parameter.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear a un delegado que tiene un parámetro de tipo genérico covariante.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If you use only variance support to match method signatures with delegate types and do not use the <ph id="ph1">`in`</ph> and <ph id="ph2">`out`</ph> keywords, you may find that sometimes you can instantiate delegates with identical lambda expressions or methods, but you cannot assign one delegate to another.</source>
          <target state="translated">Si utiliza sólo admiten la varianza para hacer coincidir las firmas de método con tipos de delegado y no use el <ph id="ph1">`in`</ph> y <ph id="ph2">`out`</ph> palabras clave, es posible que a veces se pueden crear instancias de delegados con métodos o expresiones lambda idénticos, pero no se puede asignar un delegado a otro.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In the following code example, <ph id="ph1">`SampleGenericDelegate(Of String)`</ph> can't be explicitly converted to <ph id="ph2">`SampleGenericDelegate(Of Object)`</ph>, although <ph id="ph3">`String`</ph> inherits <ph id="ph4">`Object`</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente, <ph id="ph1">`SampleGenericDelegate(Of String)`</ph> no se puede convertir explícitamente a <ph id="ph2">`SampleGenericDelegate(Of Object)`</ph>, aunque <ph id="ph3">`String`</ph> hereda <ph id="ph4">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can fix this problem by marking the generic parameter <ph id="ph1">`T`</ph> with the <ph id="ph2">`out`</ph> keyword.</source>
          <target state="translated">Puede solucionar este problema, marque el parámetro genérico <ph id="ph1">`T`</ph> con el <ph id="ph2">`out`</ph> (palabra clave).</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Generic Delegates That Have Variant Type Parameters in the .NET Framework</source>
          <target state="translated">Parámetros de tipo de los delegados genéricos que tengan variante en .NET Framework</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>.NET Framework 4 introduced variance support for generic type parameters in several existing generic delegates:</source>
          <target state="translated">.NET framework 4 introdujo la compatibilidad con la varianza para los parámetros de tipo genérico en varios delegados genéricos existentes:</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Action`</ph> delegates from the &lt;xref:System&gt; namespace, for example, &lt;xref:System.Action%601&gt; and &lt;xref:System.Action%602&gt;</source>
          <target state="translated"><ph id="ph1">`Action`</ph>delegados de la &lt;xref:System&gt;espacio de nombres, por ejemplo, &lt;xref:System.Action%601&gt;y &lt;xref:System.Action%602&gt;&lt;/xref:System.Action%602&gt; &lt;/xref:System.Action%601&gt; &lt;/xref:System&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Func`</ph> delegates from the &lt;xref:System&gt; namespace, for example, &lt;xref:System.Func%601&gt; and &lt;xref:System.Func%602&gt;</source>
          <target state="translated"><ph id="ph1">`Func`</ph>delegados de la &lt;xref:System&gt;espacio de nombres, por ejemplo, &lt;xref:System.Func%601&gt;y &lt;xref:System.Func%602&gt;&lt;/xref:System.Func%602&gt; &lt;/xref:System.Func%601&gt; &lt;/xref:System&gt;</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Predicate%601&gt; delegate</source>
          <target state="translated">El &lt;xref:System.Predicate%601&gt;delegado&lt;/xref:System.Predicate%601&gt;</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Comparison%601&gt; delegate</source>
          <target state="translated">El &lt;xref:System.Comparison%601&gt;delegado&lt;/xref:System.Comparison%601&gt;</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Converter%602&gt; delegate</source>
          <target state="translated">El &lt;xref:System.Converter%602&gt;delegado&lt;/xref:System.Converter%602&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information and examples, see <bpt id="p1">[</bpt>Using Variance for Func and Action Generic Delegates (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept>.</source>
          <target state="translated">Para obtener más información y ejemplos, vea <bpt id="p1">[</bpt>Using Variance for Func y Action Generic Delegates (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Declaring Variant Type Parameters in Generic Delegates</source>
          <target state="translated">Declarar parámetros de tipo variante en delegados genéricos</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If a generic delegate has covariant or contravariant generic type parameters, it can be referred to as a <bpt id="p1">*</bpt>variant generic delegate<ept id="p1">*</ept>.</source>
          <target state="translated">Si un delegado genérico tiene covariante o parámetros de tipo genérico contravariante, que puede hacer referencia como un <bpt id="p1">*</bpt>delegado genérico variante<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can declare a generic type parameter covariant in a generic delegate by using the <ph id="ph1">`out`</ph> keyword.</source>
          <target state="translated">Puede declarar un parámetro de tipo genérico covariante en un delegado genérico mediante la <ph id="ph1">`out`</ph> (palabra clave).</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The covariant type can be used only as a method return type and not as a type of method arguments.</source>
          <target state="translated">El tipo covariante puede usarse solo como un tipo de valor devuelto del método y no como un tipo de argumentos de método.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following code example shows how to declare a covariant generic delegate.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo declarar a un delegado genérico covariante.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>5<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>5<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>You can declare a generic type parameter contravariant in a generic delegate by using the <ph id="ph1">`in`</ph> keyword.</source>
          <target state="translated">Puede declarar una contravariante del parámetro de tipo genérico en un delegado genérico mediante la <ph id="ph1">`in`</ph> (palabra clave).</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The contravariant type can be used only as a type of method arguments and not as a method return type.</source>
          <target state="translated">El tipo contravariante puede usarse solo como un tipo de argumentos de método y no como un tipo de valor devuelto del método.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The following code example shows how to declare a contravariant generic delegate.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo declarar a un delegado genérico contravariante.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>6<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>6<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><ph id="ph1"> `ByRef`</ph> parameters in Visual Basic can't be marked as variant.</source>
          <target state="translated"><ph id="ph1"> `ByRef`</ph>parámetros de Visual Basic no se pueden marcar como variante.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>It is also possible to support both variance and covariance in the same delegate, but for different type parameters.</source>
          <target state="translated">También es posible admitir la varianza y la covarianza en el mismo delegado, pero para distintos parámetros de tipo.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This is shown in the following example.</source>
          <target state="translated">Esta implementación se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>7<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>7<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Instantiating and Invoking Variant Generic Delegates</source>
          <target state="translated">Crear instancias e invocar delegados genéricos variantes</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You can instantiate and invoke variant delegates just as you instantiate and invoke invariant delegates.</source>
          <target state="translated">Puede crear instancias e invocar a delegados variantes igual que crear instancias e invoca delegados invariables.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In the following example, the delegate is instantiated by a lambda expression.</source>
          <target state="translated">En el ejemplo siguiente, se crea una instancia del delegado mediante una expresión lambda.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>8<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>8<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Combining Variant Generic Delegates</source>
          <target state="translated">Combinación de delegados genéricos variantes</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You should not combine variant delegates.</source>
          <target state="translated">No debe combinar a delegados variantes.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Delegate.Combine%2A&gt; method does not support variant delegate conversion and expects delegates to be of exactly the same type.</source>
          <target state="translated">El &lt;xref:System.Delegate.Combine%2A&gt;método no admite la conversión de delegado variantes y espera que los delegados para ser del mismo tipo.&lt;/xref:System.Delegate.Combine%2A&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This can lead to a run-time exception when you combine delegates either by using the &lt;xref:System.Delegate.Combine%2A&gt; method (in C# and Visual Basic) or by using the <ph id="ph1">`+`</ph> operator (in C#), as shown in the following code example.</source>
          <target state="translated">Esto puede provocar una excepción en tiempo de ejecución al combinar delegados mediante la &lt;xref:System.Delegate.Combine%2A&gt;(método) (en C# y Visual Basic) o mediante el <ph id="ph1">`+`</ph> (operador) (en C#), tal como se muestra en el ejemplo de código siguiente.&lt;/xref:System.Delegate.Combine%2A&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>9<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>9<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Variance in Generic Type Parameters for Value and Reference Types</source>
          <target state="translated">Varianza en parámetros de tipo genérico para los tipos de referencia y valor</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Variance for generic type parameters is supported for reference types only.</source>
          <target state="translated">Varianza en parámetros de tipo genérico es compatible con sólo los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`DVariant(Of Int)`</ph>can't be implicitly converted to <ph id="ph2">`DVariant(Of Object)`</ph> or <ph id="ph3">`DVariant(Of Long)`</ph>, because integer is a value type.</source>
          <target state="translated">Por ejemplo, <ph id="ph1">`DVariant(Of Int)`</ph>no se puede convertir implícitamente a <ph id="ph2">`DVariant(Of Object)`</ph> o <ph id="ph3">`DVariant(Of Long)`</ph>, porque integer es un tipo de valor.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The following example demonstrates that variance in generic type parameters is not supported for value types.</source>
          <target state="translated">En el ejemplo siguiente se muestra que la varianza de tipo genérico con parámetros no se admite para tipos de valor.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Relaxed Delegate Conversion in Visual Basic</source>
          <target state="translated">Conversión de delegado flexible en Visual Basic</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Relaxed delegate conversion enables more flexibility in matching method signatures with delegate types.</source>
          <target state="translated">Conversión de delegado flexible permite más flexibilidad en la coincidencia de las firmas de método con tipos de delegado.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For example, it lets you omit parameter specifications and omit function return values when you assign a method to a delegate.</source>
          <target state="translated">Por ejemplo, permite omitir las especificaciones de parámetro y omite los valores devueltos de función al asignar un método a un delegado.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Relaxed Delegate Conversion<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>la conversión de delegado no estricta<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vea también</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generics<ept id="p1">](https://msdn.microsoft.com/library/ms172192)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Genéricos<ept id="p1">](https://msdn.microsoft.com/library/ms172192)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Using Variance for Func and Action Generic Delegates (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Usar la varianza para Func y Action Generic Delegates (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>