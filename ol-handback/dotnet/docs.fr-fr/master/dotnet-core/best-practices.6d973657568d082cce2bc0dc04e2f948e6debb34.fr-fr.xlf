<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cf9c83de791fa4990a991689a26d4bbdd84cfe7d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\best-practices.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">764579f52179b62804b5a8102eb3bc570a212e93</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f5f2f83420d224fc7138a8161f172550635ffde7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Best practices for regular expressions</source>
          <target state="translated">Bonnes pratiques pour les expressions régulières</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Best practices for regular expressions</source>
          <target state="translated">Bonnes pratiques pour les expressions régulières</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Best practices for regular expressions</source>
          <target state="translated">Bonnes pratiques pour les expressions régulières</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</source>
          <target state="translated">Le moteur d’expression régulière dans .NET est un outil puissant et complet. Il traite le texte en fonction de correspondances de modèle plutôt qu’en comparant et en faisant correspondre le texte littéral.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In most cases, it performs pattern matching rapidly and efficiently.</source>
          <target state="translated">Dans la plupart des cas, il exécute les critères spéciaux de façon rapide et efficace.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>However, in some cases, the regular expression engine can appear to be very slow.</source>
          <target state="translated">Toutefois, dans certains cas, le moteur des expressions régulières peut sembler très lent.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</source>
          <target state="translated">Dans des cas extrêmes, il semble même cesser de répondre. Il traite en effet peu d'entrées sur une période de plusieurs heures ou même de plusieurs jours.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</source>
          <target state="translated">Cette rubrique décrit quelques-unes des meilleures pratiques que les développeurs peuvent adopter afin de garantir que les expressions régulières atteignent des performances optimales.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It contains the following sections:</source>
          <target state="translated">Elle contient les sections suivantes :</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Consider the input source<ept id="p1">](#consider-the-input-source)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Prise en compte de la source d’entrée<ept id="p1">](#consider-the-input-source)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Handle object instantiation appropriately<ept id="p1">](#handle-object-instantiation-appropriately)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Gestion correcte de l’instanciation d’objet<ept id="p1">](#handle-object-instantiation-appropriately)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Take charge of backtracking<ept id="p1">](#take-charge-of-backtracking)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Prise en charge de la rétroaction<ept id="p1">](#take-charge-of-backtracking)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Use time-out values<ept id="p1">](#use-time-out-values)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Utilisation de valeurs de délai d’attente<ept id="p1">](#use-time-out-values)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Capture only when necessary<ept id="p1">](#capture-only-when-necessary)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Capture uniquement quand cela s’avère nécessaire<ept id="p1">](#capture-only-when-necessary)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Related topics<ept id="p1">](#related-topics)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Rubriques connexes<ept id="p1">](#related-topics)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Consider the input source</source>
          <target state="translated">Prise en compte de la source d’entrée</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In general, regular expressions can accept two types of input: constrained or unconstrained.</source>
          <target state="translated">En général, les expressions régulières peuvent accepter deux types d'entrée : avec contrainte ou sans contrainte.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Constrained input is text that originates from a known or reliable source and follows a predefined format.</source>
          <target state="translated">L'entrée avec contrainte est un texte provenant d'une source fiable ou connue, et qui suit un format prédéfini.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</source>
          <target state="translated">L'entrée sans contrainte est un texte provenant d'une source non fiable, telle qu'un utilisateur web. Elle ne suit pas forcément un format prédéfini ou attendu.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Regular expression patterns are typically written to match valid input.</source>
          <target state="translated">Les modèles d'expressions régulières sont généralement écrits pour correspondre à une entrée valide.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</source>
          <target state="translated">Autrement dit, les développeurs examinent le texte qu'ils souhaitent faire correspondre, puis ils écrivent un modèle d'expression régulière qui lui correspond.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</source>
          <target state="translated">Les développeurs déterminent ensuite si ce modèle doit être corrigé ou approfondi en le testant à l'aide de plusieurs éléments d'entrée valides.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</source>
          <target state="translated">Lorsque le modèle correspond à toutes les entrées valides supposées, il est déclaré prêt pour la production et peut être intégré à une application finale.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This makes a regular expression pattern suitable for matching constrained input.</source>
          <target state="translated">Le modèle d'expression régulière est ainsi adapté à la mise en correspondance d'une entrée avec contrainte.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>However, it does not make it suitable for matching unconstrained input.</source>
          <target state="translated">Toutefois, il n'est pas adapté à la mise en correspondance d'une entrée sans contrainte.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</source>
          <target state="translated">Pour faire correspondre une entrée sans contrainte, une expression régulière doit pouvoir gérer efficacement trois types de texte :</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>• Text that matches the regular expression pattern.</source>
          <target state="translated">• Texte correspondant au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>• Text that does not match the regular expression pattern.</source>
          <target state="translated">• Texte ne correspondant pas au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>• Text that nearly matches the regular expression pattern.</source>
          <target state="translated">• Texte correspondant presque au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The last text type is especially problematic for a regular expression that has been written to handle constrained input.</source>
          <target state="translated">Le dernier type de texte est problématique pour une expression régulière écrite pour gérer les entrées avec contrainte.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If that regular expression also relies on extensive <bpt id="p1">[</bpt>backtracking<ept id="p1">](backtracking.md)</ept>, the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</source>
          <target state="translated">Si cette expression régulière repose également sur une <bpt id="p1">[</bpt>rétroaction<ept id="p1">](backtracking.md)</ept> complète, le traitement d’un texte apparemment anodin par le moteur d’expression régulière risque d’être extrêmement long (dans certains cas, un grand nombre d’heures ou de jours).</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</source>
          <target state="translated">L'exemple suivant utilise une expression régulière sujette à des rétroactions excessives et susceptible de rejeter des adresses e-mail valides.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You should not use it in an email validation routine.</source>
          <target state="translated">Vous ne devez pas l’utiliser dans une routine de validation d’e-mails.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you would like a regular expression that validates email addresses, see <bpt id="p1">[</bpt>How to: Verify that strings are in valid email format<ept id="p1">](verify-format.md)</ept>.</source>
          <target state="translated">Si vous souhaitez une expression régulière qui valide des adresses e-mail, consultez <bpt id="p1">[</bpt>Guide pratique pour vérifier que des chaînes sont dans un format d’adresse e-mail valide<ept id="p1">](verify-format.md)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</source>
          <target state="translated">Prenons l'exemple d'une expression régulière très fréquemment utilisée, mais extrêmement problématique, pour la validation de l'alias d'une adresse e-mail.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*$`</ph> is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</source>
          <target state="translated">L'expression régulière <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*$`</ph> est écrite pour traiter ce qui est considéré comme une adresse e-mail valide. Cette dernière se compose d'un caractère alphanumérique suivi de zéro, ou de plusieurs caractères (caractères alphanumériques, points ou traits d'union).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The regular expression must end with an alphanumeric character.</source>
          <target state="translated">L'expression régulière doit se terminer par un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</source>
          <target state="translated">Toutefois, comme illustré dans l'exemple suivant, bien que cette expression régulière gère facilement une entrée valide, elle s'avère particulièrement inefficace lorsqu'il s'agit de traiter une entrée presque valide.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</source>
          <target state="translated">Comme le montre la sortie de l'exemple, le moteur des expressions régulières traite l'alias de messagerie valide dans un intervalle de temps à peu près identique, indépendamment de sa longueur.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</source>
          <target state="translated">En revanche, lorsque l'adresse e-mail presque valide comporte plus de cinq caractères, le temps de traitement est environ doublé pour chaque caractère supplémentaire de la chaîne.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</source>
          <target state="translated">Cela signifie qu'une chaîne de 28 caractères presque valide serait traitée en plus d'une heure et qu'une chaîne de 33 caractères presque valide serait traitée en un peu moins d'un jour.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</source>
          <target state="translated">Étant donné que cette expression régulière a été développée en prenant uniquement en considération le format de l'entrée à faire correspondre, elle ne tient pas compte des entrées qui ne correspondent pas au modèle.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</source>
          <target state="translated">Une entrée sans contrainte correspondant presque au modèle d'expression régulière risque ainsi de nuire considérablement aux performances.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>To solve this problem, you can do the following:</source>
          <target state="translated">Pour résoudre ce problème, vous pouvez effectuer les opérations suivantes :</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</source>
          <target state="translated">Lorsque vous développez un modèle, vous devez réfléchir à la manière dont la rétroaction peut affecter les performances du moteur des expressions régulières, en particulier si votre expression régulière est conçue pour traiter des entrées sans contrainte.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Take charge of backtracking<ept id="p1">](#take-charge-of-backtracking)</ept> section.</source>
          <target state="translated">Pour plus d’informations, consultez la section <bpt id="p1">[</bpt>Prise en charge de la rétroaction<ept id="p1">](#take-charge-of-backtracking)</ept>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</source>
          <target state="translated">Testez intégralement votre expression régulière à l'aide d'entrées non valides et presque valides, ainsi que d'entrées valides.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>To generate input for a particular regular expression randomly, you can use <bpt id="p1">[</bpt>Rex<ept id="p1">](http://research.microsoft.com/en-us/projects/rex/)</ept>, which is a regular expression exploration tool from Microsoft Research.</source>
          <target state="translated">Pour générer de manière aléatoire une entrée pour une expression régulière spécifique, vous pouvez utiliser <bpt id="p1">[</bpt>Rex<ept id="p1">](http://research.microsoft.com/en-us/projects/rex/)</ept>, l’outil d’exploration d’expressions régulières de Microsoft Research.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Handle object instantiation appropriately</source>
          <target state="translated">Gestion correcte de l’instanciation d’objet</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>At the heart of .NET’s regular expression object model is the <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class, which represents the regular expression engine.</source>
          <target state="translated">Au cœur du modèle objet d’expression régulière de .NET se trouve la classe <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>, qui représente le moteur d’expression régulière.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Often, the single greatest factor that affects regular expression performance is the way in which the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> engine is used.</source>
          <target state="translated">Souvent, la façon dont le moteur <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> est utilisé est le principal facteur qui exerce un impact sur les performances des expressions régulières.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</source>
          <target state="translated">La définition d’une expression régulière implique une association étroite entre le moteur des expressions régulières et un modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>That coupling process, whether it involves instantiating a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</source>
          <target state="translated">Ce processus d’association est forcément onéreux, qu’il implique l’instanciation d’un objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> en passant à son constructeur un modèle d’expression régulière ou l’appel d’une méthode statique en lui passant le modèle d’expression régulière avec la chaîne à analyser.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</source>
          <target state="translated">Vous pouvez associer le moteur des expressions régulières à un modèle d’expression régulière spécifique, puis utiliser le moteur pour faire correspondre du texte de plusieurs façons :</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can call a static pattern-matching method, such as <bpt id="p1">[</bpt>Regex.Match(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String))</ept>.</source>
          <target state="translated">Vous pouvez appeler une méthode statique de critères spéciaux, comme <bpt id="p1">[</bpt>Regex.Match(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String))</ept>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This does not require instantiation of a regular expression object.</source>
          <target state="translated">L'instanciation d'un objet d'expression régulière n'est pas nécessaire.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You can instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object and call an instance pattern-matching method of an interpreted regular expression.</source>
          <target state="translated">Vous pouvez instancier un objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> et appeler une méthode d’instance de critères spéciaux d’une expression régulière interprétée.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This is the default method for binding the regular expression engine to a regular expression pattern.</source>
          <target state="translated">Il s’agit de la méthode par défaut pour lier le moteur des expressions régulières à un modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It results when a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated without an options argument that includes the <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> flag.</source>
          <target state="translated">Elle s’ensuit quand un objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> est instancié sans argument options qui inclut l’indicateur <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object and call an instance pattern-matching method of a compiled regular expression.</source>
          <target state="translated">Vous pouvez instancier un objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> et appeler une méthode d’instance de critères spéciaux d’une expression régulière compilée.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Regular expression objects represent compiled patterns when a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated with an options argument that includes the <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> flag.</source>
          <target state="translated">Les objets d’expression régulière représentent des modèles compilés lorsqu’un objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> est instancié avec un argument options incluant l’indicateur <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</source>
          <target state="translated">La forme de l'appel de méthode (statique, interprétée, compilée) affecte les performances si une même expression régulière est utilisée à plusieurs reprises dans les appels de méthode, ou si une application entraîne l'utilisation intensive d'objets d'expression régulière.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Static regular expressions</source>
          <target state="translated">Expressions régulières statiques</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</source>
          <target state="translated">Les méthodes d'expression régulière statiques sont recommandées pour éviter d'instancier à plusieurs reprises un objet d'expression régulière avec la même expression régulière.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in instance method calls is cached internally by the regular expression engine.</source>
          <target state="translated">À la différence des modèles d’expressions régulières utilisés par les objets d’expression régulière, les codes d’opération ou le langage compilé MSIL (Microsoft intermediate langage) des modèles utilisés dans les appels de méthode d’instance sont mis en cache en interne par le moteur des expressions régulières.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>For example, you might call a method to validate user input.</source>
          <target state="translated">Par exemple, vous pouvez appeler une méthode pour valider l’entrée d’utilisateur.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In this example, a method named <ph id="ph1">`IsValidCurrency`</ph> checks whether the user has entered a currency symbol followed by at least one decimal digit.</source>
          <target state="translated">Dans cet exemple, une méthode nommée <ph id="ph1">`IsValidCurrency`</ph> vérifie si l’utilisateur a entré un symbole monétaire suivi d’au moins un chiffre décimal.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A very inefficient implementation of the <ph id="ph1">`IsValidCurrency`</ph> method is shown in the following example.</source>
          <target state="translated">L'exemple suivant illustre une implémentation très peu efficace de la méthode <ph id="ph1">`IsValidCurrency`</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Note that each method call reinstantiates a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object with the same pattern.</source>
          <target state="translated">Notez que chaque appel de méthode réinstancie un objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> avec le même modèle.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</source>
          <target state="translated">Cela signifie ainsi que le modèle d’expression régulière doit être recompilé chaque fois que la méthode est appelée.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>You should replace this inefficient code with a call to the static <bpt id="p1">[</bpt>Regex.IsMatch(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String))</ept> method.</source>
          <target state="translated">Vous devez remplacer ce code peu efficace par un appel à la méthode <bpt id="p1">[</bpt>Regex.IsMatch(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String))</ept> statique.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This eliminates the need to instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</source>
          <target state="translated">De cette manière, un objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> n’a pas besoin d’être instancié chaque fois que vous souhaitez appeler une méthode de critères spéciaux. En outre, le moteur d’expression régulière est alors en mesure de récupérer une version compilée de l’expression régulière depuis son cache.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>By default, the last 15 most recently used static regular expression patterns are cached.</source>
          <target state="translated">Par défaut, les 15 derniers modèles d’expressions régulières statiques utilisés récemment sont mis en cache.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <bpt id="p1">[</bpt>Regex.CacheSize<ept id="p1">](xref:System.Text.RegularExpressions.Regex.CacheSize)</ept> property.</source>
          <target state="translated">Pour les applications qui requièrent un plus grand nombre d’expressions régulières statiques mises en cache, la taille du cache peut être ajustée en définissant la propriété <bpt id="p1">[</bpt>Regex.CacheSize<ept id="p1">](xref:System.Text.RegularExpressions.Regex.CacheSize)</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\p{Sc}+\s*\d+`</ph> that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</source>
          <target state="translated">L'expression régulière <ph id="ph1">`\p{Sc}+\s*\d+`</ph> utilisée dans cet exemple vérifie que la chaîne d'entrée se compose d'un symbole monétaire et d'au moins un chiffre décimal.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The pattern is defined as shown in the following table.</source>
          <target state="translated">Le modèle est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Match one or more characters in the Unicode Symbol, Currency category.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères dans la catégorie Unicode symbole, devise.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">Correspond à zéro, un ou plusieurs espaces blancs.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Interpreted vs. compiled regular expressions</source>
          <target state="translated">Expressions régulières interprétées ou compilées</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Regular expression patterns that are not bound to the regular expression engine through the specification of the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option are interpreted.</source>
          <target state="translated">Les modèles d’expression régulière qui ne sont pas associés au moteur d’expression régulière par la spécification de l’option <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> sont interprétés.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</source>
          <target state="translated">Lorsqu'un objet d'expression régulière est instancié, le moteur des expressions régulières convertit l'expression régulière en un ensemble de codes d'opération.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</source>
          <target state="translated">Lorsqu'une méthode d'instance est appelée, les codes d'opération sont convertis en langage MSIL et exécutés par le compilateur JIT.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</source>
          <target state="translated">De même, lorsqu'une méthode d'expression régulière statique est appelée et que l'expression régulière ne peut pas être récupérée dans le cache, le moteur des expressions régulières convertit l'expression régulière en un ensemble de codes d'opération et les stocke dans le cache.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>It then converts these operation codes to MSIL so that the JIT compiler can execute them.</source>
          <target state="translated">Il convertit ensuite ces codes d'opération en langage MSIL afin que le compilateur JIT puisse les exécuter.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Interpreted regular expressions reduce startup time at the cost of slower execution time.</source>
          <target state="translated">Les expressions régulières interprétées réduisent le temps de démarrage, mais ralentissent le temps d'exécution.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</source>
          <target state="translated">Pour cette raison, il est préférable de les utiliser lorsque l'expression régulière est utilisée dans un nombre d'appels de méthode restreint, ou lorsque le nombre exact d'appels de méthodes d'expression régulière est inconnu, mais qu'il est supposé être petit.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</source>
          <target state="translated">À mesure que le nombre d'appels de méthode augmente, le ralentissement de la vitesse d'exécution l'emporte sur l'amélioration des performances liée à la réduction du temps de démarrage.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Regular expression patterns that are bound to the regular expression engine through the specification of the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option are compiled.</source>
          <target state="translated">Les modèles d’expression régulière qui sont associés au moteur d’expression régulière par la spécification de l’option <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> sont compilés.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</source>
          <target state="translated">Cela signifie que, lorsqu'un objet d'expression régulière est instancié ou lorsqu'une méthode d'expression régulière statique est appelée et que l'expression régulière ne peut pas être récupérée dans le cache, le moteur des expressions régulières convertit l'expression régulière en un ensemble de codes d'opération intermédiaire, qu'il convertit ensuite en langage MSIL.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>When a method is called, the JIT compiler executes the MSIL.</source>
          <target state="translated">Lorsqu'une méthode est appelée, le compilateur JIT exécute le MSIL.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</source>
          <target state="translated">Contrairement aux expressions régulières interprétées, les expressions régulières compilées augmentent le temps de démarrage, mais elles exécutent plus rapidement les méthodes de critères spéciaux individuelles.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</source>
          <target state="translated">En conséquence, l'amélioration des performances due à la compilation de l'expression régulière augmente en fonction du nombre de méthodes d'expression régulières appelées.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</source>
          <target state="translated">Pour résumer, nous vous conseillons d'utiliser des expressions régulières interprétées lorsque vous appelez relativement peu souvent des méthodes d'expression régulières avec une expression régulière spécifique.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</source>
          <target state="translated">Nous vous conseillons d'utiliser des expressions régulières compilées lorsque vous appelez relativement souvent des méthodes d'expression régulière avec une expression régulière spécifique.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</source>
          <target state="translated">Il est difficile de déterminer le seuil exact auquel le ralentissement de la vitesse d'exécution des expressions normales interprétées l'emporte sur la réduction du temps de démarrage. Il est également difficile de déterminer le seuil auquel le ralentissement du temps de démarrage des expressions régulières compilées l'emporte sur l'amélioration des vitesses d'exécution.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</source>
          <target state="translated">Différents facteurs doivent être pris en compte, notamment la complexité des expressions régulières et les données spécifiques qui sont traitées.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <bpt id="p1">[</bpt>Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> class to compare their execution times.</source>
          <target state="translated">Pour déterminer si ce sont les expressions régulières interprétées ou compilées qui offrent les meilleures performances pour votre scénario d’application spécifique, vous pouvez utiliser la classe <bpt id="p1">[</bpt>Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> pour comparer les durées d’exécution.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's The Financier.</source>
          <target state="translated">L’exemple suivant compare les performances des expressions régulières compilées et interprétées lors de la lecture des dix premières phrases et lors de la lecture de toutes les phrases du texte de Theodore Dreiser, The Financier.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</source>
          <target state="translated">Comme l'indique la sortie de l'exemple, lorsque les méthodes de correspondance d'expression régulière sont appelées seulement dix fois, une expression régulière interprétée offre de meilleures performances qu'une expression régulière compilée.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</source>
          <target state="translated">Par contre, une expression régulière compilée offre de meilleures performances dans le cas d'un grand nombre d'appels (dans le cas présent, plus de 13 000).</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The regular expression pattern used in the example, <ph id="ph1">`\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`</ph>, is defined as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière utilisé dans l'exemple, <ph id="ph1">`\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`</ph>, est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>`(\r?\n)</source>
          <target state="translated">`(\r?\n)</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>,?\s)`</source>
          <target state="translated">,?\s)`</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</source>
          <target state="translated">Mettre en correspondance un ou aucun retour chariot suivi d'un caractère de saut de ligne, ou une ou aucune virgule, suivie d'un espace blanc.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>`(\w+((\r?\n)</source>
          <target state="translated">`(\w+((\r?\n)</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>,?\s))*`</source>
          <target state="translated">,?\s))*`</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</source>
          <target state="translated">Mettre en correspondance zéro, une ou plusieurs occurrences d'un ou plusieurs caractères alphabétiques qui sont suivis par un ou aucun retour chariot et un caractère de saut de ligne, ou par une ou aucune virgule, suivie d'un espace blanc.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Match a period, question mark, colon, semicolon, or exclamation point.</source>
          <target state="translated">Mettre en correspondance un point, un point d'interrogation, deux-points, un point-virgule ou un point d'exclamation.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Take charge of backtracking</source>
          <target state="translated">Prise en charge de la rétroaction</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</source>
          <target state="translated">Normalement, le moteur des expressions régulières utilise une progression linéaire pour se déplacer dans une chaîne d’entrée et pour la comparer à un modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>However, when indeterminate quantifiers such as <bpt id="p1">__</bpt><ph id="ph1">*</ph><ept id="p1">__</ept>, <bpt id="p2">**</bpt><ph id="ph2">+</ph><ept id="p2">**</ept>, and <bpt id="p3">**</bpt>?<ept id="p3">**</ept></source>
          <target state="translated">Toutefois, quand des quantificateurs indéterminés comme <bpt id="p1">__</bpt><ph id="ph1">*</ph><ept id="p1">__</ept>, <bpt id="p2">**</bpt><ph id="ph2">+</ph><ept id="p2">**</ept> et <bpt id="p3">**</bpt>?<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</source>
          <target state="translated">sont utilisés dans un modèle d’expression régulière, le moteur d’expression régulière peut abandonner une partie des correspondances partielles trouvées et revenir à un état précédemment enregistré pour trouver une correspondance pour le modèle entier.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>This process is known as backtracking.</source>
          <target state="translated">Ce processus est appelé « rétroaction ».</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For more information on backtracking, see <bpt id="p1">[</bpt>Details of regular expression behavior<ept id="p1">](regex-behavior.md)</ept> and <bpt id="p2">[</bpt>Backtracking in regular expressions<ept id="p2">](backtracking.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la rétroaction, consultez <bpt id="p1">[</bpt>Comportement détaillé des expressions régulières<ept id="p1">](regex-behavior.md)</ept> et <bpt id="p2">[</bpt>Rétroaction dans les expressions régulières<ept id="p2">](backtracking.md)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Support for backtracking gives regular expressions power and flexibility.</source>
          <target state="translated">La prise en charge de la rétroaction confère aux expressions régulières leur puissance et leur flexibilité.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</source>
          <target state="translated">La responsabilité de contrôle du fonctionnement du moteur des expressions régulières est alors confiée aux développeurs d'expressions régulières.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</source>
          <target state="translated">Souvent, les développeurs ne sont pas conscients de cette responsabilité. Leur utilisation incorrecte de la rétroaction ou leur dépendance vis-à-vis d'une rétroaction excessive a souvent un impact négatif très important sur les performances des expressions régulières.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>In a worst-case scenario, execution time can double for each additional character in the input string.</source>
          <target state="translated">Dans le pire des scénarios, la durée d'exécution peut doubler pour chaque caractère supplémentaire de la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</source>
          <target state="translated">En réalité, lorsque la rétroaction est utilisée de manière excessive, il est facile de créer l'équivalent de programmation d'une boucle sans fin si l'entrée correspond presque au modèle d'expression régulière. Le moteur des expressions régulières peut alors traiter une chaîne d'entrée relativement courte en plusieurs heures, voire en plusieurs jours.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</source>
          <target state="translated">Les performances des applications sont souvent altérées par l'utilisation de la rétroaction, même si ce processus n'est pas essentiel pour une correspondance.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b\p{Lu}\w*\b`</ph> matches all words that begin with an uppercase character, as the following table shows.</source>
          <target state="translated">Par exemple, l'expression régulière <ph id="ph1">`\b\p{Lu}\w*\b`</ph> établit une correspondance entre tous les mots qui commencent par une majuscule, comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Match an uppercase character.</source>
          <target state="translated">Mettre en correspondance une majuscule.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
          <target state="translated">Mettre en correspondance zéro, un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</source>
          <target state="translated">Étant donné qu'une limite de mot est différente d'un caractère alphabétique et qu'elle n'est pas un sous-ensemble de ce dernier, il est impossible que le moteur des expressions régulières franchisse une limite de mot lors de la mise en correspondance de caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</source>
          <target state="translated">Cela signifie que, pour cette expression régulière, une rétroaction ne peut jamais contribuer à la réussite globale d'une correspondance. Elle risque en revanche de diminuer les performances, étant donné que le moteur des expressions régulières doit impérativement enregistrer sont état pour chaque correspondance préliminaire d'un caractère alphabétique trouvée.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>If you determine that backtracking is not necessary, you can disable it by using the <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element.</source>
          <target state="translated">Si vous considérez que la rétroaction n’est pas nécessaire, vous pouvez la désactiver à l’aide de l’élément de langage <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The following example parses an input string by using two regular expressions.</source>
          <target state="translated">L'exemple suivant analyse une chaîne d'entrée à l'aide de deux expressions régulières.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The first, <ph id="ph1">`\b\p{Lu}\w*\b`</ph>, relies on backtracking.</source>
          <target state="translated">La première, <ph id="ph1">`\b\p{Lu}\w*\b`</ph>, utilise la rétroaction.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The second, <ph id="ph1">`\b\p{Lu}(?&gt;\w*)\b`</ph>, disables backtracking.</source>
          <target state="translated">La seconde, <ph id="ph1">`\b\p{Lu}(?&gt;\w*)\b`</ph>, désactive la rétroaction.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, they both produce the same result.</source>
          <target state="translated">Comme l'indique la sortie de l'exemple, les résultats obtenus sont identiques.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>In many cases, backtracking is essential for matching a regular expression pattern to input text.</source>
          <target state="translated">Dans de nombreux cas, la rétroaction est essentielle pour faire correspondre un modèle d’expression régulière à un texte d’entrée.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</source>
          <target state="translated">Toutefois, une rétroaction excessive risque d'altérer considérablement les performances et de donner l'impression qu'une application a cessé de répondre.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</source>
          <target state="translated">Cela se produit notamment lorsque les quantificateurs sont imbriqués et que le texte correspondant à la sous-expression externe est un sous-ensemble du texte correspondant à la sous-expression interne.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</source>
          <target state="translated">En plus d’éviter une rétroaction excessive, vous devez utiliser la fonctionnalité de délai d’attente pour garantir qu’une rétroaction excessive n’altère pas considérablement les performances des expressions régulières.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Use time-out values<ept id="p1">](#use-time-out-values)</ept> section.</source>
          <target state="translated">Pour plus d’informations, consultez la section <bpt id="p1">[</bpt>Utilisation de valeurs de délai d’attente<ept id="p1">](#use-time-out-values)</ept>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$`</ph> is intended to match a part number that consists of at least one alphanumeric character.</source>
          <target state="translated">Par exemple, le modèle d'expression régulière <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$`</ph> est conçu pour mettre en correspondance un numéro de référence composé d'au moins un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</source>
          <target state="translated">Tous les caractères supplémentaires peuvent être composés d'un caractère alphanumérique, d'un trait d'union, d'un trait de soulignement ou d'un point. Toutefois, le dernier caractère doit impérativement être alphanumérique.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>A dollar sign terminates the part number.</source>
          <target state="translated">Un signe dollar termine le numéro de référence.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression <ph id="ph1">`[0-9A-Z]`</ph> is a subset of the subexpression <ph id="ph2">`[-.\w]*`</ph>.</source>
          <target state="translated">Dans certains cas, ce modèle d'expression régulière peut présenter des performances médiocres, si les quantificateurs sont imbriqués et que la sous-expression <ph id="ph1">`[0-9A-Z]`</ph> est un sous-ensemble de la sous-expression <ph id="ph2">`[-.\w]*`</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</source>
          <target state="translated">Dans ces cas, vous pouvez optimiser les performances des expressions régulières en supprimant les quantificateurs imbriqués et en remplaçant la sous-expression externe par une assertion de préanalyse ou de postanalyse de largeur nulle.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</source>
          <target state="translated">Les assertions de préanalyse et de postanalyse sont des points d'ancrage. Elles ne déplacent pas le pointeur dans la chaîne d'entrée, mais elles vérifient en amont et en aval si une condition spécifiée est remplie.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>For example, the part number regular expression can be rewritten as <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])\$$`</ph>.</source>
          <target state="translated">Par exemple, l'expression régulière de numéro de référence peut être réécrite sous la forme <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])\$$`</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>This regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">Ce modèle d'expression régulière est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the input string.</source>
          <target state="translated">Commencer la correspondance au début de la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">Mettre en correspondance un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The part number must consist of at least this character.</source>
          <target state="translated">Le numéro de référence doit au minimum comporter ce caractère.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of any word character, hyphen, or period.</source>
          <target state="translated">Mettre en correspondance zéro, une ou plusieurs occurrences de tout caractère alphabétique, trait d'union ou point.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`</ph><ph id="ph2">\$</ph>]</source>
          <target state="translated"><ph id="ph1">`</ph><ph id="ph2">\$</ph>]</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Match a dollar sign.</source>
          <target state="translated">Mettre en correspondance un signe dollar.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</source>
          <target state="translated">Effectuer une préanalyse avancée du signe dollar de fin de s'assurer que le caractère précédent est un caractère alphanumérique.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`$`</ph> End the match at the end of the input string.</source>
          <target state="translated"><ph id="ph1">`$`</ph> Terminer la correspondance à la fin de la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The following example illustrates the use of this regular expression to match an array containing possible part numbers.</source>
          <target state="translated">L'exemple suivant illustre l'utilisation de cette expression régulière pour faire correspondre un tableau pouvant contenir des numéros de référence potentiels.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</source>
          <target state="translated">Le langage d’expression régulière dans .NET comprend les éléments de langage suivants, que vous pouvez utiliser pour éliminer les quantificateurs imbriqués.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Constructions de regroupement dans les expressions régulières<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Language element</source>
          <target state="translated">Élément du langage</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookahead.</source>
          <target state="translated">Préanalyse positive de largeur nulle.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Look ahead of the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> matches the input string.</source>
          <target state="translated">Effectuer une préanalyse de la position actuelle pour déterminer si <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> correspond à la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookahead.</source>
          <target state="translated">Préanalyse négative de largeur nulle.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Look ahead of the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> does not match the input string.</source>
          <target state="translated">Effectuer une préanalyse de la position actuelle pour déterminer si <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> ne correspond pas à la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind.</source>
          <target state="translated">Postanalyse positive de largeur nulle.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Look behind the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> matches the input string.</source>
          <target state="translated">Effectuer une postanalyse de la position actuelle pour déterminer si <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> correspond à la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind.</source>
          <target state="translated">Postanalyse négative de largeur nulle.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Look behind the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> does not match the input string.</source>
          <target state="translated">Effectuer une postanalyse de la position actuelle pour déterminer si <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> ne correspond pas à la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Use time-out values</source>
          <target state="translated">Utilisation de valeurs de délai d’attente</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</source>
          <target state="translated">Si une expression régulière traite une entrée qui correspond presque au modèle d'expression régulière, elle peut souvent se baser sur une rétroaction excessive, laquelle affecte considérablement ses performances.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</source>
          <target state="translated">En plus d'envisager soigneusement l'utilisation de la rétroaction et de tester l'expression régulière sur une entrée presque correspondante, vous devez toujours définir une valeur de délai d'attente pour garantir la minimalisation de l'impact d'une rétroaction excessive, le cas échéant.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out.</source>
          <target state="translated">Le délai d'attente d'expression régulière définit le laps de temps pendant lequel le moteur des expressions régulières recherchera une correspondance unique avant d'expirer.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The default time-out interval is <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept>, which means that the regular expression will not time out.</source>
          <target state="translated">L’intervalle de délai d’attente par défaut est <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept>, ce qui signifie que l’expression régulière n’expire pas.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You can override this value and define a time-out interval as follows:</source>
          <target state="translated">Vous pouvez remplacer cette valeur et définir un délai d'attente comme suit :</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>By providing a time-out value when you instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object by calling the <bpt id="p2">[</bpt>Regex(String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> constructor.</source>
          <target state="translated">En fournissant une valeur de délai d’attente quand vous instanciez un objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> en appelant le constructeur <bpt id="p2">[</bpt>Regex(String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>By calling a static pattern matching method, such as <bpt id="p1">[</bpt>Regex.Match(String, String, RegexOptions, TimeSpan)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> or <bpt id="p2">[</bpt>Regex.Replace(String, String, String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept>, that includes a <bpt id="p3">*</bpt>matchTimeout<ept id="p3">*</ept> parameter.</source>
          <target state="translated">En appelant une méthode de critères spéciaux statique (méthode), comme <bpt id="p1">[</bpt>Regex.Match(String, String, RegexOptions, TimeSpan)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> ou <bpt id="p2">[</bpt>Regex.Replace(String, String, String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept>, qui inclut un paramètre <bpt id="p3">*</bpt>matchTimeout<ept id="p3">*</ept>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> exception.</source>
          <target state="translated">Si vous avez défini un intervalle de délai d’attente et qu’aucune correspondance n’est trouvée à l’issue de cet intervalle, la méthode d’expression régulière lève une exception <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</source>
          <target state="translated">Dans votre gestionnaire d'exceptions, vous pouvez choisir de réessayer la mise en correspondance avec un délai d'attente plus long, d'annuler la recherche de correspondance et de supposer l'absence de correspondance, ou encore d'annuler la recherche de correspondance et de consigner les informations sur les exceptions à des fins d'analyse ultérieure.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`GetWordData`</ph> method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</source>
          <target state="translated">L'exemple ci-dessous définit une méthode <ph id="ph1">`GetWordData`</ph> qui instancie une expression régulière avec un délai d'attente de 350 millisecondes pour calculer le nombre de mots dans un document texte et le nombre moyen de caractères par mot.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is re-instantiated.</source>
          <target state="translated">Si le délai d’attente de l’opération de recherche de correspondance expire, il augmente de 350 millisecondes et l’objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> est réinstancié.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</source>
          <target state="translated">Si le nouveau délai d'attente dépasse 1 seconde, la méthode lève de nouveau l'exception pour l'appelant.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Capture only when necessary</source>
          <target state="translated">Capture uniquement quand cela s’avère nécessaire</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</source>
          <target state="translated">Les expressions régulières dans .NET prennent en charge plusieurs constructions de regroupement, ce qui vous permet de regrouper un modèle d’expression régulière dans une ou plusieurs sous-expressions.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The most commonly used grouping constructs in .NET regular expression language are <bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>, which defines a numbered capturing group, and <bpt id="p4">*</bpt><bpt id="p5">*</bpt>(?&lt;<ept id="p5">*</ept><bpt id="p6">_</bpt>name<ept id="p6">_</ept><ept id="p4">*</ept><bpt id="p7">*</bpt><ph id="ph1">&gt;</ph><ept id="p7">*</ept><bpt id="p8">*</bpt><bpt id="p9">_</bpt>subexpression<ept id="p9">_</ept><ept id="p8">*</ept><bpt id="p10">*</bpt>)<ept id="p10">*</ept>*, which defines a named capturing group.</source>
          <target state="translated">Les constructions de regroupement les plus fréquemment utilisées dans le langage d’expression régulière .NET sont <bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>, qui définit un groupe de capture numéroté et <bpt id="p4">*</bpt><bpt id="p5">*</bpt>(?&lt;<ept id="p5">*</ept><bpt id="p6">_</bpt>nom<ept id="p6">_</ept><ept id="p4">*</ept><bpt id="p7">*</bpt><ph id="ph1">&gt;</ph><ept id="p7">*</ept><bpt id="p8">*</bpt><bpt id="p9">_</bpt>sous-expression<ept id="p9">_</ept><ept id="p8">*</ept><bpt id="p10">*</bpt>)<ept id="p10">*</ept>*, qui définit un groupe de capture nommé.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</source>
          <target state="translated">Les constructions de regroupement sont essentielles pour créer des références arrières et pour définir une sous-expression à laquelle un quantificateur est appliqué.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>However, the use of these language elements has a cost.</source>
          <target state="translated">Toutefois, l'utilisation de ces éléments de langage n'est pas sans effet.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>They cause the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <bpt id="p3">[</bpt>CaptureCollection<ept id="p3">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object returned by the <bpt id="p4">[</bpt>Group.Captures<ept id="p4">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property of a particular capturing group with multiple <bpt id="p5">[</bpt>Capture<ept id="p5">](xref:System.Text.RegularExpressions.Capture)</ept> objects.</source>
          <target state="translated">Ils entraînent le remplissage de l’objet <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> renvoyé par la propriété <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> avec les captures nommées ou sans nom les plus récentes. Si une seule construction de regroupement a capturé plusieurs sous-chaînes dans la chaîne d’entrée, ils remplissent également l’objet <bpt id="p3">[</bpt>CaptureCollection<ept id="p3">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> renvoyé par la propriété <bpt id="p4">[</bpt>Group.Captures<ept id="p4">](xref:System.Text.RegularExpressions.Group.Captures)</ept> d’un groupe de capture particulier à l’aide de plusieurs objets <bpt id="p5">[</bpt>Capture<ept id="p5">](xref:System.Text.RegularExpressions.Capture)</ept>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</source>
          <target state="translated">Souvent, les constructions de regroupement sont utilisées dans une expression régulière uniquement pour que les quantificateurs puissent leur être appliqués. Les groupes capturés par ces sous-expressions ne sont alors pas utilisés par la suite.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b(\w+[;,]?\s?)+[.?!]`</ph> is designed to capture an entire sentence.</source>
          <target state="translated">Par exemple, l'expression régulière <ph id="ph1">`\b(\w+[;,]?\s?)+[.?!]`</ph> est conçue pour capturer une phrase entière.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The following table describes the language elements in this regular expression pattern and their effect on the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> object's <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> and <bpt id="p3">[</bpt>Group.Captures<ept id="p3">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collections.</source>
          <target state="translated">Le tableau suivant décrit les éléments de langage dans ce modèle d’expression régulière et leur effet sur les collections <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> et <bpt id="p3">[</bpt>Group.Captures<ept id="p3">](xref:System.Text.RegularExpressions.Group.Captures)</ept> de l’objet <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Match zero or one comma or semicolon.</source>
          <target state="translated">Mettre en correspondance zéro ou une virgule, ou zéro ou un point-virgule.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Mettre en correspondance zéro ou un espace blanc.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</source>
          <target state="translated">Mettre en correspondance une ou plusieurs occurrences d'un ou plusieurs caractères alphabétiques suivis d'une virgule ou d'un point-virgule facultatif suivi d'un espace blanc facultatif.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</source>
          <target state="translated">Cela définit le premier groupe de capture. Il est nécessaire pour que la combinaison de plusieurs caractères alphabétiques (autrement dit, un mot) suivis d'un signe de ponctuation facultatif soit répétée jusqu'à ce que le moteur des expressions régulières ait atteint la fin d'une phrase.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Match a period, question mark, or exclamation point.</source>
          <target state="translated">Mettre en correspondance un point, un point d'interrogation ou un point d'exclamation.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>As the following example shows, when a match is found, both the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> objects are populated with captures from the match.</source>
          <target state="translated">Comme l’indique l’exemple suivant, quand une correspondance est trouvée, les objets <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> et <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> sont tous les deux remplis avec les captures de la correspondance.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>In this case, the capturing group <ph id="ph1">`(\w+[;,]?\s?)`</ph> exists so that the <bpt id="p1">**</bpt><ph id="ph2">+</ph><ept id="p1">**</ept> quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</source>
          <target state="translated">Dans cet exemple, le groupe de capture <ph id="ph1">`(\w+[;,]?\s?)`</ph> existe pour que le quantificateur <bpt id="p1">**</bpt><ph id="ph2">+</ph><ept id="p1">**</ept> puisse lui être appliqué, ce qui permet au modèle d’expression régulière de correspondre à chaque mot d’une phrase.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Otherwise, it would match the last word in a sentence.</source>
          <target state="translated">Sinon, elle correspondrait au dernier mot d'une phrase.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</source>
          <target state="translated">Lorsque vous utilisez des sous-expressions uniquement pour y appliquer des quantificateurs et que le texte capturé ne vous intéresse pas, vous devez désactiver les captures de groupe.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element prevents the group to which it applies from capturing matched substrings.</source>
          <target state="translated">Par exemple, l’élément de langage <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> empêche le groupe auquel il s’applique de capturer les sous-chaînes correspondantes.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression pattern from the previous example is changed to <ph id="ph1">`\b(?:\w+[;,]?\s?)+[.?!]`</ph>.</source>
          <target state="translated">Dans l'exemple suivant, le modèle d'expression régulière de l'exemple précédent est remplacé par <ph id="ph1">`\b(?:\w+[;,]?\s?)+[.?!]`</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>As the output shows, it prevents the regular expression engine from populating the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collections.</source>
          <target state="translated">Comme le montre la sortie, il empêche le moteur d’expression régulière de remplir les collections <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> et <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>You can disable captures in one of the following ways:</source>
          <target state="translated">Vous pouvez désactiver les captures de l'une des façons suivantes :</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element.</source>
          <target state="translated">Utilisez l’élément de langage <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>This element prevents the capture of matched substrings in the group to which it applies.</source>
          <target state="translated">Cet élément empêche la capture des sous-chaînes correspondantes dans le groupe auquel il s'applique.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>It does not disable substring captures in any nested groups.</source>
          <target state="translated">Il ne désactive pas les captures de la sous-chaîne dans les groupes imbriqués.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">Utilisez l’option <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>It disables all unnamed or implicit captures in the regular expression pattern.</source>
          <target state="translated">Elle désactive toutes les captures implicites ou sans nom dans le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>When you use this option, only substrings that match named groups defined with the <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept><bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> language element can be captured.</source>
          <target state="translated">Lorsque vous utilisez cette option, seules les sous-chaînes qui correspondent à des groupes nommés définis avec l’élément de langage <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>nom<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept><bpt id="p4">_</bpt>sous-expression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> peuvent être capturées.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> flag can be passed to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or to the options parameter of a <bpt id="p3">[</bpt>Regex<ept id="p3">](xref:System.Text.RegularExpressions.Regex)</ept> static matching method.</source>
          <target state="translated">L’indicateur <bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> peut être passé au paramètre options d’un constructeur de classe <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> ou au paramètre options d’une méthode de mise en correspondance statique <bpt id="p3">[</bpt>Regex<ept id="p3">](xref:System.Text.RegularExpressions.Regex)</ept>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>n<ept id="p1">**</ept> option in the <bpt id="p2">**</bpt>(?imnsx)<ept id="p2">**</ept> language element.</source>
          <target state="translated">Utilisez l’option <bpt id="p1">**</bpt>n<ept id="p1">**</ept> dans l’élément de langage <bpt id="p2">**</bpt>(?imnsx)<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</source>
          <target state="translated">Cette option désactive toutes les captures implicites ou sans nom à partir du point où l’élément apparaît dans le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Captures are disabled either until the end of the pattern or until the <bpt id="p1">**</bpt>(-n)<ept id="p1">**</ept> option enables unnamed or implicit captures.</source>
          <target state="translated">Les captures sont désactivées jusqu’à la fin du modèle ou jusqu’à ce que l’option <bpt id="p1">**</bpt>(-n)<ept id="p1">**</ept> active les captures implicites ou sans nom.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Miscellaneous constructs in regular expressions<ept id="p1">](miscellaneous.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Constructions diverses dans les expressions régulières<ept id="p1">](miscellaneous.md)</ept>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>n<ept id="p1">**</ept> option in the <bpt id="p2">**</bpt>(?imnsx:<ept id="p2">**</ept><bpt id="p3">_</bpt>subexpression<ept id="p3">_</ept><bpt id="p4">**</bpt>)<ept id="p4">**</ept> language element.</source>
          <target state="translated">Utilisez l’option <bpt id="p1">**</bpt>n<ept id="p1">**</ept> dans l’élément de langage <bpt id="p2">**</bpt>(?imnsx:<ept id="p2">**</ept><bpt id="p3">_</bpt>sous-expression<ept id="p3">_</ept><bpt id="p4">**</bpt>)<ept id="p4">**</ept>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>This option disables all unnamed or implicit captures in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>.</source>
          <target state="translated">Cette option désactive toutes les captures implicites ou sans nom dans <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Captures by any unnamed or implicit nested capturing groups are disabled as well.</source>
          <target state="translated">Les captures effectuées par les groupes de capture imbriqués implicites ou sans nom sont également désactivées.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="translated">Rubriques connexes</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Titre</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Details of regular expression behavior<ept id="p1">](regex-behavior.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Comportement détaillé des expressions régulières<ept id="p1">](regex-behavior.md)</ept></target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Examines the implementation of the regular expression engine in .NET.</source>
          <target state="translated">Aborde l’implémentation du moteur d’expression régulière dans .NET.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</source>
          <target state="translated">Cette rubrique traite de la flexibilité des expressions régulières. Elle explique la responsabilité du développeur pour que le fonctionnement efficace et fiable du moteur des expressions régulières soit garanti.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking in regular expressions<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Retour sur trace dans les expressions régulières<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</source>
          <target state="translated">Aborde la rétroaction et la façon dont elle affecte les performances des expressions régulières, ainsi que les éléments de langage, qui offrent des alternatives à la rétroaction.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Langage des expressions régulières - Aide-mémoire<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</source>
          <target state="translated">Décrit les éléments du langage d’expression régulière dans .NET et propose des liens vers la documentation détaillée pour chaque élément de langage.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>