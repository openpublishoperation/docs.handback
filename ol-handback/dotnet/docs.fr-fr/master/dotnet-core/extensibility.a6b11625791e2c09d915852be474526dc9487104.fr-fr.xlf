<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b5c25fc" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">827b5567400fd8ed1f32e60ba593a3ae71a0d745</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tools\extensibility.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">79d72a8f09cdb994a27cb59521b5f4267ab44f11</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">65ce7cce456cec5da2e00d516127f33f84b7630d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model | Microsoft Docs</source>
          <target state="translated">Modèle d’extensibilité des outils CLI .NET Core | Microsoft Docs</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">Modèle d’extensibilité des outils CLI .NET Core</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>CLI, extensibility, custom commands, .NET Core</source>
          <target state="translated">CLI, extensibilité, commandes personnalisées, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">Modèle d’extensibilité des outils CLI .NET Core</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Vue d'ensemble</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This document will cover the main ways how to extend the CLI tools and explain the scenarios that drive each of them.</source>
          <target state="translated">Ce document explique les principales méthodes permettant d’étendre les outils CLI, et décrit les scénarios dans lesquels elles sont utilisées.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It will the outline how to consume the tools as well as provide short notes on how to build both types of tools.</source>
          <target state="translated">Ce document décrit comment utiliser les outils et explique brièvement comment créer ces deux types d’outils.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How to extend CLI tools</source>
          <target state="translated">Extension des outils CLI</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The CLI tools can be extended in three main ways:</source>
          <target state="translated">Vous pouvez étendre les outils CLI de trois façons :</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Via NuGet packages on a per-project basis</source>
          <target state="translated">Via les packages NuGet, par projet</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Via NuGet packages with custom targets</source>
          <target state="translated">Via les packages NuGet avec des cibles personnalisées</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Via the system's PATH</source>
          <target state="translated">Via le chemin (PATH) du système</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The three extensibility mechanisms outlined above are not exclusive; you can use all or just one or combine them.</source>
          <target state="translated">Les trois mécanismes d’extensibilité présentés ci-dessus ne sont pas exclusifs. Vous pouvez utiliser un seul, une partie ou la totalité d’entre eux.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Which one to pick depends largely on what is the goal you are trying to achieve with your extension.</source>
          <target state="translated">Le choix de la méthode dépend en grande partie de l’objectif de votre extension.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Per-project based extensibility</source>
          <target state="translated">Extensibilité par projet</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Per-project tools are <bpt id="p1">[</bpt>framework-dependented deployments<ept id="p1">](../deploying/index.md)</ept> that are distributed as NuGet packages.</source>
          <target state="translated">Les outils par projet sont des <bpt id="p1">[</bpt>déploiements dépendants du framework<ept id="p1">](../deploying/index.md)</ept> qui sont distribués dans les packages NuGet.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Tools are only available in the context of the project that references them and for which they are restored; invocation outside of the context of the project (for example, outside of the directory that contains the project) will fail as the command will not be able to be found.</source>
          <target state="translated">Les outils sont uniquement disponibles dans le contexte du projet qui les référence et pour lequel ils sont restaurés. Les appels en dehors du contexte du projet (par exemple, en dehors du répertoire qui contient le projet) échoueront, car la commande ne pourra pas être trouvée.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>These tools are perfect for build servers, since nothing outside of the project file is needed.</source>
          <target state="translated">Ces outils sont parfaits pour les serveurs de build, puisque rien en dehors du fichier projet n’est nécessaire.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The build process runs restore for the project it builds and tools will be available.</source>
          <target state="translated">Le processus de génération exécute la restauration pour le projet qu’il génère, et des outils seront disponibles.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Language projects, such as F#, are also in this category; after all, each project can only be written in one specific language.</source>
          <target state="translated">Les projets de langage, tels que F#, figurent également dans cette catégorie. Chaque projet ne peut être écrit que dans un langage.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Finally, this extensibility model provides support for creation of tools that need access to the built output of the project.</source>
          <target state="translated">Enfin, ce modèle d’extensibilité prend en charge la création d’outils qui ont besoin d’accéder à la sortie générée du projet.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For instance, various Razor view tools in <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC applications fall into this category.</source>
          <target state="translated">Par exemple, les outils d’affichage Razor des applications MVC <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> appartiennent à cette catégorie.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consuming per-project tools</source>
          <target state="translated">Utilisation des outils par projet</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Consuming these tools requires you to add a <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element for each tool you want to use to your project file.</source>
          <target state="translated">Vous devez ajouter à votre fichier projet un élément <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> pour chaque outil que vous souhaitez utiliser.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Inside the <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element, you reference the package in which the tool resides and you specify the version you need.</source>
          <target state="translated">À l’intérieur de l’élément <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph>, vous référencez le package dans lequel réside l’outil et vous spécifiez la version dont vous avez besoin.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>After running <ph id="ph1">`dotnet restore`</ph>, the tool and its dependencies are restored.</source>
          <target state="translated">Après l’exécution de <ph id="ph1">`dotnet restore`</ph>, l’outil et ses dépendances sont restaurés.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For tools that need to load the build output of the project for execution, there is usually another dependency which is listed under the regular dependencies in the project file.</source>
          <target state="translated">Pour les outils qui doivent charger la sortie de génération du projet pour l’exécution, il existe généralement une autre dépendance qui est répertoriée sous les dépendances régulières du fichier projet.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Since CLI uses MSBuild as its build engine, it is recommended that these parts of the tool be written as custom MSBuild targets and tasks since that way they can take part in the overall build process.</source>
          <target state="translated">Étant donné que l’interface CLI utilise MSBuild comme moteur de génération, nous vous recommandons d’écrire ces parties de l’outil sous forme de cibles et tâches MSBuild personnalisées pour qu’elles puissent prendre part à l’ensemble du processus de génération.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Also, they can get any and all data easily that is produced via the build, for example the location of the output files, the current configuration being built etc. All of this information becomes a set of MSBuild properties that can be read from any target.</source>
          <target state="translated">Elles peuvent aussi facilement récupérer tout ou partie des données produites par la génération, telles que l’emplacement des fichiers de sortie ou la configuration en cours de génération. Toutes ces informations deviennent un jeu de propriétés MSBuild qui peut être lu à partir de toutes les cibles.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>We will see how to add a custom target using NuGet later in this document.</source>
          <target state="translated">Nous verrons comment ajouter une cible personnalisée à l’aide de NuGet plus loin dans ce document.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Let's review an example of adding a simple tools-only tool to a simple project.</source>
          <target state="translated">Voyons un exemple d’ajout d’un outil simple de type « tools-only » à un projet simple.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Given an example command called <ph id="ph1">`dotnet-api-search`</ph> that allows you to search through the NuGet packages for the specified API, here is a console application's project file that uses that tool:</source>
          <target state="translated">Prenons un exemple de commande appelé <ph id="ph1">`dotnet-api-search`</ph> qui vous permette de parcourir les packages NuGet à la recherche de l’API spécifiée. Voici le fichier projet de l’application console qui utilise cet outil :</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element is structured in a similar way as the <ph id="ph2">`&lt;PackageReference&gt;`</ph> element.</source>
          <target state="translated">L’élément <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> est structuré de la même façon que l’élément <ph id="ph2">`&lt;PackageReference&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>It needs the package ID of the package containing the tool and its version at the very least.</source>
          <target state="translated">Il a besoin, au minimum, de l’ID de package du package qui contient l’outil et sa version.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Building tools</source>
          <target state="translated">Outils de création</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>As mentioned, tools are just portable console applications.</source>
          <target state="translated">Comme nous l’avons mentionné précédemment, les outils sont des applications console portables.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You would build one as you would build any console application.</source>
          <target state="translated">Ils peuvent être créés comme toute autre application console.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>After you build it, you would use <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> command to create a NuGet package (nupkg) that contains your code, information about its dependencies and so on.</source>
          <target state="translated">Une fois l’outil créé, utilisez la commande <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> pour créer un package NuGet (nupkg) devant contenir votre code, les informations sur ses dépendances, etc.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The package name can be whatever the author wants, but the application inside, the actual tool binary, has to conform to the convention of <ph id="ph1">`dotnet-&lt;command&gt;`</ph> in order for <ph id="ph2">`dotnet`</ph> to be able to invoke it.</source>
          <target state="translated">L’auteur est libre de nommer le package comme il l’entend. Toutefois, l’application qui s’y trouve, le fichier binaire de l’outil, doit respecter la convention de <ph id="ph1">`dotnet-&lt;command&gt;`</ph> afin de pouvoir être appelée par <ph id="ph2">`dotnet`</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In pre-RC3 versions of the .NET Core command-line tools, the <ph id="ph1">`dotnet pack`</ph> command had a bug that caused the <ph id="ph2">`runtime.config.json`</ph> to not be packed with the tool.</source>
          <target state="translated">Dans les versions antérieures à RC3 des outils en ligne de commande .NET Core, la commande <ph id="ph1">`dotnet pack`</ph> présentait un bogue qui empêchait la compression de <ph id="ph2">`runtime.config.json`</ph> avec l’outil.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Lacking that file results in errors at runtime.</source>
          <target state="translated">L’absence de ce fichier aboutit à des erreurs lors de l’exécution.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If you encounter this behavior, be sure to update to the latest tooling and try the <ph id="ph1">`dotnet pack`</ph> again.</source>
          <target state="translated">Si vous rencontrez ce comportement, veillez à utiliser les outils les plus récents et essayez <ph id="ph1">`dotnet pack`</ph> une nouvelle fois.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Since tools are portable applications, the user consuming the tool has to have the version of the .NET Core libraries that the tool was built against in order to run the tool.</source>
          <target state="translated">Étant donné que les outils sont des applications portables, l’utilisateur qui utilise un outil doit disposer de la version des bibliothèques .NET Core à l’aide desquelles l’outil a été développé, afin de pouvoir l’exécuter.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Any other dependency that the tool uses and that is not contained within the .NET Core libraries is restored and placed in the NuGet cache.</source>
          <target state="translated">Toute autre dépendance que l’outil utilise et qui ne figure pas dans les bibliothèques .NET Core est restaurée et placée dans le cache de NuGet.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The entire tool is, therefore, run using the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache.</source>
          <target state="translated">L’outil entier est, par conséquent, exécuté à l’aide des assemblys des bibliothèques .NET Core et du cache de NuGet.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>These kind of tools have a dependency graph that is completely separate from the dependency graph of the project that uses them.</source>
          <target state="translated">Ces types d’outils ont un graphique de dépendance qui est complètement distinct du graphique de dépendance du projet qui les utilise.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The restore process will first restore the project's dependencies, and will then restore each of the tools and their dependencies.</source>
          <target state="translated">Le processus de restauration restaure d’abord les dépendances du projet, puis restaure chacun des outils et leurs dépendances.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You can find richer examples and different combinations of this in the <bpt id="p1">[</bpt>.NET Core CLI repo<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.</source>
          <target state="translated">Vous trouverez des exemples plus complets dans le <bpt id="p1">[</bpt>dépôt sur les outils CLI .NET Core<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>You can also see the <bpt id="p1">[</bpt>implementation of tools used<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> in the same repo.</source>
          <target state="translated">Vous pouvez également voir l’<bpt id="p1">[</bpt>implémentation des outils utilisés<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> dans le même dépôt.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Custom targets</source>
          <target state="translated">Cibles personnalisées</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>NuGet has had the capability to package custom MSBuild target and props files for a while now and you can find the official documentation on this on the <bpt id="p1">[</bpt>NuGet documentation site<ept id="p1">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>.</source>
          <target state="translated">NuGet offre depuis un certain temps la possibilité d’empaqueter des fichiers de propriétés et de cibles MSBuild personnalisés, et la documentation officielle à ce sujet est disponible sur le <bpt id="p1">[</bpt>site de la documentation de NuGet<ept id="p1">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>With the move in the CLI to using MSBuild, the same mechanism of extensibility applies to .NET Core projects.</source>
          <target state="translated">Suite à l’adoption de MSBuild dans l’interface CLI, le même mécanisme d’extensibilité s’applique aux projets .NET Core.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You would use this type of extensiblity when you want to extend the build process or when you want to access any of the artifacts in the build process, such as generated files or inspect the configuration under which the build is invoked etc.</source>
          <target state="translated">Vous utilisez ce type d’extensibilité quand vous souhaitez étendre le processus de génération ou que vous souhaitez accéder à tous les artefacts dans le processus de génération, tels que les fichiers générés, ou inspecter la configuration sous laquelle la build est appelée, entre autres.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The sample target's project file is included below for reference.</source>
          <target state="translated">Le fichier projet de l’exemple de cible est inclus ci-dessous pour référence.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It shows how to use the new <ph id="ph1">`csproj`</ph> syntax for instructing <ph id="ph2">`dotnet pack`</ph> command what to package to place the targets files as well as assemblies into the <ph id="ph3">`build`</ph> folder inside the package.</source>
          <target state="translated">Il montre comment utiliser la nouvelle syntaxe <ph id="ph1">`csproj`</ph> pour indiquer à la commande <ph id="ph2">`dotnet pack`</ph> ce qu’elle doit empaqueter pour placer les fichiers des cibles et les assemblys dans le dossier <ph id="ph3">`build`</ph> du package.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Take note of the <ph id="ph1">`&lt;ItemGroup&gt;`</ph> below that has the <ph id="ph2">`Label`</ph> property set to "dotnet pack instructions".</source>
          <target state="translated">Vous pouvez remarquer ci-dessous la présence d’une balise <ph id="ph1">`&lt;ItemGroup&gt;`</ph> dont la propriété <ph id="ph2">`Label`</ph> est définie sur « dotnet pack instructions ».</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Consuming custom targets is done by providing a <ph id="ph1">`&lt;PackageReference&gt;`</ph> that points to the package and its version inside the project that is being extended.</source>
          <target state="translated">L’utilisation de cibles personnalisées s’effectue en fournissant un <ph id="ph1">`&lt;PackageReference&gt;`</ph> qui pointe vers le package et sa version dans le projet en cours d’extension.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Unlike the tools, the custom targets package does get included into the consuming project's dependency closure.</source>
          <target state="translated">Contrairement aux outils, le package des cibles personnalisées n’est pas inclus dans la fermeture de dépendance du projet de consommation.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Using the custom target depends solely on how you configure it.</source>
          <target state="translated">L’utilisation de la cible personnalisée dépend uniquement de la façon dont vous la configurez.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Since it is the usual MSBuild target, it can depend on a given target, run after another target and can also be manually invoked using the <ph id="ph1">`dotnet msbuild /t:&lt;target-name&gt;`</ph> command.</source>
          <target state="translated">Puisqu’il s’agit de la cible MSBuild habituelle, elle peut dépendre d’une cible donnée, exécutée après une autre cible, et peut également être appelée manuellement à l’aide de la commande <ph id="ph1">`dotnet msbuild /t:&lt;target-name&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>However, if you wish to provide a better user experience to your users, you can combine per-project tools and custom targets.</source>
          <target state="translated">Toutefois, si vous souhaitez procurer une meilleure expérience à vos utilisateurs, vous pouvez combiner des outils par projet et des cibles personnalisées.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In this scenario, the per-project tool would essentially just accept whatever needed parameters and would translate that into the required <ph id="ph1">`dotnet msbuild`</ph> invocation that would execute the target.</source>
          <target state="translated">Dans ce scénario, l’outil par projet se contenterait essentiellement d’accepter tous les paramètres nécessaires à partir desquels il générerait l’invocation <ph id="ph1">`dotnet msbuild`</ph> requise pour exécuter la cible.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You can see a sample of this kind of synergy on the <bpt id="p1">[</bpt>MVP Summit 2016 Hackathon samples<ept id="p1">](https://github.com/dotnet/MVPSummitHackathon2016)</ept> repo in the <bpt id="p2">[</bpt><ph id="ph1">`dotnet-packer`</ph><ept id="p2">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept> project.</source>
          <target state="translated">Vous pouvez voir un exemple de ce type de synergie sur le dépôt des <bpt id="p1">[</bpt>exemples du MVP Summit 2016 Hackathon<ept id="p1">](https://github.com/dotnet/MVPSummitHackathon2016)</ept> du projet <bpt id="p2">[</bpt><ph id="ph1">`dotnet-packer`</ph><ept id="p2">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility</source>
          <target state="translated">Extensibilité basée sur le chemin (PATH)</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more than a single project.</source>
          <target state="translated">L’extensibilité basée sur le chemin est généralement utilisée pour les ordinateurs de développement qui nécessitent un outil qui traite conceptuellement plusieurs projets.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The main drawback of this extensions mechanism is that it is tied to the machine where the tool exists.</source>
          <target state="translated">Le principal inconvénient de ce mécanisme d’extension est qu’il est limité à l’ordinateur sur lequel est installé l’outil.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>If you need it on another machine, you would have to deploy it.</source>
          <target state="translated">Si vous avez besoin de l’installer sur un autre ordinateur, vous devrez le déployer.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>This pattern of CLI toolset extensibility is very simple.</source>
          <target state="translated">Ce modèle d’extensibilité des outils CLI est très simple.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>As covered in the <bpt id="p1">[</bpt>.NET Core CLI overview<ept id="p1">](index.md)</ept>, <ph id="ph1">`dotnet`</ph> driver can run any command that is named after the <ph id="ph2">`dotnet-&lt;command&gt;`</ph> convention.</source>
          <target state="translated">Comme indiqué dans la <bpt id="p1">[</bpt>présentation des outils CLI .NET Core<ept id="p1">](index.md)</ept>, le pilote <ph id="ph1">`dotnet`</ph> peut exécuter toutes les commandes dont le nom respecte la convention <ph id="ph2">`dotnet-&lt;command&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The default resolution logic will first probe several locations and will finally fall to the system PATH.</source>
          <target state="translated">La logique de résolution par défaut sonde d’abord plusieurs emplacements avant d’arriver au chemin système.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>If the requested command exists in the system PATH and is a binary that can be invoked, <ph id="ph1">`dotnet`</ph> driver will invoke it.</source>
          <target state="translated">Si la commande demandée existe dans le chemin système et s’il s’agit d’un fichier binaire qui peut être appelé, le pilote <ph id="ph1">`dotnet`</ph> l’appellera.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The binary can be pretty much anything that the operating system can execute.</source>
          <target state="translated">La seule qualité indispensable au fichier binaire est d’être exécutable par le système d’exploitation.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>On Unix systems, this means anything that has the execute bit set via <ph id="ph1">`chmod +x`</ph>.</source>
          <target state="translated">Sur les systèmes Unix, il peut s’agir de tous les fichiers dont le bit d’exécution est défini via <ph id="ph1">`chmod +x`</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>On Windows it means anything that Windows knows how to run.</source>
          <target state="translated">Sur les systèmes Windows, il peut s’agir de n’importe quel fichier que Windows peut exécuter.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>As an example, let's take a look at a very simple implementation of a <ph id="ph1">`dotnet clean`</ph> command.</source>
          <target state="translated">Voyons par exemple une implémentation très simple d’une commande <ph id="ph1">`dotnet clean`</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>We will use <ph id="ph1">`bash`</ph> to implement this command.</source>
          <target state="translated">Nous allons utiliser <ph id="ph1">`bash`</ph> pour implémenter cette commande.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The command will simply delete the <ph id="ph1">`bin/`</ph> and <ph id="ph2">`obj/`</ph> directories in the current directory.</source>
          <target state="translated">La commande supprime les répertoires <ph id="ph1">`bin/`</ph> et <ph id="ph2">`obj/`</ph> situés dans le répertoire actif.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`--lock`</ph> argument is passed to it, it will also delete <ph id="ph2">`project.lock.json`</ph> file.</source>
          <target state="translated">Si l’argument <ph id="ph1">`--lock`</ph> lui est passé, elle supprime également le fichier <ph id="ph2">`project.lock.json`</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The entirety of the command is given below.</source>
          <target state="translated">L’intégralité de la commande est affichée ci-dessous.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>On macOS, we can save this script as <ph id="ph1">`dotnet-clean`</ph> and set its executable bit with <ph id="ph2">`chmod +x dotnet-clean`</ph>.</source>
          <target state="translated">Sur Mac OS, nous pouvons enregistrer ce script en tant que <ph id="ph1">`dotnet-clean`</ph> et définir son bit exécutable avec <ph id="ph2">`chmod +x dotnet-clean`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>We can then create a symbolic link to it in <ph id="ph1">`/usr/local/bin`</ph> using the command <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph>.</source>
          <target state="translated">Nous pouvons ensuite créer un lien symbolique vers le script dans <ph id="ph1">`/usr/local/bin`</ph> à l’aide de la commande <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>This will make it possible to invoke the clean command using the <ph id="ph1">`dotnet clean`</ph> syntax.</source>
          <target state="translated">Cela permet d’appeler la commande Clean à l’aide de la syntaxe <ph id="ph1">`dotnet clean`</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can test this by creating an app, running <ph id="ph1">`dotnet build`</ph> on it and then running <ph id="ph2">`dotnet clean`</ph>.</source>
          <target state="translated">Vous pouvez tester cela en créant une application, en exécutant <ph id="ph1">`dotnet build`</ph> sur l’application, puis en exécutant <ph id="ph2">`dotnet clean`</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The .NET Core CLI tools allow three main extensibility points.</source>
          <target state="translated">Les outils CLI .NET Core permettent trois principaux points d’extensibilité.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The per-project tools are contained within the project's context, but they allow easy installation through restoration.</source>
          <target state="translated">Les outils par projet sont contenus dans le contexte du projet, mais ils permettent une installation rapide grâce à une restauration.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Custom targets allow you to easily extend the build process with custom tasks.</source>
          <target state="translated">Les cibles personnalisées vous permettent d’étendre facilement le processus de génération avec des tâches personnalisées.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>PATH-based tools are good for general, cross-project tools that are usable on a single machine.</source>
          <target state="translated">Les outils basés sur le chemin sont efficaces pour les outils généraux multiprojets qui sont utilisables sur un seul ordinateur.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>