<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b2162a90d5cb6f3472a9d323a3e46e137c9edf82</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\anchors.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d2e25c2b175059780bad8d84610bac5dd45943c9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">be0ae2ec2339240e0b2afaf2a28731c577021241</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Anchors in regular expressions</source>
          <target state="translated">Ancres dans les expressions régulières</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Anchors in regular expressions</source>
          <target state="translated">Ancres dans les expressions régulières</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Anchors in regular expressions</source>
          <target state="translated">Ancres dans les expressions régulières</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Anchors, or atomic zero-width assertions, specify a position in the string where a match must occur.</source>
          <target state="translated">Les ancres, ou assertions atomiques de largeur nulle, spécifient une position dans la chaîne où une correspondance doit se produire.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>When you use an anchor in your search expression, the regular expression engine does not advance through the string or consume characters; it looks for a match in the specified position only.</source>
          <target state="translated">Quand vous utilisez une ancre dans votre expression de recherche, le moteur des expressions régulières n'avance pas dans la chaîne ou ne consomme pas de caractères ; il recherche uniquement une correspondance à la position spécifiée.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> specifies that the match must start at the beginning of a line or string.</source>
          <target state="translated">Par exemple, <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> spécifie que la correspondance doit commencer au début d’une ligne ou d’une chaîne.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Therefore, the regular expression <ph id="ph1">`^http:`</ph> matches "http:" only when it occurs at the beginning of a line.</source>
          <target state="translated">Par conséquent, l'expression régulière <ph id="ph1">`^http:`</ph> correspond uniquement à « http: » quand elle se produit au début d'une ligne.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The following table lists the anchors supported by the regular expressions in .NET.</source>
          <target state="translated">Le tableau suivant répertorie les ancres prises en charge par les expressions régulières dans .NET.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Anchor</source>
          <target state="translated">Ancre</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The match must occur at the beginning of the string or line.</source>
          <target state="translated">La correspondance doit se produire au début de la chaîne ou de la ligne.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string or line, or before \n at the end of the string or line.</source>
          <target state="translated">La correspondance doit se produire à la fin de la chaîne ou de la ligne ou avant \n à la fin de la chaîne ou de la ligne.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\A<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\A<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The match must occur at the beginning of the string only (no multiline support)</source>
          <target state="translated">La correspondance doit se produire au début de la chaîne uniquement (aucun support multiligne).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string, or before \n at the end of the string.</source>
          <target state="translated">La correspondance doit se produire à la fin de la chaîne ou avant \n à la fin de la chaîne.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\z<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\z<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string only.</source>
          <target state="translated">La correspondance doit se produire uniquement à la fin de la chaîne.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\G<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\G<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The match must start at the position where the previous match ended.</source>
          <target state="translated">La correspondance doit démarrer à la position où la correspondance précédente s'est terminée.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\b<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\b<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The match must occur on a word boundary.</source>
          <target state="translated">La correspondance doit se produire à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\B<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\B<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The match must not occur on a word boundary.</source>
          <target state="translated">La correspondance ne doit pas se produire à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Start of String or Line: ^</source>
          <target state="translated">Début de chaîne ou de ligne : ^</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> anchor specifies that the following pattern must begin at the first character position of the string.</source>
          <target state="translated">L’ancre <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> spécifie que le modèle suivant doit commencer à la position du premier caractère de la chaîne.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> with the <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option (see <bpt id="p3">[</bpt>Regular expression options<ept id="p3">](options.md)</ept>), the match must occur at the beginning of each line.</source>
          <target state="translated">Si vous utilisez <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> avec l’option <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> (consultez <bpt id="p3">[</bpt>Options des expressions régulières<ept id="p3">](options.md)</ept>), la correspondance doit se trouver au début de chaque ligne.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">L’exemple suivant utilise l’ancre <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> dans une expression régulière qui extrait des informations à propos des années pendant lesquelles certaines équipes de baseball professionnelles ont existé.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The example calls two overloads of the <ph id="ph1">`Regex.Matches`</ph> method:</source>
          <target state="translated">L'exemple appelle deux surcharges de la méthode <ph id="ph1">`Regex.Matches`</ph> :</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The call to the <bpt id="p1">[</bpt>Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> overload finds only the first substring in the input string that matches the regular expression pattern.</source>
          <target state="translated">L’appel à la surcharge <bpt id="p1">[</bpt>Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> recherche uniquement la première sous-chaîne dans la chaîne d’entrée qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The call to the <bpt id="p1">[</bpt>Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> overload with the options parameter set to <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> finds all five substrings.</source>
          <target state="translated">L’appel à la surcharge <bpt id="p1">[</bpt>Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> avec le paramètre options défini sur <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> recherche les cinq sous-chaînes.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+`</ph> is defined as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+`</ph> est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the input string (or the beginning of the line if the method is called with the <ph id="ph1">`RegexOptions.Multiline`</ph> option).</source>
          <target state="translated">Commencer la correspondance au début de la chaîne d'entrée (ou au début de la ligne si la méthode est appelée avec l'option <ph id="ph1">`RegexOptions.Multiline`</ph>).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed either by zero or by one space exactly two times.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères de mot suivis de zéro ou d'un espace précisément deux fois.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Il s'agit du premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This expression also defines a second and third capturing group: The second consists of the captured word, and the third consists of the captured spaces.</source>
          <target state="translated">Cette expression définit également un deuxième et un troisième groupe de capture : le deuxième se compose du mot capturé, et le troisième se compose des espaces capturés.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Match a comma followed by a white-space character.</source>
          <target state="translated">Mettre en correspondance une virgule suivie d'un caractère d'espace blanc.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a space, followed by one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères de mot suivis d'un espace, suivi d'un ou plusieurs caractères de mot.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This is the fourth capturing group.</source>
          <target state="translated">Il s'agit du quatrième groupe de capture.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Match a comma.</source>
          <target state="translated">Mettre en correspondance une virgule.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Match a space followed by four decimal digits.</source>
          <target state="translated">Mettre en correspondance un espace suivi de quatre chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?`</ph></source>
          <target state="translated"><ph id="ph1">`(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?`</ph></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a hyphen followed by four decimal digits or the string "present".</source>
          <target state="translated">Mettre en correspondance zéro ou une occurrence d'un trait d'union suivie de quatre chiffres décimaux ou de la chaîne « present ».</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This is the sixth capturing group.</source>
          <target state="translated">Il s'agit du sixième groupe de capture.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>It also includes a seventh capturing group.</source>
          <target state="translated">Il inclut également un septième groupe de capture.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a comma.</source>
          <target state="translated">Mettre en correspondance zéro ou une occurrence d'une virgule.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(\s\d{4}(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?,?)+`</ph></source>
          <target state="translated"><ph id="ph1">`(\s\d{4}(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?,?)+`</ph></target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of the following: a space, four decimal digits, zero or one occurrence of a hyphen followed by four decimal digits or the string "present", and zero or one comma.</source>
          <target state="translated">Mettre en correspondance une ou plusieurs occurrences des éléments suivants : un espace, quatre chiffres décimaux, zéro ou une occurrence d'un trait d'union suivie de quatre chiffres décimaux ou de la chaîne « present » et zéro ou une virgule.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This is the fifth capturing group.</source>
          <target state="translated">Il s'agit du cinquième groupe de capture.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>End of String or Line: $</source>
          <target state="translated">Fin de chaîne ou de ligne : $</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string.</source>
          <target state="translated">L’ancre <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> spécifie que le modèle précédent doit se produire à la fin de la chaîne d’entrée ou avant \n en fin de chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> with the <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, the match can also occur at the end of a line.</source>
          <target state="translated">Si vous utilisez <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> avec l’option <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>, la correspondance peut également se trouver à la fin d’une ligne.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Note that <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> matches <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> but does not match <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (the combination of carriage return and newline characters, or CR/LF).</source>
          <target state="translated">Notez que <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> correspond à <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>, mais ne correspond pas à <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (combinaison de caractères de retour chariot et de saut de ligne ou CR/LF).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To match the CR/LF character combination, include <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> in the regular expression pattern.</source>
          <target state="translated">Pour établir une correspondance avec la combinaison de caractères CR/LF, incluez <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> dans le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following example adds the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> anchor to the regular expression pattern used in the example in the previous "Start of String or Line" section.</source>
          <target state="translated">L’exemple suivant ajoute l’ancre <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> au modèle d’expression régulière utilisé dans l’exemple dans la section « Début de chaîne ou de ligne » précédente.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When used with the original input string, which includes five lines of text, the <bpt id="p1">[</bpt>Regex.Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> method is unable to find a match, because the end of the first line does not match the <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept> pattern.</source>
          <target state="translated">En cas d’utilisation avec la chaîne d’entrée d’origine, qui inclut cinq lignes de texte, la méthode <bpt id="p1">[</bpt>Regex.Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> ne peut pas trouver de correspondance, parce que la fin de la première ligne ne correspond pas au modèle <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>When the original input string is split into a string array, the <ph id="ph1">`Regex.Matches(String, String)`</ph> method succeeds in matching each of the five lines.</source>
          <target state="translated">Quand la chaîne d'entrée d'origine est fractionnée dans un tableau de chaînes, la méthode <ph id="ph1">`Regex.Matches(String, String)`</ph> réussit à faire correspondre chacune des cinq lignes.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When the <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">*</bpt>options<ept id="p2">*</ept> parameter set to <ph id="ph1">`RegexOptions.Multiline`</ph>, no matches are found because the regular expression pattern does not account for the carriage return element (\u+000D).</source>
          <target state="translated">Quand la méthode <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> est appelée avec le paramètre <bpt id="p2">*</bpt>options<ept id="p2">*</ept> ayant la valeur <ph id="ph1">`RegexOptions.Multiline`</ph>, aucune correspondance n’est trouvée parce que le modèle d’expression régulière ne représente pas l’élément de retour chariot (\u+000D).</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>However, when the regular expression pattern is modified by replacing <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> with <bpt id="p2">**</bpt>\r?$<ept id="p2">**</ept>, calling the <ph id="ph2">`Regex.Matches(String, String, RegexOptions)`</ph> method with the <bpt id="p3">*</bpt>options<ept id="p3">*</ept> parameter set to <ph id="ph3">`RegexOptions.Multiline`</ph> again finds five matches.</source>
          <target state="translated">Toutefois, quand le modèle d’expression régulière est modifié par le remplacement de <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> par <bpt id="p2">**</bpt>\r?$<ept id="p2">**</ept>, l’appel de la méthode <ph id="ph2">`Regex.Matches(String, String, RegexOptions)`</ph> avec le paramètre <bpt id="p3">*</bpt>options<ept id="p3">*</ept> ayant la valeur <ph id="ph3">`RegexOptions.Multiline`</ph> trouve encore cinq correspondances.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Start of String Only: \A</source>
          <target state="translated">Début de chaîne uniquement : \A</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> anchor specifies that a match must occur at the beginning of the input string.</source>
          <target state="translated">L’ancre <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> spécifie qu’une correspondance doit se produire au début de la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>It is identical to the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> anchor, except that <bpt id="p2">**</bpt>\A<ept id="p2">**</ept> ignores the <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option.</source>
          <target state="translated">Elle est identique à l’ancre <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept>, si ce n’est que <bpt id="p2">**</bpt>\A<ept id="p2">**</ept> ignore l’option <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Therefore, it can only match the start of the first line in a multiline input string.</source>
          <target state="translated">Par conséquent, elle peut correspondre uniquement au début de la première ligne dans une chaîne d'entrée multiligne.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The following example is similar to the examples for the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> anchors.</source>
          <target state="translated">L’exemple suivant est semblable aux exemples des ancres <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> et <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">Il utilise l’ancre <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> dans une expression régulière qui extrait des informations sur les années où jouaient certaines équipes de baseball professionnelles.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The input string includes five lines.</source>
          <target state="translated">La chaîne d'entrée inclut cinq lignes.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The call to the <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method finds only the first substring in the input string that matches the regular expression pattern.</source>
          <target state="translated">L’appel à la méthode <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> recherche uniquement la première sous-chaîne dans la chaîne d’entrée qui correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>As the example shows, the <ph id="ph1">`Multiline`</ph> option has no effect.</source>
          <target state="translated">Comme le montre l'exemple, l'option <ph id="ph1">`Multiline`</ph> n'a aucun effet.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>End of String or Before Ending Newline: \Z</source>
          <target state="translated">Fin de chaîne ou avant un saut de ligne final : \Z</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> anchor specifies that a match must occur at the end of the input string, or before <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> at the end of the input string.</source>
          <target state="translated">L’ancre <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> spécifie qu’une correspondance doit se produire à la fin de la chaîne d’entrée ou avant <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> en fin de chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>It is identical to the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> anchor, except that <bpt id="p2">**</bpt>\Z<ept id="p2">**</ept> ignores the <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option.</source>
          <target state="translated">Elle est identique à l’ancre <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept>, si ce n’est que <bpt id="p2">**</bpt>\Z<ept id="p2">**</ept> ignore l’option <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Therefore, in a multiline string, it can only match the end of the last line, or the last line before <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</source>
          <target state="translated">Par conséquent, dans une chaîne multiligne, elle peut correspondre uniquement à la fin de la dernière ligne ou à la dernière ligne avant <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Note that <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> matches <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> but does not match <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (the CR/LF character combination).</source>
          <target state="translated">Notez que <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> correspond à <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>, mais ne correspond pas à <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (combinaison de caractères CR/LF).</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>To match CR/LF, include <bpt id="p1">**</bpt>\r?\Z<ept id="p1">**</ept> in the regular expression pattern.</source>
          <target state="translated">Pour établir une correspondance avec les caractères CR/LF, incluez <bpt id="p1">**</bpt>\r?\Z<ept id="p1">**</ept> dans le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> anchor in a regular expression that is similar to the example in the previous "Start of String or Line" section, which extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">L’exemple suivant utilise l’ancre <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> dans une expression régulière qui est semblable à l’exemple dans la section « Début de chaîne ou de ligne » précédente, qui extrait des informations à propos des années pendant lesquelles certaines équipes de baseball professionnelles ont existé.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The subexpression <ph id="ph1">`\r?\Z`</ph> in the regular expression <ph id="ph2">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z`</ph> matches the end of a string, and also matches a string that ends with <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> or <bpt id="p2">**</bpt>\r\n<ept id="p2">**</ept>.</source>
          <target state="translated">La sous-expression <ph id="ph1">`\r?\Z`</ph> dans l’expression régulière <ph id="ph2">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z`</ph> correspond à la fin d’une chaîne et correspond également à une chaîne qui se termine par <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> ou <bpt id="p2">**</bpt>\r\n<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>As a result, each element in the array matches the regular expression pattern.</source>
          <target state="translated">Par conséquent, chaque élément du tableau correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>End of String Only: \z</source>
          <target state="translated">Fin de chaîne uniquement : \z</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> anchor specifies that a match must occur at the end of the input string.</source>
          <target state="translated">L’ancre <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> spécifie qu’une correspondance doit se produire à la fin de la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Like the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> language element, <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> ignores the <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option.</source>
          <target state="translated">Comme l’élément de langage <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept>, <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> ignore l’option <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Unlike the <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> language element, <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> does not match a <bpt id="p3">**</bpt>\n<ept id="p3">**</ept> character at the end of a string.</source>
          <target state="translated">Contrairement à l’élément de langage <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept>, <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> ne correspond pas à un caractère <bpt id="p3">**</bpt>\n<ept id="p3">**</ept> à la fin d’une chaîne.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Therefore, it can only match the last line of the input string.</source>
          <target state="translated">Par conséquent, elle peut correspondre uniquement à la dernière ligne de la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> anchor in a regular expression that is otherwise identical to the example in the previous section, which extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">L’exemple suivant utilise l’ancre <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> dans une expression régulière qui est sinon identique à l’exemple dans la section précédente, qui extrait des informations à propos des années pendant lesquelles certaines équipes de baseball professionnelles ont existé.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The example tries to match each of five elements in a string array with the regular expression pattern <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`</ph>.</source>
          <target state="translated">L'exemple essaie de faire correspondre chacun des cinq éléments dans un tableau de chaînes avec le modèle d'expression régulière <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Two of the strings end with carriage return and line feed characters, one ends with a line feed character, and two end with neither a carriage return nor a line feed character.</source>
          <target state="translated">Deux des chaînes se terminent par un retour chariot et des caractères de saut de ligne, l'une se termine par un caractère de saut de ligne, et deux ne se terminent ni par un retour chariot ni par un caractère de saut de ligne.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>As the output shows, only the strings without a carriage return or line feed character match the pattern.</source>
          <target state="translated">Comme le montre la sortie, seules les chaînes sans retour chariot ou caractère de saut de ligne correspondent au modèle.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Contiguous Matches: \G</source>
          <target state="translated">Correspondances contiguës : \G</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\G<ept id="p1">**</ept> anchor specifies that a match must occur at the point where the previous match ended.</source>
          <target state="translated">L’ancre <bpt id="p1">**</bpt>\G<ept id="p1">**</ept> spécifie qu’une correspondance doit se produire au point où la correspondance précédente s’est terminée.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>When you use this anchor with the <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> or <bpt id="p2">[</bpt>Match.NextMatch<ept id="p2">](xref:System.Text.RegularExpressions.Match.NextMatch)</ept> method, it ensures that all matches are contiguous.</source>
          <target state="translated">Quand vous utilisez cette ancre avec la méthode <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> ou <bpt id="p2">[</bpt>Match.NextMatch<ept id="p2">](xref:System.Text.RegularExpressions.Match.NextMatch)</ept>, elle garantit que toutes les correspondances sont contiguës.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The following example uses a regular expression to extract the names of rodent species from a comma-delimited string.</source>
          <target state="translated">L'exemple suivant utilise une expression régulière pour extraire les noms d'espèces de rongeurs d'une chaîne délimitée par des virgules.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\G(\w+\s?\w*),?`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">L'expression régulière <ph id="ph1">`\G(\w+\s?\w*),?`</ph> est interprétée comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Begin where the last match ended.</source>
          <target state="translated">Commencer là où la dernière correspondance s'est terminée.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Match zero or one space.</source>
          <target state="translated">Mettre en correspondance zéro ou un espace.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
          <target state="translated">Mettre en correspondance zéro, un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by zero or one space, followed by zero or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères de mot suivis de zéro ou d'un espace, suivi de zéro ou davantage de caractères de mot.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Il s'agit du premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a literal comma character.</source>
          <target state="translated">Mettre en correspondance zéro ou une occurrence d'une virgule littérale.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Word Boundary: \b</source>
          <target state="translated">Limite de mot : \b</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> anchor specifies that the match must occur on a boundary between a word character (the <bpt id="p2">**</bpt>\w<ept id="p2">**</ept> language element) and a non-word character (the <bpt id="p3">**</bpt>\W<ept id="p3">**</ept> language element).</source>
          <target state="translated">L’ancre <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> spécifie que la correspondance doit se produire à la limite entre un caractère de mot (élément de langage <bpt id="p2">**</bpt>\w<ept id="p2">**</ept>) et un caractère n’appartenant pas à un mot (élément de langage <bpt id="p3">**</bpt>\W<ept id="p3">**</ept>).</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore.</source>
          <target state="translated">Les caractères de mot se composent de caractères alphanumériques et de traits de soulignement ; un caractère n'appartenant pas à un mot est un caractère qui n'est pas alphanumérique ou qui n'est pas un trait de soulignement.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>(For more information, see <bpt id="p1">[</bpt>Character classes in regular expressions<ept id="p1">](classes.md)</ept>.) The match may also occur on a word boundary at the beginning or end of the string.</source>
          <target state="translated">(Pour plus d’informations, consultez <bpt id="p1">[</bpt>Classes de caractères dans les expressions régulières<ept id="p1">](classes.md)</ept>.) La correspondance peut également se produire à la limite d'un mot au début ou à la fin de la chaîne.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
          <target state="translated">L’ancre <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> est fréquemment utilisée pour faire en sorte qu’une sous-expression corresponde à un mot entier plutôt qu’au début ou à la fin d’un mot uniquement.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\bare\w*\b`</ph> in the following example illustrates this usage.</source>
          <target state="translated">L'expression régulière <ph id="ph1">`\bare\w*\b`</ph> dans l'exemple suivant illustre cette utilisation.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>It matches any word that begins with the substring "are".</source>
          <target state="translated">Elle correspond à tout mot qui commence par la sous-chaîne « are ».</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The output from the example also illustrates that <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> matches both the beginning and the end of the input string.</source>
          <target state="translated">La sortie de l’exemple illustre également que <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> correspond à la fois au début et la fin de la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">Le modèle d’expression régulière est interprété comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match the substring "are".</source>
          <target state="translated">Mettre en correspondance la sous-chaîne « are ».</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
          <target state="translated">Mettre en correspondance zéro, un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Non-Word Boundary: \B</source>
          <target state="translated">Limite n'appartenant pas à un mot : \B</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> anchor specifies that the match must not occur on a word boundary.</source>
          <target state="translated">L’ancre <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> spécifie que la correspondance ne doit pas se produire à la limite d’un mot.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>It is the opposite of the <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> anchor.</source>
          <target state="translated">Elle est le contraire de l’ancre <bpt id="p1">**</bpt>\b<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> anchor to locate occurrences of the substring "qu" in a word.</source>
          <target state="translated">L’exemple suivant utilise l’ancre <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> pour trouver des occurrences de la sous-chaîne « qu » dans un mot.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\Bqu\w+`</ph> matches a substring that begins with a "qu" that does not start a word and that continues to the end of the word.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\Bqu\w+`</ph> met en correspondance une sous-chaîne qui commence par un « qu » qui n'est pas en début de mot et continue jusqu'à la fin du mot.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière est interprété comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Do not begin the match at a word boundary.</source>
          <target state="translated">Ne pas commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Match the substring "qu".</source>
          <target state="translated">Mettre en correspondance la sous-chaîne « qu ».</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Langage des expressions régulières - Aide-mémoire<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Options des expressions régulières<ept id="p1">](options.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>