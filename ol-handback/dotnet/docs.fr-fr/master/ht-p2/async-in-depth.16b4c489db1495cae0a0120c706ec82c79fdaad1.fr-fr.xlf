<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6536a608a4ee1bb10f41907a28114193a300a52c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\async-in-depth.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4a59cc5bc6b7d68b057f06623b3cc2f09799a72f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0300c978d5652352126d5e8e8e0c9370ad283890</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Async in depth</source>
          <target state="translated">Async en détail</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>In-depth explanation of how asynchronous code works in .NET</source>
          <target state="translated">Explication détaillée du fonctionnement du code asynchrone dans .NET</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, .NET Standard</source>
          <target state="translated">.NET, .NET Core, .NET Standard</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Async in depth</source>
          <target state="translated">Async en détail</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</source>
          <target state="translated">L’écriture de code asynchrone utilisant des E/S et le processeur est simple avec le modèle asynchrone .NET basé sur des tâches.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The model is exposed by the <ph id="ph1">`Task`</ph> and <ph id="ph2">`Task&lt;T&gt;`</ph> types and the <ph id="ph3">`async`</ph> and <ph id="ph4">`await`</ph> language keywords.</source>
          <target state="translated">Le modèle est exposé par les types <ph id="ph1">`Task`</ph> et <ph id="ph2">`Task&lt;T&gt;`</ph>, et les mots clés de langage <ph id="ph3">`async`</ph> et <ph id="ph4">`await`</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This article explains how to use .NET async and provides insight into the async framework used under the covers.</source>
          <target state="translated">Cet article explique comment utiliser le code asynchrone .NET et fournit un aperçu du framework asynchrone utilisé en coulisses.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Task and Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph></source>
          <target state="translated">Task et Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Tasks are constructs used to implement what is known as the <bpt id="p1">[</bpt>Promise Model of Concurrency<ept id="p1">](https://en.wikipedia.org/wiki/Futures_and_promises)</ept>.</source>
          <target state="translated">Les tâches sont des constructions utilisées pour implémenter ce que l’on appelle le <bpt id="p1">[</bpt>modèle de promesses de concurrence<ept id="p1">](https://en.wikipedia.org/wiki/Futures_and_promises)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</source>
          <target state="translated">En bref, elles vous offrent la « promesse » que le travail sera terminé à un moment ultérieur, ce qui vous permet de coordonner la promesse et une nouvelle API.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task`</ph> represents a single operation which does not return a value.</source>
          <target state="translated"><ph id="ph1">`Task`</ph> représente une opération unique qui ne retourne pas de valeur.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task&lt;T&gt;`</ph> represents a single operation which returns a value of type <ph id="ph2">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Task&lt;T&gt;`</ph> représente une opération unique qui retourne une valeur de type <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It’s important to reason about tasks as abstractions of work happening asynchronously, and <bpt id="p1">*</bpt>not<ept id="p1">*</ept> an abstraction over threading.</source>
          <target state="translated">Il est important de considérer les tâches comme des abstractions de travail effectuées de manière asynchrone et <bpt id="p1">*</bpt>pas<ept id="p1">*</ept> comme une abstraction sur le modèle de thread.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</source>
          <target state="translated">Par défaut, les tâches s’exécutent sur le thread actuel et délèguent le travail au système d’exploitation, comme il convient.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Optionally, tasks can be be explicitly requested to run on a separate thread via the <ph id="ph1">`Task.Run`</ph> API.</source>
          <target state="translated">Éventuellement, l’API <ph id="ph1">`Task.Run`</ph> peut servir à demander explicitement aux tâches de s’exécuter sur un thread distinct.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of <ph id="ph1">`Task&lt;T&gt;`</ph>) of a task.</source>
          <target state="translated">Les tâches exposent un protocole d’API pour surveiller et attendre la valeur de résultat d’une tâche et y accéder (dans le cas de <ph id="ph1">`Task&lt;T&gt;`</ph>).</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Language integration, with the <ph id="ph1">`await`</ph> keyword, provides a higher-level abstraction for using tasks.</source>
          <target state="translated">L’intégration au langage, avec le mot clé <ph id="ph1">`await`</ph>, fournit une abstraction de niveau supérieur pour l’utilisation des tâches.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Using <ph id="ph1">`await`</ph> allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</source>
          <target state="translated">L’utilisation de <ph id="ph1">`await`</ph> permet à votre application ou service d’effectuer un travail utile pendant l’exécution d’une tâche en cédant le contrôle à son appelant jusqu’à ce que la tâche soit terminée.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</source>
          <target state="translated">Votre code n’a pas besoin de s’appuyer sur des rappels ou des événements pour continuer l’exécution une fois la tâche terminée.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The language and task API integration does that for you.</source>
          <target state="translated">L’intégration des API de langage et de tâche s’en charge pour vous.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If you’re using <ph id="ph1">`Task&lt;T&gt;`</ph>, the <ph id="ph2">`await`</ph> keyword will additionally “unwrap” the value returned when the Task is complete.</source>
          <target state="translated">Si vous utilisez <ph id="ph1">`Task&lt;T&gt;`</ph>, le mot clé <ph id="ph2">`await`</ph> « désencapsule » également la valeur retournée quand la tâche est terminée.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The details of how this works are explained further below.</source>
          <target state="translated">Les détails de ce fonctionnement sont expliqués plus bas.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can learn more about tasks and the different ways to interact with them in the <bpt id="p1">[</bpt>Task-based Asynchronous Pattern (TAP) Article<ept id="p1">](https://msdn.microsoft.com/library/hh873175.aspx)</ept>.</source>
          <target state="translated">Pour en savoir plus sur les tâches et les différentes façons d’interagir avec elles, lisez l’<bpt id="p1">[</bpt>article Task-based Asynchronous Pattern (TAP)<ept id="p1">](https://msdn.microsoft.com/library/hh873175.aspx)</ept> (Modèle asynchrone basé sur des tâches).</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Deeper Dive into Tasks for an I/O-Bound Operation</source>
          <target state="translated">Approfondissement : Tâches pour une opération utilisant des E/S</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following section describes a 10,000 foot view of what happens with a typical async I/O call.</source>
          <target state="translated">La section suivante décrit en détail toutes les étapes d’un appel d’E/S asynchrone standard.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Let's start with a couple examples.</source>
          <target state="translated">Commençons par deux exemples.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The first example calls an async method and returns an active task, likely yet to complete.</source>
          <target state="translated">Le premier exemple appelle une méthode async et retourne une tâche active qui n’est pas encore terminée.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The second example adds the use of he <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords to operate on the task.</source>
          <target state="translated">Le deuxième exemple ajoute l’utilisation des mots clés <ph id="ph1">`async`</ph> et <ph id="ph2">`await`</ph> pour agir sur la tâche.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The call to <ph id="ph1">`GetStringAsync()`</ph> calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</source>
          <target state="translated">L’appel de <ph id="ph1">`GetStringAsync()`</ph> s’effectue par le biais de bibliothèques .NET de niveau inférieur (peut-être en appelant d’autres méthodes async) jusqu’à ce qu’il atteigne un appel interop P/Invoke dans une bibliothèque de réseau native.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The native library may subsequently call into a System API call (such as <ph id="ph1">`write()`</ph> to a socket on Linux).</source>
          <target state="translated">La bibliothèque native peut ensuite effectuer un appel de l’API système (tel que <ph id="ph1">`write()`</ph> pour un socket sur Linux).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A task object will be created at the native/managed boundary, possibly using <bpt id="p1">[</bpt>TaskCompletionSource<ept id="p1">](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))</ept>.</source>
          <target state="translated">Un objet de tâche est créé dans la limite native/managée, éventuellement à l’aide de <bpt id="p1">[</bpt>TaskCompletionSource<ept id="p1">](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))</ept>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</source>
          <target state="translated">L’objet de tâche est transmis à travers les couches, éventuellement traité ou directement retourné, ou retourné à l’appelant initial.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In the second example above, a <ph id="ph1">`Task&lt;T&gt;`</ph> object will be returned from <ph id="ph2">`GetStringAsync`</ph>.</source>
          <target state="translated">Dans le deuxième exemple ci-dessus, un objet <ph id="ph1">`Task&lt;T&gt;`</ph> est retourné par <ph id="ph2">`GetStringAsync`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The use of the <ph id="ph1">`await`</ph> keyword causes the method to return a newly created task object.</source>
          <target state="translated">L’utilisation du mot clé <ph id="ph1">`await`</ph> indique à la méthode de retourner un objet de tâche nouvellement créé.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Control returns to the caller from this location in the <ph id="ph1">`GetFirstCharactersCountAsync`</ph> method.</source>
          <target state="translated">Le contrôle retourne à l’appelant à partir de cet emplacement dans la méthode <ph id="ph1">`GetFirstCharactersCountAsync`</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The methods and properties of the <bpt id="p1">[</bpt>Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Threading.Tasks.Task%601)</ept> object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</source>
          <target state="translated">Les méthodes et propriétés de l’objet <bpt id="p1">[</bpt>Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Threading.Tasks.Task%601)</ept> permettent aux appelants de surveiller la progression de la tâche, qui se termine quand le code restant dans GetFirstCharactersCountAsync a été exécuté.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as <ph id="ph1">`/net`</ph> in the Linux Kernel).</source>
          <target state="translated">Après l’appel de l’API système, la demande se trouve dans l’espace du noyau et transite vers le sous-système de réseau du système d’exploitation (comme <ph id="ph1">`/net`</ph> dans le noyau Linux).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Here the OS will handle the networking request <bpt id="p1">*</bpt>asynchronously<ept id="p1">*</ept>.</source>
          <target state="translated">Ici, le système d’exploitation gère la demande de mise en réseau de manière <bpt id="p1">*</bpt>asynchrone<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and <bpt id="p1">*</bpt>then<ept id="p1">*</ept> a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</source>
          <target state="translated">Les détails peuvent être différents selon le système d’exploitation utilisé (l’appel du pilote de périphérique peut être planifié comme un signal envoyé au runtime, ou il peut être effectué et <bpt id="p1">*</bpt>ensuite<ept id="p1">*</ept> un signal est renvoyé), mais finalement le runtime est informé que la demande de mise en réseau est en cours.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</source>
          <target state="translated">À ce stade, le travail du pilote de périphérique est planifié, en cours ou déjà terminé (la demande est déjà « sur le réseau »), mais parce que tout se passe de manière asynchrone, le pilote de périphérique est en mesure de gérer immédiatement autre chose !</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</source>
          <target state="translated">Par exemple, dans Windows, un thread de système d’exploitation effectue un appel au pilote de périphérique réseau et lui demande d’effectuer l’opération de mise en réseau via un paquet de requêtes d’interruption qui représente l’opération.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</source>
          <target state="translated">Le pilote de périphérique reçoit le paquet de requêtes d’interruption, effectue l’appel au réseau, marque le paquet comme étant « en attente » et le renvoie au système d’exploitation.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</source>
          <target state="translated">Le thread du système d’exploitation sait maintenant que le paquet de requêtes d’interruption est « en attente », il n’a donc rien d’autre à faire pour ce travail et « revient » pour pouvoir être utilisé pour une autre opération.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</source>
          <target state="translated">Quand la demande est satisfaite et que les données reviennent à travers le pilote de périphérique, il avertit le processeur que de nouvelles données sont reçues via une interruption.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</source>
          <target state="translated">La façon dont cette interruption est gérée varie selon le système d’exploitation, mais les données sont ensuite transmises au système d’exploitation jusqu’à ce que se produise un appel d’interopérabilité système (par exemple, dans Linux, un gestionnaire d’interruptions planifie la moitié inférieure de l’IRQ pour qu’elle transmette les données via le système d’exploitation de façon asynchrone).</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Note that this <bpt id="p1">*</bpt>also<ept id="p1">*</ept> happens asynchronously!</source>
          <target state="translated">Notez que cela se produit <bpt id="p1">*</bpt>également<ept id="p1">*</ept> de façon asynchrone !</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The result is queued up until the next available thread is able execute the async method and "unwrap" the result of the completed task.</source>
          <target state="translated">Le résultat est placé en file d’attente jusqu’à ce que le prochain thread disponible soit en mesure d’exécuter la méthode async et de « désencapsuler » le résultat de la tâche effectuée.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Throughout this entire process, a key takeaway is that <bpt id="p1">**</bpt>no thread is dedicated to running the task<ept id="p1">**</ept>.</source>
          <target state="translated">Tout au long de ce processus, un élément clé à retenir est qu’<bpt id="p1">**</bpt>aucun thread n’est dédié à l’exécution de la tâche<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Although work is executed in some context (i.e. the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to <bpt id="p1">*</bpt>waiting<ept id="p1">*</ept> for data from the request to come back.</source>
          <target state="translated">Bien que le travail soit exécuté dans un contexte (c’est-à-dire que le système d’exploitation doit passer des données à un pilote de périphérique et répondre à une interruption), aucun thread n’est destiné à <bpt id="p1">*</bpt>attendre<ept id="p1">*</ept> le retour des données de la demande.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</source>
          <target state="translated">Cela permet au système de gérer une plus grande quantité de travail au lieu d’attendre la fin des appels d’E/S.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</source>
          <target state="translated">Bien que les étapes ci-dessus puissent donner l’impression d’un grand nombre d’opérations à effectuer, en termes de durée totale d’exécution, ce n’est rien comparé au temps nécessaire pour effectuer le travail d’E/S réel.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Although not at all precise, a potential timeline for such a call would look like this:</source>
          <target state="translated">Voici une vague idée de ce que pourrait être la chronologie de ces étapes :</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>0-1————————————————————————————————————————————————–2-3</source>
          <target state="translated">0-1————————————————————————————————————————————————–2-3</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Time spent from points <ph id="ph1">`0`</ph> to <ph id="ph2">`1`</ph> is everything up until an async method yields control to its caller.</source>
          <target state="translated">La durée entre les points <ph id="ph1">`0`</ph> et <ph id="ph2">`1`</ph> représente tout ce qui se passe avant qu’une méthode async cède le contrôle à son appelant.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Time spent from points <ph id="ph1">`1`</ph> to <ph id="ph2">`2`</ph> is the time spent on I/O, with no CPU cost.</source>
          <target state="translated">La durée entre les points <ph id="ph1">`1`</ph> et <ph id="ph2">`2`</ph> représente le temps consacré aux E/S, sans coût de processeur.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Finally, time spent from points <ph id="ph1">`2`</ph> to <ph id="ph2">`3`</ph> is passing control back (and potentially a value) to the async method, at which point it is executing again.</source>
          <target state="translated">Enfin, la durée entre les points <ph id="ph1">`2`</ph> et <ph id="ph2">`3`</ph> représente le temps consacré à rendre le contrôle (et éventuellement une valeur) à la méthode async, moment à partir duquel elle s’exécute à nouveau.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>What does this mean for a server scenario?</source>
          <target state="translated">Qu’est-ce que cela signifie dans un scénario de serveur ?</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This model works well with a typical server scenario workload.</source>
          <target state="translated">Ce modèle fonctionne correctement avec la charge de travail d’un scénario de serveur classique.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</source>
          <target state="translated">Comme aucun thread n’est destiné à s’interrompre sur les tâches non terminées, le pool de threads serveur peut traiter un plus grand nombre de demandes web.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Consider two servers: one that runs async code, and one that does not.</source>
          <target state="translated">Prenons deux serveurs : l’un d’eux exécute du code asynchrone et l’autre pas.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For the purpose of this example, each server only has 5 threads available to service requests.</source>
          <target state="translated">Pour les besoins de cet exemple, chaque serveur n’a que 5 threads disponibles pour traiter les demandes.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Note that these numbers are imaginarily small and serve only in a demonstrative context.</source>
          <target state="translated">Notez que ces chiffres sont intentionnellement petits et servent uniquement dans un contexte de démonstration.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Assume both servers receive 6 concurrent requests.</source>
          <target state="translated">Supposons que les deux serveurs reçoivent 6 demandes simultanées.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Each request performs an I/O operation.</source>
          <target state="translated">Chaque demande effectue une opération d’E/S.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The server <bpt id="p1">*</bpt>without<ept id="p1">*</ept> async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</source>
          <target state="translated">Le serveur <bpt id="p1">*</bpt>sans<ept id="p1">*</ept> code asynchrone doit placer en file d’attente la 6ème demande jusqu’à ce que l’un des 5 threads ait terminé le travail utilisant des E/S et écrit une réponse.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</source>
          <target state="translated">Quand la 20ème demande arrive, le serveur commence peut-être à ralentir, car la file d’attente devient trop longue.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The server <bpt id="p1">*</bpt>with<ept id="p1">*</ept> async code running on it still queues up the 6th request, but because it uses <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph>, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</source>
          <target state="translated">Le serveur <bpt id="p1">*</bpt>avec<ept id="p1">*</ept> code asynchrone peut placer en file d’attente la 6ème demande, mais parce qu’il utilise <ph id="ph1">`async`</ph> et <ph id="ph2">`await`</ph>, chacun de ses threads est libéré quand le travail utilisant des E/S démarre, et non quand il se termine.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</source>
          <target state="translated">Quand la 20ème demande arrive, la file d’attente des demandes entrantes est bien plus petite (ou est totalement vide) et le serveur ne ralentit pas.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Although this is a contrived example, it works in a very similar fashion in the real world.</source>
          <target state="translated">Bien qu’il s’agisse d’un exemple fictif, il fonctionne de manière très similaire dans le monde réel.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In fact, you can expect a server to be able to handle an order of magnitude more requests using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> than if it were dedicating a thread for each request it receives.</source>
          <target state="translated">En réalité, un serveur est capable de gérer un nombre bien plus important de demandes à l’aide de <ph id="ph1">`async`</ph> et <ph id="ph2">`await`</ph> que s’il dédiait un thread à chaque demande qu’il reçoit.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>What does this mean for client scenario?</source>
          <target state="translated">Qu’est-ce que cela signifie dans un scénario de client ?</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The biggest gain for using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> for a client app is an increase in responsiveness.</source>
          <target state="translated">Le plus gros avantage de l’utilisation de <ph id="ph1">`async`</ph> et <ph id="ph2">`await`</ph> pour une application cliente est l’augmentation de la réactivité.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph>.</source>
          <target state="translated">Même si vous pouvez améliorer la réactivité d’une application en gérant manuellement des threads de manière dynamique, c’est une opération coûteuse par rapport à la simple utilisation de <ph id="ph1">`async`</ph> et <ph id="ph2">`await`</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</source>
          <target state="translated">Dans le cas particulier d’un jeu mobile, il est essentiel d’affecter aussi peu que possible le thread d’interface utilisateur en ce qui concerne les E/S.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</source>
          <target state="translated">Plus important encore, parce que le travail utilisant des E/S ne se sert pratiquement pas du processeur, en dédiant un thread de processeur entier pour effectuer vaguement des tâches utiles, vous utilisez mal vos ressources.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with <ph id="ph1">`async`</ph> methods, and does not require extra work (such as calling a thread-safe delegate).</source>
          <target state="translated">Par ailleurs, la répartition du travail sur le thread d’interface utilisateur (par exemple, la mise à jour d’une interface utilisateur) est très simple avec des méthodes <ph id="ph1">`async`</ph> et n’engendre pas de travail supplémentaire (par exemple, l’appel d’un délégué thread-safe).</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Deeper Dive into Task and Task<ph id="ph1">&lt;T&gt;</ph> for a CPU-Bound Operation</source>
          <target state="translated">Approfondissement : Task et Task<ph id="ph1">&lt;T&gt;</ph> pour une opération utilisant le processeur</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>CPU-bound <ph id="ph1">`async`</ph> code is a bit different than I/O-bound <ph id="ph2">`async`</ph> code.</source>
          <target state="translated">Le code <ph id="ph1">`async`</ph> utilisant le processeur est un peu différent du code <ph id="ph2">`async`</ph> utilisant des E/S.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</source>
          <target state="translated">Comme le travail est effectué sur le processeur, il n’est pas possible de dédier un thread au calcul.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The use of <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</source>
          <target state="translated">L’utilisation de <ph id="ph1">`async`</ph> et <ph id="ph2">`await`</ph> est un moyen d’interagir avec un thread en arrière-plan et de faire en sorte que l’appelant de la méthode async reste réactif.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Note that this does not provide any protection for shared data.</source>
          <target state="translated">Notez que cela ne protège en rien les données partagées.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If you are using shared data, you will still need to apply an appropriate synchronization strategy.</source>
          <target state="translated">Si vous utilisez des données partagées, vous devez quand même appliquer une stratégie de synchronisation appropriée.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Here's a 10,000 foot view of a CPU-bound async call:</source>
          <target state="translated">Voici une vue générale d’un appel asynchrone utilisant le processeur :</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CalculateResult()`</ph> executes on the thread it was called on.</source>
          <target state="translated"><ph id="ph1">`CalculateResult()`</ph> s’exécute sur le thread sur lequel il a été appelé.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When it calls <ph id="ph1">`Task.Run`</ph>, it queues the expensive CPU-bound operation, <ph id="ph2">`DoExpensiveCalculation()`</ph>, on the thread pool and receives a <ph id="ph3">`Task&lt;int&gt;`</ph> handle.</source>
          <target state="translated">Quand il appelle <ph id="ph1">`Task.Run`</ph>, il place en file d’attente l’opération coûteuse qui utilise le processeur, <ph id="ph2">`DoExpensiveCalculation()`</ph>, sur le pool de threads et reçoit un handle <ph id="ph3">`Task&lt;int&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`DoExpensiveCalculation()`</ph> is eventually run concurrently on the next available thread, likely on another CPU core.</source>
          <target state="translated"><ph id="ph1">`DoExpensiveCalculation()`</ph> est finalement exécuté simultanément sur le prochain thread disponible, probablement sur un autre cœur d’UC.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>It's possible to do concurrent work while <ph id="ph1">`DoExpensiveCalculation()`</ph> is busy on another thread, because the thread which called <ph id="ph2">`CalculateResult()`</ph> is still executing.</source>
          <target state="translated">Il est possible d’effectuer des tâches simultanées quand <ph id="ph1">`DoExpensiveCalculation()`</ph> est occupé sur un autre thread, car le thread qui a appelé <ph id="ph2">`CalculateResult()`</ph> est encore en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Once <ph id="ph1">`await`</ph> is encountered, the execution of <ph id="ph2">`CalculateResult()`</ph> is yielded to its caller, allowing other work to be done with the current thread while <ph id="ph3">`DoExpensiveCalculation()`</ph> is churning out a result.</source>
          <target state="translated">Une fois que <ph id="ph1">`await`</ph> a été trouvé, l’exécution de <ph id="ph2">`CalculateResult()`</ph> est cédée à son appelant, ce qui permet d’effectuer d’autres tâches avec le thread actuel pendant que <ph id="ph3">`DoExpensiveCalculation()`</ph> produit un résultat.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Once it has finished, the result is queued up to run on the main thread.</source>
          <target state="translated">Une fois cette opération terminée, le résultat est placé en file d’attente pour s’exécuter sur le thread principal.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Eventually, the main thread will return to executing <ph id="ph1">`CalculateResult()`</ph>, at which point it will have the result of <ph id="ph2">`DoExpensiveCalculation()`</ph>.</source>
          <target state="translated">Finalement, le thread principal retourne à l’exécution de <ph id="ph1">`CalculateResult()`</ph>, à partir duquel il obtient le résultat de <ph id="ph2">`DoExpensiveCalculation()`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Why does async help here?</source>
          <target state="translated">Pourquoi async est-il utile ici ?</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> are the best practice managing CPU-bound work when you need responsiveness.</source>
          <target state="translated"><ph id="ph1">`async`</ph> et <ph id="ph2">`await`</ph> sont la meilleure approche pour gérer les travaux utilisant l’UC quand vous avez besoin de réactivité.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>There are multiple patterns for using async with CPU-bound work.</source>
          <target state="translated">Il existe plusieurs modèles d’utilisation d’async avec des tâches utilisant le processeur.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>It's important to note that there is a small cost to using async and it's not recommended for tight loops.</source>
          <target state="translated">Notez que l’utilisation d’async représente un coût, même s’il est faible, et qu’elle n’est donc pas recommandée pour les boucles serrées.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>It's up to you to determine how you write your code around this new capability.</source>
          <target state="translated">C’est à vous de déterminer la façon dont vous écrivez votre code autour de cette nouvelle fonctionnalité.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>