<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7d7f869b07d7cf00ffa69da117aa199d1b6e8f20</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\common-type-system.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f66d2394f5af4bc23f5a34be8d74d91b9969f4c7</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f03d101855314514e4afe7575f76c76990f1ab5e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Common type system in depth</source>
          <target state="translated">Approfondissement du système de type commun</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Common type system in depth</source>
          <target state="translated">Approfondissement du système de type commun</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Common type system in depth</source>
          <target state="translated">Approfondissement du système de type commun</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections that explore the common type system in depth:</source>
          <target state="translated">Cette rubrique contient les sections suivantes qui explorent le système de type commun de manière approfondie :</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types in .NET<ept id="p1">](#types-in-net)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types dans .NET<ept id="p1">](#types-in-net)</ept></target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type definitions<ept id="p1">](#type-definitions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Définitions de types<ept id="p1">](#type-definitions)</ept></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type members<ept id="p1">](#type-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Membres de type<ept id="p1">](#type-members)</ept></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Characteristics of type members<ept id="p1">](#characteristics-of-type-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Caractéristiques des membres de type<ept id="p1">](#characteristics-of-type-members)</ept></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Types in .NET</source>
          <target state="translated">Types dans .NET</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>All types in .NET are either value types or reference types.</source>
          <target state="translated">Tous les types dans .NET sont soit des types valeur, soit des types référence.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Value types are data types whose objects are represented by the object's actual value.</source>
          <target state="translated">Les types valeur sont des types de données dont les objets sont représentés par la valeur réelle de l'objet.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If an instance of a value type is assigned to a variable, that variable is given a fresh copy of the value.</source>
          <target state="translated">Si une instance d'un type valeur est assignée à une variable, cette variable reçoit une copie actualisée de la valeur.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Reference types are data types whose objects are represented by a reference (similar to a pointer) to the object's actual value.</source>
          <target state="translated">Les types référence sont des types de données dont les objets sont représentés par une référence (identique à un pointeur) à la valeur réelle de l'objet.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If a reference type is assigned to a variable, that variable references (points to) the original value.</source>
          <target state="translated">Si un type référence est assigné à une variable, celle-ci référence (ou pointe vers) la valeur d'origine.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>No copy is made.</source>
          <target state="translated">Aucune copie n'est effectuée.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The common type system in .NET supports the following five categories of types:</source>
          <target state="translated">Le système de type commun (CTS, Common Type System) dans .NET prend en charge les cinq catégories de types suivantes :</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Classes<ept id="p1">](#classes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Classes<ept id="p1">](#classes)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Structures<ept id="p1">](#structures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Structures<ept id="p1">](#structures)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enumerations<ept id="p1">](#enumerations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Énumérations<ept id="p1">](#enumerations)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates<ept id="p1">](#delegates)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Délégués<ept id="p1">](#delegates)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A class is a reference type that can be derived directly from another class and that is derived implicitly from <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</source>
          <target state="translated">Une classe est un type référence qui peut être dérivé directement d’une autre classe et qui est implicitement dérivé de <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The class defines the operations that an object (which is an instance of the class) can perform (methods, events, or properties) and the data that the object contains (fields).</source>
          <target state="translated">Une classe définit les opérations qu'un objet (qui est une instance de la classe) peut effectuer (méthodes, événements ou propriétés) et les données que l'objet contient (champs).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Although a class generally includes both definition and implementation (unlike interfaces, for example, which contain only definition without implementation), it can have one or more members that have no implementation.</source>
          <target state="translated">Bien qu'une classe inclue généralement la définition et l'implémentation (contrairement aux interfaces, par exemple, qui contiennent uniquement la définition sans l'implémentation), elle peut comporter un ou plusieurs membres dépourvus d'implémentation.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The following table describes some of the characteristics that a class may have.</source>
          <target state="translated">Le tableau suivant décrit certaines des caractéristiques qu'une classe peut avoir.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Each language that supports the runtime provides a way to indicate that a class or class member has one or more of these characteristics.</source>
          <target state="translated">Chaque langage prenant en charge le runtime fournit un moyen d'indiquer qu'une classe ou qu'un membre d'une classe a une ou plusieurs de ces caractéristiques.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>However, individual programming languages that target .NET may not make all these characteristics available.</source>
          <target state="translated">Cependant, il se peut que des langages de programmation individuels qui ciblent .NET ne mettent pas toutes ces caractéristiques à disposition.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Characteristic</source>
          <target state="translated">Caractéristique</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>sealed</source>
          <target state="translated">sealed</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Specifies that another class cannot be derived from this type.</source>
          <target state="translated">Spécifie qu'une autre classe ne peut pas être dérivée de ce type.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>implements</source>
          <target state="translated">implémente</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Indicates that the class uses one or more interfaces by providing implementations of interface members.</source>
          <target state="translated">Indique que la classe utilise une ou plusieurs interfaces en fournissant des implémentations des membres d'interface.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>abstract</source>
          <target state="translated">abstract</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Indicates that the class cannot be instantiated.</source>
          <target state="translated">Indique que la classe ne peut pas être instanciée.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>To use it, you must derive another class from it.</source>
          <target state="translated">Pour l'utiliser, vous devez dériver une autre classe de celle-ci.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>inherits</source>
          <target state="translated">hérite</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Indicates that instances of the class can be used anywhere the base class is specified.</source>
          <target state="translated">Indique que des instances de la classe peuvent être utilisées partout où la classe de base est spécifiée.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A derived class that inherits from a base class can use the implementation of any public members provided by the base class, or the derived class can override the implementation of the public members with its own implementation.</source>
          <target state="translated">Une classe dérivée qui hérite d'une classe de base peut utiliser l'implémentation de n'importe quel membre public fourni par la classe de base, ou la classe dérivée peut remplacer l'implémentation des membres publics par sa propre implémentation.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>exported or not exported</source>
          <target state="translated">exported ou not exported</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Indicates whether a class is visible outside the assembly in which it is defined.</source>
          <target state="translated">Indique si une classe est visible à l'extérieur de l'assembly dans lequel elle est définie.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This characteristic applies only to top-level classes and not to nested classes.</source>
          <target state="translated">Cette caractéristique s'applique uniquement aux classes de niveau supérieur, et pas aux classes imbriquées.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A class can also be nested in a parent class or structure.</source>
          <target state="translated">Une classe peut également être imbriquée dans une structure ou une classe parente.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Nested classes also have member characteristics.</source>
          <target state="translated">Les classes imbriquées ont également des caractéristiques de membre.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Nested types<ept id="p1">](#nested-types)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Types imbriqués<ept id="p1">](#nested-types)</ept>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Class members that have no implementation are abstract members.</source>
          <target state="translated">Les membres de classe sans implémentation sont des membres abstraits.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A class that has one or more abstract members is itself abstract; new instances of it cannot be created.</source>
          <target state="translated">Une classe qui possède un ou plusieurs membres abstraits est elle-même abstraite ; il n'est pas possible d'en créer de nouvelles instances.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Some languages that target the runtime let you mark a class as abstract even if none of its members are abstract.</source>
          <target state="translated">Certains langages qui ciblent le runtime vous permettent de marquer une classe comme abstraite même si aucun de ses membres n'est abstrait.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can use an abstract class when you want to encapsulate a basic set of functionality that derived classes can inherit or override when appropriate.</source>
          <target state="translated">Vous pouvez utiliser une classe abstraite lorsque vous voulez encapsuler un ensemble de fonctionnalités de base dont des classes dérivées peuvent hériter ou qu'elles peuvent substituer lorsque cela est approprié.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Classes that are not abstract are referred to as concrete classes.</source>
          <target state="translated">Les classes qui ne sont pas abstraites sont qualifiées de classes concrètes.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A class can implement any number of interfaces, but it can inherit from only one base class in addition to <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>, from which all classes inherit implicitly.</source>
          <target state="translated">Une classe peut implémenter n’importe quel nombre d’interfaces, mais elle ne peut hériter que d’une seule classe de base en plus de la classe <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>, de laquelle toutes les classes héritent implicitement.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>All classes must have at least one constructor, which initializes new instances of the class.</source>
          <target state="translated">Toutes les classes doivent avoir au moins un constructeur qui initialise de nouvelles instances de la classe.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you do not explicitly define a constructor, most compilers will automatically provide a default (parameterless) constructor.</source>
          <target state="translated">Si vous ne définissez pas explicitement un constructeur, la plupart des compilateurs fourniront automatiquement un constructeur par défaut (sans paramètre).</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Structures</source>
          <target state="translated">Structures</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>A structure is a value type that derives implicitly from <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, which in turn is derived from <bpt id="p2">[</bpt>System.Object<ept id="p2">](xref:System.Object)</ept>.</source>
          <target state="translated">Une structure est un type valeur qui dérive implicitement de <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept> qui, à son tour, est dérivé de <bpt id="p2">[</bpt>System.Object<ept id="p2">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A structure is very useful for representing values whose memory requirements are small, and for passing values as by-value parameters to methods that have strongly typed parameters.</source>
          <target state="translated">Une structure est très utile pour représenter des valeurs dont les besoins en ressources mémoire sont faibles, ainsi que pour passer des valeurs en tant que paramètres par valeur à des méthodes qui ont des paramètres fortement typés.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In .NET, all primitive data types (<bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>DateTime<ept id="p4">](xref:System.DateTime)</ept>, <bpt id="p5">[</bpt>Decimal<ept id="p5">](xref:System.Decimal)</ept>, <bpt id="p6">[</bpt>Double<ept id="p6">](xref:System.Double)</ept>, <bpt id="p7">[</bpt>Int16<ept id="p7">](xref:System.Int16)</ept>, <bpt id="p8">[</bpt>Int32<ept id="p8">](xref:System.Int32)</ept>, <bpt id="p9">[</bpt>Int64<ept id="p9">](xref:System.Int64)</ept>, <bpt id="p10">[</bpt>SByte<ept id="p10">](xref:System.SByte)</ept>, <bpt id="p11">[</bpt>Single<ept id="p11">](xref:System.Single)</ept>, <bpt id="p12">[</bpt>UInt16<ept id="p12">](xref:System.UInt16)</ept>, <bpt id="p13">[</bpt>UInt32<ept id="p13">](xref:System.UInt32)</ept>, and <bpt id="p14">[</bpt>UInt64<ept id="p14">](xref:System.UInt64)</ept>) are defined as structures.</source>
          <target state="translated">Dans .NET, tous les types de données primitifs (<bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>DateTime<ept id="p4">](xref:System.DateTime)</ept>, <bpt id="p5">[</bpt>Decimal<ept id="p5">](xref:System.Decimal)</ept>, <bpt id="p6">[</bpt>Double<ept id="p6">](xref:System.Double)</ept>, <bpt id="p7">[</bpt>Int16<ept id="p7">](xref:System.Int16)</ept>, <bpt id="p8">[</bpt>Int32<ept id="p8">](xref:System.Int32)</ept>, <bpt id="p9">[</bpt>Int64<ept id="p9">](xref:System.Int64)</ept>, <bpt id="p10">[</bpt>SByte<ept id="p10">](xref:System.SByte)</ept>, <bpt id="p11">[</bpt>Single<ept id="p11">](xref:System.Single)</ept>, <bpt id="p12">[</bpt>UInt16<ept id="p12">](xref:System.UInt16)</ept>, <bpt id="p13">[</bpt>UInt32<ept id="p13">](xref:System.UInt32)</ept> et <bpt id="p14">[</bpt>UInt64<ept id="p14">](xref:System.UInt64)</ept>) sont définis comme structures.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Like classes, structures define both data (the fields of the structure) and the operations that can be performed on that data (the methods of the structure).</source>
          <target state="translated">Comme les classes, les structures définissent à la fois les données (les champs de la structure) et les opérations qui peuvent être exécutées sur ces données (les méthodes de la structure).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This means that you can call methods on structures, including the virtual methods defined on the <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> and <bpt id="p2">[</bpt>System.ValueType<ept id="p2">](xref:System.ValueType)</ept> classes, and any methods defined on the value type itself.</source>
          <target state="translated">Cela signifie que vous pouvez appeler des méthodes sur des structures, notamment les méthodes virtuelles définies sur les classes <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> et <bpt id="p2">[</bpt>System.ValueType<ept id="p2">](xref:System.ValueType)</ept>, ainsi que toute méthode définie sur le type valeur lui-même.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In other words, structures can have fields, properties, and events, as well as static and nonstatic methods.</source>
          <target state="translated">En d'autres termes, les structures peuvent comporter des champs, des propriétés et des événements, ainsi que des méthodes statiques et non statiques.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You can create instances of structures, pass them as parameters, store them as local variables, or store them in a field of another value type or reference type.</source>
          <target state="translated">Vous pouvez créer des instances de structures, les passer en tant que paramètres, les stocker en tant que variables locales ou les stocker dans un champ d'un autre type valeur ou type référence.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Structures can also implement interfaces.</source>
          <target state="translated">Les structures peuvent aussi implémenter des interfaces.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Value types also differ from classes in several respects.</source>
          <target state="translated">Les types valeur diffèrent également des classes par plusieurs aspects.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>First, although they implicitly inherit from <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, they cannot directly inherit from any type.</source>
          <target state="translated">Tout d’abord, bien qu’ils héritent implicitement de <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, ils ne peuvent pas hériter directement de n’importe quel type.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Similarly, all value types are sealed, which means that no other type can be derived from them.</source>
          <target state="translated">De même, tous les types valeur sont sealed, ce qui signifie qu'aucun autre type ne peut en être dérivé.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>They also do not require constructors.</source>
          <target state="translated">De plus, ils ne nécessitent pas de constructeurs.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For each value type, the common language runtime supplies a corresponding boxed type, which is a class that has the same state and behavior as the value type.</source>
          <target state="translated">Pour chaque type valeur, le Common Language Runtime fournit un type boxed correspondant qui est une classe ayant le même état et le même comportement que le type valeur.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>An instance of a value type is boxed when it is passed to a method that accepts a parameter of type <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</source>
          <target state="translated">Une instance d’un type valeur est boxed lorsqu’elle est passée à une méthode qui accepte un paramètre de type <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>It is unboxed (that is, converted from an instance of a class back to an instance of a value type) when control returns from a method call that accepts a value type as a by-reference parameter.</source>
          <target state="translated">Elle est unboxed (c'est-à-dire reconvertie d'une instance d'une classe en instance d'un type valeur) lorsque le contrôle retourne d'un appel de méthode qui accepte un type valeur comme paramètre par référence.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Some languages require that you use special syntax when the boxed type is required; others automatically use the boxed type when it is needed.</source>
          <target state="translated">Certains langages imposent l'utilisation d'une syntaxe spéciale lorsque le type boxed est requis ; d'autres utilisent automatiquement le type boxed lorsqu'il est nécessaire.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>When you define a value type, you are defining both the boxed and the unboxed type.</source>
          <target state="translated">Lorsque vous définissez un type valeur, vous définissez le type boxed et le type unboxed.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Énumérations</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>An enumeration (enum) is a value type that inherits directly from <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept> and that supplies alternate names for the values of an underlying primitive type.</source>
          <target state="translated">Une énumération (enum) est un type valeur qui hérite directement de <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept> et qui fournit des noms de remplacement pour les valeurs d’un type primitif sous-jacent.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>An enumeration type has a name, an underlying type that must be one of the built-in signed or unsigned integer types (such as <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>, or <bpt id="p3">[</bpt>UInt64<ept id="p3">](xref:System.UInt64)</ept>), and a set of fields.</source>
          <target state="translated">Un type énumération a un nom, un type sous-jacent qui doit être l’un des types d’entiers signés ou non signés intégrés (tels que <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept> ou <bpt id="p3">[</bpt>UInt64<ept id="p3">](xref:System.UInt64)</ept>) et un ensemble de champs.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The fields are static literal fields, each of which represents a constant.</source>
          <target state="translated">Les champs sont des champs statiques de type Literal, chacun représentant une constante.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The same value can be assigned to multiple fields.</source>
          <target state="translated">La même valeur peut être assignée à plusieurs champs.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>When this occurs, you must mark one of the values as the primary enumeration value for reflection and string conversion.</source>
          <target state="translated">Dans ce cas, vous devez marquer l'une des valeurs comme valeur d'énumération primaire pour la réflexion et la conversion de chaînes.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You can assign a value of the underlying type to an enumeration and vice versa (no cast is required by the runtime).</source>
          <target state="translated">Vous pouvez assigner une valeur du type sous-jacent à une énumération et vice-versa (aucun cast n'est requis par le runtime).</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You can create an instance of an enumeration and call the methods of <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept>, as well as any methods defined on the enumeration's underlying type.</source>
          <target state="translated">Vous pouvez créer une instance d’une énumération et appeler les méthodes de <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept>, ainsi que toute méthode définie sur le type sous-jacent de l’énumération.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>However, some languages might not let you pass an enumeration as a parameter when an instance of the underlying type is required (or vice versa).</source>
          <target state="translated">Cependant, il est possible que certains langages ne vous permettent pas de passer une énumération en tant que paramètre lorsqu'une instance du type sous-jacent est requise (ou vice versa).</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following additional restrictions apply to enumerations:</source>
          <target state="translated">Les restrictions supplémentaires suivantes s'appliquent aux énumérations :</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>They cannot define their own methods.</source>
          <target state="translated">Elles ne peuvent pas définir leurs propres méthodes.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>They cannot implement interfaces.</source>
          <target state="translated">Elles ne peuvent pas implémenter d'interfaces.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>They cannot define properties or events.</source>
          <target state="translated">Elles ne peuvent pas définir des propriétés ou des événements.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>They cannot be generic, unless they are generic only because they are nested within a generic type.</source>
          <target state="translated">Elles ne peuvent pas être génériques, à moins qu'elles le soient uniquement parce qu'elles sont imbriquées dans un type générique.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>That is, an enumeration cannot have type parameters of its own.</source>
          <target state="translated">Par conséquent, une énumération ne peut pas avoir de paramètres de type propres.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Nested types (including enumerations) created with C# include the type parameters of all enclosing generic types, and are therefore generic even if they do not have type parameters of their own.</source>
          <target state="translated">Les types imbriqués (y compris les énumérations) créés avec C# incluent les paramètres de type de tous les types génériques englobants, et sont donc génériques, même s’ils n’ont pas de paramètres de type propres.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Type.MakeGenericType<ept id="p1">](xref:System.Type.MakeGenericType(System.Type[]))</ept> reference topic.</source>
          <target state="translated">Pour plus d’informations, consultez la rubrique de référence <bpt id="p1">[</bpt>Type.MakeGenericType<ept id="p1">](xref:System.Type.MakeGenericType(System.Type[]))</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> attribute denotes a special kind of enumeration called a bit field.</source>
          <target state="translated">L’attribut <bpt id="p1">[</bpt>FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> désigne un genre particulier d’énumération appelé « champ de bits ».</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The runtime itself does not distinguish between traditional enumerations and bit fields, but your language might do so.</source>
          <target state="translated">Le runtime lui-même ne fait pas de distinction entre les énumérations traditionnelles et les champs de bits, mais votre langage pourrait le faire.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>When this distinction is made, bitwise operators can be used on bit fields, but not on enumerations, to generate unnamed values.</source>
          <target state="translated">Lorsque cette distinction est effectuée, les opérateurs binaires peuvent être utilisés sur les champs de bits, mais pas sur les énumérations, pour générer des valeurs sans nom.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Enumerations are generally used for lists of unique elements, such as days of the week, country or region names, and so on.</source>
          <target state="translated">Les énumérations sont généralement utilisées pour des listes d'éléments uniques, tels que les jours de la semaine, des noms de pays ou de région, etc.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Bit fields are generally used for lists of qualities or quantities that might occur in combination, such as <ph id="ph1">`Red And Big And Fast`</ph>.</source>
          <target state="translated">Les champs de bits sont généralement utilisés pour des listes de qualités ou de quantités pouvant être utilisées en combinaison, telle que <ph id="ph1">`Red And Big And Fast`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following example shows how to use both bit fields and traditional enumerations.</source>
          <target state="translated">L'exemple suivant montre comment utiliser les champs de bits et les énumérations traditionnelles.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>An interface defines a contract that specifies a "can do" relationship or a "has a" relationship.</source>
          <target state="translated">Une interface définit un contrat qui spécifie une relation « peut faire » ou « a un ».</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Interfaces are often used to implement functionality, such as comparing and sorting (the <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> and <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept> interfaces), testing for equality (the <bpt id="p3">[</bpt>IEquatable<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p3">](xref:System.IEquatable%601)</ept> interface), or enumerating items in a collection (the <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept> and <bpt id="p5">[</bpt>IEnumerable<ph id="ph5">&amp;lt;</ph>T<ph id="ph6">&amp;gt;</ph><ept id="p5">](xref:System.Collections.Generic.IEnumerable%601)</ept> interfaces).</source>
          <target state="translated">Les interfaces sont souvent utilisées pour implémenter des fonctionnalités, comme la comparaison et le tri (interfaces <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> et <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept>), le test de l’égalité (interface <bpt id="p3">[</bpt>IEquatable<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p3">](xref:System.IEquatable%601)</ept>) ou l’énumération d’éléments dans une collection (interfaces <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept> et <bpt id="p5">[</bpt>IEnumerable<ph id="ph5">&amp;lt;</ph>T<ph id="ph6">&amp;gt;</ph><ept id="p5">](xref:System.Collections.Generic.IEnumerable%601)</ept>).</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Interfaces can have properties, methods, and events, all of which are abstract members; that is, although the interface defines the members and their signatures, it leaves it to the type that implements the interface to define the functionality of each interface member.</source>
          <target state="translated">Les interfaces peuvent avoir des propriétés, des méthodes et des événements qui sont tous des membres abstraits, c'est-à-dire que bien que l'interface définisse les membres et leurs signatures, elle laisse le type qui implémente l'interface définir la fonctionnalité de chaque membre d'interface.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This means that any class or structure that implements an interface must supply definitions for the abstract members declared in the interface.</source>
          <target state="translated">En d'autres termes, toute classe ou structure qui implémente une interface doit fournir des définitions pour les membres abstraits déclarés dans l'interface.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>An interface can require any implementing class or structure to also implement one or more other interfaces.</source>
          <target state="translated">Une interface peut imposer à une classe ou à une structure d'implémentation d'implémenter une ou plusieurs autres interfaces.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to interfaces:</source>
          <target state="translated">Les restrictions suivantes s'appliquent aux interfaces :</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>An interface can be declared with any accessibility, but interface members must all have public accessibility.</source>
          <target state="translated">Une interface peut être déclarée avec n'importe quelle accessibilité, mais les membres d'interface doivent tous avoir une accessibilité publique.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Interfaces cannot define constructors.</source>
          <target state="translated">Les interfaces ne peuvent pas définir de constructeurs.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Interfaces cannot define fields.</source>
          <target state="translated">Les interfaces ne peuvent pas définir de champs.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Interfaces can define only instance members.</source>
          <target state="translated">Les interfaces peuvent définir uniquement des membres d'instance.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>They cannot define static members.</source>
          <target state="translated">Elles ne peuvent pas définir des membres statiques.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Each language must provide rules for mapping an implementation to the interface that requires the member, because more than one interface can declare a member with the same signature, and these members can have separate implementations.</source>
          <target state="translated">Chaque langage doit fournir des règles de mappage d'une implémentation à l'interface qui nécessite le membre, car plusieurs interfaces peuvent déclarer un membre avec la même signature, et ces membres peuvent avoir des implémentations séparées.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Delegates</source>
          <target state="translated">Délégués</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Delegates are reference types that serve a purpose similar to that of function pointers in C++.</source>
          <target state="translated">Les délégués sont des types référence qui jouent un rôle similaire à celui des pointeurs fonction en C++.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>They are used for event handlers and callback functions in .NET.</source>
          <target state="translated">Ils sont utilisés pour les gestionnaires d’événements et les fonctions de rappel dans .NET.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Unlike function pointers, delegates are secure, verifiable, and type safe.</source>
          <target state="translated">Contrairement aux pointeurs fonction, les délégués sont de type sécurisé, sûr et vérifiable.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>A delegate type can represent any instance method or static method that has a compatible signature.</source>
          <target state="translated">Un type délégué peut représenter n'importe quelle méthode d'instance ou méthode statique ayant une signature compatible.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">Le paramètre d'un délégué est compatible avec le paramètre correspondant d'une méthode si le type de paramètre du délégué est plus restrictif que le type de paramètre de la méthode. En effet, cela garantit qu'un argument transmis au délégué peut être transmis à la méthode en toute sécurité.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">De même, le type de retour d’un délégué est compatible avec le type de retour d’une méthode si le type de retour de la méthode est plus restrictif que le type de retour du délégué, car cela garantit que le cast de la valeur de retour de la méthode peut être effectué sans risque au type de retour du délégué.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For example, a delegate that has a parameter of type <bpt id="p1">[</bpt>IEnumerable<ept id="p1">](xref:System.Collections.IEnumerable)</ept> and a return type of <bpt id="p2">[</bpt>Object<ept id="p2">](xref:System.Object)</ept> can represent a method that has a parameter of type <bpt id="p3">[</bpt>Object<ept id="p3">](xref:System.Object)</ept> and a return value of type <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept>.</source>
          <target state="translated">Par exemple, un délégué ayant un paramètre de type <bpt id="p1">[</bpt>IEnumerable<ept id="p1">](xref:System.Collections.IEnumerable)</ept> et un type de retour <bpt id="p2">[</bpt>Object<ept id="p2">](xref:System.Object)</ept> peut représenter une méthode ayant un paramètre de type <bpt id="p3">[</bpt>Object<ept id="p3">](xref:System.Object)</ept> et une valeur de retour de type <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>A delegate is said to be bound to the method it represents.</source>
          <target state="translated">On dit qu'un délégué est lié à la méthode qu'il représente.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In addition to being bound to the method, a delegate can be bound to an object.</source>
          <target state="translated">Outre cette liaison, un délégué peut être lié à un objet.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The object represents the first parameter of the method, and is passed to the method every time the delegate is invoked.</source>
          <target state="translated">L'objet représente le premier paramètre de la méthode, et est passé à cette dernière chaque fois que le délégué est appelé.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If the method is an instance method, the bound object is passed as the implicit <ph id="ph1">`this`</ph> parameter (<ph id="ph2">`Me`</ph> in Visual Basic); if the method is static, the object is passed as the first formal parameter of the method, and the delegate signature must match the remaining parameters.</source>
          <target state="translated">Si la méthode est une méthode d'instance, l'objet dépendant est passé en tant que paramètre <ph id="ph1">`this`</ph> implicite (<ph id="ph2">`Me`</ph> en Visual Basic) ; si la méthode est statique, l'objet est passé en tant que premier paramètre formel de la méthode, et la signature du délégué doit correspondre aux paramètres restants.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>All delegates inherit from <bpt id="p1">[</bpt>System.MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, which inherits from <bpt id="p2">[</bpt>System.Delegate<ept id="p2">](xref:System.Delegate)</ept>.</source>
          <target state="translated">Tous les délégués héritent de <bpt id="p1">[</bpt>System.MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, qui hérite de <bpt id="p2">[</bpt>System.Delegate<ept id="p2">](xref:System.Delegate)</ept>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The C# and Visual Basic languages don't allow inheritance from these types.</source>
          <target state="translated">Les langages C# et Visual Basic n’autorisent pas l’héritage à partir de ces types.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Instead, they provide keywords for declaring delegates.</source>
          <target state="translated">Ils fournissent à la place des mots clés pour la déclaration des délégués.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Because delegates inherit from <bpt id="p1">[</bpt>MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, a delegate has an invocation list, which is a list of methods that the delegate represents and that are executed when the delegate is invoked.</source>
          <target state="translated">Étant donné que les délégués héritent de <bpt id="p1">[</bpt>MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, un délégué dispose d’une liste d’appel, qui est la liste des méthodes représentées par le délégué et exécutées lorsque celui-ci est appelé.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>All methods in the list receive the arguments supplied when the delegate is invoked.</source>
          <target state="translated">Toutes les méthodes de la liste reçoivent les arguments fournis lorsque le délégué est appelé.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The return value is not defined for a delegate that has more than one method in its invocation list, even if the delegate has a return type.</source>
          <target state="translated">La valeur de retour n'est pas définie pour un délégué dont la liste d'appel comprend plusieurs méthodes, même si le délégué dispose d'un type de retour.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>In many cases, such as with callback methods, a delegate represents only one method, and the only actions you have to take are creating the delegate and invoking it.</source>
          <target state="translated">Dans la plupart des cas, comme avec les méthodes de rappel, un délégué représente une seule méthode, et les mesures que vous devez prendre se limitent à la création et l'appel du délégué.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>For delegates that represent multiple methods, .NET provides methods of the <bpt id="p1">[</bpt>Delegate<ept id="p1">](xref:System.Delegate)</ept> and <bpt id="p2">[</bpt>MulticastDelegate<ept id="p2">](xref:System.MulticastDelegate)</ept> delegate classes to support operations such as adding a method to a delegate's invocation list (the <bpt id="p3">[</bpt>Delegate.Combine<ept id="p3">](xref:System.Delegate.Combine(System.Delegate,System.Delegate))</ept> method), removing a method (the <bpt id="p4">[</bpt>Delegate.Remove<ept id="p4">](xref:System.Delegate.Remove(System.Delegate,System.Delegate))</ept> method), and getting the invocation list (the <bpt id="p5">[</bpt>Delegate.GetInvocationList<ept id="p5">](xref:System.Delegate.GetInvocationList)</ept> method).</source>
          <target state="translated">Pour les délégués qui représentent plusieurs méthodes, .NET fournit les méthodes des classes de délégué <bpt id="p1">[</bpt>Delegate<ept id="p1">](xref:System.Delegate)</ept> et <bpt id="p2">[</bpt>MulticastDelegate<ept id="p2">](xref:System.MulticastDelegate)</ept> pour prendre en charge les opérations telles que l’ajout d’une méthode à la liste d’appel d’un délégué (méthode <bpt id="p3">[</bpt>Delegate.Combine<ept id="p3">](xref:System.Delegate.Combine(System.Delegate,System.Delegate))</ept>), la suppression d’une méthode (méthode <bpt id="p4">[</bpt>Delegate.Remove<ept id="p4">](xref:System.Delegate.Remove(System.Delegate,System.Delegate))</ept>) et l’obtention de la liste d’appel (méthode <bpt id="p5">[</bpt>Delegate.GetInvocationList<ept id="p5">](xref:System.Delegate.GetInvocationList)</ept>).</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>It is not necessary to use these methods for event-handler delegates in C# or Visual Basic, because these languages provide syntax for adding and removing event handlers.</source>
          <target state="translated">Il n’est pas nécessaire d’utiliser ces méthodes pour les délégués de gestionnaires d’événements en C# ou Visual Basic, car ces langages fournissent une syntaxe pour l’ajout et la suppression des gestionnaires d’événements.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Type definitions</source>
          <target state="translated">Définitions de type</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>A type definition includes the following:</source>
          <target state="translated">Une définition de type inclut les éléments suivants :</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Any attributes defined on the type.</source>
          <target state="translated">les attributs définis sur le type ;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The type's accessibility (visibility).</source>
          <target state="translated">L'accessibilité du type (visibilité).</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The type's name.</source>
          <target state="translated">le nom du type ;</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The type's base type.</source>
          <target state="translated">le type de base du type ;</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Any interfaces implemented by the type.</source>
          <target state="translated">les interfaces implémentées par le type ;</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Definitions for each of the type's members.</source>
          <target state="translated">les définitions de chacun des membres du type.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributs</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Attributes provide additional user-defined metadata.</source>
          <target state="translated">Les attributs fournissent des métadonnées définies par l'utilisateur supplémentaires.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Most commonly, they are used to store additional information about a type in its assembly, or to modify the behavior of a type member in either the design-time or run-time environment.</source>
          <target state="translated">La plupart du temps, ils sont utilisés pour stocker les informations supplémentaires relatives à un type de l’assembly, ou pour modifier le comportement d’un membre de type dans l’environnement au moment du design ou dans l’environnement d’exécution.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Attributes are themselves classes that inherit from <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept>.</source>
          <target state="translated">Les attributs sont eux-mêmes des classes qui héritent de <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Languages that support the use of attributes each have their own syntax for applying attributes to a language element.</source>
          <target state="translated">Les langages qui prennent en charge l'utilisation d'attributs ont chacun leur propre syntaxe pour l'application d'attributs à un élément du langage.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Attributes can be applied to almost any language element; the specific elements to which an attribute can be applied are defined by the <bpt id="p1">[</bpt>AttributeUsageAttribute<ept id="p1">](xref:System.AttributeUsageAttribute)</ept> that is applied to that attribute class.</source>
          <target state="translated">Les attributs peuvent être appliqués à presque n’importe quel élément de langage ; les éléments spécifiques auxquels un attribut peut être appliqué sont définis par l’attribut <bpt id="p1">[</bpt>AttributeUsageAttribute<ept id="p1">](xref:System.AttributeUsageAttribute)</ept> qui est appliqué à cette classe d’attributs.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Type accessibility</source>
          <target state="translated">Accessibilité des types</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>All types have a modifier that governs their accessibility from other types.</source>
          <target state="translated">Tous les types ont un modificateur qui régit leur accessibilité à partir d'autres types.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following table describes the type accessibilities supported by the runtime.</source>
          <target state="translated">Le tableau suivant décrit les accessibilités de type prises en charge par le runtime.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Accessibilité</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>public</source>
          <target state="translated">public</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The type is accessible by all assemblies.</source>
          <target state="translated">Le type est accessible par tous les assemblys.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>assembly</source>
          <target state="translated">assembly</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The type is accessible only from within its assembly.</source>
          <target state="translated">Le type est accessible uniquement à partir de cet assembly.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The accessibility of a nested type depends on its accessibility domain, which is determined by both the declared accessibility of the member and the accessibility domain of the immediately containing type.</source>
          <target state="translated">L'accessibilité d'un type imbriqué dépend de son domaine d'accessibilité, qui est déterminé par l'accessibilité déclarée du membre et le domaine d'accessibilité du type conteneur immédiat.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>However, the accessibility domain of a nested type cannot exceed that of the containing type.</source>
          <target state="translated">Toutefois, le domaine d'accessibilité d'un type imbriqué ne peut pas dépasser celui du type conteneur.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The accessibility domain of a nested member <ph id="ph1">`M`</ph> declared in a type <ph id="ph2">`T`</ph>within a program <ph id="ph3">`P`</ph> is defined as follows (noting that <ph id="ph4">`M`</ph> might itself be a type):</source>
          <target state="translated">Le domaine d’accessibilité d’un membre imbriqué <ph id="ph1">`M`</ph> déclaré dans un type <ph id="ph2">`T`</ph> à l’intérieur d’un programme <ph id="ph3">`P`</ph> est défini de la manière suivante (en notant que <ph id="ph4">`M`</ph> pourrait lui-même être un type) :</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`public`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the accessibility domain of <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Si l'accessibilité déclarée de <ph id="ph1">`M`</ph> est <ph id="ph2">`public`</ph>, le domaine d'accessibilité de <ph id="ph3">`M`</ph> correspond à celui de <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`protected internal`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the intersection of the accessibility domain of <ph id="ph4">`T`</ph> with the program text of <ph id="ph5">`P`</ph> and the program text of any type derived from <ph id="ph6">`T`</ph> declared outside <ph id="ph7">`P`</ph>.</source>
          <target state="translated">Si l'accessibilité déclarée de <ph id="ph1">`M`</ph> est <ph id="ph2">`protected internal`</ph>, le domaine d'accessibilité de <ph id="ph3">`M`</ph> correspond à l'intersection du domaine d'accessibilité de <ph id="ph4">`T`</ph> avec le texte de programme de <ph id="ph5">`P`</ph> et le texte de programme de n'importe quel type dérivé de <ph id="ph6">`T`</ph> déclaré en dehors de <ph id="ph7">`P`</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`protected`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the intersection of the accessibility domain of <ph id="ph4">`T`</ph> with the program text of <ph id="ph5">`T`</ph> and any type derived from <ph id="ph6">`T`</ph>.</source>
          <target state="translated">Si l'accessibilité déclarée de <ph id="ph1">`M`</ph> est <ph id="ph2">`protected`</ph>, le domaine d'accessibilité de <ph id="ph3">`M`</ph> correspond à l'intersection du domaine d'accessibilité de <ph id="ph4">`T`</ph> avec le texte de programme de <ph id="ph5">`T`</ph> et n'importe quel type dérivé de <ph id="ph6">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`internal`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the intersection of the accessibility domain of <ph id="ph4">`T`</ph> with the program text of<ph id="ph5">`P`</ph>.</source>
          <target state="translated">Si l’accessibilité déclarée de <ph id="ph1">`M`</ph> est <ph id="ph2">`internal`</ph>, le domaine d’accessibilité de <ph id="ph3">`M`</ph> correspond à l’intersection du domaine d’accessibilité de <ph id="ph4">`T`</ph> avec le texte de programme de <ph id="ph5">`P`</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`private`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the program text of <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Si l'accessibilité déclarée de <ph id="ph1">`M`</ph> est <ph id="ph2">`private`</ph>, le domaine d'accessibilité de <ph id="ph3">`M`</ph> correspond au texte de programme de <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Type names</source>
          <target state="translated">Noms de types</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The common type system imposes only two restrictions on names:</source>
          <target state="translated">Le système de type commun (CTS, Common Type System) impose uniquement deux restrictions sur les noms :</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>All names are encoded as strings of Unicode (16-bit) characters.</source>
          <target state="translated">Tous les noms sont encodés comme des chaînes de caractères Unicode (16 bits).</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Names are not permitted to have an embedded (16-bit) value of 0x0000.</source>
          <target state="translated">Les noms ne peuvent pas incorporer la valeur (16 bits) 0x0000.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>However, most languages impose additional restrictions on type names.</source>
          <target state="translated">Toutefois, la plupart des langages imposent des restrictions supplémentaires sur les noms de types.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>All comparisons are done on a byte-by-byte basis, and are therefore case-sensitive and locale-independent.</source>
          <target state="translated">Toutes les comparaisons sont effectuées octet par octet ; elles respectent donc la casse et sont indépendantes des paramètres régionaux.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Although a type might reference types from other modules and assemblies, a type must be fully defined within one .NET module.</source>
          <target state="translated">Bien qu’un type puisse référencer des types d’autres modules et assemblys, il doit être entièrement défini à l’intérieur d’un seul module .NET.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>(Depending on compiler support, however, it can be divided into multiple source code files.) Type names need be unique only within a namespace.</source>
          <target state="translated">(Cependant, en fonction de la prise en charge du compilateur, il peut être divisé en plusieurs fichiers de code source.) Les noms de types doivent être uniques seulement à l'intérieur d'un espace de noms.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>To fully identify a type, the type name must be qualified by the namespace that contains the implementation of the type.</source>
          <target state="translated">Pour identifier complètement un type, le nom du type doit être qualifié par l'espace de noms qui contient l'implémentation du type.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Base types and interfaces</source>
          <target state="translated">Types de base et interfaces</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>A type can inherit values and behaviors from another type.</source>
          <target state="translated">Un type peut hériter des valeurs et des comportements d'un autre type.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The common type system does not allow types to inherit from more than one base type.</source>
          <target state="translated">Le système de type commun (CTS, Common Type System) ne permet pas à des types d'hériter de plusieurs types de base.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>A type can implement any number of interfaces.</source>
          <target state="translated">Un type peut implémenter n'importe quel nombre d'interfaces.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>To implement an interface, a type must implement all the virtual members of that interface.</source>
          <target state="translated">Pour implémenter une interface, un type doit implémenter tous les membres virtuels de cette interface.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>A virtual method can be implemented by a derived type and can be invoked either statically or dynamically.</source>
          <target state="translated">Une méthode virtuelle peut être implémentée par un type dérivé et peut être appelée de manière statique ou dynamique.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Type members</source>
          <target state="translated">Membres de type</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The runtime enables you to define members of your type, which specifies the behavior and state of a type.</source>
          <target state="translated">Le runtime vous permet de définir les membres de votre type, ce qui spécifie le comportement et l'état d'un type.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Type members include the following:</source>
          <target state="translated">Les membres de type incluent les éléments suivants :</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Fields<ept id="p1">](#fields)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Champs<ept id="p1">](#fields)</ept></target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Propriétés<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Methods<ept id="p1">](#methods)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Méthodes<ept id="p1">](#methods)</ept></target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Constructors<ept id="p1">](#constructors)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Constructeurs<ept id="p1">](#constructors)</ept></target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Événements<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nested types<ept id="p1">](#nested-types)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types imbriqués<ept id="p1">](#nested-types)</ept></target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Champs</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>A field describes and contains part of the type's state.</source>
          <target state="translated">Un champ décrit et contient une partie de l'état du type.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Fields can be of any type supported by the runtime.</source>
          <target state="translated">Les champs peuvent correspondre à n'importe quel type pris en charge par le runtime.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Most commonly, fields are either <ph id="ph1">`private`</ph> or <ph id="ph2">`protected`</ph>, so that they are accessible only from within the class or from a derived class.</source>
          <target state="translated">La plupart du temps, les champs sont soit <ph id="ph1">`private`</ph>, soit <ph id="ph2">`protected`</ph>, de sorte qu'ils sont accessibles uniquement à partir de la classe ou d'une classe dérivée.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>If the value of a field can be modified from outside its type, a property set accessor is typically used.</source>
          <target state="translated">Si la valeur d'un champ peut être modifiée en dehors de son type, un accesseur set de propriété est en général utilisé.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Publicly exposed fields are usually read-only and can be of two types:</source>
          <target state="translated">Les champs exposés publiquement sont généralement en lecture seule et peuvent être de deux types :</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Constants, whose value is assigned at design time.</source>
          <target state="translated">Constantes, dont la valeur est assignée au moment du design.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>These are static members of a class, although they are not defined using the <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) keyword.</source>
          <target state="translated">Ce sont des membres statiques d'une classe, bien qu'ils ne soient pas définis à l'aide du mot clé <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Read-only variables, whose values can be assigned in the class constructor.</source>
          <target state="translated">Des variables en lecture seule, dont les valeurs peuvent être assignées dans le constructeur de classe.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The following example illustrates these two usages of read-only fields.</source>
          <target state="translated">L'exemple ci-dessous illustre ces deux utilisations de champs en lecture seule.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Propriétés</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>A property names a value or state of the type and defines methods for getting or setting the property's value.</source>
          <target state="translated">Une propriété nomme une valeur ou un état du type et définit des méthodes pour obtenir ou définir la valeur de la propriété.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Properties can be primitive types, collections of primitive types, user-defined types, or collections of user-defined types.</source>
          <target state="translated">Les propriétés peuvent être des types primitifs, des collections de types primitifs, des types définis par l'utilisateur ou des collections de types définis par l'utilisateur.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Properties are often used to keep the public interface of a type independent from the type's actual representation.</source>
          <target state="translated">Les propriétés sont souvent utilisées pour maintenir l'interface publique d'un type indépendante de la représentation réelle du type.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>This enables properties to reflect values that are not directly stored in the class (for example, when a property returns a computed value) or to perform validation before values are assigned to private fields.</source>
          <target state="translated">Cela permet aux propriétés de refléter des valeurs qui ne sont pas directement stockées dans la classe (par exemple, lorsqu'une propriété retourne une valeur calculée) ou d'effectuer une validation avant que des valeurs soient assignées à des champs privés.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The following example illustrates the latter pattern.</source>
          <target state="translated">L’exemple suivant illustre ce dernier modèle.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>In addition to including the property itself, the Microsoft intermediate language (MSIL) for a type that contains a readable property includes a <ph id="ph1">`get`</ph><bpt id="p1">*</bpt>_propertyname<ept id="p1">*</ept> method, and the MSIL for a type that contains a writable property includes a <ph id="ph2">`set`</ph><bpt id="p2">*</bpt>_propertyname<ept id="p2">*</ept> method.</source>
          <target state="translated">En plus d’inclure la propriété elle-même, le langage MSIL (Microsoft Intermediate Language) pour un type qui contient une propriété lisible inclut une méthode <ph id="ph1">`get`</ph><bpt id="p1">*</bpt>_nompropriété<ept id="p1">*</ept>, et le MSIL pour un type qui contient une propriété accessible en écriture inclut une méthode <ph id="ph2">`set`</ph><bpt id="p2">*</bpt>_nompropriété<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Méthodes</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>A method describes operations that are available on the type.</source>
          <target state="translated">Une méthode décrit les opérations qui sont disponibles sur le type.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>A method's signature specifies the allowable types of all its parameters and of its return value.</source>
          <target state="translated">La signature d'une méthode spécifie les types autorisés de tous ses paramètres et de sa valeur de retour.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Although most methods define the precise number of parameters required for method calls, some methods support a variable number of parameters.</source>
          <target state="translated">Bien que la plupart des méthodes définissent le nombre précis de paramètres requis pour les appels de méthode, certaines méthodes acceptent un nombre variable de paramètres.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The final declared parameter of these methods is marked with the <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> attribute.</source>
          <target state="translated">Le dernier paramètre déclaré de ces méthodes est marqué avec l'attribut <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Language compilers typically provide a keyword, such as <ph id="ph1">`params`</ph> in C# and <ph id="ph2">`ParamArray`</ph> in Visual Basic, that makes explicit use of <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> unnecessary.</source>
          <target state="translated">Les compilateurs de langage fournissent généralement un mot clé, tel que <ph id="ph1">`params`</ph> en C# et <ph id="ph2">`ParamArray`</ph> en Visual Basic, qui rendent l’utilisation explicite de <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> inutile.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructeurs</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>A constructor is a special kind of method that creates new instances of a class or structure.</source>
          <target state="translated">Un constructeur est un genre de méthode particulier qui crée de nouvelles instances d'une classe ou d'une structure.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Like any other method, a constructor can include parameters; however, constructors have no return value (that is, they return <ph id="ph1">`void`</ph>).</source>
          <target state="translated">Comme n'importe quelle autre méthode, un constructeur peut inclure des paramètres ; toutefois, les constructeurs n'ont pas de valeur de retour (en d'autres termes, ils retournent <ph id="ph1">`void`</ph>).</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>If the source code for a class does not explicitly define a constructor, the compiler includes a default (parameterless) constructor.</source>
          <target state="translated">Si le code source d'une classe ne définit pas explicitement un constructeur, le compilateur inclut un constructeur par défaut (sans paramètre).</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>However, if the source code for a class defines only parameterized constructors, the C# compiler doesn't generate a parameterless constructor.</source>
          <target state="translated">Toutefois, si le code source d’une classe définit uniquement des constructeurs paramétrables, le compilateur C# ne génère pas de constructeur sans paramètre.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>If the source code for a structure defines constructors, they must be parameterized; a structure cannot define a default (parameterless) constructor, and compilers do not generate parameterless constructors for structures or other value types.</source>
          <target state="translated">Si le code source d'une structure définit des constructeurs, ils doivent être paramétrables ; une structure ne peut pas définir un constructeur (sans paramètre) par défaut et les compilateurs ne génèrent pas de constructeur sans paramètre pour les structures ou les autres types valeurs.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>All value types do have an implicit default constructor.</source>
          <target state="translated">Tous les types valeurs disposent d'un constructeur implicite par défaut.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>This constructor is implemented by the common language runtime and initializes all fields of the structure to their default values.</source>
          <target state="translated">Ce constructeur est implémenté par le Common Language Runtime et initialise tous les champs de la structure avec leurs valeurs par défaut.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Événements</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>An event defines an incident that can be responded to, and defines methods for subscribing to, unsubscribing from, and raising the event.</source>
          <target state="translated">Un événement définit un incident auquel il est possible de répondre, et définit les méthodes permettant de s'abonner à l'événement, d'annuler cet abonnement et de déclencher l'événement.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Events are often used to inform other types of state changes.</source>
          <target state="translated">Les événements sont souvent utilisés pour signaler d'autres types de changements d'état.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Nested types</source>
          <target state="translated">Types imbriqués</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>A nested type is a type that is a member of some other type.</source>
          <target state="translated">Un type imbriqué est un type qui est un membre d'un autre type.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Nested types should be tightly coupled to their containing type and must not be useful as a general-purpose type.</source>
          <target state="translated">Un type imbriqué doit être fortement couplé avec le type qui le contient et ne doit pas être utilisé en tant que type à usage général.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Nested types are useful when the declaring type uses and creates instances of the nested type, and use of the nested type is not exposed in public members.</source>
          <target state="translated">Ceux-ci sont utiles lorsque le type de déclaration utilise et crée des instances du type imbriqué et que l'utilisation du type imbriqué n'est pas exposée dans des membres publics.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Nested types are confusing to some developers and should not be publicly visible unless there is a compelling reason for visibility.</source>
          <target state="translated">Certains développeurs éprouvent des difficultés à appréhender correctement les types imbriqués. Il faut savoir qu'ils ne doivent pas être publiquement visibles sauf s'il existe une bonne raison à cela.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>In a well-designed library, developers should rarely have to use nested types to instantiate objects or declare variables.</source>
          <target state="translated">Dans une bibliothèque bien conçue, les développeurs doivent rarement avoir à utiliser des types imbriqués pour instancier des objets ou déclarer des variables.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Characteristics of type members</source>
          <target state="translated">Caractéristiques des membres de type</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The common type system allows type members to have a variety of characteristics; however, languages are not required to support all these characteristics.</source>
          <target state="translated">Le système de type commun (CTS, Common Type System) permet aux membres de type d'avoir diverses caractéristiques ; toutefois, les langages ne doivent pas obligatoirement prendre en charge toutes ces caractéristiques.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following table describes member characteristics.</source>
          <target state="translated">Le tableau suivant décrit les caractéristiques des membres.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Characteristic</source>
          <target state="translated">Caractéristique</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Can apply to</source>
          <target state="translated">Applicable à</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>abstract</source>
          <target state="translated">abstract</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events</source>
          <target state="translated">Méthodes, propriétés et événements</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The type does not supply the method's implementation.</source>
          <target state="translated">Le type n'assure pas l'implémentation de la méthode.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Types that inherit or implement abstract methods must supply an implementation for the method.</source>
          <target state="translated">Les types qui héritent de méthodes abstraites ou qui en implémentent doivent fournir une implémentation pour la méthode.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The only exception is when the derived type is itself an abstract type.</source>
          <target state="translated">Une exception : le type dérivé est lui-même un type abstrait.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>All abstract methods are virtual.</source>
          <target state="translated">Toutes les méthodes abstraites sont virtuelles.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>private</source>
          <target state="translated">private</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Tous</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Accessible only from within the same type as the member, or within a nested type.</source>
          <target state="translated">Accessible uniquement à partir du même type que le membre ou à l'intérieur d'un type imbriqué.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>family</source>
          <target state="translated">family</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Tous</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Accessible from within the same type as the member, and from derived types that inherit from it.</source>
          <target state="translated">Accessible à partir du même type que le membre et à partir des types dérivés qui en héritent.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>assemby</source>
          <target state="translated">assemby</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Tous</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Accessible only in the assembly in which the type is defined.</source>
          <target state="translated">Accessible uniquement dans l'assembly dans lequel le type est défini.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>family and assembly</source>
          <target state="translated">family et assembly</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Tous</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Accessible only from types that qualify for both family and assembly access.</source>
          <target state="translated">Accessible uniquement à partir des types qui se qualifient pour un accès family et assembly.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>family or assemby</source>
          <target state="translated">family ou assembly</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Tous</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Accessible only from types that qualify for either family or assembly access.</source>
          <target state="translated">Accessible uniquement à partir des types qui se qualifient pour un accès family ou assembly.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>public</source>
          <target state="translated">public</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Tous</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Accessible from any type.</source>
          <target state="translated">Accessible à partir de n'importe quel type.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>final</source>
          <target state="translated">final</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events</source>
          <target state="translated">Méthodes, propriétés et événements</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The virtual method cannot be overridden in a derived type.</source>
          <target state="translated">La méthode virtuelle ne peut pas être substituée dans un type dérivé.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>initialize-only</source>
          <target state="translated">initialize-only</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Champs</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The value can only be initialized, and cannot be written after initialization.</source>
          <target state="translated">La valeur peut seulement être initialisée et ne peut pas être écrite après initialisation.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>instance</source>
          <target state="translated">instance</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Fields, methods, properties, and events</source>
          <target state="translated">Champs, méthodes, propriétés et événements</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>If a member is not marked as <ph id="ph1">`static`</ph> (C#), <ph id="ph2">`Shared`</ph> (Visual Basic), <ph id="ph3">`virtual`</ph> (C#), or <ph id="ph4">`Overridable`</ph> (Visual Basic),  it is an instance member (there is no instance keyword).</source>
          <target state="translated">Si un membre n’est pas marqué comme <ph id="ph1">`static`</ph> (C#), <ph id="ph2">`Shared`</ph> (Visual Basic), <ph id="ph3">`virtual`</ph> (C#) ou <ph id="ph4">`Overridable`</ph> (Visual Basic), il est membre d’instance (il n’y a pas de mot clé d’instance).</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>There will be as many copies of such members in memory as there are objects that use it.</source>
          <target state="translated">La mémoire comptera autant de copies de tels membres que d'objets qui les utilisent.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>literal</source>
          <target state="translated">littéral</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Champs</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The value assigned to the field is a fixed value, known at compile time, of a built-in value type.</source>
          <target state="translated">La valeur assignée au champ est une valeur fixe, connue au moment de la compilation, d'un type valeur intégré.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Literal fields are sometimes referred to as constants.</source>
          <target state="translated">Les champs de type Literal sont parfois qualifiés de constantes.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>newslot or override</source>
          <target state="translated">newslot ou override</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Tous</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Defines how the member interacts with inherited members that have the same signature: <ph id="ph1">`newslot`</ph> hides inherited members that have the same signature; <ph id="ph2">`override`</ph> replaces the definition of an inherited virtual method.</source>
          <target state="translated">Définit la façon dont le membre interagit avec des membres hérités ayant la même signature : <ph id="ph1">`newslot`</ph> masque les membres hérités ayant la même signature ; <ph id="ph2">`override`</ph> remplace la définition d’une méthode virtuelle héritée.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The default is newslot.</source>
          <target state="translated">La valeur par défaut est newslot.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>static</source>
          <target state="translated">statique</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Fields, methods, properties, and events</source>
          <target state="translated">Champs, méthodes, propriétés et événements</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The member belongs to the type it is defined on, not to a particular instance of the type; the member exists even if an instance of the type is not created, and it is shared among all instances of the type.</source>
          <target state="translated">Le membre appartient au type sur lequel il est défini, et non à une instance particulière du type ; le membre existe même si une instance du type n'est pas créée, et il est partagé entre toutes les instances du type.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>virtual</source>
          <target state="translated">virtual</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events</source>
          <target state="translated">Méthodes, propriétés et événements</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The method can be implemented by a derived type and can be invoked either statically or dynamically.</source>
          <target state="translated">La méthode peut être implémentée par un type dérivé et peut être appelée de manière statique ou dynamique.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>If dynamic invocation is used, the type of the instance that makes the call at run time (rather than the type known at compile time) determines which implementation of the method is called.</source>
          <target state="translated">Si un appel dynamique est utilisé, le type de l'instance qui effectue l'appel au moment de l'exécution détermine quelle implémentation de la méthode est appelée (plutôt que le type connu au moment de la compilation).</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>To invoke a virtual method statically, the variable might have to be cast to a type that uses the desired version of the method.</source>
          <target state="translated">Pour appeler une méthode virtuelle de manière statique, un cast en un type qui utilise la version désirée de la méthode devra éventuellement être effectué sur la variable.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Surcharge</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Each type member has a unique signature.</source>
          <target state="translated">Chaque membre de type a une signature unique.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Method signatures consist of the method name and a parameter list (the order and types of the method's arguments).</source>
          <target state="translated">Les signatures de méthode sont composées du nom de la méthode, d'une liste de paramètres (l'ordre et les types des arguments de la méthode).</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Multiple methods with the same name can be defined within a type as long as their signatures differ.</source>
          <target state="translated">Plusieurs méthodes du même nom peuvent être définies dans un type à condition que leurs signatures diffèrent.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>When two or more methods with the same name are defined, the method is said to be overloaded.</source>
          <target state="translated">Lorsque plusieurs méthodes du même nom sont définies, la méthode est dite surchargée.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>For example, in <bpt id="p1">[</bpt>System.Char<ept id="p1">](xref:System.Char)</ept>, the <ph id="ph1">`IsDigit`</ph> method is overloaded.</source>
          <target state="translated">Par exemple, dans <bpt id="p1">[</bpt>System.Char<ept id="p1">](xref:System.Char)</ept>, la méthode <ph id="ph1">`IsDigit`</ph> est surchargée.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>One method takes a <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept>.</source>
          <target state="translated">Une seule méthode accepte un <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The other method takes a <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> and an <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>.</source>
          <target state="translated">L’autre méthode prend un <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> et un <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>The return type is not considered part of a method's signature.</source>
          <target state="translated">Le type de retour n’est pas considéré comme une partie de la signature d’une méthode.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>That is, methods cannot be overloaded if they differ only by return type.</source>
          <target state="translated">En d'autres termes, les méthodes ne peuvent pas être surchargées si seul le type de retour les différencie.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Inheriting, overriding, and hiding members</source>
          <target state="translated">Héritage, substitution et masquage de membres</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A derived type inherits all members of its base type; that is, these members are defined on, and available to, the derived type.</source>
          <target state="translated">Un type dérivé hérite de tous les membres de son type de base ; c'est-à-dire que ces membres sont définis sur le type dérivé et disponibles pour celui-ci.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>The behavior or qualities of inherited members can be modified in two ways:</source>
          <target state="translated">Le comportement ou les qualités de membres hérités peuvent être modifiés de deux manières :</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>A derived type can hide an inherited member by defining a new member with the same signature.</source>
          <target state="translated">Un type dérivé peut masquer un membre hérité en définissant un nouveau membre avec la même signature.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>This might be done to make a previously public member private or to define new behavior for an inherited method that is marked as <ph id="ph1">`final`</ph>.</source>
          <target state="translated">Cela permet notamment de rendre privé un membre précédemment public ou de définir un nouveau comportement pour une méthode héritée marquée comme <ph id="ph1">`final`</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>A derived type can override an inherited virtual method.</source>
          <target state="translated">Un type dérivé peut substituer une méthode virtuelle héritée.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The overriding method provides a new definition of the method that will be invoked based on the type of the value at run time rather than the type of the variable known at compile time.</source>
          <target state="translated">La méthode de substitution fournit une nouvelle définition de la méthode qui sera appelée en fonction du type de la valeur au moment de l'exécution et non du type de la variable connue au moment de la compilation.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>A method can override a virtual method only if the virtual method is not marked as <ph id="ph1">`final`</ph> and the new method is at least as accessible as the virtual method.</source>
          <target state="translated">Une méthode peut substituer une méthode virtuelle uniquement si la méthode virtuelle n'est pas marquée comme <ph id="ph1">`final`</ph> et si la nouvelle méthode est au moins aussi accessible que la méthode virtuelle.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type conversion in the .NET Framework<ept id="p1">](type-conversion.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Conversion de type dans le .NET Framework<ept id="p1">](type-conversion.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>