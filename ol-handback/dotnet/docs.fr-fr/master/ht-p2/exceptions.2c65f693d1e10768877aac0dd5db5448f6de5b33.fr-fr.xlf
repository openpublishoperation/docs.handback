<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0c73fb0a12092877ff5b54221f4a80693d1d1152</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\exceptions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4039eb59d735cb586da4b617c06c78c4c56de430</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9296088cb345ca8e749cc7c98a39bacca0772227</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Handling and throwing exceptions in .NET</source>
          <target state="translated">Gestion et levée d’exceptions dans .NET</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Understand how to use exceptions in .NET</source>
          <target state="translated">Guide pratique pour utiliser des exceptions dans .NET</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Handling and throwing exceptions in .NET</source>
          <target state="translated">Gestion et levée d’exceptions dans .NET</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Applications must be able to handle errors that occur during execution in a consistent manner.</source>
          <target state="translated">Les applications doivent pouvoir gérer de manière cohérente les erreurs qui se produisent au moment de l'exécution.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>.NET provides a model for notifying applications of errors in a uniform way: .NET operations indicate failure by throwing exceptions.</source>
          <target state="translated">.NET fournit un modèle pour avertir les applications de façon uniforme de la présence d’erreurs : les opérations .NET indiquent un échec en levant des exceptions.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>An exception is any error condition or unexpected behavior that is encountered by an executing program.</source>
          <target state="translated">Une exception est une condition d'erreur ou un comportement inattendu rencontré par un programme en cours d'exécution.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Exceptions can be thrown because of a fault in your code or in code that you call (such as a shared library), unavailable operating system resources, unexpected conditions that the runtime encounters (such as code that cannot be verified), and so on.</source>
          <target state="translated">Les exceptions peuvent être levées à cause d’une erreur dans votre code ou dans le code que vous appelez (une bibliothèque partagée, par exemple), de ressources de système d’exploitation non disponibles, de conditions inattendues rencontrées par le runtime (du code qui ne peut pas être vérifié, par exemple), etc.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Your application can recover from some of these conditions, but not from others.</source>
          <target state="translated">Votre application peut récupérer suite à certaines de ces conditions, mais pas toutes.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Although you can recover from most application exceptions, you cannot recover from most runtime exceptions.</source>
          <target state="translated">Bien que vous puissiez récupérer suite à la plupart des exceptions d'application, vous ne pouvez pas récupérer suite à la plupart des exceptions runtime.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In .NET, an exception is an object that inherits from the <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept> class.</source>
          <target state="translated">Dans .NET, une exception est un objet qui hérite de la classe <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>An exception is thrown from an area of code where a problem has occurred.</source>
          <target state="translated">Une exception est levée à partir d'une partie du code où un problème s'est produit.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The exception is passed up the stack until the application handles it or the program terminates.</source>
          <target state="translated">L'exception remonte la pile jusqu'à sa prise en charge par l'application ou l'arrêt du programme.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Exceptions vs. traditional error-handling methods</source>
          <target state="translated">Comparaison des exceptions et des méthodes traditionnelles de gestion des erreurs</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Traditionally, a language's error-handling model relied on either the language's unique way of detecting errors and locating handlers for them, or on the error-handling mechanism provided by the operating system.</source>
          <target state="translated">Traditionnellement, le modèle de gestion des erreurs d'un langage reposait soit sur le mode unique utilisé par le langage en question pour détecter des erreurs et leur trouver des gestionnaires appropriés, soit sur le mécanisme de gestion des erreurs fourni par le système d'exploitation.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The way .NET implements exception handling provides the following advantages:</source>
          <target state="translated">La façon dont .NET implémente la gestion des exceptions offre les avantages suivants :</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Exception throwing and handling works the same for .NET programming languages.</source>
          <target state="translated">La gestion et la levée des exceptions fonctionne de la même façon pour les langages de programmation .NET.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Does not require any particular language syntax for handling exceptions, but allows each language to define its own syntax.</source>
          <target state="translated">Ne requiert aucune syntaxe particulière pour la gestion des exceptions, mais laisse chaque langage définir sa propre syntaxe.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Exceptions can be thrown across process and even machine boundaries.</source>
          <target state="translated">Les exceptions peuvent être levées au-delà des limites des processus et même des ordinateurs.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Exception-handling code can be added to an application to increase program reliability.</source>
          <target state="translated">Un code de gestion des exceptions peut être ajouté à une application pour augmenter la fiabilité du programme.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Exceptions offer advantages over other methods of error notification, such as return codes.</source>
          <target state="translated">Les exceptions offrent des avantages par rapport à d’autres méthodes de notification des erreurs, comme les codes de retour.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Failures do not go unnoticed because if an exception is thrown and you don't handle it, the runtime terminates your application.</source>
          <target state="translated">Les erreurs ne passent pas inaperçues, car si une exception est levée et que vous ne la gérez pas, le runtime arrête votre application.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Invalid values do not continue to propagate through the system as a result of code that fails to check for a failure return code.</source>
          <target state="translated">Les valeurs non valides ne continuent pas à se propager dans le système parce que du code n’a pas pu vérifier un code de retour d’échec.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Exception class and properties</source>
          <target state="translated">Classe et propriétés d’exception</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">@System.Exception</ph> class is the base class from which exceptions inherit.</source>
          <target state="translated">La classe <ph id="ph1">@System.Exception</ph> est la classe de base dont héritent les exceptions.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">@System.InvalidCastException</ph> class hierarchy is as follows:</source>
          <target state="translated">Par exemple, la hiérarchie de classes <ph id="ph1">@System.InvalidCastException</ph> se présente comme suit :</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">@System.Exception</ph> class has the following properties that help make understanding an exception easier.</source>
          <target state="translated">La classe <ph id="ph1">@System.Exception</ph> a les propriétés suivantes qui vous permettront de mieux comprendre une exception.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Property Name</source>
          <target state="translated">Nom de propriété</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">@System.Collections.IDictionary</ph> that holds arbitrary data in key-value pairs.</source>
          <target state="translated"><ph id="ph1">@System.Collections.IDictionary</ph> qui contient des données arbitraires dans des paires clé-valeur.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Can hold a URL (or URN) to a help file that provides extensive information about the cause of an exception.</source>
          <target state="translated">Peut contenir une URL (ou URN) vers un fichier d’aide qui fournit des informations détaillées sur la cause d’une exception.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>This property can be used to create and preserve a series of exceptions during exception handling.</source>
          <target state="translated">Cette propriété peut être utilisée pour créer et conserver une série d’exceptions pendant la gestion des exceptions.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You can use it to create a new exception that contains previously caught exceptions.</source>
          <target state="translated">Vous pouvez l’utiliser pour créer une exception qui contient des exceptions interceptées précédemment.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The original exception can be captured by the second exception in the <ph id="ph1">@System.Exception.InnerException</ph> property, allowing code that handles the second exception to examine the additional information.</source>
          <target state="translated">L’exception d’origine peut être capturée par la deuxième exception dans la propriété <ph id="ph1">@System.Exception.InnerException</ph>, ce qui permet au code qui gère la deuxième exception d’examiner les informations supplémentaires.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a method that receives an argument that's improperly formatted.</source>
          <target state="translated">Par exemple, supposons que vous disposez d’une méthode qui reçoit un argument avec une mise en forme incorrecte.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The code tries to read the argument, but an exception is thrown.</source>
          <target state="translated">Le code essaie de lire l’argument, mais une exception est levée.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The method catches the exception and throws a <ph id="ph1">@System.FormatException.</ph> To improve the caller's ability to determine the reason an exception is thrown, it is sometimes desirable for a method to catch an exception thrown by a helper routine and then throw an exception more indicative of the error that has occurred.</source>
          <target state="translated">La méthode intercepte l’exception et lève une exception <ph id="ph1">@System.FormatException.</ph> Pour améliorer la capacité de l’appelant à déterminer la raison pour laquelle une exception est levée, il est parfois souhaitable qu’une méthode intercepte une exception levée par une routine d’assistance, puis qu’elle lève une exception plus évocatrice de l’erreur qui s’est produite.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A new and more meaningful exception can be created, where the inner exception reference can be set to the original exception.</source>
          <target state="translated">Une exception plus significative peut être créée, dans laquelle la référence à l’exception interne peut être définie sur l’exception d’origine.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This more meaningful exception can then be thrown to the caller.</source>
          <target state="translated">Cette exception plus significative peut ensuite être levée pour l’appelant.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Note that with this functionality, you can create a series of linked exceptions that ends with the exception that was thrown first.</source>
          <target state="translated">Notez que cette fonctionnalité vous permet de créer une série d’exceptions liées qui se termine avec l’exception initialement levée.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Provides details about the cause of an exception.</source>
          <target state="translated">Fournit les détails de la cause d’une exception.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of the application or the object that causes the error.</source>
          <target state="translated">Obtient ou définit le nom de l'application ou de l'objet qui est à l'origine de l'erreur.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Contains a stack trace that can be used to determine where an error occurred.</source>
          <target state="translated">Contient une trace de pile qui peut être utilisée pour déterminer où une erreur s’est produite.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The stack trace includes the source file name and program line number if debugging information is available.</source>
          <target state="translated">La trace de la pile comprend le nom du fichier source et le numéro de ligne du programme si les informations de débogage sont disponibles.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Most of the classes that inherit from <ph id="ph1">@System.Exception</ph> do not implement additional members or provide additional functionality; they simply inherit from <ph id="ph2">@System.Exception.</ph> Therefore, the most important information for an exception can be found in the hierarchy of exception classes, the exception name, and the information contained in the exception.</source>
          <target state="translated">La plupart des classes qui héritent de <ph id="ph1">@System.Exception</ph> n’implémentent pas de membres supplémentaires et ne fournissent pas de fonctionnalités supplémentaires. Elles héritent simplement de <ph id="ph2">@System.Exception.</ph> Par conséquent, vous pouvez trouver les informations les plus importantes d’une exception dans la hiérarchie des classes d’exception, le nom de l’exception et les informations contenues dans l’exception.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>It is recommended to throw and catch only objects that derive from <ph id="ph1">@System.Exception,</ph> but you can throw any object that derives from the <ph id="ph2">@System.Object</ph> class as an exception.</source>
          <target state="translated">Nous vous recommandons de lever et d’intercepter uniquement des objets qui dérivent de <ph id="ph1">@System.Exception,</ph>, mais vous pouvez lever comme exception n’importe quel objet qui dérive de la classe <ph id="ph2">@System.Object</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Note that not all languages support throwing and catching objects that do not derive from <ph id="ph1">@System.Exception.</ph></source>
          <target state="translated">Notez que tous les langages ne prennent pas forcément en charge la levée et l’interception d’objets qui ne dérivent pas de <ph id="ph1">@System.Exception.</ph></target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Common Exceptions</source>
          <target state="translated">Exceptions courantes</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The following table lists some common exceptions with examples of what can cause them.</source>
          <target state="translated">Le tableau suivant répertorie certaines exceptions courantes avec des exemples de cause possible.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Exception type</source>
          <target state="translated">Type d'exception</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Base type</source>
          <target state="translated">Type de base</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Exemple</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Base class for all exceptions.</source>
          <target state="translated">Classe de base pour toutes les exceptions.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>None (use a derived class of this exception).</source>
          <target state="translated">Aucun (utilisez une classe dérivée de cette exception).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Thrown by the runtime only when an array is indexed improperly.</source>
          <target state="translated">Levée par le runtime uniquement en cas d’indexation incorrecte du tableau.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Indexing an array outside its valid range: <ph id="ph1">`arr[arr.Length+1]`</ph></source>
          <target state="translated">Indexation d’un tableau en dehors de sa plage valide : <ph id="ph1">`arr[arr.Length+1]`</ph></target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Thrown by the runtime only when a null object is referenced.</source>
          <target state="translated">Levée par le runtime uniquement si un objet Null est référencé.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Thrown by methods when in an invalid state.</source>
          <target state="translated">Levée par les méthodes en cas d’état non valide.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Calling <ph id="ph1">`Enumerator.GetNext()`</ph> after removing an Item from the underlying collection.</source>
          <target state="translated">Appel de <ph id="ph1">`Enumerator.GetNext()`</ph> après la suppression d’un élément de la collection sous-jacente.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Base class for all argument exceptions.</source>
          <target state="translated">Classe de base pour toutes les exceptions d’argument.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>None (use a derived class of this exception).</source>
          <target state="translated">Aucun (utilisez une classe dérivée de cette exception).</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Thrown by methods that do not allow an argument to be null.</source>
          <target state="translated">Levée par les méthodes qui n’acceptent pas la valeur Null pour un argument.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Thrown by methods that verify that arguments are in a given range.</source>
          <target state="translated">Levée par les méthodes qui vérifient que les arguments sont inclus dans une plage donnée.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>How to use the try/catch block to catch exceptions</source>
          <target state="translated">Guide pratique pour utiliser le bloc try/catch pour intercepter des exceptions</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Place the sections of code that might throw exceptions in a <ph id="ph1">`try`</ph> block and place code that handles exceptions in a <ph id="ph2">`catch`</ph> block.</source>
          <target state="translated">Placez les sections de code qui peuvent lever des exceptions dans un bloc <ph id="ph1">`try`</ph> et placez le code qui gère les exceptions dans un bloc <ph id="ph2">`catch`</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`catch`</ph> block is a series of statements beginning with the keyword <ph id="ph2">`catch`</ph>, followed by an exception type and an action to be taken.</source>
          <target state="translated">Le bloc <ph id="ph1">`catch`</ph> est une série d’instructions qui commencent par le mot clé <ph id="ph2">`catch`</ph>, suivi d’un type d’exception et d’une action à effectuer.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The following code example uses a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block to catch a possible exception.</source>
          <target state="translated">L’exemple de code suivant utilise un bloc <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> pour intercepter une exception possible.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Main`</ph> method contains a <ph id="ph2">`try`</ph> block with a <ph id="ph3">@System.IO.StreamReader</ph> statement that opens a data file called <ph id="ph4">`data.txt`</ph> and writes a string from the file.</source>
          <target state="translated">La méthode <ph id="ph1">`Main`</ph> contient un bloc <ph id="ph2">`try`</ph> avec une instruction <ph id="ph3">@System.IO.StreamReader</ph> qui ouvre un fichier de données appelé <ph id="ph4">`data.txt`</ph> et écrit une chaîne à partir du fichier.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Following the <ph id="ph1">`try`</ph> block is a <ph id="ph2">`catch`</ph> block that catches any exception that results from the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">À la suite du bloc <ph id="ph1">`try`</ph>, un bloc <ph id="ph2">`catch`</ph> intercepte toute exception qui résulte du bloc <ph id="ph3">`try`</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The common language runtime catches exceptions that are not caught by a catch block.</source>
          <target state="translated">Le Common Language Runtime intercepte les exceptions qui ne sont pas interceptées par un bloc catch.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Depending on how the runtime is configured, a debug dialog box appears, or the program stops executing and a dialog box with exception information appears, or an error is printed out to STDERR.</source>
          <target state="translated">Selon la configuration du runtime, une boîte de dialogue de débogage s’affiche, le programme s’arrête et une boîte de dialogue s’affiche avec des informations sur l’exception, ou une erreur est imprimée dans STDERR.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Almost any line of code can cause an exception, particularly exceptions that are thrown by the common language runtime itself, such as <ph id="ph1">@System.OutOfMemoryException.</ph> Most applications don't have to deal with these exceptions, but you should be aware of this possibility when writing libraries to be used by others.</source>
          <target state="translated">Toute ligne de code ou presque peut générer une exception, notamment les exceptions qui sont levées par le Common Language Runtime lui-même, telles que <ph id="ph1">@System.OutOfMemoryException.</ph> La plupart des applications n’ont pas à traiter ces exceptions, mais vous devez être conscient de cette possibilité quand vous écrivez des bibliothèques destinées à d’autres utilisateurs.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For suggestions on when to set code in a Try block, see <bpt id="p1">[</bpt>Best Practices for Exceptions<ept id="p1">](#best-practices-for-exceptions)</ept>.</source>
          <target state="translated">Afin d’obtenir des suggestions pour savoir quand définir du code dans un bloc Try, consultez les <bpt id="p1">[</bpt>Bonnes pratiques pour les exceptions<ept id="p1">](#best-practices-for-exceptions)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>How to use specific exceptions in a Catch block</source>
          <target state="translated">Guide pratique pour utiliser des exceptions spécifiques dans un bloc Catch</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The preceding code example illustrates a basic <ph id="ph1">`catch`</ph> statement that catches any exception.</source>
          <target state="translated">L’exemple de code précédent illustre une instruction <ph id="ph1">`catch`</ph> de base qui intercepte toutes les exceptions.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>In general, though, it's good programming practice to catch a specific type of exception rather than use a basic <ph id="ph1">`catch`</ph> statement.</source>
          <target state="translated">En général, cependant, il est conseillé en programmation d’intercepter un type d’exception spécifique au lieu d’utiliser une instruction <ph id="ph1">`catch`</ph> de base.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>When an exception occurs, it is passed up the stack and each catch block is given the opportunity to handle it.</source>
          <target state="translated">Quand une exception se produit, elle remonte la pile et chaque bloc catch a la possibilité de la gérer.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The order of catch statements is important.</source>
          <target state="translated">L’ordre des instructions catch est important.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Put catch blocks targeted to specific exceptions before a general exception catch block or the compiler might issue an error.</source>
          <target state="translated">Placez les blocs catch ciblés sur des exceptions spécifiques avant un bloc catch d’exceptions générales, sinon le compilateur peut générer une erreur.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The proper catch block is determined by matching the type of the exception to the name of the exception specified in the catch block.</source>
          <target state="translated">Le bloc catch approprié est déterminé en mettant en correspondance le type de l’exception avec le nom de l’exception spécifiée dans le bloc catch.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If there is no specific catch block, the exception is caught by a general catch block, if one exists.</source>
          <target state="translated">S’il n’existe aucun bloc catch spécifique, l’exception est interceptée par un bloc catch général, le cas échéant.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The following code example uses a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block to catch an <ph id="ph4">@System.InvalidCastException.</ph> The sample creates a class called <ph id="ph5">`Employee`</ph> with a single property, employee level (<ph id="ph6">`Emlevel`</ph>).</source>
          <target state="translated">Le code suivant exemple utilise un bloc <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> pour intercepter <ph id="ph4">@System.InvalidCastException.</ph> L’exemple crée une classe appelée <ph id="ph5">`Employee`</ph> avec une propriété unique, <ph id="ph6">`Emlevel`</ph> (niveau de l’employé).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A method, <ph id="ph1">`PromoteEmployee`</ph>, takes an object and increments the employee level.</source>
          <target state="translated">Une méthode <ph id="ph1">`PromoteEmployee`</ph> prend un objet et incrémente le niveau de l’employé.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">@System.InvalidCastException</ph> occurs when a <ph id="ph2">@System.DateTime</ph> instance is passed to the <ph id="ph3">`PromoteEmployee`</ph> method.</source>
          <target state="translated">Une exception <ph id="ph1">@System.InvalidCastException</ph> se produit quand une instance <ph id="ph2">@System.DateTime</ph> est passée à la méthode <ph id="ph3">`PromoteEmployee`</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>How to use finally blocks</source>
          <target state="translated">Guide pratique pour utiliser des blocs finally</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>When an exception occurs, execution stops and control is given to the appropriate exception handler.</source>
          <target state="translated">Quand une exception se produit, l’exécution s’arrête et le contrôle est donné au gestionnaire d’exceptions approprié.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>This often means that lines of code you expect to be executed are bypassed.</source>
          <target state="translated">Cela signifie souvent que les lignes de code qui doivent être exécutées sont ignorées.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Some resource cleanup, such as closing a file, needs to be done even if an exception is thrown.</source>
          <target state="translated">Un nettoyage des ressources, comme la fermeture d’un fichier, doit être effectué même si une exception est levée.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>To do this, you can use a <ph id="ph1">`finally`</ph> block.</source>
          <target state="translated">Pour ce faire, vous pouvez utiliser un bloc <ph id="ph1">`finally`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`finally`</ph> block always executes, regardless of whether an exception is thrown.</source>
          <target state="translated">Un bloc <ph id="ph1">`finally`</ph> s’exécute toujours, qu’une exception soit levée ou non.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The following code example uses a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block to catch an <ph id="ph4">@System.ArgumentOutOfRangeException.</ph> The <ph id="ph5">`Main`</ph> method creates two arrays and attempts to copy one to the other.</source>
          <target state="translated">L’exemple de code suivant utilise un bloc <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> pour intercepter une exception <ph id="ph4">@System.ArgumentOutOfRangeException.</ph> La méthode <ph id="ph5">`Main`</ph> crée deux tableaux et tente de copier l’un dans l’autre.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The action generates an <ph id="ph1">@System.ArgumentOutOfRangeException</ph> and the error is written to the console.</source>
          <target state="translated">Cette action génère une exception <ph id="ph1">@System.ArgumentOutOfRangeException</ph> et l’erreur est écrite dans la console.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`finally`</ph> block executes regardless of the outcome of the copy action.</source>
          <target state="translated">Le bloc <ph id="ph1">`finally`</ph> s’exécute indépendamment du résultat de l’action de copie.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>How to explicitly throw exceptions</source>
          <target state="translated">Guide pratique pour lever explicitement des exceptions</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can explicitly throw an exception using the <ph id="ph1">`throw`</ph> statement.</source>
          <target state="translated">Vous pouvez lever explicitement une exception à l’aide de l’instruction <ph id="ph1">`throw`</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>You can also throw a caught exception again using the <ph id="ph1">`throw`</ph> statement.</source>
          <target state="translated">Vous pouvez aussi lever de nouveau une exception interceptée à l’aide de l’instruction <ph id="ph1">`throw`</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>It is good coding practice to add information to an exception that is re-thrown to provide more information when debugging.</source>
          <target state="translated">En codage, il est conseillé d’ajouter des informations à une exception levée une deuxième fois pour fournir plus d’informations durant le débogage.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The following code example uses a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block to catch a possible <ph id="ph4">@System.IO.FileNotFoundException.</ph> Following the <ph id="ph5">`try`</ph> block is a <ph id="ph6">`catch`</ph> block that catches the <ph id="ph7">@System.IO.FileNotFoundException</ph> and writes a message to the console if the data file is not found.</source>
          <target state="translated">L’exemple de code suivant utilise un bloc <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> pour intercepter une éventuelle exception <ph id="ph4">@System.IO.FileNotFoundException.</ph> À la suite du bloc <ph id="ph5">`try`</ph>, un bloc <ph id="ph6">`catch`</ph> intercepte l’exception <ph id="ph7">@System.IO.FileNotFoundException</ph> et écrit un message dans la console si le fichier de données est introuvable.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The next statement is the <ph id="ph1">`throw`</ph> statement that throws a new <ph id="ph2">@System.IO.FileNotFoundException</ph> and adds text information to the exception.</source>
          <target state="translated">L’instruction suivante est <ph id="ph1">`throw`</ph>, qui lève une nouvelle exception <ph id="ph2">@System.IO.FileNotFoundException</ph> et ajoute des informations de texte à l’exception.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>How to create user-defined exceptions</source>
          <target state="translated">Guide pratique pour créer des exceptions définies par l’utilisateur</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>.NET provides a hierarchy of exception classes ultimately derived from the base class <ph id="ph1">@System.Exception.</ph> However, if none of the predefined exceptions meets your needs, you can create your own exception classes by deriving from the <ph id="ph2">@System.Exception</ph> class.</source>
          <target state="translated">.NET fournit une hiérarchie de classes d’exceptions qui sont en fin de compte dérivées de la classe de base <ph id="ph1">@System.Exception.</ph> Toutefois, si aucune exception prédéfinie ne répond à vos besoins, vous pouvez créer vos propres classes d’exception en les dérivant de la classe <ph id="ph2">@System.Exception</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>When creating your own exceptions, end the class name of the user-defined exception with the word "Exception," and implement the three common constructors, as shown in the following example.</source>
          <target state="translated">Quand vous créez vos propres exceptions, terminez le nom de la classe définie par l’utilisateur par le mot « Exception » et implémentez les trois constructeurs communs, comme indiqué dans l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The example defines a new exception class named <ph id="ph1">`EmployeeListNotFoundException`</ph>.</source>
          <target state="translated">L’exemple définit une nouvelle classe d’exception nommée <ph id="ph1">`EmployeeListNotFoundException`</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The class is derived from <ph id="ph1">@System.Exception</ph> and includes three constructors.</source>
          <target state="translated">La classe est dérivée de l’exception <ph id="ph1">@System.Exception</ph> et inclut trois constructeurs.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In situations where you are using remoting, you must ensure that the metadata for any user-defined exceptions is available at the server (callee) and to the client (the proxy object or caller).</source>
          <target state="translated">Dans les situations où vous utilisez la communication à distance, vous devez vérifier que les métadonnées des exceptions définies par l’utilisateur sont disponibles sur le serveur (appelé) et le client (objet proxy ou appelant).</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Best practices for exceptions<ept id="p1">](#best-practices-for-exceptions)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez les <bpt id="p1">[</bpt>Bonnes pratiques pour les exceptions<ept id="p1">](#best-practices-for-exceptions)</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Best practices for exceptions</source>
          <target state="translated">Bonnes pratiques pour les exceptions</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>A well-designed app handles exceptions and errors to prevent app crashes.</source>
          <target state="translated">Une application bien conçue gère les exceptions et les erreurs pour empêcher les incidents d'applications.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This section describes best practices for handling and creating exceptions.</source>
          <target state="translated">Cette section présente les bonnes pratiques pour la gestion et la création des exceptions.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Use try/catch/finally blocks</source>
          <target state="translated">Utiliser des blocs try/catch/finally</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph><ph id="ph4">/</ph><ph id="ph5">`finally`</ph> blocks around code that can potentially generate an exception.</source>
          <target state="translated">Utilisez des blocs <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph><ph id="ph4">/</ph><ph id="ph5">`finally`</ph> autour du code susceptible de générer une exception.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`catch`</ph> blocks, always order exceptions from the most specific to the least specific.</source>
          <target state="translated">Dans les blocs <ph id="ph1">`catch`</ph>, veillez à toujours classer les exceptions de la plus spécifique à la moins spécifique.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Use a <ph id="ph1">`finally`</ph> block to clean up resources, whether you can recover or not.</source>
          <target state="translated">Utilisez un bloc <ph id="ph1">`finally`</ph> pour nettoyer les ressources, que la récupération soit possible ou non.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Handle common conditions without throwing exceptions</source>
          <target state="translated">Gérer les conditions courantes sans lever d’exception</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For conditions that are likely to occur but might trigger an exception, consider handling them in a way that will avoid the exception.</source>
          <target state="translated">En ce qui concerne les conditions susceptibles de se produire, mais pouvant déclencher une exception, gérez-les de façon à éviter l’exception.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For example, if you try to close a connection that is already closed, you'll get an <ph id="ph1">`InvalidOperationException`</ph>.</source>
          <target state="translated">Par exemple, si vous essayez de fermer une connexion déjà fermée, vous obtenez une exception <ph id="ph1">`InvalidOperationException`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>You can avoid that by using an <ph id="ph1">`if`</ph> statement to check the connection state before trying to close it.</source>
          <target state="translated">Vous pouvez l’éviter avec une instruction <ph id="ph1">`if`</ph> qui permet de vérifier l’état de la connexion avant d’essayer de la fermer.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>If you don't check connection state before closing, you can catch the <ph id="ph1">`InvalidOperationException`</ph> exception.</source>
          <target state="translated">Si vous ne vérifiez pas l’état de la connexion avant de la fermer, vous pouvez intercepter l’exception <ph id="ph1">`InvalidOperationException`</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The method to choose depends on how often you expect the event to occur.</source>
          <target state="translated">Le choix de la méthode dépend de la fréquence à laquelle l’événement doit se produire.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Use exception handling if the event doesn't occur very often, that is, if the event is truly exceptional and indicates an error (such as an unexpected end-of-file).</source>
          <target state="translated">Utilisez la gestion des exceptions si l'événement ne se produit pas très souvent, c'est-à-dire, si l'événement est véritablement exceptionnel et indique une erreur (telle qu'une fin de fichier inattendue).</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>When you use exception handling, less code is executed in normal conditions.</source>
          <target state="translated">Lorsque vous utilisez la gestion des exceptions, la quantité de code exécutée en situation normale est moindre.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Check for error conditions in code if the event happens routinely and could be considered part of normal execution.</source>
          <target state="translated">Recherchez les conditions d’erreur dans le code si l’événement se produit régulièrement et peut être considéré comme faisant partie de l’exécution normale.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>When you check for common error conditions, less code is executed because you avoid exceptions.</source>
          <target state="translated">Quand vous recherchez les conditions d’erreur courantes, vous exécutez moins de code, car vous évitez les exceptions.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Design classes so that exceptions can be avoided</source>
          <target state="translated">Concevoir des classes pour éviter les exceptions</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>A class can provide methods or properties that enable you to avoid making a call that would trigger an exception.</source>
          <target state="translated">Une classe peut fournir des méthodes ou propriétés qui vous permettent d’éviter d’effectuer un appel susceptible de déclencher une exception.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>For example, a <ph id="ph1">@System.IO.FileStream</ph> class provides methods that help determine whether the end of the file has been reached.</source>
          <target state="translated">Par exemple, une classe <ph id="ph1">@System.IO.FileStream</ph> fournit des méthodes qui permettent de déterminer si la fin du fichier a été atteinte.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>These can be used to avoid the exception that is thrown if you read past the end of the file.</source>
          <target state="translated">Ces méthodes peuvent servir à éviter l’exception qui est levée si vous dépassez la fin du fichier pendant la lecture.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The following example shows how to read to the end of a file without triggering an exception.</source>
          <target state="translated">L’exemple suivant montre comment lire un fichier jusqu’à la fin sans lever d’exception.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Another way to avoid exceptions is to return null for extremely common error cases instead of throwing an exception.</source>
          <target state="translated">Un autre moyen d’éviter les exceptions est de retourner Null pour les cas d’erreur très répandus au lieu de lever une exception.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>An extremely common error case can be considered normal flow of control.</source>
          <target state="translated">Un cas d'erreur très répandu peut être considéré comme un flux de contrôle normal.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>By returning null in these cases, you minimize the performance impact to an app.</source>
          <target state="translated">En retournant null dans ces cas-là, vous réduisez l'impact sur les performances d'une application.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Throw exceptions instead of returning an error code</source>
          <target state="translated">Lever des exceptions au lieu de retourner un code d’erreur</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Exceptions ensure that failures do not go unnoticed because calling code didn't check a return code.</source>
          <target state="translated">Les exceptions font en sorte que les échecs ne passent pas inaperçus parce que l’appel du code n’a pas vérifié le code de retour.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Use the predefined .NET exception types</source>
          <target state="translated">Utiliser les types d’exception .NET prédéfinis</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Introduce a new exception class only when a predefined one doesn't apply.</source>
          <target state="translated">N'introduisez une nouvelle classe d'exception que quand aucune classe d'exception prédéfinie ne s'applique.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Par exemple :</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Throw an <ph id="ph1">@System.InvalidOperationException</ph> exception if a property set or method call is not appropriate given the object's current state.</source>
          <target state="translated">Levez une exception <ph id="ph1">@System.InvalidOperationException</ph> si un appel de jeu de propriétés ou de méthode n'est pas approprié étant donné l'état actuel de l'objet.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Throw an <ph id="ph1">@System.ArgumentException</ph> exception or one of the predefined classes that derive from <ph id="ph2">@System.ArgumentException</ph> if invalid parameters are passed.</source>
          <target state="translated">Levez une exception <ph id="ph1">@System.ArgumentException</ph> ou l’une des classes prédéfinies qui dérivent de <ph id="ph2">@System.ArgumentException</ph> si des paramètres non valides sont passés.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>End exception class names with the word <ph id="ph1">`Exception`</ph></source>
          <target state="translated">Terminer les noms de classes d’exception par le mot <ph id="ph1">`Exception`</ph></target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>When a custom exception is necessary, name it appropriately and derive it from the <ph id="ph1">@System.Exception</ph> class.</source>
          <target state="translated">Quand une exception personnalisée est nécessaire, nommez-la de manière appropriée et dérivez-la de la classe <ph id="ph1">@System.Exception</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Par exemple :</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Include three constructors in custom exception classes</source>
          <target state="translated">Inclure trois constructeurs dans des classes d’exception personnalisées</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Use at least the three common constructors when creating your own exception classes: the default constructor, a constructor that takes a string message, and a constructor that takes a string message and an inner exception.</source>
          <target state="translated">Utilisez au moins les trois constructeurs communs pendant la création de vos propres classes d’exception : le constructeur par défaut, un constructeur qui prend un message de type chaîne et un constructeur qui prend un message de type chaîne et une exception interne.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Exception.%23ctor,</ph> which uses default values.</source>
          <target state="translated"><ph id="ph1">@System.Exception.%23ctor,</ph>, qui utilise les valeurs par défaut.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Exception.%23ctor(System.String),</ph> which accepts a string message.</source>
          <target state="translated"><ph id="ph1">@System.Exception.%23ctor(System.String),</ph>, qui accepte un message de type chaîne.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Exception.%23ctor(System.String,System.Exception),</ph> which accepts a string message and an inner exception.</source>
          <target state="translated"><ph id="ph1">@System.Exception.%23ctor(System.String,System.Exception),</ph>, qui accepte un message de type chaîne et une exception interne.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>For an example, see <bpt id="p1">[</bpt>How to: Create User-Defined Exceptions<ept id="p1">](#how-to-create-user-defined-exceptions)</ept>.</source>
          <target state="translated">Pour obtenir un exemple, consultez <bpt id="p1">[</bpt>Guide pratique : créer des exceptions définies par l’utilisateur<ept id="p1">](#how-to-create-user-defined-exceptions)</ept>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Ensure that exception data is available when code executes remotely</source>
          <target state="translated">Vérifier que les données d’exception sont disponibles quand le code s’exécute à distance</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>When you create user-defined exceptions, ensure that the metadata for the exceptions is available to code that is executing remotely.</source>
          <target state="translated">Quand vous créez des exceptions définies par l’utilisateur, vous devez vérifier que les métadonnées des exceptions sont disponibles pour le code qui s’exécute à distance.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example, on .NET runtimes that implement App Domains, exceptions may occur across App domains.</source>
          <target state="translated">Par exemple, sur les runtimes .NET qui implémentent des domaines d’application, des exceptions peuvent se produire entre domaines d’application.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Suppose App Domain A creates App Domain B, which executes code that throws an exception.</source>
          <target state="translated">Supposons que le domaine d’application A crée le domaine d’application B, lequel exécute du code qui lève une exception.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>For App Domain A to properly catch and handle the exception, it must be able to find the assembly that contains the exception thrown by App Domain B. If App Domain B throws an exception that is contained in an assembly under its application base, but not under App Domain A's application base, App Domain A will not be able to find the exception, and the common language runtime will throw a <ph id="ph1">@System.IO.FileNotFoundException</ph> exception.</source>
          <target state="translated">Pour que le domaine d’application A intercepte et gère l’exception correctement, il doit pouvoir trouver l’assembly qui contient l’exception levée par le domaine d’application B. Si le domaine d’application B lève une exception qui est contenue dans un assembly sous sa base d’application, mais pas sous la base d’application du domaine d’application A, le domaine d’application A ne peut pas trouver l’exception et le Common Language Runtime lève une exception <ph id="ph1">@System.IO.FileNotFoundException</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>To avoid this situation, you can deploy the assembly that contains the exception information in two ways:</source>
          <target state="translated">Pour éviter cette situation, vous pouvez déployer l'assembly qui contient les informations sur les exceptions de deux façons :</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Put the assembly into a common application base shared by both app domains.</source>
          <target state="translated">Placez l'assembly dans une base d'application commune partagée par les deux domaines d'application.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> ou -</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>If the domains do not share a common application base, sign the assembly that contains the exception information with a strong name and deploy the assembly into the global assembly cache.</source>
          <target state="translated">Si les domaines ne partagent pas une base d'application commune, signez l'assembly qui contient les informations sur les exceptions à l'aide d'un nom fort et déployez l'assembly dans le Global Assembly Cache.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Include a localized description string in every exception</source>
          <target state="translated">Inclure une chaîne de description localisée dans chaque exception</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The error message that the user sees is derived from the description string of the exception that was thrown, and not from the name of the exception class.</source>
          <target state="translated">Le message d’erreur que l’utilisateur voit est dérivé de la chaîne de description de l’exception qui a été levée et non du nom de la classe d’exception.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Use grammatically correct error messages</source>
          <target state="translated">Utiliser des messages d’erreur grammaticalement corrects</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Write clear sentences and include ending punctuation.</source>
          <target state="translated">Écrivez des phrases claires et insérez une ponctuation finale.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Each sentence in a description string of an exception should end in a period.</source>
          <target state="translated">Chaque phrase de la chaîne de description d'une exception doit se terminer par un point.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>For example, "The log table has overflowed.”</source>
          <target state="translated">Par exemple, « La table du journal a débordé. »</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>would be an appropriate description string.</source>
          <target state="translated">est une chaîne de description appropriée.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>In custom exceptions, provide additional properties as needed</source>
          <target state="translated">Dans les exceptions personnalisées, fournir des propriétés supplémentaires si nécessaire</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Provide additional properties for an exception (in addition to the description string) only when there's a programmatic scenario where the additional information is useful.</source>
          <target state="translated">Fournissez des propriétés supplémentaires (autres que la chaîne de description) pour une exception uniquement s'il existe un scénario par programmation dans lequel les informations supplémentaires sont utiles.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">@System.IO.FileNotFoundException</ph> provides the <ph id="ph2">@System.IO.FileNotFoundException.FileName</ph> property.</source>
          <target state="translated">Par exemple, la classe <ph id="ph1">@System.IO.FileNotFoundException</ph> fournit la propriété <ph id="ph2">@System.IO.FileNotFoundException.FileName</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Place throw statements so that the stack trace will be helpful</source>
          <target state="translated">Placer des instructions throw pour que la trace de la pile soit utile</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The stack trace begins at the statement where the exception is thrown and ends at the <ph id="ph1">`catch`</ph> statement that catches the exception.</source>
          <target state="translated">La trace de la pile commence à l'instruction où l'exception est levée et se termine à l'instruction <ph id="ph1">`catch`</ph> qui intercepte l'exception.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Use exception builder methods</source>
          <target state="translated">Utiliser des méthodes de générateur d’exceptions</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>It is common for a class to throw the same exception from different places in its implementation.</source>
          <target state="translated">Il est fréquent qu'une classe lève la même exception à partir de différents endroits de son implémentation.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>To avoid excessive code, use helper methods that create the exception and return it.</source>
          <target state="translated">Pour éviter un excès de code, utilisez des méthodes d'assistance qui créent une exception et la retournent.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Exemple :</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In some cases, it's more appropriate to use the exception's constructor to build the exception.</source>
          <target state="translated">Dans certains cas, il est plus approprié d’utiliser le constructeur de l’exception pour générer l’exception.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>An example is a global exception class such as <ph id="ph1">@System.ArgumentException,</ph></source>
          <target state="translated">Par exemple, une classe d’exception globale comme <ph id="ph1">@System.ArgumentException,</ph></target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Clean up intermediate results when throwing an exception</source>
          <target state="translated">Nettoyer les résultats intermédiaires quand vous levez une exception</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Callers should be able to assume that there are no side effects when an exception is thrown from a method.</source>
          <target state="translated">Les appelants doivent supposer qu'il n'y a aucun effet secondaire quand une exception est levée à partir d'une méthode.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>For example, if you have code that transfers money by withdrawing from one account and depositing in another account, and an exception is thrown while executing the deposit, you don't want the withdrawal to remain in effect.</source>
          <target state="translated">Par exemple, si vous avez du code qui transfère de l’argent en le retirant d’un compte pour le déposer dans un autre, et qu’une exception est levée pendant l’exécution du transfert, vous ne voulez pas que le retrait reste en vigueur.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>One way to handle this situation is to catch any exceptions thrown by the deposit transaction and roll back the withdrawal.</source>
          <target state="translated">Pour gérer cette situation, vous pouvez intercepter toutes les exceptions levées par la transaction de dépôt et annuler le retrait.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>This example illustrates the use of <ph id="ph1">`throw`</ph> to re-throw the original exception, which can make it easier for callers to see the real cause of the problem without having to examine the <ph id="ph2">@System.Exception.InnerException</ph> property.</source>
          <target state="translated">Cet exemple illustre l’utilisation de <ph id="ph1">`throw`</ph> pour lever de nouveau l’exception d’origine, ce qui peut permettre aux appelants de voir plus facilement la véritable cause du problème sans avoir à examiner la propriété <ph id="ph2">@System.Exception.InnerException</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>An alternative is to throw a new exception and include the original exception as the inner exception:</source>
          <target state="translated">Vous pouvez aussi lever une nouvelle exception et inclure l’exception d’origine comme exception interne :</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>To learn more about how exceptions work in .NET, see <bpt id="p1">[</bpt>What Every Dev needs to Know About Exceptions in the Runtime<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/exceptions.md)</ept>.</source>
          <target state="translated">Pour en savoir plus sur le fonctionnement des exceptions dans .NET, consultez <bpt id="p1">[</bpt>What Every Dev needs to Know About Exceptions in the Runtime<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/exceptions.md)</ept> (Tout ce que doit savoir un développeur sur les exceptions dans le runtime).</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>