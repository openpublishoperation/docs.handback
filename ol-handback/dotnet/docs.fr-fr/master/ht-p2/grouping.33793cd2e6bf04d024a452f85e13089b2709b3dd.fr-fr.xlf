<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d27c8c68ea49f150fa0ae5c5c8b437c8c42c9c90</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\grouping.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2017a86039e285c3f7e84539ab1e03b25993ee39</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7b92eefc164c45f986532643547fc46ea2def520</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">Constructions de regroupement dans les expressions régulières</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">Constructions de regroupement dans les expressions régulières</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">Constructions de regroupement dans les expressions régulières</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</source>
          <target state="translated">Les constructions de regroupement délimitent les sous-expressions d'une expression régulière et capturent les sous-chaînes d'une chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can use grouping constructs to do the following:</source>
          <target state="translated">Utilisez les constructions de regroupement pour effectuer les opérations suivantes :</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Match a subexpression that is repeated in the input string.</source>
          <target state="translated">Mettre en correspondance une sous-expression qui est répétée dans la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Apply a quantifier to a subexpression that has multiple regular expression language elements.</source>
          <target state="translated">Appliquer un quantificateur à une sous-expression qui possède plusieurs éléments de langage d'expression régulière.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more information about quantifiers, see <bpt id="p1">[</bpt>Quantifiers in regular expressions<ept id="p1">](quantifiers.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les quantificateurs, consultez <bpt id="p1">[</bpt>Quantificateurs dans les expressions régulières<ept id="p1">](quantifiers.md)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Include a subexpression in the string that is returned by the <bpt id="p1">[</bpt>Regex.Replace<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> and <bpt id="p2">[</bpt>Match.Result<ept id="p2">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> methods.</source>
          <target state="translated">Inclure une sous-expression dans la chaîne retournée par les méthodes <bpt id="p1">[</bpt>Regex.Replace<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> et <bpt id="p2">[</bpt>Match.Result<ept id="p2">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Retrieve individual subexpressions from the <bpt id="p1">[</bpt>Match.Groups<ept id="p1">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property and process them separately from the matched text as a whole.</source>
          <target state="translated">Récupérer des sous-expressions spécifiques de la propriété <bpt id="p1">[</bpt>Match.Groups<ept id="p1">](xref:System.Text.RegularExpressions.Match.Groups)</ept> et les traiter séparément du texte global mis en correspondance.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following table lists the grouping constructs supported by .NET regular expression engine and indicates whether they are capturing or non-capturing.</source>
          <target state="translated">Le tableau suivant répertorie les constructions de regroupement prises en charge par le moteur d’expression régulière de .NET et indique si ce sont des constructions avec ou sans capture.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Grouping construct</source>
          <target state="translated">Construction de regroupement</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Capturing or noncapturing</source>
          <target state="translated">Avec ou sans capture</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Matched subexpressions<ept id="p1">](#matched-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Sous-expressions mises en correspondance<ept id="p1">](#matched-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">Capture</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Named matched subexpressions<ept id="p1">](#named-matched-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Sous-expressions mises en correspondance nommées<ept id="p1">](#named-matched-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">Capture</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Balancing group definitions<ept id="p1">](#balancing-group-definitions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Définitions de groupe d’équilibrage<ept id="p1">](#balancing-group-definitions)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">Capture</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Noncapturing groups<ept id="p1">](#noncapturing-groups)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Groupes sans capture<ept id="p1">](#noncapturing-groups)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Sans capture</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Group options<ept id="p1">](#group-options)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Options de groupe<ept id="p1">](#group-options)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Sans capture</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width positive lookahead assertions<ept id="p1">](#zero-width-positive-lookahead-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Assertions de préanalyse positive de largeur nulle<ept id="p1">](#zero-width-positive-lookahead-assertions)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Sans capture</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width negative lookahead assertions<ept id="p1">](#zero-width-negative-lookahead-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Assertions de préanalyse négative de largeur nulle<ept id="p1">](#zero-width-negative-lookahead-assertions)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Sans capture</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width positive lookbehind assertions<ept id="p1">](#zero-width-positive-lookbehind-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Assertions de postanalyse positive de largeur nulle<ept id="p1">](#zero-width-positive-lookbehind-assertions)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Sans capture</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width negative lookbehind assertions<ept id="p1">](#zero-width-negative-lookbehind-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Assertions de postanalyse négative de largeur nulle<ept id="p1">](#zero-width-negative-lookbehind-assertions)</ept></target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Sans capture</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nonbacktracking subexpressions<ept id="p1">](#nonbacktracking-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Sous-expressions non rétroactives<ept id="p1">](#nonbacktracking-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Sans capture</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For information on groups and the regular expression object model, see <bpt id="p1">[</bpt>Grouping Constructs and Regular Expression Objects<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les groupes et le modèle objet d’expression régulière, consultez <bpt id="p1">[</bpt>Constructions de regroupement et objets d’expression régulière<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Matched subexpressions</source>
          <target state="translated">Sous-expressions mises en correspondance</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following grouping construct captures a matched subexpression:</source>
          <target state="translated">La construction de regroupement suivante capture une sous-expression mise en correspondance :</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">où <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> représente un modèle d’expression régulière valide.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</source>
          <target state="translated">Les captures qui utilisent des parenthèses sont numérotées automatiquement de la gauche vers la droite en fonction de l'ordre des parenthèses ouvrantes dans l'expression régulière, à partir de 1.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The capture that is numbered zero is the text matched by the entire regular expression pattern.</source>
          <target state="translated">La capture numérotée 0 représente le texte mis en correspondance par le modèle d’expression régulière entier.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>By default, the (subexpression) language element captures the matched subexpression.</source>
          <target state="translated">Par défaut, l’élément de langage (sous-expression) capture la sous-expression mise en correspondance.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>But if the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression (see Group options later in this topic), the matched subexpression is not captured.</source>
          <target state="translated">Toutefois, si le paramètre RegexOptions d’une méthode de mise en correspondance de modèle d’expression régulière comprend l’indicateur RegexOptions.ExplicitCapture ou que l’option n est appliquée à cette sous-expression (voir Options de groupe plus loin dans cette rubrique), la sous-expression mise en correspondance n’est pas capturée.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can access captured groups in four ways:</source>
          <target state="translated">Vous pouvez accéder aux groupes capturés de quatre façons :</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>By using the backreference construct within the regular expression.</source>
          <target state="translated">En utilisant la construction de référence arrière dans l'expression régulière.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept>, where <ept id="p1">*</ept>number* is the ordinal number of the captured subexpression.</source>
          <target state="translated">La sous-expression mise en correspondance est référencée dans la même expression régulière en utilisant la syntaxe <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>nombre<ept id="p3">_</ept>, où <ept id="p1">*</ept>nombre* est le nombre ordinal de la sous-expression capturée.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>By using the named backreference construct within the regular expression.</source>
          <target state="translated">En utilisant la construction de référence arrière nommée dans l'expression régulière.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, where <bpt id="p4">*</bpt>name<ept id="p4">*</ept> is the name of a capturing group, or <bpt id="p5">**</bpt>\k<ept id="p5">**</ept><bpt id="p6">_</bpt>&lt;number<ept id="p6">_</ept><bpt id="p7">**</bpt><ph id="ph2">&gt;</ph><ept id="p7">**</ept>, where <bpt id="p8">*</bpt>number<ept id="p8">*</ept> is the ordinal number of a capturing group.</source>
          <target state="translated">La sous-expression mise en correspondance est référencée dans la même expression régulière en utilisant la syntaxe<bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>nom<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, où <bpt id="p4">*</bpt>nom<ept id="p4">*</ept> est le nom d’un groupe de capture, ou la syntaxe <bpt id="p5">**</bpt>\k<ept id="p5">**</ept><bpt id="p6">_</bpt>&lt;nombre<ept id="p6">_</ept><bpt id="p7">**</bpt><ph id="ph2">&gt;</ph><ept id="p7">**</ept>, où <bpt id="p8">*</bpt>nombre<ept id="p8">*</ept> est le nombre ordinal d’un groupe de capture.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A capturing group has a default name that is identical to its ordinal number.</source>
          <target state="translated">Un groupe de capture possède un nom par défaut qui est identique à son nombre ordinal.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For more information, see Grouping constructs and regular expression objects later in this topic.</source>
          <target state="translated">Pour plus d’informations, consultez « Constructions de regroupement et objets d’expression régulière » plus loin dans cette rubrique.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> replacement sequence in a <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p5">*</bpt>number<ept id="p5">*</ept> is the ordinal number of the captured subexpression.</source>
          <target state="translated">En utilisant la séquence de remplacement <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>nombre<ept id="p2">_</ept> dans un appel de méthode <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> ou <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept>, où <bpt id="p5">*</bpt>nombre<ept id="p5">*</ept> est le nombre ordinal de la sous-expression capturée.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Programmatically, by using the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">Par programmation, en utilisant l’objet <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> retourné par la propriété <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The member at position zero in the collection represents the entire regular expression match.</source>
          <target state="translated">Le membre situé à la position zéro dans la collection représente la correspondance de l’expression régulière entière.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Each subsequent member represents a matched subexpression.</source>
          <target state="translated">Chaque membre suivant représente une sous-expression mise en correspondance.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Grouping Constructs and Regular Expression Objects<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept> section.</source>
          <target state="translated">Pour plus d’informations, consultez la section <bpt id="p1">[</bpt>Constructions de regroupement et objets d’expression régulière<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that identifies duplicated words in text.</source>
          <target state="translated">L'exemple suivant illustre une expression régulière qui identifie des mots en double dans le texte.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</source>
          <target state="translated">Les deux groupes de capture du modèle d'expression régulière représentent les deux instances du mot en double.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The second instance is captured to report its starting position in the input string.</source>
          <target state="translated">La capture de la seconde instance permet d'indiquer la position de départ du mot dans la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is the following:</source>
          <target state="translated">Le modèle d'expression régulière est le suivant :</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">Le tableau suivant montre comment le modèle d'expression régulière est interprété.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Il s'agit du premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Mettre en correspondance un espace blanc.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Match the string in the first captured group.</source>
          <target state="translated">Mettre en correspondance la chaîne dans le premier groupe capturé.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">Il s'agit du deuxième groupe de capture.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the <ph id="ph1">`Match.Index`</ph> property.</source>
          <target state="translated">L'exemple l'affecte à un groupe capturé pour que la position de départ du mot en double puisse être récupérée de la propriété <ph id="ph1">`Match.Index`</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Match a non-word character, including white space and punctuation.</source>
          <target state="translated">Mettre en correspondance un caractère n'appartenant pas à un mot, comme un espace blanc ou un signe de ponctuation.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</source>
          <target state="translated">Cela empêche le modèle d'expression régulière de mettre en correspondance un mot qui commence par le mot récupéré du premier groupe capturé.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Named matched subexpressions</source>
          <target state="translated">Sous-expressions mises en correspondance nommées</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following grouping construct captures a matched subexpression and lets you access it by name or by number:</source>
          <target state="translated">La construction de regroupement suivante capture une sous-expression mise en correspondance et vous permet d'y accéder à partir d'un nom ou d'un nombre :</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">ou :</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is a valid group name, and <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">où <bpt id="p1">*</bpt>name<ept id="p1">*</ept> est un nom de groupe valide, et <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> représente un modèle d’expression régulière valide.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>name<ept id="p1">*</ept> must not contain any punctuation characters and cannot begin with a number.</source>
          <target state="translated"><bpt id="p1">*</bpt>name<ept id="p1">*</ept> ne doit pas contenir de caractères de ponctuation et ne peut pas commencer par un nombre.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> parameter of a regular expression pattern matching method includes the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> flag, or if the <bpt id="p3">**</bpt>n<ept id="p3">**</ept> option is applied to this subexpression (see <bpt id="p4">[</bpt>Group options<ept id="p4">](#group-options)</ept> later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</source>
          <target state="translated">Si le paramètre <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> d’une méthode de mise en correspondance de modèle d’expression régulière comprend l’indicateur <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> ou que l’option <bpt id="p3">**</bpt>n<ept id="p3">**</ept> est appliquée à cette sous-expression (voir <bpt id="p4">[</bpt>Options de groupe<ept id="p4">](#group-options)</ept> plus loin dans cette rubrique), la seule façon de capturer une sous-expression consiste à nommer explicitement des groupes de capture.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can access named captured groups in the following ways:</source>
          <target state="translated">Vous pouvez accéder aux groupes capturés nommés comme suit :</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>By using the named backreference construct within the regular expression.</source>
          <target state="translated">En utilisant la construction de référence arrière nommée dans l'expression régulière.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, where <bpt id="p4">*</bpt>name<ept id="p4">*</ept> is the name of the captured subexpression.</source>
          <target state="translated">La sous-expression mise en correspondance est référencée dans la même expression régulière en utilisant la syntaxe <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>nom<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, où <bpt id="p4">*</bpt>nom<ept id="p4">*</ept> est le nom de la sous-expression capturée.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>By using the backreference construct within the regular expression.</source>
          <target state="translated">En utilisant la construction de référence arrière dans l'expression régulière.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept>, where <ept id="p1">*</ept>number* is the ordinal number of the captured subexpression.</source>
          <target state="translated">La sous-expression mise en correspondance est référencée dans la même expression régulière en utilisant la syntaxe <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>nombre<ept id="p3">_</ept>, où <ept id="p1">*</ept>nombre* est le nombre ordinal de la sous-expression capturée.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</source>
          <target state="translated">Les sous-expressions mises en correspondance nommées sont numérotées de manière consécutive de la gauche vers la droite après les sous-expressions mises en correspondance.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt>${<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> replacement sequence in a <bpt id="p4">[</bpt>Regex.Replace<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p5">[</bpt>Match.Result<ept id="p5">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p6">*</bpt>name<ept id="p6">*</ept> is the name of the captured subexpression.</source>
          <target state="translated">En utilisant la séquence de remplacement <bpt id="p1">**</bpt>${<ept id="p1">**</ept><bpt id="p2">_</bpt>nom<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> dans un appel de méthode <bpt id="p4">[</bpt>Regex.Replace<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> ou <bpt id="p5">[</bpt>Match.Result<ept id="p5">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept>, où <bpt id="p6">*</bpt>nom<ept id="p6">*</ept> est le nom de la sous-expression capturée.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> replacement sequence in a <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p5">*</bpt>number<ept id="p5">*</ept> is the ordinal number of the captured subexpression.</source>
          <target state="translated">En utilisant la séquence de remplacement <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>nombre<ept id="p2">_</ept> dans un appel de méthode <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> ou <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept>, où <bpt id="p5">*</bpt>nombre<ept id="p5">*</ept> est le nombre ordinal de la sous-expression capturée.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Programmatically, by using the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">Par programmation, en utilisant l’objet <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> retourné par la propriété <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The member at position zero in the collection represents the entire regular expression match.</source>
          <target state="translated">Le membre situé à la position zéro dans la collection représente la correspondance de l’expression régulière entière.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Each subsequent member represents a matched subexpression.</source>
          <target state="translated">Chaque membre suivant représente une sous-expression mise en correspondance.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Named captured groups are stored in the collection after numbered captured groups.</source>
          <target state="translated">Les groupes capturés nommés sont stockés dans la collection après les groupes capturés numérotés.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Programmatically, by providing the subexpression name to the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object's indexer  (in C#) or to its Item property (in Visual Basic).</source>
          <target state="translated">Par programmation, en fournissant le nom de la sous-expression à l’indexeur de l’objet <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> (en C#) ou à sa propriété Item (en Visual Basic).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</source>
          <target state="translated">Un modèle d’expression régulière simple permet d’illustrer comment les groupes numérotés (sans nom) et nommés peuvent être référencés par programmation ou à l’aide d’une syntaxe de langage d’expression régulière.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`((?&lt;One&gt;abc)\d+)?(?&lt;Two&gt;xyz)(.*)`</ph> produces the following capturing groups by number and by name.</source>
          <target state="translated">L’expression régulière <ph id="ph1">`((?&lt;One&gt;abc)\d+)?(?&lt;Two&gt;xyz)(.*)`</ph> génère les groupes de capture suivants en fonction du nombre et du nom.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The first capturing group (number 0) always refers to the entire pattern.</source>
          <target state="translated">Le premier groupe de capture (nombre 0) fait toujours référence au modèle entier.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Nombre</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Nom</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>0 (default name)</source>
          <target state="translated">0 (nom par défaut)</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>1 (default name)</source>
          <target state="translated">1 (nom par défaut)</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>2 (default name)</source>
          <target state="translated">2 (nom par défaut)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>One</source>
          <target state="translated">Un</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Two</source>
          <target state="translated">Deux</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</source>
          <target state="translated">L'exemple suivant illustre une expression régulière qui identifie les mots en double et le mot qui se trouve juste après chaque mot en double.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The regular expression pattern defines two named subexpressions: <ph id="ph1">`duplicateWord`</ph>, which represents the duplicated word; and <ph id="ph2">`nextWord`</ph>, which represents the word that follows the duplicated word.</source>
          <target state="translated">Le modèle d'expression régulière définit deux sous-expressions nommées : <ph id="ph1">`duplicateWord`</ph>, qui représente le mot en double, et <ph id="ph2">`nextWord`</ph>, qui représente le mot qui suit le mot en double.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is as follows:</source>
          <target state="translated">Le modèle d'expression régulière est le suivant :</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression is interpreted.</source>
          <target state="translated">Le tableau suivant montre comment l'expression régulière est interprétée.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`duplicateWord`</ph>.</source>
          <target state="translated">Nommer ce groupe de capture <ph id="ph1">`duplicateWord`</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Mettre en correspondance un espace blanc.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Match the string from the captured group that is named <ph id="ph1">`duplicateWord`</ph>.</source>
          <target state="translated">Mettre en correspondance la chaîne à partir du groupe capturé nommé <ph id="ph1">`duplicateWord`</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match a non-word character, including white space and punctuation.</source>
          <target state="translated">Mettre en correspondance un caractère n'appartenant pas à un mot, comme un espace blanc ou un signe de ponctuation.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</source>
          <target state="translated">Cela empêche le modèle d'expression régulière de mettre en correspondance un mot qui commence par le mot récupéré du premier groupe capturé.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`nextWord`</ph>.</source>
          <target state="translated">Nommer ce groupe de capture <ph id="ph1">`nextWord`</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Note that a group name can be repeated in a regular expression.</source>
          <target state="translated">Notez qu'un nom de groupe peut être répété dans une expression régulière.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>For example, it is possible for more than one group to be named <ph id="ph1">`digit`</ph>, as the following example illustrates.</source>
          <target state="translated">Par exemple, il est possible pour plusieurs groupes soient nommés <ph id="ph1">`digit`</ph>, comme le montre l'exemple suivant.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>In the case of duplicate names, the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object is determined by the last successful capture in the input string.</source>
          <target state="translated">Dans le cas de noms en doublon, la valeur de l’objet <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> est déterminée par la dernière capture réussie dans la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>In addition, the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> is populated with information about each capture just as it would be if the group name was not duplicated.</source>
          <target state="translated">En outre, la collection <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> est remplie avec des informations sur chaque capture, comme si le nom du groupe n’était pas en doublon.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression <ph id="ph1">`\D+(?&lt;digit&gt;\d+)\D+(?&lt;digit&gt;\d+)?`</ph> includes two occurrences of a group named <ph id="ph2">`digit`</ph>.</source>
          <target state="translated">Dans l'exemple suivant, l'expression régulière <ph id="ph1">`\D+(?&lt;digit&gt;\d+)\D+(?&lt;digit&gt;\d+)?`</ph> comprend deux occurrences d'un groupe nommé <ph id="ph2">`digit`</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The first <ph id="ph1">`digit`</ph> named group captures one or more digit characters.</source>
          <target state="translated">Le premier groupe nommé <ph id="ph1">`digit`</ph> capture un ou plusieurs caractères numériques.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The second <ph id="ph1">`digit`</ph> named group captures either zero or one occurrence of one or more digit characters.</source>
          <target state="translated">Le deuxième groupe nommé <ph id="ph1">`digit`</ph> capture zéro ou une occurrence d'un ou plusieurs caractères numériques.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object.</source>
          <target state="translated">Comme la sortie de l’exemple le montre, si le deuxième groupe de capture correspond à du texte, la valeur de ce texte définit la valeur de l’objet <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object.</source>
          <target state="translated">Si le deuxième groupe de capture ne correspond pas à la chaîne d’entrée, la valeur de la dernière correspondance définit la valeur de l’objet <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression is interpreted.</source>
          <target state="translated">Le tableau suivant montre comment l'expression régulière est interprétée.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Match one or more non-decimal digit characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères non décimaux.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digit characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères décimaux.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Assign the match to the <ph id="ph1">`digit`</ph> named group.</source>
          <target state="translated">Affecter la correspondance au groupe nommé <ph id="ph1">`digit`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Match one or more non-decimal digit characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères non décimaux.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of one or more decimal digit characters.</source>
          <target state="translated">Mettre en correspondance zéro ou une occurrence d'un ou plusieurs caractères numériques décimaux.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Assign the match to the <ph id="ph1">`digit`</ph> named group.</source>
          <target state="translated">Affecter la correspondance au groupe nommé <ph id="ph1">`digit`</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Balancing group definitions</source>
          <target state="translated">Définitions de groupe d'équilibrage</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</source>
          <target state="translated">Une définition de groupe d'équilibrage supprime la définition d'un groupe précédemment défini et stocke, dans le groupe actuel, l'intervalle entre le groupe précédemment défini et ce dernier.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>This grouping construct has the following format:</source>
          <target state="translated">Cette construction de regroupement se présente sous la forme suivante :</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">ou :</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> is the current group (optional), <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> is a previously defined group, and <bpt id="p3">*</bpt>subexpression<ept id="p3">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">où <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> est le groupe actuel (facultatif), <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> un groupe défini et <bpt id="p3">*</bpt>subexpression<ept id="p3">*</ept> un modèle d’expression régulière valide.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The balancing group definition deletes the definition of <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> and stores the interval between <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> and <bpt id="p3">*</bpt>name1<ept id="p3">*</ept> in <bpt id="p4">*</bpt>name1<ept id="p4">*</ept>.</source>
          <target state="translated">La définition de groupe d’équilibrage supprime la définition de <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> et stocke l’intervalle entre <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> et <bpt id="p3">*</bpt>name1<ept id="p3">*</ept> dans <bpt id="p4">*</bpt>name1<ept id="p4">*</ept>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>If no <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> group is defined, the match backtracks.</source>
          <target state="translated">Si aucun groupe <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> n’est défini, la recherche de correspondance s’effectue de façon rétroactive.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Because deleting the last definition of <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> reveals the previous definition of <bpt id="p2">*</bpt>name2<ept id="p2">*</ept>, this construct lets you use the stack of captures for group <bpt id="p3">*</bpt>name2<ept id="p3">*</ept> as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</source>
          <target state="translated">Comme la suppression de la dernière définition de <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> révèle la définition antérieure de <bpt id="p2">*</bpt>name2<ept id="p2">*</ept>, cette construction vous permet d’utiliser la pile de captures du groupe <bpt id="p3">*</bpt>name2<ept id="p3">*</ept> comme compteur pour effectuer le suivi des constructions imbriquées, telles que des parenthèses ou des crochets ouvrants et fermants.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The balancing group definition uses <bpt id="p1">*</bpt>name2<ept id="p1">*</ept>as a stack.</source>
          <target state="translated">La définition de groupe d’équilibrage utilise <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> comme pile.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The beginning character of each nested construct is placed in the group and in its <bpt id="p1">[</bpt>Group.Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collection.</source>
          <target state="translated">Le caractère initial de chaque construction imbriquée est placé dans le groupe et dans sa collection <bpt id="p1">[</bpt>Group.Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>When the closing character is matched, its corresponding opening character is removed from the group, and the <bpt id="p1">[</bpt>Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collection is decreased by one.</source>
          <target state="translated">Quand le caractère fermant est mis en correspondance, le caractère ouvrant correspondant est supprimé du groupe, et la collection <bpt id="p1">[</bpt>Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> est diminuée d’une unité.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>After the opening and closing characters of all nested constructs have been matched, <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> is empty.</source>
          <target state="translated">Une fois que les caractères ouvrant et fermant de toutes les constructions imbriquées ont été mis en correspondance, <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> est vide.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</source>
          <target state="translated">Une fois que vous avez modifié l'expression régulière dans l'exemple suivant pour utiliser les caractères ouvrant et fermant appropriés d'une construction imbriquée, vous pouvez l'utiliser pour gérer la plupart des constructions imbriquées, telles que les expressions mathématiques ou les lignes de code de programme qui comprennent plusieurs appels de méthode imbriqués.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The following example uses a balancing group definition to match left and right angle brackets (&lt;&gt;) in an input string.</source>
          <target state="translated">L'exemple suivant utilise une définition de groupe d'équilibrage pour mettre en correspondance les chevrons gauche et droit (&lt;&gt;) dans une chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The example defines two named groups, <ph id="ph1">`Open`</ph> and <ph id="ph2">`Close`</ph>, that are used like a stack to track matching pairs of angle brackets.</source>
          <target state="translated">L'exemple définit deux groupes nommés, <ph id="ph1">`Open`</ph> et <ph id="ph2">`Close`</ph>, qui sont utilisés comme une pile pour effectuer le suivi des paires de chevrons correspondantes.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Each captured left angle bracket is pushed into the capture collection of the <ph id="ph1">`Open`</ph> group, and each captured right angle bracket is pushed into the capture collection of the <ph id="ph2">`Close`</ph> group.</source>
          <target state="translated">Chaque chevron gauche capturé est placé dans la collection de captures du groupe <ph id="ph1">`Open`</ph>, tandis que chaque chevron droit capturé est placé dans la collection de captures du groupe <ph id="ph2">`Close`</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</source>
          <target state="translated">La définition de groupe d'équilibrage s'assure qu'à chaque chevron gauche correspond un chevron droit.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>If there is not, the final subpattern, <ph id="ph1">`(?(Open)(?!))`</ph>, is evaluated only if the <ph id="ph2">`Open`</ph> group is not empty (and, therefore, if all nested constructs have not been closed).</source>
          <target state="translated">Si tel n'est pas le cas, le sous-modèle final, <ph id="ph1">`(?(Open)(?!))`</ph>, n'est évalué que si le groupe <ph id="ph2">`Open`</ph> n'est pas vide (signe que toutes les constructions imbriquées n'ont pas été fermées).</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>If the final subpattern is evaluated, the match fails, because the <ph id="ph1">`(?!)`</ph> subpattern is a zero-width negative lookahead assertion that always fails.</source>
          <target state="translated">Si le sous-modèle final est évalué, la recherche de correspondance échoue, car le sous-modèle <ph id="ph1">`(?!)`</ph> est une assertion de préanalyse négative de largeur nulle qui échoue systématiquement.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is:</source>
          <target state="translated">Le modèle d'expression régulière est le suivant :</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The regular expression is interpreted as follows:</source>
          <target state="translated">L'expression régulière est interprétée comme suit :</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Begin at the start of the string.</source>
          <target state="translated">Commencer au début de la chaîne.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Match zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">Mettre en correspondance zéro caractère, ou plus, à l'exception des chevrons gauches ou droits.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Match a left angle bracket and assign it to a group named <ph id="ph1">`Open`</ph>.</source>
          <target state="translated">Mettre en correspondance un chevron gauche et l'affecter à un groupe nommé <ph id="ph1">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Match zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">Mettre en correspondance zéro caractère, ou plus, à l'exception des chevrons gauches ou droits.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">Mettre en correspondance une ou plusieurs occurrences d'un chevron gauche suivies de zéro caractère, ou plus, à l'exception des chevrons gauches ou droits.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">Il s'agit du deuxième groupe de capture.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Match a right angle bracket, assign the substring between the <ph id="ph1">`Open`</ph> group and the current group to the <ph id="ph2">`Close`</ph> group, and delete the definition of the <ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">Mettre en correspondance un chevron droit, affecter la sous-chaîne entre le groupe <ph id="ph1">`Open`</ph> et le groupe actuel au groupe <ph id="ph2">`Close`</ph>, puis supprimer la définition du groupe <ph id="ph3">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of any character that is neither a left nor a right angle bracket.</source>
          <target state="translated">Mettre en correspondance zéro occurrence, ou plus, d’un caractère à l’exception d’un chevron gauche ou droit.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</source>
          <target state="translated">Mettre en correspondance une occurrence, ou plus, d'un chevron droit, suivies de zéro occurrence, ou plus, d'un caractère à l'exception d'un chevron gauche ou droit.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>When matching the right angle bracket, assign the substring between the <ph id="ph1">`Open`</ph> group and the current group to the <ph id="ph2">`Close`</ph> group, and delete the definition of the<ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">Durant la mise en correspondance du chevron droit, affecter la sous-chaîne entre le groupe <ph id="ph1">`Open`</ph> et le groupe actuel au groupe <ph id="ph2">`Close`</ph>, puis supprimer la définition du groupe <ph id="ph3">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>This is the third capturing group.</source>
          <target state="translated">Il s'agit du troisième groupe de capture.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</source>
          <target state="translated">Mettre en correspondance zéro occurrence, ou plus, du modèle suivant : une ou plusieurs occurrences d'un chevron gauche, suivies de zéro caractère, ou plus, autre qu'un chevron, suivis d'une ou plusieurs occurrences d'un chevron droit, suivies de zéro caractère, ou plus, autre qu'un chevron.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>When matching the right angle bracket, delete the definition of the <ph id="ph1">`Open`</ph> group, and assign the substring between the <ph id="ph2">`Open`</ph> group and the current group to the <ph id="ph3">`Close`</ph> group.</source>
          <target state="translated">Durant la mise en correspondance du chevron droit, supprimer la définition du groupe <ph id="ph1">`Open`</ph> et affecter la sous-chaîne entre le groupe <ph id="ph2">`Open`</ph> et le groupe actuel au groupe <ph id="ph3">`Close`</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Il s'agit du premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Open`</ph> group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</source>
          <target state="translated">Si le groupe <ph id="ph1">`Open`</ph> existe, abandonner la recherche de correspondance si une chaîne vide peut être mise en correspondance, mais ne pas avancer la position du moteur d'expression régulière dans la chaîne.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>This is a zero-width negative lookahead assertion.</source>
          <target state="translated">Il s'agit d'une assertion de préanalyse négative de largeur nulle.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Because an empty string is always implicitly present in an input string, this match always fails.</source>
          <target state="translated">Comme une chaîne vide est toujours implicitement présente dans une chaîne d'entrée, cette recherche de correspondance échoue systématiquement.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Failure of this match indicates that the angle brackets are not balanced.</source>
          <target state="translated">L'échec de cette recherche de correspondance indique que les chevrons ne sont pas équilibrés.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Match the end of the input string.</source>
          <target state="translated">Mettre en correspondance la fin de la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The final subexpression, <ph id="ph1">`(?(Open)(?!))`</ph>, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</source>
          <target state="translated">La sous-expression finale, <ph id="ph1">`(?(Open)(?!))`</ph>, indique si les constructions d'imbrication dans la chaîne d'entrée sont correctement équilibrées (par exemple, si à chaque chevron gauche correspond un chevron droit).</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>It uses conditional matching based on a valid captured group; for more information, see <bpt id="p1">[</bpt>Alternation constructs in regular expressions<ept id="p1">](alternation.md)</ept>.</source>
          <target state="translated">Elle utilise une mise en correspondance conditionnelle basée sur un groupe capturé valide. Pour plus d’informations, consultez <bpt id="p1">[</bpt>Constructions d’alternative dans les expressions régulières<ept id="p1">](alternation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Open`</ph> group is defined, the regular expression engine attempts to match the subexpression <ph id="ph2">`(?!)`</ph> in the input string.</source>
          <target state="translated">Si le groupe <ph id="ph1">`Open`</ph> est défini, le moteur d'expression régulière essaie de mettre en correspondance la sous-expression <ph id="ph2">`(?!)`</ph> dans la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group should be defined only if nesting constructs are unbalanced.</source>
          <target state="translated">Le groupe <ph id="ph1">`Open`</ph> ne doit être défini que si les constructions d'imbrication ne sont pas équilibrées.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</source>
          <target state="translated">Le modèle à mettre en correspondance dans la chaîne d'entrée doit donc être un modèle qui entraîne systématiquement l'échec de la recherche de correspondance.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In this case, <ph id="ph1">`(?!)`</ph> is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</source>
          <target state="translated">Dans ce cas, <ph id="ph1">`(?!)`</ph> est une assertion de préanalyse négative de largeur nulle qui échoue systématiquement, car une chaîne vide est toujours implicitement présente à la position suivante dans la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>In the example, the regular expression engine evaluates the input string "<ph id="ph1">&lt;abc&gt;</ph>&lt;mno<ph id="ph2">&lt;xyz&gt;</ph>&gt;" as shown in the following table.</source>
          <target state="translated">Dans l’exemple, le moteur d’expression régulière évalue la chaîne d’entrée « <ph id="ph1">&lt;abc&gt;</ph>&lt;mno<ph id="ph2">&lt;xyz&gt;</ph>&gt; » comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Step</source>
          <target state="translated">Étape</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Résultat</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Starts the match at the beginning of the input string</source>
          <target state="translated">Commence la correspondance au début de la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters before the left angle bracket;finds no matches.</source>
          <target state="translated">Recherche des caractères autres que des chevrons avant le chevron gauche ; ne trouve aucune correspondance.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;abc&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">Met en correspondance le chevron gauche dans « <ph id="ph1">&lt;abc&gt;</ph> » et l’affecte au groupe <ph id="ph2">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Matches "abc".</source>
          <target state="translated">Met en correspondance « abc ».</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="translated">5</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>"&lt;abc" is the value of the second captured group.</source>
          <target state="translated">« &lt;abc » est la valeur du deuxième groupe capturé.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Le caractère suivant dans la chaîne d'entrée n'étant pas un chevron gauche, le moteur d'expression régulière ne repasse pas par le sous-modèle <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>6</source>
          <target state="translated">6</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Matches the right angle bracket in "<ph id="ph1">&lt;abc&gt;</ph>", assigns "abc", which is the substring between the <ph id="ph2">`Open`</ph> group and the right angle bracket, to the <ph id="ph3">`Close`</ph> group, and deletes the current value ("&lt;") of the <ph id="ph4">`Open`</ph> group, leaving it empty.</source>
          <target state="translated">Met en correspondance le chevron droit dans « <ph id="ph1">&lt;abc&gt;</ph> », affecte « abc », qui est la sous-chaîne entre le groupe <ph id="ph2">`Open`</ph> et le chevron droit, au groupe <ph id="ph3">`Close`</ph>, puis supprime la valeur actuelle (« &lt; ») du groupe <ph id="ph4">`Open`</ph>, qui se trouve alors vide.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>7</source>
          <target state="translated">7</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters after the right angle bracket; finds no matches.</source>
          <target state="translated">Recherche des caractères autres que des chevrons après le chevron droit ; ne trouve aucune correspondance.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>8</source>
          <target state="translated">8</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">La valeur du troisième groupe capturé est « &gt; ».</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Le caractère suivant dans la chaîne d'entrée n'étant pas un chevron droit, le moteur d'expression régulière ne repasse pas par le sous-modèle <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>9</source>
          <target state="translated">9</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The value of the first captured group is "<ph id="ph1">&lt;abc&gt;</ph>".</source>
          <target state="translated">La valeur du premier groupe capturé est « <ph id="ph1">&lt;abc&gt;</ph> ».</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The next character in the input string is a left angle bracket, so the regular expression engine loops back to the <ph id="ph1">`(((?'Open'&lt;)`</ph> subpattern.</source>
          <target state="translated">Le caractère suivant dans la chaîne d’entrée étant un chevron gauche, le moteur d’expression régulière repasse par le sous-modèle <ph id="ph1">`(((?'Open'&lt;)`</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>10</source>
          <target state="translated">10</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;mno&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">Met en correspondance le chevron gauche dans « <ph id="ph1">&lt;mno&gt;</ph> » et l’affecte au groupe <ph id="ph2">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`Group.Captures`</ph> collection now has a single value, "&lt;".</source>
          <target state="translated">Sa collection <ph id="ph1">`Group.Captures`</ph> ne possède maintenant qu'une valeur, en l'occurrence « &lt; ».</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>11</source>
          <target state="translated">11</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Matches "mno".</source>
          <target state="translated">Met en correspondance « mno ».</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>12</source>
          <target state="translated">12</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>"&lt;mno" is the value of the second captured group.</source>
          <target state="translated">« &lt;mno » est la valeur du deuxième groupe capturé.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The next character in the input string is an left angle bracket, so the regular expression engine loops back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Le caractère suivant dans la chaîne d'entrée étant un chevron gauche, le moteur d'expression régulière repasse par le sous-modèle <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>13</source>
          <target state="translated">13</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;xyz&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">Met en correspondance le chevron gauche dans « <ph id="ph1">&lt;xyz&gt;</ph> » et l’affecte au groupe <ph id="ph2">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Group.Captures`</ph> collection of the <ph id="ph2">`Open`</ph> group now includes two captures: the left angle bracket from "<ph id="ph3">&lt;mno&gt;</ph>", and the left angle bracket from "<ph id="ph4">&lt;xyz&gt;</ph>".</source>
          <target state="translated">La collection <ph id="ph1">`Group.Captures`</ph> du groupe <ph id="ph2">`Open`</ph> comprend maintenant deux captures : le chevron gauche dans « <ph id="ph3">&lt;mno&gt;</ph> » et le chevron gauche dans « <ph id="ph4">&lt;xyz&gt;</ph> ».</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Matches "xyz".</source>
          <target state="translated">Met en correspondance « xyz ».</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>"&lt;xyz" is the value of the second captured group.</source>
          <target state="translated">« &lt;xyz » est la valeur du deuxième groupe capturé.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Le caractère suivant dans la chaîne d'entrée n'étant pas un chevron gauche, le moteur d'expression régulière ne repasse pas par le sous-modèle <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Matches the right angle bracket in "<ph id="ph1">&lt;xyz&gt;</ph>".</source>
          <target state="translated">Met en correspondance le chevron droit dans « <ph id="ph1">&lt;xyz&gt;</ph> »,</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>"xyz", assigns the substring between the <ph id="ph1">`Open`</ph> group and the right angle bracket to the <ph id="ph2">`Close`</ph> group, and deletes the current value of the <ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">« xyz » affecte la sous-chaîne entre le groupe <ph id="ph1">`Open`</ph> et le chevron droit au groupe <ph id="ph2">`Close`</ph>, puis supprime la valeur actuelle du groupe <ph id="ph3">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The value of the previous capture (the left angle bracket in "<ph id="ph1">&lt;mno&gt;</ph>") becomes the current value of the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">La valeur de la capture précédente (le chevron gauche dans « <ph id="ph1">&lt;mno&gt;</ph> ») devient la valeur actuelle du groupe <ph id="ph2">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Captures`</ph> collection of the <ph id="ph2">`Open`</ph> group now includes a single capture, the left angle bracket from "<ph id="ph3">&lt;xyz&gt;</ph>".</source>
          <target state="translated">La collection <ph id="ph1">`Captures`</ph> du groupe <ph id="ph2">`Open`</ph> comprend maintenant une seule capture, en l’occurrence le chevron gauche dans « <ph id="ph3">&lt;xyz&gt;</ph> ».</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters; finds no matches.</source>
          <target state="translated">Recherche des caractères autres que des chevrons ; ne trouve aucune correspondance.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">La valeur du troisième groupe capturé est « &gt; ».</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The next character in the input string is a right angle bracket, so the regular expression engine loops back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Le caractère suivant dans la chaîne d'entrée étant un chevron droit, le moteur d'expression régulière repasse par le sous-modèle <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Matches the final right angle bracket in "xyz&gt;&gt;", assigns "mno<ph id="ph1">&lt;xyz&gt;</ph>" (the substring between the <ph id="ph2">`Open`</ph> group and the right angle bracket) to the <ph id="ph3">`Close`</ph> group, and deletes the current value of the <ph id="ph4">`Open`</ph> group.</source>
          <target state="translated">Met en correspondance le chevron droit final dans « xyz&gt;&gt; », affecte « mno<ph id="ph1">&lt;xyz&gt;</ph> » (la sous-chaîne entre le groupe <ph id="ph2">`Open`</ph> et le chevron droit) au groupe <ph id="ph3">`Close`</ph>, puis supprime la valeur actuelle du groupe <ph id="ph4">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group is now empty.</source>
          <target state="translated">Le groupe <ph id="ph1">`Open`</ph> est maintenant vide.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>20</source>
          <target state="translated">20</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters; finds no matches.</source>
          <target state="translated">Recherche des caractères autres que des chevrons ; ne trouve aucune correspondance.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>21</source>
          <target state="translated">21</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">La valeur du troisième groupe capturé est « &gt; ».</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Le caractère suivant dans la chaîne d'entrée n'étant pas un chevron droit, le moteur d'expression régulière ne repasse pas par le sous-modèle <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>22</source>
          <target state="translated">22</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The value of the first captured group is "&lt;mno<ph id="ph1">&lt;xyz&gt;</ph>&gt;".</source>
          <target state="translated">La valeur du premier groupe capturé est « &lt;mno<ph id="ph1">&lt;xyz&gt;</ph>&gt; ».</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(((?'Open'&lt;)`</ph> subpattern.</source>
          <target state="translated">Le caractère suivant dans la chaîne d'entrée n'étant pas un chevron gauche, le moteur d'expression régulière ne repasse pas par le sous-modèle <ph id="ph1">`(((?'Open'&lt;)`</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>23</source>
          <target state="translated">23</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group is not defined, so no match is attempted.</source>
          <target state="translated">Le groupe <ph id="ph1">`Open`</ph> n'étant pas défini, aucune recherche de correspondance n'est effectuée.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>24</source>
          <target state="translated">24</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Matches the end of the input string.</source>
          <target state="translated">Met en correspondance la fin de la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Noncapturing groups</source>
          <target state="translated">Groupes sans capture</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The following grouping construct does not capture the substring that is matched by a subexpression:</source>
          <target state="translated">La construction de regroupement suivante ne capture pas la sous-chaîne mise en correspondance par une sous-expression :</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">où <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> représente un modèle d’expression régulière valide.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</source>
          <target state="translated">En règle générale, la construction de groupe sans capture est utilisée quand un quantificateur est appliqué à un groupe, mais que les sous-chaînes capturées par celui-ci ne présentent aucun intérêt.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
          <target state="translated">Si une expression régulière comprend des constructions de regroupement imbriquées, une construction de groupe sans capture externe ne s'applique pas aux constructions de groupe imbriquées internes.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that includes noncapturing groups.</source>
          <target state="translated">L'exemple suivant illustre une expression régulière qui comprend des groupes sans capture.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Note that the output does not include any captured groups.</source>
          <target state="translated">Notez que la sortie ne comprend aucun groupe capturé.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`(?:\b(?:\w+)\W*)+\.`</ph> matches a sentence that is terminated by a period.</source>
          <target state="translated">L'expression régulière <ph id="ph1">`(?:\b(?:\w+)\W*)+\.`</ph> met en correspondance une phrase terminée par un point.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</source>
          <target state="translated">Comme l'expression régulière porte sur des phrases et non sur des mots spécifiques, les constructions de regroupement sont exclusivement utilisées en tant que quantificateurs.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière est interprété comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Do not assign the matched text to a captured group.</source>
          <target state="translated">Ne pas affecter le texte mis en correspondance à un groupe capturé.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Match zero or more non-word characters.</source>
          <target state="translated">Mettre en correspondance zéro ou plusieurs caractères non alphabétiques.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</source>
          <target state="translated">Mettre en correspondance le modèle d'un ou plusieurs caractères alphabétiques en commençant à la limite d'un mot, suivi de zéro caractère non alphabétique, ou plus, une ou plusieurs fois.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Do not assign the matched text to a captured group.</source>
          <target state="translated">Ne pas affecter le texte mis en correspondance à un groupe capturé.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Match a period.</source>
          <target state="translated">Mettre en correspondance un point.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Group options</source>
          <target state="translated">Options de groupe</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The following grouping construct applies or disables the specified options within a subexpression:</source>
          <target state="translated">La construction de regroupement suivante applique ou désactive les options spécifiées dans une sous-expression :</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">où <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> représente un modèle d’expression régulière valide.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`(?i-s:)`</ph> turns on case insensitivity and disables single-line mode.</source>
          <target state="translated">Par exemple, <ph id="ph1">`(?i-s:)`</ph> désactive la prise en compte des majuscules et des minuscules, ainsi que le mode à ligne simple.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>For more information about the inline options you can specify, see <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les options inline que vous pouvez spécifier, consultez <bpt id="p1">[</bpt>Options des expressions régulières<ept id="p1">](options.md)</ept>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>You can specify options that apply to an entire regular expression rather than a subexpression by using a <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or a static method.</source>
          <target state="translated">Vous pouvez spécifier des options qui s’appliquent à une expression régulière entière plutôt qu’à une sous-expression en utilisant un constructeur de classe <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> ou une méthode statique.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>You can also specify inline options that apply after a specific point in a regular expression by using the <ph id="ph1">`(?imnsx-imnsx)`</ph> language construct.</source>
          <target state="translated">Vous pouvez également spécifier des options inline qui s'appliquent après un point spécifique dans une expression régulière en utilisant la construction de langage <ph id="ph1">`(?imnsx-imnsx)`</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The group options construct is not a capturing group.</source>
          <target state="translated">La construction des options de groupe n'est pas un groupe de capture.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>That is, although any portion of a string that is captured by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is included in the match, it is not included in a captured group nor used to populate the <bpt id="p2">[</bpt>GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object.</source>
          <target state="translated">En d’autres termes, bien qu’une partie d’une chaîne capturée par <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> soit incluse dans la correspondance, elle n’est pas placée dans un groupe capturé, ni utilisée pour remplir l’objet <bpt id="p2">[</bpt>GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b(?ix: d \w+)\s `</ph>in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern whitespace in identifying all words that begin with the letter "d".</source>
          <target state="translated">Dans l’exemple suivant, l’expression régulière <ph id="ph1">`\b(?ix: d \w+)\s `</ph> utilise des options inline dans une construction de regroupement pour désactiver la prise en compte des majuscules et des minuscules et ignorer l’espace blanc du modèle durant l’identification de tous les mots commençant par la lettre « d ».</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>The regular expression is defined as shown in the following table.</source>
          <target state="translated">L'expression régulière est définie comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</source>
          <target state="translated">Sans prendre en compte les majuscules et les minuscules et en ignorant l'espace blanc dans ce modèle, mettre en correspondance un caractère « d » suivi d'un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Mettre en correspondance un espace blanc.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookahead assertions</source>
          <target state="translated">Assertions de préanalyse positive de largeur nulle</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width positive lookahead assertion:</source>
          <target state="translated">La construction de regroupement suivante définit une assertion de préanalyse positive de largeur nulle :</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><bpt id="p3">__</bpt>)<ept id="p3">__</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">*</bpt>sous-expression<ept id="p2">*</ept><bpt id="p3">__</bpt>)<ept id="p3">__</ept></target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">où <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> représente un modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>For a match to be successful, the input string must match the regular expression pattern in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, although the matched substring is not included in the match result.</source>
          <target state="translated">Pour qu’une recherche de correspondance réussisse, la chaîne d’entrée doit correspondre au modèle d’expression régulière dans <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept>, bien que la sous-chaîne mise en correspondance ne soit pas incluse dans le résultat de la recherche de correspondance.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookahead assertion does not backtrack.</source>
          <target state="translated">Une assertion de préanalyse positive de largeur nulle n'est pas rétroactive.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</source>
          <target state="translated">En règle générale, une assertion de préanalyse positive de largeur nulle est trouvée à la fin d'un modèle d'expression régulière.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</source>
          <target state="translated">Elle définit une sous-chaîne qui doit être trouvée à la fin d'une chaîne pour qu'une mise en correspondance se produise, mais qui ne doit pas être incluse dans la correspondance.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>It is also useful for preventing excessive backtracking.</source>
          <target state="translated">En outre, elle est utile pour empêcher une rétroactivité excessive.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</source>
          <target state="translated">Vous pouvez utiliser une assertion de préanalyse positive de largeur nulle indiquant qu'un groupe capturé particulier doit commencer par un texte qui correspond à une partie du modèle défini pour ce groupe.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</source>
          <target state="translated">Par exemple, si un groupe de capture met en correspondance des caractères alphabétiques consécutifs, vous pouvez utiliser une assertion de préanalyse positive de largeur nulle pour imposer que le premier caractère soit un caractère majuscule alphabétique.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</source>
          <target state="translated">L'exemple suivant utilise une assertion de préanalyse positive de largeur nulle pour mettre en correspondance le mot qui précède le verbe « is » dans la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>The regular expression \b\w+(?=\sis\b) is interpreted as shown in the following table.</source>
          <target state="translated">L’expression régulière \b\w+(?=\sis\b) est interprétée comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</source>
          <target state="translated">Détermine si les caractères alphabétiques sont suivis d'un espace blanc et de la chaîne « is », qui se termine à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>If so, the match is successful.</source>
          <target state="translated">Si tel est le cas, la recherche de correspondance réussit.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookahead assertions</source>
          <target state="translated">Assertions de préanalyse négative de largeur nulle</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width negative lookahead assertion:</source>
          <target state="translated">La construction de regroupement suivante définit une assertion de préanalyse négative de largeur nulle :</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">où <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> représente un modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For the match to be successful, the input string must not match the regular expression pattern in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, although the matched string is not included in the match result.</source>
          <target state="translated">Pour que la recherche de correspondance réussisse, la chaîne d’entrée ne doit pas correspondre au modèle d’expression régulière dans <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept>, bien que la chaîne mise en correspondance ne soit pas incluse dans le résultat de la recherche de correspondance.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</source>
          <target state="translated">En règle générale, une assertion de préanalyse négative de largeur nulle est utilisée au début ou à la fin d'une expression régulière.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</source>
          <target state="translated">Au début d'une expression régulière, elle peut définir un modèle spécifique qui ne doit pas être mis en correspondance quand le début de l'expression régulière définit un modèle de recherche de correspondance similaire, mais plus général.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>In this case, it is often used to limit backtracking.</source>
          <target state="translated">Dans ce cas, elle est souvent utilisée pour limiter la rétroactivité.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
          <target state="translated">À la fin d'une expression régulière, elle peut définir une sous-expression qui ne peut pas apparaître à la fin d'une correspondance.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</source>
          <target state="translated">L'exemple suivant définit une expression régulière qui utilise une assertion de préanalyse de largeur nulle au début de l'expression régulière pour mettre en correspondance les mots qui ne commencent pas par « un ».</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The regular expression \b(?!un)\w+\b is interpreted as shown in the following table.</source>
          <target state="translated">L’expression régulière \b(?!un)\w+\b est interprétée comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Determine whether the next two characters are "un".</source>
          <target state="translated">Déterminer si les deux caractères suivants sont « un ».</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>If they are not, a match is possible.</source>
          <target state="translated">Si tel n'est pas le cas, une correspondance est possible.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</source>
          <target state="translated">L'exemple suivant définit une expression régulière qui utilise une assertion de préanalyse de largeur nulle à la fin de l'expression régulière pour mettre en correspondance les mots qui ne se terminent pas par un caractère de ponctuation.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b\w+\b(?!\p{P})`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">L'expression régulière <ph id="ph1">`\b\w+\b(?!\p{P})`</ph> est interprétée comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</source>
          <target state="translated">Si le caractère suivant n'est pas un symbole de ponctuation (tel qu'un point ou une virgule), la recherche de correspondance réussit.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions</source>
          <target state="translated">Assertions de postanalyse positive de largeur nulle</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width positive lookbehind assertion:</source>
          <target state="translated">La construction de regroupement suivante définit une assertion de postanalyse positive de largeur nulle :</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;=<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;=<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">où <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> représente un modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>For a match to be successful, <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> must occur at the input string to the left of the current position, although subexpression is not included in the match result.</source>
          <target state="translated">Pour qu’une recherche de correspondance réussisse, <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> doit se trouver dans la chaîne d’entrée à gauche de la position actuelle, bien que la sous-expression ne soit pas incluse dans le résultat de la recherche de correspondance.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookbehind assertion does not backtrack.</source>
          <target state="translated">Une assertion de postanalyse positive de largeur nulle n'est pas rétroactive.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</source>
          <target state="translated">Les assertions de postanalyse positive de largeur nulle sont généralement utilisées au début des expressions régulières.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
          <target state="translated">Le modèle qu'elles définissent est une condition préalable pour une correspondance, bien qu'il ne fasse pas partie du résultat de la recherche de correspondance.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</source>
          <target state="translated">L'exemple suivant met en correspondance les deux derniers chiffres des années appartenant au vingt et unième siècle (en d'autres termes, les chiffres « 20 » doivent précéder la chaîne mise en correspondance).</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(?&lt;=\b20)\d{2}\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`(?&lt;=\b20)\d{2}\b`</ph> est interprété comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>Match two decimal digits.</source>
          <target state="translated">Mettre en correspondance deux chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</source>
          <target state="translated">Continuer la mise en correspondance si les deux chiffres décimaux sont précédés des chiffres décimaux « 20 » à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</source>
          <target state="translated">Les assertions de postanalyse positive de largeur nulle permettent également de limiter la rétroactivité quand le ou les derniers caractères d'un groupe capturé doivent être une partie des caractères qui correspondent au modèle d'expression régulière de ce groupe.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</source>
          <target state="translated">Par exemple, si un groupe capture tous les caractères alphabétiques consécutifs, vous pouvez utiliser une assertion de postanalyse positive de largeur nulle pour imposer que le dernier caractère soit un caractère alphabétique.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind assertions</source>
          <target state="translated">Assertions de postanalyse négative de largeur nulle</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width negative lookbehind assertion:</source>
          <target state="translated">La construction de regroupement suivante définit une assertion de postanalyse négative de largeur nulle :</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">où <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> représente un modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>For a match to be successful, <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> must not occur at the input string to the left of the current position.</source>
          <target state="translated">Pour qu’une recherche de correspondance réussisse, <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> ne doit pas se trouver dans la chaîne d’entrée à gauche de la position actuelle.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>However, any substring that does not match subexpression is not included in the match result.</source>
          <target state="translated">Toutefois, toute sous-chaîne qui ne correspond pas à la sous-expression est exclue du résultat de la recherche de correspondance.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</source>
          <target state="translated">Les assertions de postanalyse négative de largeur nulle sont généralement utilisées au début des expressions régulières.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>The pattern that they define precludes a match in the string that follows.</source>
          <target state="translated">Le modèle qu'elles définissent exclut une mise en correspondance dans la chaîne qui suit.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</source>
          <target state="translated">Elles permettent également de limiter la rétroactivité quand le ou les derniers caractères d'un groupe capturé ne doivent pas être un ou plusieurs des caractères qui correspondent au modèle d'expression régulière de ce groupe.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (_).</source>
          <target state="translated">Par exemple, si un groupe capture tous les caractères alphabétiques consécutifs, vous pouvez utiliser une assertion de postanalyse positive de largeur nulle pour imposer que le dernier caractère ne soit pas un caractère de soulignement (_).</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</source>
          <target state="translated">L'exemple suivant met en correspondance la date de n'importe quel jour de la semaine ne tombant pas pendant le week-end (c'est-à-dire, tous les jours sauf le samedi et le dimanche).</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(?&lt;!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`(?&lt;!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b`</ph> est interprété comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a white-space character.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques suivis d'un espace blanc.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Match either one or two decimal digits followed by a white-space character and a comma.</source>
          <target state="translated">Mettre en correspondance un ou deux chiffres décimaux suivis d'un espace blanc et d'une virgule.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Match four decimal digits, and end the match at a word boundary.</source>
          <target state="translated">Mettre en correspondance quatre chiffres décimaux, puis terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>`(?&lt;!(Saturday</source>
          <target state="translated">`(?&lt;!(Saturday</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Sunday) )`</source>
          <target state="translated">Sunday) )`</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</source>
          <target state="translated">Si la correspondance est précédée d'une chaîne autre que « Saturday » ou « Sunday » suivie d'un espace, la mise en correspondance réussit.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpressions</source>
          <target state="translated">Sous-expressions non rétroactives</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</source>
          <target state="translated">La construction de regroupement suivante représente une sous-expression non rétroactive (ou « gourmande ») :</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">où <bpt id="p1">*</bpt>sous-expression<ept id="p1">*</ept> représente un modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</source>
          <target state="translated">D’ordinaire, si une expression régulière comprend un modèle de mise en correspondance facultatif ou de substitution et qu’aucune mise en correspondance ne réussit, le moteur d’expression régulière peut explorer plusieurs directions pour mettre en correspondance une chaîne d’entrée avec un modèle.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</source>
          <target state="translated">Si aucune correspondance n'est trouvée au niveau de la première branche, le moteur d'expression régulière peut revenir au point d'exécution de la première mise en correspondance et renouveler l'opération au niveau de la deuxième branche.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>This process can continue until all branches have been tried.</source>
          <target state="translated">Ce processus peut se poursuivre jusqu’à ce que toutes les branches aient été essayées.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language construct disables backtracking.</source>
          <target state="translated">La construction de langage <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> désactive la rétroactivité.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>The regular expression engine will match as many characters in the input string as it can.</source>
          <target state="translated">Le moteur d'expression régulière met en correspondance tous les caractères possibles de la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>When no further match is possible, it will not backtrack to attempt alternate pattern matches.</source>
          <target state="translated">Quand aucune mise en correspondance supplémentaire n'est possible, il n'essaie pas d'effectuer une mise en correspondance de modèle de substitution de manière rétroactive.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</source>
          <target state="translated">(En d'autres termes, la sous-expression ne met en correspondance que les chaînes qu'elle seule peut mettre en correspondance ; elle n'essaie pas de mettre en correspondance une chaîne avec le concours de sous-expressions qui la suivent éventuellement.)</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>This option is recommended if you know that backtracking will not succeed.</source>
          <target state="translated">Cette option est recommandée si vous savez que la rétroactivité est vouée à l'échec.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>Preventing the regular expression engine from performing unnecessary searching improves performance.</source>
          <target state="translated">Empêcher le moteur d'expression régulière d'effectuer des recherches superflues améliore les performances.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</source>
          <target state="translated">L'exemple suivant montre comment une sous-expression non rétroactive modifie les résultats d'une mise en correspondance de modèle.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</source>
          <target state="translated">Contrairement à l'expression régulière non rétroactive, l'expression régulière rétroactive met en correspondance une série de caractères répétés suivis d'une occurrence supplémentaire du même caractère à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>The nonbacktracking regular expression <ph id="ph1">`(?&gt;(\w)\1+).\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">L'expression régulière non rétroactive <ph id="ph1">`(?&gt;(\w)\1+).\b`</ph> est définie comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Match a single word character and assign it to the first capturing group.</source>
          <target state="translated">Mettre en correspondance un seul caractère alphabétique et l'affecter au premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Match the value of the first captured substring one or more times.</source>
          <target state="translated">Mettre en correspondance la valeur de la première sous-chaîne capturée une ou plusieurs fois.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>Match any character.</source>
          <target state="translated">Mettre en correspondance n'importe quel caractère.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>End the match on a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</source>
          <target state="translated">Mettre en correspondance une ou plusieurs occurrences d'un caractère alphabétique en double, mais ne pas effectuer rétroactivement une mise en correspondance du dernier caractère à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Grouping constructs and regular expression objects</source>
          <target state="translated">Constructions de regroupement et objets d’expression régulière</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Substrings that are matched by a regular expression capturing group are represented by <bpt id="p1">[</bpt>System.Text.RegularExpressions.Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects, which can be retrieved from the <bpt id="p2">[</bpt>System.Text.RegularExpressions.GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object that is returned by the <bpt id="p3">[</bpt>Match.Groups<ept id="p3">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">Les sous-chaînes mises en correspondance par un groupe de capture d’expression régulière sont représentées par des objets <bpt id="p1">[</bpt>System.Text.RegularExpressions.Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>, qui peuvent être récupérés de l’objet <bpt id="p2">[</bpt>System.Text.RegularExpressions.GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> retourné par la propriété <bpt id="p3">[</bpt>Match.Groups<ept id="p3">](xref:System.Text.RegularExpressions.Match.Groups)</ept>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object is populated as follows:</source>
          <target state="translated">L’objet <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> est rempli comme suit :</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>The first <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object in the collection (the object at index zero) represents the entire match.</source>
          <target state="translated">Le premier objet <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> de la collection (l’objet d’index zéro) représente la correspondance entière.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>The next set of <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects represent unnamed (numbered) capturing groups.</source>
          <target state="translated">L’ensemble d’objets <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> suivant représente des groupes de capture sans nom (numérotés).</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>They appear in the order in which they are defined in the regular expression, from left to right.</source>
          <target state="translated">Ils apparaissent dans l'ordre dans lequel ils sont définis dans l'expression régulière, de la gauche vers la droite.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</source>
          <target state="translated">Les valeurs d'index de ces groupes vont de 1 au nombre de groupes de capture sans nom dans la collection.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>(The index of a particular group is equivalent to its numbered backreference.</source>
          <target state="translated">(L'index d'un groupe particulier est équivalent à sa référence arrière numérotée.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>For more information about backreferences, see <bpt id="p1">[</bpt>Backreference constructs in regular expressions<ept id="p1">](backreference.md)</ept></source>
          <target state="translated">Pour plus d’informations sur les références arrières, consultez <bpt id="p1">[</bpt>Constructions de backreference dans les expressions régulières<ept id="p1">](backreference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>The final set of <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects represent named capturing groups.</source>
          <target state="translated">Le dernier ensemble d’objets <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> représente des groupes de capture nommés.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>They appear in the order in which they are defined in the regular expression, from left to right.</source>
          <target state="translated">Ils apparaissent dans l'ordre dans lequel ils sont définis dans l'expression régulière, de la gauche vers la droite.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</source>
          <target state="translated">La valeur d'index du premier groupe de capture nommé est égale à l'index du dernier groupe de capture sans nom, plus une unité.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</source>
          <target state="translated">En l'absence de groupe de capture sans nom dans l'expression régulière, la valeur d'index du premier groupe de capture nommé est égale à un (1).</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>If you apply a quantifier to a capturing group, the corresponding <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object's <bpt id="p2">[</bpt>Capture.Value<ept id="p2">](xref:System.Text.RegularExpressions.Capture.Value)</ept>, <bpt id="p3">[</bpt>Capture.Index<ept id="p3">](xref:System.Text.RegularExpressions.Capture.Index)</ept>, and <bpt id="p4">[</bpt>Capture.Length<ept id="p4">](xref:System.Text.RegularExpressions.Capture.Length)</ept> properties reflect the last substring that is captured by a capturing group.</source>
          <target state="translated">Si vous appliquez un quantificateur à un groupe de capture, les propriétés s <bpt id="p2">[</bpt>Capture.Value<ept id="p2">](xref:System.Text.RegularExpressions.Capture.Value)</ept>, <bpt id="p3">[</bpt>Capture.Index<ept id="p3">](xref:System.Text.RegularExpressions.Capture.Index)</ept> et <bpt id="p4">[</bpt>Capture.Length<ept id="p4">](xref:System.Text.RegularExpressions.Capture.Length)</ept> de l’objet <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> correspondant reflètent la dernière sous-chaîne capturée par un groupe de capture.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object that is returned by the <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property.</source>
          <target state="translated">Vous pouvez récupérer de l’objet <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> retourné par la propriété <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> un ensemble complet de sous-chaînes capturées par des groupes possédant des quantificateurs.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>The following example clarifies the relationship between the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> and <bpt id="p2">[</bpt>Capture<ept id="p2">](xref:System.Text.RegularExpressions.Capture)</ept> objects.</source>
          <target state="translated">L’exemple suivant clarifie la relation entre les objets <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> et <bpt id="p2">[</bpt>Capture<ept id="p2">](xref:System.Text.RegularExpressions.Capture)</ept>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(\w+)\W+)+`</ph> extracts individual words from a string.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\b(\w+)\W+)+`</ph> extrait des mots spécifiques d'une chaîne.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
          <target state="translated">Il est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Together, these characters form a word.</source>
          <target state="translated">Ensemble, ces caractères forment un mot.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">Il s'agit du deuxième groupe de capture.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>Match one or more non-word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères non alphabétiques.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</source>
          <target state="translated">Mettre en correspondance le modèle d'un ou plusieurs caractères alphabétiques, suivis d'un ou plusieurs caractères non alphabétiques, une ou plusieurs fois.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Il s'agit du premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The first capturing group matches each word of the sentence.</source>
          <target state="translated">Le premier groupe de capture met en correspondance chaque mot de la phrase.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>The second capturing group matches each word along with the punctuation and white space that follow the word.</source>
          <target state="translated">Le second groupe de capture met en correspondance chaque mot, ainsi que la ponctuation et l'espace blanc qui suivent le mot.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object whose index is 2 provides information about the text matched by the second capturing group.</source>
          <target state="translated">L’objet <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> dont l’index a pour valeur 2 fournit des informations sur le texte mis en correspondance par le second groupe de capture.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The complete set of words captured by the capturing group are available from the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object returned by the <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property.</source>
          <target state="translated">Tous les mots capturés par le groupe de capture sont récupérables de l’objet <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> retourné par la propriété <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Langage des expressions régulières - Aide-mémoire<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking in regular expressions<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Retour sur trace dans les expressions régulières<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>