<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">47a407d1c1e768a027aaca63ee7a668e992467b2</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\language-independence.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2cd82917b5829a18453fc14cb36b156bb7d01cb4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">53915650050c83efbb1f9ca1a95efbb9f2ee476c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Language independence and language-independent components</source>
          <target state="translated">Indépendance du langage et composants indépendants du langage</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Language independence and language-independent components</source>
          <target state="translated">Indépendance du langage et composants indépendants du langage</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Language independence and language-independent components</source>
          <target state="translated">Indépendance du langage et composants indépendants du langage</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The .NET platform is language independent.</source>
          <target state="translated">La plateforme .NET est indépendante du langage.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This means that, as a developer, you can develop in one of the many languages that target the .NET platform, such as C#, F#, and Visual Basic.</source>
          <target state="translated">Cela signifie qu’en tant que développeur, vous pouvez développer dans un des nombreux langages qui ciblent la plateforme .NET, comme C#, F# et Visual Basic.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can access the types and members of class libraries developed for the .NET platform without having to know the language in which they were originally written and without having to follow any of the original language's conventions.</source>
          <target state="translated">Vous pouvez accéder aux types et aux membres des bibliothèques de classes développées pour la plateforme .NET sans avoir à connaître le langage dans lequel ils ont été initialement écrits ni à suivre les conventions du langage d’origine.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you are a component developer, your component can be accessed by any .NET app regardless of its language.</source>
          <target state="translated">Si vous développez des composants, votre composant est accessible par toute application .NET, indépendamment de son langage.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This first part of this article discusses creating language-independent components - that is, components that can be consumed by apps that are written in any language.</source>
          <target state="translated">La première partie de cet article décrit la création de composants indépendants du langage, c’est-à-dire de composants qui peuvent être utilisés par des applications écrites dans n’importe quel langage.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can also create a single component or app from source code written in multiple languages; see <bpt id="p1">[</bpt>Cross-Language Interoperability<ept id="p1">](#cross-language-interoperability)</ept> in the second part of this article.</source>
          <target state="translated">Vous pouvez également créer un composant ou une application unique à partir de code source écrit dans plusieurs langages. Consultez <bpt id="p1">[</bpt>Interopérabilité multilingue<ept id="p1">](#cross-language-interoperability)</ept> dans la deuxième partie de cet article.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>To fully interact with other objects written in any language, objects must expose to callers only those features that are common to all languages.</source>
          <target state="translated">Pour interagir entièrement avec d’autres objets écrits dans un langage quelconque, les objets ne doivent exposer aux appelants que les fonctionnalités communes à tous les langages.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This common set of features is defined by the Common Language Specification (CLS), which is a set of rules that apply to generated assemblies.</source>
          <target state="translated">Cet ensemble commun de fonctionnalités est défini par la spécification CLS (Common Language Specification), qui est un ensemble de règles qui s’appliquent aux assemblys générés.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The Common Language Specification is defined in Partition I, Clauses 7 through 11 of the <bpt id="p1">[</bpt>ECMA-335 Standard: Common Language Infrastructure<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept>.</source>
          <target state="translated">La spécification CLS (Common Language Specification) est définie dans la Partition I, clauses 7 à 11 du document <bpt id="p1">[</bpt>ECMA-335 Standard: Common Language Infrastructure<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If your component conforms to the Common Language Specification, it is guaranteed to be CLS-compliant and can be accessed from code in assemblies written in any programming language that supports the CLS.</source>
          <target state="translated">Si votre composant est conforme à la spécification CLS, il est garanti d'être conforme CLS et accessible à partir du code dans les assemblys écrits dans n'importe quel langage de programmation qui prend en charge la spécification CLS.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You can determine whether your component conforms to the Common Language Specification at compile time by applying the <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> attribute to your source code.</source>
          <target state="translated">Vous pouvez déterminer si votre composant est conforme à la spécification CLS (Common Language Specification) au moment de la compilation en appliquant l’attribut <bpt id="p1">[</bpt>CSLCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> à votre code source.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For more information, see The <bpt id="p1">[</bpt>CLSCompliantAttribute attribute<ept id="p1">](#the-clscompliantattribute-attribute)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Attribut CLSCompliantAttribute<ept id="p1">](#the-clscompliantattribute-attribute)</ept>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>In this article:</source>
          <target state="translated">Dans cet article :</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CLS compliance rules<ept id="p1">](#cls-compliance-rules)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Règles de conformité CLS<ept id="p1">](#cls-compliance-rules)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et signatures de membres de types<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Naming conventions<ept id="p1">](#naming-conventions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Conventions d’attribution d’un nom<ept id="p1">](#naming-conventions)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type conversion<ept id="p1">](#type-conversion)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Conversion de type<ept id="p1">](#type-conversion)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Arrays<ept id="p1">](#arrays)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tableaux<ept id="p1">](#arrays)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enumerations<ept id="p1">](#enumerations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Énumérations<ept id="p1">](#enumerations)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type members in general<ept id="p1">](#type-members-in-general)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Membres de types en général<ept id="p1">](#type-members-in-general)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Member accessibility<ept id="p1">](#member-accessibility)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Accessibilité des membres<ept id="p1">](#member-accessibility)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et membres génériques<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Constructors<ept id="p1">](#constructors)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Constructeurs<ept id="p1">](#constructors)</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Propriétés<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Événements<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Overloads<ept id="p1">](#overloads)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Surcharges<ept id="p1">](#overloads)</ept></target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Exceptions<ept id="p1">](#exceptions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Exceptions<ept id="p1">](#exceptions)</ept></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Attributes<ept id="p1">](#attributes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Attributs<ept id="p1">](#attributes)</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CLSCompliantAttribute attribute<ept id="p1">](#the-clscompliantattribute-attribute)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Attribut CLSCompliantAttribute<ept id="p1">](#the-clscompliantattribute-attribute)</ept></target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Cross-Language Interoperability<ept id="p1">](#cross-language-interoperability)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Interopérabilité interlangage<ept id="p1">](#cross-language-interoperability)</ept></target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>CLS compliance rules</source>
          <target state="translated">Règles de conformité CLS</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This section discusses the rules for creating a CLS-compliant component.</source>
          <target state="translated">Cette section présente les règles de création d'un composant conforme à CLS.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For a complete list of rules, see Partition I, Clause 11 of the <bpt id="p1">[</bpt>ECMA-335 Standard: Common Language Infrastructure<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept>.</source>
          <target state="translated">Pour obtenir une liste complète des règles, consultez la Partition I, clause 11 du document <bpt id="p1">[</bpt>ECMA-335 Standard: Common Language Infrastructure<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The Common Language Specification discusses each rule for CLS compliance as it applies to consumers (developers who are programmatically accessing a component that is CLS-compliant), frameworks (developers who are using a language compiler to create CLS-compliant libraries), and extenders (developers who are creating a tool such as a language compiler or a code parser that creates CLS-compliant components).</source>
          <target state="translated">La spécification CLS (Common Language Specification) présente chaque règle de conformité CLS telle qu'elle s'applique aux consommateurs (les développeurs qui accèdent par programme à un composant conforme CLS), aux infrastructures (les développeurs qui utilisent un compilateur de langage pour créer des bibliothèques conformes CLS) et aux extendeurs (les développeurs qui créent un outil tel qu'un compilateur de langage ou un analyseur de code qui crée des composants conformes CLS).</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This article focuses on the rules as they apply to frameworks.</source>
          <target state="translated">Cet article se concentre sur les règles applicables aux infrastructures.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Note, though, that some of the rules that apply to extenders may also apply to assemblies that are created using <bpt id="p1">[</bpt>Reflection.Emit<ept id="p1">](xref:System.Reflection.Emit)</ept>.</source>
          <target state="translated">Notez, toutefois, qu’une partie des règles qui s’appliquent aux extendeurs peut également s’appliquer aux assemblys créés à l’aide de <bpt id="p1">[</bpt>Reflection.Emit<ept id="p1">](xref:System.Reflection.Emit)</ept>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>To design a component that is language independent, you only need to apply the rules for CLS compliance to your component's public interface.</source>
          <target state="translated">Pour concevoir un composant indépendant du langage, vous n'avez qu'à appliquer les règles de conformité CLS à l'interface publique de votre composant.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Your private implementation does not have to conform to the specification.</source>
          <target state="translated">Votre implémentation privée n'a pas besoin d'être conforme à la spécification.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The rules for CLS compliance apply only to a component's public interface, not to its private implementation.</source>
          <target state="translated">Les règles de conformité CLS s'appliquent uniquement à l'interface publique d'un composant, pas à son implémentation privée.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For example, unsigned integers other than <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> are not CLS-compliant.</source>
          <target state="translated">Par exemple, les entiers non signés autres que <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> ne sont pas conformes CLS.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`Person`</ph> class in the following example exposes an <ph id="ph2">`Age`</ph> property of type <bpt id="p1">[</bpt>UInt16<ept id="p1">](xref:System.UInt16)</ept>, the following code displays a compiler warning.</source>
          <target state="translated">Étant donné que la classe <ph id="ph1">`Person`</ph> de l’exemple suivant expose une propriété <ph id="ph2">`Age`</ph> de type <bpt id="p1">[</bpt>UInt16<ept id="p1">](xref:System.UInt16)</ept>, le code suivant affiche un avertissement du compilateur.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You can make the Person class CLS-compliant by changing the type of <ph id="ph1">`Age`</ph> property from <ph id="ph2">`UInt16`</ph> to <bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept>, which is a CLS-compliant, 16-bit signed integer.</source>
          <target state="translated">Vous pouvez rendre la classe Person conforme CLS en remplaçant le type <ph id="ph2">`UInt16`</ph> de la propriété <ph id="ph1">`Age`</ph> par <bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept>, qui est un entier signé 16 bits conforme CLS.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You do not have to change the type of the private <ph id="ph1">`personAge`</ph> field.</source>
          <target state="translated">Il n'est pas nécessaire de modifier le type du champ privé <ph id="ph1">`personAge`</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A library's public interface consists of the following:</source>
          <target state="translated">L'interface publique d'une bibliothèque inclut les éléments suivants :</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Definitions of public classes.</source>
          <target state="translated">Définitions des classes publiques.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Definitions of the public members of public classes, and definitions of members accessible to derived classes (that is, protected members).</source>
          <target state="translated">Définitions des membres publics des classes publiques et définitions des membres accessibles aux classes dérivées (à savoir, membres protégés).</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Parameters and return types of public methods of public classes, and parameters and return types of methods accessible to derived classes.</source>
          <target state="translated">Paramètres et types de retour des méthodes publiques des classes publiques, et paramètres et types de retour des méthodes accessibles aux classes dérivées.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The rules for CLS compliance are listed in the following table.</source>
          <target state="translated">Les règles de conformité CLS sont répertoriées dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The text of the rules is taken verbatim from the <bpt id="p1">[</bpt>ECMA-335 Standard: Common Language Infrastructure<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept>, which is Copyright 2012 by Ecma International.</source>
          <target state="translated">Le texte des règles est repris mot pour mot du document <bpt id="p1">[</bpt>ECMA-335 Standard: Common Language Infrastructure<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept>, qui est protégé par copyright 2012 par Ecma International.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>More detailed information about these rules is found in the following sections.</source>
          <target state="translated">Vous trouverez des informations plus détaillées sur ces règles dans les sections suivantes.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Catégorie</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>See</source>
          <target state="translated">Voir</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Rule</source>
          <target state="translated">Règle</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Rule Number</source>
          <target state="translated">Numéro de règle</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Accessibilité</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Member accessibility<ept id="p1">](#member-accessibility)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Accessibilité des membres<ept id="p1">](#member-accessibility)</ept></target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Accessibility shall not be changed when overriding inherited methods, except when overriding a method inherited from a different assembly with accessibility <ph id="ph1">`family-or-assembly`</ph>.</source>
          <target state="translated">L'accessibilité ne devra pas être changée lors du remplacement de méthodes héritées, sauf en cas de remplacement d'une méthode héritée d'un assembly différent avec accessibilité <ph id="ph1">`family-or-assembly`</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>In this case, the override shall have accessibility <ph id="ph1">`family`</ph>.</source>
          <target state="translated">Dans ce cas, le remplacement devra posséder l'accessibilité <ph id="ph1">`family`</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>10</source>
          <target state="translated">10</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Accessibilité</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Member accessibility<ept id="p1">](#member-accessibility)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Accessibilité des membres<ept id="p1">](#member-accessibility)</ept></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The visibility and accessibility of types and members shall be such that types in the signature of any member shall be visible and accessible whenever the member itself is visible and accessible.</source>
          <target state="translated">La visibilité et l'accessibilité des types et des membres seront déterminées de telle sorte que les types utilisés dans la signature d'un membre seront visibles et accessibles lorsque le membre proprement dit est visible et accessible.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For example, a public method that is visible outside its assembly shall not have an argument whose type is visible only within the assembly.</source>
          <target state="translated">Par exemple, une méthode publique qui est visible à l'extérieur de son assembly n'aura pas d'argument dont le type est visible uniquement dans l'assembly.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The visibility and accessibility of types composing an instantiated generic type used in the signature of any member shall be visible and accessible whenever the member itself is visible and accessible.</source>
          <target state="translated">La visibilité et l'accessibilité des types composant un type générique instancié utilisé dans la signature d'un membre seront visibles et accessibles lorsque le membre proprement dit est visible et accessible.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For example, an instantiated generic type present in the signature of a member that is visible outside its assembly shall not have a generic argument whose type is visible only within the assembly.</source>
          <target state="translated">Par exemple, un type générique instancié présent dans la signature d'un membre qui est visible à l'extérieur de l'assembly n'aura pas d'argument générique dont le type est visible uniquement dans l'assembly.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>12</source>
          <target state="translated">12</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Tableaux</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Arrays<ept id="p1">](#arrays)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tableaux<ept id="p1">](#arrays)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Arrays shall have elements with a CLS-compliant type, and all dimensions of the array shall have lower bounds of zero.</source>
          <target state="translated">Les tableaux auront des éléments avec un type conforme à CLS, et toutes les dimensions du tableau auront des limites inférieures égales à zéro.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Only the fact that an item is an array and the element type of the array shall be required to distinguish between overloads.</source>
          <target state="translated">Seul le fait qu'un élément soit un tableau et le type d'élément du tableau seront requis pour distinguer les surcharges.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>When overloading is based on two or more array types the element types shall be named types.</source>
          <target state="translated">Lorsque la surcharge est basée sur deux ou plusieurs types de tableau, les types d'élément seront des types nommés.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributs</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Attributes<ept id="p1">](#attributes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Attributs<ept id="p1">](#attributes)</ept></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Attributes shall be of type <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept>, or a type inheriting from it.</source>
          <target state="translated">Les attributs doivent être de type <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept> ou d’un type hérité de celui-ci.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>41</source>
          <target state="translated">41</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributs</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Attributes<ept id="p1">](#attributes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Attributs<ept id="p1">](#attributes)</ept></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The CLS only allows a subset of the encodings of custom attributes.</source>
          <target state="translated">La spécification CLS autorise uniquement un sous-ensemble des encodages d'attributs personnalisés.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The only types that shall appear in these encodings are (see Partition IV): <bpt id="p1">[</bpt>System.Type<ept id="p1">](xref:System.Type)</ept>, <bpt id="p2">[</bpt>System.String<ept id="p2">](xref:System.String)</ept>, <bpt id="p3">[</bpt>System.Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>System.Boolean<ept id="p4">](xref:System.Boolean)</ept>, <bpt id="p5">[</bpt>System.Byte<ept id="p5">](xref:System.Byte)</ept>, <bpt id="p6">[</bpt>System.Int16<ept id="p6">](xref:System.Int16)</ept>, <bpt id="p7">[</bpt>System.Int32<ept id="p7">](xref:System.Int32)</ept>, <bpt id="p8">[</bpt>System.Int64<ept id="p8">](xref:System.Int64)</ept>, <bpt id="p9">[</bpt>System.Single<ept id="p9">](xref:System.Single)</ept>, <bpt id="p10">[</bpt>System.Double<ept id="p10">](xref:System.Double)</ept>, and any enumeration type based on a CLS-compliant base integer type.</source>
          <target state="translated">Les seuls types qui doivent apparaître dans ces codages sont (voir Partition IV) : <bpt id="p1">[</bpt>System.Type<ept id="p1">](xref:System.Type)</ept>, <bpt id="p2">[</bpt>System.String<ept id="p2">](xref:System.String)</ept>, <bpt id="p3">[</bpt>System.Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>System.Boolean<ept id="p4">](xref:System.Boolean)</ept>, <bpt id="p5">[</bpt>System.Byte<ept id="p5">](xref:System.Byte)</ept>, <bpt id="p6">[</bpt>System.Int16<ept id="p6">](xref:System.Int16)</ept>, <bpt id="p7">[</bpt>System.Int32<ept id="p7">](xref:System.Int32)</ept>, <bpt id="p8">[</bpt>System.Int64<ept id="p8">](xref:System.Int64)</ept>, <bpt id="p9">[</bpt>System.Single<ept id="p9">](xref:System.Single)</ept>, <bpt id="p10">[</bpt>System.Double<ept id="p10">](xref:System.Double)</ept> et tout type d’énumération reposant sur un type entier de base conforme CLS.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>34</source>
          <target state="translated">34</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributs</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Attributes<ept id="p1">](#attributes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Attributs<ept id="p1">](#attributes)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The CLS does not allow publicly visible required modifiers (<ph id="ph1">`modreq`</ph>, see Partition II), but does allow optional modifiers (<ph id="ph2">`modopt`</ph>, see Partition II) it does not understand.</source>
          <target state="translated">La spécification CLS n'autorise pas les modificateurs obligatoires visibles publiquement (<ph id="ph1">`modreq`</ph>, voir Partition II), mais autorise les modificateurs facultatifs (<ph id="ph2">`modopt`</ph>, voir Partition II) qu'elle ne comprend pas.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>35</source>
          <target state="translated">35</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructeurs</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Constructors<ept id="p1">](#constructors)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Constructeurs<ept id="p1">](#constructors)</ept></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>An object constructor shall call some instance constructor of its base class before any access occurs to inherited instance data.</source>
          <target state="translated">Un constructeur d'objet appellera un constructeur d'instance de sa classe de base avant tout accès aux données d'instance héritées.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>(This does not apply to value types, which need not have constructors.)</source>
          <target state="translated">(Cela ne s'applique pas aux types de valeurs, qui n'ont pas besoin de constructeurs.)</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>21</source>
          <target state="translated">21</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructeurs</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Constructors<ept id="p1">](#constructors)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Constructeurs<ept id="p1">](#constructors)</ept></target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>An object constructor shall not be called except as part of the creation of an object, and an object shall not be initialized twice.</source>
          <target state="translated">Un constructeur d'objet ne sera pas appelé sauf dans le cadre de la création d'un objet, et un objet ne sera pas initialisé deux fois.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>22</source>
          <target state="translated">22</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Énumérations</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enumerations<ept id="p1">](#enumerations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Énumérations<ept id="p1">](#enumerations)</ept></target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The underlying type of an enum shall be a built-in CLS integer type, the name of the field shall be "value__", and that field shall be marked <ph id="ph1">`RTSpecialName`</ph>.</source>
          <target state="translated">Le type sous-jacent d'une énumération devra être un type d'entier CLS intégré, le nom du champ devra être « valeur__ » et ce champ devra être marqué <ph id="ph1">`RTSpecialName`</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>7</source>
          <target state="translated">7</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Énumérations</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enumerations<ept id="p1">](#enumerations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Énumérations<ept id="p1">](#enumerations)</ept></target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>There are two distinct kinds of enums, indicated by the presence or absence of the <bpt id="p1">[</bpt>System.FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> (see Partition IV Library) custom attribute.</source>
          <target state="translated">Il existe deux sortes distinctes d’énumérations, signalées par la présence ou l’absence de l’attribut personnalisé <bpt id="p1">[</bpt>System.FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> (voir Partition IV, Library).</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>One represents named integer values; the other represents named bit flags that can be combined to generate an unnamed value.</source>
          <target state="translated">L'un représente des valeurs entières nommées ; l'autre représente les indicateurs binaires nommés qui peuvent être combinés pour générer une valeur sans nom.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The value of an <ph id="ph1">`enum`</ph> is not limited to the specified values.</source>
          <target state="translated">La valeur d'une <ph id="ph1">`enum`</ph> n'est pas limitée aux valeurs spécifiées.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>8</source>
          <target state="translated">8</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Énumérations</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enumerations<ept id="p1">](#enumerations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Énumérations<ept id="p1">](#enumerations)</ept></target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Literal static fields of an enum shall have the type of the enum itself.</source>
          <target state="translated">Les champs static littéraux d’une énumération auront le type de l’énumération elle-même.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>9</source>
          <target state="translated">9</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">événements</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Événements<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The methods that implement an event shall be marked <ph id="ph1">`SpecialName`</ph> in the metadata.</source>
          <target state="translated">Les méthodes qui implémentent un événement doivent être marquées <ph id="ph1">`SpecialName`</ph> dans les métadonnées.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>29</source>
          <target state="translated">29</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">événements</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Événements<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The accessibility of an event and of its accessors shall be identical.</source>
          <target state="translated">L’accessibilité d’un événement et de ses accesseurs sera identique.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>30</source>
          <target state="translated">30</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">événements</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Événements<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`add`</ph> and <ph id="ph2">`remove`</ph> methods for an event shall both either be present or absent.</source>
          <target state="translated">Les méthodes <ph id="ph1">`add`</ph> et <ph id="ph2">`remove`</ph> d'un événement devront toutes les deux être présentes ou absentes.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>31</source>
          <target state="translated">31</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">événements</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Événements<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`add`</ph>and <ph id="ph2">`remove`</ph> methods for an event shall each take one parameter whose type defines the type of the event and that shall be derived from <bpt id="p1">[</bpt>System.Delegate<ept id="p1">](xref:System.Delegate)</ept>.</source>
          <target state="translated">Les méthodes <ph id="ph1">`add`</ph> et <ph id="ph2">`remove`</ph> d’un événement doivent chacune accepter un paramètre dont le type définit le type de l’événement et qui doit être dérivé de <bpt id="p1">[</bpt>System.Delegate<ept id="p1">](xref:System.Delegate)</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>32</source>
          <target state="translated">32</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">événements</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Événements<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Events shall adhere to a specific naming pattern.</source>
          <target state="translated">Les événements adhéreront à un modèle d’attribution de nom spécifique.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The SpecialName attribute referred to in CLS rule 29 shall be ignored in appropriate name comparisons and shall adhere to identifier rules.</source>
          <target state="translated">L’attribut SpecialName dont il est question dans la règle 29 de la spécification CLS doit être ignoré dans les comparaisons de noms appropriées et doit respecter les règles d’identificateur.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>33</source>
          <target state="translated">33</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Exceptions<ept id="p1">](#exceptions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Exceptions<ept id="p1">](#exceptions)</ept></target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Objects that are thrown shall be of type <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept> or a type inheriting from it.</source>
          <target state="translated">Les objets levés doivent être de type <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept> ou d’un type hérité de celui-ci.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Nonetheless, CLS-compliant methods are not required to block the propagation of other types of exceptions.</source>
          <target state="translated">Néanmoins, les méthodes conformes à CLS ne sont pas requises pour bloquer la propagation d'autres types d'exceptions.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>40</source>
          <target state="translated">40</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">Général</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CLS compliance rules<ept id="p1">](#cls-compliance-rules)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Règles de conformité CLS<ept id="p1">](#cls-compliance-rules)</ept></target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>CLS rules apply only to those parts of a type that are accessible or visible outsideof the defining assembly.</source>
          <target state="translated">Les règles CLS s'appliquent uniquement aux éléments d'un type qui sont accessibles ou visibles en dehors de l'assembly de définition.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">Général</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CLS compliance rules<ept id="p1">](#cls-compliance-rules)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Règles de conformité CLS<ept id="p1">](#cls-compliance-rules)</ept></target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Members of non-CLS compliant types shall not be marked CLS-compliant.</source>
          <target state="translated">Les membres de types non conformes à CLS ne seront pas marqués comme conformes à CLS.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Génériques</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et membres génériques<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Nested types shall have at least as many generic parameters as the enclosing type.</source>
          <target state="translated">Les types imbriqués devront posséder au moins autant de paramètres génériques que le type englobant.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Generic parameters in a nested type correspond by position to the generic parameters in its enclosing type.</source>
          <target state="translated">Les paramètres génériques d'un type imbriqué ont la même position que les paramètres génériques du type englobant correspondant.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>42</source>
          <target state="translated">42</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Génériques</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et membres génériques<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The name of a generic type shall encode the number of type parameters declared on the non-nested type, or newly introduced to the type if nested, according to the rules defined above.</source>
          <target state="translated">Le nom d’un type générique devra encoder le nombre de paramètres de type déclarés sur le type non imbriqué ou récemment introduits dans le type s’il est imbriqué, selon les règles définies ci-dessus.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>43</source>
          <target state="translated">43</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Génériques</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et membres génériques<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>A generic type shall redeclare sufficient constraints to guarantee that any constraints on the base type, or interfaces would be satisfied by the generic type constraints.</source>
          <target state="translated">Un type générique devra redéclarer les contraintes suffisantes afin de garantir que les contraintes sur le type de base ou les interfaces seraient satisfaites par les contraintes de type générique.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>44</source>
          <target state="translated">44</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Génériques</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et membres génériques<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Types used as constraints on generic parameters shall themselves be CLS-compliant.</source>
          <target state="translated">Les types utilisés comme contraintes sur les paramètres génériques devront eux-mêmes être conformes à CLS.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>45</source>
          <target state="translated">45</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Génériques</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et membres génériques<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The visibility and accessibility of members (including nested types) in an instantiated generic type shall be considered to be scoped to the specific instantiation rather than the generic type declaration as a whole.</source>
          <target state="translated">La visibilité et l'accessibilité des membres (y compris des types imbriqués) d'un type générique instancié devront être définies dans l'instanciation spécifique plutôt que dans la déclaration générale du type générique.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Assuming this, the visibility and accessibility rules of CLS rule 12 still apply.</source>
          <target state="translated">Sachant cela, les règles de visibilité et d'accessibilité de la règle 12 de la spécification CLS s'appliquent toujours.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>46</source>
          <target state="translated">46</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Génériques</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et membres génériques<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For each abstract or virtual generic method, there shall be a default concrete (nonabstract) implementation</source>
          <target state="translated">À chaque méthode générique abstraite ou virtuelle doit correspondre une implémentation concrète (non abstraite) par défaut</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>47</source>
          <target state="translated">47</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>CLS-compliant interfaces shall not require the definition of non-CLS compliantmethods in order to implement them.</source>
          <target state="translated">Les interfaces conformes à CLS ne devront pas nécessiter la définition de méthodes non conformes à CLS pour pouvoir les implémenter.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>CLS-compliant interfaces shall not define static methods, nor shall they define fields.</source>
          <target state="translated">Les interfaces conformes à CLS ne devront pas définir de méthodes statiques ni de champs.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Membres</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type members in general<ept id="p1">](#type-members-in-general)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Membres de types en général<ept id="p1">](#type-members-in-general)</ept></target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Global static fields and methods are not CLS-compliant.</source>
          <target state="translated">Les méthodes et les champs static globaux ne sont pas conformes CLS.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>36</source>
          <target state="translated">36</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Membres</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The value of a literal static is specified through the use of field initialization metadata.</source>
          <target state="translated">La valeur d'un champ statique littéral est spécifiée via l'utilisation de métadonnées d'initialisation de champ.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>A CLS-compliant literal must have a value specified in field initialization metadata that is of exactly the same type as the literal (or of the underlying type, if that literal is an <ph id="ph1">`enum`</ph>).</source>
          <target state="translated">Un littéral conforme à CLS doit avoir une valeur spécifiée dans les métadonnées d'initialisation de champ qui est exactement du même type que le littéral (ou du type sous-jacent, si ce littéral est une <ph id="ph1">`enum`</ph>).</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>13</source>
          <target state="translated">13</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Membres</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type members in general<ept id="p1">](#type-members-in-general)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Membres de types en général<ept id="p1">](#type-members-in-general)</ept></target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The vararg constraint is not part of the CLS, and the only calling convention supported by the CLS is the standard managed calling convention.</source>
          <target state="translated">La contrainte vararg ne fait pas partie de la spécification CLS, et la seule convention d’appel prise en charge par la spécification CLS est la convention d’appel managée standard.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Naming conventions</source>
          <target state="translated">Conventions d'attribution d'un nom</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Naming conventions<ept id="p1">](#naming-conventions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Conventions d’attribution d’un nom<ept id="p1">](#naming-conventions)</ept></target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Assemblies shall follow Annex 7 of Technical Report 15 of the Unicode Standard3.0 governing the set of characters permitted to start and be included in identifiers, available online at <bpt id="p1">[</bpt>Unicode Normalization Forms<ept id="p1">](http://www.unicode.org/unicode/reports/tr15/tr15-18.html)</ept>.</source>
          <target state="translated">Les assemblys doivent suivre l’Annexe 7 du Rapport technique 15 de la norme Unicode 3.0 régissant l’ensemble des caractères autorisés pour lancer les identificateurs et être inclus dans ces derniers. Cette annexe est disponible en ligne sous <bpt id="p1">[</bpt>Unicode Normalization Forms<ept id="p1">](http://www.unicode.org/unicode/reports/tr15/tr15-18.html)</ept> (Formes de normalisation Unicode).</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Identifiers shall be in the canonical format defined by Unicode Normalization Form C. For CLS purposes, two identifiersare the same if their lowercase mappings (as specified by the Unicode locale-insensitive, one-to-one lowercase mappings) are the same.</source>
          <target state="translated">Les identificateurs doivent être dans un format canonique défini par la forme C de normalisation Unicode. Dans le cadre de la spécification CLS, deux identificateurs sont les mêmes si leurs mappages en minuscules (comme spécifié par les mappages en minuscules un-à-un insensibles aux paramètres régionaux Unicode) sont identiques.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>That is, for two identifiers to be considered different under the CLS they shall differ in more than simply their case.</source>
          <target state="translated">Autrement dit, pour que deux identificateurs soient considérés comme différents dans le cadre de la spécification CLS, ils doivent être différenciés par d’autres éléments que leur casse.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>However, in order to override an inherited definition the CLI requires the precise encoding of the original declaration be used.</source>
          <target state="translated">Toutefois, pour remplacer une définition héritée, l’infrastructure CLI nécessite l’utilisation de l’encodage exact de la déclaration d’origine.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Surcharge</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Naming conventions<ept id="p1">](#naming-conventions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Conventions d’attribution d’un nom<ept id="p1">](#naming-conventions)</ept></target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>All names introduced in a CLS-compliant scope shall be distinct independent of kind, except where the names are identical and resolved via overloading.</source>
          <target state="translated">Tous les noms introduits dans une portée conforme CLS doivent être distincts, indépendamment de leur type, sauf quand les noms sont identiques et résolus par surcharge.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>That is, while the CTS allows a single type to use the same name for a method and a field, the CLS does not.</source>
          <target state="translated">Par exemple, alors que CTS autorise un type à utiliser le même nom pour une méthode et un champ, CLS ne l’autorise pas.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="translated">5</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Surcharge</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Naming conventions<ept id="p1">](#naming-conventions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Conventions d’attribution d’un nom<ept id="p1">](#naming-conventions)</ept></target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Fields and nested types shall be distinct by identifier comparison alone, eventhough the CTS allows distinct signatures to be distinguished.</source>
          <target state="translated">Les champs et les types imbriqués seront distincts par comparaison d'identificateurs seule, même si CTS autorise la distinction de signatures différentes.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events that have the same name (by identifier comparison) shall differ by more than just the return type,except as specified in CLS Rule 39</source>
          <target state="translated">Les méthodes, les propriétés et les événements qui portent le même nom (par comparaison d’identificateurs) doivent différer par d’autres éléments que le seul type de retour, sauf dans les cas spécifiés dans la règle 39 de la spécification CLS</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>6</source>
          <target state="translated">6</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Surcharge</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Overloads<ept id="p1">](#overloads)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Surcharges<ept id="p1">](#overloads)</ept></target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Only properties and methods can be overloaded.</source>
          <target state="translated">Seules les propriétés et les méthodes peuvent être surchargées.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>37</source>
          <target state="translated">37</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Surcharge</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Overloads<ept id="p1">](#overloads)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Surcharges<ept id="p1">](#overloads)</ept></target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Properties and methods can be overloaded based only on the number and types of their parameters, except the conversion operators named <ph id="ph1">`op_Implicit`</ph> and <ph id="ph2">`op_Explicit`</ph>, which can also be overloaded based on their return type.</source>
          <target state="translated">Les propriétés et les méthodes peuvent être surchargées en fonction du nombre et des types de leurs paramètres uniquement, à l'exception des opérateurs de conversion nommés <ph id="ph1">`op_Implicit`</ph> et <ph id="ph2">`op_Explicit`</ph>, qui peuvent également être surchargés selon leur type de retour.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>38</source>
          <target state="translated">38</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Surcharge</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>If two or more CLS-compliant methods declared in a type have the same nameand, for a specific set of type instantiations, they have the same parameter and return types, then all these methods shall be semantically equivalent at those type instantiations.</source>
          <target state="translated">Si deux ou plusieurs méthodes conformes CLS déclarées dans un type ont le même nom et, pour un jeu spécifique d’instanciations de types, ont le même paramètre et les mêmes types de retour, alors toutes ces méthodes sont sémantiquement équivalentes à ces instanciations de type.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>48</source>
          <target state="translated">48</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Propriétés</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Propriétés<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The methods that implement the getter and setter methods of a property shall be marked <ph id="ph1">`SpecialName`</ph> in the metadata.</source>
          <target state="translated">Les méthodes qui implémentent les méthodes getter et setter d’une propriété doivent être marquées <ph id="ph1">`SpecialName`</ph> dans les métadonnées.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>24</source>
          <target state="translated">24</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Propriétés</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Propriétés<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>A property’s accessors shall all be static, all be virtual, or all be instance.</source>
          <target state="translated">Les accesseurs d’une propriété devront tous être statiques, virtuels ou être des instances.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>26</source>
          <target state="translated">26</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Propriétés</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Propriétés<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The type of a property shall be the return type of the getter and the type of the last argument of the setter.</source>
          <target state="translated">Le type d’une propriété devra correspondre au type de retour de la méthode getter et au type du dernier argument de la méthode setter.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The types of the parameters of the property shall be the types of the parameters to the getter and the types of all but the final parameter of the setter.</source>
          <target state="translated">Les types des paramètres de la propriété devront correspondre aux types des paramètres de la méthode getter et aux types de tous les paramètres de la méthode setter, sauf le dernier.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>All of these types shall be CLS-compliant, and shall not be managed pointers (i.e., shall not be passed by reference).</source>
          <target state="translated">Tous ces types devront être conformes à CLS et ne pas être des pointeurs managés (à savoir, ils ne doivent pas être passés par référence).</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>27</source>
          <target state="translated">27</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Propriétés</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Propriétés<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Properties shall adhere to a specific naming pattern.</source>
          <target state="translated">Les propriétés adhéreront à un modèle d’attribution de nom spécifique.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`SpecialName`</ph> attribute referred to in CLS rule 24 shall be ignored in appropriate name comparisons and shall adhere to identifier rules.</source>
          <target state="translated">L'attribut <ph id="ph1">`SpecialName`</ph> dont il est question dans la règle 24 de la spécification CLS sera ignoré dans les comparaisons de noms appropriées et respectera les règles d'identificateur.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>A property shall have a getter method, a setter method, or both.</source>
          <target state="translated">Une propriété aura une méthode getter, une méthode setter ou les deux.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>28</source>
          <target state="translated">28</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Type conversion</source>
          <target state="translated">Conversion de type</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type conversion<ept id="p1">](#type-conversion)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Conversion de type<ept id="p1">](#type-conversion)</ept></target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>If either op_Implicit or op_Explicit is provided, an alternate means of providing the coercion shall be provided.</source>
          <target state="translated">Si op_Implicit ou op_Explicit est fourni, un autre moyen est utilisé pour fournir la contrainte.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>39</source>
          <target state="translated">39</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et signatures de membres de types<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Boxed value types are not CLS-compliant.</source>
          <target state="translated">Les types de valeurs encadrés ne sont pas conformes à CLS.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et signatures de membres de types<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>All types appearing in a signature shall be CLS-compliant.</source>
          <target state="translated">Tous les types apparaissant dans une signature devront être conformes à CLS.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>All types composing an instantiated generic type shall be CLS-compliant.</source>
          <target state="translated">Tous les types composant un type générique instancié devront être conformes à CLS.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>11</source>
          <target state="translated">11</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et signatures de membres de types<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Typed references are not CLS-compliant.</source>
          <target state="translated">Les références typées ne sont pas conformes CLS.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et signatures de membres de types<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Unmanaged pointer types are not CLS-compliant.</source>
          <target state="translated">Les types de pointeurs non managés ne sont pas conformes à CLS.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et signatures de membres de types<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>CLS-compliant classes, value types, and interfaces shall not require the implementation of non-CLS-compliant members</source>
          <target state="translated">Les classes, les types de valeurs et les interfaces conformes CLS ne doivent pas nécessiter l’implémentation de membres non conformes CLS</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>20</source>
          <target state="translated">20</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Types et signatures de membres de types<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> is CLS-compliant.</source>
          <target state="translated"><bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> est conforme CLS.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Any other CLS-compliant class shall inherit from a CLS-compliant class.</source>
          <target state="translated">Toute autre classe conforme à CLS héritera d'une classe conforme à CLS.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>23</source>
          <target state="translated">23</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Types and type member signatures</source>
          <target state="translated">Types et signatures de membres de types</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> type is CLS-compliant and is the base type of all object types in the .NET Framework type system.</source>
          <target state="translated">Le type <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> est conforme CLS et correspond au type de base de tous les types d’objets du système de types .Net Framework.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Inheritance in the .NET Framework is either implicit (for example, the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> class implicitly inherits from the <ph id="ph1">`Object`</ph> class) or explicit (for example, the <bpt id="p2">[</bpt>CultureNotFoundException<ept id="p2">](xref:System.Globalization.CultureNotFoundException)</ept> class explicitly inherits from the <bpt id="p3">[</bpt>ArgumentException<ept id="p3">](xref:System.ArgumentException)</ept> class, which explicitly inherits from the <bpt id="p4">[</bpt>Exception<ept id="p4">](xref:System.Exception)</ept> class.</source>
          <target state="translated">Dans le .NET Framework, l’héritage est implicite (par exemple, la classe <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> hérite implicitement de la classe <ph id="ph1">`Object`</ph>) ou explicite (par exemple, la classe <bpt id="p2">[</bpt>CultureNotFoundException<ept id="p2">](xref:System.Globalization.CultureNotFoundException)</ept> hérite explicitement de la classe <bpt id="p3">[</bpt>ArgumentException<ept id="p3">](xref:System.ArgumentException)</ept>, qui hérite explicitement de la classe <bpt id="p4">[</bpt>Exception<ept id="p4">](xref:System.Exception)</ept>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>For a derived type to be CLS compliant, its base type must also be CLS-compliant.</source>
          <target state="translated">Pour qu'un type dérivé soit conforme à CLS, son type de base doit également être conforme à CLS.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The following example shows a derived type whose base type is not CLS-compliant.</source>
          <target state="translated">L'exemple suivant montre un type dérivé dont le type de base n'est pas conforme à CLS.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>It defines a base <ph id="ph1">`Counter`</ph> class that uses an unsigned 32-bit integer as a counter.</source>
          <target state="translated">Il définit une classe <ph id="ph1">`Counter`</ph> de base qui utilise un entier 32 bits non signé en tant que compteur.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Because the class provides counter functionality by wrapping an unsigned integer, the class is marked as non-CLS-compliant.</source>
          <target state="translated">La classe fournissant une fonctionnalité de compteur en encapsulant un entier non signé, elle est marquée comme non conforme à CLS.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>As a result, a derived class, <ph id="ph1">`NonZeroCounter`</ph>, is also not CLS-compliant.</source>
          <target state="translated">Par conséquent, une classe dérivée, <ph id="ph1">`NonZeroCounter`</ph>, n'est pas non plus conforme à CLS.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>All types that appear in member signatures, including a method's return type or a property type, must be CLS-compliant.</source>
          <target state="translated">Tous les types qui apparaissent dans les signatures de membres, notamment le type de retour d’une méthode ou un type de propriété, doivent être conformes à CLS.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>In addition, for generic types:</source>
          <target state="translated">En outre, pour les types génériques :</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>All types that compose an instantiated generic type must be CLS-compliant.</source>
          <target state="translated">Tous les types qui composent un type générique instancié doivent être conformes à CLS.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>All types used as constraints on generic parameters must be CLS-compliant.</source>
          <target state="translated">Tous les types utilisés comme contraintes sur des paramètres génériques doivent eux-mêmes être conformes à CLS.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>The .NET <bpt id="p1">[</bpt>common type system<ept id="p1">](common-type-system.md)</ept> includes a number of built-in types that are supported directly by the common language runtime and are specially encoded in an assembly's metadata.</source>
          <target state="translated">Le <bpt id="p1">[</bpt>système de type commun<ept id="p1">](common-type-system.md)</ept> .NET inclut un certain nombre de types intégrés pris en charge directement par le Common Langage Runtime et qui sont spécialement encodés dans les métadonnées d’un assembly.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Of these intrinsic types, the types listed in the following table are CLS-compliant.</source>
          <target state="translated">Parmi les types intrinsèques, les types répertoriés dans le tableau suivant sont conformes à CLS.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>CLS-compliant type</source>
          <target state="translated">Type conforme à CLS</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept></target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>8-bit unsigned integer</source>
          <target state="translated">Entier 8 bits non signé</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept></target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>16-bit signed integer</source>
          <target state="translated">Entier 16 bits signé</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept></target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>32-bit signed integer</source>
          <target state="translated">Entier 32 bits signé</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>64-bit signed integer</source>
          <target state="translated">Entier 64 bits signé</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Single<ept id="p1">](xref:System.Single)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Single<ept id="p1">](xref:System.Single)</ept></target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Single-precision floating-point value</source>
          <target state="translated">Valeur à virgule flottante simple précision</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept></target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Double-precision floating-point value</source>
          <target state="translated">Valeur à virgule flottante double précision</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept></target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>true or false value type</source>
          <target state="translated">Type de valeur true ou false</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept></target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>UTF-16 encoded code unit</source>
          <target state="translated">Unité de code encodée en UTF-16</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept></target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Non-floating-point decimal number</source>
          <target state="translated">Nombre décimal à virgule fixe</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IntPtr<ept id="p1">](xref:System.IntPtr)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IntPtr<ept id="p1">](xref:System.IntPtr)</ept></target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Pointer or handle of a platform-defined size</source>
          <target state="translated">Pointeur ou handle d'une taille définie par la plateforme</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept></target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Collection of zero, one, or more Char objects</source>
          <target state="translated">Collection de zéro, un ou plusieurs objets Char</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>The intrinsic types listed in the following table are not CLS-Compliant.</source>
          <target state="translated">Les types intrinsèques répertoriés dans le tableau suivant ne sont pas conformes à CLS.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Non-compliant type</source>
          <target state="translated">Type non conforme</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>CLS-compliant alternative</source>
          <target state="translated">Alternative conforme à CLS</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SByte<ept id="p1">](xref:System.SByte)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>SByte<ept id="p1">](xref:System.SByte)</ept></target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>8-bit signed integer data type</source>
          <target state="translated">Type de données entier signé 8 bits</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept></target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt16<ept id="p1">](xref:System.UInt16)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UInt16<ept id="p1">](xref:System.UInt16)</ept></target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>16-bit unsigned integer</source>
          <target state="translated">Entier 16 bits non signé</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept></target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept></target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>32-bit unsigned integer</source>
          <target state="translated">Entier 32 bits non signé</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt64<ept id="p1">](xref:System.UInt64)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UInt64<ept id="p1">](xref:System.UInt64)</ept></target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>64-bit unsigned integer</source>
          <target state="translated">Entier 64 bits non signé</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept> (may overflow), <bpt id="p2">[</bpt>BigInteger<ept id="p2">](xref:System.Numerics.BigInteger)</ept>, or <bpt id="p3">[</bpt>Double<ept id="p3">](xref:System.Double)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept> (peut déborder), <bpt id="p2">[</bpt>BigInteger<ept id="p2">](xref:System.Numerics.BigInteger)</ept> ou <bpt id="p3">[</bpt>Double<ept id="p3">](xref:System.Double)</ept></target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UIntPtr<ept id="p1">](xref:System.UIntPtr)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UIntPtr<ept id="p1">](xref:System.UIntPtr)</ept></target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Unsigned pointer or handle</source>
          <target state="translated">Pointeur ou handle non signé</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IntPtr<ept id="p1">](xref:System.IntPtr)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IntPtr<ept id="p1">](xref:System.IntPtr)</ept></target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>The .NET Framework Class Library or any other class library may include other types that aren't CLS-compliant; for example:</source>
          <target state="translated">La bibliothèque de classes du .NET Framework ou toute autre bibliothèque de classes peut inclure d'autres types non conformes à CLS. Par exemple :</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Boxed value types.</source>
          <target state="translated">Types de valeurs encadrés.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>The following C# example creates a class that has a public property of type <ph id="ph1">`int`</ph><bpt id="p1">*</bpt> named <ph id="ph2">`Value`</ph>. Because an <ph id="ph3">`int`</ph><ept id="p1">*</ept> is a boxed value type, the compiler flags it as non-CLS-compliant.</source>
          <target state="translated">L’exemple C# suivant crée une classe qui a une propriété publique de type <ph id="ph1">`int`</ph><bpt id="p1">*</bpt> nommée <ph id="ph2">`Value`</ph>. Comme <ph id="ph3">`int`</ph><ept id="p1">*</ept> est un type de valeur encadré, le compilateur le signale comme non conforme CLS.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>Typed references, which are special constructs that contain a reference to an object and a reference to a type.</source>
          <target state="translated">Références typées, qui sont des constructions spéciales qui contiennent une référence à un objet et une référence à un type.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>If a type is not CLS-compliant, you should apply the <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> attribute with an <bpt id="p2">*</bpt>isCompliant<ept id="p2">*</ept> parameter with a value of <ph id="ph1">`false`</ph> to it.</source>
          <target state="translated">Si un type n’est pas conforme CLS, vous devez lui appliquer l’attribut <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> avec un paramètre <bpt id="p2">*</bpt>isCompliant<ept id="p2">*</ept> dont la valeur est <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>CLSCompliantAttribute attribute<ept id="p1">](#the-clscompliantattribute-attribute)</ept> section.</source>
          <target state="translated">Pour plus d’informations, consultez la section <bpt id="p1">[</bpt>Attribut CLSCompliantAttribute<ept id="p1">](#the-clscompliantattribute-attribute)</ept>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>The following example illustrates the problem of CLS compliance in a method signature and in generic type instantiation.</source>
          <target state="translated">L'exemple suivant illustre le problème de conformité CLS dans une signature de méthode et dans une instanciation de type générique.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>It defines an <ph id="ph1">`InvoiceItem`</ph> class with a property of type <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept>, a property of type <bpt id="p2">[</bpt>Nullable(Of UInt32)<ept id="p2">](xref:System.Nullable%601)</ept>, and a constructor with parameters of type <ph id="ph2">`UInt32`</ph> and <ph id="ph3">`Nullable(Of UInt32)`</ph>.</source>
          <target state="translated">Il définit une classe <ph id="ph1">`InvoiceItem`</ph> avec une propriété de type <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept>, une propriété de type <bpt id="p2">[</bpt>Nullable(Of UInt32)<ept id="p2">](xref:System.Nullable%601)</ept> et un constructeur avec des paramètres de type <ph id="ph2">`UInt32`</ph> et <ph id="ph3">`Nullable(Of UInt32)`</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>You get four compiler warnings when you try to compile this example.</source>
          <target state="translated">Vous obtenez quatre avertissements du compilateur lorsque vous essayez de compiler cet exemple.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>To eliminate the compiler warnings, replace the non-CLS-compliant types in the <ph id="ph1">`InvoiceItem`</ph> public interface with compliant types:</source>
          <target state="translated">Pour supprimer les avertissements du compilateur, remplacez les types non conforme à CLS de l'interface publique <ph id="ph1">`InvoiceItem`</ph> par des types conformes :</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>In addition to the specific types listed, some categories of types are not CLS compliant.</source>
          <target state="translated">Outre les types spécifiques répertoriés, certaines catégories de types ne sont pas conformes à CLS.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>These include unmanaged pointer types and function pointer types.</source>
          <target state="translated">Celles-ci incluent les types de pointeurs non managés et les types de pointeurs de fonctions.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>The following example generates a compiler warning because it uses a pointer to an integer to create an array of integers.</source>
          <target state="translated">L'exemple suivant génère un avertissement du compilateur, car il utilise un pointeur vers un entier pour créer un tableau d'entiers.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>For CLS-compliant abstract classes (that is, classes marked as <ph id="ph1">`abstract`</ph> in C#), all members of the class must also be CLS-compliant.</source>
          <target state="translated">Pour les classes abstraites conformes CLS (autrement dit, les classes marquées comme <ph id="ph1">`abstract`</ph> en C#), tous les membres de la classe doivent également être conformes CLS.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Naming conventions</source>
          <target state="translated">Conventions d'attribution d'un nom</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>Because some programming languages are case-insensitive, identifiers (such as the names of namespaces, types, and members) must differ by more than case.</source>
          <target state="translated">Étant donné que certains langages de programmation ne respectent pas la casse, les identificateurs (tels que les noms d'espaces de noms, de types et de membres) doivent se différencier par autre chose que la casse.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>Two identifiers are considered equivalent if their lowercase mappings are the same.</source>
          <target state="translated">Deux identificateurs sont considérés comme équivalents si leurs mappages en minuscules sont identiques.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The following C# example defines two public classes, <ph id="ph1">`Person`</ph> and <ph id="ph2">`person`</ph>.</source>
          <target state="translated">L'exemple C# suivant définit deux classes publiques : <ph id="ph1">`Person`</ph> et <ph id="ph2">`person`</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Because they differ only by case, the C# compiler flags them as not CLS-compliant.</source>
          <target state="translated">Étant donné qu'elles ne diffèrent que par leur casse, le compilateur C# les signale comme étant non conformes à CLS.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Programming language identifiers, such as the names of namespaces, types, and members, must conform to the <bpt id="p1">[</bpt>Unicode Standard 3.0, Technical Report 15, Annex 7<ept id="p1">](http://www.unicode.org/reports/tr15/tr15-18.html)</ept>.</source>
          <target state="translated">Les identificateurs de langage de programmation, comme les noms d’espaces de noms, de types et de membres, doivent être conformes au document <bpt id="p1">[</bpt>Unicode Standard 3.0, Technical Report 15, Annex 7<ept id="p1">](http://www.unicode.org/reports/tr15/tr15-18.html)</ept> (Norme Unicode 3.0, Rapport technique 15, Annexe 7).</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>This means that:</source>
          <target state="translated">Cela signifie que :</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>The first character of an identifier can be any Unicode uppercase letter, lowercase letter, title case letter, modifier letter, other letter, or letter number.</source>
          <target state="translated">Le premier caractère d'un identificateur peut être une lettre majuscule, une lettre minuscule, une initiale majuscule, une lettre de modificateur, une autre lettre ou un nombre sous forme de lettre, Unicode.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>For information on Unicode character categories, see the <bpt id="p1">[</bpt>System.Globalization.UnicodeCategory<ept id="p1">](xref:System.Globalization.UnicodeCategory)</ept> enumeration.</source>
          <target state="translated">Pour plus d’informations sur les catégories de caractères Unicode, consultez l’énumération <bpt id="p1">[</bpt>System.Globalization.UnicodeCategory<ept id="p1">](xref:System.Globalization.UnicodeCategory)</ept>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>Subsequent characters can be from any of the categories as the first character, and can also include non-spacing marks, spacing combining marks, decimal numbers, connector punctuations, and formatting codes.</source>
          <target state="translated">Les caractères suivants peuvent provenir de n'importe laquelle des catégories, comme le premier caractère, et peuvent également inclure des marques de non-espacement, des nombres décimaux, des ponctuations de connecteur et des codes de mise en forme.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>Before you compare identifiers, you should filter out formatting codes and convert the identifiers to Unicode Normalization Form C, because a single character can be represented by multiple UTF-16-encoded code units.</source>
          <target state="translated">Avant de comparer les identificateurs, vous devez éliminer par filtrage les codes de mise en forme et convertir les identificateurs au formulaire de normalisation Unicode C, car un caractère unique peut être représenté par plusieurs unités de code encodées en UTF-16.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>Character sequences that produce the same code units in Unicode Normalization Form C are not CLS-compliant.</source>
          <target state="translated">Les séquences de caractères qui produisent les mêmes unités de code dans un formulaire de normalisation Unicode C ne sont pas conformes à CLS.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>The following example defines a property named <ph id="ph1">`Å`</ph>, which consists of the character ANGSTROM SIGN (U+212B), and a second property named <ph id="ph2">`Å`</ph> which consists of the character LATIN CAPITAL LETTER A WITH RING ABOVE (U+00C5).</source>
          <target state="translated">L’exemple suivant définit une propriété nommée <ph id="ph1">`Å`</ph>, qui est constituée du caractère SYMBOLE ANGSTRÖM (U+212B), et une deuxième propriété nommée <ph id="ph2">`Å`</ph>, qui est constituée du caractère LETTRE MAJUSCULE LATINE A AVEC DIACRITIQUE ROND EN CHEF (U+00C5).</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>The C# compiler flags the source code as non-CLS-compliant.</source>
          <target state="translated">Le compilateur C# signale le code source comme non conforme CLS.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Member names within a particular scope (such as the namespaces within an assembly, the types within a namespace, or the members within a type) must be unique except for names that are resolved through overloading.</source>
          <target state="translated">Les noms de membres dans une portée donnée (tels que les espaces de noms dans un assembly, les types dans un espace de noms ou les membres dans un type) doivent être uniques, à l'exception des noms résolus par la surcharge.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>This requirement is more stringent than that of the common type system, which allows multiple members within a scope to have identical names as long as they are different kinds of members (for example, one is a method and one is a field).</source>
          <target state="translated">Cette spécification est plus stricte que celle du système de type commun, qui autorise plusieurs membres d'une portée à avoir des noms identiques tant qu'il s'agit de types de membres différents (par exemple, l'un est une méthode et l'autre est un champ).</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>In particular, for type members:</source>
          <target state="translated">En particulier, pour les membres de types :</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Fields and nested types are distinguished by name alone.</source>
          <target state="translated">Les champs et les types imbriqués se distinguent par le nom uniquement.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events that have the same name must differ by more than just return type.</source>
          <target state="translated">Les méthodes, les propriétés et les événements qui portent le même nom doivent différer par autre chose que le type de retour.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>The following example illustrates the requirement that member names must be unique within their scope.</source>
          <target state="translated">L'exemple suivant illustre la spécification selon laquelle les noms de membres doivent être uniques dans leur portée.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>It defines a class named <ph id="ph1">`Converter`</ph> that includes four members named <ph id="ph2">`Conversion`</ph>.</source>
          <target state="translated">Il définit une classe nommée <ph id="ph1">`Converter`</ph> qui inclut quatre membres nommés <ph id="ph2">`Conversion`</ph>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Three are methods, and one is a property.</source>
          <target state="translated">Trois sont des méthodes, le dernier est une propriété.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>The method that includes an <ph id="ph1">`Int64`</ph> parameter is uniquely named, but the two methods with an <ph id="ph2">`Int32`</ph> parameter are not, because return value is not considered a part of a member's signature.</source>
          <target state="translated">La méthode qui inclut un paramètre <ph id="ph1">`Int64`</ph> est nommée de manière unique, contrairement aux deux méthodes contenant un paramètre <ph id="ph2">`Int32`</ph>, car la valeur de retour n'est pas considérée comme faisant partie de la signature d'un membre.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Conversion`</ph> property also violates this requirement, because properties cannot have the same name as overloaded methods.</source>
          <target state="translated">La propriété <ph id="ph1">`Conversion`</ph> enfreint également cette spécification, car les propriétés ne peuvent pas avoir le même nom que les méthodes surchargées.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Individual languages include unique keywords, so languages that target the common language runtime must also provide some mechanism for referencing identifiers (such as type names) that coincide with keywords.</source>
          <target state="translated">Les langages individuels incluent des mots clés uniques de sorte que les langages qui ciblent le Common Langage Runtime doivent également fournir un mécanisme de référencement des identificateurs (tels que les noms de types) qui coïncident avec les mots clés.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`case`</ph> is a keyword in both C# and Visual Basic.</source>
          <target state="translated">Par exemple, <ph id="ph1">`case`</ph> est un mot clé en C# et Visual Basic.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>However, the following Visual Basic example is able to disambiguate a class named <ph id="ph1">`case`</ph> from the <ph id="ph2">`case`</ph> keyword by using opening and closing braces.</source>
          <target state="translated">Toutefois, l'exemple Visual Basic suivant peut supprimer l'ambiguïté entre une classe nommée <ph id="ph1">`case`</ph> et le mot clé <ph id="ph2">`case`</ph> en utilisant des accolades ouvrantes et fermantes.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>Otherwise, the example would produce the error message, "Keyword is not valid as an identifier," and fail to compile.</source>
          <target state="translated">Sans cela, l'exemple générerait le message d'erreur : « Mot clé non valide en tant qu'identificateur » et échouerait lors de la compilation.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>The following C# example is able to instantiate the <ph id="ph1">`case`</ph> class by using the <ph id="ph2">@</ph> symbol to disambiguate the identifier from the language keyword.</source>
          <target state="translated">L'exemple C# suivant peut instancier la classe <ph id="ph1">`case`</ph> en utilisant le symbole <ph id="ph2">@</ph> pour lever l'ambiguïté de l'identificateur par rapport au mot clé de langage.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>Without it, the C# compiler would display two error messages, "Type expected" and "Invalid expression term 'case'."</source>
          <target state="translated">Sans cela, le compilateur C# afficherait deux messages d'erreur : « Type attendu » et « Terme d'expression non valide 'case' ».</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>Type conversion</source>
          <target state="translated">Conversion de type</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>The Common Language Specification defines two conversion operators:</source>
          <target state="translated">La spécification CLS (Common Language Specification) définit deux opérateurs de conversion :</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`op_Implicit`</ph>, which is used for widening conversions that do not result in loss of data or precision.</source>
          <target state="translated"><ph id="ph1">`op_Implicit`</ph>, qui est utilisé pour les conversions étendues qui n'entraînent pas la perte de données ou de précision.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept> structure includes an overloaded <ph id="ph1">`op_Implicit`</ph> operator to convert values of integral types and <bpt id="p2">[</bpt>Char<ept id="p2">](xref:System.Char)</ept> values to <ph id="ph2">`Decimal`</ph> values.</source>
          <target state="translated">Par exemple, la structure <bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept> inclut un opérateur <ph id="ph1">`op_Implicit`</ph> surchargé pour convertir les valeurs de types intégraux et les valeurs <bpt id="p2">[</bpt>Char<ept id="p2">](xref:System.Char)</ept> en valeurs <ph id="ph2">`Decimal`</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`op_Explicit`</ph>, which is used for narrowing conversions that can result in loss of magnitude (a value is converted to a value that has a smaller range) or precision.</source>
          <target state="translated"><ph id="ph1">`op_Explicit`</ph>, qui est utilisé pour les conversions restrictives qui peuvent entraîner la perte d'amplitude (une valeur est convertie en une valeur qui entraîne une plus petite plage) ou de précision.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">`Decimal`</ph> structure includes an overloaded <ph id="ph2">`op_Explicit`</ph> operator to convert <bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept> and <bpt id="p2">[</bpt>Single<ept id="p2">](xref:System.Single)</ept> values to <ph id="ph3">`Decimal`</ph> and to convert <ph id="ph4">`Decimal`</ph> values to integral values, <ph id="ph5">`Double`</ph>, <ph id="ph6">`Single`</ph>, and <ph id="ph7">`Char`</ph>.</source>
          <target state="translated">Par exemple, la structure <ph id="ph1">`Decimal`</ph> inclut un opérateur <ph id="ph2">`op_Explicit`</ph> surchargé pour convertir les valeurs <bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept> et <bpt id="p2">[</bpt>Single<ept id="p2">](xref:System.Single)</ept> en <ph id="ph3">`Decimal`</ph>, et convertir les valeurs <ph id="ph4">`Decimal`</ph> en valeurs intégrales, <ph id="ph5">`Double`</ph>, <ph id="ph6">`Single`</ph> et <ph id="ph7">`Char`</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>However, not all languages support operator overloading or the definition of custom operators.</source>
          <target state="translated">Toutefois, tous les langages ne prennent pas en charge la surcharge d'opérateur ou la définition d'opérateurs personnalisés.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>If you choose to implement these conversion operators, you should also provide an alternate way to perform the conversion.</source>
          <target state="translated">Si vous décidez d'implémenter ces opérateurs de conversion, vous devez également fournir une autre façon d'effectuer la conversion.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>We recommend that you provide <ph id="ph1">`From`</ph>Xxx and <ph id="ph2">`To`</ph>Xxx methods.</source>
          <target state="translated">Nous vous recommandons de fournir les méthodes <ph id="ph1">`From`</ph>Xxx et <ph id="ph2">`To`</ph>Xxx.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>The following example defines CLS-compliant implicit and explicit conversions.</source>
          <target state="translated">L'exemple suivant définit les conversions implicites et explicites conformes à CLS.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>It creates a <ph id="ph1">`UDouble`</ph>class that represents an signed double-precision, floating-point number.</source>
          <target state="translated">Il crée une classe <ph id="ph1">`UDouble`</ph> qui représente un nombre à virgule flottante double précision signé.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>It provides for implicit conversions from <ph id="ph1">`UDouble`</ph> to <ph id="ph2">`Double`</ph> and for explicit conversions from <ph id="ph3">`UDouble`</ph> to <ph id="ph4">`Single`</ph>, <ph id="ph5">`Double`</ph> to <ph id="ph6">`UDouble`</ph>, and <ph id="ph7">`Single`</ph> to <ph id="ph8">`UDouble`</ph>.</source>
          <target state="translated">Il s'applique aux conversions implicites de <ph id="ph1">`UDouble`</ph> à <ph id="ph2">`Double`</ph> et aux conversions explicites de <ph id="ph3">`UDouble`</ph> à <ph id="ph4">`Single`</ph>, de <ph id="ph5">`Double`</ph> à <ph id="ph6">`UDouble`</ph> et de <ph id="ph7">`Single`</ph> à <ph id="ph8">`UDouble`</ph>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>It also defines a <ph id="ph1">`ToDouble`</ph> method as an alternative to the implicit conversion operator and the <ph id="ph2">`ToSingle`</ph>, <ph id="ph3">`FromDouble`</ph>, and <ph id="ph4">`FromSingle`</ph> methods as alternatives to the explicit conversion operators.</source>
          <target state="translated">Il définit également une méthode <ph id="ph1">`ToDouble`</ph> comme une alternative à l'opérateur de conversion implicite et les méthodes <ph id="ph2">`ToSingle`</ph>, <ph id="ph3">`FromDouble`</ph> et <ph id="ph4">`FromSingle`</ph> comme alternatives aux opérateurs de conversion explicite.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Tableaux</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>CLS-compliant arrays conform to the following rules:</source>
          <target state="translated">Les tableaux conformes à CLS respectent les règles suivantes :</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>All dimensions of an array must have a lower bound of zero.</source>
          <target state="translated">Toutes les dimensions d'un tableau doivent avoir une limite inférieure égale à zéro.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>The following example creates a non-CLS-compliant array with a lower bound of one.</source>
          <target state="translated">L'exemple suivant crée un tableau non conforme à CLS avec une limite inférieure égale à un.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Note that, despite the presence of the <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> attribute, the compiler does not detect that the array returned by the <ph id="ph1">`Numbers.GetTenPrimes`</ph> method is not CLS-compliant.</source>
          <target state="translated">Notez que, malgré la présence de l’attribut <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept>, le compilateur ne détecte pas que le tableau retourné par la méthode <ph id="ph1">`Numbers.GetTenPrimes`</ph> n’est pas conforme CLS.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>All array elements must consist of CLS-compliant types.</source>
          <target state="translated">Tous les éléments du tableau doivent se composer de types conformes à CLS.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>The following example defines two methods that return non-CLS-compliant arrays.</source>
          <target state="translated">L'exemple suivant définit deux méthodes qui retournent des tableaux non conformes à CLS.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>The first returns an array of <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept> values.</source>
          <target state="translated">La première retourne un tableau de valeurs <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>The second returns an <bpt id="p1">[</bpt>Object<ept id="p1">](xref:System.Object)</ept> array that includes <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept> and <ph id="ph1">`UInt32`</ph> values.</source>
          <target state="translated">La deuxième retourne un tableau <bpt id="p1">[</bpt>Object<ept id="p1">](xref:System.Object)</ept> qui inclut les valeurs <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept> et <ph id="ph1">`UInt32`</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Although the compiler identifies the first array as non-compliant because of its <ph id="ph1">`UInt32`</ph> type, it fails to recognize that the second array includes non-CLS-compliant elements.</source>
          <target state="translated">Bien que le compilateur identifie le premier tableau comme non conforme en raison de son type <ph id="ph1">`UInt32`</ph>, il ne parvient pas à reconnaître que le second tableau inclut des éléments non conformes à CLS.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>Overload resolution for methods that have array parameters is based on the fact that they are arrays and on their element type.</source>
          <target state="translated">La résolution de surcharge pour les méthodes qui ont des paramètres de tableau repose sur le fait qu’il s’agit de tableaux et sur leur type d’élément.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>For this reason, the following definition of an overloaded <ph id="ph1">`GetSquares`</ph> method is CLS-compliant.</source>
          <target state="translated">C'est pourquoi la définition suivante d'une méthode <ph id="ph1">`GetSquares`</ph> surchargée est conforme à CLS.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>CLS-compliant interfaces can define properties, events, and virtual methods (methods with no implementation).</source>
          <target state="translated">Les interfaces conformes à CLS peuvent définir des propriétés, des événements et des méthodes virtuelles (méthodes sans implémentation).</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>A CLS-compliant interface cannot have any of the following:</source>
          <target state="translated">Une interface conforme à CLS ne peut avoir aucune des caractéristiques suivantes :</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>Static methods or static fields.</source>
          <target state="translated">Méthodes statiques ou champs static.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The C# compiler generatse compiler errors if you define a static member in an interface.</source>
          <target state="translated">Le compilateur C# génère des erreurs du compilateur si vous définissez un membre statique dans une interface.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Fields.</source>
          <target state="translated">Champs.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>The C# acompiler generates compiler errors if you define a field in an interface.</source>
          <target state="translated">Le compilateur C# génère des erreurs du compilateur si vous définissez un champ dans une interface.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>Methods that are not CLS-compliant.</source>
          <target state="translated">Méthodes qui ne sont pas conformes à CLS.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>For example, the following interface definition includes a method, <ph id="ph1">`INumber.GetUnsigned`</ph>, that is marked as non-CLS-compliant.</source>
          <target state="translated">Par exemple, la définition d'interface suivante inclut une méthode, <ph id="ph1">`INumber.GetUnsigned`</ph>, qui est marquée comme non conforme à CLS.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>This example generates a compiler warning.</source>
          <target state="translated">Cet exemple génère un avertissement du compilateur.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>Because of this rule, CLS-compliant types are not required to implement non-CLS-compliant members.</source>
          <target state="translated">En raison de cette règle, pour implémenter des membres non conformes à CLS, il n'est pas nécessaire d'utiliser des types conformes à CLS.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>If a CLS-compliant framework does expose a class that implements a non-CLS compliant interface, it should also provide concrete implementations of all non-CLS-compliant members.</source>
          <target state="translated">Si une infrastructure conforme à CLS expose une classe qui implémente une interface non conforme à CLS, elle doit également fournir des implémentations concrètes de tous les membres non conformes.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>CLS-compliant language compilers must also allow a class to provide separate implementations of members that have the same name and signature in multiple interfaces.</source>
          <target state="translated">Les compilateurs de langages conformes à CLS doivent également permettre à une classe de fournir des implémentations séparées des membres qui ont les mêmes nom et signature dans plusieurs interfaces.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>C# supports explicit interface implementations to provide different implementations of identically named methods.</source>
          <target state="translated">C# prend en charge des implémentations d’interface explicites pour fournir des implémentations différentes de méthodes portant le même nom.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The following example illustrates this scenario by defining a <ph id="ph1">`Temperature`</ph> class that implements the <ph id="ph2">`ICelsius`</ph> and <ph id="ph3">`IFahrenheit`</ph> interfaces as explicit interface implementations.</source>
          <target state="translated">L'exemple suivant illustre ce scénario en définissant une classe <ph id="ph1">`Temperature`</ph> qui implémente les interfaces <ph id="ph2">`ICelsius`</ph> et <ph id="ph3">`IFahrenheit`</ph> en tant qu'implémentations d'interface explicites.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Énumérations</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>CLS-compliant enumerations must follow these rules:</source>
          <target state="translated">Les énumérations conformes à CLS doivent suivre ces règles :</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>The underlying type of the enumeration must be an intrinsic CLS-compliant integer (<bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, <bpt id="p2">[</bpt>Int16<ept id="p2">](xref:System.Int16)</ept>, <bpt id="p3">[</bpt>Int32<ept id="p3">](xref:System.Int32)</ept>, or <bpt id="p4">[</bpt>Int64<ept id="p4">](xref:System.Int64)</ept>).</source>
          <target state="translated">Le type sous-jacent de l’énumération doit être un entier conforme CLS intrinsèque (<bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, <bpt id="p2">[</bpt>Int16<ept id="p2">](xref:System.Int16)</ept>, <bpt id="p3">[</bpt>Int32<ept id="p3">](xref:System.Int32)</ept> ou <bpt id="p4">[</bpt>Int64<ept id="p4">](xref:System.Int64)</ept>).</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>For example, the following code tries to define an enumeration whose underlying type is <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept> and generates a compiler warning.</source>
          <target state="translated">Par exemple, le code suivant tente de définir une énumération dont le type sous-jacent est <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept> et génère un avertissement du compilateur.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>An enumeration type must have a single instance field named <ph id="ph1">`Value__`</ph> that is marked with the <ph id="ph2">`FieldAttributes.RTSpecialName`</ph> attribute.</source>
          <target state="translated">Un type d'énumération doit avoir un champ d'instance unique nommé <ph id="ph1">`Value__`</ph> qui est marqué avec l'attribut <ph id="ph2">`FieldAttributes.RTSpecialName`</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>This enables you to reference the field value implicitly.</source>
          <target state="translated">Cela vous permet de référencer implicitement la valeur du champ.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>An enumeration includes literal static fields whose types match the type of the enumeration itself.</source>
          <target state="translated">Une énumération inclut les champs statiques littéraux du même type que l'énumération elle-même.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>For example, if you define a <ph id="ph1">`State`</ph> enumeration with values of <ph id="ph2">`State.On`</ph> and <ph id="ph3">`State.Off`</ph>, <ph id="ph4">`State.On`</ph> and <ph id="ph5">`State.Off`</ph> are both literal static fields whose type is <ph id="ph6">`State`</ph>.</source>
          <target state="translated">Par exemple, si vous définissez une énumération <ph id="ph1">`State`</ph> avec les valeurs <ph id="ph2">`State.On`</ph> et <ph id="ph3">`State.Off`</ph>, <ph id="ph4">`State.On`</ph> et <ph id="ph5">`State.Off`</ph> sont les deux champs statiques littéraux dont le type est <ph id="ph6">`State`</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>There are two kinds of enumerations:</source>
          <target state="translated">Il existe deux types d'énumérations :</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>An enumeration that represents a set of mutually exclusive, named integer values.</source>
          <target state="translated">Une énumération qui représente un jeu de valeurs entières nommées qui s'excluent mutuellement.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>This type of enumeration is indicated by the absence of the <bpt id="p1">[</bpt>System.FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> custom attribute.</source>
          <target state="translated">Ce type d’énumération est indiqué par l’absence de l’attribut personnalisé <bpt id="p1">[</bpt>System.FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>An enumeration that represents a set of bit flags that can combine to generate an unnamed value.</source>
          <target state="translated">Une énumération qui représente un jeu d'indicateurs binaires qui peuvent être combinés pour générer une valeur sans nom.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>This type of enumeration is indicated by the presence of the <bpt id="p1">[</bpt>System.FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> custom attribute.</source>
          <target state="translated">Ce type d’énumération est indiqué par la présence de l’attribut personnalisé <bpt id="p1">[</bpt>System.FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>For more information, see the documentation for the <bpt id="p1">[</bpt>Enum<ept id="p1">](xref:System.Enum)</ept> structure.</source>
          <target state="translated">Pour plus d’informations, consultez la documentation de la structure <bpt id="p1">[</bpt>Enum<ept id="p1">](xref:System.Enum)</ept>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>The value of an enumeration is not limited to the range of its specified values.</source>
          <target state="translated">La valeur d'une énumération ne se limite pas à la plage de ses valeurs spécifiées.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>In other words, the range of values in an enumeration is the range of its underlying value.</source>
          <target state="translated">En d'autres termes, la plage de valeurs d'une énumération est la plage de sa valeur sous-jacente.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">`Enum.IsDefined`</ph> method to determine whether a specified value is a member of an enumeration.</source>
          <target state="translated">Vous pouvez utiliser la méthode <ph id="ph1">`Enum.IsDefined`</ph> pour déterminer si une valeur spécifiée est membre d'une énumération.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>Type members in general</source>
          <target state="translated">Membres de types en général</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>The Common Language Specification requires all fields and methods to be accessed as members of a particular class.</source>
          <target state="translated">La spécification CLS (Common Language Specification) nécessite que tous les champs et toutes les méthodes soient accessibles en tant que membres d'une classe particulière.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Therefore, global static fields and methods (that is, static fields or methods that are defined apart from a type) are not CLS-compliant.</source>
          <target state="translated">Par conséquent, les méthodes et les champs static globaux (autrement dit, les méthodes ou les champs static définis en dehors d’un type) ne sont pas conformes à CLS.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>If you try to include a global field or method in your source code, the C# compiler generates a compiler error.</source>
          <target state="translated">Si vous essayez d’inclure un champ global ou une méthode globale dans votre code source, le compilateur C# génère une erreur de compilateur.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>The Common Language Specification supports only the standard managed calling convention.</source>
          <target state="translated">La spécification CLS (Common Language Specification) prend uniquement en charge la convention d’appel managée standard.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>It doesn't support unmanaged calling conventions and methods with variable argument lists marked with the <ph id="ph1">`varargs`</ph> keyword.</source>
          <target state="translated">Elle ne prend pas en charge les conventions d'appel non managées ni les méthodes avec des listes d'arguments variables marquées avec le mot clé <ph id="ph1">`varargs`</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>For variable argument lists that are compatible with the standard managed calling convention, use the <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> attribute or the individual language's implementation, such as the <ph id="ph1">`params`</ph> keyword in C# and the <ph id="ph2">`ParamArray`</ph> keyword in Visual Basic.</source>
          <target state="translated">Pour les listes d’arguments variables compatibles avec la convention d’appel managée standard, utilisez l’attribut <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> ou l’implémentation de chaque langage, comme le mot clé <ph id="ph1">`params`</ph> en C# et le mot clé <ph id="ph2">`ParamArray`</ph> en Visual Basic.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>Member accessibility</source>
          <target state="translated">Accessibilité des membres</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Overriding an inherited member cannot change the accessibility of that member.</source>
          <target state="translated">Le remplacement d'un membre hérité ne peut pas modifier l'accessibilité de ce membre.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>For example, a public method in a base class cannot be overridden by a private method in a derived class.</source>
          <target state="translated">Par exemple, une méthode publique dans une classe de base ne peut pas être remplacée par une méthode privée dans une classe dérivée.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>There is one exception: a <ph id="ph1">`protected internal`</ph> (in C#) or <ph id="ph2">`Protected Friend`</ph> (in Visual Basic) member in one assembly that is overridden by a type in a different assembly.</source>
          <target state="translated">Il existe une exception : un membre <ph id="ph1">`protected internal`</ph> (en C#) ou <ph id="ph2">`Protected Friend`</ph> (en Visual Basic) dans un assembly qui est remplacé par un type dans un autre assembly.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>In that case, the accessibility of the override is <ph id="ph1">`Protected`</ph>.</source>
          <target state="translated">Dans ce cas, l'accessibilité du remplacement est <ph id="ph1">`Protected`</ph>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The following example illustrates the error that is generated when the <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> attribute is set to <ph id="ph1">`true`</ph>, and <ph id="ph2">`Person`</ph>, which is a class derived from <ph id="ph3">`Animal`</ph>, tries to change the accessibility of the <ph id="ph4">`Species`</ph> property from public to private.</source>
          <target state="translated">L’exemple suivant illustre l’erreur générée quand l’attribut <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> a la valeur <ph id="ph1">`true`</ph>, et que <ph id="ph2">`Person`</ph>, qui est une classe dérivée de <ph id="ph3">`Animal`</ph>, tente de remplacer l’accessibilité publique de la propriété <ph id="ph4">`Species`</ph> par une accessibilité privée.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The example compiles successfully if its accessibility is changed to public.</source>
          <target state="translated">L'exemple se compile correctement si son accessibilité devient publique.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>Types in the signature of a member must be accessible whenever that member is accessible.</source>
          <target state="translated">Les types de la signature d'un membre doivent être accessibles chaque fois que ce membre est accessible.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>For example, this means that a public member cannot include a parameter whose type is private, protected, or internal.</source>
          <target state="translated">Par exemple, cela signifie qu’un membre public ne peut pas inclure un paramètre dont le type est privé, protégé ou interne.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>The following example illustrates the compiler error that results when a <ph id="ph1">`StringWrapper`</ph> class constructor exposes an internal <ph id="ph2">`StringOperationType`</ph> enumeration value that determines how a string value should be wrapped.</source>
          <target state="translated">L'exemple suivant illustre l'erreur de compilateur obtenue lorsqu'un constructeur de classe <ph id="ph1">`StringWrapper`</ph> expose une valeur d'énumération <ph id="ph2">`StringOperationType`</ph> interne qui détermine comment une valeur de chaîne doit être encapsulée.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>Generic types and members</source>
          <target state="translated">Types et membres génériques</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>Nested types always have at least as many generic parameters as their enclosing type.</source>
          <target state="translated">Les types imbriqués ont toujours au moins autant de paramètres génériques que leur type englobant.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>These correspond by position to the generic parameters in the enclosing type.</source>
          <target state="translated">Ceux-ci correspondent par position aux paramètres génériques du type englobant.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>The generic type can also include new generic parameters.</source>
          <target state="translated">Le type générique peut également inclure de nouveaux paramètres génériques.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The relationship between the generic type parameters of a containing type and its nested types may be hidden by the syntax of individual languages.</source>
          <target state="translated">La relation entre les paramètres de type générique d'un type conteneur et ses types imbriqués peut être masquée par la syntaxe des différents langages.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>In the following example, a generic type <ph id="ph1">`Outer&lt;T&gt;`</ph> contains two nested classes, <ph id="ph2">`Inner1A`</ph> and <ph id="ph3">`Inner1B&lt;U&gt;`</ph>.</source>
          <target state="translated">Dans l'exemple suivant, un type générique <ph id="ph1">`Outer&lt;T&gt;`</ph> contient deux classes imbriquées, <ph id="ph2">`Inner1A`</ph> et <ph id="ph3">`Inner1B&lt;U&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>The calls to the <ph id="ph1">`ToString`</ph> method, which each class inherits from <ph id="ph2">`Object.ToString`</ph>, show that each nested class includes the type parameters of its containing class.</source>
          <target state="translated">Les appels à la méthode <ph id="ph1">`ToString`</ph>, dont chaque classe hérite de <ph id="ph2">`Object.ToString`</ph>, indiquent que chaque classe imbriquée inclut les paramètres de type de sa classe conteneur.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>Generic type names are encoded in the form <bpt id="p1">*</bpt>name<ept id="p1">*</ept>'<bpt id="p2">*</bpt>n<ept id="p2">*</ept>, where <bpt id="p3">*</bpt>name<ept id="p3">*</ept> is the type name, <bpt id="p4">*</bpt><ph id="ph1">`</ph><ept id="p4">*</ept> is a character literal, and <bpt id="p5">*</bpt>n<ept id="p5">*</ept> is the number of parameters declared on the type, or, for nested generic types, the number of newly introduced type parameters.</source>
          <target state="translated">Les noms des types génériques sont encodés sous la forme <bpt id="p1">*</bpt>nom<ept id="p1">*</ept>'<bpt id="p2">*</bpt>n<ept id="p2">*</ept>, où <bpt id="p3">*</bpt>nom<ept id="p3">*</ept> est le nom du type, <bpt id="p4">*</bpt><ph id="ph1">`</ph><ept id="p4">*</ept> est un caractère littéral et <bpt id="p5">*</bpt>n<ept id="p5">*</ept> est le nombre de paramètres déclarés sur le type ou, pour les types génériques imbriqués, le nombre de paramètres de type récemment introduits.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>This encoding of generic type names is primarily of interest to developers who use reflection to access CLS-complaint generic types in a library.</source>
          <target state="translated">Cet encodage de noms de types génériques intéresse principalement les développeurs qui utilisent la réflexion pour accéder aux types génériques conformes à CLS dans une bibliothèque.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>If constraints are applied to a generic type, any types used as constraints must also be CLS-compliant.</source>
          <target state="translated">Si les contraintes sont appliquées à un type générique, tous les types utilisés en tant que contraintes doivent également être conformes à CLS.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>The following example defines a class named <ph id="ph1">`BaseClass`</ph> that is not CLS-compliant and a generic class named <ph id="ph2">`BaseCollection`</ph> whose type parameter must derive from <ph id="ph3">`BaseClass`</ph>.</source>
          <target state="translated">L'exemple suivant définit une classe nommée <ph id="ph1">`BaseClass`</ph> qui n'est pas conforme à CLS et une classe générique nommée <ph id="ph2">`BaseCollection`</ph> dont le paramètre de type doit dériver de <ph id="ph3">`BaseClass`</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>But because <ph id="ph1">`BaseClass`</ph>is not CLS-compliant, the compiler emits a warning.</source>
          <target state="translated">Toutefois, comme <ph id="ph1">`BaseClass`</ph> n’est pas conforme CLS, le compilateur émet un avertissement.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>If a generic type is derived from a generic base type, it must redeclare any constraints so that it can guarantee that constraints on the base type are also satisfied.</source>
          <target state="translated">Si un type générique est dérivé d'un type de base générique, il doit redéclarer toutes les contraintes pour s'assurer que les contraintes du type de base sont également satisfaites.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`Number&lt;T&gt;`</ph> that can represent any numeric type.</source>
          <target state="translated">L'exemple suivant définit un <ph id="ph1">`Number&lt;T&gt;`</ph> qui peut représenter un type numérique.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>It also defines a <ph id="ph1">`FloatingPoint&lt;T&gt;`</ph> class that represents a floating point value.</source>
          <target state="translated">Il définit également une classe <ph id="ph1">`FloatingPoint&lt;T&gt;`</ph> qui représente une valeur à virgule flottante.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>However, the source code fails to compile, because it does not apply the constraint on <ph id="ph1">`Number&lt;T&gt;`</ph> (that T must be a value type) to <ph id="ph2">`FloatingPoint&lt;T&gt;`</ph>.</source>
          <target state="translated">Toutefois, le code source ne se compile pas, car il n'applique pas la contrainte <ph id="ph1">`Number&lt;T&gt;`</ph> (ce T doit être un type de valeur) à <ph id="ph2">`FloatingPoint&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The example compiles successfully if the constraint is added to the <ph id="ph1">`FloatingPoint&lt;T&gt;`</ph> class.</source>
          <target state="translated">L'exemple se compile correctement si la contrainte est ajoutée à la classe <ph id="ph1">`FloatingPoint&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The Common Language Specification imposes a conservative per-instantiation model for nested types and protected members.</source>
          <target state="translated">La spécification CLS (Common Language Specification) impose un modèle conservateur par instanciation pour les types imbriqués et les membres protégés.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Open generic types cannot expose fields or members with signatures that contain a specific instantiation of a nested, protected generic type.</source>
          <target state="translated">Les types génériques ouverts ne peuvent pas exposer de champs ou de membres avec des signatures qui contiennent une instanciation spécifique d'un type générique imbriqué et protégé.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>Non-generic types that extend a specific instantiation of a generic base class or interface cannot expose fields or members with signatures that contain a different instantiation of a nested, protected generic type.</source>
          <target state="translated">Les types non génériques qui étendent une instanciation spécifique d'une classe de base ou une interface générique ne peuvent pas exposer de champs ou de membres avec des signatures qui contiennent une instanciation différente d'un type générique imbriqué et protégé.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The following example defines a generic type, <ph id="ph1">`C1&lt;T&gt;`</ph>, and a protected class, <ph id="ph2">`C1&lt;T&gt;.N`</ph>.</source>
          <target state="translated">L’exemple suivant définit un type générique, <ph id="ph1">`C1&lt;T&gt;`</ph>, et une classe protégée, <ph id="ph2">`C1&lt;T&gt;.N`</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`C1&lt;T&gt;`</ph> has two methods, <ph id="ph2">`M1`</ph> and <ph id="ph3">`M2`</ph>.</source>
          <target state="translated"><ph id="ph1">`C1&lt;T&gt;`</ph> a deux méthodes : <ph id="ph2">`M1`</ph> et <ph id="ph3">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>However, <ph id="ph1">`M1`</ph> is not CLS-compliant because it tries to return a <ph id="ph2">`C1&lt;int&gt;.N`</ph> object from <ph id="ph3">`C1&lt;T&gt;`</ph>.</source>
          <target state="translated">Toutefois, la méthode <ph id="ph1">`M1`</ph> n’est pas conforme CLS, car elle essaie de retourner un objet <ph id="ph2">`C1&lt;int&gt;.N`</ph> de <ph id="ph3">`C1&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>A second class, <ph id="ph1">`C2`</ph>, is derived from <ph id="ph2">`C1&lt;long&gt;`</ph>.</source>
          <target state="translated">Une deuxième classe, <ph id="ph1">`C2`</ph>, est dérivée de <ph id="ph2">`C1&lt;long&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>It has two methods, <ph id="ph1">`M3`</ph> and <ph id="ph2">`M4`</ph>.</source>
          <target state="translated">Elle a deux méthodes, <ph id="ph1">`M3`</ph> et <ph id="ph2">`M4`</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`M3`</ph> is not CLS-compliant because it tries to return a <ph id="ph2">`C1&lt;int&gt;.N`</ph> object from a subclass of <ph id="ph3">`C1&lt;long&gt;`</ph>.</source>
          <target state="translated"><ph id="ph1">`M3`</ph>’est pas conforme CLS, car elle essaie de retourner un objet <ph id="ph2">`C1&lt;int&gt;.N`</ph> d’une sous-classe de <ph id="ph3">`C1&lt;long&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>Note that language compilers can be even more restrictive.</source>
          <target state="translated">Notez que les compilateurs de langage peuvent être encore plus restrictifs.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>In this example, Visual Basic displays an error when it tries to compile <ph id="ph1">`M4`</ph>.</source>
          <target state="translated">Dans cet exemple, Visual Basic affiche une erreur lorsqu'il tente de compiler <ph id="ph1">`M4`</ph>.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructeurs</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>Constructors in CLS-compliant classes and structures must follow these rules:</source>
          <target state="translated">Les constructeurs des classes et structures conformes à CLS doivent suivre ces règles :</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>A constructor of a derived class must call the instance constructor of its base class before it accesses inherited instance data.</source>
          <target state="translated">Un constructeur d'une classe dérivée doit appeler le constructeur d'instance de sa classe de base avant d'accéder aux données d'instance héritées.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>This requirement is due to the fact that base class constructors are not inherited by their derived classes.</source>
          <target state="translated">Cette spécification est due au fait que les constructeurs de classes de base ne sont pas hérités par leurs classes dérivées.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>This rule does not apply to structures, which do not support direct inheritance.</source>
          <target state="translated">Cette règle ne s'applique pas aux structures, qui ne prennent pas en charge l'héritage direct.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>Typically, compilers enforce this rule independently of CLS compliance, as the following example shows.</source>
          <target state="translated">En général, les compilateurs appliquent cette règle indépendamment de la conformité CLS, comme indiqué dans l'exemple suivant.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>It creates a <ph id="ph1">`Doctor`</ph> class that is derived from a <ph id="ph2">`Person`</ph> class, but the <ph id="ph3">`Doctor`</ph>class fails to call the <ph id="ph4">`Person`</ph> class constructor to initialize inherited instance fields.</source>
          <target state="translated">Il crée une classe <ph id="ph1">`Doctor`</ph> dérivée d’une classe <ph id="ph2">`Person`</ph>, mais la classe <ph id="ph3">`Doctor`</ph> ne parvient pas à appeler le constructeur de classe <ph id="ph4">`Person`</ph> pour initialiser les champs d’instance hérités.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>An object constructor cannot be called except to create an object.</source>
          <target state="translated">Un constructeur d'objet ne peut être appelé que pour créer un objet.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>In addition, an object cannot be initialized twice.</source>
          <target state="translated">En outre, un objet ne peut pas être initialisé deux fois.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>For example, this means that <ph id="ph1">`Object.MemberwiseClone`</ph> must not call constructors.</source>
          <target state="translated">Par exemple, cela signifie que <ph id="ph1">`Object.MemberwiseClone`</ph> ne doit pas appeler de constructeurs.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Propriétés</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>Properties in CLS-compliant types must follow these rules:</source>
          <target state="translated">Les propriétés dans les types conformes à CLS doivent suivre ces règles :</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>A property must have a setter, a getter, or both.</source>
          <target state="translated">Une propriété doit posséder une méthode setter, getter ou les deux.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>In an assembly, these are implemented as special methods, which means that they will appear as separate methods (the getter is named <ph id="ph1">`get`</ph><ph id="ph2">\_</ph><bpt id="p1">*</bpt>propertyname<ept id="p1">*</ept> and the setter is <ph id="ph3">`set*\_*propertyname*) marked as `</ph>SpecialName` in the assembly's metadata.</source>
          <target state="translated">Dans un assembly, celles-ci sont implémentées comme des méthodes spéciales, ce qui signifie qu’elles apparaissent comme des méthodes distinctes (la méthode getter est nommée <ph id="ph1">`get`</ph><ph id="ph2">\_</ph><bpt id="p1">*</bpt>propertyname<ept id="p1">*</ept> et la méthode setter est nommée <ph id="ph3">`set*\_*propertyname*) marked as `</ph>SpecialName` dans les métadonnées de l’assembly.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>The C# compiler enforces this rule automatically without the need to apply the <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> attribute.</source>
          <target state="translated">Le compilateur C# applique automatiquement cette règle sans qu’il soit nécessaire d’appliquer l’attribut <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>A property's type is the return type of the property getter and the last argument of the setter.</source>
          <target state="translated">Le type d’une propriété correspond au type de retour de la méthode getter de la propriété et du dernier argument de la méthode setter.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>These types must be CLS compliant, and arguments cannot be assigned to the property by reference (that is, they cannot be managed pointers).</source>
          <target state="translated">Ces types doivent être conformes à CLS et les arguments ne peuvent pas être assignés à la propriété par référence (autrement dit, ils ne peuvent pas être des pointeurs managés).</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>If a property has both a getter and a setter, they must both be virtual, both static, or both instance.</source>
          <target state="translated">Si une propriété possède une méthode getter et une méthode setter, elles doivent être toutes les deux virtuelles, statiques ou être toutes les deux des instances.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>The C# compiler automatically enforces this rule through property definition syntax.</source>
          <target state="translated">Le compilateur C# applique automatiquement cette règle par le biais de la syntaxe de définition de propriété.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Événements</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>An event is defined by its name and its type.</source>
          <target state="translated">Un événement est défini par son nom et son type.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>The event type is a delegate that is used to indicate the event.</source>
          <target state="translated">Le type d'événement est un délégué utilisé pour indiquer l'événement.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">`DbConnection.StateChange`</ph> event is of type <ph id="ph2">`StateChangeEventHandler`</ph>.</source>
          <target state="translated">Par exemple, l'événement <ph id="ph1">`DbConnection.StateChange`</ph> est de type <ph id="ph2">`StateChangeEventHandler`</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>In addition to the event itself, three methods with names based on the event name provide the event's implementation and are marked as <ph id="ph1">`SpecialName`</ph> in the assembly's metadata:</source>
          <target state="translated">Outre l'événement lui-même, trois méthodes avec des noms basés sur le nom de l'événement fournissent une implémentation de l'événement et sont marquées comme <ph id="ph1">`SpecialName`</ph> dans les métadonnées de l'assembly :</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>A method for adding an event handler, named <ph id="ph1">`add`</ph>_<bpt id="p1">*</bpt>EventName<ept id="p1">*</ept>.</source>
          <target state="translated">Une méthode pour ajouter un gestionnaire d’événements, appelée <ph id="ph1">`add`</ph>_<bpt id="p1">*</bpt>EventName<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>For example, the event subscription method for the <ph id="ph1">`DbConnection.StateChange`</ph> event is named <ph id="ph2">`add_StateChange`</ph>.</source>
          <target state="translated">Par exemple, la méthode d'abonnement aux événements pour l'événement <ph id="ph1">`DbConnection.StateChange`</ph> est nommée <ph id="ph2">`add_StateChange`</ph>.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>A method for removing an event handler, named <ph id="ph1">`remove`</ph>_<bpt id="p1">*</bpt>EventName<ept id="p1">*</ept>.</source>
          <target state="translated">Une méthode pour supprimer un gestionnaire d’événements, appelée <ph id="ph1">`remove`</ph>_<bpt id="p1">*</bpt>EventName<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>For example, the removal method for the <ph id="ph1">`DbConnection.StateChange`</ph> event is named <ph id="ph2">`remove_StateChange`</ph>.</source>
          <target state="translated">Par exemple, la méthode de suppression pour l'événement <ph id="ph1">`DbConnection.StateChange`</ph> est nommée <ph id="ph2">`remove_StateChange`</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>A method for indicating that the event has occurred, named <ph id="ph1">`raise`</ph>_<bpt id="p1">*</bpt>EventName<ept id="p1">*</ept>.</source>
          <target state="translated">Une méthode pour indiquer que l’événement s’est produit, appelée <ph id="ph1">`raise`</ph>_<bpt id="p1">*</bpt>EventName<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>Most of the Common Language Specification's rules regarding events are implemented by language compilers and are transparent to component developers.</source>
          <target state="translated">La plupart des règles de la spécification CLS concernant les événements sont implémentées par les compilateurs de langage et sont transparentes aux développeurs de composants.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>The methods for adding, removing, and raising the event must have the same accessibility.</source>
          <target state="translated">L'accessibilité des méthodes permettant d'ajouter, de supprimer et de déclencher un événement doit être identique.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>They must also all be static, instance, or virtual.</source>
          <target state="translated">Les méthodes doivent également toutes être statiques, instanciées ou virtuelles.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The methods for adding and removing an event have one parameter whose type is the event delegate type.</source>
          <target state="translated">Les méthodes d'ajout et de suppression d'un événement ont un paramètre dont le type est le type du délégué d'événement.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>The add and remove methods must both be present or both be absent.</source>
          <target state="translated">Les méthodes d'ajout et de suppression doivent être toutes les deux présentes ou absentes.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>The following example defines a CLS-compliant class named <ph id="ph1">`Temperature`</ph> that raises a <ph id="ph2">`TemperatureChanged`</ph> event if the change in temperature between two readings equals or exceeds a threshold value.</source>
          <target state="translated">L'exemple suivant définit une classe conforme à CLS nommée <ph id="ph1">`Temperature`</ph> qui déclenche un événement <ph id="ph2">`TemperatureChanged`</ph> si le changement de température entre deux lectures est égal ou supérieur à une valeur seuil.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Temperature`</ph> class explicitly defines a <ph id="ph2">`raise_TemperatureChanged`</ph> method so that it can selectively execute event handlers.</source>
          <target state="translated">La classe <ph id="ph1">`Temperature`</ph> définit explicitement une méthode <ph id="ph2">`raise_TemperatureChanged`</ph> afin de pouvoir exécuter de manière sélective les gestionnaires d'événements.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="translated">Overloads</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>The Common Language Specification imposes the following requirements on overloaded members:</source>
          <target state="translated">La spécification CLS impose les conditions suivantes aux membres surchargés :</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>Members can be overloaded based on the number of parameters and the type of any parameter.</source>
          <target state="translated">Les membres peuvent être surchargés selon le nombre de paramètres et le type d'un paramètre.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Calling convention, return type, custom modifiers applied to the method or its parameter, and whether parameters are passed by value or by reference are not considered when differentiating between overloads.</source>
          <target state="translated">La convention d’appel, le type de retour, les modificateurs personnalisés appliqués à la méthode ou à son paramètre et le fait que les paramètres soient transmis par valeur ou par référence ne sont pas pris en considération lors de la différenciation des surcharges.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>For an example, see the code for the requirement that names must be unique within a scope in the <bpt id="p1">[</bpt>Naming conventions<ept id="p1">](#naming-conventions)</ept> section.</source>
          <target state="translated">Pour obtenir un exemple, consultez le code de l’exigence indiquant que les noms doivent être uniques dans une portée, dans la section <bpt id="p1">[</bpt>Conventions d’affectation de noms<ept id="p1">](#naming-conventions)</ept>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>Only properties and methods can be overloaded.</source>
          <target state="translated">Seules les propriétés et les méthodes peuvent être surchargées.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>Fields and events cannot be overloaded.</source>
          <target state="translated">Les champs et les événements ne peuvent pas être surchargés.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>Generic methods can be overloaded based on the number of their generic parameters.</source>
          <target state="translated">Les méthodes génériques peuvent être surchargées selon le nombre de leurs paramètres génériques.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`op_Explicit`</ph> and <ph id="ph2">`op_Implicit`</ph> operators are exceptions to the rule that return value is not considered part of a method signature for overload resolution.</source>
          <target state="translated">Les opérateurs <ph id="ph1">`op_Explicit`</ph> et <ph id="ph2">`op_Implicit`</ph> sont des exceptions à la règle indiquant que la valeur de retour n'est pas considérée comme faisant partie d'une signature de méthode pour la résolution de la surcharge.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>These two operators can be overloaded based on both their parameters and their return value.</source>
          <target state="translated">Ces deux opérateurs peuvent être surchargés selon leurs paramètres et leur valeur de retour.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>Exception objects must derive from <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept> or from another type derived from <ph id="ph1">`System.Exception`</ph>.</source>
          <target state="translated">Les objets d’exception doivent dériver de <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept> ou d’un autre type dérivé de <ph id="ph1">`System.Exception`</ph>.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>The following example illustrates the compiler error that results when a custom class named <ph id="ph1">`ErrorClass`</ph> is used for exception handling.</source>
          <target state="translated">L'exemple suivant illustre l'erreur de compilateur obtenue lorsqu'une classe personnalisée nommée <ph id="ph1">`ErrorClass`</ph> est utilisée pour la gestion des exceptions.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>To correct this error, the <ph id="ph1">`ErrorClass`</ph> class must inherit from <ph id="ph2">`System.Exception`</ph>.</source>
          <target state="translated">Pour corriger cette erreur, la classe <ph id="ph1">`ErrorClass`</ph> doit hériter de <ph id="ph2">`System.Exception`</ph>.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>In addition, the Message property must be overridden.</source>
          <target state="translated">Par ailleurs, la propriété Message doit être remplacée.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>The following example corrects these errors to define an <ph id="ph1">`ErrorClass`</ph> class that is CLS-compliant.</source>
          <target state="translated">L'exemple suivant corrige ces erreurs pour définir une classe <ph id="ph1">`ErrorClass`</ph> conforme à CLS.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributs</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>In.NET Framework assemblies, custom attributes provide an extensible mechanism for storing custom attributes and retrieving metadata about programming objects, such as assemblies, types, members, and method parameters.</source>
          <target state="translated">Dans les assemblys .NET Framework, les attributs personnalisés fournissent un mécanisme extensible pour stocker des attributs personnalisés et récupérer les métadonnées concernant la programmation des objets, tels que les assemblys, les types, les membres et les paramètres de méthode.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>Custom attributes must derive from <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept> or from a type derived from <ph id="ph1">`System.Attribute`</ph>.</source>
          <target state="translated">Les attributs personnalisés doivent dériver de <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept> ou d’un type dérivé de <ph id="ph1">`System.Attribute`</ph>.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>The following example violates this rule.</source>
          <target state="translated">L'exemple suivant enfreint cette règle.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>It defines a <ph id="ph1">`NumericAttribute`</ph> class that does not derive from <ph id="ph2">`System.Attribute`</ph>.</source>
          <target state="translated">Il définit une classe <ph id="ph1">`NumericAttribute`</ph> qui ne dérive pas de <ph id="ph2">`System.Attribute`</ph>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>Note that a compiler error results only when the non-CLS-compliant attribute is applied, not when the class is defined.</source>
          <target state="translated">Notez qu'une erreur du compilateur se produit uniquement lorsque l'attribut non conforme à CLS est appliqué, pas lorsque la classe est définie.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>The constructor or the properties of a CLS-compliant attribute can expose only the following types:</source>
          <target state="translated">Le constructeur ou les propriétés d'un attribut conforme à CLS peuvent exposer uniquement les types suivants :</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept></target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept></target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept></target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept></target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept></target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept></target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Single<ept id="p1">](xref:System.Single)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Single<ept id="p1">](xref:System.Single)</ept></target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept></target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type<ept id="p1">](xref:System.Type)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Type<ept id="p1">](xref:System.Type)</ept></target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>Any enumeration type whose underlying type is <ph id="ph1">`Byte`</ph>, <ph id="ph2">`Int16`</ph>, <ph id="ph3">`Int32`</ph>, or <ph id="ph4">`Int64`</ph>.</source>
          <target state="translated">Tout type d'énumération dont le type sous-jacent est <ph id="ph1">`Byte`</ph>, <ph id="ph2">`Int16`</ph>, <ph id="ph3">`Int32`</ph> ou <ph id="ph4">`Int64`</ph>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`DescriptionAttribute`</ph> class that derives from <bpt id="p1">[</bpt>Attribute<ept id="p1">](xref:System.Attribute)</ept>.</source>
          <target state="translated">L’exemple suivant définit une classe <ph id="ph1">`DescriptionAttribute`</ph> qui dérive de <bpt id="p1">[</bpt>Attribute<ept id="p1">](xref:System.Attribute)</ept>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>The class constructor has a parameter of type <ph id="ph1">`Descriptor`</ph>, so the class is not CLS-compliant.</source>
          <target state="translated">Le constructeur de classe a un paramètre de type <ph id="ph1">`Descriptor`</ph>, la classe n'est donc pas conforme à CLS.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>Note that the C# compiler emits a warning but compiles successfully.</source>
          <target state="translated">Notez que le compilateur C# émet un avertissement, mais effectue la compilation.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>The CLSCompliantAttribute attribute</source>
          <target state="translated">Attribut CLSCompliantAttribute</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> attribute is used to indicate whether a program element complies with the Common Language Specification.</source>
          <target state="translated">L’attribut <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> permet d’indiquer si un élément de programme est conforme à la spécification CLS (Common Language Specification).</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CLSCompliantAttribute.CLSCompliantAttribute(Boolean)`</ph> constructor includes a single required parameter, <bpt id="p1">*</bpt>isCompliant<ept id="p1">*</ept>, that indicates whether the program element is CLS-compliant.</source>
          <target state="translated">Le constructeur <ph id="ph1">`CLSCompliantAttribute.CLSCompliantAttribute(Boolean)`</ph> inclut un seul paramètre obligatoire, <bpt id="p1">*</bpt>isCompliant<ept id="p1">*</ept>, qui indique si l’élément de programme est conforme CLS.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>At compile time, the compiler detects non-compliant elements that are presumed to be CLS-compliant and emits a warning.</source>
          <target state="translated">Au moment de la compilation, le compilateur détecte les éléments non conformes qui sont présumés conformes à CLS et émet alors un avertissement.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>The compiler does not emit warnings for types or members that are explicitly declared to be non-compliant.</source>
          <target state="translated">Le compilateur n'émet pas d'avertissements pour les types ou les membres qui sont explicitement déclarés comme étant non conformes.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>Component developers can use the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute in two ways:</source>
          <target state="translated">Les développeurs de composants peuvent utiliser l'attribut <ph id="ph1">`CLSCompliantAttribute`</ph> de deux façons :</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>To define the parts of the public interface exposed by a component that are CLS-compliant and the parts that are not CLS-compliant.</source>
          <target state="translated">Pour définir les parties de l'interface publique exposées par un composant qui sont conformes à CLS et celles qui ne sont pas conformes à CLS.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>When the attribute is used to mark particular program elements as CLS-compliant, its use guarantees that those elements are accessible from all languages and tools that target the .NET Framework.</source>
          <target state="translated">Lorsque l'attribut est utilisé pour marquer des éléments de programme particuliers comme étant conformes à CLS, son utilisation garantit que ces éléments sont accessibles à partir de tous les langages et outils qui ciblent le .NET Framework.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>To ensure that the component library's public interface exposes only program elements that are CLS-compliant.</source>
          <target state="translated">Pour vérifier que l'interface publique de la bibliothèque de composants expose uniquement les éléments de programme conformes à CLS.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>If elements are not CLS-compliant, compilers will generally issue a warning.</source>
          <target state="translated">Si les éléments ne sont pas conformes à CLS, les compilateurs publieront généralement un avertissement.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>In some cases, language compilers enforce CLS-compliant rules regardless of whether the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute is used.</source>
          <target state="translated">Dans certains cas, les compilateurs de langages imposent les règles conformes à CLS que l'attribut <ph id="ph1">`CLSCompliantAttribute`</ph> soit utilisé ou non.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>For example, defining a <ph id="ph1">`*static`</ph> member in an interface violates a CLS rule.</source>
          <target state="translated">Par exemple, la définition d’un membre <ph id="ph1">`*static`</ph> dans une interface est une infraction à une règle CLS.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>However, if you define a <ph id="ph1">`*static`</ph> member in an interface, the C# compiler displays an error message and fails to compile the app.</source>
          <target state="translated">Toutefois, si vous définissez un membre <ph id="ph1">`*static`</ph> dans une interface, le compilateur C# affiche un message d’erreur et ne compile pas l’application.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CLSCompliantAttribute`</ph> attribute is marked with an <bpt id="p1">[</bpt>AttributeUsageAttribute<ept id="p1">](xref:System.AttributeUsageAttribute)</ept> attribute that has a value of <ph id="ph2">`AttributeTargets.All`</ph>.</source>
          <target state="translated">L’attribut <ph id="ph1">`CLSCompliantAttribute`</ph> est marqué avec un attribut <bpt id="p1">[</bpt>AttributeUsageAttribute<ept id="p1">](xref:System.AttributeUsageAttribute)</ept> qui a la valeur <ph id="ph2">`AttributeTargets.All`</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>This value allows you to apply the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute to any program element, including assemblies, modules, types (classes, structures, enumerations, interfaces, and delegates), type members (constructors, methods, properties, fields, and events), parameters, generic parameters, and return values.</source>
          <target state="translated">Cette valeur permet d'appliquer l'attribut <ph id="ph1">`CLSCompliantAttribute`</ph> à un élément de programme, notamment aux assemblys, modules, types (classes, structures, énumérations, interfaces et délégués), membres de types (constructeurs, méthodes, propriétés, champs et événements), paramètres, paramètres génériques et valeurs de retour.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>However, in practice, you should apply the attribute only to assemblies, types, and type members.</source>
          <target state="translated">Toutefois, dans la pratique, vous devez appliquer l'attribut uniquement aux assemblys, aux types et aux membres de types.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Otherwise, compilers ignore the attribute and continue to generate compiler warnings whenever they encounter a non-compliant parameter, generic parameter, or return value in your library's public interface.</source>
          <target state="translated">Sinon, les compilateurs ignorent l'attribut et continuent à générer des avertissements de compilateur lorsqu'ils rencontrent un paramètre non conforme, un paramètre générique ou une valeur de retour dans l'interface publique de votre bibliothèque.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>The value of the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute is inherited by contained program elements.</source>
          <target state="translated">La valeur de l'attribut <ph id="ph1">`CLSCompliantAttribute`</ph> est héritée par les éléments de programme contenus.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>For example, if an assembly is marked as CLS-compliant, its types are also CLS-compliant.</source>
          <target state="translated">Par exemple, si un assembly est marqué comme étant conforme à CLS, ses types sont également conformes à CLS.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>If a type is marked as CLS-compliant, its nested types and members are also CLS-compliant.</source>
          <target state="translated">Si un type est marqué comme étant conforme à CLS, ses membres et types imbriqués seront également conformes à CLS.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>You can explicitly override the inherited compliance by applying the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute to a contained program element.</source>
          <target state="translated">Vous pouvez remplacer explicitement la conformité héritée en appliquant l'attribut <ph id="ph1">`CLSCompliantAttribute`</ph> à un élément de programme contenu.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>For example, you can use the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute with an <bpt id="p1">*</bpt>isCompliant<ept id="p1">*</ept> value of <ph id="ph2">`false`</ph> to define a non-compliant type in a compliant assembly, and you can use the attribute with an <bpt id="p2">*</bpt>isComplian<ept id="p2">*</ept> value of <ph id="ph3">`true`</ph> to define a compliant type in a non-compliant assembly.</source>
          <target state="translated">Par exemple, vous pouvez utiliser l’attribut <ph id="ph1">`CLSCompliantAttribute`</ph> avec une valeur <bpt id="p1">*</bpt>isCompliant<ept id="p1">*</ept> égale à <ph id="ph2">`false`</ph> pour définir un type non conforme dans un assembly conforme, et vous pouvez utiliser l’attribut avec une valeur <bpt id="p2">*</bpt>isCompliant<ept id="p2">*</ept> égale à <ph id="ph3">`true`</ph> pour définir un type conforme dans un assembly non conforme.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>You can also define non-compliant members in a compliant type.</source>
          <target state="translated">Vous pouvez également définir des membres non conformes dans un type conforme.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>However, a non-compliant type cannot have compliant members, so you cannot use the attribute with an <bpt id="p1">*</bpt>isCompliant<ept id="p1">*</ept> value of <ph id="ph1">`true`</ph> to override inheritance from a non-compliant type.</source>
          <target state="translated">Toutefois, un type non conforme ne peut pas avoir de membres conformes, vous ne pouvez donc pas utiliser l’attribut avec une valeur <bpt id="p1">*</bpt>isCompliant<ept id="p1">*</ept> égale à <ph id="ph1">`true`</ph> pour remplacer l’héritage d’un type non conforme.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>When you are developing components, you should always use the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute to indicate whether your assembly, its types, and its members are CLS-compliant.</source>
          <target state="translated">Lorsque vous développez des composants, vous devez toujours utiliser l'attribut <ph id="ph1">`CLSCompliantAttribute`</ph> pour indiquer si votre assembly, ses types et ses membres sont conformes à CLS.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>To create CLS-compliant components:</source>
          <target state="translated">Pour créer des composants conformes à CLS :</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`CLSCompliantAttribute`</ph> to mark you assembly as CLS-compliant.</source>
          <target state="translated">Utilisez <ph id="ph1">`CLSCompliantAttribute`</ph> pour marquer votre assembly comme étant conforme à CLS.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Mark any publicly exposed types in the assembly that are not CLS-compliant as non-compliant.</source>
          <target state="translated">Marquez les types exposés publiquement de l'assembly qui ne sont pas conformes à CLS comme non conformes.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Mark any publicly exposed members in CLS-compliant types as non-compliant.</source>
          <target state="translated">Marquez tous les membres exposés publiquement dans des types conformes à CLS comme non conformes.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>Provide a CLS-compliant alternative for non-CLS-compliant members.</source>
          <target state="translated">Fournissez une alternative conforme à CLS pour les membres non conformes.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>If you've successfully marked all your non-compliant types and members, your compiler should not emit any non-compliance warnings.</source>
          <target state="translated">Si vous avez correctement marqué tous vos types et membres non conformes, le compilateur ne doit émettre aucun avertissement de non-conformité.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>However, you should indicate which members are not CLS-compliant and list their CLS-compliant alternatives in your product documentation.</source>
          <target state="translated">Toutefois, vous devez indiquer quels membres ne sont pas conformes à CLS et répertorier leurs alternatives conformes à CLS dans votre documentation produit.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute to define a CLS-compliant assembly and a type, <ph id="ph2">`CharacterUtilities`</ph>, that has two non-CLS-compliant members.</source>
          <target state="translated">L'exemple suivant utilise l'attribut <ph id="ph1">`CLSCompliantAttribute`</ph> pour définir un assembly conforme à CLS et un type, <ph id="ph2">`CharacterUtilities`</ph>, qui a deux membres non conformes à CLS.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>Because both members are tagged with the <ph id="ph1">`CLSCompliant(false)`</ph> attribute, the compiler produces no warnings.</source>
          <target state="translated">Les deux membres étant référencés avec l'attribut <ph id="ph1">`CLSCompliant(false)`</ph>, le compilateur ne génère aucun avertissement.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The class also provides a CLS-compliant alternative for both methods.</source>
          <target state="translated">La classe fournit également une alternative conforme à CLS pour les deux méthodes.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Ordinarily, we would just add two overloads to the <ph id="ph1">`ToUTF16`</ph> method to provide CLS-compliant alternatives.</source>
          <target state="translated">Normalement, nous ajouterions seulement deux surcharges à la méthode <ph id="ph1">`ToUTF16`</ph> pour fournir des alternatives conformes à CLS.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>However, because methods cannot be overloaded based on return value, the names of the CLS-compliant methods are different from the names of the non-compliant methods.</source>
          <target state="translated">Toutefois, les méthodes ne pouvant pas être surchargées selon la valeur de retour, les noms des méthodes conformes à CLS sont différents des noms des méthodes non conformes.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>If you are developing an app rather than a library (that is, if you aren't exposing types or members that can be consumed by other app developers), the CLS compliance of the program elements that your app consumes are of interest only if your language does not support them.</source>
          <target state="translated">Si vous développez une application plutôt qu'une bibliothèque (autrement dit, si vous n'exposez pas des types ou des membres qui peuvent être utilisés par d'autres développeurs d'applications), la conformité CLS des éléments de programme que votre application consomme n'a d'intérêt que si votre langage ne les prend pas en charge.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>In that case, your language compiler will generate an error when you try to use a non-CLS-compliant element.</source>
          <target state="translated">Dans ce cas, votre compilateur de langage générera une erreur lorsque vous essaierez d'utiliser un élément non conforme à CLS.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>Cross-Language Interoperability</source>
          <target state="translated">Interopérabilité interlangage</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>Language independence has a number of possible meanings.</source>
          <target state="translated">L'indépendance du langage a plusieurs significations possibles.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>One meaning involves seamlessly consuming types written in one language from an app written in another language.</source>
          <target state="translated">Une des significations implique la consommation de façon transparente des types écrits dans un langage à partir d’une application écrite dans un autre langage.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>A second meaning, which is the focus of this article, involves combining code written in multiple languages into a single .NET Framework assembly.</source>
          <target state="translated">Une deuxième signification, qui est le sujet de cet article, consiste à combiner du code écrit dans plusieurs langages dans un même assembly .NET Framework.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>The following example illustrates cross-language interoperability by creating a class library named Utilities.dll that includes two classes, <ph id="ph1">`NumericLib`</ph> and <ph id="ph2">`StringLib`</ph>.</source>
          <target state="translated">L'exemple suivant illustre l'interopérabilité interlangage en créant une bibliothèque de classes nommée Utilities.dll qui comprend deux classes, <ph id="ph1">`NumericLib`</ph> et <ph id="ph2">`StringLib`</ph>.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`NumericLib`</ph> class is written in C#, and the <ph id="ph2">`StringLib`</ph> class is written in Visual Basic.</source>
          <target state="translated">La classe <ph id="ph1">`NumericLib`</ph> est écrite en C# et la classe <ph id="ph2">`StringLib`</ph> est écrite en Visual Basic.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>Here's the source code for <ph id="ph1">`StringUtil.vb`</ph>, which includes a single member, <ph id="ph2">`ToTitleCase`</ph>, in its <ph id="ph3">`StringLib`</ph> class.</source>
          <target state="translated">Voici le code source de <ph id="ph1">`StringUtil.vb`</ph>, qui comprend un seul membre, <ph id="ph2">`ToTitleCase`</ph>, dans sa classe <ph id="ph3">`StringLib`</ph>.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>Here's the source code for NumberUtil.cs, which defines a <ph id="ph1">`NumericLib`</ph> class that has two members, <ph id="ph2">`IsEven`</ph> and <ph id="ph3">`NearZero`</ph>.</source>
          <target state="translated">Voici le code source de NumberUtil.cs, qui définit une classe <ph id="ph1">`NumericLib`</ph> qui a deux membres, <ph id="ph2">`IsEven`</ph> et <ph id="ph3">`NearZero`</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>To package the two classes in a single assembly, you must compile them into modules.</source>
          <target state="translated">Pour placer les deux classes dans un même assembly, vous devez les compiler dans des modules.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>To compile the Visual Basic source code file into a module, use this command:</source>
          <target state="translated">Pour compiler le fichier de code source Visual Basic dans un module, utilisez cette commande :</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>To compile the C# source code file into a module, use this command:</source>
          <target state="translated">Pour compiler le fichier de code source C# dans un module, utilisez cette commande :</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>You then use the Link tool (Link.exe) to compile the two modules into an assembly:</source>
          <target state="translated">Vous utilisez ensuite l’outil de liaison (Link.exe) pour compiler les deux modules en un assembly :</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>The following example then calls the <ph id="ph1">`NumericLib.NearZero`</ph> and <ph id="ph2">`StringLib.ToTitleCase`</ph> methods.</source>
          <target state="translated">L'exemple suivant appelle ensuite les méthodes <ph id="ph1">`NumericLib.NearZero`</ph> et <ph id="ph2">`StringLib.ToTitleCase`</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>Note that both the Visual Basic code and the C# code are able to access the methods in both classes.</source>
          <target state="translated">Notez que le code Visual Basic et le code C# peuvent accéder aux méthodes des deux classes.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>To compile the Visual Basic code, use this command:</source>
          <target state="translated">Pour compiler le code Visual Basic, utilisez cette commande :</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>To compile with C#, change the name of the compiler from vbc to csc, and change the file extension from .vb to .cs:</source>
          <target state="translated">Pour compiler avec C#, changez le nom du compilateur vbc en csc et changez l’extension de fichier .vb en .cs :</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>