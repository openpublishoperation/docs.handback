<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">21672e28d0e76b98f6dac698096fccb2ce4edd03</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\options.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e7ed328ee4fc3ad1c060537e6e61b2ccbfdca11</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">23d388f8fdf51663297ee81b7fb936708875c16b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">Options des expressions régulières</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">Options des expressions régulières</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">Options des expressions régulières</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</source>
          <target state="translated">Par défaut, la comparaison d’une chaîne d’entrée avec des caractères littéraux dans un modèle d’expression régulière respecte la casse, l’espace blanc dans un modèle d’expression régulière est interprété comme un espace blanc littéral et les groupes de capture dans une expression régulière sont nommés de manière implicite aussi bien qu’explicite.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</source>
          <target state="translated">Vous pouvez modifier ces aspects, ainsi que d'autres, du comportement par défaut des expressions régulières en spécifiant des options d'expression régulière.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern matching method as a <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> enumeration value.</source>
          <target state="translated">Ces options, qui sont répertoriées dans le tableau suivant, peuvent être incluses inline dans le cadre du modèle d’expression régulière ou fournies à un constructeur de classe <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> ou à une méthode de mise en correspondance de modèle statique comme valeur d’énumération <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>RegexOptions member</source>
          <target state="translated">Membre RegexOptions</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Inline character</source>
          <target state="translated">Caractère inline</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Effect</source>
          <target state="translated">Effet</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Aucun<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Non disponible</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Use default behavior.</source>
          <target state="translated">Utilise le comportement par défaut.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Default options<ept id="p1">](#default-options)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Options par défaut<ept id="p1">](#default-options)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>i<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>i<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Use case-insensitive matching.</source>
          <target state="translated">Utilise la correspondance qui ne respecte pas la casse.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Case-insensitive matching<ept id="p1">](#case-insensitive-matching)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Correspondance qui ne respecte pas la casse<ept id="p1">](#case-insensitive-matching)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>m<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Use multiline mode, where <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> match the beginning and end of each line (instead of the beginning and end of the input string).</source>
          <target state="translated">Utilise le mode multiligne, où <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> et <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> correspondent au début et à la fin de chaque ligne (plutôt qu’au début et à la fin de la chaîne d’entrée).</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Multiline mode<ept id="p1">](#multiline-mode)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Mode multiligne<ept id="p1">](#multiline-mode)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>s<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>s<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Use single-line mode, where the period (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) matches every character (instead of every character except <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>).</source>
          <target state="translated">Utilise le mode à ligne simple, où le point (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) correspond à chaque caractère (y compris <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Single-line mode<ept id="p1">](#single-line-mode)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Mode à ligne simple<ept id="p1">](#single-line-mode)</ept>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>n<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>n<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Do not capture unnamed groups.</source>
          <target state="translated">Ne capture aucun groupe sans nom.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The only valid captures are explicitly named or numbered groups of the form <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</source>
          <target state="translated">Les seules captures valides sont les groupes explicitement nommés ou numérotés de la forme <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>nom<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>sous-expression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Explicit captures only<ept id="p1">](#explicit-captures-only)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Captures explicites uniquement<ept id="p1">](#explicit-captures-only)</ept>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Non disponible</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Compile the regular expression to an assembly.</source>
          <target state="translated">Compile l'expression régulière en un assembly.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Compiled regular expressions<ept id="p1">](#compiled-regular-expressions)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Expressions régulières compilées<ept id="p1">](#compiled-regular-expressions)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>x<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>x<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Exclude unescaped white space from the pattern, and enable comments after a number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>).</source>
          <target state="translated">Exclure du modèle l’espace blanc sans séquence d’échappement et autoriser les commentaires après un signe dièse (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>).</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Ignore white space<ept id="p1">](#ignore-white-space)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Ignorer l’espace blanc<ept id="p1">](#ignore-white-space)</ept>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Non disponible</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Change the search direction.</source>
          <target state="translated">Modifie le sens de la recherche.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Search moves from right to left instead of from left to right.</source>
          <target state="translated">La recherche s'effectue de droite à gauche au lieu de gauche à droite.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Right-to-left mode<ept id="p1">](#right-to-left-mode)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Mode de recherche de droite à gauche<ept id="p1">](#right-to-left-mode)</ept>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Non disponible</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Enable ECMAScript-compliant behavior for the expression.</source>
          <target state="translated">Active le comportement compatible ECMAScript pour l’expression.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>ECMAScript matching behavior<ept id="p1">](#ecmascript-matching-behavior)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Comportement de correspondance ECMAScript<ept id="p1">](#ecmascript-matching-behavior)</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Non disponible</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Ignore cultural differences in language.</source>
          <target state="translated">Ignorer les différences culturelles propres à la langue.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Comparison using the invariant culture<ept id="p1">](#comparison-using-the-invariant-culture)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Comparaison utilisant la culture dite indifférente<ept id="p1">](#comparison-using-the-invariant-culture)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Specifying the options</source>
          <target state="translated">Spécification des options</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You can specify options for regular expressions in one of three ways:</source>
          <target state="translated">Vous pouvez spécifier les options des expressions régulières de trois façons :</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter of a <bpt id="p2">[</bpt>System.Text.RegularExpressions.Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor such as <bpt id="p3">[</bpt>Regex.Regex(String, RegexOptions)<ept id="p3">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions))</ept> or static (Shared in Visual Basic) pattern-matching method, such as  <bpt id="p4">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</source>
          <target state="translated">Dans le paramètre <bpt id="p1">*</bpt>options<ept id="p1">*</ept> d’un constructeur de classe <bpt id="p2">[</bpt>System.Text.RegularExpressions.Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> comme <bpt id="p3">[</bpt>Regex.Regex(String, RegexOptions)<ept id="p3">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions))</ept> ou d’une méthode de mise en correspondance de modèle statique (Shared en Visual Basic) comme <bpt id="p4">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter is a bitwise OR combination of <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> enumerated values.</source>
          <target state="translated">Le paramètre <bpt id="p1">*</bpt>options<ept id="p1">*</ept> est une combinaison OR au niveau du bit de valeurs énumérées <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>When options are supplied to a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> instance by using the <bpt id="p2">*</bpt>options<ept id="p2">*</ept> parameter of a class constructor, the options are are assigned to the <bpt id="p3">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property.</source>
          <target state="translated">Quand des options sont fournies à une instance de <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> à l’aide du paramètre <bpt id="p2">*</bpt>options<ept id="p2">*</ept> d’un constructeur de classe, les options sont affectées à la propriété <bpt id="p3">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>However, the <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property does not reflect inline options in the regular expression pattern itself.</source>
          <target state="translated">Cependant, la propriété <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> ne reflète pas les options inline dans le modèle d’expression régulière lui-même.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">L'exemple suivant illustre cette situation.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter of the <bpt id="p2">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">Il utilise le paramètre <bpt id="p1">*</bpt>options<ept id="p1">*</ept> de la méthode <bpt id="p2">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> pour autoriser la correspondance qui ne respecte pas la casse et pour ignorer l’espace blanc du modèle pendant l’identification des mots commençant par la lettre « d ».</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>By applying inline options in a regular expression pattern with the syntax <bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept>.</source>
          <target state="translated">En appliquant des options inline dans un modèle d’expression régulière avec la syntaxe <bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</source>
          <target state="translated">L’option s’applique au modèle depuis le point où elle est définie jusqu’à la fin du modèle ou jusqu’au point auquel sa définition est annulée par une autre option inline.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Note that the <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> instance does not reflect these inline options.</source>
          <target state="translated">Notez que la propriété <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> d’une instance de <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> ne reflète pas ces options inline.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Miscellaneous constructs in regular expressions<ept id="p1">](miscellaneous.md)</ept> topic.</source>
          <target state="translated">Pour plus d’informations, consultez la rubrique <bpt id="p1">[</bpt>Constructions diverses dans les expressions régulières<ept id="p1">](miscellaneous.md)</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">L'exemple suivant illustre cette situation.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">Il utilise des options inline pour autoriser la correspondance qui ne respecte pas la casse et pour ignorer l’espace blanc du modèle pendant l’identification des mots commençant par la lettre « d ».</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>By applying inline options in a particular grouping construct in a regular expression pattern with the syntax <bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">En appliquant des options inline dans une construction de regroupement particulière au sein d’un modèle d’expression régulière avec la syntaxe <bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</source>
          <target state="translated">L'absence de signe avant un jeu d'options active ce dernier, tandis qu'un signe moins le désactive.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>(<bpt id="p1">**</bpt>?<ept id="p1">**</ept></source>
          <target state="translated">(<bpt id="p1">**</bpt>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</source>
          <target state="translated">est une partie fixe de la syntaxe de la construction du langage qui est obligatoire, que les options soient activées ou désactivées.) L'option ne s'applique qu'à ce groupe.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Constructions de regroupement dans les expressions régulières<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">L'exemple suivant illustre cette situation.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">Il utilise des options inline dans une construction de regroupement pour autoriser la correspondance qui ne respecte pas la casse et pour ignorer l’espace blanc du modèle pendant l’identification des mots commençant par la lettre « d ».</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>If options are specified inline, a minus sign (-) before an option or set of options turns off those options.</source>
          <target state="translated">Si des options sont spécifiées inline, un signe moins (-) avant une option ou un jeu d’options désactive ces options.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For example, the inline construct <bpt id="p1">**</bpt>(?ix-ms)<ept id="p1">**</ept> turns on the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> and <bpt id="p3">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> options and turns off the <bpt id="p4">[</bpt>RegexOptions.Multiline<ept id="p4">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> and <bpt id="p5">[</bpt>RegexOptions.Singleline<ept id="p5">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> options.</source>
          <target state="translated">Par exemple, la construction inline <bpt id="p1">**</bpt>(?ix-ms)<ept id="p1">**</ept> active les options <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> et <bpt id="p3">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> et désactive les options <bpt id="p4">[</bpt>RegexOptions.Multiline<ept id="p4">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> et <bpt id="p5">[</bpt>RegexOptions.Singleline<ept id="p5">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>All regular expression options are turned off by default.</source>
          <target state="translated">Toutes les options d'expression régulière sont désactivées par défaut.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If the regular expression options specified in the options parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</source>
          <target state="translated">Si les options d’expression régulière spécifiées dans le paramètre options d’un appel de constructeur ou de méthode entrent en conflit avec les options spécifiées inline dans un modèle d’expression régulière, ces dernières sont utilisées.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The following five regular expression options can be set both with the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter and inline:</source>
          <target state="translated">Les cinq options d’expression régulière suivantes peuvent être définies avec le paramètre <bpt id="p1">*</bpt>options<ept id="p1">*</ept> et inline :</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The following five regular expression options can be set using the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter but cannot be set inline:</source>
          <target state="translated">Les cinq options d’expression régulière suivantes peuvent être définies avec le paramètre <bpt id="p1">*</bpt>options<ept id="p1">*</ept>, mais ne peuvent pas être définies inline :</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Determining the options</source>
          <target state="translated">Détermination des options</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can determine which options were provided to a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object when it was instantiated by retrieving the value of the read-only <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> property.</source>
          <target state="translated">Vous pouvez déterminer les options initialement fournies à un objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> au moment de son instanciation en récupérant la valeur de la propriété <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> en lecture seule.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To test for the presence of any option except <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, perform an AND operation with the value of the <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> property and the <bpt id="p3">[</bpt>RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> value in which you are interested.</source>
          <target state="translated">Pour tester la présence d’une option autre que <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, effectuez une opération AND avec la valeur de la propriété <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> et la valeur <bpt id="p3">[</bpt>RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> qui vous intéresse.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Then test whether the result equals that <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> value.</source>
          <target state="translated">Ensuite, déterminez si le résultat est égal à cette valeur <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The following example tests whether the <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option has been set.</source>
          <target state="translated">L’exemple suivant détermine si l’option <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> a été définie.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>To test for <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, determine whether the value of the <bpt id="p2">[</bpt>RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property is equal to <bpt id="p3">[</bpt>RegexOptions.None<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, as the following example illustrates.</source>
          <target state="translated">Pour tester la présence de <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, déterminez si la valeur de la propriété <bpt id="p2">[</bpt>RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> est égale à <bpt id="p3">[</bpt>RegexOptions.None<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, comme l’illustre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following sections list the options supported by regular expression in  .NET.</source>
          <target state="translated">Les sections suivantes répertorient les options prises en charge par les expressions régulières dans le .NET.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Default options</source>
          <target state="translated">Options par défaut</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</source>
          <target state="translated">L’option <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> indique qu’aucune option n’a été spécifiée et que le moteur d’expression régulière utilise son comportement par défaut.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This includes the following:</source>
          <target state="translated">Ce dernier est détaillé ci-après :</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</source>
          <target state="translated">Le modèle est interprété en tant qu'expression régulière canonique, plutôt qu'en tant qu'expression régulière ECMAScript.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is matched in the input string from left to right.</source>
          <target state="translated">Le modèle d'expression régulière est appliqué à la chaîne d'entrée de la gauche vers la droite.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Comparisons are case-sensitive.</source>
          <target state="translated">Les comparaisons respectent la casse.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> language elements match the beginning and end of the input string.</source>
          <target state="translated">Les éléments de langage <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> et <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> correspondent au début et à la fin de la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>.<ept id="p1">**</ept></source>
          <target state="translated">L’élément de langage <bpt id="p1">**</bpt>.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>language element matches every character except <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</source>
          <target state="translated">correspond à chaque caractère à l’exception de <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Any white space in a regular expression pattern is interpreted as a literal space character.</source>
          <target state="translated">Tout espace blanc dans un modèle d’expression régulière est interprété en tant qu’espace littéral.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The conventions of the current culture are used when comparing the pattern to the input string.</source>
          <target state="translated">Les conventions de la culture actuelle sont utilisées pendant la comparaison du modèle à la chaîne d'entrée.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Capturing groups in the regular expression pattern are implicit as well as explicit.</source>
          <target state="translated">Les groupes de capture dans le modèle d’expression régulière sont implicites aussi bien qu’explicites.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option has no inline equivalent.</source>
          <target state="translated">L’option <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> n’a pas d’équivalent inline.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</source>
          <target state="translated">Quand les options d'expression régulière sont appliquées inline, le comportement par défaut est restauré option par option, via la désactivation de chaque option concernée.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`(?i)`</ph> turns on case-insensitive comparison, and <ph id="ph2">`(?-i)`</ph> restores the default case-sensitive comparison.</source>
          <target state="translated">Par exemple, <ph id="ph1">`(?i)`</ph> active la comparaison sans respect de la casse, tandis que <ph id="ph2">`(?-i)`</ph> restaure la comparaison avec respect de la casse par défaut.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</source>
          <target state="translated">Comme l’option <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> représente le comportement par défaut du moteur d’expression régulière, elle est rarement spécifiée de manière explicite dans un appel de méthode.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>A constructor or static pattern-matching method without an options parameter is called instead.</source>
          <target state="translated">Un constructeur ou une méthode de mise en correspondance de modèle statique sans paramètre options est appelé à la place.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Case-insensitive matching</source>
          <target state="translated">Correspondance qui ne respecte pas la casse</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option, or the <bpt id="p2">**</bpt>i<ept id="p2">**</ept> inline option, provides case-insensitive matching.</source>
          <target state="translated">L’option <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>, ou l’option inline <bpt id="p2">**</bpt>i<ept id="p2">**</ept>, fournit une correspondance qui ne respecte pas la casse.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>By default, the casing conventions of the current culture are used.</source>
          <target state="translated">Par défaut, les conventions de gestion de la casse de la culture actuelle sont utilisées.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression pattern, <ph id="ph1">`\bthe\w*\b`</ph>, that matches all words starting with "the".</source>
          <target state="translated">L'exemple suivant définit un modèle d'expression régulière, <ph id="ph1">`\bthe\w*\b`</ph>, qui met en correspondance tous les mots commençant par « the ».</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Because the first call to the Match method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</source>
          <target state="translated">Comme le premier appel de la méthode Match utilise la comparaison avec respect de la casse par défaut, la chaîne « The » n’apparaît pas parmi les résultats de ce premier appel.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It is matched when the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with options set to <bpt id="p2">[</bpt>IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>.</source>
          <target state="translated">Par contre, elle est trouvée quand la méthode <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> est appelée avec le paramètre options défini sur <bpt id="p2">[</bpt>IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The following example modifies the regular expression pattern from the previous example to use inline options instead of the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter to provide case-insensitive comparison.</source>
          <target state="translated">L’exemple suivant modifie le modèle d’expression régulière proposé dans l’exemple précédent de manière à utiliser des options inline au lieu du paramètre <bpt id="p1">*</bpt>options<ept id="p1">*</ept> pour effectuer une comparaison sans respect de la casse.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</source>
          <target state="translated">Le premier modèle définit l’option de non-respect de la casse dans une construction de regroupement qui s’applique uniquement à la lettre « t » de la chaîne « the ».</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</source>
          <target state="translated">Comme la construction de l’option intervient au début du modèle, le second modèle applique l’option de non-respect de la casse à l’expression régulière entière.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Multiline mode</source>
          <target state="translated">Mode multiligne</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, or the <bpt id="p2">**</bpt>m<ept id="p2">**</ept> inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</source>
          <target state="translated">L’option <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>, ou l’option inline <bpt id="p2">**</bpt>m<ept id="p2">**</ept>, permet au moteur d’expression régulière de gérer une chaîne d’entrée constituée de plusieurs lignes.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It changes the interpretation of the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</source>
          <target state="translated">Elle modifie l’interprétation des éléments de langage <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> et <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> de manière à ce qu’ils correspondent au début et à la fin d’une ligne, et non au début et à la fin de la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>By default, <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> matches only the end of the input string.</source>
          <target state="translated">Par défaut, <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> correspond uniquement à la fin de la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>If you specify the <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, it matches either the newline character <bpt id="p2">**</bpt>(\n)<ept id="p2">**</ept> or the end of the input string.</source>
          <target state="translated">Si vous spécifiez l’option <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>, elle correspond au caractère de saut de ligne<bpt id="p2">**</bpt>(\n)<ept id="p2">**</ept> ou à la fin de la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>It does not, however, match the carriage return/line feed character combination.</source>
          <target state="translated">Toutefois, elle ne correspond pas à la combinaison de caractères retour chariot/saut de ligne.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>To successfully match them, use the subexpression <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> instead of just <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>.</source>
          <target state="translated">Pour les mettre en correspondance, utilisez la sous-expression <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> au lieu de simplement <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The following example extracts bowlers names and scores and adds them to a <bpt id="p1">[</bpt>SortedList<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.SortedList%602)</ept> collection that sorts them in descending order.</source>
          <target state="translated">L’exemple suivant extrait les prénoms et scores des lanceurs, puis les ajoute à une collection <bpt id="p1">[</bpt>SortedList<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.SortedList%602)</ept> qui les trie dans l’ordre décroissant.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> method is called twice.</source>
          <target state="translated">La méthode <bpt id="p1">[</bpt>Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> est appelée deux fois.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>In the first method call, the regular expression is <ph id="ph1">`^(\w+)\s(\d+)$`</ph> and no options are set.</source>
          <target state="translated">Dans le premier appel de la méthode, l'expression régulière est <ph id="ph1">`^(\w+)\s(\d+)$`</ph> et aucune option n'est définie.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</source>
          <target state="translated">Comme le montre la sortie, aucune correspondance n’est trouvée, car le moteur d’expression régulière ne peut pas mettre en correspondance le modèle d’entrée avec le début et la fin de la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>In the second method call, the regular expression is changed to <ph id="ph1">`^(\w+)\s(\d+)\r?$`</ph> and the options are set to <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</source>
          <target state="translated">Dans le second appel de la méthode, l’expression régulière devient <ph id="ph1">`^(\w+)\s(\d+)\r?$`</ph> et les options sont définies sur <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</source>
          <target state="translated">Comme le montre la sortie, les noms et scores sont correctement mis en correspondance, et les scores apparaissent dans l'ordre décroissant.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^(\w+)\s(\d+)\r*$`</ph> is defined as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`^(\w+)\s(\d+)\r*$`</ph> est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Begin at the start of the line.</source>
          <target state="translated">Commencer au début de la ligne.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Il s'agit du premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Mettre en correspondance un espace blanc.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">Il s'agit du deuxième groupe de capture.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Match zero or one carriage return character.</source>
          <target state="translated">Mettre en correspondance zéro ou un caractère de retour chariot.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>End at the end of the line.</source>
          <target state="translated">Terminer à la fin de la ligne.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous one, except that it uses the inline option <bpt id="p1">**</bpt>(?m)<ept id="p1">**</ept> to set the multiline option.</source>
          <target state="translated">L’exemple suivant est équivalent à l’exemple précédent, à la différence qu’il utilise l’option inline <bpt id="p1">**</bpt>(?m)<ept id="p1">**</ept> pour définir l’option multiligne.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Single-line mode</source>
          <target state="translated">Mode à ligne simple</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option, or the s inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</source>
          <target state="translated">L’option <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept>, ou l’option inline s, indique au moteur d’expression régulière de traiter la chaîne d’entrée comme si elle était composée d’une seule ligne.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>It does this by changing the behavior of the period (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) language element so that it matches every character, instead of matching every character except for the newline character <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> or \u000A.</source>
          <target state="translated">Pour ce faire, elle modifie le comportement de l’élément de langage point (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) de manière à mettre en correspondance chaque caractère, y compris le caractère de saut de ligne <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> ou \u000A.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The following example illustrates how the behavior of the .</source>
          <target state="translated">L’exemple suivant montre comment l’utilisation de l’option</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>language element changes when you use the <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> modifie le comportement de l’élément de langage ..</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^.+`</ph> starts at the beginning of the string and matches every character.</source>
          <target state="translated">L'expression régulière <ph id="ph1">`^.+`</ph> commence au début de la chaîne et correspond à tous les caractères.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, <bpt id="p1">**</bpt>\r<ept id="p1">**</ept> or \u000D, but it does not match <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</source>
          <target state="translated">Par défaut, la correspondance se termine à la fin de la première ligne ; le modèle d’expressions régulières correspond au retour chariot, <bpt id="p1">**</bpt>\r<ept id="p1">**</ept> ou \u000D, mais il ne correspond pas à <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option interprets the entire input string as a single line, it matches every character in the input string, including <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</source>
          <target state="translated">Étant donné que l’option <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> interprète la chaîne d’entrée entière comme une ligne unique, il correspond à chaque caractère de la chaîne d’entrée, notamment <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous one, except that it uses the inline option <bpt id="p1">**</bpt>(?s)<ept id="p1">**</ept> to enable single-line mode.</source>
          <target state="translated">L’exemple suivant est équivalent à l’exemple précédent, à la différence qu’il utilise l’option inline <bpt id="p1">**</bpt>(?s)<ept id="p1">**</ept> pour activer le mode à ligne simple.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Explicit captures only</source>
          <target state="translated">Captures explicites uniquement</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</source>
          <target state="translated">Par défaut, les groupes de capture sont définis à l’aide de parenthèses dans le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Named groups are assigned a name or number by the <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> language option, whereas unnamed groups are accessible by index.</source>
          <target state="translated">Les groupes nommés se voient affecter un nom ou un nombre par l’option de langage <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>nom<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>sous-expression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>, tandis que les groupes sans nom sont accessibles en fonction de leur index.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object, unnamed groups precede named groups.</source>
          <target state="translated">Dans l’objet <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept>, les groupes sans nom précèdent les groupes nommés.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</source>
          <target state="translated">Les constructions de regroupement sont souvent utilisées pour simplement appliquer des quantificateurs à plusieurs éléments de langage, et les sous-chaînes capturées ne présentent aucun intérêt.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>For example, if the following regular expression:</source>
          <target state="translated">Par exemple, si l'expression régulière suivante :</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> object) is of interest.</source>
          <target state="translated">est uniquement destinée à extraire d’un document les phrases qui se terminent par un point, un point d’exclamation ou un point d’interrogation, seule la phrase résultante (représentée par l’objet <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept>) présente un intérêt.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The individual words in the collection are not.</source>
          <target state="translated">Les différents mots de la collection n’en présentent pas.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collection objects.</source>
          <target state="translated">Les groupes de capture qui ne sont pas utilisés par la suite peuvent affecter les performances, car le moteur d’expression régulière doit remplir les deux objets de collection <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> et <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>As an alternative, you can use either the <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option or the <bpt id="p2">**</bpt>n<ept id="p2">**</ept> inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the <bpt id="p3">**</bpt>(?&lt;<ept id="p3">**</ept><bpt id="p4">_</bpt>name<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">&gt;</ph><ept id="p5">**</ept> <bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept> construct.</source>
          <target state="translated">En guise de solution, vous pouvez utiliser l’option <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> ou l’option inline <bpt id="p2">**</bpt>n<ept id="p2">**</ept> pour indiquer que les seules captures valides sont les groupes explicitement nommés ou numérotés désignés par la construction <bpt id="p3">**</bpt>(?&lt;<ept id="p3">**</ept><bpt id="p4">_</bpt>nom<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">&gt;</ph><ept id="p5">**</ept> <bpt id="p6">_</bpt>sous-expression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The following example displays information about the matches returned by the <ph id="ph1">`\b\(?((\w+),?\s?)+[\.!?]\)?`</ph> regular expression pattern when the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept> method is called with and without the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">L’exemple suivant affiche des informations sur les correspondances retournées par le modèle d’expression régulière <ph id="ph1">`\b\(?((\w+),?\s?)+[\.!?]\)?`</ph> quand la méthode <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept> est appelée avec et sans l’option <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>As the output from the first method call shows, the regular expression engine fully populates the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collection objects with information about captured substrings.</source>
          <target state="translated">Comme le montre la sortie du premier appel de la méthode, le moteur d’expression régulière remplit entièrement les objets de collection <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> et <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> avec des informations relatives aux sous-chaînes capturées.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Because the second method is called with options set to <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>, it does not capture information on groups.</source>
          <target state="translated">Comme la seconde méthode est appelée avec options défini sur <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>, elle ne capture pas d’information sur les groupes.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b\(?((?&gt;\w+),?\s?)+[\.!?]\)?`</ph> is defined as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\b\(?((?&gt;\w+),?\s?)+[\.!?]\)?`</ph> est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Begin at a word boundary.</source>
          <target state="translated">Commencer à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrences of the opening parenthesis ("(").</source>
          <target state="translated">Mettre en correspondance zéro occurrence, ou plus, de la parenthèse ouvrante (« ( »).</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Match one or more word characters, followed by zero or one commas.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques, suivis de zéro virgule, ou plus.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Do not backtrack when matching word characters.</source>
          <target state="translated">Ne pas effectuer de recherches rétroactives quand des caractères alphabétiques sont mis en correspondance.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space characters.</source>
          <target state="translated">Mettre en correspondance zéro ou des espaces blancs.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</source>
          <target state="translated">Mettre en correspondance la combinaison d'un ou plusieurs caractères alphabétiques, suivis de zéro ou d'une virgule, suivies de zéro ou d'un espace blanc, une ou plusieurs fois.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</source>
          <target state="translated">Mettre en correspondance n'importe lequel des trois symboles de ponctuation, suivi de zéro ou d'une parenthèse fermante (« ) »).</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>You can also use the <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> inline element to suppress automatic captures.</source>
          <target state="translated">Vous pouvez également utiliser l’élément inline <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> pour supprimer les captures automatiques.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous regular expression pattern to use the <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> inline element instead of the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">L’exemple suivant modifie le modèle d’expression régulière précédent pour utiliser l’élément inline <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> au lieu de l’option <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Finally, you can use the inline group element <bpt id="p1">**</bpt>(?n:)<ept id="p1">**</ept> to suppress automatic captures on a group-by-group basis.</source>
          <target state="translated">Enfin, vous pouvez utiliser l’élément de groupe inline <bpt id="p1">**</bpt>(?n:)<ept id="p1">**</ept> pour supprimer les captures automatiques groupe par groupe.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous pattern to suppress unnamed captures in the outer group, <ph id="ph1">`((?&gt;\w+),?\s?)`</ph>.</source>
          <target state="translated">L'exemple suivant modifie le modèle précédent pour supprimer les captures sans nom du groupe externe, <ph id="ph1">`((?&gt;\w+),?\s?)`</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Note that this suppresses unnamed captures in the inner group as well.</source>
          <target state="translated">Notez que cette opération supprime également les captures sans nom du groupe interne.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Compiled regular expressions</source>
          <target state="translated">Expressions régulières compilées</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>By default, regular expressions in .NET are interpreted.</source>
          <target state="translated">Par défaut, les expressions régulières dans .NET sont interprétées.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>When a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated or a static <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</source>
          <target state="translated">Quand un objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> est instancié ou qu’une méthode <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> statique est appelée, le modèle d’expression régulière est analysé de manière à générer un ensemble d’opcodes personnalisés, puis un interpréteur utilise ces opcodes pour exécuter l’expression régulière.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</source>
          <target state="translated">Cela implique un compromis : le coût d'initialisation du moteur d'expression régulière est réduit au prix d'une baisse des performances au moment de l'exécution.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You can use compiled instead of interpreted regular expressions by using the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option.</source>
          <target state="translated">Vous pouvez utiliser des expressions régulières compilées à la place d’expressions régulières interprétées en utilisant l’option <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</source>
          <target state="translated">Dans ce cas, quand un modèle est transmis au moteur d’expression régulière, il est analysé de manière à générer un ensemble d’opcodes convertis ensuite en un code MSIL (Microsoft Intermediate Language), qui peut être directement communiqué au Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Compiled regular expressions maximize run-time performance at the expense of initialization time.</source>
          <target state="translated">Les expressions régulières compilées optimisent les performances d'exécution au détriment du temps d'initialisation.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>A regular expression can be compiled only by supplying the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or a static pattern-matching method.</source>
          <target state="translated">Pour compiler une expression régulière, vous devez fournir la valeur <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> au paramètre options d’un constructeur de classe <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> ou d’une méthode de mise en correspondance de modèle statique.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">La compilation ne peut pas être effectuée via une option inline.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>You can use compiled regular expressions in calls to both static and instance regular expressions.</source>
          <target state="translated">Vous pouvez utiliser des expressions régulières compilées dans les appels d'expressions régulières statiques et d'instance.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>In static regular expressions, the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option is passed to the options parameter of the regular expression pattern-matching method.</source>
          <target state="translated">Dans les expressions régulières statiques, l’option <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> est transmise au paramètre options de la méthode de mise en correspondance de modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>In instance regular expressions, it is passed to the options parameter of the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor.</source>
          <target state="translated">Dans les expressions régulières d’instance, elle est transmise au paramètre options du constructeur de classe <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>In both cases, it results in enhanced performance.</source>
          <target state="translated">Dans les deux cas, les performances s'en trouvent améliorées.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>However, this improvement in performance occurs only under the following conditions:</source>
          <target state="translated">Toutefois, cette amélioration ne se produit que dans les conditions suivantes :</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</source>
          <target state="translated">Un objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> qui représente une expression régulière particulière est utilisé dans plusieurs appels de méthodes de mise en correspondance de modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is not allowed to go out of scope, so it can be reused.</source>
          <target state="translated">La portée de l’objet <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> est strictement délimitée, ce qui permet sa réutilisation.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>A static regular expression is used in multiple calls to regular expression pattern-matching methods.</source>
          <target state="translated">Une expression régulière statique est utilisée dans plusieurs appels de méthodes de mise en correspondance de modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</source>
          <target state="translated">(L'amélioration des performances est possible, car les expressions régulières utilisées dans les appels de méthode statique sont mises en cache par le moteur d'expression régulière.)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Ignore white space</source>
          <target state="translated">Ignorer l’espace blanc</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</source>
          <target state="translated">Par défaut, l’espace blanc dans un modèle d’expression régulière est significatif ; il oblige le moteur d’expression régulière à mettre en correspondance un espace blanc dans la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Because of this, the regular expression <ph id="ph1">`"\b\w+\s"`</ph> and <ph id="ph2">`"\b\w+ "`</ph> are roughly equivalent regular expressions.</source>
          <target state="translated">Ainsi, les expressions régulières <ph id="ph1">`"\b\w+\s"`</ph> et <ph id="ph2">`"\b\w+ "`</ph> sont pratiquement équivalentes.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>In addition, when the number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</source>
          <target state="translated">En outre, quand le signe dièse (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) est rencontré dans un modèle d’expression régulière, il est interprété comme un caractère littéral à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option, or the <bpt id="p2">**</bpt>x<ept id="p2">**</ept> inline option, changes this default behavior as follows:</source>
          <target state="translated">L’option <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept>, ou l’option inline <bpt id="p2">**</bpt>x<ept id="p2">**</ept>, modifie ce comportement par défaut comme suit :</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Unescaped white space in the regular expression pattern is ignored.</source>
          <target state="translated">L’espace blanc sans séquence d’échappement dans le modèle d’expression régulière est ignoré.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>To be part of a regular expression pattern, white-space characters must be escaped (for example, as <bpt id="p1">**</bpt>\s<ept id="p1">**</ept> or "*<bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept> ").</source>
          <target state="translated">Pour faire partie d’un modèle d’expression régulière, les espaces blancs doivent être inclus dans une séquence d’échappement (par exemple, « <bpt id="p1">**</bpt>\s<ept id="p1">**</ept> » ou « *<bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept>  »).</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) is interpreted as the beginning of a comment, rather than as a literal character.</source>
          <target state="translated">Le signe dièse (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) est interprété comme le début d’un commentaire, plutôt que comme un caractère littéral.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>All text in the regular expression pattern from the <bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept> character to the end of the string is interpreted as a comment.</source>
          <target state="translated">Tout le texte d’un modèle d’expression régulière depuis le caractère <bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept> jusqu’à la fin de la chaîne est interprété comme un commentaire.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>However, in the following cases, white space characters in a regular expression aren't ignored, even if you use the <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option:</source>
          <target state="translated">Toutefois, dans les cas suivants, les espaces blancs d’une expression régulière ne sont pas ignorés, même si vous utilisez l’option <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> :</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>White space within a character class is always interpreted literally.</source>
          <target state="translated">L'espace blanc dans une classe de caractères est toujours interprété de façon littérale.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`[ .,;:]`</ph> matches any single white-space character, period, comma, semicolon, or colon.</source>
          <target state="translated">Par exemple, le modèle d'expression régulière <ph id="ph1">`[ .,;:]`</ph> met en correspondance n'importe quel espace blanc, point, virgule, point-virgule ou symbole deux-points unique.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>White space isn't allowed within a bracketed quantifier, such as <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,}<ept id="p6">**</ept>, and <bpt id="p7">**</bpt>{<ept id="p7">**</ept><bpt id="p8">_</bpt>n<ept id="p8">_</ept><bpt id="p9">**</bpt>,<ept id="p9">**</ept><bpt id="p10">_</bpt>m<ept id="p10">_</ept><bpt id="p11">**</bpt>}<ept id="p11">**</ept>.</source>
          <target state="translated">L’espace blanc n’est pas autorisé dans un quantificateur entre accolades, comme <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,}<ept id="p6">**</ept> et <bpt id="p7">**</bpt>{<ept id="p7">**</ept><bpt id="p8">_</bpt>n<ept id="p8">_</ept><bpt id="p9">**</bpt>,<ept id="p9">**</ept><bpt id="p10">_</bpt>m<ept id="p10">_</ept><bpt id="p11">**</bpt>}<ept id="p11">**</ept>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <bpt id="p1">**</bpt>\d{1. 3}<ept id="p1">**</ept> fails to match any sequences of digits from one to three digits because it contains a white-space character.</source>
          <target state="translated">Par exemple, le modèle d’expression régulière <bpt id="p1">**</bpt>\d{1. 3}<ept id="p1">**</ept> ne peut pas mettre en correspondance les séquences d’un à trois chiffres, car il contient un espace blanc.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>White space isn't allowed within a character sequence that introduces a language element.</source>
          <target state="translated">L'espace blanc n'est pas autorisé dans une séquence de caractères qui introduit un élément de langage.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Exemple :</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The language element <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> represents a noncapturing group, and the <bpt id="p4">**</bpt>(?:<ept id="p4">**</ept> portion of the element can't have embedded spaces.</source>
          <target state="translated">L’élément de langage <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> représente un groupe sans capture, et la partie <bpt id="p4">**</bpt>(?:<ept id="p4">**</ept> de l’élément ne peut pas comporter d’espaces.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The pattern <bpt id="p1">**</bpt>(? :<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> throws an <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept> at run time because the regular expression engine can't parse the pattern, and the pattern <bpt id="p5">**</bpt>(? :<ept id="p5">**</ept><bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept>  fails to match <bpt id="p8">*</bpt>subexpression<ept id="p8">*</ept>.</source>
          <target state="translated">Le modèle <bpt id="p1">**</bpt>(? :<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> lève une <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept> au moment de l’exécution, car le moteur d’expression régulière ne peut pas l’analyser, et le modèle <bpt id="p5">**</bpt>(? :<ept id="p5">**</ept><bpt id="p6">_</bpt>sous-expression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept> ne parvient pas à mettre en correspondance <bpt id="p8">*</bpt>sous-expression<ept id="p8">*</ept>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The language element <bpt id="p1">**</bpt>\p{<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, which represents a Unicode category or named block, can't include embedded spaces in the <bpt id="p4">**</bpt>\p{<ept id="p4">**</ept> portion of the element.</source>
          <target state="translated">L’élément de langage <bpt id="p1">**</bpt>\p{<ept id="p1">**</ept><bpt id="p2">_</bpt>nom<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, qui représente une catégorie Unicode ou un bloc nommé, ne peut pas comporter d’espaces dans sa partie <bpt id="p4">**</bpt>\p{<ept id="p4">**</ept>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>If you do include a white space, the element throws an <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept> at run time.</source>
          <target state="translated">Si vous incluez un espace blanc, l’élément lève une <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept> au moment de l’exécution.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</source>
          <target state="translated">L'activation de cette option permet de simplifier les expressions régulières qui sont souvent difficiles à analyser et à comprendre.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>It improves readability, and makes it possible to document a regular expression.</source>
          <target state="translated">Elle améliore la lisibilité et rend possible la documentation d'une expression régulière.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The following example defines the following regular expression pattern:</source>
          <target state="translated">L’exemple ci-après définit le modèle d’expression régulière suivant :</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\b \(? ( (?&gt;\w+) ,?\s? )+ [\.!?] \)? # Matches an entire sentence`</ph>.</source>
          <target state="translated"><ph id="ph1">`\b \(? ( (?&gt;\w+) ,?\s? )+ [\.!?] \)? # Matches an entire sentence`</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>This pattern is similar to the pattern defined in the <bpt id="p1">[</bpt>Explicit captures only<ept id="p1">](#explicit-captures-only)</ept> section, except that it uses the <bpt id="p2">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option to ignore pattern white space.</source>
          <target state="translated">Ce modèle est similaire au modèle défini dans la section <bpt id="p1">[</bpt>Captures explicites uniquement<ept id="p1">](#explicit-captures-only)</ept>, à la différence qu’il utilise l’option <bpt id="p2">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> pour ignorer l’espace blanc du modèle.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following example uses the inline option <bpt id="p1">**</bpt>(?x)<ept id="p1">**</ept> to ignore pattern white space.</source>
          <target state="translated">L’exemple suivant utilise l’option inline <bpt id="p1">**</bpt>(?x)<ept id="p1">**</ept> pour ignorer l’espace blanc du modèle.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Right-to-left mode</source>
          <target state="translated">Mode de recherche de droite à gauche</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine searches from left to right.</source>
          <target state="translated">Par défaut, le moteur d'expression régulière recherche de gauche à droite.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>You can reverse the search direction by using the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option.</source>
          <target state="translated">Vous pouvez inverser le sens de la recherche à l’aide de l’option <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The search automatically begins at the last character position of the string.</source>
          <target state="translated">La recherche commence automatiquement à la position du dernier caractère de la chaîne.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>For pattern-matching methods that include a starting position parameter, such as <bpt id="p1">[</bpt>Regex.Match(String, Int32)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept>, the starting position is the index of the rightmost character position at which the search is to begin.</source>
          <target state="translated">Pour les méthodes de mise en correspondance de modèle qui comprennent un paramètre de position de début, comme <bpt id="p1">[</bpt>Regex.Match(String, Int32)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept>, la position de début est l’index de la position du caractère le plus à droite à laquelle la recherche doit commencer.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Right-to-left pattern mode is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">Pour utiliser le mode de recherche de droite à gauche, vous devez fournir la valeur <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> au paramètre options d’un constructeur de classe <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> ou d’une méthode de mise en correspondance de modèle statique.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">La compilation ne peut pas être effectuée via une option inline.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</source>
          <target state="translated">L’option <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> modifie uniquement le sens de la recherche ; elle n’interprète pas le modèle d’expression régulière de droite à gauche.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\bb\w+\s`</ph> matches words that begin with the letter "b" and are followed by a white-space character.</source>
          <target state="translated">Par exemple, l'expression régulière <ph id="ph1">`\bb\w+\s`</ph> met en correspondance les mots qui commencent par la lettre « b » et qui sont suivis d'un espace blanc.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>In the following example, the input string consists of three words that include one or more "b" characters.</source>
          <target state="translated">Dans l'exemple suivant, la chaîne d'entrée se compose de trois mots qui comprennent un ou plusieurs caractères « b ».</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</source>
          <target state="translated">Le premier mot commence par « b », le deuxième se termine par « b », tandis que le troisième comprend deux caractères « b » en son milieu.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, only the first word matches the regular expression pattern.</source>
          <target state="translated">Comme le montre la sortie de l’exemple, seul le premier mot correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Also note that the lookahead assertion (the <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element) and the lookbehind assertion (the <bpt id="p4">**</bpt>(?&lt;<ept id="p4">**</ept><ph id="ph2">=</ph><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> language element) do not change direction.</source>
          <target state="translated">Notez également que l’assertion de préanalyse (l’élément de langage <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> et l’assertion de postanalyse (l’élément de langage <bpt id="p4">**</bpt>(?&lt;<ept id="p4">**</ept><ph id="ph2">=</ph><bpt id="p5">_</bpt>sous-expression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> ne changent pas le sens.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The lookahead assertions look to the right; the lookbehind assertions look to the left.</source>
          <target state="translated">Les assertions de préanalyse recherchent vers la droite, tandis que les assertions de postanalyse recherchent vers la gauche.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`(?&lt;=\d{1,2}\s)\w+,?\s\d{4}`</ph> uses the lookbehind assertion to test for a date that precedes a month name.</source>
          <target state="translated">Par exemple, l'expression régulière <ph id="ph1">`(?&lt;=\d{1,2}\s)\w+,?\s\d{4}`</ph> utilise l'assertion de postanalyse pour déterminer si une date précède le nom d'un mois.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The regular expression then matches the month and the year.</source>
          <target state="translated">Ensuite, l'expression régulière met en correspondance le mois et l'année.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>For information on lookahead and lookbehind assertsions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les assertions de préanalyse et de postanalyse, consultez <bpt id="p1">[</bpt>Constructions de regroupement dans les expressions régulières<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">Le modèle d’expression régulière est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The beginning of the match must be preceded by one or two decimal digits followed by a space.</source>
          <target state="translated">Le début de la correspondance doit être précédé d'un ou deux chiffres décimaux suivis d'un espace.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Match zero or one comma characters.</source>
          <target state="translated">Mettre en correspondance zéro ou une virgule.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Mettre en correspondance un espace blanc.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Match four decimal digits.</source>
          <target state="translated">Mettre en correspondance quatre chiffres décimaux.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>ECMAScript matching behavior</source>
          <target state="translated">Comportement de correspondance ECMAScript</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</source>
          <target state="translated">Par défaut, le moteur d’expression régulière utilise un comportement canonique pour appliquer un modèle d’expression régulière à un texte d’entrée.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> option.</source>
          <target state="translated">Toutefois, vous pouvez indiquer au moteur d’expression régulière d’utiliser un comportement de correspondance ECMAScript en spécifiant l’option <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>ECMAScript-compliant behavior is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">À cette fin, vous devez fournir la valeur <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> au paramètre options d’un constructeur de classe <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> ou d’une méthode de mise en correspondance de modèle statique.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">La compilation ne peut pas être effectuée via une option inline.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> option can be combined only with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> and <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> options.</source>
          <target state="translated">L’option <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> ne peut être combinée qu’aux options <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> et <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>The use of any other option in a regular expression results in an <bpt id="p1">[</bpt>ArgumentOutOfRangeException<ept id="p1">](xref:System.ArgumentOutOfRangeException)</ept>.</source>
          <target state="translated">L’utilisation d’une autre option dans une expression régulière aboutit à une <bpt id="p1">[</bpt>ArgumentOutOfRangeException<ept id="p1">](xref:System.ArgumentOutOfRangeException)</ept>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</source>
          <target state="translated">Le comportement des expressions régulières ECMAScript et canoniques diffère dans trois domaines : la syntaxe de la classe de caractères, les groupes de capture avec référence circulaire et l’interprétation des séquences d’échappement octales ou des références arrière.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Character class syntax.</source>
          <target state="translated">Syntaxe de la classe de caractères.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</source>
          <target state="translated">Comme les expressions régulières canoniques prennent en charge Unicode, contrairement à ECMAScript, les classes de caractères dans ECMAScript possèdent une syntaxe plus limitée, et certains éléments de langage des classes de caractères ont une signification différente.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>For example, ECMAScript does not support language elements such as the Unicode category or block elements <bpt id="p1">*</bpt>\p<ept id="p1">*</ept> and <bpt id="p2">**</bpt>\P<ept id="p2">**</ept>.</source>
          <target state="translated">Par exemple, ECMAScript ne prend pas en charge les éléments de langage tels que la catégorie Unicode ou les éléments de bloc <bpt id="p1">*</bpt>\p<ept id="p1">*</ept> et <bpt id="p2">**</bpt>\P<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Similarly, the <bpt id="p1">**</bpt>\w<ept id="p1">**</ept> element, which matches a word character, is equivalent to the <bpt id="p2">**</bpt>[a-zA-Z_0-9]<ept id="p2">**</ept> character class when using ECMAScript and <bpt id="p3">**</bpt>[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]<ept id="p3">**</ept> when using canonical behavior.</source>
          <target state="translated">De même, l’élément <bpt id="p1">**</bpt>\w<ept id="p1">**</ept>, qui correspond à un caractère alphabétique, est équivalent à la classe de caractères <bpt id="p2">**</bpt>[a-zA-Z_0-9]<ept id="p2">**</ept>, dans le cas de l’utilisation d’ECMAScript, et à <bpt id="p3">**</bpt>[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]<ept id="p3">**</ept>, dans le cas de l’utilisation du comportement canonique.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Character classes in regular expressions<ept id="p1">](classes.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Classes de caractères dans les expressions régulières<ept id="p1">](classes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between canonical and ECMAScript pattern matching.</source>
          <target state="translated">L’exemple suivant illustre la différence entre les mises en correspondance de modèle canonique et ECMAScript.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>It defines a regular expression, <ph id="ph1">`\b(\w+\s*)+`</ph>, that matches words followed by white-space characters.</source>
          <target state="translated">Il définit une expression régulière, <ph id="ph1">`\b(\w+\s*)+`</ph>, qui met en correspondance les mots suivis d'espaces blancs.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</source>
          <target state="translated">L'entrée se compose de deux chaînes ; l'une d'elles utilise le jeu de caractères latin, l'autre le jeu de caractères cyrillique.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>As the output shows, the call to the <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</source>
          <target state="translated">Comme le montre la sortie, l’appel de méthode <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> qui utilise la correspondance ECMAScript ne parvient pas à mettre en correspondance les mots cyrilliques, contrairement à l’appel de méthode qui utilise la correspondance canonique.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Self-referencing capturing groups.</source>
          <target state="translated">Groupes de capture avec référence circulaire.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>A regular expression capture class with a backreference to itself must be updated with each capture iteration.</source>
          <target state="translated">Une classe de capture d'expression régulière avec une référence arrière à elle-même doit être mise à jour à chaque itération de capture.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>As the following example shows, this feature enables the regular expression <ph id="ph1">`((a+)(\1) ?)+`</ph> to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</source>
          <target state="translated">Comme le montre l'exemple suivant, cette fonctionnalité permet à l'expression régulière <ph id="ph1">`((a+)(\1) ?)+`</ph> de mettre en correspondance la chaîne d'entrée «  aa aaaa aaaaaa  » dans le cas de l'utilisation de la correspondance ECMAScript, mais pas dans le cas de l'utilisation de la correspondance canonique.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>For more information about string comparisons that are case-sensitive and that use the invariant culture, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](best-practices.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les comparaisons de chaînes respectant la casse et utilisant la culture dite indifférente, consultez <bpt id="p1">[</bpt>Bonnes pratiques pour l’utilisation de chaînes<ept id="p1">](best-practices.md)</ept>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Instead of using the case-insensitive comparisons of the current culture, you can specify the <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> option to ignore cultural differences in language and to use the conventions of the invariant culture.</source>
          <target state="translated">Au lieu d’utiliser les comparaisons sans respect de la casse de la culture actuelle, vous pouvez spécifier l’option <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> pour ignorer les différences culturelles propres à la langue et pour utiliser les conventions de la culture dite indifférente.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Comparison using the invariant culture is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">Pour effectuer une comparaison en utilisant la culture dite indifférente, vous devez fournir la valeur <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> au paramètre options d’un constructeur de classe <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> ou d’une méthode de mise en correspondance de modèle statique.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">La compilation ne peut pas être effectuée via une option inline.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The following example is identical to the previous example, except that the static <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with options that include <bpt id="p2">[</bpt>RegexOptions.CultureInvariant<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept>.</source>
          <target state="translated">L’exemple suivant est identique à l’exemple précédent, à la différence que la méthode <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> statique est appelée avec des options qui incluent <bpt id="p2">[</bpt>RegexOptions.CultureInvariant<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</source>
          <target state="translated">Même si la culture actuelle est définie sur Turc (Turquie), le moteur d'expression régulière parvient à mettre en correspondance « FILE » et « file » et à bloquer l'accès à la ressource de fichier.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Langage des expressions régulières - Aide-mémoire<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>