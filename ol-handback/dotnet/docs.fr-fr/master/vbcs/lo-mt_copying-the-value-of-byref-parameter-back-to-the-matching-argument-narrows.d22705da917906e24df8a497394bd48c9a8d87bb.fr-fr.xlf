<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">84574006b2e2ccc669fdd83ebfb6eec06b00f041</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\language-reference\error-messages\copying-the-value-of-byref-parameter-back-to-the-matching-argument-narrows.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ff0866c44a9d55824685e5b354178e390469a9d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c692df7cb60942abb4f052b86df555a646810bfa</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Copying the value of &amp;#39;ByRef&amp;#39; parameter &amp;#39;<ph id="ph1">&amp;lt;</ph>parametername<ph id="ph2">&amp;gt;</ph>&amp;#39; back to the matching argument narrows from type &amp;#39;<ph id="ph3">&amp;lt;</ph>typename1<ph id="ph4">&amp;gt;</ph>&amp;#39; to type &amp;#39;<ph id="ph5">&amp;lt;</ph>typename2<ph id="ph6">&amp;gt;</ph>&amp;#39; | Microsoft Docs</source>
          <target state="translated">Copie de la valeur du paramètre 'ByRef' '<ph id="ph1">&amp;lt;</ph>parametername<ph id="ph2">&amp;gt;</ph>'dans l’argument correspondant passe du type'<ph id="ph3">&amp;lt;</ph>NomType1<ph id="ph4">&amp;gt;</ph>' en type'<ph id="ph5">&amp;lt;</ph>NomType2<ph id="ph6">&amp;gt;</ph>' | Documents Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Copying the value of &amp;#39;ByRef&amp;#39; parameter &amp;#39;<ph id="ph1">&amp;lt;</ph>parametername<ph id="ph2">&amp;gt;</ph>&amp;#39; back to the matching argument narrows from type &amp;#39;<ph id="ph3">&amp;lt;</ph>typename1<ph id="ph4">&amp;gt;</ph>&amp;#39; to type &amp;#39;<ph id="ph5">&amp;lt;</ph>typename2<ph id="ph6">&amp;gt;</ph>&amp;#39;</source>
          <target state="translated">Copie de la valeur du paramètre 'ByRef' '<ph id="ph1">&amp;lt;</ph>parametername<ph id="ph2">&amp;gt;</ph>'dans l’argument correspondant passe du type'<ph id="ph3">&amp;lt;</ph>NomType1<ph id="ph4">&amp;gt;</ph>' en type'<ph id="ph5">&amp;lt;</ph>NomType2<ph id="ph6">&amp;gt;</ph>»</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A procedure is called with an argument that widens to the corresponding parameter type, and the conversion from the parameter to the argument is narrowing.</source>
          <target state="translated">Une procédure est appelée avec un argument qui s’étend au type de paramètre correspondant, et la conversion du paramètre à l’argument est restrictive.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>When you define a class or structure, you can define one or more conversion operators to convert that class or structure type to other types.</source>
          <target state="translated">Quand vous définissez une classe ou une structure, vous pouvez définir un ou plusieurs opérateurs de conversion pour convertir le type de la classe ou de la structure en d’autres types.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can also define reverse conversion operators to convert those other types back to your class or structure type.</source>
          <target state="translated">Vous pouvez également définir des opérateurs de conversion inverse pour convertir ces autres types vers le type de votre classe ou de votre structure.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>When you use your class or structure type in a procedure call, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> can use these conversion operators to convert the type of an argument to the type of its corresponding parameter.</source>
          <target state="translated">Lorsque vous utilisez votre type de classe ou de structure dans un appel de procédure, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> peut utiliser ces opérateurs de conversion pour convertir le type d’un argument pour le type de son paramètre correspondant.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>If you pass the argument <bpt id="p1">[</bpt>ByRef<ept id="p1">](../../../visual-basic/language-reference/modifiers/byref.md)</ept>, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> sometimes copies the argument value into a local variable in the procedure instead of passing a reference.</source>
          <target state="translated">Si vous passez l’argument <bpt id="p1">[</bpt>ByRef<ept id="p1">](../../../visual-basic/language-reference/modifiers/byref.md)</ept>, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> copie parfois sa valeur dans une variable locale de la procédure au lieu de passer une référence.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In such a case, when the procedure returns, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> must then copy the local variable value back into the argument in the calling code.</source>
          <target state="translated">Dans ce cas, la procédure retourne <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> doit copier la valeur de variable locale dans l’argument dans le code appelant.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>If a <ph id="ph1">`ByRef`</ph> argument value is copied into the procedure and the argument and parameter are of the same type, no conversion is necessary.</source>
          <target state="translated">Si une valeur d’argument <ph id="ph1">`ByRef`</ph> est copiée dans la procédure, et si l’argument et le paramètre sont du même type, aucune conversion n’est nécessaire.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>But if the types are different, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> must convert in both directions.</source>
          <target state="translated">Mais si les types sont différents, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> doit convertir dans les deux sens.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If one of the types is your class or structure type, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> must convert it both to and from the other type.</source>
          <target state="translated">Si un des types est votre type de classe ou structure, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> doit le convertir vers et à partir de l’autre type.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>If one of these conversions is widening, the reverse conversion might be narrowing.</source>
          <target state="translated">Si une de ces conversions est étendue, la conversion inverse peut être restrictive.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Error ID:<ept id="p1">**</ept> BC32053</source>
          <target state="translated"><bpt id="p1">**</bpt>ID d’erreur :<ept id="p1">**</ept> BC32053</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>To correct this error</source>
          <target state="translated">Pour corriger cette erreur</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If possible, use a calling argument of the same type as the procedure parameter, so <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> does not need to do any conversion.</source>
          <target state="translated">Si possible, utilisez un argument d’appel du même type que le paramètre de procédure, par conséquent, <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> ne doit pas effectuer de conversion.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>If you need to call the procedure with an argument type different from the parameter type but do not need to return a value into the calling argument, define the parameter to be <bpt id="p1">[</bpt>ByVal<ept id="p1">](../../../visual-basic/language-reference/modifiers/byval.md)</ept> instead of <ph id="ph1">`ByRef`</ph>.</source>
          <target state="translated">Si vous avez besoin d’appeler la procédure avec un argument de type différent du type de paramètre, mais n’avez pas besoin de retourner une valeur dans l’argument d’appel, de définir le paramètre pour être <bpt id="p1">[</bpt>ByVal<ept id="p1">](../../../visual-basic/language-reference/modifiers/byval.md)</ept> au lieu de <ph id="ph1">`ByRef`</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>If you need to return a value into the calling argument, define the reverse conversion operator as <bpt id="p1">[</bpt>Widening<ept id="p1">](../../../visual-basic/language-reference/modifiers/widening.md)</ept>, if possible.</source>
          <target state="translated">Si vous devez retourner une valeur dans l’argument d’appel, définir l’opérateur de conversion inverse <bpt id="p1">[</bpt>Widening<ept id="p1">](../../../visual-basic/language-reference/modifiers/widening.md)</ept>, si possible.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Procedures<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Procédures<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Procedure Parameters and Arguments<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/procedure-parameters-and-arguments.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Arguments et paramètres de procédure<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/procedure-parameters-and-arguments.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Passing Arguments by Value and by Reference<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/passing-arguments-by-value-and-by-reference.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Passage des Arguments par valeur et par référence<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/passing-arguments-by-value-and-by-reference.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Operator Procedures<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/operator-procedures.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Procédures d’opérateur<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/operator-procedures.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Operator Statement<ept id="p1">](../../../visual-basic/language-reference/statements/operator-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Operator (instruction)<ept id="p1">](../../../visual-basic/language-reference/statements/operator-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Define an Operator<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/how-to-define-an-operator.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Comment : définir un opérateur<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/how-to-define-an-operator.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Define a Conversion Operator<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/how-to-define-a-conversion-operator.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Comment : définir un opérateur de Conversion<ept id="p1">](../../../visual-basic/programming-guide/language-features/procedures/how-to-define-a-conversion-operator.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Type Conversions in Visual Basic<ept id="p1">](../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Conversions de type dans Visual Basic<ept id="p1">](../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Widening and Narrowing Conversions<ept id="p1">](../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Conversions étendues et restrictives<ept id="p1">](../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>