<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">299a938cd4b10dbca308685e389fab76656ac20b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\how-to-stream-xml-fragments-with-access-to-header-information.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">811db565726f68cf18d9257f1a55f877fb4cb50e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">856269d6c8277e24a38cba81592f7ad18cd5a367</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>How to: Stream XML Fragments with Access to Header Information (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Procédure : diffuser des fragments XML en continu avec accès aux informations d’en-tête (Visual Basic) | Documents Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>How to: Stream XML Fragments with Access to Header Information (Visual Basic)</source>
          <target state="translated">Procédure : diffuser des fragments XML en continu avec accès aux informations d’en-tête (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Sometimes you have to read arbitrarily large XML files, and write your application so that the memory footprint of the application is predictable.</source>
          <target state="translated">Vous devez parfois lire des fichiers XML arbitrairement volumineux et écrire votre application de sorte que son encombrement mémoire soit prévisible.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>If you attempt to populate an XML tree with a large XML file, your memory usage will be proportional to the size of the file—that is, excessive.</source>
          <target state="translated">Si vous tentez de remplir une arborescence XML avec un grand fichier XML, l'utilisation de la mémoire sera proportionnelle à la taille du fichier (c'est-à-dire excessive).</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Therefore, you should use a streaming technique instead.</source>
          <target state="translated">Par conséquent, vous devez utiliser une technique de diffusion en continu à la place.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>One option is to write your application using &lt;xref:System.Xml.XmlReader&gt;.</source>
          <target state="translated">Une option consiste à écrire votre application à l’aide de &lt;xref:System.Xml.XmlReader&gt;.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>However, you might want to use <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> to query the XML tree.</source>
          <target state="translated">Toutefois, vous pouvez souhaiter utiliser <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> pour interroger l’arborescence XML.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If this is the case, you can write your own custom axis method.</source>
          <target state="translated">Si tel est le cas, vous pouvez écrire votre propre méthode d'axe personnalisée.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Write a LINQ to XML Axis Method (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/how-to-write-a-linq-to-xml-axis-method.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Comment : écrire un LINQ vers la méthode d’axe XML (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/how-to-write-a-linq-to-xml-axis-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To write your own axis method, you write a small method that uses the &lt;xref:System.Xml.XmlReader&gt; to read nodes until it reaches one of the nodes in which you are interested.</source>
          <target state="translated">Pour écrire votre propre méthode d’axe, vous écrivez une petite méthode qui utilise le &lt;xref:System.Xml.XmlReader&gt;pour lire les nœuds jusqu'à atteindre l’un des nœuds qui vous intéressent.&lt;/xref:System.Xml.XmlReader&gt;</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The method then calls &lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;, which reads from the &lt;xref:System.Xml.XmlReader&gt; and instantiates an XML fragment.</source>
          <target state="translated">La méthode appelle ensuite &lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;, qui lit à partir de la &lt;xref:System.Xml.XmlReader&gt;et instancie un fragment XML.&lt;/xref:System.Xml.XmlReader&gt; &lt;/xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can then write LINQ queries on your custom axis method.</source>
          <target state="translated">Vous pouvez ensuite écrire des requêtes LINQ sur votre méthode d'axe personnalisée.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Streaming techniques are best applied in situations where you need to process the source document only once, and you can process the elements in document order.</source>
          <target state="translated">Il est préférable d'appliquer des techniques de diffusion en continu dans les situations où vous devez traiter le document source une seule fois et où vous pouvez traiter les éléments dans l'ordre du document.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Certain standard query operators, such as &lt;xref:System.Linq.Enumerable.OrderBy%2A&gt;, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</source>
          <target state="translated">Norme de certain opérateurs de requête, tel que &lt;xref:System.Linq.Enumerable.OrderBy%2A&gt;, itérer au sein de leur source, recueillent toutes les données, trier et puis produisent le premier élément de la séquence.&lt;/xref:System.Linq.Enumerable.OrderBy%2A&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Note that if you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint.</source>
          <target state="translated">Notez que si vous utilisez un opérateur de requête qui matérialise sa source avant de produire le premier élément, vous ne conserverez pas un faible encombrement mémoire.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Exemple</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Sometimes the problem gets just a little more interesting.</source>
          <target state="translated">Le problème peut parfois être un peu plus épineux.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In the following XML document, the consumer of your custom axis method also has to know the name of the customer that each item belongs to.</source>
          <target state="translated">Dans le document XML suivant, le consommateur de votre méthode d'axe personnalisée doit également connaître le nom du client auquel appartient chaque élément.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The approach that this example takes is to also watch for this header information, save the header information, and then build a small XML tree that contains both the header information and the detail that you are enumerating.</source>
          <target state="translated">L'approche utilisée dans cet exemple consiste à rechercher ces informations d'en-tête, à les enregistrer, puis à générer une petite arborescence XML qui contient à la fois les informations d'en-tête et le détail que vous énumérez.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The axis method then yields this new, small XML tree.</source>
          <target state="translated">La méthode d'axe produit ensuite cette nouvelle petite arborescence XML.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The query then has access to the header information as well as the detail information.</source>
          <target state="translated">La requête a alors accès aux informations d'en-tête et aux informations de détail.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This approach has a small memory footprint.</source>
          <target state="translated">Cette approche présente un faible encombrement mémoire.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>As each detail XML fragment is yielded, no references are kept to the previous fragment, and it is available for garbage collection.</source>
          <target state="translated">À mesure que chaque fragment XML de détail est produit, aucune référence au fragment précédent n'est conservée et il est disponible pour le garbage collection.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Note that this technique creates many short lived objects on the heap.</source>
          <target state="translated">Notez que cette technique crée de nombreux objets à courte durée de vie sur la pile.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following example shows how to implement and use a custom axis method that streams XML fragments from the file specified by the URI.</source>
          <target state="translated">L'exemple suivant montre comment implémenter et utiliser une méthode d'axe personnalisée qui diffuse en continu des fragments XML à partir du fichier spécifié par l'URI.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This custom axis is specifically written such that it expects a document that has <ph id="ph1">`Customer`</ph>, <ph id="ph2">`Name`</ph>, and <ph id="ph3">`Item`</ph> elements, and that those elements will be arranged as in the above <ph id="ph4">`Source.xml`</ph> document.</source>
          <target state="translated">Cet axe personnalisé est écrit spécifiquement de sorte qu'il s'attende à recevoir un document possédant des éléments <ph id="ph1">`Customer`</ph>, <ph id="ph2">`Name`</ph> et <ph id="ph3">`Item`</ph>, et que ces éléments seront disposés comme dans le document <ph id="ph4">`Source.xml`</ph> ci-dessus.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>It is a simplistic implementation.</source>
          <target state="translated">Il s'agit d'une implémentation simpliste.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>A more robust implementation would be prepared to parse an invalid document.</source>
          <target state="translated">Une implémentation plus robuste serait préparée à analyser un document non valide.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This code produces the following output:</source>
          <target state="translated">Ce code génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Advanced LINQ to XML Programming (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>LINQ to XML (Visual Basic) de la programmation avancée<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>