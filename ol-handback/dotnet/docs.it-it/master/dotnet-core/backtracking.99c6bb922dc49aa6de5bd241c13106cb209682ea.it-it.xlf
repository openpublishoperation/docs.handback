<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">58925ce755e995432f3ff205793a192f34999e12</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\backtracking.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">eb5a2765378d54e249072401d2bb7a91a5fde343</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">44f9547568980ddd9867439669c8bc02c62fd81a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Backtracking in regular expressions</source>
          <target state="translated">Backtracking nelle espressioni regolari</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Backtracking in regular expressions</source>
          <target state="translated">Backtracking nelle espressioni regolari</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Backtracking in regular expressions</source>
          <target state="translated">Backtracking nelle espressioni regolari</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Backtracking occurs when a regular expression pattern contains optional <bpt id="p1">[</bpt>quantifiers<ept id="p1">](quantifiers.md)</ept> or <bpt id="p2">[</bpt>alternation constructs<ept id="p2">](alternation.md)</ept>, and the regular expression engine returns to a previous saved state to continue its search for a match.</source>
          <target state="translated">Il backtracking si verifica quando un modello di espressione regolare contiene <bpt id="p1">[</bpt>quantificatori<ept id="p1">](quantifiers.md)</ept> o <bpt id="p2">[</bpt>costrutti di alternanza<ept id="p2">](alternation.md)</ept> facoltativi e il motore delle espressioni regolari torna a uno stato salvato in precedenza per continuare la ricerca di una corrispondenza.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</source>
          <target state="translated">Il backtracking è fondamentale per la potenza delle espressioni regolari. Consente alle espressioni di essere potenti e flessibili e di cercare una corrispondenza di modelli molto complessi.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>At the same time, this power comes at a cost.</source>
          <target state="translated">Questa tecnica presenta tuttavia anche alcuni svantaggi.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Backtracking is often the single most important factor that affects the performance of the regular expression engine.</source>
          <target state="translated">Il backtracking spesso è il fattore più importante che influisce sulle prestazioni del motore delle espressioni regolari.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</source>
          <target state="translated">Fortunatamente, lo sviluppatore è in grado di controllare il comportamento del motore delle espressioni regolari e il modo in cui viene utilizzato il backtracking.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This topic explains how backtracking works and how it can be controlled.</source>
          <target state="translated">In questo argomento viene illustrato il funzionamento del backtracking e il modo in cui può essere controllato.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In general, a Nondeterministic Finite Automaton (NFA) engine like the  regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</source>
          <target state="translated">In generale, un motore NFA (Nondeterministic Finite Automaton) come il motore delle espressioni regolari affida la responsabilità della creazione di espressioni regolari efficienti e veloci allo sviluppatore.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections:</source>
          <target state="translated">Di seguito sono elencate le diverse sezioni di questo argomento:</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Linear comparison without backtracking<ept id="p1">](#linear-comparison-without-backtracking)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Confronto lineare senza backtracking<ept id="p1">](#linear-comparison-without-backtracking)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking with optional quantifiers or alternation constructs<ept id="p1">](#backtracking-with-optional-quantifiers-or-alternation-constructs)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Backtracking con quantificatori facoltativi o costrutti di alternanza<ept id="p1">](#backtracking-with-optional-quantifiers-or-alternation-constructs)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking with nested optional quantifiers<ept id="p1">](#backtracking-with-nested-optional-quantifiers)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Backtracking con quantificatori facoltativi annidati<ept id="p1">](#backtracking-with-nested-optional-quantifiers)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Controlling backtracking<ept id="p1">](#controlling-backtracking)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Controllo del backtracking<ept id="p1">](#controlling-backtracking)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Linear comparison without backtracking</source>
          <target state="translated">Confronto lineare senza backtracking</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</source>
          <target state="translated">Se un modello di espressione regolare non contiene quantificatori facoltativi o costrutti di alternanza, il motore delle espressioni regolari viene eseguito in un tempo lineare,</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</source>
          <target state="translated">ovvero dopo che il motore delle espressioni regolari trova una corrispondenza tra il primo elemento del linguaggio del modello e il testo della stringa di input, prova a trovare una corrispondenza tra l'elemento del linguaggio successivo del modello e il carattere o il gruppo di caratteri successivi della stringa di input.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This continues until the match either succeeds or fails.</source>
          <target state="translated">Il processo continua finché la ricerca della corrispondenza non avrà esito positivo o negativo.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In either case, the regular expression engine advances by one character at a time in the input string.</source>
          <target state="translated">In entrambi i casi, il motore delle espressioni regolari avanza di un carattere alla volta nella stringa di input.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">Nell'esempio seguente viene illustrato questo concetto.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`e{2}\w\b`</ph> looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</source>
          <target state="translated">L'espressione regolare <ph id="ph1">`e{2}\w\b`</ph> cerca due occorrenze della lettera "e", seguite da qualsiasi carattere alfanumerico, seguito da un confine di parola.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Although this regular expression includes the quantifier <ph id="ph1">`{2}`</ph>, it is evaluated in a linear manner.</source>
          <target state="translated">Benché questa espressione regolare includa il quantificatore <ph id="ph1">`{2}`</ph>, viene valutata in modo lineare.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The regular expression engine does not backtrack because <ph id="ph1">`{2}`</ph> is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</source>
          <target state="translated">Il motore delle espressioni regolari non esegue il backtracking perché <ph id="ph1">`{2}`</ph> non è un quantificatore facoltativo, ma specifica un numero esatto e non un numero variabile di volte in cui trovare la corrispondenza della sottoespressione precedente.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</source>
          <target state="translated">Di conseguenza, il motore delle espressioni regolari tenta di trovare una corrispondenza tra il modello di espressione regolare e la stringa di input come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Operazione</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Position in pattern</source>
          <target state="translated">Posizione nel modello</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Position in string</source>
          <target state="translated">Posizione nella stringa</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Risultato</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">h</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>"needing a reed" (index 0)</source>
          <target state="translated">"needing a reed" (indice 0)</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Nessuna corrispondenza.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">h</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>"eeding a reed" (index 1)</source>
          <target state="translated">"eeding a reed" (indice 1)</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Possibile corrispondenza.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>e{2}</source>
          <target state="translated">e{2}</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>"eding a reed" (index 2)</source>
          <target state="translated">"eding a reed" (indice 2)</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Possibile corrispondenza.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>\w</source>
          <target state="translated">\w</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>"ding a reed" (index 3)</source>
          <target state="translated">"ding a reed" (indice 3)</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Possibile corrispondenza.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="translated">5</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>\b</source>
          <target state="translated">\b</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>"ing a reed" (index 4)</source>
          <target state="translated">"ing a reed" (indice 4)</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Possible match fails.</source>
          <target state="translated">Possibile corrispondenza non riuscita.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>6</source>
          <target state="translated">6</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">h</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>"eding a reed" (index 2)</source>
          <target state="translated">"eding a reed" (indice 2)</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Possibile corrispondenza.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>7</source>
          <target state="translated">7</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>e{2}</source>
          <target state="translated">e{2}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>"ding a reed" (index 3)</source>
          <target state="translated">"ding a reed" (indice 3)</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Possible match fails.</source>
          <target state="translated">Possibile corrispondenza non riuscita.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>8</source>
          <target state="translated">8</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">h</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>"ding a reed" (index 3)</source>
          <target state="translated">"ding a reed" (indice 3)</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Match fails.</source>
          <target state="translated">La corrispondenza ha esito negativo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>9</source>
          <target state="translated">9</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">h</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>"ing a reed" (index 4)</source>
          <target state="translated">"ing a reed" (indice 4)</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Nessuna corrispondenza.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>10</source>
          <target state="translated">10</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">h</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>"ng a reed" (index 5)</source>
          <target state="translated">"ng a reed" (indice 5)</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Nessuna corrispondenza.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>11</source>
          <target state="translated">11</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">h</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>"g a reed" (index 6)</source>
          <target state="translated">"g a reed" (indice 6)</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Nessuna corrispondenza.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>12</source>
          <target state="translated">12</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">h</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>" a reed" (index 7)</source>
          <target state="translated">" a reed" (indice 7)</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Nessuna corrispondenza.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>13</source>
          <target state="translated">13</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">h</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>"a reed" (index 8)</source>
          <target state="translated">"a reed" (indice 8)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Nessuna corrispondenza.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">h</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>" reed" (index 9)</source>
          <target state="translated">"reed" (indice 9)</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Nessuna corrispondenza.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">h</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>"reed" (index 10)</source>
          <target state="translated">"reed" (indice 10)</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>No match</source>
          <target state="translated">Nessuna corrispondenza.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">h</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>"eed" (index 11)</source>
          <target state="translated">"eed" (indice 11)</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Possibile corrispondenza.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>e{2}</source>
          <target state="translated">e{2}</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>"ed" (index 12)</source>
          <target state="translated">"ed" (indice 12)</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Possibile corrispondenza.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>\w</source>
          <target state="translated">\w</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>"d" (index 13)</source>
          <target state="translated">"d" (indice 13)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Possibile corrispondenza.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>\b</source>
          <target state="translated">\b</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>"" (index 14)</source>
          <target state="translated">"" (indice 14)</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Match.</source>
          <target state="translated">Corrispondenza.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</source>
          <target state="translated">Se un modello di espressione regolare non include quantificatori facoltativi o costrutti di alternanza, il numero massimo di confronti necessari per trovare una corrispondenza tra il modello di espressione regolare e la stringa di input equivale approssimativamente al numero di caratteri della stringa di input.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</source>
          <target state="translated">In questo caso, l'espressione regolare utilizza 19 confronti per identificare le possibili corrispondenze nella stringa di 13 caratteri.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</source>
          <target state="translated">In altre parole, il motore delle espressioni regolari viene eseguito in un tempo quasi lineare se non contiene quantificatori facoltativi o costrutti di alternanza.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Backtracking with optional quantifiers or alternation constructs</source>
          <target state="translated">Backtracking con quantificatori facoltativi o costrutti di alternanza</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</source>
          <target state="translated">Quando un'espressione regolare include quantificatori facoltativi o costrutti di alternanza, la valutazione della stringa di input non è più lineare.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</source>
          <target state="translated">La corrispondenza dei modelli con un motore NFA è determinata dagli elementi del linguaggio nell'espressione regolare e non dai caratteri con cui trovare una corrispondenza nella stringa di input.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</source>
          <target state="translated">Il motore delle espressioni regolari prova pertanto a trovare una piena corrispondenza con le sottoespressioni facoltative o alternative.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</source>
          <target state="translated">Quando avanza all'elemento del linguaggio successivo nella sottoespressione e la corrispondenza ha esito negativo, il motore delle espressioni regolari può abbandonare una parte della corrispondenza esatta e tornare a uno stato salvato in precedenza al fine di trovare una corrispondenza tra l'intera espressione regolare e la stringa di input.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This process of returning to a previous saved state to find a match is known as backtracking.</source>
          <target state="translated">Questo processo di tornare a uno stato salvato in precedenza per trovare una corrispondenza è noto come backtracking.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>For example, consider the regular expression pattern <ph id="ph1">`.*(es)`</ph>, which matches the characters "es" and all the characters that precede it.</source>
          <target state="translated">Si consideri, ad esempio, il modello di espressione regolare <ph id="ph1">`.*(es)`</ph> che cerca una corrispondenza con i caratteri "es" e tutti i caratteri che li precedono.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</source>
          <target state="translated">Come illustrato nell'esempio seguente, se la stringa di input è "Essential services are provided by regular expressions.", il modello cerca una corrispondenza con l'intera stringa fino ai caratteri "es" in "expressions" compresi.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>To do this, the regular expression engine uses backtracking as follows:</source>
          <target state="translated">A tale scopo, il motore delle espressioni regolari utilizza il backtracking come segue:</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It matches the <ph id="ph1">`.*`</ph> (which matches zero, one, or more occurrences of any character) with the whole input string.</source>
          <target state="translated">Trova la corrispondenza di <ph id="ph1">`.*`</ph>, ovvero di zero, uno o più occorrenze di qualsiasi carattere, con l'intera stringa di input.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It attempts to match "e" in the regular expression pattern.</source>
          <target state="translated">Tenta di trovare una corrispondenza di "e" nel modello di espressione regolare.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>However, the input string has no remaining characters available to match.</source>
          <target state="translated">Tuttavia, nella stringa di input non sono presenti altri caratteri di cui cercare una corrispondenza.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</source>
          <target state="translated">Esegue il backtracking fino all'ultima corrispondenza esatta, "Essential services are provided by regular expressions", e tenta di trovare una corrispondenza di "e" con il punto alla fine della frase.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The match fails.</source>
          <target state="translated">La corrispondenza ha esito negativo.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</source>
          <target state="translated">Continua a eseguire il backtracking fino a una corrispondenza esatta precedente, un carattere alla volta, finché la sottostringa temporaneamente corrispondente non è "Essential services are provided by regular expr".</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</source>
          <target state="translated">Confronta quindi la "e" nel modello con la seconda "e" in "expressions" e trova una corrispondenza.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</source>
          <target state="translated">Confronta la "s" nel modello con la "s" che segue il carattere "e" corrispondente (la prima "s" in "expressions").</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The match is successful.</source>
          <target state="translated">La corrispondenza ha esito positivo.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</source>
          <target state="translated">Quando si utilizza il backtracking, la ricerca di una corrispondenza tra il modello di espressione regolare e la stringa di input, con una lunghezza pari a 55 caratteri, richiede 67 operazioni di confronto.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Interestingly, if the regular expression pattern included a lazy quantifier, <ph id="ph1">`.*?(es),`</ph> matching the regular expression would require additional comparisons.</source>
          <target state="translated">È interessante notare che se nel modello di espressione regolare venisse incluso un quantificatore lazy <ph id="ph1">`.*?(es),`</ph>, la ricerca di una corrispondenza dell'espressione regolare richiederebbe altri confronti.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>In this case, instead of having to backtrack from the end of the string to the "r" in "expressions", the regular expression engine would have to backtrack all the way to the beginning of the string to match "Es" and would require 113 comparisons.</source>
          <target state="translated">In questo caso, anziché eseguire il backtracking dalla fine della stringa fino alla "r" in "expressions", il motore delle espressioni regolari dovrà eseguire il backtracking fino all'inizio della stringa per trovare una corrispondenza di "Es" richiedendo 113 confronti.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</source>
          <target state="translated">In genere, se un modello di espressione regolare include un singolo costrutto di alternanza o un singolo quantificatore facoltativo, il numero di operazioni di confronto necessarie per trovare una corrispondenza del modello è più del doppio rispetto al numero di caratteri della stringa di input.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Backtracking with nested optional quantifiers</source>
          <target state="translated">Backtracking con quantificatori facoltativi annidati</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</source>
          <target state="translated">Il numero di operazioni di confronto necessarie per trovare una corrispondenza di un modello di espressione regolare può aumentare in modo esponenziale se il modello include un numero elevato di costrutti di alternanza, se include costrutti di alternanza annidati o se include sopratutto quantificatori facoltativi annidati.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`^(a+)+$`</ph> is designed to match a complete string that contains one or more "a" characters.</source>
          <target state="translated">Il modello di espressione regolare <ph id="ph1">`^(a+)+$`</ph>, ad esempio, è progettato per cercare una corrispondenza con una stringa completa contenente uno o più caratteri "a".</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The example provides two input strings of identical length, but only the first string matches the pattern.</source>
          <target state="translated">Nell'esempio vengono fornite due stringhe di input di lunghezza identica, ma solo la prima stringa corrisponde al modello.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>System.Diagnostics.Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> class is used to determine how long the match operation takes.</source>
          <target state="translated">La classe <bpt id="p1">[</bpt>System.Diagnostics.Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> viene usata per determinare il tempo richiesto dall'operazione di corrispondenza.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</source>
          <target state="translated">Come illustrato nell'output dell'esempio, il motore delle espressioni regolari ha impiegato il doppio del tempo per rilevare che una stringa di input non corrisponde al modello rispetto al tempo impiegato per identificare una stringa corrispondente.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This is because an unsuccessful match always represents a worst-case scenario.</source>
          <target state="translated">Ciò è dovuto al fatto che una corrispondenza negativa rappresenta sempre lo scenario peggiore.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</source>
          <target state="translated">Il motore delle espressioni regolari deve utilizzare l'espressione regolare per seguire tutti i percorsi possibili nei dati prima di poter concludere che la corrispondenza è negativa e le parentesi annidate creano molti percorsi aggiuntivi nei dati.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The regular expression engine concludes that the second string did not match the pattern by doing the following:</source>
          <target state="translated">Il motore delle espressioni regolari conclude che la seconda stringa non corrisponde al modello effettuando le operazioni seguenti:</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern a+.</source>
          <target state="translated">Verifica di essere all'inizio della stringa, quindi cerca una corrispondenza tra i primi cinque caratteri della stringa con il modello a+.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>It then determines that there are no additional groups of "a" characters in the string.</source>
          <target state="translated">Determina quindi che non esistono altri gruppi di caratteri "a" nella stringa.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Finally, it tests for the end of the string.</source>
          <target state="translated">Infine, verifica la fine della stringa.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Because one additional character remains in the string, the match fails.</source>
          <target state="translated">Poiché nella stringa rimane un ulteriore carattere, la corrispondenza ha esito negativo.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>This failed match requires 9 comparisons.</source>
          <target state="translated">La corrispondenza non riuscita richiede 9 confronti.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</source>
          <target state="translated">Il motore delle espressioni regolari salva inoltre le informazioni di stato dalle relative corrispondenze di "a" (che chiameremo corrispondenza 1), "aa" (corrispondenza 2), "aaa" (corrispondenza 3) e "aaaa" (corrispondenza 4).</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>It returns to the previously saved match 4.</source>
          <target state="translated">Torna alla corrispondenza 4 salvata in precedenza.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>It determines that there is one additional "a" character to assign to an additional captured group.</source>
          <target state="translated">Determina che esiste un altro carattere "a" da assegnare a un gruppo acquisito aggiuntivo.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Finally, it tests for the end of the string.</source>
          <target state="translated">Infine, verifica la fine della stringa.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Because one additional character remains in the string, the match fails.</source>
          <target state="translated">Poiché nella stringa rimane un ulteriore carattere, la corrispondenza ha esito negativo.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This failed match requires 4 comparisons.</source>
          <target state="translated">La corrispondenza non riuscita richiede 4 confronti.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>So far, a total of 13 comparisons have been performed.</source>
          <target state="translated">Fino a questo momento sono stati eseguiti complessivamente 13 confronti.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>It returns to the previously saved match 3.</source>
          <target state="translated">Torna alla corrispondenza 3 salvata in precedenza.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>It determines that there are two additional "a" characters to assign to an additional captured group.</source>
          <target state="translated">Determina che esistono sono altri due caratteri "a" da assegnare a un gruppo acquisito aggiuntivo.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>However, the end-of-string test fails.</source>
          <target state="translated">Tuttavia, il test di fine della stringa ha esito negativo.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</source>
          <target state="translated">Torna quindi alla corrispondenza&amp;3; e tenta di trovare una corrispondenza degli altri due caratteri "a" nei due gruppi acquisiti aggiuntivi.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The end-of-string test still fails.</source>
          <target state="translated">Il test di fine della stringa ha ancora esito negativo.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>These failed matches require 12 comparisons.</source>
          <target state="translated">Le corrispondenza non riuscite richiedono 12 confronti.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>So far, a total of 25 comparisons have been performed.</source>
          <target state="translated">Fino a questo punto, sono stati eseguiti complessivamente 25 confronti.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</source>
          <target state="translated">Il confronto della stringa di input con l'espressione regolare continua in questo modo fino a quando il motore delle espressioni regolari non ha tentato tutte le combinazioni di corrispondenze possibili, concludendo infine che non vi è alcuna corrispondenza.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Because of the nested quantifiers, this comparison is an O(2n) or an exponential operation, where n is the number of characters in the input string.</source>
          <target state="translated">A causa dei quantificatori annidati, questo confronto è un'operazione O(2n) o un'operazione esponenziale, dove n è il numero di caratteri all'interno della stringa di input.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</source>
          <target state="translated">Ciò significa che nei casi peggiori una stringa di input di 30 caratteri richiede circa 1.073.741.824 confronti e una stringa di input di 40 caratteri richiede circa 1.099.511.627.776 confronti.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</source>
          <target state="translated">Se si utilizzano stringhe di queste lunghezze o di lunghezze ancora maggiore, i metodi delle espressioni regolari possono richiedere una quantità di tempo eccessiva per il completamento quando elaborano un input che non corrisponde al modello di espressione regolare.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Controlling backtracking</source>
          <target state="translated">Controllo del backtracking</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Backtracking lets you create powerful, flexible regular expressions.</source>
          <target state="translated">Il backtracking consente di creare espressioni regolari potenti e flessibili.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</source>
          <target state="translated">Tuttavia, come illustrato nella sezione precedente, insieme a questi vantaggi si ottiene una notevole riduzione delle prestazioni.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>To prevent excessive backtracking, you should define a time-out interval when you instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object or call a static regular expression matching method.</source>
          <target state="translated">Per evitare un uso eccessivo del backtracking, è consigliabile definire un intervallo di timeout quando si crea un'istanza di un oggetto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> o si chiama un metodo di espressione regolare statica corrispondente.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>This is discussed in the next section.</source>
          <target state="translated">Questo è discusso nella sezione seguente.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>In addition, .NET Core supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: <bpt id="p1">[</bpt>nonbacktracking subexpressions<ept id="p1">](#nonbacktracking-subexpression)</ept>, <bpt id="p2">[</bpt>lookbehind assertions<ept id="p2">](#lookbehind-assertions)</ept>, and <bpt id="p3">[</bpt>lookahead assertions<ept id="p3">](#lookahead-assertions)</ept>.</source>
          <target state="translated">.NET Core supporta anche tre elementi del linguaggio delle espressioni regolari che limitano o evitano del tutto l'uso del backtracking e che supportano espressioni regolari complesse senza o con una minima riduzione delle prestazioni: <bpt id="p1">[</bpt>sottoespressioni non di backtracking<ept id="p1">](#nonbacktracking-subexpression)</ept>, <bpt id="p2">[</bpt>asserzioni lookbehind<ept id="p2">](#lookbehind-assertions)</ept> e <bpt id="p3">[</bpt>asserzioni lookahead<ept id="p3">](#lookahead-assertions)</ept>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>For more information about each language element, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Per altre informazioni su ogni elemento del linguaggio, vedere <bpt id="p1">[</bpt>Costrutti di raggruppamento nelle espressioni regolari<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Defining a time-out interval</source>
          <target state="translated">Definizione di un intervallo di timeout</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>You can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> exception.</source>
          <target state="translated">È possibile impostare un valore di timeout che rappresenta l'intervallo più lungo entro il quale il motore delle espressioni regolari cercherà una singola corrispondenza prima di rinunciare e generare un'eccezione <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>You specify the time-out interval by supplying a <bpt id="p1">[</bpt>TimeSpan<ept id="p1">](xref:System.TimeSpan)</ept> value to the <ph id="ph1">`Regex(String, RegexOptions, TimeSpan)`</ph> constructor for instance regular expressions.</source>
          <target state="translated">Specificare l'intervallo di timeout specificando un valore <bpt id="p1">[</bpt>TimeSpan<ept id="p1">](xref:System.TimeSpan)</ept> al costruttore <ph id="ph1">`Regex(String, RegexOptions, TimeSpan)`</ph> per creare un'istanza di espressioni regolari.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>In addition, each static pattern matching method has an overload with a <bpt id="p1">[</bpt>TimeSpan<ept id="p1">](xref:System.TimeSpan)</ept> value to the [Regex.Regex(String, RegexOptions, TimeSpan)] parameter that allows you to specify a time-out value.</source>
          <target state="translated">Ogni metodo statico di ricerca della corrispondenza ha un overload con un valore <bpt id="p1">[</bpt>TimeSpan<ept id="p1">](xref:System.TimeSpan)</ept> per il parametro [Regex.Regex(String, RegexOptions, TimeSpan)], che consente di specificare un valore di timeout.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>By default, the time-out interval is set to <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept> and the regular expression engine does not time out.</source>
          <target state="translated">Per impostazione predefinita l'intervallo di timeout viene impostato su <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept>, mentre il motore delle espressioni regolari non ha timeout.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>We recommend th&gt;at you always set a time-out interval if your regular expression relies on backtracking.</source>
          <target state="translated">È consigliabile impostare sempre un intervallo di timeout se l'espressione regolare si basa sul backtracking.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept>n exception indicates that the regular expression engine was unable to find a match within in the specified time-out interval but does not indicate why the exception was thrown.</source>
          <target state="translated">Un'eccezione <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept>n indica che il motore delle espressioni regolari non ha trovato una corrispondenza nell'intervallo di timeout specificato, ma non specifica il motivo per cui l'eccezione è stata generata.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</source>
          <target state="translated">Il motivo può essere l'utilizzo eccessivo del backtracking, ma è anche possibile che l'intervallo di timeout sia stato impostato troppo basso dato il carico di sistema al momento in cui l'eccezione è stata generata.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</source>
          <target state="translated">Quando si gestisce l'eccezione, è possibile scegliere di ignorare ulteriori corrispondenze con la stringa di input o aumentare l'intervallo di timeout e ritentare l'operazione corrispondente.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>For example, the following code calls the <ph id="ph1">`Regex(String, RegexOptions, TimeSpan)`</ph> constructor to instantiate a Regex object with a time-out value of one second.</source>
          <target state="translated">Ad esempio, il codice seguente chiama il costruttore <ph id="ph1">`Regex(String, RegexOptions, TimeSpan)`</ph> per creare un'istanza di un oggetto Regex con un valore di timeout di un secondo.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(a+)+$`</ph>, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</source>
          <target state="translated">Il modello di espressione regolare <ph id="ph1">`(a+)+$`</ph>, che corrisponde a uno o più sequenze di uno o più caratteri "a" alla fine di una riga, è soggetto all'utilizzo eccessivo del backtracking.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If a <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</source>
          <target state="translated">Se viene generata l'eccezione <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept>, l'esempio aumenta il valore di timeout fino a un intervallo massimo di tre secondi.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>After that, it abandons the attempt to match the pattern.</source>
          <target state="translated">Successivamente, ignora il tentativo di corrispondere al modello.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpression</source>
          <target state="translated">Sottoespressione non di backtracking</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept> <bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element suppresses backtracking in a subexpression.</source>
          <target state="translated">L'elemento del linguaggio <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept> <bpt id="p2">_</bpt>sottoespressione <ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> evita l'uso del backtracking in una sottoespressione.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>It is useful for preventing the performance problems associated with failed matches.</source>
          <target state="translated">È utile per non incorrere nei problemi di prestazioni associati alle corrispondenze non riuscite.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</source>
          <target state="translated">Nell'esempio seguente vengono illustrati i miglioramenti nelle prestazioni con i quantificatori annidati quando non si utilizza il backtracking.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</source>
          <target state="translated">Viene calcolato il tempo impiegato dal motore delle espressioni regolari per determinare che una stringa di input non corrisponde a due espressioni regolari.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</source>
          <target state="translated">La prima espressione regolare utilizza il backtracking per tentare di trovare una corrispondenza con una stringa contenente una o più occorrenze di una o più cifre esadecimali seguite da due punti, seguiti da una o più cifre esadecimali, seguite da un doppio due punti.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The second regular expression is identical to the first, except that it disables backtracking.</source>
          <target state="translated">La seconda espressione regolare è identica alla prima, con la differenza che il backtracking è disabilitato.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the performance improvement from disabling backtracking is significant.</source>
          <target state="translated">Come illustrato nell'output dell'esempio, il miglioramento delle prestazioni derivante dalla disabilitazione del backtracking è significativo.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Lookbehind assertions</source>
          <target state="translated">Asserzioni lookbehind</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>.NET includes two language elements, <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> and <bpt id="p4">**</bpt>(?&lt;!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept>, that match the previous character or characters in the input string.</source>
          <target state="translated">.NET include due elementi del linguaggio, <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>e <bpt id="p4">**</bpt>(?&lt;!<ept id="p4">**</ept><bpt id="p5">_</bpt>sottoespressione<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept>, che trovano il carattere o i caratteri precedenti nella stringa di input.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, without advancing or backtracking.</source>
          <target state="translated">Entrambi gli elementi di linguaggio sono asserzioni di larghezza zero, ovvero determinano se il carattere o i caratteri che precedono immediatamente il carattere corrente possono essere trovati da una <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept>, senza avanzamento o backtracking.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a positive lookbehind assertion; that is, the character or characters before the current position must match <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> è un'asserzione lookbehind positiva, ovvero il carattere o i caratteri prima della posizione corrente devono corrispondere alla <bpt id="p4">*</bpt>sottoespressione<ept id="p4">*</ept>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a negative lookbehind assertion; that is, the character or characters before the current position must not match <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> è un'asserzione lookbehind negativa, ovvero il carattere o i caratteri prima della posizione corrente non devono corrispondere alla <bpt id="p4">*</bpt>sottoespressione<ept id="p4">*</ept>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Both positive and negative lookbehind assertions are most useful when <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is a subset of the previous <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>.</source>
          <target state="translated">Le asserzioni lookbehind positive e negative sono entrambe particolarmente utili quando la <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> è un sottoinsieme della <bpt id="p2">*</bpt>sottoespressione<ept id="p2">*</ept> precedente.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The following example uses two equivalent regular expression patterns that validate the user name in an e-mail address.</source>
          <target state="translated">Nell'esempio seguente vengono utilizzati due modelli di espressione regolare equivalenti per verificare il nome utente in un indirizzo di posta elettronica.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The first pattern is subject to poor performance because of excessive backtracking.</source>
          <target state="translated">Il primo modello è soggetto a una riduzione delle prestazioni a causa di un utilizzo eccessivo del backtracking.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</source>
          <target state="translated">Il secondo modello modifica la prima espressione regolare sostituendo un quantificatore annidato con un'asserzione lookbehind positiva.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The output from the example displays the execution time of the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method.</source>
          <target state="translated">Nell'output dell'esempio viene visualizzato il tempo di esecuzione del metodo <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The first regular expression pattern, <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*@, is defined as shown in the following table.`</ph></source>
          <target state="translated">Il primo modello di espressione regolare, <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*@, is defined as shown in the following table.`</ph></target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
          <target state="translated">Inizia la ricerca della corrispondenza all'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">Trova la corrispondenza di un carattere alfanumerico.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option.</source>
          <target state="translated">Poiché il metodo <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> viene chiamato con l'opzione <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>, il confronto non rileva la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Match zero, one, or more occurrences of a hyphen, period, or word character.</source>
          <target state="translated">Trova la corrispondenza di zero, una o più occorrenze di un trattino, un punto o un carattere alfanumerico.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">Trova la corrispondenza di un carattere alfanumerico.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</source>
          <target state="translated">Trova la corrispondenza di zero o più occorrenze della combinazione di zero o più trattini, punti o caratteri alfanumerici seguiti da un carattere alfanumerico.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Equivale al primo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Match an at sign ("@").</source>
          <target state="translated">Trova la corrispondenza di una chiocciola ("@").</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The second regular expression pattern, <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])@`</ph>, uses a positive lookbehind assertion.</source>
          <target state="translated">Il secondo criterio di espressione regolare, <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])@`</ph>, usa un'asserzione lookbehind positiva</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
          <target state="translated">e viene definito come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
          <target state="translated">Inizia la ricerca della corrispondenza all'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">Trova la corrispondenza di un carattere alfanumerico.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option.</source>
          <target state="translated">Poiché il metodo <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> viene chiamato con l'opzione <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>, il confronto non rileva la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of a hyphen, period, or word character.</source>
          <target state="translated">Trova la corrispondenza di zero o più occorrenze di un trattino, un punto o un carattere alfanumerico.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Look back at the last matched character and continue the match if it is alphanumeric.</source>
          <target state="translated">Esegue la ricerca dell'ultimo carattere corrispondente e continua la ricerca della corrispondenza se si tratta di un carattere alfanumerico.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</source>
          <target state="translated">Si noti che i caratteri alfanumerici sono un subset del set costituito da punti, trattini e tutti i caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Match an at sign ("@").</source>
          <target state="translated">Trova la corrispondenza di una chiocciola ("@").</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Lookahead assertions</source>
          <target state="translated">Asserzioni lookahead</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>.NET includes two language elements, <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> and <bpt id="p4">**</bpt>(?!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept>, that match the next character or characters in the input string.</source>
          <target state="translated">.NET include due elementi di linguaggio, <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> e <bpt id="p4">**</bpt>(?!<ept id="p4">**</ept><bpt id="p5">_</bpt>sottoespressione<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept>, che trovano il carattere o i caratteri successivi nella stringa di input.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, without advancing or backtracking.</source>
          <target state="translated">Entrambi gli elementi di linguaggio sono asserzioni di larghezza zero, ovvero determinano se il carattere o i caratteri che seguono immediatamente il carattere corrente possono essere trovati dalla <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept>, senza avanzamento o backtracking.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a positive lookahead assertion; that is, the character or characters after the current position must match <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> è un'asserzione lookahead positiva, ovvero il carattere o i caratteri dopo la posizione corrente devono corrispondere alla <bpt id="p4">*</bpt>sottoespressione<ept id="p4">*</ept>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a negative lookahead assertion; that is, the character or characters after the current position must not match <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> è un'asserzione lookahead negativa, ovvero il carattere o i caratteri dopo la posizione corrente non devono corrispondere alla <bpt id="p4">*</bpt>sottoespressione<ept id="p4">*</ept>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Both positive and negative lookahead assertions are most useful when <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is a subset of the next <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>.</source>
          <target state="translated">Le asserzioni lookahead positive e negative sono entrambe particolarmente utili quando la <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> è un sottoinsieme della <bpt id="p2">*</bpt>sottoespressione<ept id="p2">*</ept> successiva.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</source>
          <target state="translated">Nell'esempio seguente vengono utilizzati due modelli di espressione regolare equivalenti per verificare un nome di tipo completo.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The first pattern is subject to poor performance because of excessive backtracking.</source>
          <target state="translated">Il primo modello è soggetto a una riduzione delle prestazioni a causa di un utilizzo eccessivo del backtracking.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</source>
          <target state="translated">Il secondo modello modifica la prima espressione regolare sostituendo un quantificatore annidato con un'asserzione lookahead positiva.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The output from the example displays the execution time of the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method.</source>
          <target state="translated">Nell'output dell'esempio viene visualizzato il tempo di esecuzione del metodo <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The first regular expression pattern, <ph id="ph1">`^(([A-Z]\w*)+\.)*[A-Z]\w*$`</ph>, is defined as shown in the following table.</source>
          <target state="translated">Il primo criterio di espressione regolare, <ph id="ph1">`^(([A-Z]\w*)+\.)*[A-Z]\w*$`</ph>, è definito nel modo illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modello</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
          <target state="translated">Inizia la ricerca della corrispondenza all'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</source>
          <target state="translated">Trova la corrispondenza di un carattere alfabetico (A-Z) seguito da zero o più caratteri alfanumerici una o più volte seguiti da un punto.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option.</source>
          <target state="translated">Poiché il metodo <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> viene chiamato con l'opzione <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>, il confronto non rileva la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Match the previous pattern zero or more times.</source>
          <target state="translated">Trova la corrispondenza del modello precedente zero o più volte.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Match an alphabetical character followed by zero or more word characters.</source>
          <target state="translated">Trova la corrispondenza di un carattere alfabetico seguito da zero o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>End the match at the end of the input string.</source>
          <target state="translated">Termina la ricerca della corrispondenza alla fine della stringa di input.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The second regular expression pattern, <ph id="ph1">`^((?=[A-Z])\w+\.)*[A-Z]\w*$`</ph>, uses a positive lookahead assertion.</source>
          <target state="translated">Il secondo criterio di espressione regolare, <ph id="ph1">`^((?=[A-Z])\w+\.)*[A-Z]\w*$`</ph>, usa un'asserzione lookahead positiva</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
          <target state="translated">e viene definito come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
          <target state="translated">Inizia la ricerca della corrispondenza all'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Look ahead to the first character and continue the match if it is alphabetical (A-Z).</source>
          <target state="translated">Esegue la ricerca fino primo carattere e continua la ricerca della corrispondenza se si tratta di un carattere alfabetico (A-Z).</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option.</source>
          <target state="translated">Poiché il metodo <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> viene chiamato con l'opzione <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>, il confronto non rileva la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a period.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri alfanumerici seguiti da un punto.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters followed by a period zero or more times.</source>
          <target state="translated">Trova la corrispondenza del modello di uno o più caratteri alfanumerici seguiti da un punto zero o più volte.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The initial word character must be alphabetical.</source>
          <target state="translated">Il carattere alfanumerico iniziale deve essere alfabetico.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Match an alphabetical character followed by zero or more word characters.</source>
          <target state="translated">Trova la corrispondenza di un carattere alfabetico seguito da zero o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>End the match at the end of the input string.</source>
          <target state="translated">Termina la ricerca della corrispondenza alla fine della stringa di input.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Vedere anche</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET regular expressions<ept id="p1">](regular-expressions.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Espressioni regolari .NET<ept id="p1">](regular-expressions.md)</ept></target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Linguaggio di espressioni regolari - Riferimento rapido<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Quantifiers in regular expressions<ept id="p1">](quantifiers.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Quantificatori nelle espressioni regolari<ept id="p1">](quantifiers.md)</ept></target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Alternation constructs in regular expressions<ept id="p1">](alternation.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Costrutti di alternanza nelle espressioni regolari<ept id="p1">](alternation.md)</ept></target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Costrutti di raggruppamento nelle espressioni regolari<ept id="p1">](grouping.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>