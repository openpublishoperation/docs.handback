<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cf9c83de791fa4990a991689a26d4bbdd84cfe7d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\best-practices.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">764579f52179b62804b5a8102eb3bc570a212e93</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f5f2f83420d224fc7138a8161f172550635ffde7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Best practices for regular expressions</source>
          <target state="translated">Procedure consigliate per le espressioni regolari</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Best practices for regular expressions</source>
          <target state="translated">Procedure consigliate per le espressioni regolari</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Best practices for regular expressions</source>
          <target state="translated">Procedure consigliate per le espressioni regolari</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</source>
          <target state="translated">Il motore delle espressioni regolari in .NET è uno strumento potente e completo che consente di elaborare il testo in base alle corrispondenze dei modelli anziché in base al confronto e alla corrispondenza con il testo letterale.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In most cases, it performs pattern matching rapidly and efficiently.</source>
          <target state="translated">Nella maggior parte dei casi, la corrispondenza dei modelli viene applicata in modo rapido ed efficiente.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>However, in some cases, the regular expression engine can appear to be very slow.</source>
          <target state="translated">In alcuni casi, tuttavia, il motore delle espressioni regolari può risultare molto lento.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</source>
          <target state="translated">In casi estremi, può anche sembrare che il motore non risponda durante l'elaborazione di un input relativamente piccolo per ore o perfino giorni.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</source>
          <target state="translated">In questo argomento vengono illustrate alcune procedure consigliate che possono essere adottate dagli sviluppatori per ottenere prestazioni ottimali con le espressioni regolari.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It contains the following sections:</source>
          <target state="translated">Include le sezioni seguenti:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Consider the input source<ept id="p1">](#consider-the-input-source)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Esaminare l'origine di input<ept id="p1">](#consider-the-input-source)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Handle object instantiation appropriately<ept id="p1">](#handle-object-instantiation-appropriately)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Gestire la creazione di istanze degli oggetti in modo appropriato<ept id="p1">](#handle-object-instantiation-appropriately)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Take charge of backtracking<ept id="p1">](#take-charge-of-backtracking)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Assumere il controllo del backtracking<ept id="p1">](#take-charge-of-backtracking)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Use time-out values<ept id="p1">](#use-time-out-values)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Usare valori di timeout<ept id="p1">](#use-time-out-values)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Capture only when necessary<ept id="p1">](#capture-only-when-necessary)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Eseguire l'acquisizione solo quando necessario<ept id="p1">](#capture-only-when-necessary)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Related topics<ept id="p1">](#related-topics)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Argomenti correlati<ept id="p1">](#related-topics)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Consider the input source</source>
          <target state="translated">Esaminare l'origine di input</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In general, regular expressions can accept two types of input: constrained or unconstrained.</source>
          <target state="translated">In generale, le espressioni regolari possono accettare due tipi di input: vincolato o non vincolato.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Constrained input is text that originates from a known or reliable source and follows a predefined format.</source>
          <target state="translated">Per input vincolato si intende un testo che proviene da un'origine conosciuta o affidabile e segue un formato predefinito.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</source>
          <target state="translated">Per input non vincolato si intende un testo che proviene da un'origine non inaffidabile, ad esempio un utente Web, e non può seguire un formato predefinito o previsto.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Regular expression patterns are typically written to match valid input.</source>
          <target state="translated">I modelli di espressione regolare vengono scritti in genere in modo da corrispondere all'input valido,</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</source>
          <target state="translated">ovvero gli sviluppatori esaminano il testo per il quale desiderano trovare una corrispondenza e scrivono quindi un modello di espressione regolare a esso corrispondente.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</source>
          <target state="translated">Gli sviluppatori determinano infine se questo modello richiede una correzione o un'ulteriore elaborazione testandolo con più elementi di input validi.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</source>
          <target state="translated">Se il modello corrisponde a tutti gli input considerati validi, viene dichiarato pronto per la produzione e può essere incluso in un'applicazione rilasciata.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This makes a regular expression pattern suitable for matching constrained input.</source>
          <target state="translated">In tal modo, un modello di espressione regolare viene considerato appropriato per la corrispondenza con un input vincolato.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>However, it does not make it suitable for matching unconstrained input.</source>
          <target state="translated">Tuttavia, non verrà considerato appropriato per la corrispondenza con un input non vincolato.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</source>
          <target state="translated">Per corrispondere a un input non vincolato, un'espressione regolare deve potere gestire efficientemente tre tipi di testo:</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>• Text that matches the regular expression pattern.</source>
          <target state="translated">• Testo che corrisponde al modello di espressione regolare.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>• Text that does not match the regular expression pattern.</source>
          <target state="translated">• Testo che non corrisponde al modello di espressione regolare.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>• Text that nearly matches the regular expression pattern.</source>
          <target state="translated">• Testo che quasi corrisponde al modello di espressione regolare.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The last text type is especially problematic for a regular expression that has been written to handle constrained input.</source>
          <target state="translated">L'ultimo tipo di testo è particolarmente problematico per un'espressione regolare scritta per gestire l'input vincolato.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If that regular expression also relies on extensive <bpt id="p1">[</bpt>backtracking<ept id="p1">](backtracking.md)</ept>, the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</source>
          <target state="translated">Se tale espressione regolare si basa anche sul <bpt id="p1">[</bpt>backtracking<ept id="p1">](backtracking.md)</ept> esteso, il motore delle espressioni regolari può richiedere una quantità eccessiva di tempo, in alcuni casi molte ore o giorni, per l'elaborazione di un testo apparentemente irrilevante.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</source>
          <target state="translated">Nell'esempio seguente viene utilizzata un'espressione regolare soggetta a un backtracking eccessivo e che con tutta probabilità rifiuta indirizzi di posta elettronica validi.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You should not use it in an email validation routine.</source>
          <target state="translated">Non utilizzarla in una routine di convalida di posta elettronica.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you would like a regular expression that validates email addresses, see <bpt id="p1">[</bpt>How to: Verify that strings are in valid email format<ept id="p1">](verify-format.md)</ept>.</source>
          <target state="translated">Per un'espressione regolare che convalida gli indirizzi di posta elettronica, vedere <bpt id="p1">[</bpt>Procedura: Verificare che le stringhe siano in formato di posta elettronica valido<ept id="p1">](verify-format.md)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</source>
          <target state="translated">Si consideri, ad esempio, un'espressione regolare comunemente utilizzata ma estremamente problematica per la convalida dell'alias di un indirizzo di posta elettronica.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*$`</ph> is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</source>
          <target state="translated">L'espressione regolare <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*$`</ph> viene scritta per elaborare gli indirizzi di posta elettronica ritenuti validi, composti da un carattere alfanumerico seguito da zero o più caratteri che possono essere alfanumerici, punti o trattini.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The regular expression must end with an alphanumeric character.</source>
          <target state="translated">L'espressione regolare deve terminare con un carattere alfanumerico.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</source>
          <target state="translated">Tuttavia, come illustrato nell'esempio seguente, sebbene questa espressione regolare gestisca facilmente l'input valido, le prestazioni risulteranno molto inefficienti quando viene elaborato un input quasi valido.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</source>
          <target state="translated">Come illustrato nell'output dell'esempio, il motore delle espressioni regolari elabora l'alias di posta elettronica valido nello stesso intervallo di tempo indipendentemente dalla lunghezza.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</source>
          <target state="translated">D'altra parte, quando l'indirizzo di posta elettronica quasi valido ha più di cinque caratteri, il tempo di elaborazione raddoppia approssimativamente per ogni carattere aggiuntivo nella stringa.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</source>
          <target state="translated">Ciò significa che l'elaborazione di una stringa di 28 caratteri quasi valida richiederebbe più di un'ora e l'elaborazione di una stringa di 33 caratteri quasi valida richiederebbe quasi un giorno.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</source>
          <target state="translated">Poiché questa espressione regolare è stata sviluppata considerando unicamente la corrispondenza con il formato di input, l'input che non corrisponde al modello non viene preso in considerazione.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</source>
          <target state="translated">Di conseguenza, è possibile consentire a un input non vincolato che corrisponde quasi al modello di espressione regolare di ridurre significativamente le prestazioni.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>To solve this problem, you can do the following:</source>
          <target state="translated">Per risolvere tale problema, è possibile effettuare le operazioni seguenti:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</source>
          <target state="translated">Durante lo sviluppo di un modello, è consigliabile considerare il modo in cui il backtracking potrebbe influire sulle prestazioni del motore delle espressioni regolari, soprattutto se l'espressione regolare è progettata per elaborare un input non vincolato.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Take charge of backtracking<ept id="p1">](#take-charge-of-backtracking)</ept> section.</source>
          <target state="translated">Per altre informazioni, vedere la sezione <bpt id="p1">[</bpt>Assumere il controllo del backtracking<ept id="p1">](#take-charge-of-backtracking)</ept>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</source>
          <target state="translated">Testare in modo approfondito l'espressione regolare utilizzando un input non valido e quasi valido nonché un input valido.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>To generate input for a particular regular expression randomly, you can use <bpt id="p1">[</bpt>Rex<ept id="p1">](http://research.microsoft.com/en-us/projects/rex/)</ept>, which is a regular expression exploration tool from Microsoft Research.</source>
          <target state="translated">Per generare casualmente input per un'espressione regolare specifica, è possibile usare <bpt id="p1">[</bpt>Rex<ept id="p1">](http://research.microsoft.com/en-us/projects/rex/)</ept>, uno strumento di analisi delle espressioni regolari di Microsoft Research.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Handle object instantiation appropriately</source>
          <target state="translated">Gestire la creazione di istanze degli oggetti in modo appropriato</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>At the heart of .NET’s regular expression object model is the <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class, which represents the regular expression engine.</source>
          <target state="translated">Il modello a oggetti delle espressioni regolari di .NET è basato sulla classe <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>, che rappresenta il motore delle espressioni regolari.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Often, the single greatest factor that affects regular expression performance is the way in which the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> engine is used.</source>
          <target state="translated">Il fattore principale che spesso influisce sulle prestazioni delle espressioni regolari è il modo in cui viene usato il motore <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</source>
          <target state="translated">Per definire un'espressione regolare è necessario associare il motore delle espressioni regolari a un modello di espressione regolare.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>That coupling process, whether it involves instantiating a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</source>
          <target state="translated">Tale processo di associazione, indipendentemente dal fatto che comporti la creazione di un'istanza di un oggetto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> passando al relativo costruttore un modello di espressione regolare o la chiamata a un metodo statico passando il modello di espressione regolare con una stringa da analizzare, è necessariamente dispendioso.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</source>
          <target state="translated">È possibile associare il motore delle espressioni regolari a un modello di espressione regolare specifico e quindi usare il motore per trovare una corrispondenza con il testo in diversi modi:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can call a static pattern-matching method, such as <bpt id="p1">[</bpt>Regex.Match(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String))</ept>.</source>
          <target state="translated">È possibile chiamare un metodo di corrispondenza dei modelli statico, ad esempio <bpt id="p1">[</bpt>Regex.Match(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String))</ept>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This does not require instantiation of a regular expression object.</source>
          <target state="translated">Non è richiesta la creazione di un'istanza di un oggetto di espressione regolare.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You can instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object and call an instance pattern-matching method of an interpreted regular expression.</source>
          <target state="translated">È possibile creare un'istanza di un oggetto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> e chiamare un metodo di corrispondenza dei modelli dell'istanza di un'espressione regolare interpretata.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This is the default method for binding the regular expression engine to a regular expression pattern.</source>
          <target state="translated">È il metodo predefinito per associare il motore delle espressioni regolari a un modello di espressione regolare.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It results when a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated without an options argument that includes the <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> flag.</source>
          <target state="translated">Si verifica quando viene creata un'istanza di un oggetto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> senza un argomento options che include il flag <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object and call an instance pattern-matching method of a compiled regular expression.</source>
          <target state="translated">È possibile creare un'istanza di un oggetto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> e chiamare un metodo di corrispondenza dei modelli dell'istanza di un'espressione regolare compilata.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Regular expression objects represent compiled patterns when a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated with an options argument that includes the <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> flag.</source>
          <target state="translated">Gli oggetti di espressioni regolari rappresentano i modelli compilati quando l'istanza di un oggetto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> viene creata con un argomento options che include il flag <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</source>
          <target state="translated">Il formato della chiamata al metodo (statico, interpretato, compilato) influisce sulle prestazioni se la stessa espressione regolare viene utilizzata più volte nelle chiamate al metodo oppure se in un'applicazione vengono utilizzati spesso gli oggetti di espressione regolare.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Static regular expressions</source>
          <target state="translated">Espressioni regolari statiche</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</source>
          <target state="translated">I metodi con espressioni regolari statiche sono consigliati come alternativa alla creazione ripetuta di un'istanza di un oggetto di espressione regolare con la stessa espressione regolare.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in instance method calls is cached internally by the regular expression engine.</source>
          <target state="translated">A differenza dei modelli di espressione regolare usati dagli oggetti di espressione regolare, i codici operativi o il linguaggio MSIL (Microsoft Intermediate Language) compilato dei modelli usati nelle chiamate al metodo di istanza vengono memorizzati nella cache interna dal motore delle espressioni regolari.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>For example, you might call a method to validate user input.</source>
          <target state="translated">È possibile ad esempio chiamare un metodo per convalidare l'input dell'utente.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In this example, a method named <ph id="ph1">`IsValidCurrency`</ph> checks whether the user has entered a currency symbol followed by at least one decimal digit.</source>
          <target state="translated">In questo esempio, un metodo denominato <ph id="ph1">`IsValidCurrency`</ph> controlla se l'utente ha immesso un simbolo di valuta seguito da almeno una cifra decimale.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A very inefficient implementation of the <ph id="ph1">`IsValidCurrency`</ph> method is shown in the following example.</source>
          <target state="translated">Nell'esempio seguente viene illustrata un'implementazione molto inefficiente del metodo <ph id="ph1">`IsValidCurrency`</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Note that each method call reinstantiates a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object with the same pattern.</source>
          <target state="translated">Si noti che ogni chiamata al metodo crea una nuova istanza dell'oggetto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> con lo stesso modello.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</source>
          <target state="translated">Di conseguenza, il modello di espressione regolare deve essere ricompilato ogni volta che viene chiamato il metodo.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>You should replace this inefficient code with a call to the static <bpt id="p1">[</bpt>Regex.IsMatch(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String))</ept> method.</source>
          <target state="translated">È consigliabile sostituire questo codice inefficiente con una chiamata al metodo statico <bpt id="p1">[</bpt>Regex.IsMatch(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String))</ept>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This eliminates the need to instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</source>
          <target state="translated">In questo modo si evita di dover creare un'istanza di un oggetto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> ogni volta che si vuole chiamare un metodo di corrispondenza dei modelli e si consente al motore delle espressioni regolari di recuperare una versione compilata dell'espressione regolare dalla cache.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>By default, the last 15 most recently used static regular expression patterns are cached.</source>
          <target state="translated">Per impostazione predefinita, nella cache vengono memorizzati gli ultimi 15 modelli di espressione regolare statica usati più di recente.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <bpt id="p1">[</bpt>Regex.CacheSize<ept id="p1">](xref:System.Text.RegularExpressions.Regex.CacheSize)</ept> property.</source>
          <target state="translated">Per le applicazioni che richiedono un numero maggiore di espressioni regolari statiche memorizzate nella cache, la dimensione della cache può essere modificata impostando la proprietà <bpt id="p1">[</bpt>Regex.CacheSize<ept id="p1">](xref:System.Text.RegularExpressions.Regex.CacheSize)</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\p{Sc}+\s*\d+`</ph> that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</source>
          <target state="translated">L'espressione regolare <ph id="ph1">`\p{Sc}+\s*\d+`</ph> usata in questo esempio verifica che la stringa di input sia costituita da un simbolo di valuta e da almeno una cifra decimale.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The pattern is defined as shown in the following table.</source>
          <target state="translated">Il modello viene definito come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modello</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Match one or more characters in the Unicode Symbol, Currency category.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri nella categoria Unicode Symbol, Currency.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">Trovare la corrispondenza di zero o più spazi vuoti.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Trova la corrispondenza con una o più cifre decimali.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Interpreted vs. compiled regular expressions</source>
          <target state="translated">Espressioni regolari interpretate ed espressioni regolari compilate</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Regular expression patterns that are not bound to the regular expression engine through the specification of the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option are interpreted.</source>
          <target state="translated">I modelli di espressione regolare che non sono associati al motore delle espressioni mediante l'opzione <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> vengono interpretati.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</source>
          <target state="translated">Quando viene creata un'istanza di un oggetto di espressione regolare, il motore delle espressioni regolari converte l'espressione regolare in un set di codici operativi.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</source>
          <target state="translated">Quando viene chiamato un metodo di istanza, i codici operativi vengono convertiti in MSIL ed eseguiti dal compilatore JIT.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</source>
          <target state="translated">Analogamente, quando viene chiamato un metodo con espressioni regolari statiche e l'espressione regolare non è presente nella cache, il motore delle espressioni regolari converte l'espressione regolare in un set di codici operativi che memorizza nella cache.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>It then converts these operation codes to MSIL so that the JIT compiler can execute them.</source>
          <target state="translated">Converte quindi i codici operativi in MSIL in modo tale che possano essere eseguiti dal compilatore JIT.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Interpreted regular expressions reduce startup time at the cost of slower execution time.</source>
          <target state="translated">Le espressioni regolari interpretate consentono di ridurre il tempo di avvio ma implicano tempi di esecuzione più lenti.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</source>
          <target state="translated">Per questo motivo, risultano particolarmente adatte quando l'espressione regolare viene utilizzata in un numero limitato di chiamate al metodo o se il numero esatto di chiamate ai metodi delle espressioni regolari è sconosciuto ma si prevede che sia esiguo.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</source>
          <target state="translated">Man mano che aumenta il numero di chiamate al metodo, il miglioramento delle prestazioni rispetto alla riduzione del tempo di avvio viene superato dalla minore velocità di esecuzione.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Regular expression patterns that are bound to the regular expression engine through the specification of the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option are compiled.</source>
          <target state="translated">I modelli di espressione regolare che sono associati al motore delle espressioni mediante l'opzione <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> vengono compilati.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</source>
          <target state="translated">Ciò significa che quando viene creata un'istanza di un oggetto di espressione regolare o quando viene chiamato un metodo con espressioni regolari statiche e l'espressione regolare non è presente nella cache, il motore delle espressioni regolari converte l'espressione regolare in un set intermedio di codici operativi, il quale viene quindi convertito in MSIL.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>When a method is called, the JIT compiler executes the MSIL.</source>
          <target state="translated">Il codice MSIL viene eseguito dal compilatore JIT non appena viene chiamato un metodo.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</source>
          <target state="translated">A differenza delle espressioni regolari interpretate, le espressioni regolari compilate aumentano il tempo di avvio eseguendo i singoli metodi di corrispondenza dei modelli più velocemente.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</source>
          <target state="translated">Di conseguenza, il vantaggio in termini di prestazioni che risulta dalla compilazione dell'espressione regolare aumenta proporzionalmente al numero di metodi dell'espressione regolare chiamati.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</source>
          <target state="translated">Riepilogando, è consigliabile utilizzare le espressioni regolari interpretate quando i metodi dell'espressione regolare vengono chiamati raramente con un'espressione regolare specifica</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</source>
          <target state="translated">e le espressioni regolari compilate quando i metodi dell'espressione regolare vengono chiamati frequentemente con un'espressione regolare specifica.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</source>
          <target state="translated">È difficile determinare la soglia esatta oltre la quale la minore velocità di esecuzione delle espressioni regolari interpretate supera i vantaggi offerti dalla riduzione del tempo di avvio o la soglia oltre la quale la riduzione del tempo di avvio delle espressioni regolari compilate supera i vantaggi offerti dalla maggiore velocità di esecuzione.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</source>
          <target state="translated">Dipende da vari fattori, tra cui la complessità dell'espressione regolare e i dati specifici che vengono elaborati.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <bpt id="p1">[</bpt>Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> class to compare their execution times.</source>
          <target state="translated">Per determinare se le espressioni regolari interpretate o compilate offrono le migliori prestazioni per lo scenario specifico dell'applicazione, è possibile usare la classe <bpt id="p1">[</bpt>Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> per confrontare i rispettivi tempi di esecuzione.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's The Financier.</source>
          <target state="translated">Nell'esempio seguente vengono confrontate le prestazioni delle espressioni regolari compilate e interpretate durante la lettura delle prime dieci frasi e durante la lettura di tutte le frasi del testo di The Financier di Theodore Dreiser.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</source>
          <target state="translated">Come illustrato nell'output dell'esempio, quando vengono effettuate solo dieci chiamate ai metodi di corrispondenza delle espressioni regolari, un'espressione regolare interpretata offre prestazioni migliori rispetto a un'espressione regolare compilata.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</source>
          <target state="translated">Tuttavia, un'espressione regolare compilata offre prestazioni migliori quando viene effettuato un numero di chiamate maggiore, in questo caso oltre 13.000.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The regular expression pattern used in the example, <ph id="ph1">`\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`</ph>, is defined as shown in the following table.</source>
          <target state="translated">Il criterio di espressione regolare usato nell'esempio, <ph id="ph1">`\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`</ph>, è definito nel modo illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modello</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Inizia la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>`(\r?\n)</source>
          <target state="translated">`(\r?\n)</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>,?\s)`</source>
          <target state="translated">,?\s)`</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</source>
          <target state="translated">Trova la corrispondenza di uno o nessun ritorno a capo seguito da un carattere di nuova riga o di una o nessuna virgola seguita da uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>`(\w+((\r?\n)</source>
          <target state="translated">`(\w+((\r?\n)</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>,?\s))*`</source>
          <target state="translated">,?\s))*`</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</source>
          <target state="translated">Trova la corrispondenza di zero o più occorrenze di uno o più caratteri alfanumerici seguiti da uno o nessun ritorno a capo e un carattere di nuova riga o da una o nessuna virgola seguita da uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Match a period, question mark, colon, semicolon, or exclamation point.</source>
          <target state="translated">Trova la corrispondenza di un punto, un punto interrogativo, due punti, un punto e virgola o un punto esclamativo.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Take charge of backtracking</source>
          <target state="translated">Assumere il controllo del backtracking</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</source>
          <target state="translated">In genere, il motore delle espressioni regolari usa la progressione lineare per spostarsi in una stringa di input e confrontarla con un modello di espressione regolare.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>However, when indeterminate quantifiers such as <bpt id="p1">__</bpt><ph id="ph1">*</ph><ept id="p1">__</ept>, <bpt id="p2">**</bpt><ph id="ph2">+</ph><ept id="p2">**</ept>, and <bpt id="p3">**</bpt>?<ept id="p3">**</ept></source>
          <target state="translated">Tuttavia, quando in un modello di espressione regolare vengono usati quantificatori indeterminati come <bpt id="p1">__</bpt><ph id="ph1">*</ph><ept id="p1">__</ept>, <bpt id="p2">**</bpt><ph id="ph2">+</ph><ept id="p2">**</ept> e <bpt id="p3">**</bpt>?<ept id="p3">**</ept>,</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</source>
          <target state="translated">il motore delle espressioni regolari può tralasciare una parte delle corrispondenze parziali corrette e tornare a uno stato salvato in precedenza per cercare una corrispondenza corretta per l'intero modello.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>This process is known as backtracking.</source>
          <target state="translated">Questo processo è noto come backtracking.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For more information on backtracking, see <bpt id="p1">[</bpt>Details of regular expression behavior<ept id="p1">](regex-behavior.md)</ept> and <bpt id="p2">[</bpt>Backtracking in regular expressions<ept id="p2">](backtracking.md)</ept>.</source>
          <target state="translated">Per altre informazioni sul backtracking, vedere <bpt id="p1">[</bpt>Dettagli sul comportamento delle espressioni regolari<ept id="p1">](regex-behavior.md)</ept> e <bpt id="p2">[</bpt>Backtracking nelle espressioni regolari<ept id="p2">](backtracking.md)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Support for backtracking gives regular expressions power and flexibility.</source>
          <target state="translated">Il supporto del backtracking fornisce alle espressioni regolari potenza e flessibilità.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</source>
          <target state="translated">Inoltre la responsabilità del controllo del funzionamento del motore delle espressioni regolari viene affidata agli sviluppatori delle espressioni regolari.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</source>
          <target state="translated">Poiché spesso gli sviluppatori non sono consapevoli di questa responsabilità, un utilizzo improprio del backtracking o un utilizzo eccessivo del backtracking rappresenta spesso la causa principale della riduzione delle prestazioni delle espressioni regolari.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>In a worst-case scenario, execution time can double for each additional character in the input string.</source>
          <target state="translated">Nello scenario peggiore, il tempo di esecuzione può raddoppiarsi per ogni carattere aggiuntivo nella stringa di input.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</source>
          <target state="translated">Utilizzando infatti il backtracking in modo eccessivo, è facile creare l'equivalente a livello di codice di un ciclo infinito se l'input corrisponde quasi al modello di espressione regolare. Il motore delle espressioni regolari può richiedere ore o persino giorni per l'elaborazione di una stringa di input relativamente breve.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</source>
          <target state="translated">L'utilizzo del backtracking comporta spesso una riduzione delle prestazioni delle applicazioni sebbene il backtracking non sia essenziale per una corrispondenza.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b\p{Lu}\w*\b`</ph> matches all words that begin with an uppercase character, as the following table shows.</source>
          <target state="translated">Ad esempio, l'espressione regolare <ph id="ph1">`\b\p{Lu}\w*\b`</ph> cerca una corrispondenza di tutte le parole che iniziano con un carattere maiuscolo, come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modello</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Inizia la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Match an uppercase character.</source>
          <target state="translated">Trova la corrispondenza di un carattere maiuscolo.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
          <target state="translated">Trova la corrispondenza di zero o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Termina la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</source>
          <target state="translated">Poiché un confine di parola non è uguale a un carattere alfanumerico né è un subset di tali caratteri, non è possibile che il motore delle espressioni regolari attraversi un confine di parola quando viene trovata una corrispondenza con i caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</source>
          <target state="translated">Ciò significa che per questa espressione regolare, il backtracking non potrà mai contribuire alla riuscita dell'operazione ma potrà solo ridurre le prestazioni poiché il motore delle espressioni regolari deve salvare lo stato per ogni corrispondenza preliminare corretta di un carattere alfanumerico.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>If you determine that backtracking is not necessary, you can disable it by using the <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element.</source>
          <target state="translated">Se si determina che il backtracking non è necessario, è possibile disabilitarlo usando l'elemento del linguaggio <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The following example parses an input string by using two regular expressions.</source>
          <target state="translated">Nell'esempio seguente viene analizzata una stringa di input utilizzando due espressioni regolari.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The first, <ph id="ph1">`\b\p{Lu}\w*\b`</ph>, relies on backtracking.</source>
          <target state="translated">La prima, <ph id="ph1">`\b\p{Lu}\w*\b`</ph>, si basa sul backtracking.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The second, <ph id="ph1">`\b\p{Lu}(?&gt;\w*)\b`</ph>, disables backtracking.</source>
          <target state="translated">La seconda, <ph id="ph1">`\b\p{Lu}(?&gt;\w*)\b`</ph>, disabilita il backtracking.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, they both produce the same result.</source>
          <target state="translated">Come illustrato nell'output dell'esempio, entrambe producono lo stesso risultato.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>In many cases, backtracking is essential for matching a regular expression pattern to input text.</source>
          <target state="translated">In molti casi, il backtracking è essenziale per la corrispondenza di un modello di espressione regolare con il testo di input.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</source>
          <target state="translated">Tuttavia, un utilizzo eccessivo del backtracking può ridurre notevolmente le prestazioni e dare l'impressione che un'applicazione non risponda.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</source>
          <target state="translated">In particolare, tale situazione si verifica quando vengono annidati i quantificatori e il testo che corrisponde alla sottoespressione esterna è un subset del testo che corrisponde alla sottoespressione interna.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</source>
          <target state="translated">Oltre a evitare un eccessivo utilizzo del backtracking, è necessario utilizzare la funzionalità di timeout per assicurarsi che l'eccessivo backtracking non comprometta troppo le prestazioni dell'espressione regolare.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Use time-out values<ept id="p1">](#use-time-out-values)</ept> section.</source>
          <target state="translated">Per altre informazioni, vedere la sezione <bpt id="p1">[</bpt>Usare valori di timeout<ept id="p1">](#use-time-out-values)</ept>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$`</ph> is intended to match a part number that consists of at least one alphanumeric character.</source>
          <target state="translated">Ad esempio, il criterio di espressione regolare <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$`</ph> viene usato per trovare la corrispondenza con un numero parte costituito da almeno un carattere alfanumerico.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</source>
          <target state="translated">Tutti i caratteri aggiuntivi possono essere costituiti da un carattere alfanumerico, un trattino, un carattere di sottolineatura o un punto, sebbene l'ultimo carattere debba essere alfanumerico.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>A dollar sign terminates the part number.</source>
          <target state="translated">Il numero parte termina con il simbolo del dollaro.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression <ph id="ph1">`[0-9A-Z]`</ph> is a subset of the subexpression <ph id="ph2">`[-.\w]*`</ph>.</source>
          <target state="translated">In alcuni casi, il criterio di espressione regolare può presentare prestazioni estremamente insufficienti perché vengono annidati i quantificatori e perché la sottoespressione <ph id="ph1">`[0-9A-Z]`</ph> è un subset della sottoespressione <ph id="ph2">`[-.\w]*`</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</source>
          <target state="translated">In questi casi, è possibile ottimizzare le prestazioni dell'espressione regolare rimuovendo i quantificatori annidati e sostituendo la sottoespressione esterna con un'asserzione lookahead o lookbehind di larghezza zero.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</source>
          <target state="translated">Le asserzioni lookahead e lookbehind sono ancoraggi; non spostano il puntatore nella stringa di input, ma eseguono il lookahead e lookbehind per verificare se è stata soddisfatta una condizione specificata.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>For example, the part number regular expression can be rewritten as <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])\$$`</ph>.</source>
          <target state="translated">Ad esempio, l'espressione regolare del numero parte può essere riscritta come <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])\$$`</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>This regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">Tale modello di espressione regolare viene definito come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modello</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the input string.</source>
          <target state="translated">Inizia la corrispondenza all'inizio della stringa di input.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">Trova la corrispondenza di un carattere alfanumerico.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The part number must consist of at least this character.</source>
          <target state="translated">Il numero parte deve essere costituito da almeno uno di questi caratteri.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of any word character, hyphen, or period.</source>
          <target state="translated">Trova la corrispondenza di zero o più occorrenze di un carattere alfanumerico, un trattino o un punto.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`</ph><ph id="ph2">\$</ph>]</source>
          <target state="translated"><ph id="ph1">`</ph><ph id="ph2">\$</ph>]</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Match a dollar sign.</source>
          <target state="translated">Trova la corrispondenza di un simbolo del dollaro.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</source>
          <target state="translated">Esegue il lookahead del simbolo del dollaro finale per verificare che il carattere precedente sia alfanumerico.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`$`</ph> End the match at the end of the input string.</source>
          <target state="translated"><ph id="ph1">`$`</ph> Termina la ricerca della corrispondenza alla fine della stringa di input.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The following example illustrates the use of this regular expression to match an array containing possible part numbers.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'utilizzo dell'espressione regolare per trovare la corrispondenza con una matrice contenente i numeri parte possibili.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</source>
          <target state="translated">Il linguaggio delle espressioni regolari in .NET include i seguenti elementi che è possibile usare per eliminare i quantificatori annidati.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Costrutti di raggruppamento nelle espressioni regolari<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Language element</source>
          <target state="translated">Elemento di linguaggio</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookahead.</source>
          <target state="translated">Asserzione lookahead positiva di larghezza zero.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Look ahead of the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> matches the input string.</source>
          <target state="translated">Lookahead della posizione corrente per determinare se <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> corrisponde alla stringa di input.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookahead.</source>
          <target state="translated">Asserzione lookahead negativa di larghezza zero.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Look ahead of the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> does not match the input string.</source>
          <target state="translated">Lookahead della posizione corrente per determinare se <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> non corrisponde alla stringa di input.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind.</source>
          <target state="translated">Lookbehind positivo di larghezza zero.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Look behind the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> matches the input string.</source>
          <target state="translated">Lookbehind della posizione corrente per determinare se <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> corrisponde alla stringa di input.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind.</source>
          <target state="translated">Lookbehind negativo di larghezza zero.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Look behind the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> does not match the input string.</source>
          <target state="translated">Lookbehind della posizione corrente per determinare se <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> non corrisponde alla stringa di input.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Use time-out values</source>
          <target state="translated">Usare valori di timeout</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</source>
          <target state="translated">Se le espressioni regolari elaborano l'input che corrisponde quasi al modello dell'espressione regolare, possono spesso basarsi su un backtracking eccessivo, con un impatto notevole sulle prestazioni.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</source>
          <target state="translated">Oltre a considerare attentamente l'utilizzo del backtracking e a testare l'espressione regolare rispetto all'input maggiormente corrispondente, è necessario impostare sempre un valore di timeout per assicurarsi che l'impatto di un eventuale backtracking eccessivo sia contenuto.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out.</source>
          <target state="translated">L'intervallo di timeout dell'espressione regolare definisce il periodo di tempo durante il quale il motore delle espressioni regolari cercherà una singola corrispondenza prima del timeout.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The default time-out interval is <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept>, which means that the regular expression will not time out.</source>
          <target state="translated">L'intervallo di timeout predefinito è <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept> che significa che l'espressione regolare non scadrà.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You can override this value and define a time-out interval as follows:</source>
          <target state="translated">È possibile eseguire l'override di questo valore e definire un intervallo di timeout come segue:</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>By providing a time-out value when you instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object by calling the <bpt id="p2">[</bpt>Regex(String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> constructor.</source>
          <target state="translated">Specificando un valore di timeout quando si crea un'istanza di un oggetto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> chiamando il costruttore <bpt id="p2">[</bpt>Regex(String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>By calling a static pattern matching method, such as <bpt id="p1">[</bpt>Regex.Match(String, String, RegexOptions, TimeSpan)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> or <bpt id="p2">[</bpt>Regex.Replace(String, String, String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept>, that includes a <bpt id="p3">*</bpt>matchTimeout<ept id="p3">*</ept> parameter.</source>
          <target state="translated">Chiamando un metodo di corrispondenza statico, ad esempio <bpt id="p1">[</bpt>Regex.Match(String, String, RegexOptions, TimeSpan)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> o <bpt id="p2">[</bpt>Regex.Replace(String, String, String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> che include un parametro <bpt id="p3">*</bpt>matchTimeout<ept id="p3">*</ept>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> exception.</source>
          <target state="translated">Se è stato definito un intervallo di timeout e non viene trovata alcuna corrispondenza alla fine di questo intervallo, il metodo dell'espressione regolare genera un'eccezione <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</source>
          <target state="translated">Nel gestore eccezioni, è possibile continuare a cercare la corrispondenza con un intervallo di timeout più lungo, abbandonare il tentativo di ricerca supponendo che non esista alcuna corrispondenza oppure abbandonare il tentativo di ricerca e registrare le informazioni sull'eccezione per un'analisi futura.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`GetWordData`</ph> method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</source>
          <target state="translated">Nell'esempio seguente viene definito un metodo <ph id="ph1">`GetWordData`</ph> che crea un'istanza di un'espressione regolare con un intervallo di timeout di 350 millisecondi per calcolare il numero di parole e il numero medio di caratteri di una parola in un documento di testo.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is re-instantiated.</source>
          <target state="translated">Se l'operazione di ricerca della corrispondenza scade, l'intervallo di timeout viene aumentato di 350 millisecondi e viene nuovamente creata un'istanza dell'oggetto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</source>
          <target state="translated">Se il nuovo intervallo di timeout supera 1 secondo, il metodo genera nuovamente l'eccezione al chiamante.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Capture only when necessary</source>
          <target state="translated">Eseguire l'acquisizione solo quando necessario</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</source>
          <target state="translated">Le espressioni regolari in .NET supportano diversi costrutti di raggruppamento, che consentono di raggruppare un modello di espressione regolare in una o più sottoespressioni.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The most commonly used grouping constructs in .NET regular expression language are <bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>, which defines a numbered capturing group, and <bpt id="p4">*</bpt><bpt id="p5">*</bpt>(?&lt;<ept id="p5">*</ept><bpt id="p6">_</bpt>name<ept id="p6">_</ept><ept id="p4">*</ept><bpt id="p7">*</bpt><ph id="ph1">&gt;</ph><ept id="p7">*</ept><bpt id="p8">*</bpt><bpt id="p9">_</bpt>subexpression<ept id="p9">_</ept><ept id="p8">*</ept><bpt id="p10">*</bpt>)<ept id="p10">*</ept>*, which defines a named capturing group.</source>
          <target state="translated">I costrutti di raggruppamento più comunemente usati nel linguaggio delle espressioni regolari di .NET sono <bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> che definisce un gruppo di acquisizione numerato, e <bpt id="p4">*</bpt><bpt id="p5">*</bpt>(?&lt;<ept id="p5">*</ept><bpt id="p6">_</bpt>name<ept id="p6">_</ept><ept id="p4">*</ept><bpt id="p7">*</bpt><ph id="ph1">&gt;</ph><ept id="p7">*</ept><bpt id="p8">*</bpt><bpt id="p9">_</bpt>subexpression<ept id="p9">_</ept><ept id="p8">*</ept><bpt id="p10">*</bpt>)<ept id="p10">*</ept>*che definisce un gruppo di acquisizione denominato.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</source>
          <target state="translated">I costrutti di raggruppamento sono indispensabili per la creazione di backreference e per la definizione di una sottoespressione a cui viene applicato un quantificatore.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>However, the use of these language elements has a cost.</source>
          <target state="translated">Tuttavia, l'utilizzo di questi elementi del linguaggio ha un costo.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>They cause the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <bpt id="p3">[</bpt>CaptureCollection<ept id="p3">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object returned by the <bpt id="p4">[</bpt>Group.Captures<ept id="p4">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property of a particular capturing group with multiple <bpt id="p5">[</bpt>Capture<ept id="p5">](xref:System.Text.RegularExpressions.Capture)</ept> objects.</source>
          <target state="translated">Comportano il popolamento dell'oggetto <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> restituito dalla proprietà <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> con le acquisizioni non denominate o denominate più recenti e se un singolo costrutto di raggruppamento ha acquisito più sottostringhe nella stringa di input comportano anche il popolamento dell'oggetto <bpt id="p3">[</bpt>CaptureCollection<ept id="p3">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> restituito dalla proprietà <bpt id="p4">[</bpt>Group.Captures<ept id="p4">](xref:System.Text.RegularExpressions.Group.Captures)</ept> di un gruppo di acquisizione specifico con più oggetti <bpt id="p5">[</bpt>Capture<ept id="p5">](xref:System.Text.RegularExpressions.Capture)</ept>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</source>
          <target state="translated">I costrutti di raggruppamento spesso vengono utilizzati solo in un'espressione regolare in modo tale che sia possibile applicarvi i quantificatori e che i gruppi acquisiti da queste sottoespressioni non vengano utilizzati successivamente.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b(\w+[;,]?\s?)+[.?!]`</ph> is designed to capture an entire sentence.</source>
          <target state="translated">Ad esempio, l'espressione regolare <ph id="ph1">`\b(\w+[;,]?\s?)+[.?!]`</ph> è progettata per acquisire un'intera frase.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The following table describes the language elements in this regular expression pattern and their effect on the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> object's <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> and <bpt id="p3">[</bpt>Group.Captures<ept id="p3">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collections.</source>
          <target state="translated">Nella tabella seguente sono descritti gli elementi del linguaggio del modello di espressione regolare e il relativo effetto sulle raccolte <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> e <bpt id="p3">[</bpt>Group.Captures<ept id="p3">](xref:System.Text.RegularExpressions.Group.Captures)</ept> dell'oggetto <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Inizia la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Match zero or one comma or semicolon.</source>
          <target state="translated">Trova la corrispondenza di una o nessuna virgola oppure di uno o nessun punto e virgola.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Trova la corrispondenza di uno o nessuno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</source>
          <target state="translated">Trova la corrispondenza di una o più occorrenze di uno o più caratteri alfanumerici seguiti da una virgola o un punto e virgola facoltativo seguito da uno spazio vuoto facoltativo.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</source>
          <target state="translated">Questo modello definisce il primo gruppo di acquisizione, necessario affinché la combinazione di più caratteri alfanumerici, ovvero una parola, seguiti da un simbolo di punteggiatura facoltativo venga ripetuta finché il motore delle espressioni regolari non raggiunge la fine di una frase.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Match a period, question mark, or exclamation point.</source>
          <target state="translated">Trova la corrispondenza di un punto, un punto interrogativo o un punto esclamativo.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>As the following example shows, when a match is found, both the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> objects are populated with captures from the match.</source>
          <target state="translated">Come illustrato nell'esempio seguente, quando viene trovata una corrispondenza, entrambi gli oggetti <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> e <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> vengono popolati con le acquisizioni della corrispondenza.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>In this case, the capturing group <ph id="ph1">`(\w+[;,]?\s?)`</ph> exists so that the <bpt id="p1">**</bpt><ph id="ph2">+</ph><ept id="p1">**</ept> quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</source>
          <target state="translated">In questo caso, è presente il gruppo di acquisizione <ph id="ph1">`(\w+[;,]?\s?)`</ph> in modo tale che sia possibile applicarvi il quantificatore <bpt id="p1">**</bpt><ph id="ph2">+</ph><ept id="p1">**</ept> consentendo al criterio di espressione regolare di trovare la corrispondenza con ogni parola di una frase.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Otherwise, it would match the last word in a sentence.</source>
          <target state="translated">In caso contrario, verrebbe trovata la corrispondenza con l'ultima parola di una frase.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</source>
          <target state="translated">Quando le sottoespressioni vengono utilizzate solo per applicarvi i quantificatori e non è necessario il testo acquisito, è consigliabile disabilitare le acquisizioni del gruppo.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element prevents the group to which it applies from capturing matched substrings.</source>
          <target state="translated">Ad esempio, l'elemento del linguaggio <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> impedisce al gruppo al quale viene applicato di acquisire le sottostringhe corrispondenti.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression pattern from the previous example is changed to <ph id="ph1">`\b(?:\w+[;,]?\s?)+[.?!]`</ph>.</source>
          <target state="translated">Nell'esempio seguente il criterio di espressione regolare dell'esempio precedente viene modificato in <ph id="ph1">`\b(?:\w+[;,]?\s?)+[.?!]`</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>As the output shows, it prevents the regular expression engine from populating the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collections.</source>
          <target state="translated">Come illustrato nell'output, il motore delle espressioni regolari non popolerà le raccolte <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> e <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>You can disable captures in one of the following ways:</source>
          <target state="translated">È possibile disabilitare le acquisizioni in uno dei modi seguenti:</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element.</source>
          <target state="translated">Usare l'elemento del linguaggio <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>This element prevents the capture of matched substrings in the group to which it applies.</source>
          <target state="translated">Questo elemento impedisce l'acquisizione delle sottostringhe corrispondenti nel gruppo a cui viene applicato.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>It does not disable substring captures in any nested groups.</source>
          <target state="translated">Non disabilita le acquisizioni delle sottostringhe in tutti i gruppi annidati.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">Usare l'opzione <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>It disables all unnamed or implicit captures in the regular expression pattern.</source>
          <target state="translated">Disabilita tutte le acquisizioni non denominate o implicite nel modello di espressione regolare.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>When you use this option, only substrings that match named groups defined with the <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept><bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> language element can be captured.</source>
          <target state="translated">Quando si usa questa opzione, è possibile acquisire solo le sottostringhe che corrispondono ai gruppi denominati definiti con l'elemento del linguaggio <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept><bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> flag can be passed to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or to the options parameter of a <bpt id="p3">[</bpt>Regex<ept id="p3">](xref:System.Text.RegularExpressions.Regex)</ept> static matching method.</source>
          <target state="translated">Il flag <bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> può essere passato al parametro options di un costruttore di classe <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> o al parametro options di un metodo di corrispondenza statico <bpt id="p3">[</bpt>Regex<ept id="p3">](xref:System.Text.RegularExpressions.Regex)</ept>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>n<ept id="p1">**</ept> option in the <bpt id="p2">**</bpt>(?imnsx)<ept id="p2">**</ept> language element.</source>
          <target state="translated">Usare l'opzione <bpt id="p1">**</bpt>n<ept id="p1">**</ept> nell'elemento del linguaggio <bpt id="p2">**</bpt>(?imnsx)<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</source>
          <target state="translated">Questa opzione disabilita tutte le acquisizioni non denominate o implicite dal punto nel modello di espressione regolare in corrispondenza del quale viene visualizzato l'elemento.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Captures are disabled either until the end of the pattern or until the <bpt id="p1">**</bpt>(-n)<ept id="p1">**</ept> option enables unnamed or implicit captures.</source>
          <target state="translated">Le acquisizioni vengono disabilitate fino alla fine del modello o finché l'opzione <bpt id="p1">**</bpt>(-n)<ept id="p1">**</ept> non abilita le acquisizioni non denominate o implicite.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Miscellaneous constructs in regular expressions<ept id="p1">](miscellaneous.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Costrutti vari nelle espressioni regolari<ept id="p1">](miscellaneous.md)</ept>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>n<ept id="p1">**</ept> option in the <bpt id="p2">**</bpt>(?imnsx:<ept id="p2">**</ept><bpt id="p3">_</bpt>subexpression<ept id="p3">_</ept><bpt id="p4">**</bpt>)<ept id="p4">**</ept> language element.</source>
          <target state="translated">Usare l'opzione <bpt id="p1">**</bpt>n<ept id="p1">**</ept> nell'elemento del linguaggio <bpt id="p2">**</bpt>(?imnsx:<ept id="p2">**</ept><bpt id="p3">_</bpt>subexpression<ept id="p3">_</ept><bpt id="p4">**</bpt>)<ept id="p4">**</ept>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>This option disables all unnamed or implicit captures in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>.</source>
          <target state="translated">Questa opzione disabilita tutte le acquisizioni non denominate o implicite in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Captures by any unnamed or implicit nested capturing groups are disabled as well.</source>
          <target state="translated">Vengono inoltre disabilitate tutte le acquisizioni dai gruppi di acquisizione annidati non denominati o impliciti.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="translated">Argomenti correlati</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Titolo</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Details of regular expression behavior<ept id="p1">](regex-behavior.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Dettagli sul comportamento delle espressioni regolari<ept id="p1">](regex-behavior.md)</ept></target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Examines the implementation of the regular expression engine in .NET.</source>
          <target state="translated">Viene esaminata l'implementazione del motore delle espressioni regolari in .NET.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</source>
          <target state="translated">L'argomento è incentrato sulla flessibilità delle espressioni regolari e sulla responsabilità dello sviluppatore al fine di garantire un funzionamento efficace e affidabile del motore delle espressioni regolari.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking in regular expressions<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Backtracking nelle espressioni regolari<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</source>
          <target state="translated">Viene illustrato il backtracking e il modo in cui influisce sulle prestazioni delle espressioni regolari e vengono esaminati gli elementi del linguaggio che forniscono le alternative al backtracking.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Linguaggio di espressioni regolari - Riferimento rapido<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</source>
          <target state="translated">Vengono illustrati gli elementi del linguaggio delle espressioni regolari in .NET e vengono forniti i collegamenti alla documentazione dettagliata per ogni elemento del linguaggio.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>