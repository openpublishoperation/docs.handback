<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-47f9650" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05fcdadee5d932a53941386f97971c24cc912fd8</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\grouping.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ef12f7fd6c6d1c5edcd6954e8451b5b059c9d592</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7faad857c3326bcbf1815b67708e4e9622566dc1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">Costrutti di raggruppamento nelle espressioni regolari</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">Costrutti di raggruppamento nelle espressioni regolari</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">Costrutti di raggruppamento nelle espressioni regolari</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</source>
          <target state="translated">I costrutti di raggruppamento delineano sottoespressioni di un'espressione regolare e acquisiscono sottostringhe di una stringa di input.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can use grouping constructs to do the following:</source>
          <target state="translated">È possibile usare i costrutti di raggruppamento per effettuare le operazioni seguenti:</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Match a subexpression that is repeated in the input string.</source>
          <target state="translated">Trovare la corrispondenza di una sottoespressione ripetuta nella stringa di input.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Apply a quantifier to a subexpression that has multiple regular expression language elements.</source>
          <target state="translated">Applicare un quantificatore a una sottoespressione che dispone di più elementi del linguaggio di espressioni regolari.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more information about quantifiers, see <bpt id="p1">[</bpt>Quantifiers in regular expressions<ept id="p1">](quantifiers.md)</ept>.</source>
          <target state="translated">Per altre informazioni sui quantificatori, vedere <bpt id="p1">[</bpt>Quantificatori nelle espressioni regolari<ept id="p1">](quantifiers.md)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Include a subexpression in the string that is returned by the <bpt id="p1">[</bpt>Regex.Replace<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> and <bpt id="p2">[</bpt>Match.Result<ept id="p2">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> methods.</source>
          <target state="translated">Includere una sottoespressione nella stringa restituita dai metodi <bpt id="p1">[</bpt>Regex.Replace<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> e <bpt id="p2">[</bpt>Match.Result<ept id="p2">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Retrieve individual subexpressions from the <bpt id="p1">[</bpt>Match.Groups<ept id="p1">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property and process them separately from the matched text as a whole.</source>
          <target state="translated">Recuperare le singole sottoespressioni dalla proprietà <bpt id="p1">[</bpt>Match.Groups<ept id="p1">](xref:System.Text.RegularExpressions.Match.Groups)</ept> ed elaborarle separatamente dal testo corrispondente nel suo complesso.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following table lists the grouping constructs supported by .NET regular expression engine and indicates whether they are capturing or non-capturing.</source>
          <target state="translated">La tabella seguente elenca i costrutti di raggruppamento supportati dal motore delle espressioni regolari di .NET e indica se sono di acquisizione o non acquisizione.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Grouping construct</source>
          <target state="translated">Costrutto di raggruppamento</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Capturing or noncapturing</source>
          <target state="translated">Acquisizione o non acquisizione</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Matched subexpressions<ept id="p1">](#matched-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Sottoespressioni corrispondenti<ept id="p1">](#matched-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">Acquisizione</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Named matched subexpressions<ept id="p1">](#named-matched-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Sottoespressioni corrispondenti denominate<ept id="p1">](#named-matched-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">Acquisizione</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Balancing group definitions<ept id="p1">](#balancing-group-definitions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Definizioni di gruppo di bilanciamento<ept id="p1">](#balancing-group-definitions)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">Acquisizione</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Noncapturing groups<ept id="p1">](#noncapturing-groups)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Gruppi di non acquisizione<ept id="p1">](#noncapturing-groups)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Non acquisizione</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Group options<ept id="p1">](#group-options)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Opzioni di gruppo<ept id="p1">](#group-options)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Non acquisizione</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width positive lookahead assertions<ept id="p1">](#zero-width-positive-lookahead-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Asserzioni lookahead positive di larghezza zero<ept id="p1">](#zero-width-positive-lookahead-assertions)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Non acquisizione</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width negative lookahead assertions<ept id="p1">](#zero-width-negative-lookahead-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Asserzioni lookahead negative di larghezza zero<ept id="p1">](#zero-width-negative-lookahead-assertions)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Non acquisizione</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width positive lookbehind assertions<ept id="p1">](#zero-width-positive-lookbehind-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Asserzioni lookbehind positive di larghezza zero<ept id="p1">](#zero-width-positive-lookbehind-assertions)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Non acquisizione</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width negative lookbehind assertions<ept id="p1">](#zero-width-negative-lookbehind-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Asserzioni lookbehind negative di larghezza zero<ept id="p1">](#zero-width-negative-lookbehind-assertions)</ept></target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Non acquisizione</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nonbacktracking subexpressions<ept id="p1">](#nonbacktracking-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Sottoespressioni di non backtracking<ept id="p1">](#nonbacktracking-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Non acquisizione</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For information on groups and the regular expression object model, see <bpt id="p1">[</bpt>Grouping Constructs and Regular Expression Objects<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>.</source>
          <target state="translated">Per informazioni sui gruppi e sul modello a oggetti delle espressioni regolari, vedere <bpt id="p1">[</bpt>Costrutti di raggruppamento e oggetti di espressione regolare<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Matched subexpressions</source>
          <target state="translated">Sottoespressioni corrispondenti</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following grouping construct captures a matched subexpression:</source>
          <target state="translated">Nel costrutto di raggruppamento seguente viene acquisita una sottoespressione corrispondente:</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">dove <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> è un qualsiasi criterio di espressioni regolari valido.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</source>
          <target state="translated">Le acquisizioni che usano parentesi sono numerate automaticamente da sinistra verso destra in base all'ordine delle parentesi di apertura nell'espressione regolare, a partire da uno.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The capture that is numbered zero is the text matched by the entire regular expression pattern.</source>
          <target state="translated">L'acquisizione che viene numerata zero è il testo corrispondente all'intero criterio dell'espressione regolare.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>By default, the (subexpression) language element captures the matched subexpression.</source>
          <target state="translated">Per impostazione predefinita, l'elemento di linguaggio (sottoespressione) acquisisce la sottoespressione corrispondente.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>But if the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression (see Group options later in this topic), the matched subexpression is not captured.</source>
          <target state="translated">Tuttavia, se il parametro RegexOptions di un metodo dei criteri di ricerca di espressioni regolari include il flag RegexOptions.ExplicitCapture o se viene applicata l'opzione n a questa sottoespressione (vedere Opzioni di gruppo più avanti in questo argomento), la sottoespressione corrispondente non viene acquisita.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can access captured groups in four ways:</source>
          <target state="translated">È possibile accedere a questi gruppi acquisiti in quattro modi diversi:</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>By using the backreference construct within the regular expression.</source>
          <target state="translated">Tramite il costrutto del backreference all'interno dell'espressione regolare.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept>, where <ept id="p1">*</ept>number* is the ordinal number of the captured subexpression.</source>
          <target state="translated">Tramite la sintassi <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>numero<ept id="p3">_</ept>, dove <ept id="p1">*</ept>numero* è il numero ordinale della sottoespressione acquisita, è possibile fare riferimento alla sottoespressione corrispondente nella stessa espressione regolare.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>By using the named backreference construct within the regular expression.</source>
          <target state="translated">Tramite il costrutto del backreference denominato all'interno dell'espressione regolare.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, where <bpt id="p4">*</bpt>name<ept id="p4">*</ept> is the name of a capturing group, or <bpt id="p5">**</bpt>\k<ept id="p5">**</ept><bpt id="p6">_</bpt>&lt;number<ept id="p6">_</ept><bpt id="p7">**</bpt><ph id="ph2">&gt;</ph><ept id="p7">**</ept>, where <bpt id="p8">*</bpt>number<ept id="p8">*</ept> is the ordinal number of a capturing group.</source>
          <target state="translated">Tramite la sintassi <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>nome<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, dove <bpt id="p4">*</bpt>nome<ept id="p4">*</ept> è il nome di un gruppo di acquisizione, o <bpt id="p5">**</bpt>\k<ept id="p5">**</ept><bpt id="p6">_</bpt>&lt;numero<ept id="p6">_</ept><bpt id="p7">**</bpt><ph id="ph2">&gt;</ph><ept id="p7">**</ept>, dove <bpt id="p8">*</bpt>numero<ept id="p8">*</ept> è il numero ordinale di un gruppo di acquisizione, è possibile fare riferimento alla sottoespressione corrispondente nella stessa espressione regolare.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A capturing group has a default name that is identical to its ordinal number.</source>
          <target state="translated">Un gruppo di acquisizione ha un nome predefinito identico al relativo numero ordinale.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For more information, see Grouping constructs and regular expression objects later in this topic.</source>
          <target state="translated">Per altre informazioni, vedere Costrutti di raggruppamento e oggetti di espressione regolare più avanti in questo argomento.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> replacement sequence in a <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p5">*</bpt>number<ept id="p5">*</ept> is the ordinal number of the captured subexpression.</source>
          <target state="translated">Tramite la sequenza di sostituzione <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>numero<ept id="p2">_</ept> in una chiamata al metodo <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> o <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept>, dove <bpt id="p5">*</bpt>numero<ept id="p5">*</ept> è il numero ordinale della sottoespressione acquisita.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Programmatically, by using the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">A livello di programmazione, tramite l'oggetto <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> restituito dalla proprietà <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The member at position zero in the collection represents the entire regular expression match.</source>
          <target state="translated">Il membro alla posizione zero nella raccolta rappresenta l'intera corrispondenza dell'espressione regolare.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Each subsequent member represents a matched subexpression.</source>
          <target state="translated">Ogni membro successivo rappresenta una sottoespressione corrispondente.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Grouping Constructs and Regular Expression Objects<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept> section.</source>
          <target state="translated">Per altre informazioni, vedere la sezione <bpt id="p1">[</bpt>Costrutti di raggruppamento e oggetti di espressione regolare<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that identifies duplicated words in text.</source>
          <target state="translated">Nell'esempio seguente viene illustrata un'espressione regolare che identifica le parole duplicate in un testo.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</source>
          <target state="translated">I due gruppi di acquisizione del criterio di ricerca di espressioni regolari rappresentano le due istanze della parola duplicata.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The second instance is captured to report its starting position in the input string.</source>
          <target state="translated">La seconda istanza è acquisita per riportare la posizione iniziale nella stringa di input.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is the following:</source>
          <target state="translated">Il criterio dell'espressione regolare è il seguente:</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">Nella tabella seguente è illustrata l'interpretazione del criterio di ricerca di espressioni regolari.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Equivale al primo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Trova la corrispondenza con uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Match the string in the first captured group.</source>
          <target state="translated">Trova la corrispondenza con la stringa nel primo gruppo acquisito.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">Equivale al secondo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the <ph id="ph1">`Match.Index`</ph> property.</source>
          <target state="translated">L'esempio lo assegna a un gruppo acquisito in modo che sia possibile recuperare la posizione iniziale della parola duplicata dalla proprietà <ph id="ph1">`Match.Index`</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Match a non-word character, including white space and punctuation.</source>
          <target state="translated">Trova la corrispondenza con un carattere non alfanumerico, inclusi spazio vuoto e punteggiatura.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</source>
          <target state="translated">Impedisce al criterio dell'espressione regolare di trovare la corrispondenza con una parola che inizia con la parola del primo gruppo acquisito.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Named matched subexpressions</source>
          <target state="translated">Sottoespressioni corrispondenti denominate</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following grouping construct captures a matched subexpression and lets you access it by name or by number:</source>
          <target state="translated">Il costrutto di raggruppamento seguente acquisisce una sottoespressione corrispondente e consente di accedervi tramite nome o numero:</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">oppure:</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is a valid group name, and <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">dove <bpt id="p1">*</bpt>nome<ept id="p1">*</ept> è un nome di gruppo valido e <bpt id="p2">*</bpt>sottoespressione<ept id="p2">*</ept> è un qualsiasi criterio di espressioni regolari valido.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>name<ept id="p1">*</ept> must not contain any punctuation characters and cannot begin with a number.</source>
          <target state="translated"><bpt id="p1">*</bpt>nome<ept id="p1">*</ept> non deve contenere alcun simbolo di punteggiatura e non può iniziare con un numero.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> parameter of a regular expression pattern matching method includes the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> flag, or if the <bpt id="p3">**</bpt>n<ept id="p3">**</ept> option is applied to this subexpression (see <bpt id="p4">[</bpt>Group options<ept id="p4">](#group-options)</ept> later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</source>
          <target state="translated">Se il parametro <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> di un metodo dei criteri di ricerca di espressioni regolari include il flag <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> o se l'opzione <bpt id="p3">**</bpt>n<ept id="p3">**</ept> viene applicata a questa sottoespressione (vedere <bpt id="p4">[</bpt>Opzioni di gruppo<ept id="p4">](#group-options)</ept> più avanti in questo argomento), l'unico modo per acquisire una sottoespressione è assegnare esplicitamente un nome ai gruppi di acquisizione.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can access named captured groups in the following ways:</source>
          <target state="translated">È possibile accedere ai gruppi acquisiti denominati nei modi seguenti:</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>By using the named backreference construct within the regular expression.</source>
          <target state="translated">Tramite il costrutto del backreference denominato all'interno dell'espressione regolare.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, where <bpt id="p4">*</bpt>name<ept id="p4">*</ept> is the name of the captured subexpression.</source>
          <target state="translated">Tramite la sintassi <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>nome<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, dove <bpt id="p4">*</bpt>nome<ept id="p4">*</ept> è il nome della sottoespressione acquisita, è possibile fare riferimento alla sottoespressione corrispondente nella stessa espressione regolare.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>By using the backreference construct within the regular expression.</source>
          <target state="translated">Tramite il costrutto del backreference all'interno dell'espressione regolare.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept>, where <ept id="p1">*</ept>number* is the ordinal number of the captured subexpression.</source>
          <target state="translated">Tramite la sintassi <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>numero<ept id="p3">_</ept>, dove <ept id="p1">*</ept>numero* è il numero ordinale della sottoespressione acquisita, è possibile fare riferimento alla sottoespressione corrispondente nella stessa espressione regolare.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</source>
          <target state="translated">Le sottoespressioni corrispondenti denominate sono numerate consecutivamente da sinistra a destra dopo le sottoespressioni corrispondenti.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt>${<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> replacement sequence in a <bpt id="p4">[</bpt>Regex.Replace<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p5">[</bpt>Match.Result<ept id="p5">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p6">*</bpt>name<ept id="p6">*</ept> is the name of the captured subexpression.</source>
          <target state="translated">Tramite la sequenza di sostituzione <bpt id="p1">**</bpt>${<ept id="p1">**</ept><bpt id="p2">_</bpt>nome<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> in una chiamata al metodo <bpt id="p4">[</bpt>Regex.Replace<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> o <bpt id="p5">[</bpt>Match.Result<ept id="p5">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept>, dove <bpt id="p6">*</bpt>nome<ept id="p6">*</ept> è il nome della sottoespressione acquisita.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> replacement sequence in a <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p5">*</bpt>number<ept id="p5">*</ept> is the ordinal number of the captured subexpression.</source>
          <target state="translated">Tramite la sequenza di sostituzione <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>numero<ept id="p2">_</ept> in una chiamata al metodo <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> o <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept>, dove <bpt id="p5">*</bpt>numero<ept id="p5">*</ept> è il numero ordinale della sottoespressione acquisita.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Programmatically, by using the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">A livello di programmazione, tramite l'oggetto <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> restituito dalla proprietà <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The member at position zero in the collection represents the entire regular expression match.</source>
          <target state="translated">Il membro alla posizione zero nella raccolta rappresenta l'intera corrispondenza dell'espressione regolare.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Each subsequent member represents a matched subexpression.</source>
          <target state="translated">Ogni membro successivo rappresenta una sottoespressione corrispondente.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Named captured groups are stored in the collection after numbered captured groups.</source>
          <target state="translated">I gruppi acquisiti denominati vengono archiviati nella raccolta dopo i gruppi acquisiti numerati.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Programmatically, by providing the subexpression name to the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object's indexer  (in C#) or to its Item property (in Visual Basic).</source>
          <target state="translated">A livello di codice, specificando il nome della sottoespressione all'indicizzatore dell'oggetto <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> (in C#) o alla relativa proprietà Item (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</source>
          <target state="translated">Un criterio di ricerca di espressioni regolari semplice illustra in che modo è possibile fare riferimento a gruppi denominati e numerati (non denominati) a livello di codice o tramite la sintassi del linguaggio delle espressioni regolari.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`((?&lt;One&gt;abc)\d+)?(?&lt;Two&gt;xyz)(.*)`</ph> produces the following capturing groups by number and by name.</source>
          <target state="translated">L'espressione regolare <ph id="ph1">`((?&lt;One&gt;abc)\d+)?(?&lt;Two&gt;xyz)(.*)`</ph> crea i gruppi di acquisizione seguenti in base a numero e nome.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The first capturing group (number 0) always refers to the entire pattern.</source>
          <target state="translated">Il primo gruppo di acquisizione (numero 0) fa sempre riferimento all'intero criterio.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Numero</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Nome</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>0 (default name)</source>
          <target state="translated">0 (nome predefinito)</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>1 (default name)</source>
          <target state="translated">1 (nome predefinito)</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>2 (default name)</source>
          <target state="translated">2 (nome predefinito)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>One</source>
          <target state="translated">Uno</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Two</source>
          <target state="translated">Due</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</source>
          <target state="translated">Nell'esempio seguente viene illustrata un'espressione regolare che identifica parole duplicate e la parola che segue immediatamente ogni parola duplicata.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The regular expression pattern defines two named subexpressions: <ph id="ph1">`duplicateWord`</ph>, which represents the duplicated word; and <ph id="ph2">`nextWord`</ph>, which represents the word that follows the duplicated word.</source>
          <target state="translated">Il criterio di ricerca di espressioni regolari definisce due sottoespressioni denominate: <ph id="ph1">`duplicateWord`</ph> che rappresenta la parola duplicata e <ph id="ph2">`nextWord`</ph> che rappresenta la parola che segue la parola duplicata.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is as follows:</source>
          <target state="translated">Il criterio di ricerca di espressioni regolari è il seguente:</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression is interpreted.</source>
          <target state="translated">Nella tabella seguente viene illustrato come viene interpretata l'espressione regolare.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`duplicateWord`</ph>.</source>
          <target state="translated">Il nome di questo gruppo di acquisizione è <ph id="ph1">`duplicateWord`</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Trova la corrispondenza con uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Match the string from the captured group that is named <ph id="ph1">`duplicateWord`</ph>.</source>
          <target state="translated">Trova la corrispondenza con la stringa del gruppo acquisito che è denominata <ph id="ph1">`duplicateWord`</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match a non-word character, including white space and punctuation.</source>
          <target state="translated">Trova la corrispondenza con un carattere non alfanumerico, inclusi spazio vuoto e punteggiatura.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</source>
          <target state="translated">Impedisce al criterio dell'espressione regolare di trovare la corrispondenza con una parola che inizia con la parola del primo gruppo acquisito.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`nextWord`</ph>.</source>
          <target state="translated">Il nome di questo gruppo di acquisizione è <ph id="ph1">`nextWord`</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Note that a group name can be repeated in a regular expression.</source>
          <target state="translated">Il nome di un gruppo può essere ripetuto in un'espressione regolare.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>For example, it is possible for more than one group to be named <ph id="ph1">`digit`</ph>, as the following example illustrates.</source>
          <target state="translated">Ad esempio, è possibile che più di un gruppo sia denominato <ph id="ph1">`digit`</ph>, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>In the case of duplicate names, the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object is determined by the last successful capture in the input string.</source>
          <target state="translated">Nel caso di nomi duplicati, il valore dell'oggetto <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> è determinato dall'ultima acquisizione corretta nella stringa di input.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>In addition, the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> is populated with information about each capture just as it would be if the group name was not duplicated.</source>
          <target state="translated">L'oggetto <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> viene anche popolato con informazioni su ogni acquisizione, secondo la normale procedura usata quando il nome del gruppo non è duplicato.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression <ph id="ph1">`\D+(?&lt;digit&gt;\d+)\D+(?&lt;digit&gt;\d+)?`</ph> includes two occurrences of a group named <ph id="ph2">`digit`</ph>.</source>
          <target state="translated">Nell'esempio seguente l'espressione regolare <ph id="ph1">`\D+(?&lt;digit&gt;\d+)\D+(?&lt;digit&gt;\d+)?`</ph> include due occorrenze di un gruppo denominato <ph id="ph2">`digit`</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The first <ph id="ph1">`digit`</ph> named group captures one or more digit characters.</source>
          <target state="translated">Il primo gruppo denominato <ph id="ph1">`digit`</ph> acquisisce una o più cifre.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The second <ph id="ph1">`digit`</ph> named group captures either zero or one occurrence of one or more digit characters.</source>
          <target state="translated">Il secondo gruppo denominato <ph id="ph1">`digit`</ph> acquisisce zero o un'occorrenza di una o più cifre.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object.</source>
          <target state="translated">Come illustrato nell'esempio, se il secondo gruppo di acquisizione corrisponde al testo, il valore del testo definisce il valore dell'oggetto <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object.</source>
          <target state="translated">Se il secondo gruppo di acquisizione non corrisponde alla stringa di input, il valore dell'ultima corrispondenza corretta definisce il valore dell'oggetto <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression is interpreted.</source>
          <target state="translated">Nella tabella seguente viene illustrato come viene interpretata l'espressione regolare.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Match one or more non-decimal digit characters.</source>
          <target state="translated">Corrisponde a una o più cifre non decimali.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digit characters.</source>
          <target state="translated">Corrisponde a una o più cifre decimali.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Assign the match to the <ph id="ph1">`digit`</ph> named group.</source>
          <target state="translated">Assegna la corrispondenza al gruppo denominato <ph id="ph1">`digit`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Match one or more non-decimal digit characters.</source>
          <target state="translated">Corrisponde a una o più cifre non decimali.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of one or more decimal digit characters.</source>
          <target state="translated">Corrisponde a zero o a un'occorrenza di una o più cifre decimali.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Assign the match to the <ph id="ph1">`digit`</ph> named group.</source>
          <target state="translated">Assegna la corrispondenza al gruppo denominato <ph id="ph1">`digit`</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Balancing group definitions</source>
          <target state="translated">Definizioni di gruppo di bilanciamento</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</source>
          <target state="translated">Una definizione di gruppo di bilanciamento elimina la definizione di un gruppo precedentemente definito e archivia nel gruppo corrente l'intervallo tra il gruppo precedentemente definito e il gruppo corrente.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>This grouping construct has the following format:</source>
          <target state="translated">Questo costrutto di raggruppamento presenta il formato seguente:</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">oppure:</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> is the current group (optional), <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> is a previously defined group, and <bpt id="p3">*</bpt>subexpression<ept id="p3">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">dove <bpt id="p1">*</bpt>nome1<ept id="p1">*</ept> è il gruppo corrente (facoltativo), <bpt id="p2">*</bpt>nome2<ept id="p2">*</ept> è un gruppo precedentemente definito e <bpt id="p3">*</bpt>sottoespressione<ept id="p3">*</ept> è un qualsiasi criterio di espressioni regolari valido.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The balancing group definition deletes the definition of <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> and stores the interval between <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> and <bpt id="p3">*</bpt>name1<ept id="p3">*</ept> in <bpt id="p4">*</bpt>name1<ept id="p4">*</ept>.</source>
          <target state="translated">La definizione di gruppo di bilanciamento elimina la definizione di <bpt id="p1">*</bpt>nome2<ept id="p1">*</ept> e archivia l'intervallo tra <bpt id="p2">*</bpt>nome2<ept id="p2">*</ept> e <bpt id="p3">*</bpt>nome1<ept id="p3">*</ept> in <bpt id="p4">*</bpt>nome1<ept id="p4">*</ept>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>If no <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> group is defined, the match backtracks.</source>
          <target state="translated">Se non è definito alcun gruppo <bpt id="p1">*</bpt>nome2<ept id="p1">*</ept>, viene eseguito il backtracking della corrispondenza.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Because deleting the last definition of <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> reveals the previous definition of <bpt id="p2">*</bpt>name2<ept id="p2">*</ept>, this construct lets you use the stack of captures for group <bpt id="p3">*</bpt>name2<ept id="p3">*</ept> as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</source>
          <target state="translated">Poiché l'eliminazione dell'ultima definizione di <bpt id="p1">*</bpt>nome2<ept id="p1">*</ept> rivela la definizione precedente di <bpt id="p2">*</bpt>nome2<ept id="p2">*</ept>, questo costrutto consente di usare lo stack di acquisizioni per il gruppo <bpt id="p3">*</bpt>nome2<ept id="p3">*</ept> come contatore per tenere traccia dei costrutti annidati, come ad esempio le parentesi o le parentesi quadre di apertura e chiusura.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The balancing group definition uses <bpt id="p1">*</bpt>name2<ept id="p1">*</ept>as a stack.</source>
          <target state="translated">La definizione del gruppo di bilanciamento usa <bpt id="p1">*</bpt>nome2<ept id="p1">*</ept> come stack.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The beginning character of each nested construct is placed in the group and in its <bpt id="p1">[</bpt>Group.Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collection.</source>
          <target state="translated">Il carattere iniziale di ogni costrutto annidato viene posizionato nel gruppo e nella relativa raccolta <bpt id="p1">[</bpt>Group.Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>When the closing character is matched, its corresponding opening character is removed from the group, and the <bpt id="p1">[</bpt>Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collection is decreased by one.</source>
          <target state="translated">Quando viene trovata la corrispondenza con il carattere di chiusura, il carattere di apertura associato viene rimosso dal gruppo e la raccolta <bpt id="p1">[</bpt>Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> viene ridotta di una unità.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>After the opening and closing characters of all nested constructs have been matched, <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> is empty.</source>
          <target state="translated">Dopo aver trovato la corrispondenza dei caratteri di apertura e chiusura di tutti i costrutti annidati, <bpt id="p1">*</bpt>nome1<ept id="p1">*</ept> sarà vuoto.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</source>
          <target state="translated">Dopo avere modificato l'espressione regolare dell'esempio seguente affinché usi il carattere di apertura e chiusura appropriato di un costrutto annidato, è possibile usarla per gestire più costrutti annidati, come ad esempio espressioni matematiche o righe di codice del programma che includono più chiamate al metodo annidate.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The following example uses a balancing group definition to match left and right angle brackets (&lt;&gt;) in an input string.</source>
          <target state="translated">Nell'esempio seguente viene usata una definizione di gruppo di bilanciamento per trovare una corrispondenza di parentesi uncinate aperte e chiuse (&lt;&gt;) in una stringa di input.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The example defines two named groups, <ph id="ph1">`Open`</ph> and <ph id="ph2">`Close`</ph>, that are used like a stack to track matching pairs of angle brackets.</source>
          <target state="translated">Nell'esempio vengono definiti due gruppi denominati, <ph id="ph1">`Open`</ph> e <ph id="ph2">`Close`</ph>, usati come uno stack per rilevare coppie corrispondenti di parentesi uncinate.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Each captured left angle bracket is pushed into the capture collection of the <ph id="ph1">`Open`</ph> group, and each captured right angle bracket is pushed into the capture collection of the <ph id="ph2">`Close`</ph> group.</source>
          <target state="translated">Ogni parentesi uncinata aperta acquisita viene inserita nella raccolta di acquisizioni del gruppo <ph id="ph1">`Open`</ph> e ogni parentesi uncinata chiusa acquisita viene inserita nella raccolta di acquisizioni del gruppo <ph id="ph2">`Close`</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</source>
          <target state="translated">La definizione di gruppo di bilanciamento si assicura che sia presente una parentesi uncinata chiusa corrispondente per ogni parentesi uncinata aperta.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>If there is not, the final subpattern, <ph id="ph1">`(?(Open)(?!))`</ph>, is evaluated only if the <ph id="ph2">`Open`</ph> group is not empty (and, therefore, if all nested constructs have not been closed).</source>
          <target state="translated">In caso contrario, il criterio secondario <ph id="ph1">`(?(Open)(?!))`</ph> finale viene valutato solo se il gruppo <ph id="ph2">`Open`</ph> non è vuoto e, pertanto, se tutti i costrutti annidati non sono stati chiusi.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>If the final subpattern is evaluated, the match fails, because the <ph id="ph1">`(?!)`</ph> subpattern is a zero-width negative lookahead assertion that always fails.</source>
          <target state="translated">Se il criterio secondario finale viene valutato, non viene trovata la corrispondenza perché il criterio secondario <ph id="ph1">`(?!)`</ph> è un'asserzione lookahead negativa di larghezza zero che ha sempre esito negativo.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is:</source>
          <target state="translated">Il criterio di ricerca di espressioni regolari è:</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The regular expression is interpreted as follows:</source>
          <target state="translated">L'espressione regolare viene interpretata nel modo seguente.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Begin at the start of the string.</source>
          <target state="translated">Comincia all'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Match zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">Trova la corrispondenza di zero o più caratteri diversi da parentesi uncinate aperte o chiuse.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Match a left angle bracket and assign it to a group named <ph id="ph1">`Open`</ph>.</source>
          <target state="translated">Trova la corrispondenza di una parentesi uncinata aperta e la assegna a un gruppo denominato <ph id="ph1">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Match zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">Trova la corrispondenza di zero o più caratteri diversi da parentesi uncinate aperte o chiuse.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">Trova la corrispondenza di una o più occorrenze di una parentesi uncinata aperta seguita da zero o più caratteri diversi da parentesi uncinate aperte o chiuse.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">Equivale al secondo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Match a right angle bracket, assign the substring between the <ph id="ph1">`Open`</ph> group and the current group to the <ph id="ph2">`Close`</ph> group, and delete the definition of the <ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">Trova la corrispondenza di una parentesi uncinata chiusa, assegna la sottostringa tra il gruppo <ph id="ph1">`Open`</ph> e il gruppo corrente al gruppo <ph id="ph2">`Close`</ph> ed elimina la definizione del gruppo <ph id="ph3">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of any character that is neither a left nor a right angle bracket.</source>
          <target state="translated">Trova la corrispondenza di zero o più occorrenze di qualsiasi carattere diverso da parentesi uncinate aperte o chiuse.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</source>
          <target state="translated">Trova la corrispondenza di una o più occorrenze di una parentesi uncinata chiusa seguita da zero o più occorrenze di caratteri diversi da parentesi uncinate aperte o chiuse.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>When matching the right angle bracket, assign the substring between the <ph id="ph1">`Open`</ph> group and the current group to the <ph id="ph2">`Close`</ph> group, and delete the definition of the<ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">In caso di corrispondenza di una parentesi uncinata chiusa, assegna la sottostringa tra il gruppo <ph id="ph1">`Open`</ph> e il gruppo corrente al gruppo <ph id="ph2">`Close`</ph> ed elimina la definizione del gruppo <ph id="ph3">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>This is the third capturing group.</source>
          <target state="translated">Equivale al terzo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</source>
          <target state="translated">Trova la corrispondenza di zero o più occorrenze del criterio seguente: una o più occorrenze di una parentesi uncinata aperta seguite da zero o più parentesi uncinate, seguite da zero o più parentesi non uncinate, seguite da una o più occorrenze di parentesi uncinate chiuse, seguite da zero o più occorrenze di parentesi non uncinate.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>When matching the right angle bracket, delete the definition of the <ph id="ph1">`Open`</ph> group, and assign the substring between the <ph id="ph2">`Open`</ph> group and the current group to the <ph id="ph3">`Close`</ph> group.</source>
          <target state="translated">In caso di corrispondenza di una parentesi uncinata chiusa, elimina la definizione del gruppo <ph id="ph1">`Open`</ph> e assegna la sottostringa tra il gruppo <ph id="ph2">`Open`</ph> e il gruppo corrente al gruppo <ph id="ph3">`Close`</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Equivale al primo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Open`</ph> group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</source>
          <target state="translated">Se il gruppo <ph id="ph1">`Open`</ph> esiste, abbandona la corrispondenza se è possibile trovare una corrispondenza per una stringa vuota, ma non avanza la posizione del motore delle espressioni regolari nella stringa.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>This is a zero-width negative lookahead assertion.</source>
          <target state="translated">Si tratta di un'asserzione lookahead negativa di larghezza zero.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Because an empty string is always implicitly present in an input string, this match always fails.</source>
          <target state="translated">Poiché una stringa vuota è sempre presente in modo implicito in una stringa di input, questa corrispondenza ha sempre esito negativo.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Failure of this match indicates that the angle brackets are not balanced.</source>
          <target state="translated">L'esito negativo della corrispondenza indica che le parentesi uncinate non sono bilanciate.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Match the end of the input string.</source>
          <target state="translated">Trova la corrispondenza con la fine della stringa di input.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The final subexpression, <ph id="ph1">`(?(Open)(?!))`</ph>, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</source>
          <target state="translated">La sottoespressione finale, <ph id="ph1">`(?(Open)(?!))`</ph>, indica se i costrutti annidati nella stringa di input sono bilanciati correttamente, ad esempio se a ogni parentesi uncinata aperta corrisponde una parentesi uncinata chiusa.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>It uses conditional matching based on a valid captured group; for more information, see <bpt id="p1">[</bpt>Alternation constructs in regular expressions<ept id="p1">](alternation.md)</ept>.</source>
          <target state="translated">Usa la corrispondenza condizionale in base a un gruppo acquisito valido. Per altre informazioni, vedere <bpt id="p1">[</bpt>Costrutti di alternanza nelle espressioni regolari<ept id="p1">](alternation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Open`</ph> group is defined, the regular expression engine attempts to match the subexpression <ph id="ph2">`(?!)`</ph> in the input string.</source>
          <target state="translated">Se il gruppo <ph id="ph1">`Open`</ph> è definito, il motore delle espressioni regolari tenta di stabilire una corrispondenza con la sottoespressione <ph id="ph2">`(?!)`</ph> nella stringa di input.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group should be defined only if nesting constructs are unbalanced.</source>
          <target state="translated">Il gruppo <ph id="ph1">`Open`</ph> deve essere definito solo se i costrutti annidati non sono bilanciati.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</source>
          <target state="translated">Di conseguenza, il criterio per cui trovare la corrispondenza nella stringa di input deve essere inclusi tra quelli che determinano sempre un esito negativo della corrispondenza.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In this case, <ph id="ph1">`(?!)`</ph> is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</source>
          <target state="translated">In questo caso, <ph id="ph1">`(?!)`</ph> è un'asserzione lookahead negativa di larghezza zero che ha sempre esito negativo, in quanto una stringa vuota è sempre implicitamente presente nella posizione successiva nella stringa di input.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>In the example, the regular expression engine evaluates the input string "<ph id="ph1">&lt;abc&gt;</ph>&lt;mno<ph id="ph2">&lt;xyz&gt;</ph>&gt;" as shown in the following table.</source>
          <target state="translated">Nell'esempio, il motore delle espressioni regolari valuta la stringa di input "<ph id="ph1">&lt;abc&gt;</ph>&lt;mno<ph id="ph2">&lt;xyz&gt;</ph>&gt;", come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Step</source>
          <target state="translated">Passaggio</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Risultato</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Starts the match at the beginning of the input string</source>
          <target state="translated">Inizia la corrispondenza all'inizio della stringa di input.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters before the left angle bracket;finds no matches.</source>
          <target state="translated">Cerca parentesi non uncinate prima della parentesi uncinata aperta; non trova corrispondenze.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;abc&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">Trova la corrispondenza della parentesi uncinata aperta in "<ph id="ph1">&lt;abc&gt;</ph>" e la assegna al gruppo <ph id="ph2">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Matches "abc".</source>
          <target state="translated">Trova la corrispondenza con "abc".</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="translated">5</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>"&lt;abc" is the value of the second captured group.</source>
          <target state="translated">"&lt;abc" è il valore del secondo gruppo acquisito.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Il carattere successivo nella stringa di input non è una parentesi uncinata aperta, pertanto il motore delle espressioni regolari non esegue il loopback al criterio secondario <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>6</source>
          <target state="translated">6</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Matches the right angle bracket in "<ph id="ph1">&lt;abc&gt;</ph>", assigns "abc", which is the substring between the <ph id="ph2">`Open`</ph> group and the right angle bracket, to the <ph id="ph3">`Close`</ph> group, and deletes the current value ("&lt;") of the <ph id="ph4">`Open`</ph> group, leaving it empty.</source>
          <target state="translated">Trova la corrispondenza della parentesi uncinata chiusa in "<ph id="ph1">&lt;abc&gt;</ph>", assegna "abc", che è la sottostringa tra il gruppo <ph id="ph2">`Open`</ph> e la parentesi uncinata chiusa, al gruppo <ph id="ph3">`Close`</ph> ed elimina il valore corrente ("&lt;") del gruppo <ph id="ph4">`Open`</ph>, lasciandolo vuoto.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>7</source>
          <target state="translated">7</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters after the right angle bracket; finds no matches.</source>
          <target state="translated">Cerca parentesi non uncinate dopo la parentesi uncinata chiusa; non trova corrispondenze.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>8</source>
          <target state="translated">8</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">Il valore del terzo gruppo acquisito è "&gt;".</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Il carattere successivo nella stringa di input non è una parentesi uncinata chiusa, pertanto il motore delle espressioni regolari non esegue il loopback al criterio secondario <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>9</source>
          <target state="translated">9</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The value of the first captured group is "<ph id="ph1">&lt;abc&gt;</ph>".</source>
          <target state="translated">Il valore del primo gruppo acquisito è "<ph id="ph1">&lt;abc&gt;</ph>".</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The next character in the input string is a left angle bracket, so the regular expression engine loops back to the <ph id="ph1">`(((?'Open'&lt;)`</ph> subpattern.</source>
          <target state="translated">Il carattere successivo nella stringa di input è una parentesi uncinata aperta, pertanto il motore delle espressioni regolari esegue il loopback al criterio secondario <ph id="ph1">`(((?'Open'&lt;)`</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>10</source>
          <target state="translated">10</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;mno&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">Trova la corrispondenza della parentesi uncinata aperta in "<ph id="ph1">&lt;mno&gt;</ph>" e la assegna al gruppo <ph id="ph2">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`Group.Captures`</ph> collection now has a single value, "&lt;".</source>
          <target state="translated">Nella raccolta <ph id="ph1">`Group.Captures`</ph> è ora presente un solo valore, "&lt;".</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>11</source>
          <target state="translated">11</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Matches "mno".</source>
          <target state="translated">Trova la corrispondenza con "mno".</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>12</source>
          <target state="translated">12</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>"&lt;mno" is the value of the second captured group.</source>
          <target state="translated">"&lt;mno" è il valore del secondo gruppo acquisito.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The next character in the input string is an left angle bracket, so the regular expression engine loops back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Il carattere successivo nella stringa di input è una parentesi uncinata aperta, pertanto il motore delle espressioni regolari esegue il loopback al criterio secondario <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>13</source>
          <target state="translated">13</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;xyz&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">Trova la corrispondenza della parentesi uncinata aperta in "<ph id="ph1">&lt;xyz&gt;</ph>" e la assegna al gruppo <ph id="ph2">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Group.Captures`</ph> collection of the <ph id="ph2">`Open`</ph> group now includes two captures: the left angle bracket from "<ph id="ph3">&lt;mno&gt;</ph>", and the left angle bracket from "<ph id="ph4">&lt;xyz&gt;</ph>".</source>
          <target state="translated">Nella raccolta <ph id="ph1">`Group.Captures`</ph> del gruppo <ph id="ph2">`Open`</ph> sono ora incluse due acquisizioni: la parentesi uncinata aperta di "<ph id="ph3">&lt;mno&gt;</ph>" e la parentesi uncinata aperta di "<ph id="ph4">&lt;xyz&gt;</ph>".</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Matches "xyz".</source>
          <target state="translated">Trova la corrispondenza con "xyz".</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>"&lt;xyz" is the value of the second captured group.</source>
          <target state="translated">"&lt;xyz" è il valore del secondo gruppo acquisito.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Il carattere successivo nella stringa di input non è una parentesi uncinata aperta, pertanto il motore delle espressioni regolari non esegue il loopback al criterio secondario <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Matches the right angle bracket in "<ph id="ph1">&lt;xyz&gt;</ph>".</source>
          <target state="translated">Trova la corrispondenza della parentesi uncinata chiusa in "<ph id="ph1">&lt;xyz&gt;</ph>".</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>"xyz", assigns the substring between the <ph id="ph1">`Open`</ph> group and the right angle bracket to the <ph id="ph2">`Close`</ph> group, and deletes the current value of the <ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">"xyz", assegna la sottostringa tra il gruppo <ph id="ph1">`Open`</ph> e la parentesi uncinata chiusa al gruppo <ph id="ph2">`Close`</ph> ed elimina il valore corrente dal gruppo <ph id="ph3">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The value of the previous capture (the left angle bracket in "<ph id="ph1">&lt;mno&gt;</ph>") becomes the current value of the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">Il valore dell'acquisizione precedente (la parentesi uncinata aperta in "<ph id="ph1">&lt;mno&gt;</ph>") diventa il valore corrente del gruppo <ph id="ph2">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Captures`</ph> collection of the <ph id="ph2">`Open`</ph> group now includes a single capture, the left angle bracket from "<ph id="ph3">&lt;xyz&gt;</ph>".</source>
          <target state="translated">La raccolta <ph id="ph1">`Captures`</ph> del gruppo <ph id="ph2">`Open`</ph> include ora una sola acquisizione, ovvero la parentesi uncinata aperta di "<ph id="ph3">&lt;xyz&gt;</ph>".</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters; finds no matches.</source>
          <target state="translated">Cerca parentesi non uncinate; non trova corrispondenze.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">Il valore del terzo gruppo acquisito è "&gt;".</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The next character in the input string is a right angle bracket, so the regular expression engine loops back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Il carattere successivo nella stringa di input è una parentesi uncinata chiusa, pertanto il motore delle espressioni regolari esegue il loopback al criterio secondario <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Matches the final right angle bracket in "xyz&gt;&gt;", assigns "mno<ph id="ph1">&lt;xyz&gt;</ph>" (the substring between the <ph id="ph2">`Open`</ph> group and the right angle bracket) to the <ph id="ph3">`Close`</ph> group, and deletes the current value of the <ph id="ph4">`Open`</ph> group.</source>
          <target state="translated">Trova la corrispondenza della parentesi uncinata chiusa finale in "xyz&gt;&gt;", assegna "mno<ph id="ph1">&lt;xyz&gt;</ph>" (la sottostringa tra il gruppo <ph id="ph2">`Open`</ph> e la parentesi uncinata chiusa) al gruppo <ph id="ph3">`Close`</ph> ed elimina il valore corrente del gruppo <ph id="ph4">`Open`</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group is now empty.</source>
          <target state="translated">Il gruppo <ph id="ph1">`Open`</ph> è ora vuoto.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>20</source>
          <target state="translated">20</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters; finds no matches.</source>
          <target state="translated">Cerca parentesi non uncinate; non trova corrispondenze.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>21</source>
          <target state="translated">21</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">Il valore del terzo gruppo acquisito è "&gt;".</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Il carattere successivo nella stringa di input non è una parentesi uncinata chiusa, pertanto il motore delle espressioni regolari non esegue il loopback al criterio secondario <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>22</source>
          <target state="translated">22</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The value of the first captured group is "&lt;mno<ph id="ph1">&lt;xyz&gt;</ph>&gt;".</source>
          <target state="translated">Il valore del primo gruppo acquisito è "&lt;mno<ph id="ph1">&lt;xyz&gt;</ph>&gt;".</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(((?'Open'&lt;)`</ph> subpattern.</source>
          <target state="translated">Il carattere successivo nella stringa di input non è una parentesi uncinata aperta, pertanto il motore delle espressioni regolari non esegue il loopback al criterio secondario <ph id="ph1">`(((?'Open'&lt;)`</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>23</source>
          <target state="translated">23</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group is not defined, so no match is attempted.</source>
          <target state="translated">Il gruppo <ph id="ph1">`Open`</ph> non è definito, pertanto non viene tentato di trovare corrispondenze.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>24</source>
          <target state="translated">24</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Matches the end of the input string.</source>
          <target state="translated">Trova la corrispondenza della fine della stringa di input.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Noncapturing groups</source>
          <target state="translated">Gruppi di non acquisizione</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The following grouping construct does not capture the substring that is matched by a subexpression:</source>
          <target state="translated">Nel costrutto di raggruppamento seguente non viene acquisita la sottostringa quando viene trovata una corrispondenza con una sottoespressione:</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">dove <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> è un qualsiasi criterio di espressioni regolari valido.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</source>
          <target state="translated">Il costrutto del gruppo non di acquisizione viene generalmente usato quando un quantificatore è applicato a un gruppo, ma le sottostringhe acquisite dal gruppo non sono di alcun interesse.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
          <target state="translated">Se un'espressione regolare include costrutti di raggruppamento annidati, un costrutto del gruppo di non acquisizione esterno non si applica ai costrutti del gruppo annidati interni.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that includes noncapturing groups.</source>
          <target state="translated">Nell'esempio seguente viene illustrata un'espressione regolare che include gruppi di non acquisizione.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Note that the output does not include any captured groups.</source>
          <target state="translated">Si noti che nell'output non sono inclusi gruppi acquisiti.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`(?:\b(?:\w+)\W*)+\.`</ph> matches a sentence that is terminated by a period.</source>
          <target state="translated">L'espressione regolare <ph id="ph1">`(?:\b(?:\w+)\W*)+\.`</ph> trova la corrispondenza di una frase che termina con un punto.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</source>
          <target state="translated">Poiché l'espressione regolare si concentra sulle frasi e non sulle singole parole, i costrutti di raggruppamento vengono usati esclusivamente come quantificatori.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">Il criterio di ricerca di espressioni regolari viene interpretato come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Inizia la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Do not assign the matched text to a captured group.</source>
          <target state="translated">Non assegna il testo corrispondente a un gruppo acquisito.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Match zero or more non-word characters.</source>
          <target state="translated">Trova la corrispondenza di zero o più caratteri non alfanumerici.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</source>
          <target state="translated">Trova la corrispondenza con il criterio di ricerca di uno o più caratteri alfanumerici a partire dal confine di una parola, seguiti da zero o più caratteri non alfanumerici, una o più volte.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Do not assign the matched text to a captured group.</source>
          <target state="translated">Non assegna il testo corrispondente a un gruppo acquisito.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Match a period.</source>
          <target state="translated">Trova la corrispondenza con un punto.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Group options</source>
          <target state="translated">Opzioni di gruppo</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The following grouping construct applies or disables the specified options within a subexpression:</source>
          <target state="translated">Il costrutto di raggruppamento applica o disabilita le opzioni specificate all'interno di una sottoespressione:</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">dove <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> è un qualsiasi criterio di espressioni regolari valido.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`(?i-s:)`</ph> turns on case insensitivity and disables single-line mode.</source>
          <target state="translated">Ad esempio, <ph id="ph1">`(?i-s:)`</ph> disattiva la differenziazione tra maiuscole e minuscole e disabilita la modalità riga singola.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>For more information about the inline options you can specify, see <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">Per altre informazioni sulle opzioni inline che è possibile specificare, vedere <bpt id="p1">[</bpt>Opzioni di espressioni regolari<ept id="p1">](options.md)</ept>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>You can specify options that apply to an entire regular expression rather than a subexpression by using a <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or a static method.</source>
          <target state="translated">È possibile specificare opzioni che si applicano a un'espressione regolare intera anziché a una sottoespressione usando un costruttore della classe <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> o un metodo statico.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>You can also specify inline options that apply after a specific point in a regular expression by using the <ph id="ph1">`(?imnsx-imnsx)`</ph> language construct.</source>
          <target state="translated">È possibile specificare anche opzioni inline che si applicano dopo un punto specifico in un'espressione regolare usando il costrutto di linguaggio <ph id="ph1">`(?imnsx-imnsx)`</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The group options construct is not a capturing group.</source>
          <target state="translated">Il costrutto delle opzioni di gruppo non è un gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>That is, although any portion of a string that is captured by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is included in the match, it is not included in a captured group nor used to populate the <bpt id="p2">[</bpt>GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object.</source>
          <target state="translated">Sebbene qualsiasi parte di una stringa acquisita dalla <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> sia inclusa nella corrispondenza, non viene inclusa in un gruppo acquisito né usata per popolare l'oggetto <bpt id="p2">[</bpt>GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b(?ix: d \w+)\s `</ph>in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern whitespace in identifying all words that begin with the letter "d".</source>
          <target state="translated">Ad esempio, l'espressione regolare <ph id="ph1">`\b(?ix: d \w+)\s `</ph> nell'esempio seguente usa le opzioni inline in un costrutto di raggruppamento per abilitare la corrispondenza tra maiuscole e minuscole e per ignorare gli spazi vuoti nel criterio durante l'identificazione delle parole che iniziano con la lettera "d".</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>The regular expression is defined as shown in the following table.</source>
          <target state="translated">L'espressione regolare è definita nel modo illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Inizia la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</source>
          <target state="translated">Usando la corrispondenza senza distinzione tra maiuscole e minuscole e ignorando lo spazio vuoto in questo criterio, trova la corrispondenza con una "d" seguita da uno o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Trova la corrispondenza con uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookahead assertions</source>
          <target state="translated">Asserzioni lookahead positive di larghezza zero</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width positive lookahead assertion:</source>
          <target state="translated">Il costrutto di raggruppamento seguente definisce un'asserzione lookbehind positiva di larghezza zero:</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><bpt id="p3">__</bpt>)<ept id="p3">__</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">*</bpt>sottoespressione<ept id="p2">*</ept><bpt id="p3">__</bpt>)<ept id="p3">__</ept></target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">dove <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> è un qualsiasi criterio di espressioni regolari.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>For a match to be successful, the input string must match the regular expression pattern in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, although the matched substring is not included in the match result.</source>
          <target state="translated">Per trovare una corrispondenza, la stringa di input deve corrispondere al criterio di espressioni regolari in <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept>, sebbene la sottostringa corrispondente non venga inclusa nel risultato della corrispondenza.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookahead assertion does not backtrack.</source>
          <target state="translated">Un'asserzione lookahead positiva di larghezza zero non esegue il backtracking.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</source>
          <target state="translated">In genere, un'asserzione lookahead positiva di larghezza zero viene trovata alla fine di un criterio di ricerca di espressioni regolari</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</source>
          <target state="translated">Definisce una sottostringa che deve essere trovata alla fine di una stringa affinché venga stabilita una corrispondenza ma che non deve essere inclusa nella corrispondenza.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>It is also useful for preventing excessive backtracking.</source>
          <target state="translated">È anche utile per impedire un backtracking eccessivo.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</source>
          <target state="translated">È possibile usare un'asserzione lookahead positiva di larghezza zero per assicurarsi che un particolare gruppo acquisito inizi con il testo che corrisponde a un subset del criterio definito per tale gruppo acquisito.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</source>
          <target state="translated">Se, ad esempio, viene trovata la corrispondenza di un gruppo di acquisizioni con caratteri alfanumerici consecutivi, è possibile usare un'asserzione positiva lookahead di larghezza zero per richiedere che il primo carattere sia un carattere alfabetico maiuscolo.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</source>
          <target state="translated">Nell'esempio seguente viene usata un'asserzione lookahead positiva di larghezza zero per trovare la corrispondenza con la parola che precede il verbo "is" nella stringa di input.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>The regular expression \b\w+(?=\sis\b) is interpreted as shown in the following table.</source>
          <target state="translated">L'espressione regolare \b\w+(?=\sis\b) viene interpretata nel modo illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Inizia la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</source>
          <target state="translated">Determina se i caratteri alfanumerici vengono seguiti da uno spazio vuoto e dalla stringa "is", che termina su un confine di parola.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>If so, the match is successful.</source>
          <target state="translated">In tal caso, la corrispondenza ha esito positivo.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookahead assertions</source>
          <target state="translated">Asserzioni lookahead negative di larghezza zero</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width negative lookahead assertion:</source>
          <target state="translated">Nel costrutto di raggruppamento seguente viene definita un'asserzione lookahead negativa di larghezza zero:</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">dove <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> è un qualsiasi criterio di espressioni regolari.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For the match to be successful, the input string must not match the regular expression pattern in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, although the matched string is not included in the match result.</source>
          <target state="translated">Per trovare una corrispondenza, la stringa di input non deve corrispondere al criterio di espressioni regolari in <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept>, sebbene la stringa corrispondente non venga inclusa nel risultato della corrispondenza.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</source>
          <target state="translated">Un'asserzione lookahead negativa di larghezza zero viene usata in genere all'inizio o alla fine di un'espressione regolare.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</source>
          <target state="translated">All'inizio di un'espressione regolare, può definire un criterio specifico per il quale non deve essere trovata una corrispondenza quando l'inizio dell'espressione regolare definisce un criterio simile ma più generale per cui stabilire la corrispondenza.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>In this case, it is often used to limit backtracking.</source>
          <target state="translated">In questo caso, viene spesso usata per limitare il backtracking.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
          <target state="translated">Alla fine di un'espressione regolare, può definire una sottoespressione che non può verificarsi alla fine di una corrispondenza.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</source>
          <target state="translated">Nell'esempio seguente viene definita un'espressione regolare che usa un'asserzione lookahead di larghezza zero all'inizio dell'espressione regolare per trovare la corrispondenza con parole che non iniziano con "un".</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The regular expression \b(?!un)\w+\b is interpreted as shown in the following table.</source>
          <target state="translated">L'espressione regolare \b(?!un)\w+\b viene interpretata nel modo illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Inizia la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Determine whether the next two characters are "un".</source>
          <target state="translated">Determina se i due caratteri successivi sono "un".</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>If they are not, a match is possible.</source>
          <target state="translated">Se non lo sono, è possibile stabilire la corrispondenza.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Termina la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</source>
          <target state="translated">Nell'esempio seguente viene definita un'espressione regolare che usa un'asserzione lookahead di larghezza zero alla fine dell'espressione regolare per trovare la corrispondenza con parole che non terminano con un carattere di punteggiatura.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b\w+\b(?!\p{P})`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">L'espressione regolare <ph id="ph1">`\b\w+\b(?!\p{P})`</ph> viene interpretata come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Inizia la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Termina la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</source>
          <target state="translated">Se il carattere successivo non è un simbolo di punteggiatura (quale un punto o una virgola), la corrispondenza ha esito positivo.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions</source>
          <target state="translated">Asserzioni lookbehind positive di larghezza zero</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width positive lookbehind assertion:</source>
          <target state="translated">Nel costrutto di raggruppamento seguente viene definita un'asserzione lookbehind positiva di larghezza zero:</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;=<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;=<ept id="p1">**</ept><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">dove <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> è un qualsiasi criterio di espressioni regolari.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>For a match to be successful, <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> must occur at the input string to the left of the current position, although subexpression is not included in the match result.</source>
          <target state="translated">Per trovare una corrispondenza, <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> deve trovarsi nella stringa di input a sinistra della posizione corrente, sebbene la sottoespressione non venga inclusa nel risultato della corrispondenza.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookbehind assertion does not backtrack.</source>
          <target state="translated">Un'asserzione lookbehind positiva di larghezza zero non esegue il backtracking.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</source>
          <target state="translated">Le asserzioni lookbehind positive di larghezza zero vengono usate in genere all'inizio delle espressioni regolari.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
          <target state="translated">Il criterio definito è una precondizione per una corrispondenza, anche se non fa parte del risultato della corrispondenza.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</source>
          <target state="translated">Ad esempio, nell'esempio seguente viene cercata la corrispondenza con le ultime due cifre dell'anno per il ventunesimo secolo ovvero, richiede che la cifra "20" preceda la stringa corrispondente.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(?&lt;=\b20)\d{2}\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Il criterio di ricerca di espressioni regolari <ph id="ph1">`(?&lt;=\b20)\d{2}\b`</ph> è interpretato nel modo illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>Match two decimal digits.</source>
          <target state="translated">Trova la corrispondenza con due cifre decimali.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</source>
          <target state="translated">Continua la corrispondenza per verificare se le due cifre decimali sono precedute dalle cifre decimali "20" su un confine di parola.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Termina la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</source>
          <target state="translated">Le asserzioni lookbehind positive di larghezza zero vengono usate anche per limitare il backtracking quando l'ultimo carattere o gli ultimi caratteri in un gruppo acquisito devono essere costituiti da un subset di caratteri corrispondenti al criterio di ricerca di espressioni regolari di tale gruppo.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</source>
          <target state="translated">Se, ad esempio, un gruppo acquisisce tutti i caratteri alfanumerici consecutivi, è possibile usare un'asserzione positiva lookbehind di larghezza zero per richiedere che l'ultimo carattere sia un carattere alfabetico.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind assertions</source>
          <target state="translated">Asserzioni lookbehind negative di larghezza zero</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width negative lookbehind assertion:</source>
          <target state="translated">Nel costrutto di raggruppamento seguente viene definita un'asserzione lookbehind negativa di larghezza zero:</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">dove <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> è un qualsiasi criterio di espressioni regolari.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>For a match to be successful, <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> must not occur at the input string to the left of the current position.</source>
          <target state="translated">Per trovare una corrispondenza, <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> non deve trovarsi nella stringa di input a sinistra della posizione corrente.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>However, any substring that does not match subexpression is not included in the match result.</source>
          <target state="translated">Tuttavia, qualsiasi sottostringa che non corrisponde a sottoespressione non viene inclusa nel risultato della corrispondenza.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</source>
          <target state="translated">Le asserzioni lookbehind negative di larghezza zero vengono usate in genere all'inizio delle espressioni regolari.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>The pattern that they define precludes a match in the string that follows.</source>
          <target state="translated">Il criterio definito preclude una corrispondenza nella stringa che segue.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</source>
          <target state="translated">Queste asserzioni vengono usate anche per limitare il backtracking quando l'ultimo carattere o gli ultimi caratteri in un gruppo acquisito non devono essere costituiti da uno o più caratteri corrispondenti al criterio di ricerca di espressioni regolari di tale gruppo.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (_).</source>
          <target state="translated">Se, ad esempio, un gruppo acquisisce tutti i caratteri alfanumerici consecutivi, è possibile usare un'asserzione positiva lookbehind di larghezza zero per richiedere che l'ultimo carattere non sia un carattere di sottolineatura (_).</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</source>
          <target state="translated">Nell'esempio seguente viene cercata la corrispondenza della data per qualsiasi giorno della settimana diverso da un fine settimana (ovvero, che non è né sabato né domenica).</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(?&lt;!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Il criterio di ricerca di espressioni regolari <ph id="ph1">`(?&lt;!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b`</ph> è interpretato nel modo illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Inizia la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a white-space character.</source>
          <target state="translated">Trova la corrispondenza con uno o più caratteri alfanumerici seguiti da uno spazio vuoto.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Match either one or two decimal digits followed by a white-space character and a comma.</source>
          <target state="translated">Trova la corrispondenza con una o due cifre digitali seguite da uno spazio vuoto e da una virgola.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Match four decimal digits, and end the match at a word boundary.</source>
          <target state="translated">Trova la corrispondenza di quattro cifre digitali e termina la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>`(?&lt;!(Saturday</source>
          <target state="translated">'(?&lt;! (Sabato</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Sunday) )`</source>
          <target state="translated">Domenica) )'</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</source>
          <target state="translated">Se la corrispondenza viene preceduta da un elemento diverso dalle stringhe "Saturday" o "Sunday" seguito da uno spazio, la corrispondenza ha esito positivo.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpressions</source>
          <target state="translated">Sottoespressioni di non backtracking</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</source>
          <target state="translated">Nel costrutto di raggruppamento seguente viene rappresentata una sottoespressione di non backtracking (nota anche come sottoespressione "greedy"):</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">dove <bpt id="p1">*</bpt>sottoespressione<ept id="p1">*</ept> è un qualsiasi criterio di espressioni regolari.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</source>
          <target state="translated">Normalmente, se un'espressione regolare include un criterio di ricerca facoltativo o alternativo e una corrispondenza ha esito negativo, il motore delle espressioni regolari può creare un ramo in più direzioni per trovare la corrispondenza di una stringa di input con un criterio.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</source>
          <target state="translated">Se non viene trovata una corrispondenza quando viene esaminato il primo ramo, il motore delle espressioni regolari può tornare, o eseguire il backtracking, al punto in cui ha trovato la prima corrispondenza e tenta la corrispondenza usando il secondo ramo.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>This process can continue until all branches have been tried.</source>
          <target state="translated">Questo processo può continuare fino a che non sono stati provati tutti i rami.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language construct disables backtracking.</source>
          <target state="translated">Il costrutto di linguaggio <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> disabilita il backtracking.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>The regular expression engine will match as many characters in the input string as it can.</source>
          <target state="translated">Il motore delle espressioni regolari troverà la corrispondenza con il numero massimo possibile di caratteri nella stringa di input.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>When no further match is possible, it will not backtrack to attempt alternate pattern matches.</source>
          <target state="translated">Quando non sarà più possibile trovare altre corrispondenze, non eseguirà il backtracking per trovare corrispondenze alternative con i criteri.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</source>
          <target state="translated">Viene pertanto trovata la corrispondenza della sottoespressione solo con stringhe corrispondenti esclusivamente alla sottoespressione; non tenta di trovare una corrispondenza per una stringa in base alla sottoespressione e a qualsiasi sottoespressione successiva.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>This option is recommended if you know that backtracking will not succeed.</source>
          <target state="translated">Questa opzione è consigliata solo se si è certi che il backtracking avrà esito negativo.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>Preventing the regular expression engine from performing unnecessary searching improves performance.</source>
          <target state="translated">Impedendo al motore delle espressioni regolari di eseguire ricerche non necessarie si registra un miglioramento delle prestazioni.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come una sottoespressione di non backtracking modifica i risultati dei criteri di ricerca.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</source>
          <target state="translated">L'espressione regolare di backtracking trova una corrispondenza per una serie di caratteri ripetuti seguiti da una o più occorrenze dello stesso carattere su un confine di parola, diversamente dall'espressione regolare di non backtracking.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>The nonbacktracking regular expression <ph id="ph1">`(?&gt;(\w)\1+).\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">L'espressione regolare di non backtracking <ph id="ph1">`(?&gt;(\w)\1+).\b`</ph> è definita nel modo illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Match a single word character and assign it to the first capturing group.</source>
          <target state="translated">Trova la corrispondenza di un singolo carattere alfanumerico e la assegna al primo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Match the value of the first captured substring one or more times.</source>
          <target state="translated">Trova la corrispondenza con il valore della prima sottostringa acquisita una o più volte.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>Match any character.</source>
          <target state="translated">Trova la corrispondenza con qualsiasi carattere.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>End the match on a word boundary.</source>
          <target state="translated">Termina la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</source>
          <target state="translated">Trova una o più occorrenze di un carattere alfanumerico duplicato ma non esegue il backtracking per trovare la corrispondenza con l'ultimo carattere su un confine di parola.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Grouping constructs and regular expression objects</source>
          <target state="translated">Costrutti di raggruppamento e oggetti di espressione regolare</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Substrings that are matched by a regular expression capturing group are represented by <bpt id="p1">[</bpt>System.Text.RegularExpressions.Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects, which can be retrieved from the <bpt id="p2">[</bpt>System.Text.RegularExpressions.GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object that is returned by the <bpt id="p3">[</bpt>Match.Groups<ept id="p3">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">Le sottostringhe corrispondenti a un gruppo di acquisizione di espressioni regolari sono rappresentate da oggetti <bpt id="p1">[</bpt>System.Text.RegularExpressions.Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>, che possono essere recuperati dall'oggetto <bpt id="p2">[</bpt>System.Text.RegularExpressions.GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> restituito dalla proprietà <bpt id="p3">[</bpt>Match.Groups<ept id="p3">](xref:System.Text.RegularExpressions.Match.Groups)</ept>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object is populated as follows:</source>
          <target state="translated">L'oggetto <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> è popolato nel modo seguente:</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>The first <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object in the collection (the object at index zero) represents the entire match.</source>
          <target state="translated">Il primo oggetto <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> della raccolta (in corrispondenza dell'indice zero) rappresenta l'intera corrispondenza.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>The next set of <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects represent unnamed (numbered) capturing groups.</source>
          <target state="translated">Il set di oggetti <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> successivo rappresenta i gruppi di acquisizione non denominati (numerati).</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>They appear in the order in which they are defined in the regular expression, from left to right.</source>
          <target state="translated">Vengono visualizzati nell'ordine in cui sono definiti nell'espressione regolare, da sinistra a destra.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</source>
          <target state="translated">I valori di indice di questi gruppi sono compresi tra 1 e il numero dei gruppi di acquisizione non denominati nella raccolta.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>(The index of a particular group is equivalent to its numbered backreference.</source>
          <target state="translated">L'indice di un gruppo specifico è equivalente al relativo backreference numerato.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>For more information about backreferences, see <bpt id="p1">[</bpt>Backreference constructs in regular expressions<ept id="p1">](backreference.md)</ept></source>
          <target state="translated">Per altre informazioni sui backreference, vedere <bpt id="p1">[</bpt>Costrutti di backreference nelle espressioni regolari<ept id="p1">](backreference.md)</ept></target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>The final set of <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects represent named capturing groups.</source>
          <target state="translated">Il set di oggetti <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> finale rappresenta i gruppi di acquisizione denominati.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>They appear in the order in which they are defined in the regular expression, from left to right.</source>
          <target state="translated">Vengono visualizzati nell'ordine in cui sono definiti nell'espressione regolare, da sinistra a destra.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</source>
          <target state="translated">Il valore di indice del primo gruppo di acquisizione denominato è maggiore di uno rispetto all'ultimo gruppo di acquisizione non denominato.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</source>
          <target state="translated">Se l'espressione regolare non contiene gruppi di acquisizione non denominati, il valore di indice del primo gruppo di acquisizione denominato è uno.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>If you apply a quantifier to a capturing group, the corresponding <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object's <bpt id="p2">[</bpt>Capture.Value<ept id="p2">](xref:System.Text.RegularExpressions.Capture.Value)</ept>, <bpt id="p3">[</bpt>Capture.Index<ept id="p3">](xref:System.Text.RegularExpressions.Capture.Index)</ept>, and <bpt id="p4">[</bpt>Capture.Length<ept id="p4">](xref:System.Text.RegularExpressions.Capture.Length)</ept> properties reflect the last substring that is captured by a capturing group.</source>
          <target state="translated">Se si applica un quantificatore a un gruppo di acquisizione, le proprietà <bpt id="p2">[</bpt>Capture.Value<ept id="p2">](xref:System.Text.RegularExpressions.Capture.Value)</ept>, <bpt id="p3">[</bpt>Capture.Index<ept id="p3">](xref:System.Text.RegularExpressions.Capture.Index)</ept> e <bpt id="p4">[</bpt>Capture.Length<ept id="p4">](xref:System.Text.RegularExpressions.Capture.Length)</ept> dell'oggetto <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> corrispondente riflettono l'ultima sottostringa acquisita da un gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object that is returned by the <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property.</source>
          <target state="translated">È possibile recuperare un set completo di sottostringhe acquisite da gruppi che hanno quantificatori dall'oggetto <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> restituito dalla proprietà <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>The following example clarifies the relationship between the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> and <bpt id="p2">[</bpt>Capture<ept id="p2">](xref:System.Text.RegularExpressions.Capture)</ept> objects.</source>
          <target state="translated">Nell'esempio seguente viene illustrata la relazione tra gli oggetti <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> e <bpt id="p2">[</bpt>Capture<ept id="p2">](xref:System.Text.RegularExpressions.Capture)</ept>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(\w+)\W+)+`</ph> extracts individual words from a string.</source>
          <target state="translated">Il criterio di ricerca di espressioni regolari <ph id="ph1">`\b(\w+)\W+)+`</ph> estrae singole parole da una stringa</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
          <target state="translated">e viene definito come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Inizia la corrispondenza sul confine di parola.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri alfanumerici.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Together, these characters form a word.</source>
          <target state="translated">Insieme, questi caratteri formano una parola.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">Equivale al secondo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>Match one or more non-word characters.</source>
          <target state="translated">Trova la corrispondenza di uno o più caratteri non alfanumerici.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</source>
          <target state="translated">Trova la corrispondenza con il criterio di uno o più caratteri alfanumerici seguiti da uno o più caratteri non alfanumerici, una o più volte.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Equivale al primo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The first capturing group matches each word of the sentence.</source>
          <target state="translated">Il primo gruppo di acquisizione trova la corrispondenza per ogni parola della frase.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>The second capturing group matches each word along with the punctuation and white space that follow the word.</source>
          <target state="translated">Il secondo gruppo di acquisizione trova la corrispondenza per ogni parola insieme alla punteggiatura e allo spazio vuoto che seguono la parola.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object whose index is 2 provides information about the text matched by the second capturing group.</source>
          <target state="translated">L'oggetto <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> il cui indice è 2 offre informazioni sul testo corrispondente in base al secondo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The complete set of words captured by the capturing group are available from the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object returned by the <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property.</source>
          <target state="translated">Il set completo di parole acquisite dal gruppo di acquisizione è disponibile dall'oggetto <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> restituito dalla proprietà <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Vedere anche</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Linguaggio di espressioni regolari - Riferimento rapido<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking in regular expressions<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Backtracking nelle espressioni regolari<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>