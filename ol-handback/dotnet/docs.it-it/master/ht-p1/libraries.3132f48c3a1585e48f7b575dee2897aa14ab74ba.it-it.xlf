<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">503cf3628ee317f701f467bddc4bcb5998b82af4</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\porting\libraries.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b743c7373958ab8c3c389d1e913a132f6b59f512</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ce6b4b0287e09e26cac417d6679fc5bdee3716e0</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Porting to .NET Core - Libraries</source>
          <target state="translated">Portabilità in .NET Core - Librerie</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Porting to .NET Core - Libraries</source>
          <target state="translated">Portabilità in .NET Core - Librerie</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Porting to .NET Core - Libraries</source>
          <target state="translated">Portabilità in .NET Core - Librerie</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>With the release of .NET Core 1.0, there is an opportunity to port existing library code so that it can run cross-platform.</source>
          <target state="translated">Con la versione di .NET Core 1.0 è possibile trasferire il codice di libreria esistente per consentirne l'esecuzione su più piattaforme.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This article discusses the .NET Standard Library, unavailable technologies, how to account for the smaller number of APIs available on .NET Core 1.0, how to use the tooling that ships with .NET Core SDK Preview 2, and recommended approaches to porting your code.</source>
          <target state="translated">Questo articolo descrive la libreria .NET Standard e le tecnologie non disponibili. Spiega inoltre come tener conto del minor numero possibile di API disponibili in .NET Core 1.0 e come usare gli strumenti forniti con .NET Core SDK Preview 2. Illustra infine gli approcci consigliati per il trasferimento del codice.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Porting is a task that may take time, especially if you have a large codebase.</source>
          <target state="translated">Il trasferimento è un'attività che può richiedere diverso tempo, in particolare se si dispone di una CodeBase di grandi dimensioni.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You should also be prepared to adapt the guidance here as needed to best fit your code.</source>
          <target state="translated">È inoltre consigliabile essere pronti ad adattare le indicazioni fornite secondo quanto necessario per il proprio codice.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Every codebase is different, so this article attempts to frame things in a flexible way, but you may find yourself needing to diverge from the prescribed guidance.</source>
          <target state="translated">Ogni CodeBase è differente, motivo per cui questo articolo tenta di spiegare i concetti in modo flessibile. È tuttavia possibile che, in base alle specifiche esigenze, sia necessario scostarsi dalle linee guida offerte.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">Prerequisiti</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This article assumes you are using Visual Studio 2015 or later on Windows.</source>
          <target state="translated">Questo articolo presuppone l'uso di Visual Studio 2015 o versione successiva in Windows.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The bits required for building .NET Core code are not available on previous versions of Visual Studio.</source>
          <target state="translated">I componenti necessari per la compilazione del codice .NET Core non sono disponibili nelle precedenti versioni di Visual Studio.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This article also assumes that you understand the <bpt id="p1">[</bpt>recommended porting process<ept id="p1">](index.md)</ept> and that you have resolved any issues with <bpt id="p2">[</bpt>third-party dependencies<ept id="p2">](third-party-deps.md)</ept>.</source>
          <target state="translated">Questo articolo presuppone inoltre che l'utente abbia compreso il <bpt id="p1">[</bpt>processo di trasferimento consigliato<ept id="p1">](index.md)</ept> e che abbia risolto qualsiasi problema relativo a <bpt id="p2">[</bpt>dipendenze di terze parti<ept id="p2">](third-party-deps.md)</ept>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Targeting the .NET Standard Library</source>
          <target state="translated">Definizione della libreria .NET Standard come destinazione</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The best way to build a cross-platform library for .NET Core is to target the <bpt id="p1">[</bpt>.NET Standard Library<ept id="p1">](../../standard/library.md)</ept>.</source>
          <target state="translated">Il modo migliore per creare una libreria multipiattaforma per .NET Core è definire la <bpt id="p1">[</bpt>libreria .NET Standard<ept id="p1">](../../standard/library.md)</ept> come destinazione.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The .NET Standard Library is the formal specification of .NET APIs that are intended to be available on all .NET runtimes.</source>
          <target state="translated">La libreria .NET Standard è la specifica formale delle API .NET che devono essere disponibili in tutti i runtime .NET.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>It is supported by the .NET Core runtime.</source>
          <target state="translated">È supportata dal runtime di .NET Core.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>What this means is that you'll have to make a tradeoff between APIs you can use and platforms you can support, and pick the version of the .NET Platform Standard that best suits the tradeoff you wish to make.</source>
          <target state="translated">Questo significa che sarà necessario trovare un compromesso tra le API che è possibile usare e le piattaforme che è possibile supportare, scegliendo la versione della piattaforma standard .NET più adatta al compromesso scelto.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>As of right now, there are 7 different versions to consider: .NET Standard 1.0 through 1.6.</source>
          <target state="translated">Al momento sono disponibili sette differenti versioni, da .NET Standard 1.0 a .NET Standard 1.6.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>If you pick a higher version, you get access to more APIs at the cost of running on fewer targets.</source>
          <target state="translated">Se si sceglie una versione più recente, si ha accesso a un numero più alto di API, ma con la possibilità di eseguire il codice su un numero minore di destinazioni.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If you pick a lower version, your code can run on more targets but at the cost of fewer APIs available to you.</source>
          <target state="translated">Se invece si sceglie una versione meno recente, è possibile eseguire il codice su un numero maggiore di destinazioni, ma con conseguente riduzione del numero di API disponibili.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For your convenience, here is a matrix of each .NET Standard version and each specific area it runs on:</source>
          <target state="translated">Per praticità, di seguito è riportata una matrice con le diverse versioni di .NET Standard e le relative aree di esecuzione:</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Platform Name</source>
          <target state="translated">Nome della piattaforma</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>.NET Standard</source>
          <target state="translated">.NET Standard</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>netstandard</source>
          <target state="translated">netstandard</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>1.0</source>
          <target state="translated">1.0</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>1.1</source>
          <target state="translated">1.1</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>1.2</source>
          <target state="translated">1.2</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>1.3</source>
          <target state="translated">1.3</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>1.4</source>
          <target state="translated">1.4</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>1.5</source>
          <target state="translated">1,5</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>1.6</source>
          <target state="translated">1.6</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>.NET Core</source>
          <target state="translated">.NET Core</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>netcoreapp</source>
          <target state="translated">netcoreapp</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>1.0</source>
          <target state="translated">1.0</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>.NET Framework</source>
          <target state="translated">.NET Framework</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>net</source>
          <target state="translated">net</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>4.5</source>
          <target state="translated">4.5</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>4.5.1</source>
          <target state="translated">4.5.1</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>4.6</source>
          <target state="translated">4.6</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>4.6.1</source>
          <target state="translated">4.6.1</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>4.6.2</source>
          <target state="translated">4.6.2</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>4.6.3</source>
          <target state="translated">4.6.3</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Mono/Xamarin Platforms</source>
          <target state="translated">Piattaforme Mono/Xamarin</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Universal Windows Platform</source>
          <target state="translated">Piattaforma UWP (Universal Windows Platform)</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>uap</source>
          <target state="translated">uap</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>10.0</source>
          <target state="translated">10.0</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>win</source>
          <target state="translated">win</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>8.0</source>
          <target state="translated">8.0</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>8.1</source>
          <target state="translated">8.1</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Windows Phone</source>
          <target state="translated">Windows Phone</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>wpa</source>
          <target state="translated">wpa</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>8.1</source>
          <target state="translated">8.1</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Windows Phone Silverlight</source>
          <target state="translated">Silverlight per Windows Phone</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>wp</source>
          <target state="translated">wp</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>8.0</source>
          <target state="translated">8.0</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A key thing to understand is that <bpt id="p1">**</bpt>a project targeting a lower version cannot reference a project targeting a higher version<ept id="p1">**</ept>.</source>
          <target state="translated">Un fattore chiave da comprendere è che <bpt id="p1">**</bpt>un progetto che ha come destinazione una versione meno recente non può fare riferimento a un progetto che ha come destinazione una versione più recente<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, a project targeting the .NET Platform Standard version 1.2 cannot reference projects that target .NET Platform Standard version 1.3 or higher.</source>
          <target state="translated">Ad esempio, un progetto che ha come destinazione la piattaforma standard .NET versione 1.2 non può fare riferimento a progetti che hanno come destinazione la piattaforma standard .NET versione 1.3 o successiva.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Projects <bpt id="p1">**</bpt>can<ept id="p1">**</ept> reference lower versions, though, so a project targeting .NET Platform Standard 1.3 can reference a project targeting .NET Platform Standard 1.2 or lower.</source>
          <target state="translated">I progetti, tuttavia, <bpt id="p1">**</bpt>possono<ept id="p1">**</ept> fare riferimento a versioni meno recenti: un progetto che ha come destinazione la piattaforma standard .NET versione 1.3 può fare riferimento a un progetto che ha come destinazione la piattaforma standard .NET versione 1.2 o precedente.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>It's recommended that you pick the lowest possible .NET Standard version and use that throughout your project.</source>
          <target state="translated">È consigliabile scegliere la versione della piattaforma standard .NET meno recente e usarla in tutto il progetto.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Read more in <bpt id="p1">[</bpt>.NET Platform Standard Library<ept id="p1">](../../standard/library.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>.NET Platform Standard Library<ept id="p1">](../../standard/library.md)</ept> (Libreria della piattaforma standard .NET).</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Key Technologies Not Yet Available on the .NET Standard or .NET Core</source>
          <target state="translated">Tecnologie chiave non ancora disponibili in .NET Standard o .NET Core</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>You may be using some technologies available for the .NET Framework that are not currently available for .NET Core.</source>
          <target state="translated">È possibile che gli utenti usino tecnologie disponibili per .NET Framework che però non sono attualmente disponibili per .NET Core.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Each of the following sub-sections corresponds to one of those technologies.</source>
          <target state="translated">Ciascuna delle sottosezioni seguenti corrisponde a una di queste tecnologie.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Alternative options are listed if it is feasible for you to adopt them.</source>
          <target state="translated">Vengono inoltre elencate opzioni alternative eventualmente adottabili.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>App Domains</source>
          <target state="translated">Domini app</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>AppDomains can be used for different purposes on the .NET Framework.</source>
          <target state="translated">È possibile usare Domini app per diverse finalità all'interno di .NET Framework.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For code isolation, we recommend separate processes and/or containers as an alternative.</source>
          <target state="translated">Per l'isolamento del codice, è consigliabile usare come alternativa processi e/o contenitori separati.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For dynamic loading of assemblies, we recommend the new  <ph id="ph1">@System.Runtime.Loader.AssemblyLoadContext</ph> class.</source>
          <target state="translated">Per il caricamento dinamico di assembly, è consigliabile la nuova classe <ph id="ph1">@System.Runtime.Loader.AssemblyLoadContext</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Remoting</source>
          <target state="translated">Servizi remoti</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For communication across processes, inter-process communication (IPC) mechanisms can be used as an alternative to Remoting, such as <bpt id="p1">[</bpt>Pipes<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/system.io.pipes)</ept> or <bpt id="p2">[</bpt>Memory Mapped Files<ept id="p2">](https://docs.microsoft.com/dotnet/core/api/system.io.memorymappedfiles.memorymappedfile)</ept>.</source>
          <target state="translated">Per la comunicazione tra processi, è possibile usare il meccanismo IPC (Inter-Process Communication) in alterativa alla comunicazione remota, ad esempio <bpt id="p1">[</bpt>pipe<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/system.io.pipes)</ept> o <bpt id="p2">[</bpt>file mappati alla memoria<ept id="p2">](https://docs.microsoft.com/dotnet/core/api/system.io.memorymappedfiles.memorymappedfile)</ept>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Across machines, you can use a network based solution as an alternative, preferably a low-overhead plain text protocol such as HTTP.</source>
          <target state="translated">Per la comunicazione tra computer è possibile usare come alternativa una soluzione di rete, ad esempio un protocollo in testo normale con sovraccarico ridotto quale HTTP.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>KestrelHttpServer<ept id="p1">](https://github.com/aspnet/KestrelHttpServer)</ept>, the web server used by ASP.NET Core, is an option here.</source>
          <target state="translated"><bpt id="p1">[</bpt>KestrelHttpServer<ept id="p1">](https://github.com/aspnet/KestrelHttpServer)</ept>, il server Web usato da ASP.NET Core, rappresenta un'opzione utilizzabile.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Remote proxy generation via <bpt id="p1">[</bpt>Castle.Core<ept id="p1">](https://github.com/castleproject/Core)</ept> is also an option to consider.</source>
          <target state="translated">La generazione in remoto del proxy tramite <bpt id="p1">[</bpt>Castle.Core<ept id="p1">](https://github.com/castleproject/Core)</ept> è un'ulteriore opzione da prendere in considerazione.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Binary Serialization</source>
          <target state="translated">Serializzazione binaria</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>As an alternative to Binary Serialization, there are multiple different serialization technologies to choose.</source>
          <target state="translated">Sono disponibili diverse tecnologie di serializzazione da usare in alternativa alla serializzazione binaria.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>You should choose one that fits your goals for formatting and footprint.</source>
          <target state="translated">È consigliabile sceglierne una adatta alle proprie finalità in termini di formattazione e footprint.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Popular choices include:</source>
          <target state="translated">Le scelte più comuni includono quanto segue:</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>JSON.NET<ept id="p1">](http://www.newtonsoft.com/json)</ept> for JSON</source>
          <target state="translated"><bpt id="p1">[</bpt>JSON.NET<ept id="p1">](http://www.newtonsoft.com/json)</ept> per JSON</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Runtime.Serialization.DataContractSerializer</ph> for both XML and JSON</source>
          <target state="translated"><ph id="ph1">@System.Runtime.Serialization.DataContractSerializer</ph> per XML e JSON</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Xml.Serialization.XmlSerializer</ph> for XML</source>
          <target state="translated"><ph id="ph1">@System.Xml.Serialization.XmlSerializer</ph> per XML</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>protobuf-net<ept id="p1">](https://github.com/mgravell/protobuf-net)</ept> for Protocol Buffers</source>
          <target state="translated"><bpt id="p1">[</bpt>protobuf-net<ept id="p1">](https://github.com/mgravell/protobuf-net)</ept> per i buffer di protocollo</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Refer to the linked resources to learn about their benefits and choose the ones for your needs.</source>
          <target state="translated">Per conoscere i vantaggi offerti e scegliere le soluzioni più adatte alle specifiche esigenze, fare riferimento alle risorse collegate.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>There are many other serialization formats and technologies out there, many of which are open source.</source>
          <target state="translated">Esistono molti altri formati e tecnologie di serializzazione, molti dei quali open source.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Sandboxes</source>
          <target state="translated">Sandbox</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>As an alternative to Sandboxing, you can use operating system provided security boundaries, such as user accounts for running processes with the least set of privileges.</source>
          <target state="translated">In alternativa al sandboxing, è possibile usare i limiti di sicurezza forniti dal sistema operativo, ad esempio gli account utente, per eseguire i processi con il set di privilegi più ridotto.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Overview of <ph id="ph1">`project.json`</ph></source>
          <target state="translated">Panoramica di <ph id="ph1">`project.json`</ph></target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>project.json project model<ept id="p1">](../tools/project-json.md)</ept> is a project model that ships with .NET Core SDK 1.0 Preview 2.</source>
          <target state="translated">Il <bpt id="p1">[</bpt>modello di progetto project.json<ept id="p1">](../tools/project-json.md)</ept> viene fornito con .NET Core SDK 1.0 Preview 2.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>It offers some benefits you may wish to take advantage of today:</source>
          <target state="translated">Tale modello offre i vantaggi seguenti:</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Simple multitargeting where target-specific assemblies can be generated from a single build.</source>
          <target state="translated">Multitargeting semplice, con la possibilità di generare assembly specifici della destinazione a partire da una singola compilazione.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The ability to easily generate a NuGet package with a build of the project.</source>
          <target state="translated">Possibilità di generare facilmente un pacchetto NuGet con una compilazione del progetto.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>No need to list files in your project file.</source>
          <target state="translated">Nessuna necessità di elencare file nel file di progetto.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Unification of NuGet package dependencies and project-to-project dependencies.</source>
          <target state="translated">Unificazione delle dipendenze dei pacchetti NuGet e delle dipendenze da progetto a progetto.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>While <ph id="ph1">`project.json`</ph> is eventually going to be deprecated, it can be used to build libraries on the .NET Standard today.</source>
          <target state="translated">Anche se alla fine <ph id="ph1">`project.json`</ph> verrà deprecato, è attualmente possibile usarlo per compilare librerie in .NET Standard.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The Project File: <ph id="ph1">`project.json`</ph></source>
          <target state="translated">File di progetto: <ph id="ph1">`project.json`</ph></target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>.NET Core projects are defined by a directory containing a <ph id="ph1">`project.json`</ph> file.</source>
          <target state="translated">I progetti .NET Core sono definiti come una directory contenente un file <ph id="ph1">`project.json`</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This file is where aspects of the project are declared, such as package dependencies, compiler configuration, runtime configuration, and more.</source>
          <target state="translated">In questo file vengono dichiarati diversi elementi del progetto, ad esempio le dipendenze del pacchetto, la configurazione del compilatore, la configurazione del runtime e molto altro.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`dotnet restore`</ph> command reads this project file, restores all dependencies of the project, and generates a <ph id="ph2">`project.lock.json`</ph> file.</source>
          <target state="translated">Il comando <ph id="ph1">`dotnet restore`</ph> legge questo file, ripristina tutte le dipendenze del progetto e genera un file <ph id="ph2">`project.lock.json`</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This file contains all the necessary information the build system needs to build the project.</source>
          <target state="translated">Questo file contiene tutte le informazioni di cui il sistema di compilazione ha bisogno per compilare il progetto.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>To learn more about the <ph id="ph1">`project.json`</ph> file, read the <bpt id="p1">[</bpt>project.json reference<ept id="p1">](../tools/project-json.md)</ept>.</source>
          <target state="translated">Per altre informazioni sul file <ph id="ph1">`project.json`</ph>, vedere <bpt id="p1">[</bpt>project.json reference<ept id="p1">](../tools/project-json.md)</ept> (Riferimenti di project.json).</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The Solution File: <ph id="ph1">`global.json`</ph></source>
          <target state="translated">File di soluzione: <ph id="ph1">`global.json`</ph></target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`global.json`</ph> file is an optional file to include in a solution which contains multiple projects.</source>
          <target state="translated">Il file <ph id="ph1">`global.json`</ph> è un file opzionale da includere in una soluzione contenente più progetti.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>It typically resides in the root directory of a set of projects.</source>
          <target state="translated">Si trova in genere nella directory radice di un set di progetti.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It can be used to inform the build system of different subdirectories which can contain projects.</source>
          <target state="translated">Può essere usato per indicare al sistema di compilazione le differenti sottodirectory che possono contenere progetti.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This is for larger systems composed of several projects.</source>
          <target state="translated">Questa affermazione vale per i sistemi di grandi dimensioni composti da diversi progetti.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>For example, you can organize your code into top-level <ph id="ph1">`/src`</ph> and <ph id="ph2">`/test`</ph> folder as such:</source>
          <target state="translated">Ad esempio, è possibile organizzare il codice in cartelle di livello superiore <ph id="ph1">`/src`</ph> e <ph id="ph2">`/test`</ph>, come mostrato di seguito:</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>You can then have multiple <ph id="ph1">`project.json`</ph> files under their own sub-folders inside <ph id="ph2">`/src`</ph> and <ph id="ph3">`/test`</ph>.</source>
          <target state="translated">È quindi possibile avere più file <ph id="ph1">`project.json`</ph> nelle relative sottocartelle all'interno di <ph id="ph2">`/src`</ph> e <ph id="ph3">`/test`</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>How to Multitarget with <ph id="ph1">`project.json`</ph></source>
          <target state="translated">Come definire più destinazioni con <ph id="ph1">`project.json`</ph></target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Many libraries multitarget to have as wide of a reach as possible.</source>
          <target state="translated">Diverse librerie definiscono più destinazioni per ottenere la massima copertura possibile.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>With .NET Core, multitargeting is a "first class citizen", meaning that you can easily generate platform-specific assemblies with a single build.</source>
          <target state="translated">Con .NET Core la definizione di più destinazioni è un "oggetto di prima classe": questo significa che è possibile generare facilmente assembly specifici della piattaforma con una sola compilazione.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Multitargeting is as simple as adding the correct Target Framework Moniker (TFM) to your <ph id="ph1">`project.json`</ph> file, using the correct dependencies for each target (<ph id="ph2">`dependencies`</ph> for .NET Core and <ph id="ph3">`frameworkAssemblies`</ph> for .NET Framework), and potentially using <ph id="ph4">`#if`</ph> directives to conditionally compile the source code for platform-specific API usage.</source>
          <target state="translated">Il multitargeting è semplice quanto l'aggiunta del TFM (Target Framework Moniker) corretto al file <ph id="ph1">`project.json`</ph>, mediante l'uso delle dipendenze corrette per ciascuna destinazione (<ph id="ph2">`dependencies`</ph> per .NET Core e <ph id="ph3">`frameworkAssemblies`</ph> per .NET Framework) e potenzialmente mediante l'uso delle direttive <ph id="ph4">`#if`</ph> per la compilazione condizionale del codice sorgente per l'utilizzo delle API specifiche della piattaforma.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>For example, imagine you are building a library where you wanted to perform some network operations, and you wanted that library to run on all .NET Framework versions, a Portable Class Library (PCL) Profile, and .NET Core.</source>
          <target state="translated">Si supponga, ad esempio, di compilare una libreria in cui si vogliono eseguire alcune operazioni di rete. Si vuole inoltre che la libreria possa essere eseguita in tutte le versioni di .NET Framework, in un profilo della libreria di classi portabile e in .NET Core.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For .NET Core and .NET Framework 4.5+ targets, you may use <ph id="ph1">`System.Net.Http`</ph> library and <ph id="ph2">`async`</ph><ph id="ph3">/</ph><ph id="ph4">`await`</ph>.</source>
          <target state="translated">Per le destinazioni .NET Core e .NET Framework 4.5 e versione successiva, è possibile usare la libreria <ph id="ph1">`System.Net.Http`</ph> e <ph id="ph2">`async`</ph><ph id="ph3">/</ph><ph id="ph4">`await`</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>However, for earlier versions of .NET Framework, those APIs aren't available.</source>
          <target state="translated">Per le precedenti versioni di .NET Framework, tuttavia, tali API non sono disponibili.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Here's a sample <ph id="ph1">`frameworks`</ph> section for a <ph id="ph2">`project.json`</ph> that targets the .NET Framework versions 2.0, 3.5, 4.0, 4.5, and .NET Standard 1.6:</source>
          <target state="translated">Di seguito è riportata una sezione <ph id="ph1">`frameworks`</ph> di esempio per un file <ph id="ph2">`project.json`</ph> che ha come destinazione le versioni 2.0, 3.5, 4.0 e 4.5 di .NET Framework, oltre a .NET Standard 1.6:</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Note that PCL targets are special: they require you to specify a build definition for the compiler to recognize, and they require you to specify all of the assemblies you use, including <ph id="ph1">`mscorlib`</ph>.</source>
          <target state="translated">Si noti che le destinazioni delle librerie di classi portabili sono speciali: richiedono infatti la specifica di una definizione di compilazione che il compilatore possa riconoscere. Richiedono inoltre la specifica di tutti gli assembly usati, incluso <ph id="ph1">`mscorlib`</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Your source code could then use the dependencies like this:</source>
          <target state="translated">Il codice sorgente può quindi usare le dipendenze, come mostrato di seguito:</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Note that all of the .NET Framework and .NET Standard targets have names recognized by the compiler:</source>
          <target state="translated">Si noti che tutte le destinazioni .NET Framework e .NET Standard hanno nomi riconosciuti dal compilatore:</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>As mentioned above, if you are targeting a PCL, then you will have to specify a build definition for the compiler to understand.</source>
          <target state="translated">Come indicato in precedenza, se si definisce come destinazione una libreria di classi portabile, sarà necessario specificare una definizione di compilazione che il compilatore sia in grado di comprendere.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>There is no default definition that the compiler can use.</source>
          <target state="translated">Non è presente alcuna definizione predefinita che il compilatore possa usare.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Using <ph id="ph1">`project.json`</ph> in Visual Studio</source>
          <target state="translated">Uso di <ph id="ph1">`project.json`</ph> in Visual Studio</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>You have two options for using <ph id="ph1">`project.json`</ph> in Visual Studio:</source>
          <target state="translated">Per l'uso di <ph id="ph1">`project.json`</ph> in Visual Studio, sono disponibili le due opzioni seguenti:</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A new xproj project type.</source>
          <target state="translated">Un nuovo tipo di progetto Xproj.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>A retargeted PCL project which supports .NET Standard.</source>
          <target state="translated">Un progetto della libreria di classi portabile predestinato che supporta .NET Standard.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>There are different benefits and drawbacks for each.</source>
          <target state="translated">Per ciascuna opzione sono presenti vantaggi e svantaggi.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>When to Pick an Xproj Project</source>
          <target state="translated">Quando scegliere un progetto Xproj</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The new Xproj project system in Visual Studio utilizes the capabilities of the <ph id="ph1">`project.json`</ph>-based project model to offer two major features over existing project types: seamless multitargeting by building multiple assemblies and the ability to directly generate a NuGet package on build.</source>
          <target state="translated">Il nuovo sistema di progetto Xproj di Visual Studio usa le funzionalità del modello di progetto basate su <ph id="ph1">`project.json`</ph> per offrire due vantaggi rispetto ai tipi di progetto esistenti: multitargeting semplice mediante la compilazione di più assembly e possibilità di generare direttamente un pacchetto NuGet durante la fase di compilazione.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>However, it comes at the cost of lacking certain features you may use, such as:</source>
          <target state="translated">Questa scelta, tuttavia, comporta la perdita di alcune funzionalità, ad esempio quelle riportate di seguito:</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Support for F# or Visual Basic</source>
          <target state="translated">Supporto per F# o Visual Basic</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Generating satellite assemblies with localized resource strings</source>
          <target state="translated">Generazione di assembly satellite con stringhe di risorsa localizzate</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Directly referencing a <ph id="ph1">`.dll`</ph> file on the filesystem</source>
          <target state="translated">Riferimento diretto a un file <ph id="ph1">`.dll`</ph> nel file system</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The ability to reference a csproj-based project in the Reference Manager (depending on the <ph id="ph1">`.dll`</ph> file directly is supported, though)</source>
          <target state="translated">Possibilità di fare riferimento a un progetto basato su csproj in Gestione riferimenti (a seconda del file <ph id="ph1">`.dll`</ph> direttamente supportato)</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>If your project needs are relatively minimal and you can take advantage of the new features of xproj, you should pick it as your project system.</source>
          <target state="translated">Se le esigenze del progetto sono relativamente contenute e si intende trarre vantaggio dalle nuove funzionalità di Xproj, questo sistema di progetto è la scelta migliore.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>This can be done in Visual Studio as such:</source>
          <target state="translated">Questa operazione può essere eseguita in Visual Studio nel modo seguente:</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Ensure you are using Visual Studio 2015 or later.</source>
          <target state="translated">Verificare di usare Visual Studio 2015 o versione successiva.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Select File | New Project.</source>
          <target state="translated">Selezionare File | Nuovo progetto.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Select ".NET Core" under Visual C#.</source>
          <target state="translated">Selezionare ".NET Core" nell'area Visual C#.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Select the "Class Library (.NET Core)" template.</source>
          <target state="translated">Selezionare il modello "Libreria di classi (.NET Core)".</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>When to Pick a PCL project</source>
          <target state="translated">Quando scegliere un progetto della libreria di classi portabile</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>You can target .NET Core with the traditional project system in Visual Studio, by creating a Portable Class Library (PCL) and selecting ".NET Core" in the project configuration dialog.</source>
          <target state="translated">È possibile definire come destinazione .NET Core con il tradizionale sistema di progetto in Visual Studio creando una libreria di classi portabile e selezionando ".NET Core" nella finestra di dialogo per la configurazione del progetto.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Then you'll need to retarget the project to be based on the .NET Standard:</source>
          <target state="translated">È quindi necessario ridestinare il progetto in modo che sia basato su .NET Standard:</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Right-click on the project file in Visual Studio and select Properties.</source>
          <target state="translated">Fare clic con il pulsante destro del mouse sul file di progetto in Visual Studio e scegliere Proprietà.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Under Build, select "Convert to .NET Standard".</source>
          <target state="translated">Nell'area Compilazione selezionare "Convert to .NET Standard" (Converti in .NET Standard).</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>If you have more advanced project system needs, this should be your choice.</source>
          <target state="translated">Se sono presenti esigenze di sistema di progetto più complesse, questa è la scelta corretta.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Note that if you wish to multitarget by generating platform-specific assemblies like with the <ph id="ph1">`xproj`</ph> project system, you'll need to create a "Bait and Switch" PCL, as described in <bpt id="p1">[</bpt>How to Make Portable Class Libraries Work for You<ept id="p1">](https://blogs.msdn.microsoft.com/dsplaisted/2012/08/27/how-to-make-portable-class-libraries-work-for-you/)</ept>.</source>
          <target state="translated">Si noti che, se si vuole eseguire il multitargeting generando assembly specifici della piattaforma come con il sistema di progetto <ph id="ph1">`xproj`</ph>, sarà necessario creare una libreria di classi portabile con la tecnica dello "specchietto per le allodole", come descritto in <bpt id="p1">[</bpt>How to Make Portable Class Libraries Work for You<ept id="p1">](https://blogs.msdn.microsoft.com/dsplaisted/2012/08/27/how-to-make-portable-class-libraries-work-for-you/)</ept> (Come usare le librerie di classi portabili).</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Retargeting your .NET Framework Code to .NET Framework 4.6.2</source>
          <target state="translated">Ridestinazione del codice .NET Framework a .NET Framework 4.6.2</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If your code is not targeting .NET Framework 4.6.2, it's recommended that you retarget.</source>
          <target state="translated">Se il codice non ha come destinazione .NET Framework 4.6.2, è consigliabile ridestinarlo.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>This ensures that you can use the latest API alternatives for cases where the .NET Standard can't support existing APIs.</source>
          <target state="translated">Questa operazione assicura che vengano sempre usate le più recenti alternative alle API nei casi in cui .NET Standard non supporta le API esistenti.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>For each of your projects in Visual Studio you wish to port, do the following:</source>
          <target state="translated">Per ciascuno dei progetti Visual Studio che si vuole trasferire, effettuare le operazioni seguenti:</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Right-click on the project and select Properties</source>
          <target state="translated">Fare clic con il pulsante destro del mouse sul progetto e scegliere Proprietà.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>In the "Target Framework" dropdown, select ".NET Framework 4.6.2".</source>
          <target state="translated">Nell'elenco a discesa "Versione .NET Framework di destinazione" selezionare ".NET Framework 4.6.2".</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Recompile your projects.</source>
          <target state="translated">Ricompilare i progetti.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">L'operazione è ora completata.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Because your projects now target .NET Framework 4.6.2, you can use that version of .NET Framework as your base for porting code.</source>
          <target state="translated">Poiché i progetti hanno ora come destinazione .NET Framework 4.6.2, è possibile usare tale versione come base per il trasferimento del codice.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Determining the Portability of Your Code</source>
          <target state="translated">Determinazione della portabilità del codice</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The next step is to run the API Portability Analyzer (ApiPort) to generate a portability report that you can begin to analyze.</source>
          <target state="translated">Il passaggio successivo consiste nell'esecuzione di ApiPort (API Portability Analyzer) per generare un report sulla portabilità che è possibile iniziare ad analizzare.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>You'll need to make sure you understand the <bpt id="p1">[</bpt>API Portability tool (ApiPort)<ept id="p1">](https://github.com/Microsoft/dotnet-apiport/blob/master/docs/HowTo/)</ept> and can generate portability reports for targeting .NET Core.</source>
          <target state="translated">Assicurarsi di comprendere lo strumento <bpt id="p1">[</bpt>ApiPort<ept id="p1">](https://github.com/Microsoft/dotnet-apiport/blob/master/docs/HowTo/)</ept> e di essere in grado di generare report sulla portabilità per specificare come destinazione .NET Core.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>How you do this will likely vary based on your needs and personal tastes.</source>
          <target state="translated">La procedura dipenderà probabilmente dalle esigenze e dai gusti personali.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>What follows are a few different approaches - you may find yourself mixing each approach depending on how your code is structured.</source>
          <target state="translated">Di seguito sono riportati alcuni approcci. A seconda della strutturazione del codice, può essere necessario usare una combinazione di tali strategie.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Dealing Primarily with the Compiler</source>
          <target state="translated">Gestire principalmente il compilatore</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This approach may be the best for small projects or projects which don't use many .NET Framework APIs.</source>
          <target state="translated">Questo approccio può rivelarsi la scelta migliore per progetti di piccole dimensioni o per progetti che non usano un numero elevato di API .NET Framework.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The approach is very simple:</source>
          <target state="translated">L'approccio è molto semplice:</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Optionally run ApiPort on your project.</source>
          <target state="translated">Eseguire ApiPort sul progetto (facoltativo).</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>If ApiPort was ran, take a quick glance at the report.</source>
          <target state="translated">Se è stato eseguito ApiPort, rivedere velocemente il report.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Copy all of your code over into a new .NET Core project.</source>
          <target state="translated">Copiare tutto il codice in un nuovo progetto .NET Core.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Work out compiler errors until it compiles, referring to the portability report if needed.</source>
          <target state="translated">Risolvere gli eventuali errori durante la compilazione, se necessario facendo riferimento al report sulla portabilità.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Repeat as needed.</source>
          <target state="translated">Se necessario, ripetere i passaggi.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Although this approach is very unstructured, the code-focused approach can lead to resolving any issues quickly, and may be the best approach for smaller projects or libraries.</source>
          <target state="translated">Anche se molto poco strutturato, questo approccio centrato sul codice può consentire la rapida risoluzione di eventuali problemi e può costituire la scelta migliore per i progetti o le librerie di minori dimensioni.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>A project that contains only data models may be an ideal candidate here.</source>
          <target state="translated">Un progetto contenente solo modelli di dati può essere un candidato ideale per questo approccio.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Staying on the .NET Framework until Portability Issues are Resolved</source>
          <target state="translated">Rimanere in .NET Framework fino alla risoluzione dei problemi di portabilità</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>This approach may be the best if you prefer to have code that compiles during the entire process.</source>
          <target state="translated">Questo approccio può costituire la scelta migliore se si preferisce che il codice venga compilato durante l'intero processo.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The approach is as follows:</source>
          <target state="translated">Di seguito viene riportata la descrizione di questo approccio:</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Run ApiPort on a project.</source>
          <target state="translated">Eseguire ApiPort su un progetto.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Address issues by using different APIs which are portable.</source>
          <target state="translated">Risolvere i problemi usando diverse API portabili.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Keep note of any areas where you can't use a direct alternative.</source>
          <target state="translated">Prendere nota delle aree in cui non è possibile usare un'alternativa diretta.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Repeat steps 1-3 for all projects you're porting until you're confident each is ready to be copied over into a .NET Core project.</source>
          <target state="translated">Ripetere i passaggi da 1 a 3 per tutti i progetti in fase di trasferimento, fino a quando non si è certi che ciascuno di essi è pronto per essere copiato in un progetto .NET Core.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Copy the code into a new .NET Core projects.</source>
          <target state="translated">Copiare il codice in un nuovo progetto .NET Core.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Work out any issues that you've kept note of.</source>
          <target state="translated">Risolvere gli eventuali problemi di cui si è preso nota.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>This careful approach is more structured than simply working out compiler errors, but it is still relatively code-focused and has the benefit of always having code that can compile.</source>
          <target state="translated">Questo approccio attento è più strutturato rispetto alla semplice risoluzione degli errori del compilatore, ma è ancora relativamente centrato sul codice e offre il vantaggio di consentirne sempre la compilazione.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The way you resolve certain issues that couldn't be addressed by just using another API can vary greatly.</source>
          <target state="translated">I modi in cui gli utenti correggono determinati problemi non risolvibili mediante il semplice uso di un'altra API possono variare notevolmente.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>You may find that you need to develop a more comprehensive plan for certain projects, which is covered as the next approach.</source>
          <target state="translated">È possibile che si ritenga necessario sviluppare un piano più completo per determinati progetti, approccio descritto nella sezione seguente.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Developing a Comprehensive Plan of Attack</source>
          <target state="translated">Sviluppare un piano di attacco completo</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>This approach may be best for larger and more complex projects, where restructuring of code or rewriting certain areas may be necessary to support .NET Core.</source>
          <target state="translated">Questo approccio può costituire la scelta migliore per progetti più complessi e di maggiori dimensioni, in cui per supportare .NET Core può essere necessaria la ristrutturazione del codice o la riscrittura di determinate aree.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The approach is as follows:</source>
          <target state="translated">Di seguito viene riportata la descrizione di questo approccio:</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Run ApiPort on a project.</source>
          <target state="translated">Eseguire ApiPort su un progetto.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Understand where in your code each non-portable type is being used and how that affects overall portability.</source>
          <target state="translated">Determinare i punti del codice in cui viene usato ciascun tipo non portabile e stabilire l'entità dell'impatto sulla portabilità complessiva.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>a.</source>
          <target state="translated">a.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Understand the nature of those types.</source>
          <target state="translated">Comprendere la natura di tali tipi.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Are they small in number, but used frequently?</source>
          <target state="translated">Sono in numero limitato, ma di uso frequente?</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Are they large in number, but used infrequently?</source>
          <target state="translated">Sono numerosi, ma usati raramente?</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Is their use concentrated, or is it spread throughout your code?</source>
          <target state="translated">Il loro uso è concentrato o distribuito in tutto il codice?</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>b.</source>
          <target state="translated">b.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Is it easy to isolate code that isn't portable so you can deal with it more easily?</source>
          <target state="translated">È possibile isolare facilmente il codice non portabile per gestirlo con maggiore semplicità?</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>c.</source>
          <target state="translated">c.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Would you need to refactor your code?</source>
          <target state="translated">È necessario effettuare il refactoring del codice?</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>d.</source>
          <target state="translated">d.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>For those types which aren't portable, are there alternative APIs that accomplish the same task?</source>
          <target state="translated">Per i tipi non portabili, esistono API alternative che svolgono la stessa attività?</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>For example, if you're using the <ph id="ph1">`WebClient`</ph> class, you may be able to use the <ph id="ph2">`HttpClient`</ph> class instead.</source>
          <target state="translated">Ad esempio, se si usa la classe <ph id="ph1">`WebClient`</ph>, è possibile usare al suo posto la classe <ph id="ph2">`HttpClient`</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>e.</source>
          <target state="translated">e.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Are there different portable APIs you can use to accomplish a task, even if it's not a drop-in replacement?</source>
          <target state="translated">Esistono API portabili differenti che è possibile usare per eseguire un'attività, anche se non si tratta di una sostituzione vera e propria?</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>For example, if you're using <ph id="ph1">`XmlSchema`</ph> to help parse XML, but you don't require XML schema discovery, you could use <ph id="ph2">`System.Linq.Xml`</ph> APIs and hand-parse the data.</source>
          <target state="translated">Ad esempio, se si usa <ph id="ph1">`XmlSchema`</ph> per analizzare XML ma non è necessaria l'individuazione dello schema XML, è possibile usare le API <ph id="ph2">`System.Linq.Xml`</ph> e analizzare i dati manualmente.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>If you have assemblies that are difficult to port, is it worth leaving them on .NET Framework for now?</source>
          <target state="translated">Se sono presenti assembly difficili da trasferire, è opportuno lasciarli per il momento in .NET Framework?</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Here are some things to consider:</source>
          <target state="translated">Di seguito sono riportati alcuni aspetti da prendere in considerazione:</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>a.</source>
          <target state="translated">a.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>You may have some functionality in your library that's incompatible with .NET Core because it relies too heavily on .NET Framework- or Windows-specific functionality.</source>
          <target state="translated">Alcune funzionalità della libreria possono non essere compatibili con .NET Core poiché sono basate in misura eccessiva su funzionalità specifiche di .NET Framework o di Windows.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Is it worth leaving that functionality behind for now and releasing a .NET Core version of your library with less features for the time being?</source>
          <target state="translated">È opportuno trascurare momentaneamente tali funzionalità non compatibili e rilasciare una versione .NET Core della libreria con un numero minore di funzionalità?</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>b.</source>
          <target state="translated">b.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Would a refactor help here?</source>
          <target state="translated">Un'operazione di refactoring può risultare vantaggiosa?</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Is it reasonable to write your own implementation of an unavailable .NET Framework API?</source>
          <target state="translated">La scrittura di una propria implementazione di un'API .NET Framework non disponibile è una scelta ragionevole?</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>You could consider instead copying, modifying, and using code from the <bpt id="p1">[</bpt>.NET Framework Reference Source<ept id="p1">](https://github.com/Microsoft/referencesource)</ept>.</source>
          <target state="translated">Può essere invece opportuno copiare, modificare e usare codice tratto da <bpt id="p1">[</bpt>.NET Framework Reference Source<ept id="p1">](https://github.com/Microsoft/referencesource)</ept> (Codice sorgente di riferimento .NET Framework).</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>It's licensed under the <bpt id="p1">[</bpt>MIT License<ept id="p1">](https://github.com/Microsoft/referencesource/blob/master/LICENSE.txt)</ept>, so you have significant freedom in doing this.</source>
          <target state="translated">Tale codice è disponibile con <bpt id="p1">[</bpt>Licenza MIT<ept id="p1">](https://github.com/Microsoft/referencesource/blob/master/LICENSE.txt)</ept>, con conseguente significativa libertà di utilizzo per gli utenti.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Just be sure to properly attribute Microsoft in your code!</source>
          <target state="translated">È sufficiente assicurarsi di attribuire la creazione del codice a Microsoft.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Repeat this process as needed for different projects.</source>
          <target state="translated">Ripetere questo processo in base alle esigenze per i diversi progetti.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Once you have a plan, execute that plan.</source>
          <target state="translated">Dopo aver definito un piano, passare alla fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The analysis phase could take some time depending on how large your codebase is.</source>
          <target state="translated">A seconda delle dimensioni della CodeBase, la fase di analisi può richiedere diverso tempo.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Spending time in this phase to thoroughly understand the scope of changes needed and to develop a plan can save you a lot of time in the long run, particularly if you have a more complex codebase.</source>
          <target state="translated">Il tempo dedicato a questa fase per comprendere appieno l'ambito delle modifiche necessarie e sviluppare un piano può assicurare un notevole risparmio di tempo durante la fase di esecuzione, in particolare se si dispone di una CodeBase più complessa.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Your plan could involve making significant changes to your codebase while still targeting .NET Framework 4.6.2, making this a more structured version of the previous approach.</source>
          <target state="translated">Il piano può comportare la necessità di modifiche significative della CodeBase, mantenendo tuttavia come destinazione .NET Framework 4.6.2. Si tratta di una versione più strutturata dell'approccio precedente.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>How you go about executing your plan will be dependent on your codebase.</source>
          <target state="translated">La modalità di esecuzione del piano dipende dalle caratteristiche della CodeBase.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Mixing Approaches</source>
          <target state="translated">Combinazione di approcci</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>It's likely that you'll mix the above approaches on a per-project basis.</source>
          <target state="translated">È probabile che, in base al tipo di progetto, sia necessario combinare gli approcci descritti in precedenza.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>You should do what makes the most sense to you and for your codebase.</source>
          <target state="translated">È consigliabile effettuare le scelte più corrette per il progetto e la CodeBase.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Porting your Tests</source>
          <target state="translated">Trasferimento dei test</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The best way to make sure everything works when you've ported your code is to test your code as you port it to .NET Core.</source>
          <target state="translated">Il modo migliore per verificare un codice trasferito consiste nell'eseguirne il test durante il trasferimento in .NET Core.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>To do this, you'll need to use a testing framework that will build and run tests for .NET Core.</source>
          <target state="translated">A tale scopo è necessario usare un framework di test che compilerà ed eseguirà test per .NET Core.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Currently, you have three options:</source>
          <target state="translated">Attualmente sono disponibili le tre opzioni seguenti:</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>xUnit<ept id="p1">](https://xunit.github.io/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>xUnit<ept id="p1">](https://xunit.github.io/)</ept></target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Getting Started<ept id="p1">](http://xunit.github.io/docs/getting-started-dnx.html)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Introduzione<ept id="p1">](http://xunit.github.io/docs/getting-started-dnx.html)</ept></target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Tool to convert an MSTest project to xUnit<ept id="p1">](https://github.com/dotnet/codeformatter/tree/master/src/XUnitConverter)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Strumento per trasferire un progetto MSTest in xUnit<ept id="p1">](https://github.com/dotnet/codeformatter/tree/master/src/XUnitConverter)</ept></target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>NUnit<ept id="p1">](http://www.nunit.org/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>NUnit<ept id="p1">](http://www.nunit.org/)</ept></target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Getting Started<ept id="p1">](https://github.com/nunit/docs/wiki/Installation)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Introduzione<ept id="p1">](https://github.com/nunit/docs/wiki/Installation)</ept></target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Blog post about migrating from MSTest to NUnit<ept id="p1">](http://www.florian-rappl.de/News/Page/275/convert-mstest-to-nunit)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Post di blog sulla migrazione da MSTest a NUnit<ept id="p1">](http://www.florian-rappl.de/News/Page/275/convert-mstest-to-nunit)</ept></target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>MSTest<ept id="p1">](https://msdn.microsoft.com/library/ms243147.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>MSTest<ept id="p1">](https://msdn.microsoft.com/library/ms243147.aspx)</ept></target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Recommended Approach to Porting</source>
          <target state="translated">Approccio consigliato per il porting</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Finally, porting the code itself!</source>
          <target state="translated">Una volta eseguite le operazioni descritte in precedenza, è possibile trasferire il codice.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Ultimately, the actual porting effort will depend heavily on how your .NET Framework code is structured.</source>
          <target state="translated">In definitiva, l'effettiva entità del lavoro di trasferimento dipende in larga misura dal modo in cui il codice .NET Framework è strutturato.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>That being said, here is a recommended approach which may work well with your codebase.</source>
          <target state="translated">Detto questo, di seguito è descritto un approccio consigliato che dovrebbe funzionare correttamente con la CodeBase.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>A good way to port your code is to begin with the "base" of your library.</source>
          <target state="translated">Un buon metodo per trasferire il codice consiste nell'iniziare con la "base" della libreria.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>This may be data models or some other foundational classes and methods that everything else uses directly or indirectly.</source>
          <target state="translated">Può trattarsi di modelli o di altri metodi e classi fondamentali usati dagli altri elementi in modo diretto o indiretto.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Port the test project which tests the layer of your library that you're currently porting.</source>
          <target state="translated">Trasferire il progetto di test, operazione che verifica il livello della libreria attualmente in fase di trasferimento.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Copy over the "base" of your library into a new .NET Core project and select the version of the .NET Standard you wish to support.</source>
          <target state="translated">Copiare la "base" della libreria in un nuovo progetto .NET Core e selezionare la versione di .NET Standard che si vuole supportare.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Make any changes needed to get the code to compile.</source>
          <target state="translated">Apportare le modifiche necessarie per consentire la compilazione del codice.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Much of this may require adding NuGet package dependencies to your <ph id="ph1">`project.json`</ph> file.</source>
          <target state="translated">Può essere necessario aggiungere le dipendenze di un pacchetto NuGet al file <ph id="ph1">`project.json`</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Run tests and make any needed adjustments.</source>
          <target state="translated">Eseguire i test e apportare le modifiche eventualmente necessarie.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Pick the next layer of code to port over and repeat steps 2 and 3!</source>
          <target state="translated">Selezionare il successivo livello di codice da trasferire e ripetere i passaggi 2 e 3.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>If you methodically move outward from the base of your library and test each layer as needed, porting will be a systematic process where problems are isolated to one layer of code at a time.</source>
          <target state="translated">Spostandosi metodicamente dalla base all'esterno della libreria e testando ogni livello nel modo necessario, il trasferimento risulterà un processo sistematico in cui i problemi vengono isolati in un livello di codice alla volta.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>