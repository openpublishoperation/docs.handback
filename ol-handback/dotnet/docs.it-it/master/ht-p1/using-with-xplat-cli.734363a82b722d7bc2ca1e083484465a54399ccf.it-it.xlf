<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aafa0c110dc3a2820f7e050d70b9450af1db35d8</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tutorials\using-with-xplat-cli.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8ad728e8551de1a665eaf4799620996b7afda6d0</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1cc7baffec32a9306cc56315ec41e6862db64d33</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Getting started with .NET Core on Windows/Linux/macOS using the command line</source>
          <target state="translated">Introduzione all'uso di .NET Core su Windows/Linux/macOS dalla riga di comando</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Getting started with .NET Core on Windows, Linux, or macOS using the .NET Core command line interface (CLI)</source>
          <target state="translated">Introduzione all'uso di .NET Core su Windows/Linux/macOS dall'interfaccia della riga di comando di .NET Core</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Getting started with .NET Core on Windows/Linux/macOS using the command line</source>
          <target state="translated">Introduzione all'uso di .NET Core su Windows/Linux/macOS dalla riga di comando</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This guide will show you how to use the .NET Core CLI tooling to build cross-platform console apps.</source>
          <target state="translated">Questa guida illustra come usare gli strumenti dell'interfaccia della riga di comando di .NET Core per creare applicazioni console multipiattaforma.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It will start with the most basic console app and eventually span multiple projects, including testing.</source>
          <target state="translated">Si inizia con un'applicazione console molto semplice per poi passare a più progetti, incluso un progetto di test.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You'll add these features step-by-step, building on what you've already seen and built.</source>
          <target state="translated">Le funzionalità verranno illustrate in maniera graduale, aggiungendo nuove informazioni sulla base di quelle già acquisite.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you're unfamiliar with the .NET Core CLI toolset, read <bpt id="p1">[</bpt>the .NET Core SDK overview<ept id="p1">](../sdk.md)</ept>.</source>
          <target state="translated">Se non si ha familiarità con il set di strumenti dell'interfaccia della riga di comando di .NET Core, leggere <bpt id="p1">[</bpt>la panoramica di .NET Core SDK<ept id="p1">](../sdk.md)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">Prerequisiti</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Before you begin, ensure you have the <bpt id="p1">[</bpt>latest .NET Core CLI tooling<ept id="p1">](https://www.microsoft.com/net/core)</ept>.</source>
          <target state="translated">Prima di iniziare, assicurarsi di avere gli <bpt id="p1">[</bpt>strumenti più recenti dell'interfaccia della riga di comando di .NET Core<ept id="p1">](https://www.microsoft.com/net/core)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You'll also need a text editor.</source>
          <target state="translated">È necessario anche un editor di testo.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Hello, Console App!</source>
          <target state="translated">Creazione di un'applicazione console</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>First, navigate to or create a new folder with a name you like.</source>
          <target state="translated">Innanzitutto, passare a un'altra cartella e crearne una nuova con il nome desiderato.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>"Hello" is the name chosen for the sample code, which can be found <bpt id="p1">[</bpt>here<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/Hello)</ept>.</source>
          <target state="translated">"Hello" è il nome selezionato per il codice di esempio, che è possibile trovare <bpt id="p1">[</bpt>qui<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/Hello)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Open up a command prompt and type the following:</source>
          <target state="translated">Aprire un prompt dei comandi e digitare quanto segue:</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Let's do a quick walkthrough:</source>
          <target state="translated">Ecco una descrizione rapida dei comandi digitati:</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet new`</ph><ept id="p1">](../tools/dotnet-new.md)</ept> creates an up-to-date <ph id="ph2">`project.json`</ph> file with NuGet dependencies necessary to build a console app.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`dotnet new`</ph><ept id="p1">](../tools/dotnet-new.md)</ept> crea un file <ph id="ph2">`project.json`</ph> aggiornato con le dipendenze NuGet necessarie per compilare un'applicazione console.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>It also creates a <ph id="ph1">`Program.cs`</ph>, a basic file containing the entry point for the application.</source>
          <target state="translated">Crea inoltre un file <ph id="ph1">`Program.cs`</ph> di base contenente il punto di ingresso per l'applicazione.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`project.json`</ph>:</source>
          <target state="translated"><ph id="ph1">`project.json`</ph>:</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Program.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`Program.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet restore`</ph><ept id="p1">](../tools/dotnet-restore.md)</ept> calls into NuGet to restore the tree of dependencies.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`dotnet restore`</ph><ept id="p1">](../tools/dotnet-restore.md)</ept> esegue una chiamata a NuGet per ripristinare l'albero delle dipendenze.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>NuGet analyzes the <ph id="ph1">`project.json`</ph> file, downloads the dependencies stated in the file (or grabs them from a cache on your machine), and writes the <ph id="ph2">`project.lock.json`</ph> file.</source>
          <target state="translated">NuGet analizza il file <ph id="ph1">`project.json`</ph>, scarica le dipendenze indicate nel file (o li estrae da una cache nel computer) e scrive il file <ph id="ph2">`project.lock.json`</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`project.lock.json`</ph> file is necessary to be able to compile and run.</source>
          <target state="translated">Il file <ph id="ph1">`project.lock.json`</ph> è necessario per la compilazione e l'esecuzione.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`project.lock.json`</ph> file is a persisted and complete set of the graph of NuGet dependencies and other information describing an app.</source>
          <target state="translated">Il file <ph id="ph1">`project.lock.json`</ph> è un set completo e persistente del grafico delle dipendenze NuGet e include altre informazioni che descrivono un'applicazione.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This file is read by other tools, such as <ph id="ph1">`dotnet build`</ph> and <ph id="ph2">`dotnet run`</ph>, enabling them to process the source code with a correct set of NuGet dependencies and binding resolutions.</source>
          <target state="translated">Questo file viene letto da altri strumenti, ad esempio <ph id="ph1">`dotnet build`</ph> e <ph id="ph2">`dotnet run`</ph>, che possono quindi elaborare il codice sorgente con un set corretto di risoluzioni di binding e dipendenze NuGet.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet run`</ph><ept id="p1">](../tools/dotnet-run.md)</ept> calls <ph id="ph2">`dotnet build`</ph> to ensure that the build targets have been built, and then calls <ph id="ph3">`dotnet &lt;assembly.dll&gt;`</ph> to run the target application.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`dotnet run`</ph><ept id="p1">](../tools/dotnet-run.md)</ept> chiama <ph id="ph2">`dotnet build`</ph> per assicurarsi che le destinazioni siano state compilate e quindi chiama <ph id="ph3">`dotnet &lt;assembly.dll&gt;`</ph> per eseguire l'applicazione di destinazione.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can also execute <bpt id="p1">[</bpt><ph id="ph1">`dotnet build`</ph><ept id="p1">](../tools/dotnet-build.md)</ept> to compile the code without running the build console applications.</source>
          <target state="translated">È inoltre possibile eseguire <bpt id="p1">[</bpt><ph id="ph1">`dotnet build`</ph><ept id="p1">](../tools/dotnet-build.md)</ept> per compilare il codice senza eseguire la compilazione di applicazioni console.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Building a self-contained application</source>
          <target state="translated">Compilazione di un'applicazione autonoma</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Let's try compiling a self-contained application instead of a portable application.</source>
          <target state="translated">In questa sezione si proverà a compilare un'applicazione autonoma anziché un'applicazione portabile.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You can read more about the <bpt id="p1">[</bpt>types of portability in .NET Core<ept id="p1">](../deploying/index.md)</ept> to learn about the different application types, and how they are deployed.</source>
          <target state="translated">È possibile leggere altre informazioni sui <bpt id="p1">[</bpt>tipi di portabilità in .NET Core<ept id="p1">](../deploying/index.md)</ept> per conoscere i diversi tipi di applicazione e il modo in cui vengono distribuiti.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>You need to make some changes to your <ph id="ph1">`project.json`</ph> file to direct the tools to build a self-contained application.</source>
          <target state="translated">È necessario apportare alcune modifiche al file <ph id="ph1">`project.json`</ph> per indicare agli strumenti di compilare un'applicazione autonoma.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>You can see these in the <bpt id="p1">[</bpt>HelloNative<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/HelloNative)</ept> project in the samples directory.</source>
          <target state="translated">Le modifiche richieste sono illustrate nel progetto <bpt id="p1">[</bpt>HelloNative<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/HelloNative)</ept> nella directory degli esempi.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The first change is to remove the <ph id="ph1">`"type": "platform"`</ph> element from all dependencies.</source>
          <target state="translated">La prima modifica consiste nel rimuovere l'elemento <ph id="ph1">`"type": "platform"`</ph> da tutte le dipendenze.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This project's only dependency so far is <ph id="ph1">`"Microsoft.NETCore.App"`</ph>.</source>
          <target state="translated">Finora, l'unica dipendenza del progetto è <ph id="ph1">`"Microsoft.NETCore.App"`</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`dependencies`</ph> section should look like this:</source>
          <target state="translated">La sezione <ph id="ph1">`dependencies`</ph> assumerà un aspetto simile al seguente:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Next, you need to add a <ph id="ph1">`runtimes`</ph> node to specify all the target execution environments.</source>
          <target state="translated">Successivamente, è necessario aggiungere un nodo <ph id="ph1">`runtimes`</ph> per specificare tutti gli ambienti di esecuzione di destinazione.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For example, the following <ph id="ph1">`runtimes`</ph> node instructs the build system to create executables for the 64 bit version of Windows 10 and the 64 bit version of Mac OS X version 10.11.</source>
          <target state="translated">Ad esempio, il nodo <ph id="ph1">`runtimes`</ph> seguente indica al sistema di compilazione di creare file eseguibili per la versione a 64 bit di Windows 10 e la versione a 64 bit di Mac OS X 10.11.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The build system will generate native executables for the current environment.</source>
          <target state="translated">Il sistema di compilazione genererà file eseguibili nativi per l'ambiente corrente.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If you are following these steps on a Windows machine, you'll build a Windows executable.</source>
          <target state="translated">Se si seguono questi passaggi in un computer Windows, verrà creato un file eseguibile per Windows.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If you are following these steps on a Mac, you'll build the OS X executable.</source>
          <target state="translated">Se si seguono questi passaggi in un computer Mac, verrà creato un file eseguibile per OS X.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>See the full list of supported runtimes in the <bpt id="p1">[</bpt>RID catalog<ept id="p1">](../rid-catalog.md)</ept>.</source>
          <target state="translated">Visualizzare l'elenco completo dei runtime supportati nel <bpt id="p1">[</bpt>catalogo RID<ept id="p1">](../rid-catalog.md)</ept>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>After making those two changes you execute <ph id="ph1">`dotnet restore`</ph>, followed by <ph id="ph2">`dotnet build`</ph> to create the native executable.</source>
          <target state="translated">Dopo aver apportato queste due modifiche, eseguire <ph id="ph1">`dotnet restore`</ph>, seguito da <ph id="ph2">`dotnet build`</ph> per creare il file eseguibile nativo.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Then, you can run the generated native executable.</source>
          <target state="translated">Sarà quindi possibile eseguire il file eseguibile nativo generato.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The following example shows the commands for Windows.</source>
          <target state="translated">L'esempio seguente mostra i comandi per Windows.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The example shows where the native executable gets generated and assumes that the project directory is named HelloNative.</source>
          <target state="translated">Nell'esempio è indicato il percorso in cui viene generato il file eseguibile nativo e si presuppone che la directory del progetto sia denominata HelloNative.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You may notice that the native application takes slightly longer to build, but executes slightly faster.</source>
          <target state="translated">È possibile notare che l'applicazione nativa richiede leggermente più tempo per la compilazione, ma viene eseguita con una velocità leggermente maggiore.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This behavior becomes more noticeable as the application grows.</source>
          <target state="translated">Questo comportamento diventa più evidente con la crescita delle dimensioni dell'applicazione.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The build process generates several more files when your <ph id="ph1">`project.json`</ph> creates a native build.</source>
          <target state="translated">Il processo di compilazione genera alcuni altri file quando <ph id="ph1">`project.json`</ph> crea una build nativa.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>These files are created in <ph id="ph1">`bin\Debug\netcoreapp1.0\&lt;platform&gt;`</ph> where <ph id="ph2">`&lt;platform&gt;`</ph> is the RID chosen.</source>
          <target state="translated">Questi file vengono creati in <ph id="ph1">`bin\Debug\netcoreapp1.0\&lt;platform&gt;`</ph>, dove <ph id="ph2">`&lt;platform&gt;`</ph> è il RID selezionato.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In addition to the project's <ph id="ph1">`HelloNative.dll`</ph> there is a <ph id="ph2">`HelloNative.exe`</ph> that loads the runtime and starts the application.</source>
          <target state="translated">Oltre al file <ph id="ph1">`HelloNative.dll`</ph> del progetto è presente un file <ph id="ph2">`HelloNative.exe`</ph> che carica il runtime e avvia l'applicazione.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Note that the name of the generated application changed because the project directory's name has changed.</source>
          <target state="translated">Si noti che il nome dell'applicazione generata è cambiato in base al nuovo nome della directory del progetto.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You may want to package this application to execute it on a machine that does not include the .NET runtime.</source>
          <target state="translated">Può essere opportuno creare un pacchetto dell'applicazione per eseguirlo in un computer che non include il runtime .NET.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You do that using the <ph id="ph1">`dotnet publish`</ph> command.</source>
          <target state="translated">Per ottenere questo risultato, eseguire il comando <ph id="ph1">`dotnet publish`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`dotnet publish`</ph> command creates a new subdirectory under the <ph id="ph2">`./bin/Debug/netcoreapp1.0/&lt;platform&gt;`</ph> directory called <ph id="ph3">`publish`</ph>.</source>
          <target state="translated">Il comando <ph id="ph1">`dotnet publish`</ph> crea una nuova sottodirectory denominata <ph id="ph3">`publish`</ph> all'interno della directory <ph id="ph2">`./bin/Debug/netcoreapp1.0/&lt;platform&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It copies the executable, all dependent DLLs and the framework to this sub directory.</source>
          <target state="translated">Copia il file eseguibile, tutte le DLL dipendenti e il framework in questa sottodirectory.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can package that directory to another machine (or a container) and execute the application there.</source>
          <target state="translated">È possibile creare un pacchetto di tale directory e trasferirlo in un altro computer (o in un contenitore) e quindi eseguire l'applicazione da tale posizione.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Let's contrast that with the behavior of <ph id="ph1">`dotnet publish`</ph> in the first Hello World sample.</source>
          <target state="translated">Si metta a confronto questo comportamento con quello di <ph id="ph1">`dotnet publish`</ph> nel primo esempio Hello World.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>That application is a <bpt id="p1">*</bpt>portable application<ept id="p1">*</ept>, which is the default type of application for .NET Core.</source>
          <target state="translated">In tale esempio, l'applicazione è di tipo <bpt id="p1">*</bpt>portabile<ept id="p1">*</ept>, ovvero il tipo predefinito delle applicazioni per .NET Core.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A portable application requires that .NET Core is installed on the target machine.</source>
          <target state="translated">Per un'applicazione portabile è necessario che .NET Core sia installato nel computer di destinazione.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Portable applications can be built on one machine and executed anywhere.</source>
          <target state="translated">Le applicazioni portabili possono essere compilate in un computer ed eseguite da un'altra postazione.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Native applications must be built separately for each target machine.</source>
          <target state="translated">Le applicazioni native devono essere compilate separatamente per ogni computer di destinazione.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dotnet publish`</ph> creates a directory that has the application's DLL, and any dependent dlls that are not part of the platform installation.</source>
          <target state="translated"><ph id="ph1">`dotnet publish`</ph> crea una directory con la DLL dell'applicazione ed eventuali DLL dipendenti che non fanno parte dell'installazione della piattaforma.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Augmenting the program</source>
          <target state="translated">Possibilità di espansione del programma</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Let's change the file just a little bit.</source>
          <target state="translated">È possibile apportare modifiche al file del programma.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Fibonacci numbers are fun, so let's try that out (using the native version):</source>
          <target state="translated">Ad esempio, si può provare a inserire i numeri di Fibonacci (usando la versione nativa):</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Program.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`Program.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>And running the program (assuming you're on Windows, and have changed the project directory name to Fibonacci):</source>
          <target state="translated">E quindi eseguire il programma (si presuppone che il file venga eseguito in Windows e il nome della directory del progetto è stato modificato in Fibonacci):</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">L'operazione è ora completata.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You can augment <ph id="ph1">`Program.cs`</ph> any way you like.</source>
          <target state="translated"><ph id="ph1">`Program.cs`</ph> offre innumerevoli possibilità di espansione.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Adding some new files</source>
          <target state="translated">Aggiunta di nuovi file</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Single files are fine for simple one-off programs, but chances are you're going to want to break things out into multiple files if you're building anything which has multiple components.</source>
          <target state="translated">Per i programmi semplici sono sufficienti singoli file, ma è probabile che sia opportuno suddividere il codice in più file se si creano programmi con più componenti.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Multiple files are a way to do that.</source>
          <target state="translated">Un progetto con più file può offrire una buona soluzione.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Create a new file and give it a unique namespace:</source>
          <target state="translated">Creare un nuovo file e assegnargli uno spazio dei nomi univoco:</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Next, include it in your <ph id="ph1">`Program.cs`</ph> file:</source>
          <target state="translated">Includerlo quindi nel file <ph id="ph1">`Program.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>And finally, you can build it:</source>
          <target state="translated">E infine eseguire la compilazione:</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Now the fun part: making the new file do something!</source>
          <target state="translated">A questo punto è possibile passare alla parte più divertente della procedura: rendere operativo il nuovo file.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Example: A Fibonacci Sequence Generator</source>
          <target state="translated">Esempio: Generatore della sequenza di Fibonacci</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Let's say you want to build off of the previous <bpt id="p1">[</bpt>Fibonacci example<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/Fibonacci)</ept> by caching some Fibonacci values and add some recursive flair.</source>
          <target state="translated">Si supponga di voler sviluppare il precedente <bpt id="p1">[</bpt>esempio di sequenza di Fibonacci<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/Fibonacci)</ept> memorizzando nella cache alcuni valori di Fibonacci e aggiungendo alcune ricorsività.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Your code for a <bpt id="p1">[</bpt>better Fibonacci example<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/FibonacciBetter)</ept> might look something like this:</source>
          <target state="translated">Il codice per un <bpt id="p1">[</bpt>esempio di sequenza di Fibonacci migliore<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/FibonacciBetter)</ept> potrebbe avere un aspetto simile al seguente:</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Note that the use of <ph id="ph1">`Dictionary&lt;int, int&gt;`</ph> and <ph id="ph2">`IEnumerable&lt;int&gt;`</ph> means incorporating the <ph id="ph3">`System.Collections`</ph> namespace.</source>
          <target state="translated">Si noti che l'uso di <ph id="ph1">`Dictionary&lt;int, int&gt;`</ph> e <ph id="ph2">`IEnumerable&lt;int&gt;`</ph> implica l'inclusione dello spazio dei nomi <ph id="ph3">`System.Collections`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Microsoft.NetCore.App`</ph> package is a <bpt id="p1">*</bpt>metapackage<ept id="p1">*</ept> that contains many of the core assemblies from the .NET Framework.</source>
          <target state="translated">Il pacchetto <ph id="ph1">`Microsoft.NetCore.App`</ph> è un <bpt id="p1">*</bpt>metapacchetto<ept id="p1">*</ept> che contiene molti degli assembly principali di .NET Framework.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>By including this metapackage, you've already included the <ph id="ph1">`System.Collections.dll`</ph> assembly as part of your project.</source>
          <target state="translated">Se si include questo metapacchetto, l'assembly <ph id="ph1">`System.Collections.dll`</ph> risulterà già incluso nel progetto.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can verify this by running <ph id="ph1">`dotnet publish`</ph> and examining the files that are part of the installed package.</source>
          <target state="translated">È possibile verificarlo eseguendo <ph id="ph1">`dotnet publish`</ph> ed esaminando i file che fanno parte del pacchetto installato.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>You'll see <ph id="ph1">`System.Collections.dll`</ph> in the list.</source>
          <target state="translated"><ph id="ph1">`System.Collections.dll`</ph> risulterà incluso nell'elenco.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Now adjust the <ph id="ph1">`Main()`</ph> method in your <ph id="ph2">`Program.cs`</ph> file as shown below.</source>
          <target state="translated">A questo punto, modificare il metodo <ph id="ph1">`Main()`</ph> nel file <ph id="ph2">`Program.cs`</ph>, come illustrato di seguito.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The example assumes that <ph id="ph1">`Program.cs`</ph> has a <ph id="ph2">`using System;`</ph> statement.</source>
          <target state="translated">L'esempio presuppone che <ph id="ph1">`Program.cs`</ph> abbia un'istruzione <ph id="ph2">`using System;`</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If you have a <ph id="ph1">`using static System.Console;`</ph> statement, remove <ph id="ph2">`Console.`</ph> from <ph id="ph3">`Console.WriteLine`</ph>.</source>
          <target state="translated">Se è presente un' istruzione <ph id="ph1">`using static System.Console;`</ph>, rimuovere <ph id="ph2">`Console.`</ph> da <ph id="ph3">`Console.WriteLine`</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Finally, run it!</source>
          <target state="translated">Infine, eseguire l'applicazione.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">L'operazione è ora completata.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Using folders to organize code</source>
          <target state="translated">Uso di cartelle per organizzare il codice</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Say you wanted to introduce some new types to do work on.</source>
          <target state="translated">Si supponga di voler introdurre alcuni nuovi tipi su cui lavorare.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>You can do this by adding more files and making sure to give them namespaces you can include in your <ph id="ph1">`Program.cs`</ph> file.</source>
          <target state="translated">A tale scopo è possibile aggiungere altri file assicurandosi di assegnare loro spazi dei nomi che possono essere inclusi nel file <ph id="ph1">`Program.cs`</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This works great when the size of your project is relatively small.</source>
          <target state="translated">Questa è un'ottima soluzione quando le dimensioni del progetto sono relativamente piccole.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>However, if you have a larger app with many different data types and potentially multiple layers, you may wish to organize things logically.</source>
          <target state="translated">Tuttavia, se si ha un'applicazione più grande con molti tipi di dati diversi e potenzialmente più livelli, può essere opportuno organizzare i dati in maniera logica.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This is where folders come into play.</source>
          <target state="translated">A questo punto entrano in gioco le cartelle.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can either follow along with <bpt id="p1">[</bpt>the NewTypes sample project<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/NewTypes)</ept> that this guide covers, or create your own files and folders.</source>
          <target state="translated">È possibile seguire <bpt id="p1">[</bpt>il progetto di esempio NewTypes<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/NewTypes)</ept> descritto in questa guida o creare file e cartelle personalizzati.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>To begin, create a new folder under the root of your project.</source>
          <target state="translated">Per iniziare, creare una nuova cartella sotto la radice del progetto.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`/Model`</ph> is chosen here.</source>
          <target state="translated"><ph id="ph1">`/Model`</ph> è la cartella scelta in questo esempio.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Now add some new types to the folder:</source>
          <target state="translated">Aggiungere ora alcuni nuovi tipi nella cartella:</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Now, just as if they were files in the same directory, give them all the same namespace so you can include them in your <ph id="ph1">`Program.cs`</ph>.</source>
          <target state="translated">Come per i file presenti in una stessa directory, assegnare a tutti i tipi lo stesso spazio dei nomi in modo da poterli includere in <ph id="ph1">`Program.cs`</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Example: Pet Types</source>
          <target state="translated">Esempio: Tipi di animali domestici</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This example creates two new types, <ph id="ph1">`Dog`</ph> and <ph id="ph2">`Cat`</ph>, and has them implement an interface, <ph id="ph3">`IPet`</ph>.</source>
          <target state="translated">In questo esempio vengono creati due nuovi tipi, <ph id="ph1">`Dog`</ph> e <ph id="ph2">`Cat`</ph>, che implementano un'interfaccia, <ph id="ph3">`IPet`</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Folder Structure:</source>
          <target state="translated">Struttura di cartelle:</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`IPet.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`IPet.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Dog.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`Dog.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Cat.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`Cat.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Program.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`Program.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`project.json`</ph>:</source>
          <target state="translated"><ph id="ph1">`project.json`</ph>:</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>And if you run this:</source>
          <target state="translated">E se si esegue questo codice:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>New pet types can be added (such as a <ph id="ph1">`Bird`</ph>), extending this project.</source>
          <target state="translated">È possibile aggiungere nuovi tipi di animali domestici (come <ph id="ph1">`Bird`</ph>) estendendo il progetto.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Testing your Console App</source>
          <target state="translated">Test dell'applicazione console</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>You'll probably be wanting to test your projects at some point.</source>
          <target state="translated">È probabile che a un certo punto si decida di testare i progetti.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Here's a good way to do it:</source>
          <target state="translated">Ecco un buon metodo per eseguire questa operazione:</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Move any source of your existing project into a new <ph id="ph1">`src`</ph> folder.</source>
          <target state="translated">Spostare l'origine del progetto esistente in una nuova cartella <ph id="ph1">`src`</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Create a <ph id="ph1">`/test`</ph> directory.</source>
          <target state="translated">Creare una directory <ph id="ph1">`/test`</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Create a new <ph id="ph1">`global.json`</ph> file:</source>
          <target state="translated">Creare un nuovo file <ph id="ph1">`global.json`</ph>:</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`global.json`</ph>:</source>
          <target state="translated"><ph id="ph1">`global.json`</ph>:</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>This file tells the build system that this is a multi-project system, which allows it to look for dependencies in more than just the current folder it happens to be executing in.</source>
          <target state="translated">Il file indica al sistema di compilazione che il sistema è basato più progetti. È quindi possibile cercare le dipendenze in più percorsi e non soltanto nella cartella corrente su cui è in esecuzione.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>This is important because it allows you to place a dependency on the code under test in your test project.</source>
          <target state="translated">Questo è importante perché consente di inserire una dipendenza sul codice da testare nel progetto di test.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Example: Extending the NewTypes project</source>
          <target state="translated">Esempio: Estensione del progetto NewTypes</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Now that the project system is in place, you can create your test project and start writing tests!</source>
          <target state="translated">Ora che il sistema del progetto è stato creato, è possibile creare il progetto di test e iniziare a scrivere i test.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>From here on out, this guide will use and extend <bpt id="p1">[</bpt>the sample Types project<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/NewTypes)</ept>.</source>
          <target state="translated">A partire da questo punto, nella guida verrà usato ed esteso <bpt id="p1">[</bpt>il progetto NewTypes di esempio<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/NewTypes)</ept>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Additionally, it will use the <bpt id="p1">[</bpt>Xunit<ept id="p1">](https://xunit.github.io/)</ept> test framework.</source>
          <target state="translated">Inoltre, verrà usato il framework di test <bpt id="p1">[</bpt>xUnit<ept id="p1">](https://xunit.github.io/)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Feel free to follow along or create your own multi-project system with tests.</source>
          <target state="translated">È possibile proseguire o creare un sistema personalizzato basato su più progetti con test.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The whole project structure should look like this:</source>
          <target state="translated">La struttura dell'intero progetto avrà un aspetto simile al seguente:</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>There are two new things to make sure you have in your test project:</source>
          <target state="translated">È necessario verificare che nel progetto di test siano presenti due nuovi elementi:</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>A correct <ph id="ph1">`project.json`</ph> with the following:</source>
          <target state="translated">Un file <ph id="ph1">`project.json`</ph> corretto con i riferimenti seguenti:</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>A reference to <ph id="ph1">`xunit`</ph></source>
          <target state="translated">Un riferimento a <ph id="ph1">`xunit`</ph></target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>A reference to <ph id="ph1">`dotnet-test-xunit`</ph></source>
          <target state="translated">Un riferimento a <ph id="ph1">`dotnet-test-xunit`</ph></target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>A reference to the namespace corresponding to the code under test</source>
          <target state="translated">Un riferimento allo spazio dei nomi corrispondente al codice sottoposto a test</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>An Xunit test class.</source>
          <target state="translated">Una classe di test xUnit.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`NewTypesTests/project.json`</ph>:</source>
          <target state="translated"><ph id="ph1">`NewTypesTests/project.json`</ph>:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`PetTests.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`PetTests.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Now you can run tests!</source>
          <target state="translated">A questo punto è possibile eseguire i test.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt><ph id="ph1">`dotnet test`</ph><ept id="p1">](../tools/dotnet-test.md)</ept> command runs the test runner you have specified in your project.</source>
          <target state="translated">Il comando <bpt id="p1">[</bpt><ph id="ph1">`dotnet test`</ph><ept id="p1">](../tools/dotnet-test.md)</ept> esegue il Test Runner specificato nel progetto.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Make sure you start at the top-level directory.</source>
          <target state="translated">Assicurarsi di iniziare dalla directory di livello più alto.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Output should look like this:</source>
          <target state="translated">L'output dovrebbe essere simile al seguente:</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusione</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Hopefully this guide has helped you learn how to create a .NET Core console app, from the basics all the way up to a multi-project system with unit tests.</source>
          <target state="translated">Questa guida ha illustrato le procedure per creare un'applicazione console .NET Core, a partire dalle funzionalità di base fino a un sistema basato su più progetti con unit test.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The next step is to create awesome console apps of your own!</source>
          <target state="translated">Il passaggio successivo sarà quello di creare eccezionali applicazioni console personalizzate.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>If a more advanced example of a console app interests you, check out the next tutorial: <bpt id="p1">[</bpt>Using the CLI tools to write console apps: An advanced step-by-step guide<ept id="p1">](cli-console-app-tutorial-advanced.md)</ept>.</source>
          <target state="translated">Per un esempio più avanzato di un'applicazione console, esaminare l'esercitazione successiva: <bpt id="p1">[</bpt>Scrittura di applicazioni console .NET Core mediante gli strumenti dell'interfaccia della riga di comando: guida dettagliata avanzata<ept id="p1">](cli-console-app-tutorial-advanced.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>