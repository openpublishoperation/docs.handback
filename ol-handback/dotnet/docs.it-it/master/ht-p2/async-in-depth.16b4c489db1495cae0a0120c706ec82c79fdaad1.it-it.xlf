<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6536a608a4ee1bb10f41907a28114193a300a52c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\async-in-depth.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4a59cc5bc6b7d68b057f06623b3cc2f09799a72f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0300c978d5652352126d5e8e8e0c9370ad283890</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Async in depth</source>
          <target state="translated">La programmazione asincrona in dettaglio</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>In-depth explanation of how asynchronous code works in .NET</source>
          <target state="translated">Spiegazione approfondita di come funziona il codice asincrono in .NET</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, .NET Standard</source>
          <target state="translated">.NET, .NET Core, .NET standard</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Async in depth</source>
          <target state="translated">La programmazione asincrona in dettaglio</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</source>
          <target state="translated">La scrittura di codice asincrono associato a I/O e CPU risulta notevolmente semplificata dall'uso del modello asincrono basato su attività di .NET.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The model is exposed by the <ph id="ph1">`Task`</ph> and <ph id="ph2">`Task&lt;T&gt;`</ph> types and the <ph id="ph3">`async`</ph> and <ph id="ph4">`await`</ph> language keywords.</source>
          <target state="translated">Il modello viene esposto dai tipi <ph id="ph1">`Task`</ph> e <ph id="ph2">`Task&lt;T&gt;`</ph> e dalle parole chiave del linguaggio <ph id="ph3">`async`</ph> e <ph id="ph4">`await`</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This article explains how to use .NET async and provides insight into the async framework used under the covers.</source>
          <target state="translated">In questo articolo viene illustrato come usare il codice asincrono di .NET e vengono specificate informazioni approfondite sul framework asincrono che ne è alla base.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Task and Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph></source>
          <target state="translated">Task e Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Tasks are constructs used to implement what is known as the <bpt id="p1">[</bpt>Promise Model of Concurrency<ept id="p1">](https://en.wikipedia.org/wiki/Futures_and_promises)</ept>.</source>
          <target state="translated">Le attività sono costrutti usati per implementare il cosiddetto <bpt id="p1">[</bpt>Modello di concorrenza basato su promise<ept id="p1">](https://en.wikipedia.org/wiki/Futures_and_promises)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</source>
          <target state="translated">In poche parole offrono la "promessa" che il lavoro verrà completato in un secondo memento, consentendo all'utente di coordinare la promessa con un'API nuova.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task`</ph> represents a single operation which does not return a value.</source>
          <target state="translated"><ph id="ph1">`Task`</ph> rappresenta una singola operazione che non restituisce alcun valore.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task&lt;T&gt;`</ph> represents a single operation which returns a value of type <ph id="ph2">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Task&lt;T&gt;`</ph> rappresenta una singola operazione che restituisce un valore di tipo <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It’s important to reason about tasks as abstractions of work happening asynchronously, and <bpt id="p1">*</bpt>not<ept id="p1">*</ept> an abstraction over threading.</source>
          <target state="translated">È importante considerare le attività come astrazioni del lavoro che si svolge in modo asincrono e <bpt id="p1">*</bpt>non<ept id="p1">*</ept> un'astrazione sul threading.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</source>
          <target state="translated">Per impostazione predefinita, le attività vengono eseguite sul thread corrente e delegano il lavoro al sistema operativo, in base alle necessità.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Optionally, tasks can be be explicitly requested to run on a separate thread via the <ph id="ph1">`Task.Run`</ph> API.</source>
          <target state="translated">Facoltativamente, le attività possono essere esplicitamente richieste per l'esecuzione in un thread separato tramite l'API <ph id="ph1">`Task.Run`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of <ph id="ph1">`Task&lt;T&gt;`</ph>) of a task.</source>
          <target state="translated">Le attività espongono un protocollo di API per il monitoraggio, attendendo il valore risultante di un'attività cui poi accedono (nel caso di <ph id="ph1">`Task&lt;T&gt;`</ph>).</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Language integration, with the <ph id="ph1">`await`</ph> keyword, provides a higher-level abstraction for using tasks.</source>
          <target state="translated">L'integrazione del linguaggio, con la parola chiave <ph id="ph1">`await`</ph>, offre un'astrazione di livello superiore per l'uso delle attività.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Using <ph id="ph1">`await`</ph> allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</source>
          <target state="translated">L'uso di <ph id="ph1">`await`</ph> consente all'applicazione o al servizio di eseguire operazioni utili mentre viene eseguita un'attività, cedendo il controllo al chiamante fino al completamento dell'attività.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</source>
          <target state="translated">Non è necessario che il codice si basi su callback o eventi perché continui a essere eseguito dopo il completamento dell'attività.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The language and task API integration does that for you.</source>
          <target state="translated">Sono il linguaggio e l'integrazione dell'API dell'attività a occuparsi di questo.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If you’re using <ph id="ph1">`Task&lt;T&gt;`</ph>, the <ph id="ph2">`await`</ph> keyword will additionally “unwrap” the value returned when the Task is complete.</source>
          <target state="translated">Se si usa <ph id="ph1">`Task&lt;T&gt;`</ph>, al completamento dell'attività la parola chiave <ph id="ph2">`await`</ph> "dispiegherà" ulteriormente il valore restituito.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The details of how this works are explained further below.</source>
          <target state="translated">I dettagli di questo processo sono illustrati più sotto.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can learn more about tasks and the different ways to interact with them in the <bpt id="p1">[</bpt>Task-based Asynchronous Pattern (TAP) Article<ept id="p1">](https://msdn.microsoft.com/library/hh873175.aspx)</ept>.</source>
          <target state="translated">Per altre informazioni sulle attività e i diversi modi per interagire con esse, vedere l'articolo <bpt id="p1">[</bpt>Task-based Asynchronous Pattern (TAP)<ept id="p1">](https://msdn.microsoft.com/library/hh873175.aspx)</ept> (Modello asincrono basato su attività).</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Deeper Dive into Tasks for an I/O-Bound Operation</source>
          <target state="translated">Approfondimento sulle attività per un'operazione associata ai I/O</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following section describes a 10,000 foot view of what happens with a typical async I/O call.</source>
          <target state="translated">La sezione seguente offre una panoramica di ciò che accade con una chiamata I/O asincrona tipica.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Let's start with a couple examples.</source>
          <target state="translated">Iniziamo con alcuni esempi.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The first example calls an async method and returns an active task, likely yet to complete.</source>
          <target state="translated">Nel primo esempio viene chiamato un metodo asincrono e viene restituita un'attività attiva, ancora da completare.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The second example adds the use of he <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords to operate on the task.</source>
          <target state="translated">Nel secondo esempio viene aggiunto l'uso delle parole chiave <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph> per il funzionamento dell'attività.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The call to <ph id="ph1">`GetStringAsync()`</ph> calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</source>
          <target state="translated">La chiamata a <ph id="ph1">`GetStringAsync()`</ph> chiama le librerie .NET di livello inferiore, che possono chiamare altri metodi asincroni, finché non raggiunge le chiamate all'interoperabilità P/Invoke in una libreria di rete nativa.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The native library may subsequently call into a System API call (such as <ph id="ph1">`write()`</ph> to a socket on Linux).</source>
          <target state="translated">Successivamente, la libreria nativa può eseguire una chiamata in una chiamata API di sistema, come ad esempio <ph id="ph1">`write()`</ph> in un socket in Linux.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A task object will be created at the native/managed boundary, possibly using <bpt id="p1">[</bpt>TaskCompletionSource<ept id="p1">](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))</ept>.</source>
          <target state="translated">Verrà creato un oggetto attività al limite nativo/gestito, usando possibilmente <bpt id="p1">[</bpt>TaskCompletionSource<ept id="p1">](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))</ept>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</source>
          <target state="translated">L'oggetto attività verrà passato attraverso i livelli, attraverso operazioni o restituzione diretta, e alla fine verrà restituito al chiamante iniziale.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In the second example above, a <ph id="ph1">`Task&lt;T&gt;`</ph> object will be returned from <ph id="ph2">`GetStringAsync`</ph>.</source>
          <target state="translated">Nel secondo esempio qui sopra, un oggetto <ph id="ph1">`Task&lt;T&gt;`</ph> viene restituito da <ph id="ph2">`GetStringAsync`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The use of the <ph id="ph1">`await`</ph> keyword causes the method to return a newly created task object.</source>
          <target state="translated">L'uso della parola chiave <ph id="ph1">`await`</ph> fa sì che il metodo restituisca un oggetto attività nuovo.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Control returns to the caller from this location in the <ph id="ph1">`GetFirstCharactersCountAsync`</ph> method.</source>
          <target state="translated">Il controllo ritorna al chiamante da questa posizione nel metodo <ph id="ph1">`GetFirstCharactersCountAsync`</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The methods and properties of the <bpt id="p1">[</bpt>Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Threading.Tasks.Task%601)</ept> object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</source>
          <target state="translated">I metodi e le proprietà dell'oggetto <bpt id="p1">[</bpt>Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Threading.Tasks.Task%601)</ept> consentono ai chiamanti di controllare l'avanzamento dell'attività che verrà completata quando il codice rimanente in GetFirstCharactersCountAsync sarà stato eseguito.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as <ph id="ph1">`/net`</ph> in the Linux Kernel).</source>
          <target state="translated">Dopo la chiamata all'API di sistema, la richiesta si trova nello spazio del kernel, in direzione del sottosistema di rete del sistema operativo, ad esempio <ph id="ph1">`/net`</ph> in Linux Kernel.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Here the OS will handle the networking request <bpt id="p1">*</bpt>asynchronously<ept id="p1">*</ept>.</source>
          <target state="translated">A questo punto il sistema operativo gestisce la richiesta di rete <bpt id="p1">*</bpt>in modo asincrono<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and <bpt id="p1">*</bpt>then<ept id="p1">*</ept> a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</source>
          <target state="translated">I dettagli possono variare a seconda del sistema operativo usato. La chiamata del driver di dispositivo può essere pianificata come un segnale reinviato al runtime oppure può essere eseguita una chiamata del driver di dispositivo e <bpt id="p1">*</bpt>successivamente<ept id="p1">*</ept> il segnale viene reinviato. Alla fine comunque l'informazione che la richiesta di rete è in corso arriverà al runtime.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</source>
          <target state="translated">A questo punto, il lavoro per il driver di dispositivo sarà pianificato, in corso o già completato (la richiesta è già "in rete"), ma poiché tutto ciò accade in modo asincrono, il driver di dispositivo può gestire immediatamente un'altra operazione.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</source>
          <target state="translated">Ad esempio, in Windows un thread del sistema operativo esegue una chiamata al driver di dispositivo di rete e richiede di eseguire l'operazione di rete tramite un pacchetto di richiesta di interrupt che rappresenta l'operazione.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</source>
          <target state="translated">Il driver di dispositivo riceve il pacchetto, esegue la chiamata alla rete, contrassegna il pacchetto come "in sospeso" e lo restituisce al sistema operativo.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</source>
          <target state="translated">Poiché a questo punto il thread del sistema operativo è a conoscenza del fatto che il pacchetto sia "in sospeso", non ha altro lavoro da eseguire per il processo e lo "restituisce" in modo che possa essere usato per eseguire altre operazioni.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</source>
          <target state="translated">Quando la richiesta viene soddisfatta e i dati vengono restituiti tramite il driver di dispositivo, viene inviata una notifica alla CPU del ricevimento dei nuovi dati tramite un interrupt.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</source>
          <target state="translated">La modalità con cui viene gestito l'interrpt varia a seconda del sistema operativo, ma alla fine i dati vengono passati tramite il sistema operativo finché non raggiungono una chiamata di interoperabilità di sistema. Ad esempio, in Linux un gestore di interrupt pianificherà la metà inferiore dell'IRQ perché passi i dati nel sistema operativo in modo asincrono.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Note that this <bpt id="p1">*</bpt>also<ept id="p1">*</ept> happens asynchronously!</source>
          <target state="translated">Si noti che <bpt id="p1">*</bpt>anche<ept id="p1">*</ept> questo avviene in modo asincrono.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The result is queued up until the next available thread is able execute the async method and "unwrap" the result of the completed task.</source>
          <target state="translated">Il risultato viene inserito in coda fino a quando il thread disponibile successivo può eseguire il metodo asincrono e "dispiegare" il risultato dell'attività completata.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Throughout this entire process, a key takeaway is that <bpt id="p1">**</bpt>no thread is dedicated to running the task<ept id="p1">**</ept>.</source>
          <target state="translated">In tutto questo processo il punto chiave è che <bpt id="p1">**</bpt>nessun thread è dedicato all'esecuzione dell'attività<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Although work is executed in some context (i.e. the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to <bpt id="p1">*</bpt>waiting<ept id="p1">*</ept> for data from the request to come back.</source>
          <target state="translated">Sebbene il lavoro venga eseguito in un determinato contesto, ad esempio il sistema operativo deve passare i dati a un driver di dispositivo e rispondere a un interrupt, nessun thread è dedicato ad <bpt id="p1">*</bpt>attendere<ept id="p1">*</ept> che i dati della richiesta ritornino.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</source>
          <target state="translated">Ciò consente al sistema di gestire un volume di lavoro maggiore, anziché attendere il completamento delle chiamate I/O.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</source>
          <target state="translated">Tutto ciò può sembrare una mole di lavoro davvero imponente ma, se misurato in termini di tempo, è solo una frazione minima di quanto occorre per il lavoro I/O effettivo.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Although not at all precise, a potential timeline for such a call would look like this:</source>
          <target state="translated">Anche se tutt'altro che precisa, la seguente potrebbe essere la sequenza temporale per tale chiamata:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>0-1————————————————————————————————————————————————–2-3</source>
          <target state="translated">0-1————————————————————————————————————————————————–2-3</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Time spent from points <ph id="ph1">`0`</ph> to <ph id="ph2">`1`</ph> is everything up until an async method yields control to its caller.</source>
          <target state="translated">Il tempo impiegato dai punti <ph id="ph1">`0`</ph> a <ph id="ph2">`1`</ph> è tutto quanto accade fino a quando un metodo asincrono cede il controllo al chiamante.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Time spent from points <ph id="ph1">`1`</ph> to <ph id="ph2">`2`</ph> is the time spent on I/O, with no CPU cost.</source>
          <target state="translated">Il tempo impiegato dai punti <ph id="ph1">`1`</ph> a <ph id="ph2">`2`</ph> è il tempo dedicato alle chiamate I/O senza alcun costo della CPU.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Finally, time spent from points <ph id="ph1">`2`</ph> to <ph id="ph2">`3`</ph> is passing control back (and potentially a value) to the async method, at which point it is executing again.</source>
          <target state="translated">Infine, il tempo impiegato dai punti <ph id="ph1">`2`</ph> a <ph id="ph2">`3`</ph> è il passaggio del controllo, e potenzialmente di un valore, nuovamente al metodo asincrono, che a quel punto è ancora in esecuzione.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>What does this mean for a server scenario?</source>
          <target state="translated">Che cosa significa questo in uno scenario server?</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This model works well with a typical server scenario workload.</source>
          <target state="translated">Questo modello funziona bene con un carico di lavoro di uno scenario di server tipico.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</source>
          <target state="translated">Poiché non vi sono thread dedicati per il blocco delle attività non completate, il pool di thread del server può gestire un numero di richieste Web molto maggiore.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Consider two servers: one that runs async code, and one that does not.</source>
          <target state="translated">Prendiamo ad esempio due server: uno esegue codice asincrono, l'altro no.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For the purpose of this example, each server only has 5 threads available to service requests.</source>
          <target state="translated">Ai fini di questo esempio, ogni server ha solo 5 thread disponibili per le richieste di servizio.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Note that these numbers are imaginarily small and serve only in a demonstrative context.</source>
          <target state="translated">Si noti che questi numeri sono molto piccoli e servono solo a scopo dimostrativo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Assume both servers receive 6 concurrent requests.</source>
          <target state="translated">Si supponga che entrambi i server ricevano 6 richieste simultanee.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Each request performs an I/O operation.</source>
          <target state="translated">Ogni richiesta esegue un'operazione I/O.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The server <bpt id="p1">*</bpt>without<ept id="p1">*</ept> async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</source>
          <target state="translated">Il server <bpt id="p1">*</bpt>senza<ept id="p1">*</ept> codice asincrono deve inserire in coda tutte le sei richieste finché uno dei 5 thread non ha completato il lavoro associato a I/O e scritto la risposta.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</source>
          <target state="translated">Nel momento in cui entra la ventesima richiesta il server potrebbe iniziare a rallentare, visto che la coda sta iniziando a diventare troppo lunga.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The server <bpt id="p1">*</bpt>with<ept id="p1">*</ept> async code running on it still queues up the 6th request, but because it uses <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph>, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</source>
          <target state="translated">Il server <bpt id="p1">*</bpt>con<ept id="p1">*</ept> il codice asincrono in esecuzione inserisce in coda tutte le sei richieste ma, dal momento che usa <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph>, tutti i thread vengono liberati all'inizio del lavoro associato a I/O, non al suo completamento.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</source>
          <target state="translated">Quando entra la ventesima richiesta, la coda delle richieste in entrata è molto più piccola, sempre che vi sia una coda in entrata, e il server non risulta rallentato.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Although this is a contrived example, it works in a very similar fashion in the real world.</source>
          <target state="translated">Anche se questo è un esempio artificioso, uno scenario reale funzionerebbe in modo molto simile.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In fact, you can expect a server to be able to handle an order of magnitude more requests using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> than if it were dedicating a thread for each request it receives.</source>
          <target state="translated">Infatti, è assolutamente plausibile che un server sia in grado di gestire un numero molto maggiore di richieste usando <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph> piuttosto che dedicando un thread per ogni richiesta che riceve.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>What does this mean for client scenario?</source>
          <target state="translated">Che cosa significa questo in uno scenario client?</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The biggest gain for using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> for a client app is an increase in responsiveness.</source>
          <target state="translated">Il vantaggio principale dato dall'uso di <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph> per un'app client è un aumento della velocità di risposta.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph>.</source>
          <target state="translated">Sebbene sia possibile creare un'app reattiva generando thread manualmente, l'azione di generazione di un thread è un'operazione dispendiosa rispetto al solo suo di <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</source>
          <target state="translated">Ridurre il più possibile l'impatto sul thread dell'interfaccia utente in materia di I/O è fondamentale, soprattutto per app come un videogame mobile.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</source>
          <target state="translated">E cosa ancora più importante, dal momento che il lavoro associato a I/O virtualmente non passa alcun tempo nella CPU, dedicare un thread della CPU intero all'esecuzione di attività poco utili costituirebbe un uso scarsamente efficiente delle risorse.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with <ph id="ph1">`async`</ph> methods, and does not require extra work (such as calling a thread-safe delegate).</source>
          <target state="translated">Inviare lavoro al thread dell'interfaccia utente, ad esempio l'aggiornamento dell'interfaccia, è anche molto semplice con i metodi <ph id="ph1">`async`</ph> e non richiede operazioni aggiuntive, come ad esempio la chiamata a un delegato thread-safe.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Deeper Dive into Task and Task<ph id="ph1">&lt;T&gt;</ph> for a CPU-Bound Operation</source>
          <target state="translated">Approfondimento delle attività Task e Task<ph id="ph1">&lt;T&gt;</ph> per un'operazione associata alla CPU</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>CPU-bound <ph id="ph1">`async`</ph> code is a bit different than I/O-bound <ph id="ph2">`async`</ph> code.</source>
          <target state="translated">Il codice <ph id="ph1">`async`</ph> associato alla CPU è un po' diverso rispetto al codice <ph id="ph2">`async`</ph> associato a I/O.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</source>
          <target state="translated">Dal momento che il lavoro viene eseguito sulla CPU, non c'è modo di evitare di dedicare un thread al calcolo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The use of <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</source>
          <target state="translated">L'uso di <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph> offre un metodo chiaro per interagire con un thread in background e mantenere reattivo il chiamante del metodo asincrono.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Note that this does not provide any protection for shared data.</source>
          <target state="translated">Si noti che ciò non offre alcuna protezione per i dati condivisi.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If you are using shared data, you will still need to apply an appropriate synchronization strategy.</source>
          <target state="translated">Se si usano dati condivisi, sarà necessario applicare una strategia di sincronizzazione appropriata.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Here's a 10,000 foot view of a CPU-bound async call:</source>
          <target state="translated">Di seguito viene presentata una panoramica della chiamata asincrona associata alla CPU:</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CalculateResult()`</ph> executes on the thread it was called on.</source>
          <target state="translated"><ph id="ph1">`CalculateResult()`</ph> viene eseguito sul thread in cui è stato chiamato.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When it calls <ph id="ph1">`Task.Run`</ph>, it queues the expensive CPU-bound operation, <ph id="ph2">`DoExpensiveCalculation()`</ph>, on the thread pool and receives a <ph id="ph3">`Task&lt;int&gt;`</ph> handle.</source>
          <target state="translated">Quando chiama <ph id="ph1">`Task.Run`</ph>, inserisce in coda l'operazione dispendiosa associata alla CPU, <ph id="ph2">`DoExpensiveCalculation()`</ph>, nel pool di thread e riceve un handle <ph id="ph3">`Task&lt;int&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`DoExpensiveCalculation()`</ph> is eventually run concurrently on the next available thread, likely on another CPU core.</source>
          <target state="translated"><ph id="ph1">`DoExpensiveCalculation()`</ph> viene infine eseguito contemporaneamente nel thread disponibile successivo, probabilmente su un altro core della CPU.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>It's possible to do concurrent work while <ph id="ph1">`DoExpensiveCalculation()`</ph> is busy on another thread, because the thread which called <ph id="ph2">`CalculateResult()`</ph> is still executing.</source>
          <target state="translated">È possibile eseguire attività simultanee mentre <ph id="ph1">`DoExpensiveCalculation()`</ph> è occupato in un altro thread, poiché il thread che ha chiamato <ph id="ph2">`CalculateResult()`</ph> è ancora in esecuzione.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Once <ph id="ph1">`await`</ph> is encountered, the execution of <ph id="ph2">`CalculateResult()`</ph> is yielded to its caller, allowing other work to be done with the current thread while <ph id="ph3">`DoExpensiveCalculation()`</ph> is churning out a result.</source>
          <target state="translated">Quando viene rilevato <ph id="ph1">`await`</ph>, l'esecuzione di <ph id="ph2">`CalculateResult()`</ph> viene ceduta al chiamante, consentendo lo svolgimento di altro lavoro con il thread corrente mentre <ph id="ph3">`DoExpensiveCalculation()`</ph> sta producendo un risultato.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Once it has finished, the result is queued up to run on the main thread.</source>
          <target state="translated">Al termine dell'operazione, il risultato viene inserito in coda per l'esecuzione sul thread principale.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Eventually, the main thread will return to executing <ph id="ph1">`CalculateResult()`</ph>, at which point it will have the result of <ph id="ph2">`DoExpensiveCalculation()`</ph>.</source>
          <target state="translated">Alla fine, il thread principale tornerà all'esecuzione di <ph id="ph1">`CalculateResult()`</ph> e a quel punto sarà disponibile il risultato di <ph id="ph2">`DoExpensiveCalculation()`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Why does async help here?</source>
          <target state="translated">In che modo il codice asincrono risulta utile in questo scenario?</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> are the best practice managing CPU-bound work when you need responsiveness.</source>
          <target state="translated"><ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph> sono la procedura consigliata per la gestione di attività associate alla CPU quando è necessaria velocità di risposta.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>There are multiple patterns for using async with CPU-bound work.</source>
          <target state="translated">Vi sono diversi modelli per l'uso di codice asincrono con attività associate alla CPU.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>It's important to note that there is a small cost to using async and it's not recommended for tight loops.</source>
          <target state="translated">È importante tenere presente che esiste un costo minimo per l'uso del codice asincrono e che tale uso è sconsigliato per cicli ridotti.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>It's up to you to determine how you write your code around this new capability.</source>
          <target state="translated">Spetta all'utente determinare come scrivere il codice in base a questa nuova funzionalità.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>