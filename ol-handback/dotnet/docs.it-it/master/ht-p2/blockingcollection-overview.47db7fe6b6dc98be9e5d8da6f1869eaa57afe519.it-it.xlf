<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">991b4b8389cc967881c2c39d29c387687047489f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\collections\threadsafe\blockingcollection-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ee211c059c42480350d31c938f52419524b3332b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8b625a2430b9030f673248de32b487e185b91756</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="translated">Panoramica di BlockingCollection</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="translated">Panoramica di BlockingCollection</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="translated">Panoramica di BlockingCollection</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> is a thread-safe collection class that provides the following features:</source>
          <target state="translated"><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> è una classe di raccolta thread-safe che offre le funzionalità seguenti:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>An implementation of the Producer-Consumer pattern.</source>
          <target state="translated">Implementazione del modello Producer-Consumer.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Thread-safe addition and removal of items from a collection.</source>
          <target state="translated">Aggiunta e rimozione thread-safe di elementi da una raccolta.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Optional maximum capacity.</source>
          <target state="translated">Capacità massima facoltativa.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Insertion and removal operations that block when collection is empty or full.</source>
          <target state="translated">Operazioni di inserimento e rimozione che si bloccano quando la raccolta è vuota o piena.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Insertion and removal "try" operations that do not block or that block up to a specified period of time.</source>
          <target state="translated">Operazioni "prova" di inserimento e rimozione che non si bloccano o che si bloccano per un periodo di tempo specificato.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Encapsulates any collection type that implements <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>.</source>
          <target state="translated">Incapsulamento di qualsiasi tipo di raccolta che implementi <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Cancellation with cancellation tokens.</source>
          <target state="translated">Annullamento con token di annullamento.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Two kinds of enumeration with <ph id="ph1">`foreach`</ph>:</source>
          <target state="translated">Due tipi di enumerazione con <ph id="ph1">`foreach`</ph>:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Read-only enumeration.</source>
          <target state="translated">Enumerazione di sola lettura.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Enumeration that removes items as they are enumerated.</source>
          <target state="translated">Enumerazione che rimuove gli elementi quando vengono enumerati.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Bounding and Blocking Support</source>
          <target state="translated">Supporto di delimitazione e blocco</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> supports bounding and blocking.</source>
          <target state="translated"><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> supporta delimitazione e blocco.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Bounding means you can set the maximum capacity of the collection.</source>
          <target state="translated">La delimitazione consente di impostare la capacità massima della raccolta.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.</source>
          <target state="translated">La delimitazione è importante in determinati scenari poiché consente di controllare la dimensione massima della raccolta in memoria, impedendo ai thread Producer di spostarsi troppo oltre i thread Consumer.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.</source>
          <target state="translated">Più thread o attività possono aggiungere contemporaneamente elementi alla raccolta, e se la raccolta raggiunge la capacità massima specificata, i thread Producer si bloccano fino a quando non viene rimosso un elemento.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.</source>
          <target state="translated">Più Consumer possono rimuovere contemporaneamente elementi e quando la raccolta diventa vuota, i thread Consumer si bloccano fino a quando un Producer aggiunge un elemento.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>A producing thread can call <ph id="ph1">`CompleteAdding`</ph> to indicate that no more items will be added.</source>
          <target state="translated">Un thread Producer può chiamare <ph id="ph1">`CompleteAdding`</ph> per indicare che non verranno aggiunti altri elementi.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consumers monitor the <ph id="ph1">`IsCompleted`</ph> property to know when the collection is empty and no more items will be added.</source>
          <target state="translated">I Consumer monitorano la proprietà <ph id="ph1">`IsCompleted`</ph> per sapere quando la raccolta è vuota e non verranno aggiunti altri elementi.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The following example shows a simple <ph id="ph1">`BlockingCollection`</ph> with a bounded capacity of 100.</source>
          <target state="translated">Nell'esempio seguente viene illustrato un semplice <ph id="ph1">`BlockingCollection`</ph> con una capacità delimitata di 100.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A producer task adds items to the collection as long as some external condition is true, and then calls <ph id="ph1">`CompleteAdding`</ph>.</source>
          <target state="translated">Un'attività Producer aggiunge elementi alla raccolta, purché una condizione esterna sia true e quindi chiama <ph id="ph1">`CompleteAdding`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The consumer task takes items until the <ph id="ph1">`IsCompleted`</ph> property is true.</source>
          <target state="translated">L'attività di tipo Consumer accetta elementi finché la proprietà <ph id="ph1">`IsCompleted`</ph> è true.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For a complete example, see <bpt id="p1">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</source>
          <target state="translated">Per un esempio completo, vedere <bpt id="p1">[</bpt>Procedura: Aggiungere e rimuovere singoli elementi di un oggetto BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Timed Blocking Operations</source>
          <target state="translated">Operazioni di blocco temporizzate</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In timed blocking <ph id="ph1">`TryAdd`</ph> and <ph id="ph2">`TryTake`</ph> operations on bounded collections, the method tries to add or take an item.</source>
          <target state="translated">Nelle operazioni di blocco temporizzate <ph id="ph1">`TryAdd`</ph> e <ph id="ph2">`TryTake`</ph> sulle raccolte delimitate il metodo tenta di aggiungere o rimuovere un elemento.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If an item is available it is placed into the variable that was passed in by reference, and the method returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Se è disponibile un elemento, questo viene posizionato nella variabile che è stata passata per riferimento e il metodo restituisce <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If no item is retrieved after a specified time-out period the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se dopo un periodo di timeout specificato non viene recuperato alcun elemento, il metodo restituisce <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The thread is then free to do some other useful work before trying again to access the collection.</source>
          <target state="translated">Il thread è quindi libero di eseguire altre operazioni utili prima di tentare nuovamente di accedere alla raccolta.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For an example of timed blocking access, see the second example in <bpt id="p1">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</source>
          <target state="translated">Per un esempio di accesso con blocco temporizzato, vedere il secondo esempio in <bpt id="p1">[</bpt>Procedura: Aggiungere e rimuovere singoli elementi di un oggetto BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Cancelling Add and Take Operations</source>
          <target state="translated">Annullamento di operazioni di aggiunta e rimozione</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Add and Take operations are typically performed in a loop.</source>
          <target state="translated">Le operazioni di aggiunta e rimozione solitamente vengono eseguite in un ciclo.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can cancel a loop by passing in a <ph id="ph1">`CancellationToken`</ph> to the <ph id="ph2">`TryAdd`</ph> or <ph id="ph3">`TryTake`</ph> method, and then checking the value of the token's <ph id="ph4">`IsCancellationRequested`</ph> property on each iteration.</source>
          <target state="translated">È possibile annullare un ciclo passando un <ph id="ph1">`CancellationToken`</ph> al metodo <ph id="ph2">`TryAdd`</ph> o <ph id="ph3">`TryTake`</ph> e quindi controllando il valore della proprietà <ph id="ph4">`IsCancellationRequested`</ph> del token in ogni iterazione.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If the value is <ph id="ph1">`true`</ph>, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.</source>
          <target state="translated">Se il valore è <ph id="ph1">`true`</ph>, l'utente deve decidere se rispondere alla richiesta di annullamento cancellando tutte le risorse e uscendo dal ciclo.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following example shows an overload of <ph id="ph1">`TryAdd`</ph> that takes a cancellation token, and the code that uses it:</source>
          <target state="translated">Nell'esempio seguente viene illustrato un overload di <ph id="ph1">`TryAdd`</ph> che accetta un token di annullamento e il codice che viene usato:</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Specifying the Collection Type</source>
          <target state="translated">Specifica del tipo di raccolta</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When you create a <ph id="ph1">`BlockingCollection&lt;T&gt;;`</ph>, you can specify not only the bounded capacity but also the type of collection to use.</source>
          <target state="translated">Quando si crea un oggetto <ph id="ph1">`BlockingCollection&lt;T&gt;;`</ph>, è possibile specificare non solo la capacità delimitata ma anche il tipo di raccolta da usare.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, you could specify a <bpt id="p1">[</bpt>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> for first in-first out (FIFO) behavior, or a <bpt id="p2">[</bpt>ConcurrentStack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> for last in-first out (LIFO) behavior.</source>
          <target state="translated">Ad esempio, è possibile specificare un oggetto <bpt id="p1">[</bpt>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> per il comportamento FIFO (First In, First Out) o un oggetto <bpt id="p2">[</bpt>ConcurrentStack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> per il comportamento LIFO (Last In, First Out).</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can use any collection class that implements the <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept> interface.</source>
          <target state="translated">È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The default collection type for <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> is <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph>.</source>
          <target state="translated">Il tipo di raccolta predefinito per <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> è <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The following code example shows how to create a <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> of strings that has a capacity of 1000 and uses a <bpt id="p1">[</bpt>ConcurrentBag<ph id="ph2">&amp;lt;</ph>T<ph id="ph3">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept>:</source>
          <target state="translated">L'esempio di codice seguente illustra come creare un <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> di stringhe con una capacità di 1000, che usa un oggetto <bpt id="p1">[</bpt>ConcurrentBag<ph id="ph2">&amp;lt;</ph>T<ph id="ph3">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept>:</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>IEnumerable Support</source>
          <target state="translated">Supporto di IEnumerable</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> provides a <ph id="ph2">`GetConsumingEnumerable`</ph> method that enables consumers to use a <ph id="ph3">`foreach`</ph> statement to remove items until the collection is completed, which means it is empty and no more items will be added.</source>
          <target state="translated"><ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> fornisce un metodo <ph id="ph2">`GetConsumingEnumerable`</ph> che consente agli utenti di usare un'istruzione <ph id="ph3">`foreach`</ph> per rimuovere gli elementi fino a quando non viene completata la raccolta, ovvero finché non è vuota e non verranno aggiunti altri elementi.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Use ForEach to Remove Items in a BlockingCollection<ept id="p1">](how-to-use-foreach-to-remove.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Procedura: usare ForEach per rimuovere elementi in un oggetto BlockingCollection<ept id="p1">](how-to-use-foreach-to-remove.md)</ept>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Using Many BlockingCollections As One</source>
          <target state="translated">Uso di più oggetti BlockingCollections come uno solo</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> and use the static methods such as <ph id="ph2">`TakeFromAny`</ph> and <ph id="ph3">`AddToAny`</ph> that will add to or take from any of the collections in the array.</source>
          <target state="translated">Per gli scenari in cui un Consumer deve rimuovere elementi da più raccolte contemporaneamente, è possibile creare matrici di <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> e usare i metodi statici, ad esempio <ph id="ph2">`TakeFromAny`</ph> e <ph id="ph3">`AddToAny`</ph> che eseguiranno operazioni di aggiunta o rimozione in qualsiasi raccolta nella matrice.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If one collection is blocking, the method immediately tries another until it finds one that can perform the operation.</source>
          <target state="translated">Se una raccolta è bloccata, il metodo ne cerca immediatamente un'altra finché non ne trova una che può eseguire l'operazione.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Use Arrays of Blocking Collections in a Pipeline<ept id="p1">](how-to-use-arrays-of-blockingcollections.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Procedura: usare matrici di BlockingCollection in una pipeline<ept id="p1">](how-to-use-arrays-of-blockingcollections.md)</ept>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vedere anche</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Collections and Data Structures<ept id="p1">](../index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Raccolte e strutture di dati<ept id="p1">](../index.md)</ept></target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Thread-Safe Collections<ept id="p1">](index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Raccolte thread-safe<ept id="p1">](index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>