<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">53c3afbe0492d010f7864bb42e7b83836c10aa4a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\garbagecollection\fundamentals.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">85a4bd245b454c9539a05fdc0b6d548183dc1719</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b42d03d888b09d7d2bfa90bee0b8bfb144aeb38c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Fundamentals of garbage collection</source>
          <target state="translated">Principi fondamentali di Garbage Collection</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Fundamentals of garbage collection</source>
          <target state="translated">Principi fondamentali di Garbage Collection</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Fundamentals of garbage collection</source>
          <target state="translated">Principi fondamentali di Garbage Collection</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In the Common Language Runtime (CLR), the garbage collector serves as an automatic memory manager.</source>
          <target state="translated">In Common Language Runtime (CLR), Garbage Collector funge da gestore di memoria automatico,</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It provides the following benefits:</source>
          <target state="translated">offrendo i seguenti vantaggi:</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Enables you to develop your application without having to free memory.</source>
          <target state="translated">Consente di sviluppare un'applicazione senza alcun bisogno di liberare memoria.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Allocates objects on the managed heap efficiently.</source>
          <target state="translated">Alloca gli oggetti nell'heap gestito in maniera efficiente.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</source>
          <target state="translated">Recupera gli oggetti inutilizzati, ne cancella la memoria e tiene la memoria a disposizione per le future allocazioni.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.</source>
          <target state="translated">Gli oggetti gestiti ottengono automaticamente contenuto pulito con il quale iniziare, pertanto i costruttori non devono inizializzare ogni campo dati.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Provides memory safety by making sure that an object cannot use the content of another object.</source>
          <target state="translated">Garantisce protezione per la memoria assicurando che un oggetto non possa usare il contenuto di un altro oggetto.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This topic describes the core concepts of garbage collection.</source>
          <target state="translated">In questo argomento vengono descritti i concetti principali di Garbage Collection.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It contains the following sections:</source>
          <target state="translated">Include le sezioni seguenti:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Fundamentals of memory<ept id="p1">](#fundamentals-of-memory)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Nozioni fondamentali sulla memoria<ept id="p1">](#fundamentals-of-memory)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Conditions for a garbage collection<ept id="p1">](#conditions-for-a-garbage-collection)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Condizioni per un'operazione di Garbage Collection<ept id="p1">](#conditions-for-a-garbage-collection)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The managed heap<ept id="p1">](#the-managed-heap)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Heap gestito<ept id="p1">](#the-managed-heap)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generations<ept id="p1">](#generations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generazioni<ept id="p1">](#generations)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>What happens during a garbage collection<ept id="p1">](#what-happens-during-a-garbage-collection)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Fasi di un'operazione di Garbage Collection<ept id="p1">](#what-happens-during-a-garbage-collection)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Manipulating unmanaged resources<ept id="p1">](#manipulating-unmanaged-resources)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Modifica delle risorse non gestite<ept id="p1">](#manipulating-unmanaged-resources)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Fundamentals of memory</source>
          <target state="translated">Nozioni fondamentali sulla memoria</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The following list summarizes important CLR memory concepts.</source>
          <target state="translated">Nell'elenco seguente sono riepilogati concetti importanti relativi alla memoria CLR.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Each process has its own, separate virtual address space.</source>
          <target state="translated">Ogni processo dispone di un proprio spazio degli indirizzi virtuali distinto.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>All processes on the same computer share the same physical memory, and share the page file if there is one.</source>
          <target state="translated">Tutti i processi nello stesso computer condividono la stessa memoria fisica e condividono il file di paging, se presente.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</source>
          <target state="translated">Per impostazione predefinita, nei computer a 32 bit ogni processo dispone di uno spazio degli indirizzi virtuali in modalità utente da 2 GB.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>As an application developer, you work only with virtual address space and never manipulate physical memory directly.</source>
          <target state="translated">Uno sviluppatore di applicazioni usa solo lo spazio degli indirizzi virtuali e non modifica mai direttamente la memoria fisica.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The garbage collector allocates and frees virtual memory for you on the managed heap.</source>
          <target state="translated">Il Garbage Collector alloca e libera automaticamente la memoria virtuale nell'heap gestito.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Virtual memory can be in three states:</source>
          <target state="translated">La memoria virtuale può trovarsi in tre stati:</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Free.</source>
          <target state="translated">Libero.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The block of memory has no references to it and is available for allocation.</source>
          <target state="translated">Non vi sono riferimenti al blocco di memoria, che è disponibile per l'allocazione.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Reserved.</source>
          <target state="translated">Riservato.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The block of memory is available for your use and cannot be used for any other allocation request.</source>
          <target state="translated">Il blocco di memoria è disponibile per l'utilizzo e non può essere usato da un'altra richiesta di allocazione.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>However, you cannot store data to this memory block until it is committed.</source>
          <target state="translated">Non è tuttavia possibile archiviare i dati in questo blocco di memoria fino a quando non viene eseguito il commit.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Committed.</source>
          <target state="translated">Eseguito.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The block of memory is assigned to physical storage.</source>
          <target state="translated">Il blocco di memoria è assegnato all'archiviazione fisica.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Virtual address space can get fragmented.</source>
          <target state="translated">Lo spazio degli indirizzi virtuali può diventare frammentato.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This means that there are free blocks, also known as holes, in the address space.</source>
          <target state="translated">Ciò significa che sono presenti blocchi liberi, noti anche come buchi, nello spazio degli indirizzi.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</source>
          <target state="translated">Quando viene richiesta un'allocazione della memoria virtuale, il gestore di memoria virtuale deve trovare un singolo blocco libero con dimensioni sufficienti per soddisfare la richiesta di allocazione.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Even if you have 2 GB of free space, the allocation that requires 2 GB will be unsuccessful unless all of that space is in a single address block.</source>
          <target state="translated">Anche se si dispone di 2 GB di spazio disponibile, l'allocazione che richiede 2 GB avrà esito negativo a meno che tutto lo spazio si trovi in un unico blocco di indirizzi.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You can run out of memory if you run out of virtual address space to reserve or physical space to commit.</source>
          <target state="translated">È possibile esaurire la memoria se si esaurisce lo spazio degli indirizzi virtuali da riservare o lo spazio fisico di cui eseguire il commit.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Your page file is used even if physical memory pressure (that is, demand for physical memory) is low.</source>
          <target state="translated">Il file di paging viene usato anche se la pressione della memoria fisica (ovvero, la richiesta di memoria fisica) è bassa.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The first time your physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</source>
          <target state="translated">La prima volta che la pressione della memoria fisica è elevata, il sistema operativo deve fare spazio nella memoria fisica per archiviare i dati ed esegue il backup di alcuni dei dati che si trovano nella memoria fisica nel file di paging.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>That data is not paged until it is needed, so it is possible to encounter paging in situations where the physical memory pressure is very low.</source>
          <target state="translated">Il paging dei dati non viene eseguito fino a quando non è necessario, pertanto è possibile riscontrare il paging in situazioni in cui la pressione della memoria fisica è molto bassa.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Conditions for a garbage collection</source>
          <target state="translated">Condizioni per un'operazione di Garbage Collection</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Garbage collection occurs when one of the following conditions is true:</source>
          <target state="translated">Le operazioni di Garbage Collection vengono eseguite in presenza di una delle seguenti condizioni:</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The system has low physical memory.</source>
          <target state="translated">La memoria fisica del sistema è insufficiente.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The memory that is used by allocated objects on the managed heap surpasses an acceptable threshold.</source>
          <target state="translated">La memoria usata dagli oggetti allocati nell'heap gestito supera una soglia accettabile.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This threshold is continuously adjusted as the process runs.</source>
          <target state="translated">Questa soglia viene continuamente modificata durante l'esecuzione del processo.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>GC.Collect<ept id="p1">](xref:System.GC.Collect)</ept> method is called.</source>
          <target state="translated">Viene chiamato il metodo <bpt id="p1">[</bpt>GC.Collect<ept id="p1">](xref:System.GC.Collect)</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>In almost all cases, you do not have to call this method, because the garbage collector runs continuously.</source>
          <target state="translated">Nella quasi totalità dei casi non è necessario chiamare questo metodo, in quanto il Garbage Collector viene eseguito senza interruzioni.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This method is primarily used for unique situations and testing.</source>
          <target state="translated">Il metodo viene usato principalmente in situazioni eccezionali e per scopi di test.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The managed heap</source>
          <target state="translated">Heap gestito</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</source>
          <target state="translated">Dopo essere stato inizializzato da CLR, il Garbage Collector alloca un segmento di memoria per archiviare e gestire oggetti.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This memory is called the managed heap, as opposed to a native heap in the operating system.</source>
          <target state="translated">Questa memoria è definita heap gestito, in contrapposizione a un heap nativo presente nel sistema operativo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>There is a managed heap for each managed process.</source>
          <target state="translated">Per ogni processo gestito esiste un heap gestito.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>All threads in the process allocate memory for objects on the same heap.</source>
          <target state="translated">Tutti i thread nel processo allocano memoria per gli oggetti sullo stesso heap.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</source>
          <target state="translated">La dimensione dei segmenti allocati dal Garbage Collector è specifica dell'implementazione ed è soggetta a modifiche in qualsiasi momento, tra cui aggiornamenti periodici.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</source>
          <target state="translated">L'applicazione non deve dare per scontata o dipendere da una particolare dimensione del segmento, né provare a configurare la quantità di memoria disponibile per le allocazioni di segmenti.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The fewer objects allocated on the heap, the less work the garbage collector has to do.</source>
          <target state="translated">Minore è il numero di oggetti allocati nell'heap, minore sarà il lavoro del Garbage Collector.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When you allocate objects, do not use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</source>
          <target state="translated">Quando si allocano oggetti, non usare valori arrotondati per eccesso che superino le proprie esigenze, ad esempio non allocare una matrice di 32 byte se sono necessari solo 15 byte.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>When a garbage collection is triggered, the garbage collector reclaims the memory that is occupied by dead objects.</source>
          <target state="translated">Quando viene attivata un'operazione di Garbage Collection, il Garbage Collector recupera la memoria occupata dagli oggetti inutilizzati.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</source>
          <target state="translated">Durante il processo di recupero, gli oggetti attivi vengono compattati in modo da poter essere spostati insieme e lo spazio inutilizzato viene rimosso, riducendo le dimensioni dell'heap.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This ensures that objects that are allocated together stay together on the managed heap, to preserve their locality.</source>
          <target state="translated">In questo modo si garantisce che gli oggetti allocati insieme restino uniti nell'heap gestito, preservandone la vicinanza.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</source>
          <target state="translated">L'impatto (frequenza e durata) delle operazioni di Garbage Collection è il risultato del volume di allocazioni e della quantità di memoria esclusa nell'heap gestito.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The heap can be considered as the accumulation of two heaps: the large object heap and the small object heap.</source>
          <target state="translated">L'heap può essere considerato l'insieme di due heap: l'heap degli oggetti grandi e l'heap degli oggetti piccoli.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The large object heap contains very large objects that are 85,000 bytes and larger.</source>
          <target state="translated">L'heap oggetti grandi contiene oggetti di dimensioni pari o superiori a 85.000 byte.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The objects on the large object heap are usually arrays.</source>
          <target state="translated">Gli oggetti sull'heap oggetti grandi sono in genere matrici.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>It is rare for an instance object to be extremely large.</source>
          <target state="translated">È raro che un oggetto istanza sia particolarmente grande.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Generations</source>
          <target state="translated">Generazioni</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The heap is organized into generations so it can handle long-lived and short-lived objects.</source>
          <target state="translated">L'heap è organizzato in generazioni, così da poter gestire oggetti di lunga durata e di breve durata.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Garbage collection primarily occurs with the reclamation of short-lived objects that typically occupy only a small part of the heap.</source>
          <target state="translated">Durante un'operazione di Garbage Collection vengono recuperati per primi gli oggetti di breve durata, che in genere occupano solo una piccola parte dell'heap.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>There are three generations of objects on the heap:</source>
          <target state="translated">Esistono tre generazioni di oggetti nell'heap:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Generation 0.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Generazione 0.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This is the youngest generation and contains short-lived objects.</source>
          <target state="translated">È la generazione più recente e contiene oggetti di breve durata.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>An example of a short-lived object is a temporary variable.</source>
          <target state="translated">Un esempio di oggetto di breve durata è una variabile temporanea.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Garbage collection occurs most frequently in this generation.</source>
          <target state="translated">Le operazioni di Garbage Collection vengono eseguite il più delle volte in questa generazione.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Newly allocated objects form a new generation of objects and are implicitly generation 0 collections, unless they are large objects, in which case they go on the large object heap in a generation 2 collection.</source>
          <target state="translated">Gli oggetti appena allocati formano una nuova generazione di oggetti e sono implicitamente raccolte di generazione 0, a meno che non siano oggetti grandi, nel qual caso vengono inseriti nell'heap degli oggetti grandi in una raccolta di generazione 2.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Most objects are reclaimed for garbage collection in generation 0 and do not survive to the next generation.</source>
          <target state="translated">Gran parte degli oggetti vengono recuperati tramite Garbage Collection nella generazione 0 e non passano alla generazione successiva.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Generation 1.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Generazione 1.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</source>
          <target state="translated">Questa generazione contiene oggetti di breve durata e funge da buffer tra gli oggetti di breve durata e gli oggetti di lunga durata.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Generation 2.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Generazione 2.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This generation contains long-lived objects.</source>
          <target state="translated">Questa generazione contiene oggetti di lunga durata.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>An example of a long-lived object is an object in a server application that contains static data that is live for the duration of the process.</source>
          <target state="translated">Un esempio di oggetto di lunga durata è un oggetto in un'applicazione server contenente dati statici che restano attivi per la durata del processo.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Garbage collections occur on specific generations as conditions warrant.</source>
          <target state="translated">Le operazioni di Garbage Collection vengono eseguite in generazioni specifiche a seconda delle condizioni.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Collecting a generation means collecting objects in that generation and all its younger generations.</source>
          <target state="translated">Raccogliere una generazione significa raccogliere gli oggetti in quella generazione e in tutte le generazioni più recenti.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A generation 2 garbage collection is also known as a full garbage collection, because it reclaims all objects in all generations (that is, all objects in the managed heap).</source>
          <target state="translated">Un'operazione di Garbage Collection di generazione 2 viene definita completa, in quanto recupera tutti gli oggetti in tutte le generazioni, vale a dire tutti gli oggetti nell'heap gestito.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Survival and promotions</source>
          <target state="translated">Esclusione e promozioni</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Objects that are not reclaimed in a garbage collection are known as survivors, and are promoted to the next generation.</source>
          <target state="translated">Gli oggetti che non vengono recuperati durante un'operazione di Garbage Collection sono definiti oggetti esclusi e vengono promossi alla generazione successiva.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Objects that survive a generation 0 garbage collection are promoted to generation 1; objects that survive a generation 1 garbage collection are promoted to generation 2; and objects that survive a generation 2 garbage collection remain in generation 2.</source>
          <target state="translated">Gli oggetti esclusi da un'operazione di Garbage Collection di generazione 0 vengono promossi alla generazione 1; gli oggetti esclusi da un'operazione di Garbage Collection di generazione 1 vengono promossi alla generazione 2; gli oggetti esclusi da un'operazione di Garbage Collection di generazione 2 restano nella generazione 2.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation, so the next collection gets a substantial size of reclaimed memory.</source>
          <target state="translated">Quando il Garbage Collector rileva un tasso di esclusione elevato in una generazione, aumenta la relativa soglia delle allocazioni, in modo che la raccolta successiva generi un recupero di memoria sostanziale.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The CLR continually balances two priorities: not letting an application's working set get too big and not letting the garbage collection take too much time.</source>
          <target state="translated">CLR bilancia continuamente due priorità: impedire che il working set di un'applicazione diventi troppo grande e limitare la durata delle operazioni di Garbage Collection.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Ephemeral generations and segments</source>
          <target state="translated">Generazioni e segmenti temporanei</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Because objects in generations 0 and 1 are short-lived, these generations are known as the ephemeral generations.</source>
          <target state="translated">Poiché gli oggetti nelle generazioni 0 e 1 sono di breve durata, queste vengono definite generazioni temporanee.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Ephemeral generations must be allocated in the memory segment that is known as the ephemeral segment.</source>
          <target state="translated">Le generazioni temporanee devono essere allocate nel segmento di memoria noto come segmento temporaneo.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</source>
          <target state="translated">Ogni nuovo segmento acquisito dal Garbage Collector diventa il nuovo segmento temporaneo e contiene gli oggetti esclusi da un'operazione di Garbage Collection di generazione 0.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The old ephemeral segment becomes the new generation 2 segment.</source>
          <target state="translated">Il segmento temporaneo precedente diventa il nuovo segmento di generazione 2.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The ephemeral segment can include generation 2 objects.</source>
          <target state="translated">Il segmento temporaneo può includere oggetti di generazione 2,</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</source>
          <target state="translated">i quali possono usare più segmenti (nella misura richiesta dal processo e consentita dalla memoria).</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</source>
          <target state="translated">La quantità di memoria liberata da un'operazione di Garbage Collection temporanea è limitata alla dimensione del segmento temporaneo.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</source>
          <target state="translated">Tale quantità di memoria è proporzionale allo spazio occupato dagli oggetti inutilizzati.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>What happens during a garbage collection</source>
          <target state="translated">Fasi di un'operazione di Garbage Collection</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A garbage collection has the following phases:</source>
          <target state="translated">Un'operazione di Garbage Collection si compone delle seguenti fasi:</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>A marking phase that finds and creates a list of all live objects.</source>
          <target state="translated">Una fase di contrassegno in cui vengono individuati tutti gli oggetti attivi e ne viene creato un elenco.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>A relocating phase that updates the references to the objects that will be compacted.</source>
          <target state="translated">Una fase di rilocazione in cui vengono aggiornati i riferimenti agli oggetti che saranno compattati.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</source>
          <target state="translated">Una fase di compattazione in cui lo spazio occupato dagli oggetti inutilizzati viene recuperato e gli oggetti esclusi compattati.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</source>
          <target state="translated">Durante questa fase, gli oggetti rimasti dopo un'operazione di Garbage Collection vengono spostati verso l'estremità meno recente del segmento.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</source>
          <target state="translated">Poiché le raccolte di generazione 2 possono occupare più segmenti, gli oggetti promossi alla generazione 2 possono essere spostati in un segmento meno recente.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</source>
          <target state="translated">Gli oggetti esclusi di generazione 1 e 2 possono essere spostati in un segmento diverso, in quanto vengono promossi alla generazione 2.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Ordinarily, the large object heap is not compacted, because copying large objects imposes a performance penalty.</source>
          <target state="translated">L'heap oggetti grandi non viene in genere compresso perché la copia di oggetti grandi impone un calo delle prestazioni.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>However,  you can use the <bpt id="p1">[</bpt>GCSettings.LargeObjectHeapCompactionMode<ept id="p1">](xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode)</ept> property to compact the large object heap on demand.</source>
          <target state="translated">Tuttavia, è possibile usare la proprietà <bpt id="p1">[</bpt>GCSettings.LargeObjectHeapCompactionMode<ept id="p1">](xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode)</ept> per comprimere su richiesta l'heap oggetti grandi.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The garbage collector uses the following information to determine whether objects are live:</source>
          <target state="translated">Per stabilire se gli oggetti sono attivi, il Garbage Collector usa le seguenti informazioni:</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Stack roots.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Radici dello stack.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Stack variables provided by the just-in-time (JIT) compiler and stack walker.</source>
          <target state="translated">Variabili dello stack fornite dal compilatore JIT e dal percorso di chiamate nello stack.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Garbage collection handles.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Handle di Garbage Collection.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Handles that point to managed objects and that can be allocated by user code or by the Common Language Runtime.</source>
          <target state="translated">Handle che puntano agli oggetti gestiti e che possono essere allocati mediante codice utente o Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Static data.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Dati statici.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Static objects in application domains that could be referencing other objects.</source>
          <target state="translated">Oggetti statici nei domini applicazione che possono fare riferimento ad altri oggetti.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Each application domain keeps track of its static objects.</source>
          <target state="translated">Ogni dominio applicazione tiene traccia dei rispettivi oggetti statici.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</source>
          <target state="translated">Prima di eseguire un'operazione di Garbage Collection, tutti i thread gestiti vengono sospesi, eccetto il thread che attiva l'operazione.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</source>
          <target state="translated">Nell'illustrazione seguente viene illustrato un thread che attiva un'operazione di Garbage Collection causando la sospensione degli altri thread.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>When a thread triggers a garbage collection</source>
          <target state="translated">Quando un thread attiva un'operazione di Garbage Collection</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Thread that triggers a garbage collection</source>
          <target state="translated">Thread che attiva un'operazione di Garbage Collection</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Manipulating unmanaged resources</source>
          <target state="translated">Modifica delle risorse non gestite</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If your managed objects reference unmanaged objects by using their native file handles, you have to explicitly free the unmanaged objects, because the garbage collector tracks memory only on the managed heap.</source>
          <target state="translated">Se gli oggetti gestiti fanno riferimento a oggetti non gestiti tramite i relativi handle di file nativi, è necessario liberare in modo esplicito gli oggetti non gestiti, poiché il Garbage Collector tiene traccia della memoria solo sull'heap gestito.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Users of your managed object may not dispose the native resources used by the object.</source>
          <target state="translated">È possibile che gli utenti dell'oggetto gestito non eliminino le risorse native usate dall'oggetto.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>To perform the cleanup, you can make your managed object finalizable.</source>
          <target state="translated">Per eseguire la pulizia, è possibile rendere l'oggetto gestito finalizzabile.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Finalization consists of cleanup actions that you execute when the object is no longer in use.</source>
          <target state="translated">La finalizzazione consiste in azioni di pulizia che si eseguono quando l'oggetto non è più usato.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>When your managed object dies, it performs cleanup actions that are specified in its finalizer method.</source>
          <target state="translated">Quando l'oggetto gestito cessa di essere usato, esegue azioni di pulizia specificate nel metodo del relativo finalizzatore.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>When a finalizable object is discovered to be dead, its finalizer is put in a queue so that its cleanup actions are executed, but the object itself is promoted to the next generation.</source>
          <target state="translated">Quando viene individuato un oggetto finalizzabile inutilizzato, il relativo finalizzatore viene inserito in una coda in modo che vengano eseguite le azioni di pulizia, mentre l'oggetto stesso viene promosso alla generazione successiva.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Therefore, you have to wait until the next garbage collection that occurs on that generation (which is not necessarily the next garbage collection) to determine whether the object has been reclaimed.</source>
          <target state="translated">Sarà pertanto necessario attendere l'operazione di Garbage Collection successiva eseguita in tale generazione, che non sarà necessariamente l'operazione immediatamente successiva, per stabilire se l'oggetto è stato recuperato.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Vedere anche</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Garbage collection in .NET<ept id="p1">](gc.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Garbage Collection in .NET<ept id="p1">](gc.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>