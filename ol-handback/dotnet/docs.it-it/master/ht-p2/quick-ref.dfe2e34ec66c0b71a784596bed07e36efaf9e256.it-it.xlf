<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ff1eef78985f9b5b428f3b696fb267b59f3cb283</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\quick-ref.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e0ff58caa100937a34369f91272efa2c13056b7f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2cb0a74d0d9189dcc337a5c246206d10f1aea504</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Regular expression language - quick reference</source>
          <target state="translated">Linguaggio di espressioni regolari - Riferimento rapido</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Regular expression language - quick reference</source>
          <target state="translated">Linguaggio di espressioni regolari - Riferimento rapido</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Regular expression language - quick reference</source>
          <target state="translated">Linguaggio di espressioni regolari - Riferimento rapido</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A regular expression is a pattern that the regular expression engine attempts to match in input text.</source>
          <target state="translated">Un'espressione regolare è un modello per il quale il motore delle espressioni regolari tenta di trovare una corrispondenza nel testo di input.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>A pattern consists of one or more character literals, operators, or constructs.</source>
          <target state="translated">Un modello è costituito da uno o più i valori letterali carattere, operatori o costrutti.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For a brief introduction, see <bpt id="p1">[</bpt>Regular expressions in .NET<ept id="p1">](regular-expressions.md)</ept>.</source>
          <target state="translated">Per una breve introduzione, vedere <bpt id="p1">[</bpt>Espressioni regolari di .NET<ept id="p1">](regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Each section in this quick reference lists a particular category of characters, operators, and constructs that you can use to define regular expressions:</source>
          <target state="translated">In ogni sezione di questa guida di riferimento rapido viene elencata una categoria specifica di caratteri, operatori e costrutti che è possibile usare per definire le espressioni regolari:</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Character escapes<ept id="p1">](#character-escapes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Caratteri di escape<ept id="p1">](#character-escapes)</ept></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Character classes<ept id="p1">](#character-classes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Classi di caratteri<ept id="p1">](#character-classes)</ept></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Anchors<ept id="p1">](#anchors)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Punti di ancoraggio<ept id="p1">](#anchors)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Grouping constructs<ept id="p1">](#grouping-constructs)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Costrutti di raggruppamento<ept id="p1">](#grouping-constructs)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Quantifiers<ept id="p1">](#quantifiers)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Quantificatori<ept id="p1">](#quantifiers)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backreference constructs<ept id="p1">](#backreference-constructs)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Costrutti di backreference<ept id="p1">](#backreference-constructs)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Alternation constructs<ept id="p1">](#alternation-constructs)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Costrutti di alternanza<ept id="p1">](#alternation-constructs)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Substitutions<ept id="p1">](#substitutions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Sostituzioni<ept id="p1">](#substitutions)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression options<ept id="p1">](#regular-expression-options)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Opzioni di espressioni regolari<ept id="p1">](#regular-expression-options)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Miscellaneous constructs<ept id="p1">](#miscellaneous-constructs)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Costrutti vari<ept id="p1">](#miscellaneous-constructs)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>We’ve also provided this information in two formats that you can download and print for easy reference:</source>
          <target state="translated">Queste informazioni sono disponibili in due formati scaricabili e stampabili come riferimento:</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Download in Word (.docx) format<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Download in formato Word (.docx)<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Download in PDF (.pdf) format<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Download in formato PDF (.pdf)<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Character Escapes</source>
          <target state="translated">Caratteri di escape</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The backslash character (<ph id="ph1">\)</ph> in a regular expression indicates that the character that follows it either is a special character (as shown in the following table), or should be interpreted literally.</source>
          <target state="translated">Il carattere barra rovesciata (<ph id="ph1">\)</ph>) in un'espressione regolare indica che il carattere successivo è un carattere speciale (come illustrato nella tabella seguente) oppure deve essere interpretato letteralmente.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Character escapes in regular expressions<ept id="p1">](escapes.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Caratteri di escape nelle espressioni regolari<ept id="p1">](escapes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Escaped character</source>
          <target state="translated">Caratteri di escape</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Corrispondenze</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\a<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\a<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Matches a bell character, \u0007.</source>
          <target state="translated">Trova la corrispondenza di un carattere di controllo del segnale acustico di avviso, \u0007.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>"\u0007" in "Error!"</source>
          <target state="translated">"\u0007" in "Error!"</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>+ '\u0007'</source>
          <target state="translated">+ '\u0007'</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\b<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\b<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In a character class, matches a backspace, \u0008.</source>
          <target state="translated">In una classe di caratteri, trova la corrispondenza di un carattere backspace, \u0008.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>"\b\b\b\b" in "\b\b\b\b"</source>
          <target state="translated">"\b\b\b\b" in "\b\b\b\b"</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\t<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\t<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Matches a tab, \u0009.</source>
          <target state="translated">Trova la corrispondenza di un carattere di tabulazione, \u0009.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>"item1\t", "item2\t" in "item1\titem2\t"</source>
          <target state="translated">"item1\t", "item2\t" in "item1\titem2\t"</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\r<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\r<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Matches a carriage return, \u000D.</source>
          <target state="translated">Trova la corrispondenza di un carattere di ritorno a capo, \u000D.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>(<bpt id="p1">**</bpt>\r<ept id="p1">**</ept> is not equivalent to the newline character, <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.)</source>
          <target state="translated"><bpt id="p1">**</bpt>\r<ept id="p1">**</ept> non equivale al carattere di nuova riga <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>"\r\nThese" in "\r\nThese are\ntwo lines."</source>
          <target state="translated">"\r\nThese" in "\r\nThese are\ntwo lines."</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\v<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\v<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Matches a vertical tab, \u000B.</source>
          <target state="translated">Trova la corrispondenza di un carattere di tabulazione verticale, \u000B.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>"\v\v\v" in "\v\v\v"</source>
          <target state="translated">"\v\v\v" in "\v\v\v"</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\f<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\f<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Matches a form feed, \u000C.</source>
          <target state="translated">Trova la corrispondenza di un carattere di avanzamento carta, \u000C.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>"\f\f\f" in "\f\f\f"</source>
          <target state="translated">"\f\f\f" in "\f\f\f"</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\n<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\n<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Matches a new line, \u000A.</source>
          <target state="translated">Trova la corrispondenza di una nuova riga, \u000A.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>"\r\nThese" in "\r\nThese are\ntwo lines."</source>
          <target state="translated">"\r\nThese" in "\r\nThese are\ntwo lines."</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\e<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\e<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Matches an escape, \u001B.</source>
          <target state="translated">Trova la corrispondenza di un carattere di escape, \u001B.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>"\x001B" in "\x001B"</source>
          <target state="translated">"\x001B" in "\x001B"</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><ph id="ph1">*</ph><bpt id="p1">*</bpt><ph id="ph2">\*</ph><ept id="p1">*</ept><bpt id="p2">_</bpt>nnn<ept id="p2">_</ept></source>
          <target state="translated"><ph id="ph1">*</ph><bpt id="p1">*</bpt><ph id="ph2">\*</ph><ept id="p1">*</ept><bpt id="p2">_</bpt>nnn<ept id="p2">_</ept></target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Uses octal representation to specify a character (<bpt id="p1">*</bpt>nnn<ept id="p1">*</ept> consists of two or three digits).</source>
          <target state="translated">Usa la rappresentazione ottale per specificare un carattere (<bpt id="p1">*</bpt>nnn<ept id="p1">*</ept> è costituito da un massimo di tre cifre).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>"a b", "c d" in "a bc d"</source>
          <target state="translated">"a b", "c d" in "a bc d"</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\x<ept id="p1">**</ept><bpt id="p2">_</bpt>nn<ept id="p2">_</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\x<ept id="p1">**</ept><bpt id="p2">_</bpt>nn<ept id="p2">_</ept></target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Uses hexadecimal representation to specify a character (<bpt id="p1">*</bpt>nn<ept id="p1">*</ept> consists of exactly two digits).</source>
          <target state="translated">Usa la rappresentazione esadecimale per specificare un carattere (<bpt id="p1">*</bpt>nn<ept id="p1">*</ept> è costituito da esattamente due cifre).</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>"a b", "c d" in "a bc d"</source>
          <target state="translated">"a b", "c d" in "a bc d"</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\c<ept id="p1">**</ept><bpt id="p2">_</bpt>X<ept id="p2">_</ept> or <bpt id="p3">**</bpt>\c<ept id="p3">**</ept><bpt id="p4">_</bpt>x<ept id="p4">_</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\c<ept id="p1">**</ept><bpt id="p2">_</bpt>X<ept id="p2">_</ept> o <bpt id="p3">**</bpt>\c<ept id="p3">**</ept><bpt id="p4">_</bpt>x<ept id="p4">_</ept></target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Matches the ASCII control character that is specified by <bpt id="p1">*</bpt>X<ept id="p1">*</ept> or <bpt id="p2">*</bpt>x<ept id="p2">*</ept>, where <bpt id="p3">*</bpt>X<ept id="p3">*</ept> or <bpt id="p4">*</bpt>x<ept id="p4">*</ept> is the letter of the control character.</source>
          <target state="translated">Trova la corrispondenza con il carattere di controllo ASCII specificato da <bpt id="p1">*</bpt>X<ept id="p1">*</ept> o <bpt id="p2">*</bpt>x<ept id="p2">*</ept>, dove <bpt id="p3">*</bpt>X<ept id="p3">*</ept> o <bpt id="p4">*</bpt>x<ept id="p4">*</ept> è la lettera del carattere di controllo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>"\x0003" in "\x0003" (Ctrl-C)</source>
          <target state="translated">"\x0003" in "\x0003" (Ctrl-C)</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\u<ept id="p1">**</ept><bpt id="p2">_</bpt>nnnn<ept id="p2">_</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\u<ept id="p1">**</ept><bpt id="p2">_</bpt>nnnn<ept id="p2">_</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Matches a Unicode character by using hexadecimal representation (exactly four digits, as represented by <bpt id="p1">*</bpt>nnnn<ept id="p1">*</ept>).</source>
          <target state="translated">Trova la corrispondenza di un carattere Unicode usando una rappresentazione esadecimale (esattamente quattro cifre, come rappresentate da <bpt id="p1">*</bpt>nnnn<ept id="p1">*</ept>).</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>"a b", "c d" in "a bc d"</source>
          <target state="translated">"a b", "c d" in "a bc d"</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>When followed by a character that is not recognized as an escaped character in this and other tables in this topic, matches that character.</source>
          <target state="translated">Quando è seguito da un carattere non riconosciuto come carattere di escape, in questa e in altre tabelle del presente argomento, trova la corrispondenza di tale carattere.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">__</bpt><ph id="ph1">\*</ph><ept id="p1">__</ept> is the same as <bpt id="p2">**</bpt>\x2A<ept id="p2">**</ept>, and <bpt id="p3">**</bpt><ph id="ph2">\.</ph><ept id="p3">**</ept> is the same as <bpt id="p4">**</bpt>\x2E<ept id="p4">**</ept>.</source>
          <target state="translated">Ad esempio, <bpt id="p1">__</bpt><ph id="ph1">\*</ph><ept id="p1">__</ept> equivale a <bpt id="p2">**</bpt>\x2A<ept id="p2">**</ept> e <bpt id="p3">**</bpt><ph id="ph2">\.</ph><ept id="p3">**</ept> equivale a <bpt id="p4">**</bpt>\x2E<ept id="p4">**</ept>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>This allows the regular expression engine to disambiguate language elements (such as <ph id="ph1">`*`</ph> or <ph id="ph2">`?`</ph>) and character literals (represented by <ph id="ph3">`\*`</ph> or <ph id="ph4">`\?)`</ph>.</source>
          <target state="translated">Questo consente al motore delle espressioni regolari di distinguere tra elementi del linguaggio, ad esempio <ph id="ph1">`*`</ph> o <ph id="ph2">`?`</ph>, e valori letterali carattere, rappresentati da <ph id="ph3">`\*`</ph> o <ph id="ph4">`\?)`</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>"2+2" and "3<bpt id="p1">*</bpt>9" in "(2+2) <ept id="p1">*</ept> 3*9"</source>
          <target state="translated">"2+2" e "3<bpt id="p1">*</bpt>9" in "(2+2) <ept id="p1">*</ept> 3*9"</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Character Classes</source>
          <target state="translated">Classi di caratteri</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>A character class matches any one of a set of characters.</source>
          <target state="translated">Una classe di caratteri trova la corrispondenza con uno qualsiasi di un set di caratteri.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Character classes include the language elements listed in the following table.</source>
          <target state="translated">Le classi di caratteri includono gli elementi del linguaggio elencati nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Character classes in regular expressions<ept id="p1">](classes.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Classi di caratteri nelle espressioni regolari<ept id="p1">](classes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Character class</source>
          <target state="translated">Classe di caratteri</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Corrispondenze</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">__</bpt>[<ept id="p1">__</ept><bpt id="p2">*</bpt>character_group<ept id="p2">*</ept><bpt id="p3">__</bpt>]<ept id="p3">__</ept></source>
          <target state="translated"><bpt id="p1">__</bpt>[<ept id="p1">__</ept><bpt id="p2">*</bpt>character_group<ept id="p2">*</ept><bpt id="p3">__</bpt>]<ept id="p3">__</ept></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Matches any single character in character_group.</source>
          <target state="translated">Trova la corrispondenza con qualsiasi carattere in un elenco di singoli caratteri.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>By default, the match is case-sensitive.</source>
          <target state="translated">Per impostazione predefinita, viene effettuata la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>"a" in "gray", "a", "e" in "lane"</source>
          <target state="translated">"a" in "gray", "a", "e" in "lane"</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">__</bpt>[^<ept id="p1">__</ept><bpt id="p2">*</bpt>character_group<ept id="p2">*</ept><bpt id="p3">__</bpt>]<ept id="p3">__</ept></source>
          <target state="translated"><bpt id="p1">__</bpt>[^<ept id="p1">__</ept><bpt id="p2">*</bpt>character_group<ept id="p2">*</ept><bpt id="p3">__</bpt>]<ept id="p3">__</ept></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Negation: Matches any single character that is not in <bpt id="p1">*</bpt>character_group<ept id="p1">*</ept>.</source>
          <target state="translated">Negazione: corrisponde a qualsiasi carattere singolo non incluso in <bpt id="p1">*</bpt>character_group<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>By default, characters in <bpt id="p1">*</bpt>character_group<ept id="p1">*</ept> are case-sensitive.</source>
          <target state="translated">Per impostazione predefinita, per i caratteri in <bpt id="p1">*</bpt>character_group<ept id="p1">*</ept> si fa distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>"r", "g", "n" in "reign"</source>
          <target state="translated">"r", "g", "n" in "reign"</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">__</bpt>[<ept id="p1">__</ept><bpt id="p2">*</bpt>first-last<ept id="p2">*</ept><bpt id="p3">__</bpt>]<ept id="p3">__</ept></source>
          <target state="translated"><bpt id="p1">__</bpt>[<ept id="p1">__</ept><bpt id="p2">*</bpt>first-last<ept id="p2">*</ept><bpt id="p3">__</bpt>]<ept id="p3">__</ept></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Character range: Matches any single character in the range from <bpt id="p1">*</bpt>first<ept id="p1">*</ept> to <bpt id="p2">*</bpt>last<ept id="p2">*</ept>.</source>
          <target state="translated">Intervallo di caratteri: trova la corrispondenza di qualsiasi carattere singolo nell'intervallo dal <bpt id="p1">*</bpt>primo<ept id="p1">*</ept> all'<bpt id="p2">*</bpt>ultimo<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>"A", "B" in "AB123"</source>
          <target state="translated">"A", "B" in "AB123"</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Wildcard: Matches any single character except \n.</source>
          <target state="translated">Carattere jolly: trova la corrispondenza di qualsiasi carattere singolo ad eccezione di "\n".</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To match a literal period character (.</source>
          <target state="translated">Per confrontare un carattere punto di valore letterale (.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>or \u002E), you must precede it with the escape character (<ph id="ph1">\.</ph>).</source>
          <target state="translated">o \u002E), è necessario farlo precedere da un carattere di escape (<ph id="ph1">\.</ph>).</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>"ave" in "nave", "ate" in "water"</source>
          <target state="translated">"ave" in "nave", "ate" in "water"</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">__</bpt>\p{<ept id="p1">__</ept><bpt id="p2">*</bpt>name<ept id="p2">*</ept><bpt id="p3">__</bpt>}<ept id="p3">__</ept></source>
          <target state="translated"><bpt id="p1">__</bpt>\p{<ept id="p1">__</ept><bpt id="p2">*</bpt>nome<ept id="p2">*</ept><bpt id="p3">__</bpt>}<ept id="p3">__</ept></target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Matches any single character in the Unicode general category or named block specified by <bpt id="p1">*</bpt>name<ept id="p1">*</ept>.</source>
          <target state="translated">Trova la corrispondenza con qualsiasi carattere singolo incluso nel blocco denominato o nella categoria generale Unicode specificato da <bpt id="p1">*</bpt>nome<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\p{Lu}`</ph>, <ph id="ph2">`\p{IsCyrillic}`</ph></source>
          <target state="translated"><ph id="ph1">`\p{Lu}`</ph>, <ph id="ph2">`\p{IsCyrillic}`</ph></target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>"C", "L" in "City Lights", "?", "?" in "??em"</source>
          <target state="translated">"C", "L" in "City Lights", "?", "?" in "??em"</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1">__</bpt>\P{<ept id="p1">__</ept><bpt id="p2">*</bpt>name<ept id="p2">*</ept><bpt id="p3">__</bpt>}<ept id="p3">__</ept></source>
          <target state="translated"><bpt id="p1">__</bpt>\P{<ept id="p1">__</ept><bpt id="p2">*</bpt>nome<ept id="p2">*</ept><bpt id="p3">__</bpt>}<ept id="p3">__</ept></target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Matches any single character that is not in the Unicode general category or named block specified by <bpt id="p1">*</bpt>name<ept id="p1">*</ept>.</source>
          <target state="translated">Trova la corrispondenza con qualsiasi carattere singolo non incluso nel blocco denominato o nella categoria generale Unicode specificato da <bpt id="p1">*</bpt>nome<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\P{Lu}`</ph>, <ph id="ph2">`\P{IsCyrillic}`</ph></source>
          <target state="translated"><ph id="ph1">`\P{Lu}`</ph>, <ph id="ph2">`\P{IsCyrillic}`</ph></target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>` "i", "t", "y" in "City", "e", "m" in "??em"</source>
          <target state="translated">` "i", "t", "y" in "City", "e", "m" in "??em"</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\w<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\w<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Matches any word character.</source>
          <target state="translated">Trova la corrispondenza di qualsiasi carattere alfabetico.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>"I", "D", "A", "1", "3" in "ID A1.3"</source>
          <target state="translated">"I", "D", "A", "1", "3" in "ID A1.3"</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\W<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\W<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Matches any non-word character.</source>
          <target state="translated">Trova la corrispondenza di qualsiasi carattere non alfabetico.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>" ", "." in "ID A1.3"</source>
          <target state="translated">" ", "." in "ID A1.3"</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\s<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\s<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Matches any white-space character.</source>
          <target state="translated">Trova la corrispondenza di qualsiasi carattere di spazio.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>"D " in "ID A1.3"</source>
          <target state="translated">"D " in "ID A1.3"</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\S<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\S<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Matches any non-white-space character.</source>
          <target state="translated">Trova la corrispondenza di qualsiasi carattere diverso da uno spazio.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>" _" in "int __ctr"</source>
          <target state="translated">" _" in "int __ctr"</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\d<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\d<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Matches any decimal digit.</source>
          <target state="translated">Trova la corrispondenza di qualsiasi cifra decimale.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>"4" in "4 = IV"</source>
          <target state="translated">"4" in "4 = IV"</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\D<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\D<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Matches any character other than a decimal digit.</source>
          <target state="translated">Trova la corrispondenza con qualsiasi carattere diverso da una cifra decimale.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>" ", "=", " ", "I", "V" in "4 = IV"</source>
          <target state="translated">" ", "=", " ", "I", "V" in "4 = IV"</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Anchors</source>
          <target state="translated">Punti di ancoraggio</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Anchors, or atomic zero-width assertions, cause a match to succeed or fail depending on the current position in the string, but they do not cause the engine to advance through the string or consume characters.</source>
          <target state="translated">Gli ancoraggi, o asserzioni atomiche di larghezza zero, determinano l'esito della ricerca di una corrispondenza in base alla posizione corrente nella stringa, ma non comportano l'avanzamento del motore nella stringa o l'utilizzo di caratteri.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The metacharacters listed in the following table are anchors.</source>
          <target state="translated">I metacaratteri elencati nella tabella seguente sono ancoraggi.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Anchors in regular expressions<ept id="p1">](anchors.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Ancoraggi nelle espressioni regolari<ept id="p1">](anchors.md)</ept>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Assertion</source>
          <target state="translated">Asserzione</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Corrispondenze</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The match must start at the beginning of the string or line.</source>
          <target state="translated">La corrispondenza deve iniziare all'inizio della stringa o della riga.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>"901" in "901-333-"</source>
          <target state="translated">"901" in "901-333-"</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string or before <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> at the end of the line or string.</source>
          <target state="translated">La corrispondenza deve verificarsi alla fine della stringa o prima di <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> alla fine della riga o della stringa.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>"-333" in "-901-333"</source>
          <target state="translated">"-333" in "-901-333"</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\A<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\A<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The match must occur at the start of the string.</source>
          <target state="translated">La corrispondenza deve verificarsi all'inizio della stringa.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>"901" in "901-333-"</source>
          <target state="translated">"901" in "901-333-"</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string or before <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> at the end of the string.</source>
          <target state="translated">La corrispondenza deve verificarsi alla fine della stringa o prima di <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> alla fine della stringa.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>"-333" in "-901-333"</source>
          <target state="translated">"-333" in "-901-333"</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\z<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\z<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string.</source>
          <target state="translated">La corrispondenza deve verificarsi alla fine della stringa.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>"-333" in "-901-333"</source>
          <target state="translated">"-333" in "-901-333"</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\G<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\G<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The match must occur at the point where the previous match ended.</source>
          <target state="translated">La corrispondenza deve verificarsi nel punto in cui è terminata la corrispondenza precedente.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>"(1)", "(3)", "(5)" in "(1)(3)(5)[7]&amp;#40;9)"</source>
          <target state="translated">"(1)", "(3)", "(5)" in "(1)(3)(5)[7]&amp;#40;9)"</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\b<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\b<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The match must occur on a boundary between a <bpt id="p1">**</bpt>\w<ept id="p1">**</ept> (alphanumeric) and a <bpt id="p2">**</bpt>\W<ept id="p2">**</ept> (nonalphanumeric) character.</source>
          <target state="translated">La corrispondenza deve verificarsi sul limite tra un carattere <bpt id="p1">**</bpt>\w<ept id="p1">**</ept> (alfanumerico) e un carattere <bpt id="p2">**</bpt>\W<ept id="p2">**</ept> (non alfanumerico).</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>"them theme", "them them" in "them theme them them"</source>
          <target state="translated">"them theme", "them them" in "them theme them them"</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\B<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\B<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The match must not occur on a <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> boundary.</source>
          <target state="translated">La corrispondenza non deve verificarsi su un limite <bpt id="p1">**</bpt>\b<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>"ends", "ender" in "end sends endure lender"</source>
          <target state="translated">"ends", "ender" in "end sends endure lender"</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Grouping Constructs</source>
          <target state="translated">Costrutti di raggruppamento</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Grouping constructs delineate subexpressions of a regular expression and typically capture substrings of an input string.</source>
          <target state="translated">I costrutti di raggruppamento delineano sottoespressioni di un'espressione regolare e in genere acquisiscono sottostringhe di una stringa di input.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Grouping constructs include the language elements listed in the following table.</source>
          <target state="translated">I costrutti di raggruppamento includono gli elementi del linguaggio elencati nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Costrutti di raggruppamento nelle espressioni regolari<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Grouping construct</source>
          <target state="translated">Costrutto di raggruppamento</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Corrispondenze</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Captures the matched subexpression and assigns it a one-based ordinal number.</source>
          <target state="translated">Acquisisce la sottoespressione corrispondente e le assegna un numero ordinale in base uno.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>"ee" in "deep"</source>
          <target state="translated">"ee" in "deep"</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">&lt;name&gt;</ph></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">&lt;name&gt;</ph></target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><bpt id="p1">_</bpt>subexpression<ept id="p1">_</ept><bpt id="p2">**</bpt>)<ept id="p2">**</ept></source>
          <target state="translated"><bpt id="p1">_</bpt>subexpression<ept id="p1">_</ept><bpt id="p2">**</bpt>)<ept id="p2">**</ept></target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Captures the matched subexpression into a named group.</source>
          <target state="translated">Acquisisce la sottoespressione corrispondente in un gruppo denominato.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>"ee" in "deep"</source>
          <target state="translated">"ee" in "deep"</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept>&lt;name1-name2&gt; <bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept>&lt;nome1-nome2&gt; <bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Defines a balancing group definition.</source>
          <target state="translated">Definisce una definizione di gruppo di bilanciamento</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Balancing Group Definitions<ept id="p1">](grouping.md#balancing-group-definitions)</ept> section in <bpt id="p2">[</bpt>Grouping constructs in regular expressions<ept id="p2">](grouping.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere la sezione <bpt id="p1">[</bpt>Definizione del gruppo di bilanciamento<ept id="p1">](grouping.md#balancing-group-definitions)</ept> in <bpt id="p2">[</bpt>Costrutti di raggruppamento nelle espressioni regolari<ept id="p2">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>"((1-3)<bpt id="p1">*</bpt>(3-1))" in "3+2^((1-3)<ept id="p1">*</ept>(3-1))"</source>
          <target state="translated">"((1-3)<bpt id="p1">*</bpt>(3-1))" in "3+2^((1-3)<ept id="p1">*</ept>(3-1))"</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept>: subexpression<bpt id="p2">**</bpt>)<ept id="p2">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept>: subexpression<bpt id="p2">**</bpt>)<ept id="p2">**</ept></target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Defines a noncapturing group.</source>
          <target state="translated">Definisce un gruppo di non acquisizione.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>"WriteLine" in "Console.WriteLine()", "Write" in "Console.Write(value)"</source>
          <target state="translated">"WriteLine" in "Console.WriteLine()", "Write" in "Console.Write(value)"</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?imnsx-imnsx<ept id="p1">**</ept>: <bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?imnsx-imnsx<ept id="p1">**</ept>: <bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Applies or disables the specified options within <bpt id="p1">_</bpt>subexpression<ept id="p1">_</ept>.</source>
          <target state="translated">Applica o disabilita le opzioni specificate nella <bpt id="p1">_</bpt>sottoespressione<ept id="p1">_</ept>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Opzioni di espressioni regolari<ept id="p1">](options.md)</ept>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>"A12xl", "A12XL" in "A12xl A12XL a12xl"</source>
          <target state="translated">"A12xl", "A12XL" in "A12xl A12XL a12xl"</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">= </ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">= </ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookahead assertion.</source>
          <target state="translated">Asserzione lookahead positiva di larghezza zero.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>"is", "ran", and "out" in "He is.</source>
          <target state="translated">"is", "ran" e "out" in "He is.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The dog ran.</source>
          <target state="translated">The dog ran.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The sun is out."</source>
          <target state="translated">The sun is out."</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source><bpt id="p1">_</bpt>subexpression<ept id="p1">_</ept><bpt id="p2">**</bpt>)<ept id="p2">**</ept></source>
          <target state="translated"><bpt id="p1">_</bpt>subexpression<ept id="p1">_</ept><bpt id="p2">**</bpt>)<ept id="p2">**</ept></target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookahead assertion.</source>
          <target state="translated">Asserzione lookahead negativa di larghezza zero.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>"sure", "used" in "unsure sure unity used"</source>
          <target state="translated">"sure", "used" in "unsure sure unity used"</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">&lt;= </ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">&lt;= </ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertion.</source>
          <target state="translated">Asserzione lookbehind positiva di larghezza zero.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>"99", "50", "05" in "1851 1999 1950 1905 2003"</source>
          <target state="translated">"99", "50", "05" in "1851 1999 1950 1905 2003"</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept>&lt;!</source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept>&lt;!</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source><bpt id="p1">_</bpt>subexpression<ept id="p1">_</ept><bpt id="p2">**</bpt>)<ept id="p2">**</ept></source>
          <target state="translated"><bpt id="p1">_</bpt>subexpression<ept id="p1">_</ept><bpt id="p2">**</bpt>)<ept id="p2">**</ept></target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind assertion.</source>
          <target state="translated">Asserzione lookbehind negativa di larghezza zero.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>"51", "03" in "1851 1999 1950 1905 2003"</source>
          <target state="translated">"51", "03" in "1851 1999 1950 1905 2003"</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">&gt; </ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">&gt; </ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Nonbacktracking (or "greedy") subexpression.</source>
          <target state="translated">Sottoespressione non di backtracking (o "greedy").</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>"1ABB", "3ABB", and "5AB" in "1ABB 3ABBC 5AB 5AC"</source>
          <target state="translated">"1ABB", "3ABB" e "5AB" in "1ABB 3ABBC 5AB 5AC"</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Quantifiers</source>
          <target state="translated">Quantificatori</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>A quantifier specifies how many instances of the previous element (which can be a character, a group, or a character class) must be present in the input string for a match to occur.</source>
          <target state="translated">Un quantificatore specifica il numero di istanze dell'elemento precedente, che può essere un carattere, un gruppo o una classe di caratteri, che devono essere presenti nella stringa di input affinché venga trovata una corrispondenza.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Quantifiers include the language elements listed in the following table.</source>
          <target state="translated">I quantificatori includono gli elementi del linguaggio elencati nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Quantifiers in regular expressions<ept id="p1">](quantifiers.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Quantificatori nelle espressioni regolari<ept id="p1">](quantifiers.md)</ept>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Quantifier</source>
          <target state="translated">Quantificatore</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Corrispondenze</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Matches the previous element zero or more times.</source>
          <target state="translated">Trova la corrispondenza dell'elemento precedente zero o più volte.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>".0", "19.9", "219.9"</source>
          <target state="translated">".0", "19.9", "219.9"</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Matches the previous element one or more times.</source>
          <target state="translated">Trova la corrispondenza dell'elemento precedente una o più volte.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>"bee" in "been", "be" in "bent"</source>
          <target state="translated">"bee" in "been", "be" in "bent"</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>?<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Matches the previous element zero or one time.</source>
          <target state="translated">Trova la corrispondenza con l'elemento precedente zero volte o una volta soltanto.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>"ran", "rain"</source>
          <target state="translated">"ran", "rain"</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Matches the previous element exactly <bpt id="p1">*</bpt>n<ept id="p1">*</ept> times.</source>
          <target state="translated">Trova la corrispondenza con l'elemento precedente esattamente <bpt id="p1">*</bpt>n<ept id="p1">*</ept> volte.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>",043" in "1,043.6", ",876", ",543", and ",210" in "9,876,543,210"</source>
          <target state="translated">",043" in "1,043.6", ",876", ",543" e ",210" in "9,876,543,210"</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept>,<bpt id="p3">**</bpt>}<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept>,<bpt id="p3">**</bpt>}<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Matches the previous element at least <bpt id="p1">*</bpt>n<ept id="p1">*</ept> times.</source>
          <target state="translated">Trova la corrispondenza con l'elemento precedente almeno <bpt id="p1">*</bpt>n<ept id="p1">*</ept> volte.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>"166", "29", "1930"</source>
          <target state="translated">"166", "29", "1930"</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept>,<bpt id="p3">_</bpt>m<ept id="p3">_</ept><bpt id="p4">**</bpt>}<ept id="p4">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept>,<bpt id="p3">_</bpt>m<ept id="p3">_</ept><bpt id="p4">**</bpt>}<ept id="p4">**</ept></target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Matches the previous element at least <bpt id="p1">*</bpt>n<ept id="p1">*</ept> times, but no more than <bpt id="p2">*</bpt>m<ept id="p2">*</ept> times.</source>
          <target state="translated">Trova la corrispondenza con l'elemento precedente almeno <bpt id="p1">*</bpt>n<ept id="p1">*</ept> volte, ma non più di <bpt id="p2">*</bpt>m<ept id="p2">*</ept> volte.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>"166", "17668"; "19302" in "193024"</source>
          <target state="translated">"166", "17668"; "19302" in "193024"</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source><bpt id="p1">__</bpt>*?<ept id="p1">__</ept></source>
          <target state="translated"><bpt id="p1">__</bpt>*?<ept id="p1">__</ept></target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Matches the previous element zero or more times, but as few times as possible.</source>
          <target state="translated">Trova la corrispondenza dell'elemento precedente zero o più volte, ma il minor numero di volte possibile.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>".0", "19.9", "219.9"</source>
          <target state="translated">".0", "19.9", "219.9"</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>+?<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>+?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Matches the previous element one or more times, but as few times as possible.</source>
          <target state="translated">Trova la corrispondenza dell'elemento precedente una o più volte, ma il minor numero di volte possibile.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>"be" in "been", "be" in "bent"</source>
          <target state="translated">"be" in "been", "be" in "bent"</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>??<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>??<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Matches the previous element zero or one time, but as few times as possible.</source>
          <target state="translated">Trova la corrispondenza dell'elemento precedente zero volte o una volta, ma il minor numero di volte possibile.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>"ran", "rain"</source>
          <target state="translated">"ran", "rain"</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}?<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}?<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Matches the preceding element exactly <bpt id="p1">*</bpt>n<ept id="p1">*</ept> times.</source>
          <target state="translated">Trova la corrispondenza con l'elemento precedente esattamente <bpt id="p1">*</bpt>n<ept id="p1">*</ept> volte.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>",043" in "1,043.6", ",876", ",543", and ",210" in "9,876,543,210"</source>
          <target state="translated">",043" in "1,043.6", ",876", ",543" e ",210" in "9,876,543,210"</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept>,<bpt id="p3">**</bpt>}?<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept>,<bpt id="p3">**</bpt>}?<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Matches the previous element at least <bpt id="p1">*</bpt>n<ept id="p1">*</ept> times, but as few times as possible.</source>
          <target state="translated">Trova la corrispondenza dell'elemento precedente almeno <bpt id="p1">*</bpt>n<ept id="p1">*</ept> volte, ma il minor numero di volte possibile.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>"166", "29", "1930"</source>
          <target state="translated">"166", "29", "1930"</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept>,<bpt id="p3">_</bpt>m<ept id="p3">_</ept><bpt id="p4">**</bpt>}?<ept id="p4">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept>,<bpt id="p3">_</bpt>m<ept id="p3">_</ept><bpt id="p4">**</bpt>}?<ept id="p4">**</ept></target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Matches the previous element between <bpt id="p1">*</bpt>n<ept id="p1">*</ept> and <bpt id="p2">*</bpt>m<ept id="p2">*</ept> times, but as few times as possible.</source>
          <target state="translated">Trova la corrispondenza con l'elemento precedente tra <bpt id="p1">*</bpt>n<ept id="p1">*</ept> e <bpt id="p2">*</bpt>m<ept id="p2">*</ept> volte, ma il minor numero di volte possibile.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>"166", "17668"; "193", "024" in "193024"</source>
          <target state="translated">"166", "17668"; "193", "024" in "193024"</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Backreference Constructs</source>
          <target state="translated">Costrutti di backreference</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>A backreference allows a previously matched subexpression to be identified subsequently in the same regular expression.</source>
          <target state="translated">Un backreference consente a una sottoespressione di cui è stata trovata la corrispondenza in precedenza di essere identificata successivamente nella stessa espressione regolare.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The following table lists the backreference constructs supported by regular expressions in the .NET Framework.</source>
          <target state="translated">Nella tabella seguente sono elencati i costrutti di backreference supportati dalle espressioni regolari in .NET Framework.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Backreference constructs in regular expressions<ept id="p1">](backreference.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Costrutti di backreference nelle espressioni regolari<ept id="p1">](backreference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Backreference construct</source>
          <target state="translated">Costrutto di backreference</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Corrispondenze</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source><ph id="ph1">*</ph><bpt id="p1">*</bpt><ph id="ph2">\*</ph><ept id="p1">*</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept></source>
          <target state="translated"><ph id="ph1">*</ph><bpt id="p1">*</bpt><ph id="ph2">\*</ph><ept id="p1">*</ept><bpt id="p2">_</bpt>numero<ept id="p2">_</ept></target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Backreference.</source>
          <target state="translated">Backreference.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Matches the value of a numbered subexpression.</source>
          <target state="translated">Trova la corrispondenza del valore di una sottoespressione numerata.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>"ee" in "seek"</source>
          <target state="translated">"ee" in "seek"</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>nome<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Named backreference.</source>
          <target state="translated">Backreference denominato.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Matches the value of a named expression.</source>
          <target state="translated">Trova la corrispondenza del valore di un'espressione denominata.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>"ee" in "seek"</source>
          <target state="translated">"ee" in "seek"</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Alternation Constructs</source>
          <target state="translated">Costrutti di alternanza</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Alternation constructs modify a regular expression to enable either/or matching.</source>
          <target state="translated">I costrutti di alternanza modificano un'espressione regolare per abilitare la corrispondenza di tipo either/or.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>These constructs include the language elements listed in the following table.</source>
          <target state="translated">Questi costrutti includono gli elementi del linguaggio elencati nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Alternation constructs in regular expressions<ept id="p1">](alternation.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Costrutti di alternanza nelle espressioni regolari<ept id="p1">](alternation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Alternation construct</source>
          <target state="translated">Costrutto di alternanza</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Corrispondenze</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>&amp;#124;<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>&amp;#124;<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Matches any one element separated by the vertical bar (*&amp;#124;) character.</source>
          <target state="translated">Trova la corrispondenza di qualsiasi un elemento separato dal carattere di barra verticale (*&amp;#124;).</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>"the", "this" in "this is the day.</source>
          <target state="translated">"the", "this" in "this is the day.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>"</source>
          <target state="translated">"</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source><bpt id="p1">__</bpt>(?(<ept id="p1">__</ept><bpt id="p2">*</bpt>expression<ept id="p2">*</ept><bpt id="p3">__</bpt>)<ept id="p3">__</ept><bpt id="p4">*</bpt>yes<ept id="p4">*</ept><bpt id="p5">__</bpt>&amp;#124;<ept id="p5">__</ept><bpt id="p6">*</bpt>no<ept id="p6">*</ept><bpt id="p7">__</bpt>)<ept id="p7">__</ept></source>
          <target state="translated"><bpt id="p1">__</bpt>(?(<ept id="p1">__</ept><bpt id="p2">*</bpt>expression<ept id="p2">*</ept><bpt id="p3">__</bpt>)<ept id="p3">__</ept><bpt id="p4">*</bpt>yes<ept id="p4">*</ept><bpt id="p5">__</bpt>&amp;#124;<ept id="p5">__</ept><bpt id="p6">*</bpt>no<ept id="p6">*</ept><bpt id="p7">__</bpt>)<ept id="p7">__</ept></target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Matches <bpt id="p1">*</bpt>yes<ept id="p1">*</ept> if the regular expression pattern designated by <bpt id="p2">*</bpt>expression<ept id="p2">*</ept> matches; otherwise, matches the optional <bpt id="p3">*</bpt>no<ept id="p3">*</ept> part.</source>
          <target state="translated">Corrisponde a <bpt id="p1">*</bpt>yes<ept id="p1">*</ept> se il criterio di espressione regolare definito da <bpt id="p2">*</bpt>expression<ept id="p2">*</ept> corrisponde. In caso contrario, corrisponde alla parte <bpt id="p3">*</bpt>no<ept id="p3">*</ept> facoltativa.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>expression<ept id="p1">*</ept> is interpreted as a zero-width assertion.</source>
          <target state="translated"><bpt id="p1">*</bpt>expression<ept id="p1">*</ept> è interpretata come asserzione di larghezza zero.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>"A10", "910" in "A10 C103 910"</source>
          <target state="translated">"A10", "910" in "A10 C103 910"</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept>&amp;#124;<bpt id="p5">_</bpt>no<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept>&amp;#124;<bpt id="p5">_</bpt>no<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept></target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Matches <bpt id="p1">*</bpt>yes<ept id="p1">*</ept> if <bpt id="p2">*</bpt>name<ept id="p2">*</ept>, a named or numbered capturing group, has a match; otherwise, matches the optional <bpt id="p3">*</bpt>no<ept id="p3">*</ept>.</source>
          <target state="translated">Corrisponde a <bpt id="p1">*</bpt>yes<ept id="p1">*</ept> se esiste una corrispondenza per <bpt id="p2">*</bpt>name<ept id="p2">*</ept>, un gruppo di acquisizione denominato o numerato. In caso contrario, corrisponde alla parte <bpt id="p3">*</bpt>no<ept id="p3">*</ept> facoltativa.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Dogs.jpg, "Yiska playing.jpg" in "Dogs.jpg "Yiska playing.jpg""</source>
          <target state="translated">Dogs.jpg, "Yiska playing.jpg" in "Dogs.jpg "Yiska playing.jpg""</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Substitutions</source>
          <target state="translated">Sostituzioni</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Substitutions are regular expression language elements that are supported in replacement patterns.</source>
          <target state="translated">Le sostituzioni sono elementi del linguaggio di espressioni regolari supportati nei modelli di sostituzione.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Substitutions in regular expressions<ept id="p1">](substitutions.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Sostituzioni nelle espressioni regolari<ept id="p1">](substitutions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The metacharacters listed in the following table are atomic zero-width assertions.</source>
          <target state="translated">I metacaratteri elencati nella tabella seguente sono asserzioni atomiche di larghezza zero.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Character</source>
          <target state="translated">Carattere</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Replacement pattern</source>
          <target state="translated">Modello di sostituzione</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Input string</source>
          <target state="translated">Stringa di input</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Result string</source>
          <target state="translated">Stringa di risultato</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept></source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept></target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Substitutes the substring matched by group <bpt id="p1">*</bpt>number<ept id="p1">*</ept>.</source>
          <target state="translated">Sostituisce la sottostringa corrispondente al gruppo <bpt id="p1">*</bpt>number<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>"one two"</source>
          <target state="translated">"one two"</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>"two one"</source>
          <target state="translated">"two one"</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>${<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>${<ept id="p1">**</ept><bpt id="p2">_</bpt>nome<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Substitutes the substring matched by the named group <bpt id="p1">*</bpt>name<ept id="p1">*</ept>.</source>
          <target state="translated">Sostituisce la sottostringa corrispondente al gruppo denominato <bpt id="p1">*</bpt>nome<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>"one two"</source>
          <target state="translated">"one two"</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>"two one"</source>
          <target state="translated">"two one"</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Substitutes a literal "$".</source>
          <target state="translated">Sostituisce un valore letterale "$".</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>"103 USD"</source>
          <target state="translated">"103 USD"</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>"$103"</source>
          <target state="translated">"$103"</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Substitutes a copy of the whole match.</source>
          <target state="translated">Sostituisce una copia dell'intera corrispondenza.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>"$1.30"</source>
          <target state="translated">"$1.30"</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>"<bpt id="p1">**</bpt>$1.30<ept id="p1">**</ept>"</source>
          <target state="translated">"<bpt id="p1">**</bpt>$1.30<ept id="p1">**</ept>"</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Substitutes all the text of the input string before the match.</source>
          <target state="translated">Sostituisce tutto il testo della stringa di input prima della corrispondenza.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>"AABBCC"</source>
          <target state="translated">"AABBCC"</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>"AAAACC"</source>
          <target state="translated">"AAAACC"</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>$'<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>$'<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Substitutes all the text of the input string after the match.</source>
          <target state="translated">Sostituisce tutto il testo della stringa di input successiva alla corrispondenza.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>"AABBCC"</source>
          <target state="translated">"AABBCC"</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>"AACCCC"</source>
          <target state="translated">"AACCCC"</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Substitutes the last group that was captured.</source>
          <target state="translated">Sostituisce l'ultimo gruppo acquisito.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>"AABBCCDD"</source>
          <target state="translated">"AABBCCDD"</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>"AACCDD"</source>
          <target state="translated">"AACCDD"</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>$_<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>$_<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Substitutes the entire input string.</source>
          <target state="translated">Sostituisce l'intera stringa di input.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>"AABBCC"</source>
          <target state="translated">"AABBCC"</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>"AAAABBCCCC"</source>
          <target state="translated">"AAAABBCCCC"</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Regular Expression Options</source>
          <target state="translated">Opzioni di espressioni regolari</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>You can specify options that control how the regular expression engine interprets a regular expression pattern.</source>
          <target state="translated">È possibile specificare opzioni che controllano il modo in cui il motore delle espressioni regolari interpreta un criterio di espressione regolare.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Many of these options can be specified either inline (in the regular expression pattern) or as one or more <ph id="ph1">`RegexOptions`</ph> constants.</source>
          <target state="translated">Molte di queste opzioni possono essere specificate inline (nel criterio di espressione regolare) o come uno o più costanti <ph id="ph1">`RegexOptions`</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>This quick reference lists only inline options.</source>
          <target state="translated">Questa guida di riferimento rapida elenca solo le opzioni inline.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>For more information about inline and <ph id="ph1">`RegexOptions`</ph> options, see the article <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">Per altre informazioni sulle opzioni inline e <ph id="ph1">`RegexOptions`</ph>, vedere l'articolo <bpt id="p1">[</bpt>Opzioni di espressioni regolari<ept id="p1">](options.md)</ept>.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>You can specify an inline option in two ways:</source>
          <target state="translated">È possibile specificare un'opzione inline in due modi:</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>By using the miscellaneous construct <bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept>, where a minus sign (-) before an option or set of options turns those options off.</source>
          <target state="translated">Usando il costrutto vario <bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept>, dove un segno meno (-) prima di un'opzione o di un set di opzioni consente di disattivare tali opzioni.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">**</bpt>(?i-mn)<ept id="p1">**</ept> turns case-insensitive matching (i) on, turns multiline mode (<bpt id="p2">**</bpt>m<ept id="p2">**</ept>) off, and turns unnamed group captures (<bpt id="p3">**</bpt>n<ept id="p3">**</ept>) off.</source>
          <target state="translated">Ad esempio, <bpt id="p1">**</bpt>(?i-mn)<ept id="p1">**</ept> attiva la corrispondenza senza distinzione tra maiuscole e minuscole (i), disattiva la modalità su più righe (<bpt id="p2">**</bpt>m<ept id="p2">**</ept>) e disattiva le acquisizioni dei gruppi senza nome (<bpt id="p3">**</bpt>n<ept id="p3">**</ept>).</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>The option applies to the regular expression pattern from the point at which the option is defined, and is effective either to the end of the pattern or to the point where another construct reverses the option.</source>
          <target state="translated">L'opzione si applica al criterio di espressione regolare dal punto in cui l'opzione viene definita e diventa effettiva sia alla fine del criterio sia al punto in cui un altro costrutto annulla l'opzione.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>By using the grouping construct <bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>, which defines options for the specified group only.</source>
          <target state="translated">Usando il costrutto di raggruppamento <bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>sottoespressione<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>, che definisce le opzioni solo per il gruppo specificato.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The .NET regular expression engine supports the following inline options.</source>
          <target state="translated">Il motore delle espressioni regolari di .NET supporta le seguenti opzioni inline.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Opzione</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Criterio</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Corrispondenze</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>i<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>i<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Use case-insensitive matching.</source>
          <target state="translated">Usa la corrispondenza che non fa distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\b(?i)a(?-i)a\w+\b<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\b(?i)a(?-i)a\w+\b<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>"aardvark", "aaaAuto" in "aardvark AAAuto aaaAuto Adam breakfast"</source>
          <target state="translated">"aardvark", "aaaAuto" in "aardvark AAAuto aaaAuto Adam breakfast"</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>m<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Use multiline mode.</source>
          <target state="translated">Usare la modalità multiriga.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> match the beginning and end of a line, instead of the beginning and end of a string.</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> e <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> corrispondono all'inizio e alla fine di una riga, anziché all'inizio e alla fine di una stringa.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>For an example, see the "Multiline Mode" section in <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">Per un esempio, vedere la sezione "Modalità multiriga" in <bpt id="p1">[</bpt>Opzioni di espressioni regolari<ept id="p1">](options.md)</ept>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>n<ept id="p1">**</ept><ph id="ph1">*</ph></source>
          <target state="translated"><bpt id="p1">**</bpt>n<ept id="p1">**</ept><ph id="ph1">*</ph></target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>Do not capture unnamed groups.</source>
          <target state="translated">Non acquisire gruppi senza nome.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>For an example, see the "Explicit Captures Only" section in <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere la sezione "Solo acquisizioni esplicite" in <bpt id="p1">[</bpt>Opzioni di espressioni regolari<ept id="p1">](options.md)</ept>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>s<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>s<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>Use single-line mode.</source>
          <target state="translated">Usare la modalità a riga singola.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>For an example, see the "Single-line Mode" section in <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">Per un esempio, vedere la sezione "Modalità a riga singola" in <bpt id="p1">[</bpt>Opzioni di espressioni regolari<ept id="p1">](options.md)</ept>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>x<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>x<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>Ignore unescaped white space in the regular expression pattern.</source>
          <target state="translated">Ignorare gli spazi vuoti non di escape nel criterio di espressione regolare.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\b(?x) \d+ \s \w+<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\b(?x) \d+ \s \w+<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>"1 aardvark", "2 cats" in "1 aardvark 2 cats IV centurions"</source>
          <target state="translated">"1 aardvark", "2 cats" in "1 aardvark 2 cats IV centurions"</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>Miscellaneous Constructs</source>
          <target state="translated">Costrutti vari</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>Miscellaneous constructs either modify a regular expression pattern or provide information about it.</source>
          <target state="translated">I costrutti vari consentono di modificare un criterio di espressione regolare o forniscono informazioni su di esso.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The following table lists the miscellaneous constructs supported by the .NET.</source>
          <target state="translated">Nella tabella seguente sono elencati i costrutti vari supportati da .NET.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Miscellaneous Constructs in Regular Expressions<ept id="p1">](miscellaneous.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Costrutti vari nelle espressioni regolari<ept id="p1">](miscellaneous.md)</ept>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Construct</source>
          <target state="translated">Costrutto</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Definition</source>
          <target state="translated">Definizione</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Esempio</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>Sets or disables options such as case insensitivity in the middle of a pattern.</source>
          <target state="translated">Imposta o disabilita opzioni come la distinzione tra maiuscole e minuscole nella parte centrale di un modello.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Opzioni di espressioni regolari<ept id="p1">](options.md)</ept>.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\bA(?i)b\w+\b`</ph> matches "ABA", "Able" in "ABA Able Act"</source>
          <target state="translated"><ph id="ph1">`\bA(?i)b\w+\b`</ph> trova la corrispondenza di "ABA", "Able" in "ABA Able Act"</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?#<ept id="p1">**</ept> <bpt id="p2">_</bpt>comment<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?#<ept id="p1">**</ept> <bpt id="p2">_</bpt>comment<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Inline comment.</source>
          <target state="translated">Commento inline.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>The comment ends at the first closing parenthesis.</source>
          <target state="translated">Il commento termina in corrispondenza della prima parentesi chiusa.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\bA(?#`</ph> matches words starting with <ph id="ph2">`A)\w+\b`</ph></source>
          <target state="translated"><ph id="ph1">`\bA(?#`</ph> corrisponde a parole che iniziano con <ph id="ph2">`A)\w+\b`</ph></target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept> [to end of line]</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept> [fino alla fine della riga]</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>X-mode comment.</source>
          <target state="translated">Commento in modalità X.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>The comment starts at an unescaped # and continues to the end of the line.</source>
          <target state="translated">Il commento inizia da un carattere # senza codice di escape e continua fino alla fine della riga.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(?x)\bA\w+\b#`</ph> matches words starting with <ph id="ph2">`A`</ph></source>
          <target state="translated"><ph id="ph1">`(?x)\bA\w+\b#`</ph> corrisponde a parole che iniziano con <ph id="ph2">`A`</ph></target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vedere anche</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.RegularExpressions<ept id="p1">](xref:System.Text.RegularExpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.RegularExpressions<ept id="p1">](xref:System.Text.RegularExpressions)</ept></target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept></target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expressions in .NET<ept id="p1">](regular-expressions.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Espressioni regolari in .NET<ept id="p1">](regular-expressions.md)</ept></target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The regular expression object model<ept id="p1">](object-model.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Modello a oggetti delle espressioni regolari<ept id="p1">](object-model.md)</ept></target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression examples<ept id="p1">](regex-examples.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Esempi di espressioni regolari<ept id="p1">](regex-examples.md)</ept></target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Download in Word (.docx) format<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Download in formato Word (.docx)<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Download in PDF (.pdf) format<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Download in formato PDF (.pdf)<ept id="p1">](http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>