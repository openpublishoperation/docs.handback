<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02e2fa22e36fd2f6618527ad3c89cbbd8587dfe2</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\tour.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b5d2ad1e76f36733598999f425a89b00a11b9cd</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">486574494fd69fdc2cf6ac253f6e6e902ee27923</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Tour of .NET</source>
          <target state="translated">Panoramica di .NET</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>A guided tour through some of the prominent features of the .NET platform.</source>
          <target state="translated">Panoramica guidata di alcune delle principali funzionalità della piattaforma .NET.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, Tour, Programming Languages, Unsafe, Memory Management, Type Safety, Async</source>
          <target state="translated">.NET, .NET Core, panoramica, linguaggi di programmazione, unsafe, gestione della memoria, indipendenza dai tipi, asincrono</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Tour of .NET</source>
          <target state="translated">Panoramica di .NET</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>.NET is a general purpose development platform.</source>
          <target state="translated">.NET è una piattaforma di sviluppo con finalità generali</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It has several key features, such as multiple programming languages, asynchronous and concurrent programming models, and native interoperability which enable a wide range of scenarios across multiple platforms.</source>
          <target state="translated">che offre varie funzionalità chiave, tra cui più linguaggi di programmazione, modelli di programmazione asincroni e simultanei e l'interoperabilità nativa, che consente l'esecuzione di un'ampia gamma di scenari su più piattaforme.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This article offers a guided tour through some of the key features of the .NET platform.</source>
          <target state="translated">Questo articolo offre una panoramica guidata di alcune delle principali funzionalità della piattaforma .NET.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>.NET Architectural Components<ept id="p1">](components.md)</ept> to learn about each of the architectural "pieces" of .NET and what they're used for.</source>
          <target state="translated">Per informazioni su tutti i componenti dell'architettura di .NET e sulle relative modalità d'uso, vedere <bpt id="p1">[</bpt>Componenti dell'architettura .NET<ept id="p1">](components.md)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>How to run the code samples</source>
          <target state="translated">Come eseguire i codici di esempio</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To learn how to set up a development environment to run the code samples, check out <bpt id="p1">[</bpt>Getting Started<ept id="p1">](getting-started.md)</ept>.</source>
          <target state="translated">Per informazioni su come configurare un ambiente di sviluppo all'interno del quale eseguire i codici di esempio, vedere l'articolo <bpt id="p1">[</bpt>Introduzione<ept id="p1">](getting-started.md)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can copy and paste code samples from this page into your environment to execute them.</source>
          <target state="translated">È possibile copiare i codici di esempio da questa pagina e incollarli nel proprio ambiente per eseguirli.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In the future, this documentation site will have the ability to run these code samples in your browser.</source>
          <target state="translated">In futuro, da questo sito di programmazione sarà possibile eseguire i codici di esempio direttamente nel proprio browser.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Programming languages</source>
          <target state="translated">Linguaggi di programmazione</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>.NET supports multiple programming languages.</source>
          <target state="translated">.NET supporta più linguaggi di programmazione.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>.NET runtimes implement the <bpt id="p1">[</bpt>Common Language Infrastructure (CLI)<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>, which (among other things) specifies a language-independent runtime and language interoperability.</source>
          <target state="translated">I runtime .NET implementano l'<bpt id="p1">[</bpt>interfaccia della riga di comando<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept> (CLI, Common Language Infrastructure) che, tra altre cose, specifica un runtime indipendente dal linguaggio e l'interoperabilità di linguaggio.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This means that you can choose any .NET language to build apps and services on .NET.</source>
          <target state="translated">In questo modo, è possibile scegliere qualsiasi linguaggio .NET per creare applicazioni e servizi in .NET.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic .NET.</source>
          <target state="translated">Microsoft sviluppa e supporta attivamente tre linguaggi .NET: C#, F# e Visual Basic .NET.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages.</source>
          <target state="translated">C# è un linguaggio semplice, potente, indipendente dai tipi e orientato agli oggetti che mantiene al tempo stesso l'espressività e l'eleganza tipiche dei linguaggi di tipo C.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Anyone familiar with C and similar languages will find few problems in adapting to C#.</source>
          <target state="translated">Gli sviluppatori che hanno familiarità con C e linguaggi simili incontreranno pochi problemi ad adattarsi a C#.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>C# Guide<ept id="p1">](../csharp/index.md)</ept> to learn more about C#.</source>
          <target state="translated">Per altre informazioni su C#, vedere <bpt id="p1">[</bpt>Guida a C#<ept id="p1">](../csharp/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</source>
          <target state="translated">F# è un linguaggio di programmazione multipiattaforma e funzionale che supporta anche la programmazione tradizionale imperativa e orientata agli oggetti.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>F# Guide<ept id="p1">](../fsharp/index.md)</ept> to learn more about F#.</source>
          <target state="translated">Per altre informazioni su F#, vedere <bpt id="p1">[</bpt>Guida a F#<ept id="p1">](../fsharp/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.</source>
          <target state="translated">Visual Basic è un linguaggio semplice da apprendere che consente di creare una vasta gamma di applicazioni da eseguire in .NET.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Automatic memory management</source>
          <target state="translated">Gestione automatica della memoria</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>.NET uses <bpt id="p1">[</bpt>garbage collection<ept id="p1">](garbagecollection/index.md)</ept> to provide automatic memory management for programs.</source>
          <target state="translated">.NET usa <bpt id="p1">[</bpt>Garbage Collector<ept id="p1">](garbagecollection/index.md)</ept> per consentire la gestione automatica della memoria per i programmi.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.</source>
          <target state="translated">Il Garbage Collector ha un approccio "lazy" alla gestione della memoria, anteponendo la velocità effettiva dell'applicazione alla raccolta immediata di memoria.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To learn more about the .NET GC, check out <bpt id="p1">[</bpt>Fundamentals of garbage collection (GC)<ept id="p1">](garbagecollection/fundamentals.md)</ept>.</source>
          <target state="translated">Per altre informazioni sul Garbage Collector di.NET, vedere <bpt id="p1">[</bpt>Principi fondamentali di Garbage Collection<ept id="p1">](garbagecollection/fundamentals.md)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following two lines both allocate memory:</source>
          <target state="translated">Le due righe di codice seguenti allocano entrambe memoria:</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>There is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</source>
          <target state="translated">Non esiste una parola chiave analoga per deallocare la memoria, in quanto la deallocazione viene eseguita automaticamente quando il Garbage Collector recupera la memoria durante l'esecuzione pianificata.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Types within a given scope normally go out of scope once a method completes, at which point they can be collected.</source>
          <target state="translated">I tipi presenti all'interno di un ambito in genere escono dall'ambito dopo il completamento del metodo e a quel punto possono essere raccolte.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the <ph id="ph1">`using`</ph> statement:</source>
          <target state="translated">È tuttavia possibile indicare al Garbage Collector che un particolare oggetto è fuori ambito prima del completamento del metodo usando l'istruzione <ph id="ph1">`using`</ph>:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L6-L9)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L6-L9)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Once the <ph id="ph1">`using`</ph> block completes, the GC will know that the <ph id="ph2">`stream`</ph> object in the previous example is free to be collected and its memory reclaimed.</source>
          <target state="translated">Dopo il completamento del blocco <ph id="ph1">`using`</ph>, il Garbage Collector saprà che l'oggetto <ph id="ph2">`stream`</ph> dell'esempio precedente può essere raccolto e che la relativa memoria può essere recuperata.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Rules for this have slightly different semantics in F#.</source>
          <target state="translated">In F # queste regole hanno una semantica leggermente diversa.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>To learn more about resource management in F#, check out <bpt id="p1">[</bpt>Resource Management: The <ph id="ph1">`use`</ph> Keyword<ept id="p1">](../fsharp/language-reference/resource-management-the-use-keyword.md)</ept></source>
          <target state="translated">Per altre informazioni sulla gestione delle risorse in F#, vedere <bpt id="p1">[</bpt>Resource Management: The <ph id="ph1">`use`</ph> Keyword<ept id="p1">](../fsharp/language-reference/resource-management-the-use-keyword.md)</ept> (Gestione delle risorse: parola chiave <ph id="ph1">`use`</ph>)</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>One of the less obvious but quite far-reaching features that a garbage collector enables is memory safety.</source>
          <target state="translated">Una delle funzionalità meno ovvie, ma più potenti di Garbage Collector è la sicurezza della memoria.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).</source>
          <target state="translated">L'invariante di sicurezza della memoria è molto semplice: un programma garantisce la sicurezza della memoria se accede soltanto alla memoria che è stata allocata (e non liberata).</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Dangling pointers are always bugs, and tracking them down is often quite difficult.</source>
          <target state="translated">I puntatori tralasciati rappresentano sempre un errore e tenerne traccia è spesso piuttosto difficile.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The .NET runtime provides additional services, to complete the promise of memory safety, not naturally offered by a GC.</source>
          <target state="translated">Per garantire la sicurezza della memoria, il runtime .NET offre servizi aggiuntivi che non sono normalmente forniti da un Garbage Collector.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>It ensures that programs do not index off the end of an array or accessing a phantom field off the end of an object.</source>
          <target state="translated">Assicura infatti che i programmi non eseguano l'indicizzazione oltre la fine di un array o accedano a un campo fantasma oltre la fine di un oggetto.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following example will throw an exception as a result of memory safety.</source>
          <target state="translated">L'esempio seguente genera un'eccezione come risultato della sicurezza della memoria.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L11-L12)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L11-L12)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Type safety</source>
          <target state="translated">Indipendenza dai tipi</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Objects are allocated in terms of types.</source>
          <target state="translated">Gli oggetti vengono allocati in termini di tipi.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The only operations allowed for a given object, and the memory it consumes, are those of its type.</source>
          <target state="translated">Le uniche operazioni consentite per un determinato oggetto e per la memoria che utilizza sono quelle del relativo tipo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dog`</ph> type may have <ph id="ph2">`Jump`</ph> and <ph id="ph3">`WagTail`</ph> methods, but not likely a <ph id="ph4">`SumTotal`</ph> method.</source>
          <target state="translated">Un oggetto <ph id="ph1">`Dog`</ph> può avere i metodi <ph id="ph2">`Jump`</ph> e <ph id="ph3">`WagTail`</ph>, ma è improbabile che abbia un metodo <ph id="ph4">`SumTotal`</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A program can only call the declared methods of a given type.</source>
          <target state="translated">Un programma può chiamare soltanto i metodi dichiarati di un determinato tipo.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or <ph id="ph1">`object`</ph>).</source>
          <target state="translated">Tutte le altre chiamate genereranno un errore in fase di compilazione o un'eccezione di runtime (se si usano funzionalità dinamiche o <ph id="ph1">`object`</ph>).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>.NET languages are object-oriented, with hierarchies of base and derived classes.</source>
          <target state="translated">I linguaggi .NET sono orientati agli oggetti, con gerarchie di classi di base e derivate.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The .NET runtime will only allow object casts and calls that align with the object hierarchy.</source>
          <target state="translated">Il runtime .NET consentirà solo cast degli oggetti e chiamate allineate alla gerarchia di oggetti.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Remember that every type defined in any .NET language derives from the base <ph id="ph1">`object`</ph> type.</source>
          <target state="translated">Si tenga presente che ogni tipo definito in un qualsiasi linguaggio .NET deriva dal tipo di base <ph id="ph1">`object`</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</source>
          <target state="translated">L'indipendenza dai tipi viene inoltre usata per forzare l'incapsulamento garantendo la fedeltà delle parole chiave di accesso.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Accessor keywords are artifacts which control access to members of a given type by other code.</source>
          <target state="translated">Le parole chiave di accesso sono elementi che controllano l'accesso ai membri di un determinato tipo da parte di altro codice.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>These are usually used for various kinds of data within a type that are used to manage its behavior.</source>
          <target state="translated">Vengono in genere usate per diversi dati presenti all'interno di un tipo e per gestire il comportamento del tipo stesso.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>C#, Visual Basic, and F# support local <bpt id="p1">**</bpt>type inference<ept id="p1">**</ept>.</source>
          <target state="translated">C#, Visual Basic e F# supportano l'<bpt id="p1">**</bpt>inferenza del tipo<ept id="p1">**</ept> locale.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side.</source>
          <target state="translated">Con l'inferenza del tipo, il compilatore dedurrà il tipo dell'espressione sul lato sinistro dall'espressione sul lato destro.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This doesn't mean that the type safety is broken or avoided.</source>
          <target state="translated">Questo non significa che l'indipendenza dai tipi è interrotta o evitata.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The resulting type <bpt id="p1">**</bpt>has<ept id="p1">**</ept> a strong type with everything that implies.</source>
          <target state="translated">Il tipo risultante <bpt id="p1">**</bpt>ha<ept id="p1">**</ept> un tipo sicuro, con tutto quello che implica tale caratteristica.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Let's rewrite the first two lines of the previous example to introduce type inference.</source>
          <target state="translated">Di seguito vengono riscritte le prime due righe dell'esempio precedente per introdurre l'inferenza del tipo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Note that the rest of the example is completely the same.</source>
          <target state="translated">Il resto dell'esempio non viene modificato.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>F# has even further type inference capabilities than method-local type inference found in C# and Visual Basic.</source>
          <target state="translated">Oltre all'inferenza del tipo locale del metodo disponibile in C# e Visual Basic, F# offre anche altre funzionalità di inferenza del tipo.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>To learn more, check out <bpt id="p1">[</bpt>Type Inference<ept id="p1">](../fsharp/language-reference/type-inference.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Inferenza del tipo<ept id="p1">](../fsharp/language-reference/type-inference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">Delegati e lambda</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Delegates are like C++ function pointers, with a big difference that they are type safe.</source>
          <target state="translated">I delegati sono simili ai puntatori alle funzioni del linguaggio C++, ma con l'importante differenza che sono indipendenti dai tipi.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>They are a kind of disconnected method within the CLR type system.</source>
          <target state="translated">Sono un tipo di metodo disconnesso all'interno del sistema di tipo CLR.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Regular methods are attached to a class and only directly callable through static or instance calling conventions.</source>
          <target state="translated">I metodi regolari sono collegati a una classe e possono essere chiamati direttamente solo tramite convenzioni di chiamata statiche o di istanza.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Delegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.</source>
          <target state="translated">Nel mondo .NET i delegati vengono usati in diverse API e ubicazioni, in particolare nelle espressioni lambda, che costituiscono uno dei fondamenti di LINQ.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept> document.</source>
          <target state="translated">Per altre informazioni, vedere il documento <bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept> (Delegati e lambda).</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Generics are a feature that was added in .NET Framework 2.0.</source>
          <target state="translated">I generics sono una funzionalità aggiunta a .NET Framework 2.0.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In short, generics allow the programmer to introduce a "type parameter" when designing their classes, that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</source>
          <target state="translated">In breve, i generics consentono al programmatore di introdurre un "parametro di tipo" durante la definizione delle classi, operazione che consente al codice client (gli utenti del tipo) di specificare il tipo esatto da usare al posto del parametro di tipo.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Generics were added to help programmers implement generic data structures.</source>
          <target state="translated">I generics sono stati aggiunti per consentire ai programmatori di implementare strutture dati generiche.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Before their arrival, in order for a, say, <ph id="ph1">`List`</ph> type to be generic, it would have to work with elements that were of type <ph id="ph2">`object`</ph>.</source>
          <target state="translated">Prima della loro introduzione, per rendere un tipo <ph id="ph1">`List`</ph> generico sarebbe stato necessario usare elementi di tipo <ph id="ph2">`object`</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This would have various performance as well as semantic problems, not to mention possible subtle runtime errors.</source>
          <target state="translated">Questa soluzione poteva determinare diversi problemi sia a livello semantico che delle prestazioni, per non parlare dei possibili subdoli errori di runtime.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <ph id="ph1">`InvalidCastException`</ph> is thrown on working with the list's members.</source>
          <target state="translated">Il più noto di questi ultimi è la situazione in cui una struttura di dati contiene, ad esempio, sia numeri interi che stringhe. Quando si usano i membri dell'elenco, viene generata un'eccezione di tipo <ph id="ph1">`InvalidCastException`</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following sample shows a basic program running using an instance of <ph id="ph1">@System.Collections.Generic.List%601</ph> types.</source>
          <target state="translated">L'esempio seguente mostra un programma di base in esecuzione mediante un'istanza dei tipi <ph id="ph1">@System.Collections.Generic.List%601</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GenericsShort<ept id="p2">](../../samples/csharp/snippets/tour/GenericsShort.csx)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GenericsShort<ept id="p2">](../../samples/csharp/snippets/tour/GenericsShort.csx)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept> article.</source>
          <target state="translated">Per altre informazioni, vedere l'articolo <bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept> (Panoramica sui tipi generici (Generics)).</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Async programming</source>
          <target state="translated">Programmazione asincrona</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Async programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs.</source>
          <target state="translated">La programmazione asincrona è uno dei concetti fondamentali di .NET, poiché offre supporto asincrono nel runtime, nelle librerie del framework e nei costrutti dei linguaggi .NET.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Internally, they are based off of objects (such as <ph id="ph1">`Task`</ph>) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</source>
          <target state="translated">A livello interno, questi elementi sono basati su oggetti, ad esempio <ph id="ph1">`Task`</ph>, e sfruttano i vantaggi offerti dal sistema operativo per eseguire i processi di I/O nel modo più efficiente possibile.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To learn more about async programming in .NET, start with the <bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept>.</source>
          <target state="translated">Per altre informazioni sulla programmazione asincrona in .NET, iniziare con la lettura dell'articolo <bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept> (Panoramica sulla programmazione asincrona).</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ)</source>
          <target state="translated">LINQ (Language-Integrated Query)</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</source>
          <target state="translated">LINQ è un potente set di funzionalità per C# e Visual Basic che consente di scrivere codice semplice e dichiarativo per operare sui dati.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!</source>
          <target state="translated">I dati possono avere diverse forme, ad esempio oggetti in memoria, dati in un database SQL o un documento XML, ma il codice LINQ è in genere uguale per le diverse origini dati.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>To learn more and see some samples, check out <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</source>
          <target state="translated">Per altre informazioni e alcuni esempi, vedere <bpt id="p1">[</bpt>LINQ (Language-Integrated Query)<ept id="p1">](using-linq.md)</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">Interoperabilità nativa</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Every operating system in current use provides a lot of platform support for various programming tasks.</source>
          <target state="translated">Ogni sistema operativo in uso offre un notevole supporto alla piattaforma per diverse attività di programmazione.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>.NET provides several ways to tap into those APIs.</source>
          <target state="translated">.NET consente di accedere a tali API in diversi modi.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Collectively, this support is called "native interoperability" and in this section we will take a look at how to access native APIs from managed, .NET code.</source>
          <target state="translated">Nel suo insieme, questo supporto è denominato "interoperabilità nativa". Questa sezione spiega come accedere ad API native da codice .NET gestito.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The main way to do native interoperability is via "platform invoke" or P/Invoke for short.</source>
          <target state="translated">Il metodo principale per ottenere l'interoperabilità nativa è usare "platform invoke", abbreviato in P/Invoke.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>This support in .NET Core is available across Linux and Windows platforms.</source>
          <target state="translated">In .NET Core questo supporto è disponibile nelle piattaforme Linux e Windows.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Another, Windows-only way of doing native interoperability is known as "COM interop" which is used to work with <bpt id="p1">[</bpt>COM components<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in managed code.</source>
          <target state="translated">Un altro metodo, valido solo per Windows, per ottenere l'interoperabilità nativa è noto come "interoperabilità COM" ed è usato per operare con <bpt id="p1">[</bpt>componenti COM<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> nel codice gestito.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>It is built on top of P/Invoke infrastructure, but it works in subtly different ways.</source>
          <target state="translated">Tale metodo è basato sull'infrastruttura P/Invoke, ma funziona in modo leggermente diverso.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</source>
          <target state="translated">La maggior parte del supporto per l'interoperabilità di Mono (e di Xamarin) per Java e Objective-C è realizzato in modo simile, nel senso che vengono usati gli stessi principi.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept> document.</source>
          <target state="translated">Per altre informazioni, vedere il documento <bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept> (Interoperabilità nativa).</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Unsafe code</source>
          <target state="translated">Codice di tipo unsafe</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The CLR enables the ability to access native memory and do pointer arithmetic via <ph id="ph1">`unsafe`</ph> code.</source>
          <target state="translated">CLR consente di accedere alla memoria nativa e di eseguire operazioni di aritmetica dei puntatori tramite codice <ph id="ph1">`unsafe`</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>These operations are needed for certain algorithms and system interoperability.</source>
          <target state="translated">Queste operazioni sono necessarie per determinati algoritmi e per l'interoperabilità dei sistemi.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm.</source>
          <target state="translated">Anche se il codice di tipo unsafe è uno strumento potente, non è consigliabile usarlo a meno che non sia necessario per l'interoperabilità con API di sistema o per implementare l'algoritmo più efficiente.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety.</source>
          <target state="translated">Il codice di tipo unsafe non può essere eseguito nello stesso modo in ambienti diversi e inoltre non sfrutta i vantaggi offerti da un Garbage Collector e dall'indipendenza dai tipi.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.</source>
          <target state="translated">È consigliabile limitare e centralizzare il codice di tipo unsafe nella misura massima possibile. È inoltre necessario testare tale codice in modo accurato.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The following example is a modified version of the <ph id="ph1">`ToString()`</ph> method from the <ph id="ph2">`StringBuilder`</ph> class.</source>
          <target state="translated">L'esempio seguente è una versione modificata del metodo <ph id="ph1">`ToString()`</ph> della classe <ph id="ph2">`StringBuilder`</ph></target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>It illustrates how using <ph id="ph1">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:</source>
          <target state="translated">e illustra come l'uso di codice <ph id="ph1">`unsafe`</ph> possa implementare in modo efficiente un algoritmo spostando direttamente blocchi di memoria:</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Unsafe<ept id="p2">](../../samples/csharp/snippets/tour/Unsafe.csx)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Unsafe<ept id="p2">](../../samples/csharp/snippets/tour/Unsafe.csx)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">Passaggi successivi</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If you're interested in a tour of C# features, check out <bpt id="p1">[</bpt>Tour of C#<ept id="p1">](../csharp/tour-of-csharp/index.md)</ept>.</source>
          <target state="translated">Per una panoramica delle funzionalità di C#, vedere <bpt id="p1">[</bpt>Tour of C#<ept id="p1">](../csharp/tour-of-csharp/index.md)</ept> (Panoramica di C#).</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If you're interested in a tour of F# features, check out <bpt id="p1">[</bpt>Tour of F#<ept id="p1">](../fsharp/tour.md)</ept>.</source>
          <target state="translated">Per una panoramica delle funzionalità di F#, vedere l'articolo <bpt id="p1">[</bpt>Tour of F#<ept id="p1">](../fsharp/tour.md)</ept> (Panoramica di F#).</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>If you want to get started with writing code of your own, check out <bpt id="p1">[</bpt>Getting Started<ept id="p1">](getting-started.md)</ept>.</source>
          <target state="translated">Per un'introduzione alla scrittura di codice personalizzato, vedere <bpt id="p1">[</bpt>Introduzione<ept id="p1">](getting-started.md)</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>To learn about important components of .NET, check out <bpt id="p1">[</bpt>.NET Architectural Components<ept id="p1">](components.md)</ept>.</source>
          <target state="translated">Per informazioni sui componenti principali di .NET, vedere <bpt id="p1">[</bpt>Componenti dell'architettura .NET<ept id="p1">](components.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>