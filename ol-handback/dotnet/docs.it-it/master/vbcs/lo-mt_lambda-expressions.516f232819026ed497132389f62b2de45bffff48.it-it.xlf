<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e50593e76afecfe8807c3cb5bac479245d2feaef</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\procedures\lambda-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">895acd633a8cda2558af76ac524637fade1ae4a5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">517194bfb46ad17da82f6dda81810b1bb170a967</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Lambda Expressions (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Le espressioni lambda (Visual Basic) | Documenti di Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Lambda Expressions (Visual Basic)</source>
          <target state="translated">Espressioni lambda (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>lambda expression<ept id="p1">*</ept> is a function or subroutine without a name that can be used wherever a delegate is valid.</source>
          <target state="translated">Oggetto <bpt id="p1">*</bpt>espressione lambda<ept id="p1">*</ept> è una funzione o subroutine senza nome, che può essere utilizzato ovunque sia valido un delegato.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be functions or subroutines and can be single-line or multi-line.</source>
          <target state="translated">Le espressioni lambda possono essere funzioni o subroutine e possono essere a riga singola o multiriga.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can pass values from the current scope to a lambda expression.</source>
          <target state="translated">È possibile passare valori dall'ambito corrente in un'espressione lambda.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`RemoveHandler`</ph> statement is an exception.</source>
          <target state="translated">Il <ph id="ph1">`RemoveHandler`</ph> istruzione è un'eccezione.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You cannot pass a lambda expression in for the delegate parameter of <ph id="ph1">`RemoveHandler`</ph>.</source>
          <target state="translated">Non è possibile passare un'espressione lambda in per il parametro del delegato <ph id="ph1">`RemoveHandler`</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You create lambda expressions by using the <ph id="ph1">`Function`</ph> or <ph id="ph2">`Sub`</ph> keyword, just as you create a standard function or subroutine.</source>
          <target state="translated">Per creare espressioni lambda, utilizzare il <ph id="ph1">`Function`</ph> o <ph id="ph2">`Sub`</ph> (parola chiave), come se si crea una subroutine o una funzione standard.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>However, lambda expressions are included in a statement.</source>
          <target state="translated">Tuttavia, le espressioni lambda sono inclusi in un'istruzione.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following example is a lambda expression that increments its argument and returns the value.</source>
          <target state="translated">Nell'esempio seguente è un'espressione lambda che incrementa il proprio argomento e restituisce il valore.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The example shows both the single-line and multi-line lambda expression syntax for a function.</source>
          <target state="translated">L'esempio mostra sia la sintassi delle espressioni lambda a riga singola e a più righe per una funzione.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#14<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#14;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The following example is a lambda expression that writes a value to the console.</source>
          <target state="translated">Nell'esempio seguente è un'espressione lambda che scrive un valore nella console.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The example shows both the single-line and multi-line lambda expression syntax for a subroutine.</source>
          <target state="translated">L'esempio mostra sia la sintassi delle espressioni lambda a riga singola e a più righe di una subroutine.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#15<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#15;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Notice that in the previous examples the lambda expressions are assigned to a variable name.</source>
          <target state="translated">Si noti che, negli esempi precedenti le espressioni lambda vengono assegnate un nome di variabile.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Whenever you refer to the variable, you invoke the lambda expression.</source>
          <target state="translated">Quando si fa riferimento alla variabile, richiamare l'espressione lambda.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can also declare and invoke a lambda expression at the same time, as shown in the following example.</source>
          <target state="translated">È anche possibile dichiarare e richiamare un'espressione lambda nello stesso momento, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#3<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas n.&amp;3;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A lambda expression can be returned as the value of a function call (as is shown in the example in the <bpt id="p1">[</bpt>Context<ept id="p1">](#context)</ept> section later in this topic), or passed in as an argument to a parameter that takes a delegate type, as shown in the following example.</source>
          <target state="translated">Un'espressione lambda può essere restituita come valore di una chiamata di funzione (come illustrato nell'esempio di <bpt id="p1">[</bpt>contesto<ept id="p1">](#context)</ept> sezione più avanti in questo argomento), o passato come argomento a un parametro che accetta un tipo delegato, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#8<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas n.&amp;8;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Lambda Expression Syntax</source>
          <target state="translated">Sintassi delle espressioni lambda</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The syntax of a lambda expression resembles that of a standard function or subroutine.</source>
          <target state="translated">La sintassi di un'espressione lambda è simile a quello di una subroutine o una funzione standard.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The differences are as follows:</source>
          <target state="translated">Le differenze sono come segue:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A lambda expression does not have a name.</source>
          <target state="translated">Un'espressione lambda non ha un nome.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Lambda expressions cannot have modifiers, such as <ph id="ph1">`Overloads`</ph> or <ph id="ph2">`Overrides`</ph>.</source>
          <target state="translated">Espressioni lambda non possono avere modificatori, ad esempio <ph id="ph1">`Overloads`</ph> o <ph id="ph2">`Overrides`</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Single-line lambda functions do not use an <ph id="ph1">`As`</ph> clause to designate the return type.</source>
          <target state="translated">Le funzioni lambda a riga singola non utilizzano un <ph id="ph1">`As`</ph> clausola per definire il tipo restituito.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Instead, the type is inferred from the value that the body of the lambda expression evaluates to.</source>
          <target state="translated">Al contrario, il tipo viene dedotto dal valore che restituisce il corpo dell'espressione lambda.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For example, if the body of the lambda expression is <ph id="ph1">`cust.City = "London"`</ph>, its return type is <ph id="ph2">`Boolean`</ph>.</source>
          <target state="translated">Ad esempio, se il corpo dell'espressione lambda è <ph id="ph1">`cust.City = "London"`</ph>, il tipo restituito <ph id="ph2">`Boolean`</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>In multi-line lambda functions, you can either specify a return type by using an <ph id="ph1">`As`</ph> clause, or omit the <ph id="ph2">`As`</ph> clause so that the return type is inferred.</source>
          <target state="translated">Nelle funzioni lambda su più righe, è possibile specificare un tipo restituito tramite un <ph id="ph1">`As`</ph> clausola, oppure omettere il <ph id="ph2">`As`</ph> clausola in modo che il tipo restituito viene dedotto.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`As`</ph> clause is omitted for a multi-line lambda function, the return type is inferred to be the dominant type from all the <ph id="ph2">`Return`</ph> statements in the multi-line lambda function.</source>
          <target state="translated">Quando il <ph id="ph1">`As`</ph> clausola viene omessa per una funzione lambda su più righe, il tipo restituito viene considerato il tipo dominante da tutti i <ph id="ph2">`Return`</ph> istruzioni nella funzione lambda su più righe.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>dominant type<ept id="p1">*</ept> is a unique type that all other types can widen to.</source>
          <target state="translated">Il <bpt id="p1">*</bpt>tipo dominante<ept id="p1">*</ept> è un tipo univoco che possono ampliarsi tutti gli altri tipi.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If this unique type cannot be determined, the dominant type is the unique type that all other types in the array can narrow to.</source>
          <target state="translated">Se non è possibile determinare il tipo univoco, il tipo dominante è il tipo univoco possono restringersi tutti gli altri tipi nella matrice.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If neither of these unique types can be determined, the dominant type is <ph id="ph1">`Object`</ph>.</source>
          <target state="translated">Se nessuno di questi tipi univoci può essere determinato, il tipo dominante è <ph id="ph1">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In this case, if <ph id="ph1">`Option Strict`</ph> is set to <ph id="ph2">`On`</ph>, a compiler error occurs.</source>
          <target state="translated">In questo caso, se <ph id="ph1">`Option Strict`</ph> è impostato su <ph id="ph2">`On`</ph>, si verifica un errore del compilatore.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, if the expressions supplied to the <ph id="ph1">`Return`</ph> statement contain values of type <ph id="ph2">`Integer`</ph>, <ph id="ph3">`Long`</ph>, and <ph id="ph4">`Double`</ph>, the resulting array is of type <ph id="ph5">`Double`</ph>.</source>
          <target state="translated">Ad esempio, se le espressioni fornite per la <ph id="ph1">`Return`</ph> istruzione contengono valori di tipo <ph id="ph2">`Integer`</ph>, <ph id="ph3">`Long`</ph>, e <ph id="ph4">`Double`</ph>, la matrice risultante è di tipo <ph id="ph5">`Double`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">`Integer`</ph> and <ph id="ph2">`Long`</ph> widen to <ph id="ph3">`Double`</ph> and only <ph id="ph4">`Double`</ph>.</source>
          <target state="translated">Entrambi <ph id="ph1">`Integer`</ph> e <ph id="ph2">`Long`</ph> ampliarsi <ph id="ph3">`Double`</ph> e solo <ph id="ph4">`Double`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Therefore, <ph id="ph1">`Double`</ph> is the dominant type.</source>
          <target state="translated"><ph id="ph1">`Double`</ph> è pertanto il tipo dominante.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Widening and Narrowing Conversions<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>conversioni di ampliamento e restrizione<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The body of a single-line function must be an expression that returns a value, not a statement.</source>
          <target state="translated">Il corpo di una funzione a riga singola deve essere un'espressione che restituisce un valore, non un'istruzione.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>There is no <ph id="ph1">`Return`</ph> statement for single-line functions.</source>
          <target state="translated">Non esiste alcun <ph id="ph1">`Return`</ph> istruzione per le funzioni a riga singola.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The value returned by the single-line function is the value of the expression in the body of the function.</source>
          <target state="translated">Il valore restituito dalla funzione a riga singola è il valore dell'espressione nel corpo della funzione.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The body of a single-line subroutine must be single-line statement.</source>
          <target state="translated">Il corpo di una subroutine a riga singola deve essere a riga singola istruzione.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Single-line functions and subroutines do not include an <ph id="ph1">`End Function`</ph> or <ph id="ph2">`End Sub`</ph> statement.</source>
          <target state="translated">Funzioni a riga singola e le subroutine non includono un <ph id="ph1">`End Function`</ph> o <ph id="ph2">`End Sub`</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can specify the data type of a lambda expression parameter by using the <ph id="ph1">`As`</ph> keyword, or the data type of the parameter can be inferred.</source>
          <target state="translated">È possibile specificare il tipo di dati di un parametro di espressione lambda con il <ph id="ph1">`As`</ph> parola chiave o il tipo di dati del parametro può essere dedotto.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Either all parameters must have specified data types or all must be inferred.</source>
          <target state="translated">Tutti i parametri devono avere specificato deve essere dedotto, tipi di dati o tutti.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Optional`</ph> and <ph id="ph2">`Paramarray`</ph> parameters are not permitted.</source>
          <target state="translated"><ph id="ph1">`Optional`</ph>e <ph id="ph2">`Paramarray`</ph> i parametri non sono consentiti.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Generic parameters are not permitted.</source>
          <target state="translated">Parametri generici non sono consentiti.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Async Lambdas</source>
          <target state="translated">Espressioni lambda asincrone</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can easily create lambda expressions and statements that incorporate asynchronous processing by using the <bpt id="p1">[</bpt>Async<ept id="p1">](../../../../visual-basic/language-reference/modifiers/async.md)</ept> and <bpt id="p2">[</bpt>Await Operator<ept id="p2">](../../../../visual-basic/language-reference/operators/await-operator.md)</ept> keywords.</source>
          <target state="translated">È possibile creare con facilità le espressioni lambda e le istruzioni che includono l'elaborazione asincrona utilizzando il <bpt id="p1">[</bpt>Async<ept id="p1">](../../../../visual-basic/language-reference/modifiers/async.md)</ept> e <bpt id="p2">[</bpt>operatore Await<ept id="p2">](../../../../visual-basic/language-reference/operators/await-operator.md)</ept> parole chiave.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, the following Windows Forms example contains an event handler that calls and awaits an async method, <ph id="ph1">`ExampleMethodAsync`</ph>.</source>
          <target state="translated">Nell'esempio seguente di Windows Form è presente un gestore eventi che chiama e attende un metodo asincrono, <ph id="ph1">`ExampleMethodAsync`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can add the same event handler by using an async lambda in an <bpt id="p1">[</bpt>AddHandler Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/addhandler-statement.md)</ept>.</source>
          <target state="translated">È possibile aggiungere lo stesso gestore eventi utilizzando un'espressione lambda asincrona in un <bpt id="p1">[</bpt>AddHandler (istruzione)<ept id="p1">](../../../../visual-basic/language-reference/statements/addhandler-statement.md)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>To add this handler, add an <ph id="ph1">`Async`</ph> modifier before the lambda parameter list, as the following example shows.</source>
          <target state="translated">Per aggiungere il gestore, aggiungere un modificatore <ph id="ph1">`Async`</ph> prima dell'elenco di parametri lambda, come illustrato di seguito.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For more information about how to create and use async methods, see <bpt id="p1">[</bpt>Asynchronous Programming with Async and Await<ept id="p1">](../../../../visual-basic/programming-guide/concepts/async/index.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni su come creare e utilizzare i metodi asincroni, vedere <bpt id="p1">[</bpt>la programmazione asincrona con Async e Await<ept id="p1">](../../../../visual-basic/programming-guide/concepts/async/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="context"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Context</source>
          <target state="translated"><bpt id="p1">&lt;a name="context"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>Contesto</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>A lambda expression shares its context with the scope within which it is defined.</source>
          <target state="translated">Un'espressione lambda condivide il contesto con l'ambito entro il quale è definito.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It has the same access rights as any code written in the containing scope.</source>
          <target state="translated">Include gli stessi diritti di accesso di qualsiasi codice scritto nell'ambito che lo contiene.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This includes access to member variables, functions and subs, <ph id="ph1">`Me`</ph>, and parameters and local variables in the containing scope.</source>
          <target state="translated">Ciò include l'accesso a variabili membro, funzioni e subroutine, <ph id="ph1">`Me`</ph>e i parametri e variabili locali all'interno dell'ambito contenitore.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Access to local variables and parameters in the containing scope can extend beyond the lifetime of that scope.</source>
          <target state="translated">Accesso alle variabili locali e i parametri nell'ambito che lo contiene può estendersi oltre la durata di tale ambito.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>As long as a delegate referring to a lambda expression is not available to garbage collection, access to the variables in the original environment is retained.</source>
          <target state="translated">Come un delegato che fa riferimento a un'espressione lambda non è disponibile a garbage collection, l'accesso alle variabili nell'ambiente originale viene mantenuto.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>In the following example, variable <ph id="ph1">`target`</ph> is local to <ph id="ph2">`makeTheGame`</ph>, the method in which the lambda expression <ph id="ph3">`playTheGame`</ph> is defined.</source>
          <target state="translated">Nell'esempio seguente, variabile <ph id="ph1">`target`</ph> locale <ph id="ph2">`makeTheGame`</ph>, il metodo in cui l'espressione lambda <ph id="ph3">`playTheGame`</ph> è definito.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Note that the returned lambda expression, assigned to <ph id="ph1">`takeAGuess`</ph> in <ph id="ph2">`Main`</ph>, still has access to the local variable <ph id="ph3">`target`</ph>.</source>
          <target state="translated">Si noti che l'espressione lambda restituita, assegnata a <ph id="ph1">`takeAGuess`</ph> in <ph id="ph2">`Main`</ph>, può ancora accedere alla variabile locale <ph id="ph3">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#12<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_5.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#12;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_5.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the wide range of access rights of the nested lambda expression.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'ampia gamma di diritti di accesso dell'espressione lambda annidata.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When the returned lambda expression is executed from <ph id="ph1">`Main`</ph> as <ph id="ph2">`aDel`</ph>, it accesses these elements:</source>
          <target state="translated">Quando viene eseguita l'espressione lambda restituita da <ph id="ph1">`Main`</ph> come <ph id="ph2">`aDel`</ph>, accede a questi elementi:</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>A field of the class in which it is defined: <ph id="ph1">`aField`</ph></source>
          <target state="translated">Un campo della classe in cui è definito:<ph id="ph1">`aField`</ph></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>A property of the class in which it is defined: <ph id="ph1">`aProp`</ph></source>
          <target state="translated">Una proprietà della classe in cui è definito:<ph id="ph1">`aProp`</ph></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A parameter of method <ph id="ph1">`functionWithNestedLambda`</ph>, in which it is defined: <ph id="ph2">`level1`</ph></source>
          <target state="translated">Un parametro di metodo <ph id="ph1">`functionWithNestedLambda`</ph>, in cui è definito:<ph id="ph2">`level1`</ph></target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A local variable of <ph id="ph1">`functionWithNestedLambda`</ph>: <ph id="ph2">`localVar`</ph></source>
          <target state="translated">Una variabile locale di <ph id="ph1">`functionWithNestedLambda`</ph>:<ph id="ph2">`localVar`</ph></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A parameter of the lambda expression in which it is nested: <ph id="ph1">`level2`</ph></source>
          <target state="translated">Un parametro dell'espressione lambda in cui è annidato:<ph id="ph1">`level2`</ph></target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#9<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_6.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>9 VbVbalrLambdas<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_6.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Converting to a Delegate Type</source>
          <target state="translated">La conversione in un tipo delegato</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>A lambda expression can be implicitly converted to a compatible delegate type.</source>
          <target state="translated">Un'espressione lambda può essere convertita in modo implicito in un tipo delegato compatibile.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For information about the general requirements for compatibility, see <bpt id="p1">[</bpt>Relaxed Delegate Conversion<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept>.</source>
          <target state="translated">Per informazioni sui requisiti generali per la compatibilità, vedere <bpt id="p1">[</bpt>conversione di tipo Relaxed del delegato<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For example, the following code example shows a lambda expression that implicitly converts to <ph id="ph1">`Func(Of Integer, Boolean)`</ph> or a matching delegate signature.</source>
          <target state="translated">Ad esempio, il codice seguente viene illustrata un'espressione lambda che converte in modo implicito in <ph id="ph1">`Func(Of Integer, Boolean)`</ph> o una firma del delegato corrispondente.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#16<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_7.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#16;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_7.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The following code example shows a lambda expression that implicitly converts to <ph id="ph1">`Sub(Of Double, String, Double)`</ph> or a matching delegate signature.</source>
          <target state="translated">Esempio di codice seguente viene illustrata un'espressione lambda che converte in modo implicito in <ph id="ph1">`Sub(Of Double, String, Double)`</ph> o una firma del delegato corrispondente.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#23<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_8.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#23;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_8.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>When you assign lambda expressions to delegates or pass them as arguments to procedures, you can specify the parameter names but omit their data types, letting the types be taken from the delegate.</source>
          <target state="translated">Quando si assegnano espressioni lambda ai delegati o passati come argomenti alle procedure, è possibile specificare i nomi di parametro ma omettere i tipi di dati, consentire i tipi di essere eseguite dal delegato.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Esempi</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The following example defines a lambda expression that returns <ph id="ph1">`True`</ph> if the nullable argument has an assigned value, and <ph id="ph2">`False`</ph> if its value is <ph id="ph3">`Nothing`</ph>.</source>
          <target state="translated">Nell'esempio seguente viene definita un'espressione lambda che restituisce <ph id="ph1">`True`</ph> se l'argomento nullable ha un valore assegnato e <ph id="ph2">`False`</ph> se il valore è <ph id="ph3">`Nothing`</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#4<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_9.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas n.&amp;4;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_9.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following example defines a lambda expression that returns the index of the last element in an array.</source>
          <target state="translated">Nell'esempio seguente viene definita un'espressione lambda che restituisce l'indice dell'ultimo elemento in una matrice.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#5<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_10.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas n.&amp;5;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_10.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vedere anche</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Procedures<ept id="p1">](./index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Procedure<ept id="p1">](./index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Introduction to LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Introduzione a LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Delegates<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Delegati<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Function Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/function-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Istruzione Function<ept id="p1">](../../../../visual-basic/language-reference/statements/function-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Sub Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/sub-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Sub (istruzione)<ept id="p1">](../../../../visual-basic/language-reference/statements/sub-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Nullable Value Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/nullable-value-types.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Tipi di valore nullable<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/nullable-value-types.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Pass Procedures to Another Procedure in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/how-to-pass-procedures-to-another-procedure.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Procedura: passare una routine a un'altra routine in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/how-to-pass-procedures-to-another-procedure.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Create a Lambda Expression<ept id="p1">](./how-to-create-a-lambda-expression.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Procedura: creare un'espressione Lambda<ept id="p1">](./how-to-create-a-lambda-expression.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Relaxed Delegate Conversion<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Conversione di tipo relaxed del delegato<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>