<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d684ad4f3dd47dc7400ea401a94660af832ef866</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\objects-and-classes\object-initializers-named-and-anonymous-types.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8f07e3062df4ad6b96805e338032222151546daa</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f05c0b363d5b2cc2c3125c0f98d68a8de274a04a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Object Initializers: Named and Anonymous Types (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Inizializzatori di oggetto: Tipi di denominati e anonimi (Visual Basic) | Documenti di Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Object Initializers: Named and Anonymous Types (Visual Basic)</source>
          <target state="translated">Inizializzatori di oggetto: tipi denominati e tipi anonimi (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Object initializers enable you to specify properties for a complex object by using a single expression.</source>
          <target state="translated">Gli inizializzatori di oggetto consentono di specificare le proprietà di un oggetto complesso utilizzando una singola espressione.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>They can be used to create instances of named types and of anonymous types.</source>
          <target state="translated">Possono essere utilizzati per creare istanze di tipi denominati e tipi anonimi.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Dichiarazioni</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Declarations of instances of named and anonymous types can look almost identical, but their effects are not the same.</source>
          <target state="translated">Dichiarazioni di istanze di tipi denominati e anonimi possono apparire quasi identiche, ma i relativi effetti non sono uguali.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Each category has abilities and restrictions of its own.</source>
          <target state="translated">Ogni categoria dispone di funzionalità e restrizioni di propri.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The following example shows a convenient way to declare and initialize an instance of a named class, <ph id="ph1">`Customer`</ph>, by using an object initializer list.</source>
          <target state="translated">Nell'esempio seguente viene illustrato un modo pratico per dichiarare e inizializzare un'istanza di una classe denominata <ph id="ph1">`Customer`</ph>, utilizzando un elenco di inizializzatori di oggetto.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Notice that the name of the class is specified after the keyword <ph id="ph1">`New`</ph>.</source>
          <target state="translated">Si noti che dopo la parola chiave viene specificato il nome della classe <ph id="ph1">`New`</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#1<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit n.&amp;1;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>An anonymous type has no usable name.</source>
          <target state="translated">Un tipo anonimo dispone di un nome utilizzabile.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Therefore an instantiation of an anonymous type cannot include a class name.</source>
          <target state="translated">Creazione di un'istanza di un tipo anonimo non può pertanto includere un nome di classe.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#2<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit n.&amp;2;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The requirements and results of the two declarations are not the same.</source>
          <target state="translated">I requisiti e risultati delle due dichiarazioni non sono uguali.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For <ph id="ph1">`namedCust`</ph>, a <ph id="ph2">`Customer`</ph> class that has a <ph id="ph3">`Name`</ph> property must already exist, and the declaration creates an instance of that class.</source>
          <target state="translated">Per <ph id="ph1">`namedCust`</ph>, <ph id="ph2">`Customer`</ph> classe che dispone di un <ph id="ph3">`Name`</ph> proprietà deve essere già esistente e la dichiarazione crea un'istanza di tale classe.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For <ph id="ph1">`anonymousCust`</ph>, the compiler defines a new class that has one property, a string called <ph id="ph2">`Name`</ph>, and creates a new instance of that class.</source>
          <target state="translated">Per <ph id="ph1">`anonymousCust`</ph>, il compilatore definisce una nuova classe che contiene una proprietà, una stringa denominata <ph id="ph2">`Name`</ph>e crea una nuova istanza della classe.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Named Types</source>
          <target state="translated">Tipi denominati</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Object initializers provide a simple way to call the constructor of a type and then set the values of some or all properties in a single statement.</source>
          <target state="translated">Gli inizializzatori di oggetto forniscono un modo semplice per chiamare il costruttore di un tipo e quindi impostare i valori di alcune o tutte le proprietà in un'unica istruzione.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The compiler invokes the appropriate constructor for the statement: the default constructor if no arguments are presented, or a parameterized constructor if one or more arguments are sent.</source>
          <target state="translated">Il compilatore richiama il costruttore appropriato per l'istruzione: il costruttore predefinito, se viene presentato alcun argomento o un costruttore con parametri se vengono inviati uno o più argomenti.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>After that, the specified properties are initialized in the order in which they are presented in the initializer list.</source>
          <target state="translated">Successivamente, le proprietà specificate vengono inizializzate nell'ordine in cui vengono presentati nell'elenco di inizializzatori.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Each initialization in the initializer list consists of the assignment of an initial value to a member of the class.</source>
          <target state="translated">Ogni inizializzazione nell'elenco di inizializzatori è costituita dall'assegnazione di un valore iniziale a un membro della classe.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The names and data types of the members are determined when the class is defined.</source>
          <target state="translated">I nomi e tipi di dati dei membri vengono determinati quando la classe è definita.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In the following examples, the <ph id="ph1">`Customer`</ph> class must exist, and must have members named <ph id="ph2">`Name`</ph> and <ph id="ph3">`City`</ph> that can accept string values.</source>
          <target state="translated">Negli esempi seguenti, il <ph id="ph1">`Customer`</ph> classe deve esistere e devono avere membri denominati <ph id="ph2">`Name`</ph> e <ph id="ph3">`City`</ph> che possono accettare valori stringa.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#3<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit n.&amp;3;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Alternatively, you can obtain the same result by using the following code:</source>
          <target state="translated">In alternativa, è possibile ottenere lo stesso risultato utilizzando il codice seguente:</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#4<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit n.&amp;4;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Each of these declarations is equivalent to the following example, which creates a <ph id="ph1">`Customer`</ph> object by using the default constructor, and then specifies initial values for the <ph id="ph2">`Name`</ph> and <ph id="ph3">`City`</ph> properties by using a <ph id="ph4">`With`</ph> statement.</source>
          <target state="translated">Ognuna di queste dichiarazioni è equivalente all'esempio seguente, che consente di creare un <ph id="ph1">`Customer`</ph> oggetto utilizzando il costruttore predefinito e specifica i valori iniziali per il <ph id="ph2">`Name`</ph> e <ph id="ph3">`City`</ph> proprietà utilizzando un <ph id="ph4">`With`</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#5<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_5.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit n.&amp;5;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_5.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Customer`</ph> class contains a parameterized constructor that enables you to send in a value for <ph id="ph2">`Name`</ph>, for example, you can also declare and initialize a <ph id="ph3">`Customer`</ph> object in the following ways:</source>
          <target state="translated">Se il <ph id="ph1">`Customer`</ph> classe contiene un costruttore con parametri che consente di inviare un valore per <ph id="ph2">`Name`</ph>, ad esempio, è possibile inoltre dichiarare e inizializzare un <ph id="ph3">`Customer`</ph> oggetto nei modi seguenti:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#6<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_6.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>6 VbVbalrObjectInit<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_6.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>You do not have to initialize all properties, as the following code shows.</source>
          <target state="translated">Non è necessario inizializzare tutte le proprietà, come illustrato nel codice seguente.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#7<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_7.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit&amp;#7;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_7.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>However, the initialization list cannot be empty.</source>
          <target state="translated">Tuttavia, l'elenco di inizializzazione non può essere vuoto.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Uninitialized properties retain their default values.</source>
          <target state="translated">Le proprietà non inizializzate mantengono i valori predefiniti.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Type Inference with Named Types</source>
          <target state="translated">Inferenza del tipo con tipi denominati</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can shorten the code for the declaration of <ph id="ph1">`cust1`</ph> by combining object initializers and local type inference.</source>
          <target state="translated">È possibile ridurre il codice per la dichiarazione di <ph id="ph1">`cust1`</ph> combinando gli inizializzatori di oggetto e l'inferenza del tipo locale.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This enables you to omit the <ph id="ph1">`As`</ph> clause in the variable declaration.</source>
          <target state="translated">In questo modo è possibile omettere il <ph id="ph1">`As`</ph> clausola nella dichiarazione di variabile.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The data type of the variable is inferred from the type of the object that is created by the assignment.</source>
          <target state="translated">Il tipo di dati della variabile viene dedotto dal tipo dell'oggetto creato mediante l'assegnazione.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In the following example, the type of <ph id="ph1">`cust6`</ph> is <ph id="ph2">`Customer`</ph>.</source>
          <target state="translated">Nell'esempio seguente, il tipo di <ph id="ph1">`cust6`</ph> è <ph id="ph2">`Customer`</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#8<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_8.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit n.&amp;8;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_8.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Remarks About Named Types</source>
          <target state="translated">Note sui tipi denominati</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>A class member cannot be initialized more than one time in the object initializer list.</source>
          <target state="translated">Impossibile inizializzare un membro della classe più volte nell'elenco di inizializzatori di oggetto.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The declaration of <ph id="ph1">`cust7`</ph> causes an error.</source>
          <target state="translated">La dichiarazione di <ph id="ph1">`cust7`</ph> provoca un errore.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#9<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_9.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>9 VbVbalrObjectInit<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_9.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A member can be used to initialize itself or another field.</source>
          <target state="translated">Un membro può essere utilizzato per inizializzare se stesso o un altro campo.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>If a member is accessed before it has been initialized, as in the following declaration for <ph id="ph1">`cust8`</ph>, the default value will be used.</source>
          <target state="translated">Se si accede a un membro prima che sia stato inizializzato, come illustrato nella seguente dichiarazione per <ph id="ph1">`cust8`</ph>, verrà utilizzato il valore predefinito.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Remember that when a declaration that uses an object initializer is processed, the first thing that happens is that the appropriate constructor is invoked.</source>
          <target state="translated">Tenere presente che quando viene elaborata una dichiarazione che utilizza un inizializzatore di oggetto, la prima cosa che accade se viene richiamato il costruttore appropriato.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>After that, the individual fields in the initializer list are initialized.</source>
          <target state="translated">Successivamente, vengono inizializzati i singoli campi nell'elenco di inizializzatori.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>In the following examples, the default value for <ph id="ph1">`Name`</ph> is assigned for <ph id="ph2">`cust8`</ph>, and an initialized value is assigned in <ph id="ph3">`cust9`</ph>.</source>
          <target state="translated">Negli esempi seguenti, il valore predefinito per <ph id="ph1">`Name`</ph> viene assegnato per <ph id="ph2">`cust8`</ph>, e viene assegnato un valore inizializzato <ph id="ph3">`cust9`</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#10<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_10.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit&amp;#10;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_10.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The following example uses the parameterized constructor from <ph id="ph1">`cust3`</ph> and <ph id="ph2">`cust4`</ph> to declare and initialize <ph id="ph3">`cust10`</ph> and <ph id="ph4">`cust11`</ph>.</source>
          <target state="translated">Nell'esempio seguente viene utilizzato il costruttore con parametri da <ph id="ph1">`cust3`</ph> e <ph id="ph2">`cust4`</ph> per dichiarare e inizializzare <ph id="ph3">`cust10`</ph> e <ph id="ph4">`cust11`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#11<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_11.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit&amp;#11;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_11.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Object initializers can be nested.</source>
          <target state="translated">Gli inizializzatori di oggetto possono essere annidati.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`AddressClass`</ph> is a class that has two properties, <ph id="ph2">`City`</ph> and <ph id="ph3">`State`</ph>, and the <ph id="ph4">`Customer`</ph> class has an <ph id="ph5">`Address`</ph> property that is an instance of <ph id="ph6">`AddressClass`</ph>.</source>
          <target state="translated">Nell'esempio seguente, <ph id="ph1">`AddressClass`</ph> è una classe che dispone di due proprietà, <ph id="ph2">`City`</ph> e <ph id="ph3">`State`</ph>e <ph id="ph4">`Customer`</ph> classe dispone di un <ph id="ph5">`Address`</ph> proprietà che è un'istanza di <ph id="ph6">`AddressClass`</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#12<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_12.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit&amp;#12;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_12.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The initialization list cannot be empty.</source>
          <target state="translated">L'elenco di inizializzazione non può essere vuoto.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The instance being initialized cannot be of type Object.</source>
          <target state="translated">L'istanza da inizializzare non può essere di tipo Object.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Class members being initialized cannot be shared members, read-only members, constants, or method calls.</source>
          <target state="translated">I membri di classe in fase di inizializzazione non possono essere membri condivisi, i membri di sola lettura, costanti o chiamate al metodo.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Class members being initialized cannot be indexed or qualified.</source>
          <target state="translated">Membri della classe in fase di inizializzazione non possono essere indicizzati o completo.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The following examples raise compiler errors:</source>
          <target state="translated">Negli esempi seguenti vengono generati errori del compilatore:</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Anonymous Types</source>
          <target state="translated">Tipi anonimi</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Anonymous types use object initializers to create instances of new types that you do not explicitly define and name.</source>
          <target state="translated">Tipi anonimi utilizzano gli inizializzatori di oggetto per creare istanze di nuovi tipi che non si definisce in modo esplicito e il nome.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Instead, the compiler generates a type according to the properties you designate in the object initializer list.</source>
          <target state="translated">Al contrario, il compilatore genera un tipo in base alle proprietà designate nell'elenco di inizializzatori di oggetto.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Because the name of the type is not specified, it is referred to as an <bpt id="p1">*</bpt>anonymous type<ept id="p1">*</ept>.</source>
          <target state="translated">Poiché il nome del tipo viene omesso, viene considerato un <bpt id="p1">*</bpt>tipo anonimo<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For example, compare the following declaration to the earlier one for <ph id="ph1">`cust6`</ph>.</source>
          <target state="translated">Ad esempio, confrontare la dichiarazione seguente con quella precedente per <ph id="ph1">`cust6`</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#13<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_13.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>13 VbVbalrObjectInit<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_13.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The only difference syntactically is that no name is specified after <ph id="ph1">`New`</ph> for the data type.</source>
          <target state="translated">L'unica differenza è sintatticamente che viene specificato alcun nome dopo <ph id="ph1">`New`</ph> per il tipo di dati.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>However, what happens is quite different.</source>
          <target state="translated">Tuttavia, ciò che accade è piuttosto diversa.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The compiler defines a new anonymous type that has two properties, <ph id="ph1">`Name`</ph> and <ph id="ph2">`City`</ph>, and creates an instance of it with the specified values.</source>
          <target state="translated">Il compilatore definisce un nuovo tipo anonimo che ha due proprietà, <ph id="ph1">`Name`</ph> e <ph id="ph2">`City`</ph>e crea un'istanza con i valori specificati.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Type inference determines the types of <ph id="ph1">`Name`</ph> and <ph id="ph2">`City`</ph> in the example to be strings.</source>
          <target state="translated">L'inferenza del tipo determina i tipi di <ph id="ph1">`Name`</ph> e <ph id="ph2">`City`</ph> nell'esempio sono stringhe.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The name of the anonymous type is generated by the compiler, and may vary from compilation to compilation.</source>
          <target state="translated">Il nome del tipo anonimo viene generato dal compilatore e può variare da una compilazione di un'.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Your code should not use or rely on the name of an anonymous type.</source>
          <target state="translated">Il codice non deve utilizzare o basarsi sul nome di un tipo anonimo.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Because the name of the type is not available, you cannot use an <ph id="ph1">`As`</ph> clause to declare <ph id="ph2">`cust13`</ph>.</source>
          <target state="translated">Poiché il nome del tipo non è disponibile, è possibile utilizzare un <ph id="ph1">`As`</ph> clausola per dichiarare <ph id="ph2">`cust13`</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Its type must be inferred.</source>
          <target state="translated">Il tipo deve essere dedotto.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Without using late binding, this limits the use of anonymous types to local variables.</source>
          <target state="translated">Senza utilizzare l'associazione tardiva, limita l'utilizzo di tipi anonimi alle variabili locali.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Anonymous types provide critical support for <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> queries.</source>
          <target state="translated">Tipi anonimi forniscono supporto critico per <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> query.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For more information about the use of anonymous types in queries, see <bpt id="p1">[</bpt>Anonymous Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept> and <bpt id="p2">[</bpt>Introduction to LINQ in Visual Basic<ept id="p2">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sull'utilizzo di tipi anonimi nelle query, vedere <bpt id="p1">[</bpt>tipi anonimi<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept> e <bpt id="p2">[</bpt>Introduzione a LINQ in Visual Basic<ept id="p2">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Remarks About Anonymous Types</source>
          <target state="translated">Note sui tipi anonimi</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Typically, all or most of the properties in an anonymous type declaration will be key properties, which are indicated by typing the keyword <ph id="ph1">`Key`</ph> in front of the property name.</source>
          <target state="translated">In genere, tutte o la maggior parte delle proprietà nella dichiarazione di un tipo anonimo saranno i proprietà chiave, indicate digitando la parola chiave <ph id="ph1">`Key`</ph> davanti al nome di proprietà.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#14<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_14.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit&amp;#14;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_14.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For more information about key properties, see <bpt id="p1">[</bpt>Key<ept id="p1">](../../../../visual-basic/language-reference/modifiers/key.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulle proprietà chiave, vedere <bpt id="p1">[</bpt>chiave<ept id="p1">](../../../../visual-basic/language-reference/modifiers/key.md)</ept>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Like named types, initializer lists for anonymous type definitions must declare at least one property.</source>
          <target state="translated">Come i tipi denominati, gli elenchi di inizializzatori per definizioni di tipo anonimo devono dichiarare almeno una proprietà.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#2<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit n.&amp;2;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>When an instance of an anonymous type is declared, the compiler generates a matching anonymous type definition.</source>
          <target state="translated">Quando viene dichiarata un'istanza di un tipo anonimo, il compilatore genera una corrispondente definizione di tipo anonimo.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The names and data types of the properties are taken from the instance declaration, and are included by the compiler in the definition.</source>
          <target state="translated">I nomi e tipi di dati delle proprietà provengono dalla dichiarazione dell'istanza e sono inclusi dal compilatore nella definizione.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The properties are not named and defined in advance, as they would be for a named type.</source>
          <target state="translated">Le proprietà non sono denominate e definite in anticipo, come avviene per un tipo denominato.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Their types are inferred.</source>
          <target state="translated">I tipi inferiti.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>You cannot specify the data types of the properties by using an <ph id="ph1">`As`</ph> clause.</source>
          <target state="translated">Non è possibile specificare i tipi di dati delle proprietà utilizzando un <ph id="ph1">`As`</ph> clausola.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Anonymous types can also establish the names and values of their properties in several other ways.</source>
          <target state="translated">Tipi anonimi possono anche definire i nomi e valori delle relative proprietà in diversi altri modi.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For example, an anonymous type property can take both the name and the value of a variable, or the name and value of a property of another object.</source>
          <target state="translated">Ad esempio, una proprietà di tipo anonimo può richiedere il nome e il valore di una variabile o il nome e il valore di una proprietà di un altro oggetto.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit#15<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_15.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrObjectInit&amp;#15;<ept id="p2">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/codesnippet/VisualBasic/object-initializers-named-and-anonymous-types_15.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>For more information about the options for defining properties in anonymous types, see <bpt id="p1">[</bpt>How to: Infer Property Names and Types in Anonymous Type Declarations<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-infer-property-names-and-types-in-anonymous-type-declarations.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulle opzioni per la definizione delle proprietà nei tipi anonimi, vedere <bpt id="p1">[</bpt>procedura: dedurre i nomi delle proprietà e i tipi nelle dichiarazioni di tipo anonimo<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-infer-property-names-and-types-in-anonymous-type-declarations.md)</ept>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vedere anche</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Local Type Inference<ept id="p1">](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Inferenza del tipo locale<ept id="p1">](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Anonymous Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Tipi anonimi<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Introduction to LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Introduzione a LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Infer Property Names and Types in Anonymous Type Declarations<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-infer-property-names-and-types-in-anonymous-type-declarations.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Procedura: dedurre tipi e nomi di proprietà nelle dichiarazioni di tipo anonimo<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-infer-property-names-and-types-in-anonymous-type-declarations.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Key<ept id="p1">](../../../../visual-basic/language-reference/modifiers/key.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Chiave<ept id="p1">](../../../../visual-basic/language-reference/modifiers/key.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Declare an Object by Using an Object Initializer<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-declare-an-object-by-using-an-object-initializer.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Procedura: Dichiarare un oggetto usando un inizializzatore di oggetto<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-declare-an-object-by-using-an-object-initializer.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>