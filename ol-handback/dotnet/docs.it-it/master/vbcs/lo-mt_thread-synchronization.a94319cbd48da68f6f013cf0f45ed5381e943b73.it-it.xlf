<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ec8fa89c8921eadee428a90971d9ae4ce305a109</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\threading\thread-synchronization.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">507fd3da6f780fafc0c90fc0aad1da71b8d75111</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c9f1ce06f6aa83729f732b6a23672aef4a568997</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Thread Synchronization (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Thread di sincronizzazione (Visual Basic) | Documenti di Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Thread Synchronization (Visual Basic)</source>
          <target state="translated">Sincronizzazione dei thread (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.</source>
          <target state="translated">Le sezioni seguenti descrivono le funzionalità e le classi che possono essere utilizzate per sincronizzare l'accesso alle risorse in applicazioni multithreading.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>One of the benefits of using multiple threads in an application is that each thread executes asynchronously.</source>
          <target state="translated">Uno dei vantaggi dell'utilizzo di più thread in un'applicazione consiste nel fatto che ogni thread esegue in modo asincrono.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.</source>
          <target state="translated">Per le applicazioni di Windows, in questo modo l'attività richiede molto tempo essere eseguita in background mentre la finestra dell'applicazione e controlli rimangano attiva.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For server applications, multithreading provides the ability to handle each incoming request with a different thread.</source>
          <target state="translated">Per server applicazioni, multithreading offre la possibilità di gestire ogni richiesta in ingresso con un altro thread.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Otherwise, each new request would not get serviced until the previous request had been fully satisfied.</source>
          <target state="translated">In caso contrario, ogni nuova richiesta verrebbe soddisfatta fino a quando la richiesta precedente fosse stata siano soddisfatta.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.</source>
          <target state="translated">Tuttavia, data la natura asincrona dei thread implica che l'accesso alle risorse, ad esempio memoria, handle di file e le connessioni di rete deve essere coordinata.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.</source>
          <target state="translated">In caso contrario, due o più thread potrebbero accedere alla stessa risorsa nello stesso momento, ogni riconosce le azioni di altro.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The result is unpredictable data corruption.</source>
          <target state="translated">Il risultato è il danneggiamento dei dati imprevisti.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the &lt;xref:System.Threading.Interlocked&gt; class.</source>
          <target state="translated">Per operazioni semplici sui tipi di dati numerici integrali, la sincronizzazione dei thread può essere eseguita con i membri di &lt;xref:System.Threading.Interlocked&gt;classe.&lt;/xref:System.Threading.Interlocked&gt;</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.</source>
          <target state="translated">Per tutti gli altri dati tipi e le risorse non thread-safe, multithreading possono essere tranquillamente eseguite solo utilizzando i costrutti in questo argomento.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For background information on multithreaded programming, see:</source>
          <target state="translated">Per informazioni generali sulla programmazione multithreading, vedere:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Managed Threading Basics<ept id="p1">](http://msdn.microsoft.com/library/b2944911-0e8f-427d-a8bb-077550618935)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Nozioni di base di Threading gestito<ept id="p1">](http://msdn.microsoft.com/library/b2944911-0e8f-427d-a8bb-077550618935)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using Threads and Threading<ept id="p1">](http://msdn.microsoft.com/library/9b5ec2cd-121b-4d49-b075-222cf26f2344)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Utilizzo di thread e Threading<ept id="p1">](http://msdn.microsoft.com/library/9b5ec2cd-121b-4d49-b075-222cf26f2344)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Managed Threading Best Practices<ept id="p1">](http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Procedure consigliate di Threading gestito<ept id="p1">](http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The lock and SyncLock Keywords</source>
          <target state="translated">Il blocco e parole chiave SyncLock</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The Visual Basic <ph id="ph1">`SyncLock`</ph> statement can be used to ensure that a block of code runs to completion without interruption by other threads.</source>
          <target state="translated">Visual Basic <ph id="ph1">`SyncLock`</ph> istruzione può essere utilizzata per garantire che un blocco di codice viene eseguito fino al completamento senza interruzioni da altri thread.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.</source>
          <target state="translated">Questa operazione viene eseguita ottenendo un blocco a esclusione reciproca per un determinato oggetto per la durata del blocco di codice.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`SyncLock`</ph> statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.</source>
          <target state="translated">Oggetto <ph id="ph1">`SyncLock`</ph> istruzione viene assegnata un oggetto come argomento, seguita da un blocco di codice che deve essere eseguito da un solo thread alla volta.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The argument provided to the <ph id="ph1">`SyncLock`</ph> keyword must be an object based on a reference type, and is used to define the scope of the lock.</source>
          <target state="translated">L'argomento fornito per il <ph id="ph1">`SyncLock`</ph> (parola chiave) deve essere un oggetto basato su un tipo di riferimento e viene utilizzato per definire l'ambito del blocco.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In the example above, the lock scope is limited to this function because no references to the object <ph id="ph1">`lockThis`</ph> exist outside the function.</source>
          <target state="translated">Nell'esempio precedente, l'ambito del blocco è limitato a questa funzione perché nessun riferimento all'oggetto <ph id="ph1">`lockThis`</ph> esiste all'esterno della funzione.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If such a reference did exist, lock scope would extend to that object.</source>
          <target state="translated">Se esiste un riferimento, ambito del blocco si estende anche a tale oggetto.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.</source>
          <target state="translated">In teoria, l'oggetto fornito viene utilizzato esclusivamente per identificare la risorsa condivisa tra più thread, pertanto può essere un'istanza di classe arbitraria.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In practice, however, this object usually represents the resource for which thread synchronization is necessary.</source>
          <target state="translated">In pratica, tuttavia, questo oggetto rappresenta in genere la risorsa per il thread su cui sia necessaria la sincronizzazione.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.</source>
          <target state="translated">Ad esempio, se un oggetto contenitore deve essere utilizzato da più thread, quindi il contenitore può essere passato per bloccare e il blocco di codice sincronizzato segue il blocco acceda al contenitore.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.</source>
          <target state="translated">Come altri thread vengano bloccati sullo stesso contengono prima dell'accesso, in modo sicuro l'accesso all'oggetto è sincronizzato.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Generally, it is best to avoid locking on a <ph id="ph1">`public`</ph> type, or on object instances beyond the control of your application.</source>
          <target state="translated">In genere, è consigliabile evitare il blocco di un <ph id="ph1">`public`</ph> tipo, o istanze di oggetti sotto il controllo dell'applicazione.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`lockThis`</ph> can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.</source>
          <target state="translated">Ad esempio, <ph id="ph1">`lockThis`</ph> può risultare problematico se l'istanza è possibile accedere pubblicamente, perché il codice fuori controllo potrebbe causare il blocco anche l'oggetto.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This could create deadlock situations where two or more threads wait for the release of the same object.</source>
          <target state="translated">Questo può creare situazioni di deadlock in cui due o più thread sono in attesa per la versione dello stesso oggetto.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Locking on a public data type, as opposed to an object, can cause problems for the same reason.</source>
          <target state="translated">Il blocco di un tipo di dati pubblici, anziché su un oggetto, può causare problemi per lo stesso motivo.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Locking on literal strings is especially risky because literal strings are <bpt id="p1">*</bpt>interned<ept id="p1">*</ept> by the common language runtime (CLR).</source>
          <target state="translated">Il blocco di stringhe letterali è particolarmente rischioso poiché le stringhe letterali sono <bpt id="p1">*</bpt>inserite<ept id="p1">*</ept> da common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.</source>
          <target state="translated">Questo significa che è presente un'istanza di una stringa letterale per l'intero programma, lo stesso oggetto rappresenta il valore letterale in tutti domini applicazione, in esecuzione su tutti i thread.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.</source>
          <target state="translated">Di conseguenza, un blocco collocato su una stringa con lo stesso contenuto in qualsiasi posizione il processo dell'applicazione blocca tutte le istanze di tale stringa nell'applicazione.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>As a result, it is best to lock a private or protected member that is not interned.</source>
          <target state="translated">Di conseguenza, si consiglia di bloccare un membro privato o protetto che non è inserito.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Some classes provide members specifically for locking.</source>
          <target state="translated">Alcune classi sono disponibili membri specifici per il blocco.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Array&gt; type, for example, provides &lt;xref:System.Array.SyncRoot%2A&gt;.</source>
          <target state="translated">Il &lt;xref:System.Array&gt;tipo, ad esempio, fornisce &lt;xref:System.Array.SyncRoot%2A&gt;.&lt;/xref:System.Array.SyncRoot%2A&gt; &lt;/xref:System.Array&gt;</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Many collection types provide a <ph id="ph1">`SyncRoot`</ph> member as well.</source>
          <target state="translated">Molti tipi di raccolta forniscono un <ph id="ph1">`SyncRoot`</ph> nonché membro.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For more information about the <ph id="ph1">`SyncLock`</ph> statement, see the following topics:</source>
          <target state="translated">Per ulteriori informazioni sui <ph id="ph1">`SyncLock`</ph> istruzione, vedere gli argomenti seguenti:</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SyncLock Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/synclock-statement.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Istruzione SyncLock<ept id="p1">](../../../../visual-basic/language-reference/statements/synclock-statement.md)</ept></target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Monitors</source>
          <target state="translated">Monitoraggi</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Like the <ph id="ph1">`SyncLock`</ph> keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.</source>
          <target state="translated">Ad esempio il <ph id="ph1">`SyncLock`</ph> (parola chiave), monitoraggi evitare blocchi di codice dall'esecuzione simultanea di più thread.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Threading.Monitor.Enter%2A&gt; method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls &lt;xref:System.Threading.Monitor.Exit%2A&gt;.</source>
          <target state="translated">Il &lt;xref:System.Threading.Monitor.Enter%2A&gt;metodo consente un solo thread procedere nelle istruzioni seguenti, tutti gli altri thread sono bloccati fino a quando l'esecuzione del thread chiama &lt;xref:System.Threading.Monitor.Exit%2A&gt;.&lt;/xref:System.Threading.Monitor.Exit%2A&gt; &lt;/xref:System.Threading.Monitor.Enter%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This is just like using the <ph id="ph1">`SyncLock`</ph> keyword.</source>
          <target state="translated">Si tratta come quando si utilizza il <ph id="ph1">`SyncLock`</ph> (parola chiave).</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">Ciò equivale a:</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Using the <ph id="ph1">`SyncLock`</ph> keyword is generally preferred over using the &lt;xref:System.Threading.Monitor&gt; class directly, both because <ph id="ph2">`SyncLock`</ph> is more concise, and because <ph id="ph3">`SyncLock`</ph> insures that the underlying monitor is released, even if the protected code throws an exception.</source>
          <target state="translated">Utilizzando il <ph id="ph1">`SyncLock`</ph> (parola chiave) viene in genere preferibile all'utilizzo di &lt;xref:System.Threading.Monitor&gt;direttamente alla classe, sia perché <ph id="ph2">`SyncLock`</ph> è più conciso e poiché <ph id="ph3">`SyncLock`</ph> assicura il rilascio del monitor sottostante, anche se il codice protetto genera un'eccezione.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This is accomplished with the <ph id="ph1">`Finally`</ph> keyword, which executes its associated code block regardless of whether an exception is thrown.</source>
          <target state="translated">Questa operazione viene eseguita con il <ph id="ph1">`Finally`</ph> (parola chiave), che esegue il blocco di codice associato indipendentemente dal fatto che viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Synchronization Events and Wait Handles</source>
          <target state="translated">Eventi di sincronizzazione e gli handle di attesa</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.</source>
          <target state="translated">Utilizzo di un blocco o il monitoraggio è utile per impedire l'esecuzione simultanea di blocchi di codice sensibili thread, ma questi costrutti non consentono un solo thread comunicare un evento a un altro.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This requires <bpt id="p1">*</bpt>synchronization events<ept id="p1">*</ept>, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.</source>
          <target state="translated">Questa operazione richiede <bpt id="p1">*</bpt>gli eventi di sincronizzazione<ept id="p1">*</ept>, che sono oggetti che presentano uno dei due stati, segnalato e non segnalato, che può essere utilizzato per attivare e sospendere i thread.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.</source>
          <target state="translated">Thread può essere sospesa dal stabilite per attendere un evento di sincronizzazione che viene segnalato e può essere attivato modificando lo stato dell'evento su segnalato.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.</source>
          <target state="translated">Se si tenta di un thread in attesa di un evento che è già segnalato, il thread continua l'esecuzione senza ritardo.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>There are two kinds of synchronization events: &lt;xref:System.Threading.AutoResetEvent&gt;, and &lt;xref:System.Threading.ManualResetEvent&gt;.</source>
          <target state="translated">Esistono due tipi di eventi di sincronizzazione: &lt;xref:System.Threading.AutoResetEvent&gt;e &lt;xref:System.Threading.ManualResetEvent&gt;.&lt;/xref:System.Threading.ManualResetEvent&gt; &lt;/xref:System.Threading.AutoResetEvent&gt;</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>They differ only in that &lt;xref:System.Threading.AutoResetEvent&gt; changes from signaled to unsignaled automatically any time it activates a thread.</source>
          <target state="translated">L'unica differenza che &lt;xref:System.Threading.AutoResetEvent&gt;le modifiche da segnalato allo stato non segnalato automaticamente ogni volta che si attiva un thread.&lt;/xref:System.Threading.AutoResetEvent&gt;</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Conversely, a &lt;xref:System.Threading.ManualResetEvent&gt; allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its &lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt; method is called.</source>
          <target state="translated">Al contrario, un &lt;xref:System.Threading.ManualResetEvent&gt;consente qualsiasi numero di thread da attivare con lo stato segnalato e torna allo stato non segnalato solo stato quando il relativo &lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;viene chiamato.&lt;/xref:System.Threading.EventWaitHandle.Reset%2A&gt; &lt;/xref:System.Threading.ManualResetEvent&gt;</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Threads can be made to wait on events by calling one of the wait methods, such as &lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;, &lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;, or &lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;.</source>
          <target state="translated">I thread possono essere resi per attendere gli eventi chiamando uno dei metodi di attesa, ad esempio &lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;, &lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;, o &lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;.&lt;/xref:System.Threading.WaitHandle.WaitAll%2A&gt; &lt;/xref:System.Threading.WaitHandle.WaitAny%2A&gt; &lt;/xref:System.Threading.WaitHandle.WaitOne%2A&gt;</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt; causes the thread to wait until a single event becomes signaled, &lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName&gt; blocks a thread until one or more indicated events become signaled, and &lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName&gt; blocks the thread until all of the indicated events become signaled.</source>
          <target state="translated">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;fa sì che il thread in attesa finché non viene segnalato un singolo evento, &lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName&gt;Blocca un thread finché non viene segnalati uno o più eventi indicati, e &lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName&gt;Blocca il thread finché tutti gli eventi indicati non diventano segnalati.&lt;/xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName&gt; &lt;/xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName&gt;&lt;/xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>An event becomes signaled when its &lt;xref:System.Threading.EventWaitHandle.Set%2A&gt; method is called.</source>
          <target state="translated">L'evento diventa segnalato quando il relativo &lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;viene chiamato.&lt;/xref:System.Threading.EventWaitHandle.Set%2A&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>In the following example, a thread is created and started by the <ph id="ph1">`Main`</ph> function.</source>
          <target state="translated">Nell'esempio seguente viene creato e avviato da un thread di <ph id="ph1">`Main`</ph> (funzione).</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The new thread waits on an event using the &lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt; method.</source>
          <target state="translated">Il nuovo thread attende un evento utilizzando il &lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;(metodo).&lt;/xref:System.Threading.WaitHandle.WaitOne%2A&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The thread is suspended until the event becomes signaled by the primary thread that is executing the <ph id="ph1">`Main`</ph> function.</source>
          <target state="translated">Il thread viene sospesa fino a quando l'evento viene segnalato dal thread principale è in esecuzione il <ph id="ph1">`Main`</ph> (funzione).</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Once the event becomes signaled, the auxiliary thread returns.</source>
          <target state="translated">Una volta che viene segnalato l'evento, viene restituito il thread ausiliario.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In this case, because the event is only used for one thread activation, either the &lt;xref:System.Threading.AutoResetEvent&gt; or &lt;xref:System.Threading.ManualResetEvent&gt; classes could be used.</source>
          <target state="translated">In questo caso, poiché l'evento viene utilizzato solo per l'attivazione di un thread, è il &lt;xref:System.Threading.AutoResetEvent&gt;o &lt;xref:System.Threading.ManualResetEvent&gt;classi potrebbero essere utilizzate.&lt;/xref:System.Threading.ManualResetEvent&gt; &lt;/xref:System.Threading.AutoResetEvent&gt;</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Mutex Object</source>
          <target state="translated">Oggetto mutex</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>mutex<ept id="p1">*</ept> is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.</source>
          <target state="translated">Oggetto <bpt id="p1">*</bpt>mutex<ept id="p1">*</ept> è simile a un monitoraggio, impedisce l'esecuzione simultanea di un blocco di codice da più thread contemporaneamente.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In fact, the name "mutex" is a shortened form of the term "mutually exclusive."</source>
          <target state="translated">Infatti, il nome "mutex" è una versione abbreviata del termine "si escludono a vicenda."</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Unlike monitors, however, a mutex can be used to synchronize threads across processes.</source>
          <target state="translated">A differenza dei monitoraggi, tuttavia, un mutex consente di sincronizzare i thread tra processi.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A mutex is represented by the &lt;xref:System.Threading.Mutex&gt; class.</source>
          <target state="translated">Un mutex è rappresentato dalla &lt;xref:System.Threading.Mutex&gt;classe.&lt;/xref:System.Threading.Mutex&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>When used for inter-process synchronization, a mutex is called a <bpt id="p1">*</bpt>named mutex<ept id="p1">*</ept> because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.</source>
          <target state="translated">Quando utilizzato per la sincronizzazione tra processo, il mutex viene definito un <bpt id="p1">*</bpt>mutex denominato<ept id="p1">*</ept> perché deve essere utilizzato in un'altra applicazione e pertanto non può essere condiviso mediante una variabile globale o statica.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>It must be given a name so that both applications can access the same mutex object.</source>
          <target state="translated">Deve essere provvisto di un nome in modo che entrambe le applicazioni possono accedere lo stesso oggetto mutex.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Although a mutex can be used for intra-process thread synchronization, using &lt;xref:System.Threading.Monitor&gt; is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.</source>
          <target state="translated">Sebbene un mutex può essere utilizzato per la sincronizzazione dei thread all'interno del processo, utilizzando &lt;xref:System.Threading.Monitor&gt;è in genere preferibile, perché i monitoraggi sono stati progettati specificamente per .NET Framework e pertanto un migliore utilizzo delle risorse.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In contrast, the &lt;xref:System.Threading.Mutex&gt; class is a wrapper to a Win32 construct.</source>
          <target state="translated">Al contrario, la &lt;xref:System.Threading.Mutex&gt;classe è un wrapper per un costrutto Win32.&lt;/xref:System.Threading.Mutex&gt;</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the &lt;xref:System.Threading.Monitor&gt; class.</source>
          <target state="translated">Sebbene sia più potente di un monitor, un mutex richiede transizioni di interoperabilità che sono più dispendiosa rispetto a quelle richieste dalla &lt;xref:System.Threading.Monitor&gt;classe.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For an example of using a mutex, see <bpt id="p1">[</bpt>Mutexes<ept id="p1">](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2)</ept>.</source>
          <target state="translated">Per un esempio di utilizzo di un mutex, vedere <bpt id="p1">[</bpt>mutex<ept id="p1">](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Interlocked Class</source>
          <target state="translated">Interlocked (classe)</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You can use the methods of the &lt;xref:System.Threading.Interlocked&gt; class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.</source>
          <target state="translated">È possibile utilizzare i metodi della &lt;xref:System.Threading.Interlocked&gt;classe per evitare i problemi che possono verificarsi quando più thread tentano contemporaneamente di aggiornare o confrontare lo stesso valore.&lt;/xref:System.Threading.Interlocked&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.</source>
          <target state="translated">I metodi di questa classe consentono in modo sicuro di incremento, decrementano, scambino e confrontano i valori da qualsiasi thread.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>ReaderWriter Locks</source>
          <target state="translated">Blocchi ReaderWriter</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.</source>
          <target state="translated">In alcuni casi, si desidera bloccare una risorsa solo durante la scrittura di dati e consentire a leggere contemporaneamente i dati quando i dati non vengono aggiornati più client.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Threading.ReaderWriterLock&gt; class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.</source>
          <target state="translated">La &lt;xref:System.Threading.ReaderWriterLock&gt;classe impone l'accesso esclusivo a una risorsa mentre un thread sta modificando la risorsa, ma consente l'accesso non esclusivo durante la lettura della risorsa.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.</source>
          <target state="translated">Blocchi ReaderWriter rappresentano un'alternativa utile per i blocchi esclusivi, che altri thread in attesa, anche quando i thread non è necessitano aggiornare i dati.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Deadlocks</source>
          <target state="translated">Deadlock</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a <ph id="ph1">`deadlock`</ph>, where multiple threads are waiting for each other and the application comes to a halt.</source>
          <target state="translated">La sincronizzazione dei thread si rivela particolarmente utile nelle applicazioni multithreading, ma è sempre presente il pericolo di creazione di un <ph id="ph1">`deadlock`</ph>, in cui più thread in attesa di loro e l'applicazione si blocca.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.</source>
          <target state="translated">È analogo a una situazione in cui automobili sono stati interrotti in un'interruzione di quattro direzioni e ogni persona è in attesa per l'altra passare un deadlock.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Avoiding deadlocks is important; the key is careful planning.</source>
          <target state="translated">Evitare i deadlock è importante. la chiave è un'attenta pianificazione.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>You can often predict deadlock situations by diagramming multithreaded applications before you start coding.</source>
          <target state="translated">È spesso possibile prevedere situazioni di deadlock creando diagrammi prima di iniziare la codifica di applicazioni multithread.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vedere anche</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Thread&gt;&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;&lt;/xref:System.Threading.WaitHandle.WaitOne%2A&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;&lt;/xref:System.Threading.WaitHandle.WaitAny%2A&gt;</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;&lt;/xref:System.Threading.WaitHandle.WaitAll%2A&gt;</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.Join%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Join%2A&gt;&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.Start%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Start%2A&gt;&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.Sleep%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Sleep%2A&gt;&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Monitor&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Monitor&gt;&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Mutex&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Mutex&gt;&lt;/xref:System.Threading.Mutex&gt;</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.AutoResetEvent&gt;</source>
          <target state="translated">&lt;xref:System.Threading.AutoResetEvent&gt;&lt;/xref:System.Threading.AutoResetEvent&gt;</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ManualResetEvent&gt;</source>
          <target state="translated">&lt;xref:System.Threading.ManualResetEvent&gt;&lt;/xref:System.Threading.ManualResetEvent&gt;</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Interlocked&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Interlocked&gt;&lt;/xref:System.Threading.Interlocked&gt;</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.WaitHandle&gt;</source>
          <target state="translated">&lt;xref:System.Threading.WaitHandle&gt;&lt;/xref:System.Threading.WaitHandle&gt;</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.EventWaitHandle&gt;</source>
          <target state="translated">&lt;xref:System.Threading.EventWaitHandle&gt;&lt;/xref:System.Threading.EventWaitHandle&gt;</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading&gt;</source>
          <target state="translated">&lt;xref:System.Threading&gt;&lt;/xref:System.Threading&gt;</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;&lt;/xref:System.Threading.EventWaitHandle.Set%2A&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Multithreaded Applications (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Applicazioni multithreading (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>SyncLock Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/synclock-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Istruzione SyncLock<ept id="p1">](../../../../visual-basic/language-reference/statements/synclock-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Mutexes<ept id="p1">](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Mutex<ept id="p1">](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Interlocked Operations<ept id="p1">](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Operazioni interlocked<ept id="p1">](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>AutoResetEvent<ept id="p1">](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>AutoResetEvent<ept id="p1">](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Synchronizing Data for Multithreading<ept id="p1">](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Sincronizzazione dei dati per il Multithreading<ept id="p1">](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>