<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b5c25fc" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">827b5567400fd8ed1f32e60ba593a3ae71a0d745</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tools\extensibility.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">79d72a8f09cdb994a27cb59521b5f4267ab44f11</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">65ce7cce456cec5da2e00d516127f33f84b7630d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model | Microsoft Docs</source>
          <target state="translated">.NET Core CLI の拡張モデル | Microsoft Docs</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">.NET Core CLI の拡張モデル</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>CLI, extensibility, custom commands, .NET Core</source>
          <target state="translated">CLI, 拡張, カスタム コマンド, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">.NET Core CLI の拡張モデル</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">概要</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This document will cover the main ways how to extend the CLI tools and explain the scenarios that drive each of them.</source>
          <target state="translated">このドキュメントは、CLI ツールを拡張する主な方法と、それぞれのツールを動作させるシナリオについて説明します。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It will the outline how to consume the tools as well as provide short notes on how to build both types of tools.</source>
          <target state="translated">ここでは、ツールの利用方法を概説するだけでなく、両方の種類のツールをビルドする方法の簡単なメモを提供します。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How to extend CLI tools</source>
          <target state="translated">CLI ツールを拡張する方法</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The CLI tools can be extended in three main ways:</source>
          <target state="translated">CLI ツールは、主に次の&amp;3; つの方法で拡張できます。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Via NuGet packages on a per-project basis</source>
          <target state="translated">プロジェクトごとに NuGet パッケージを使用</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Via NuGet packages with custom targets</source>
          <target state="translated">カスタム ターゲットを持つ NuGet パッケージを使用</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Via the system's PATH</source>
          <target state="translated">システムのパスを使用</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The three extensibility mechanisms outlined above are not exclusive; you can use all or just one or combine them.</source>
          <target state="translated">上記で説明した&amp;3; つの拡張メカニズムは、排他的ではありません。すべて、または&amp;1; つだけ使用するか、これらを組み合わせることができます。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Which one to pick depends largely on what is the goal you are trying to achieve with your extension.</source>
          <target state="translated">どちらを選択するかは、拡張機能で実現しようとしている目標によって大きく異なります。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Per-project based extensibility</source>
          <target state="translated">各プロジェクト ベースの拡張機能</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Per-project tools are <bpt id="p1">[</bpt>framework-dependented deployments<ept id="p1">](../deploying/index.md)</ept> that are distributed as NuGet packages.</source>
          <target state="translated">各プロジェクトのツールは、NuGet パッケージとして配布される<bpt id="p1">[</bpt>フレームワーク依存の展開<ept id="p1">](../deploying/index.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Tools are only available in the context of the project that references them and for which they are restored; invocation outside of the context of the project (for example, outside of the directory that contains the project) will fail as the command will not be able to be found.</source>
          <target state="translated">ツールは、ツールを参照および復元するプロジェクトのコンテキスト内でのみ使用できます。プロジェクトのコンテキストの外部 (たとえば、プロジェクトが含まれているディレクトリの外) での起動は、コマンドを見つけることができないために失敗します。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>These tools are perfect for build servers, since nothing outside of the project file is needed.</source>
          <target state="translated">プロジェクト ファイルの外部は必要ないため、これらのツールはビルド サーバーに最適です。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The build process runs restore for the project it builds and tools will be available.</source>
          <target state="translated">ビルド処理では、ビルドを行うプロジェクトの復元が実行され、ツールが利用可能になります。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Language projects, such as F#, are also in this category; after all, each project can only be written in one specific language.</source>
          <target state="translated">F# などの言語プロジェクトも、このカテゴリに入ります。結局、各プロジェクトは&amp;1; つの特定の言語でのみ記述できます。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Finally, this extensibility model provides support for creation of tools that need access to the built output of the project.</source>
          <target state="translated">最後に、この拡張モデルは、プロジェクトのビルド出力へのアクセス権が必要なツールの作成をサポートします。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For instance, various Razor view tools in <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC applications fall into this category.</source>
          <target state="translated">たとえば、<bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC アプリケーションのさまざまな Razor ビュー ツールが、このカテゴリに分類されます。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consuming per-project tools</source>
          <target state="translated">各プロジェクト ツールの利用</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Consuming these tools requires you to add a <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element for each tool you want to use to your project file.</source>
          <target state="translated">これらのツールを利用するには、使用する各ツールの <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> 要素をプロジェクト ファイルに追加する必要があります。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Inside the <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element, you reference the package in which the tool resides and you specify the version you need.</source>
          <target state="translated"><ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> 要素の内部で、ツールが存在するパッケージを参照し、必要なバージョンを指定します。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>After running <ph id="ph1">`dotnet restore`</ph>, the tool and its dependencies are restored.</source>
          <target state="translated"><ph id="ph1">`dotnet restore`</ph> を実行した後、ツールとその依存関係が復元されます。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For tools that need to load the build output of the project for execution, there is usually another dependency which is listed under the regular dependencies in the project file.</source>
          <target state="translated">実行するためにプロジェクトのビルド出力を読み込む必要があるツールの場合、通常、別の依存関係がプロジェクト ファイル内の標準の依存関係に一覧されています。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Since CLI uses MSBuild as its build engine, it is recommended that these parts of the tool be written as custom MSBuild targets and tasks since that way they can take part in the overall build process.</source>
          <target state="translated">CLI では、ビルド エンジンとして MSBuild を使用するため、ツールのこれらの部分はカスタム MSBuild のターゲットおよびタスクとして記述することを推奨します。これにより、ビルド プロセス全体に参加できるようになるためです。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Also, they can get any and all data easily that is produced via the build, for example the location of the output files, the current configuration being built etc. All of this information becomes a set of MSBuild properties that can be read from any target.</source>
          <target state="translated">さらに、出力ファイルの場所、現在ビルドされている構成といった、ビルドによって生成されるすべてのデータを簡単に取得できます。この情報はすべて、どのターゲットからも読み取り可能な一連の MSBuild プロパティになります。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>We will see how to add a custom target using NuGet later in this document.</source>
          <target state="translated">このドキュメントでは、後ほど NuGet を使用してカスタム ターゲットを追加する方法を説明します。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Let's review an example of adding a simple tools-only tool to a simple project.</source>
          <target state="translated">単純なツールだけのツールを単純なプロジェクトに追加する例を確認してみましょう。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Given an example command called <ph id="ph1">`dotnet-api-search`</ph> that allows you to search through the NuGet packages for the specified API, here is a console application's project file that uses that tool:</source>
          <target state="translated">指定された API の NuGet パッケージを使用して検索できる <ph id="ph1">`dotnet-api-search`</ph> というコマンドの例を仮定すると、そのツールを使用するコンソール アプリケーションのプロジェクト ファイルは、次のようになります。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element is structured in a similar way as the <ph id="ph2">`&lt;PackageReference&gt;`</ph> element.</source>
          <target state="translated"><ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> 要素は、<ph id="ph2">`&lt;PackageReference&gt;`</ph> 要素と同様の方法で構造化されます。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>It needs the package ID of the package containing the tool and its version at the very least.</source>
          <target state="translated">少なくともツールとそのバージョンを含む、パッケージのパッケージ ID が必要です。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Building tools</source>
          <target state="translated">ツールのビルド</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>As mentioned, tools are just portable console applications.</source>
          <target state="translated">前述のように、ツールは、単なるポータブル コンソール アプリケーションです。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You would build one as you would build any console application.</source>
          <target state="translated">お客様はコンソール アプリケーションをビルドするように、ツールをビルドします。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>After you build it, you would use <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> command to create a NuGet package (nupkg) that contains your code, information about its dependencies and so on.</source>
          <target state="translated">ビルドした後、<bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> コマンドを使用して、コード、その依存関係に関する情報などを含む NuGet パッケージ (nupkg) を作成します。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The package name can be whatever the author wants, but the application inside, the actual tool binary, has to conform to the convention of <ph id="ph1">`dotnet-&lt;command&gt;`</ph> in order for <ph id="ph2">`dotnet`</ph> to be able to invoke it.</source>
          <target state="translated">パッケージ名は、作成者が必要な内容であることがありますが、アプリケーション内 (実際のツール バイナリ) は、<ph id="ph2">`dotnet`</ph> がそれを起動できるように、<ph id="ph1">`dotnet-&lt;command&gt;`</ph> の規則に準拠している必要があります。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In pre-RC3 versions of the .NET Core command-line tools, the <ph id="ph1">`dotnet pack`</ph> command had a bug that caused the <ph id="ph2">`runtime.config.json`</ph> to not be packed with the tool.</source>
          <target state="translated">.NET Core コマンドライン ツールの RC3 以前のバージョンでは、<ph id="ph1">`dotnet pack`</ph> コマンドにバグがあり、<ph id="ph2">`runtime.config.json`</ph> をツールでパックできませんでした。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Lacking that file results in errors at runtime.</source>
          <target state="translated">そのファイルがないことで、実行時にエラーが発生します。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If you encounter this behavior, be sure to update to the latest tooling and try the <ph id="ph1">`dotnet pack`</ph> again.</source>
          <target state="translated">この動作が見られる場合、最新のツールに更新し、<ph id="ph1">`dotnet pack`</ph> をもう一度お試しください。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Since tools are portable applications, the user consuming the tool has to have the version of the .NET Core libraries that the tool was built against in order to run the tool.</source>
          <target state="translated">ツールはポータブル アプリケーションであるため、ツールを利用しているユーザーは、ツールを実行するためにツールをビルドするバージョンの .NET Core ライブラリを所有している必要があります。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Any other dependency that the tool uses and that is not contained within the .NET Core libraries is restored and placed in the NuGet cache.</source>
          <target state="translated">ツールを使用し、.NET Core ライブラリ内に含まれない任意のその他の依存関係は、NuGet キャッシュに復元および配置されます。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The entire tool is, therefore, run using the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache.</source>
          <target state="translated">そのため、ツール全体が、.NET Core ライブラリからのアセンブリ、および NuGet キャッシュからのアセンブリを使用して実行されます。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>These kind of tools have a dependency graph that is completely separate from the dependency graph of the project that uses them.</source>
          <target state="translated">このようなツールには、それらのツールを使用するプロジェクトの依存関係グラフから完全に切り離された依存関係グラフがあります。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The restore process will first restore the project's dependencies, and will then restore each of the tools and their dependencies.</source>
          <target state="translated">復元処理では、最初にプロジェクトの依存関係を復元し、その後、各ツールとその依存関係を復元します。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You can find richer examples and different combinations of this in the <bpt id="p1">[</bpt>.NET Core CLI repo<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.</source>
          <target state="translated">豊富な例やさまざまな組み合わせを <bpt id="p1">[</bpt>.NET Core CLI リポジトリ<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept> で見つけることができます。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>You can also see the <bpt id="p1">[</bpt>implementation of tools used<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> in the same repo.</source>
          <target state="translated">また、同じリポジトリで<bpt id="p1">[</bpt>使用されたツールの実装<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept>を確認することもできます。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Custom targets</source>
          <target state="translated">カスタム ターゲット</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>NuGet has had the capability to package custom MSBuild target and props files for a while now and you can find the official documentation on this on the <bpt id="p1">[</bpt>NuGet documentation site<ept id="p1">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>.</source>
          <target state="translated">NuGet には以前からカスタム MSBuild ターゲットおよびプロパティ ファイルをパッケージ化する機能が備わっており、<bpt id="p1">[</bpt>NuGet ドキュメントのサイト<ept id="p1">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>でこれに関する公式の情報を確認することができます。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>With the move in the CLI to using MSBuild, the same mechanism of extensibility applies to .NET Core projects.</source>
          <target state="translated">CLI が MSBuild を使用するようになり、機能拡張の同じ機構が .NET Core プロジェクトに適用されています。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You would use this type of extensiblity when you want to extend the build process or when you want to access any of the artifacts in the build process, such as generated files or inspect the configuration under which the build is invoked etc.</source>
          <target state="translated">このような機能拡張は、ビルド プロセスの拡張が必要な場合、生成されたファイルなどのビルド プロセスの成果物にアクセスする必要がある場合、またはビルドが呼び出される構成を検査する場合などに使用します。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The sample target's project file is included below for reference.</source>
          <target state="translated">参考のため、サンプルのターゲットのプロジェクト ファイルが以下に含まれています。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It shows how to use the new <ph id="ph1">`csproj`</ph> syntax for instructing <ph id="ph2">`dotnet pack`</ph> command what to package to place the targets files as well as assemblies into the <ph id="ph3">`build`</ph> folder inside the package.</source>
          <target state="translated">何をパッケージ化して、そのパッケージの <ph id="ph3">`build`</ph> フォルダーにターゲットとアセンブリを配置するかについて <ph id="ph2">`dotnet pack`</ph> コマンドに指示するための新しい <ph id="ph1">`csproj`</ph> 構文の使い方を示します。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Take note of the <ph id="ph1">`&lt;ItemGroup&gt;`</ph> below that has the <ph id="ph2">`Label`</ph> property set to "dotnet pack instructions".</source>
          <target state="translated"><ph id="ph2">`Label`</ph> プロパティが "dotnet pack instructions" に設定されている <ph id="ph1">`&lt;ItemGroup&gt;`</ph> に注目してください。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Consuming custom targets is done by providing a <ph id="ph1">`&lt;PackageReference&gt;`</ph> that points to the package and its version inside the project that is being extended.</source>
          <target state="translated">カスタム ターゲットの利用は、拡張されているプロジェクト内部のパッケージとそのバージョンを指す <ph id="ph1">`&lt;PackageReference&gt;`</ph> を提供することで行われます。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Unlike the tools, the custom targets package does get included into the consuming project's dependency closure.</source>
          <target state="translated">ツールとは異なり、カスタム ターゲットのパッケージは利用しているプロジェクトの依存関係クロージャに含まれます。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Using the custom target depends solely on how you configure it.</source>
          <target state="translated">カスタム ターゲットの使用はその構成方法のみに依存します。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Since it is the usual MSBuild target, it can depend on a given target, run after another target and can also be manually invoked using the <ph id="ph1">`dotnet msbuild /t:&lt;target-name&gt;`</ph> command.</source>
          <target state="translated">これは通常の MSBuild ターゲットであるため、指定されたターゲットに依存しており、別のターゲットの後に実行することも、<ph id="ph1">`dotnet msbuild /t:&lt;target-name&gt;`</ph> コマンドを使用して手動で呼び出すこともできます。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>However, if you wish to provide a better user experience to your users, you can combine per-project tools and custom targets.</source>
          <target state="translated">ただし、ユーザーに優れたユーザー エクスペリエンスを提供するため、プロジェクトごとのツールとカスタム ターゲットを組み合わせることができます。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In this scenario, the per-project tool would essentially just accept whatever needed parameters and would translate that into the required <ph id="ph1">`dotnet msbuild`</ph> invocation that would execute the target.</source>
          <target state="translated">このシナリオでは、プロジェクトごとのツールは基本的に必要な任意のパラメーターのみを受け入れ、それをターゲットを実行する必要な <ph id="ph1">`dotnet msbuild`</ph> の呼び出しに変換します。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You can see a sample of this kind of synergy on the <bpt id="p1">[</bpt>MVP Summit 2016 Hackathon samples<ept id="p1">](https://github.com/dotnet/MVPSummitHackathon2016)</ept> repo in the <bpt id="p2">[</bpt><ph id="ph1">`dotnet-packer`</ph><ept id="p2">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept> project.</source>
          <target state="translated">このような相乗効果のサンプルは、<bpt id="p2">[</bpt><ph id="ph1">`dotnet-packer`</ph><ept id="p2">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept> プロジェクトの「<bpt id="p1">[</bpt>MVP Summit 2016 Hackathon samples<ept id="p1">](https://github.com/dotnet/MVPSummitHackathon2016)</ept>」 (MVP Summit 2016 ハッカソンのサンプル) レポートで参照することができます。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility</source>
          <target state="translated">パス ベースの拡張機能</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more than a single project.</source>
          <target state="translated">通常、パス ベースの拡張機能は、概念的に複数のプロジェクトに対応するツールが必要な開発用コンピューターに使用されます。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The main drawback of this extensions mechanism is that it is tied to the machine where the tool exists.</source>
          <target state="translated">この拡張機能のメカニズムの主なデメリットは、ツールが存在するマシンに関連付けられていることです。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>If you need it on another machine, you would have to deploy it.</source>
          <target state="translated">別のコンピューターで拡張機能が必要な場合は、それを展開する必要があります。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>This pattern of CLI toolset extensibility is very simple.</source>
          <target state="translated">このパターンの CLI ツールセットの拡張は、非常に単純です。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>As covered in the <bpt id="p1">[</bpt>.NET Core CLI overview<ept id="p1">](index.md)</ept>, <ph id="ph1">`dotnet`</ph> driver can run any command that is named after the <ph id="ph2">`dotnet-&lt;command&gt;`</ph> convention.</source>
          <target state="translated"><bpt id="p1">[</bpt>.NET Core CLI の概要<ept id="p1">](index.md)</ept>に関するページにあるように、<ph id="ph1">`dotnet`</ph> ドライバーは、<ph id="ph2">`dotnet-&lt;command&gt;`</ph> 規則にふさわしい名前が付けられた任意のコマンドを実行することができます。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The default resolution logic will first probe several locations and will finally fall to the system PATH.</source>
          <target state="translated">この既定の解決ロジックは、最初にいくつかの場所をプローブし、最後にシステム パスに取りかかります。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>If the requested command exists in the system PATH and is a binary that can be invoked, <ph id="ph1">`dotnet`</ph> driver will invoke it.</source>
          <target state="translated">要求されたコマンドがシステム パスに存在し、起動することができるバイナリである場合、<ph id="ph1">`dotnet`</ph> ドライバーでそれを起動します。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The binary can be pretty much anything that the operating system can execute.</source>
          <target state="translated">オペレーティング システムが実行できるほぼすべてがバイナリです。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>On Unix systems, this means anything that has the execute bit set via <ph id="ph1">`chmod +x`</ph>.</source>
          <target state="translated">Unix システムでは、<ph id="ph1">`chmod +x`</ph> によって実行ビット セットがあるすべてを意味します。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>On Windows it means anything that Windows knows how to run.</source>
          <target state="translated">Windows では、Windows が実行方法を理解しているすべてのことです。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>As an example, let's take a look at a very simple implementation of a <ph id="ph1">`dotnet clean`</ph> command.</source>
          <target state="translated">例として、<ph id="ph1">`dotnet clean`</ph> コマンドの単純な実装を見てみましょう。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>We will use <ph id="ph1">`bash`</ph> to implement this command.</source>
          <target state="translated">このコマンドを実装するには、<ph id="ph1">`bash`</ph> を使用します。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The command will simply delete the <ph id="ph1">`bin/`</ph> and <ph id="ph2">`obj/`</ph> directories in the current directory.</source>
          <target state="translated">このコマンドは、単純に現在のディレクトリ内の <ph id="ph1">`bin/`</ph> と <ph id="ph2">`obj/`</ph> ディレクトリを削除します。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`--lock`</ph> argument is passed to it, it will also delete <ph id="ph2">`project.lock.json`</ph> file.</source>
          <target state="translated"><ph id="ph1">`--lock`</ph> 引数が渡された場合、これは <ph id="ph2">`project.lock.json`</ph> ファイルも削除します。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The entirety of the command is given below.</source>
          <target state="translated">コマンドの全体は次のとおりです。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>On macOS, we can save this script as <ph id="ph1">`dotnet-clean`</ph> and set its executable bit with <ph id="ph2">`chmod +x dotnet-clean`</ph>.</source>
          <target state="translated">macOS では、このスクリプトを <ph id="ph1">`dotnet-clean`</ph> として保存し、その実行可能ビットを <ph id="ph2">`chmod +x dotnet-clean`</ph> に設定します。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>We can then create a symbolic link to it in <ph id="ph1">`/usr/local/bin`</ph> using the command <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph>.</source>
          <target state="translated">これで、コマンド <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph> を使用して、<ph id="ph1">`/usr/local/bin`</ph> でこのスクリプトへのシンボリック リンクを作成できます。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>This will make it possible to invoke the clean command using the <ph id="ph1">`dotnet clean`</ph> syntax.</source>
          <target state="translated">これにより、<ph id="ph1">`dotnet clean`</ph> 構文を使用して、クリーン コマンドを起動できるようになります。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can test this by creating an app, running <ph id="ph1">`dotnet build`</ph> on it and then running <ph id="ph2">`dotnet clean`</ph>.</source>
          <target state="translated">アプリを作成し、そのアプリで <ph id="ph1">`dotnet build`</ph> を実行して、<ph id="ph2">`dotnet clean`</ph> を実行し、これをテストできます。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">まとめ</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The .NET Core CLI tools allow three main extensibility points.</source>
          <target state="translated">.NET Core CLI ツールでは、3 つの主な拡張ポイントを許可します。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The per-project tools are contained within the project's context, but they allow easy installation through restoration.</source>
          <target state="translated">各プロジェクトのツールはプロジェクトのコンテキスト内に含まれますが、復元によって簡単にインストールできます。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Custom targets allow you to easily extend the build process with custom tasks.</source>
          <target state="translated">カスタム ターゲットを使用すると、カスタム タスクを使用してビルド プロセスを簡単に拡張できます。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>PATH-based tools are good for general, cross-project tools that are usable on a single machine.</source>
          <target state="translated">パス ベースのツールは、一般的に単一のコンピューターで使用できるプロジェクト間のツールに適しています。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>