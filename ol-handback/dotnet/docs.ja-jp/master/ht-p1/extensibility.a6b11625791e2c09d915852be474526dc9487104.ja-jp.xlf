<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ea16d4b841f5c93da222df56db36d6fb70ea35f9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tools\extensibility.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b6fec3e8b7b8e43a49178e846ebc37853a638b6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a7ca3d4f0a58b53afc1bbfcd7dad7dcdfd0867a6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">.NET Core CLI の拡張モデル</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">.NET Core CLI の拡張モデル</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>CLI, extensibility, custom commands, .NET Core</source>
          <target state="translated">CLI, 拡張, カスタム コマンド, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">.NET Core CLI の拡張モデル</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">概要</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This document will cover the main ways how to extend the CLI tools and explain the scenarios that drive each of them.</source>
          <target state="translated">このドキュメントは、CLI ツールを拡張する主な方法と、それぞれのツールを動作させるシナリオについて説明します。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It will the outline how to consume the tools as well as provide short notes on how to build both types of tools.</source>
          <target state="translated">ここでは、ツールの利用方法を概説するだけでなく、両方の種類のツールをビルドする方法の簡単なメモを提供します。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How to extend CLI tools</source>
          <target state="translated">CLI ツールを拡張する方法</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The CLI tools can be extended in two main ways:</source>
          <target state="translated">CLI ツールは、主に次の 2 つの方法で拡張できます。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Via NuGet packages on a per-project basis</source>
          <target state="translated">プロジェクトごとに NuGet パッケージを使用</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Via the system's PATH</source>
          <target state="translated">システムのパスを使用</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The two extensibility mechanisms outlined above are not exclusive; you can use both or just one.</source>
          <target state="translated">上記で説明した 2 つの拡張メカニズムは、排他的ではありません。両方または一方のみを使用することができます。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Which one to pick depends largely on what is the goal you are trying to achieve with your extension.</source>
          <target state="translated">どちらを選択するかは、拡張機能で実現しようとしている目標によって大きく異なります。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Per-project based extensibility</source>
          <target state="translated">各プロジェクト ベースの拡張機能</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Per-project tools are <bpt id="p1">[</bpt>portable console applications<ept id="p1">](../deploying/index.md)</ept> that are distributed as NuGet packages.</source>
          <target state="translated">各プロジェクトのツールは、NuGet パッケージとして配布される<bpt id="p1">[</bpt>ポータブル コンソール アプリケーション<ept id="p1">](../deploying/index.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Tools are only available in the context of the project that references them and for which they are restored; invocation outside of the context of the project (for example, outside of the directory that contains the project) will fail as the command will not be able to be found.</source>
          <target state="translated">ツールは、ツールを参照および復元するプロジェクトのコンテキスト内でのみ使用できます。プロジェクトのコンテキストの外部 (たとえば、プロジェクトが含まれているディレクトリの外) での起動は、コマンドを見つけることができないために失敗します。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>These tools are perfect for build servers as well, since nothing outside of <ph id="ph1">`project.json`</ph> is needed.</source>
          <target state="translated"><ph id="ph1">`project.json`</ph> の外部は必要ないため、これらのツールはビルド サーバーにも最適です。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The build process runs restore for the project it builds and tools will be available.</source>
          <target state="translated">ビルド処理では、ビルドを行うプロジェクトの復元が実行され、ツールが利用可能になります。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Language projects, such as F#, are also in this category; after all, each project can only be written in one specific language.</source>
          <target state="translated">F# などの言語プロジェクトも、このカテゴリに入ります。結局、各プロジェクトは 1 つの特定の言語でのみ記述できます。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Finally, this extensibility model provides support for creation of tools that need access to the built output of the project.</source>
          <target state="translated">最後に、この拡張モデルは、プロジェクトのビルド出力へのアクセス権が必要なツールの作成をサポートします。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For instance, various Razor view tools in <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC applications fall into this category.</source>
          <target state="translated">たとえば、<bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC アプリケーションのさまざまな Razor ビュー ツールが、このカテゴリに分類されます。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Consuming per-project tools</source>
          <target state="translated">各プロジェクト ツールの利用</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consuming these tools requires you to add a <ph id="ph1">`tools`</ph> node to your <ph id="ph2">`project.json`</ph>.</source>
          <target state="translated">これらのツールを利用するには、<ph id="ph1">`tools`</ph> ノードを自分の <ph id="ph2">`project.json`</ph> に追加する必要があります。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Inside the <ph id="ph1">`tools`</ph> node, you reference the package in which the tool resides.</source>
          <target state="translated"><ph id="ph1">`tools`</ph> ノード内で、ツールが存在するパッケージを参照します。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>After running <ph id="ph1">`dotnet restore`</ph>, the tool and its dependencies are restored.</source>
          <target state="translated"><ph id="ph1">`dotnet restore`</ph> を実行した後、ツールとその依存関係が復元されます。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For tools that need to load the build output of the project for execution, there is usually another dependency which is listed under the regular dependencies in the project file.</source>
          <target state="translated">実行するためにプロジェクトのビルド出力を読み込む必要があるツールの場合、通常、別の依存関係がプロジェクト ファイル内の標準の依存関係に一覧されています。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This means that tools that load project's code have two components:</source>
          <target state="translated">つまり、プロジェクトのコードを読み込むツールには、次の 2 つのコンポーネントがあるということです。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The "tools" main invoker</source>
          <target state="translated">"tools" の主な起動元</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Any number of other tools that contain the logic to work with</source>
          <target state="translated">作業するロジックを含む、さまざまなその他のツール</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Why two things?</source>
          <target state="translated">なぜ 2 つあるのでしょう。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Tools that need to load the build output of a project need to have unified dependency graph with the project they are working.</source>
          <target state="translated">プロジェクトのビルド出力を読み込む必要があるツールは、動作しているプロジェクトと統合された依存関係グラフを持っている必要があります。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>By adding the dependency bit, we enable NuGet to resolve these dependencies as a unified graph.</source>
          <target state="translated">依存関係ビットを追加して、統合されたグラフとしてこれらの依存関係を解決する NuGet を有効にします。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The invoker is there because it needs to reason about the location as well as the frameworks of the dependency tool.</source>
          <target state="translated">起動元は、場所だけでなく、依存関係ツールのフレームワークについて判断する必要があるために存在しています。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The invoker can accept all of the redirection arguments (<ph id="ph1">`-c`</ph>, <ph id="ph2">`-o`</ph>, <ph id="ph3">`-b`</ph>) that the user specifies and finds the dependency tool; it can also implement any policies for cases where multiple dependency tools exist for multiple frameworks (that is, does it run all of them, just one, etc.) In general, logic can be shared between these two tools any way that is needed.</source>
          <target state="translated">この起動元は、ユーザーが依存関係ツールを指定および検索する、すべてのリダイレクト引数 (<ph id="ph1">`-c`</ph><ph id="ph2">`-o`</ph>、<ph id="ph3">`-b`</ph>) を許可できます。また、複数の依存関係ツールが複数のフレームワーク向けに存在する場合 (すべてを実行、1 つだけを実行など)、任意のポリシーを実装することもできます。一般に、ロジックは必要に応じて 2 つツール間で共有できます。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Let's review an example of adding a simple tools-only tool to a simple project.</source>
          <target state="translated">単純なツールだけのツールを単純なプロジェクトに追加する例を確認してみましょう。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Given an example command called <ph id="ph1">`dotnet-api-search`</ph> that allows you to search through the NuGet packages for the specified API, here is a console application's <ph id="ph2">`project.json`</ph> file that uses that tool:</source>
          <target state="translated">指定された API の NuGet パッケージを使用して検索できる <ph id="ph1">`dotnet-api-search`</ph> というコマンドの例を仮定すると、そのツールを使用するコンソール アプリケーションの <ph id="ph2">`project.json`</ph> ファイルは、次のようになります。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`tools`</ph> node is structured in a similar way as the <ph id="ph2">`dependencies`</ph> node.</source>
          <target state="translated"><ph id="ph1">`tools`</ph> ノードは、<ph id="ph2">`dependencies`</ph> ノードと同様の方法で構造化されます。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>It needs the package ID of the package containing the tool and its version at the very least.</source>
          <target state="translated">少なくともツールとそのバージョンを含む、パッケージのパッケージ ID が必要です。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In the example above, we can see that there is another statement, the <ph id="ph1">`imports`</ph> one.</source>
          <target state="translated">上述の例では、<ph id="ph1">`imports`</ph> というもう 1 つのステートメントがあることがわかります。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This influences the tool's restore process and specifies that the tool is also compatible, in addition to any targeted frameworks the tools has, with <ph id="ph1">`dnxcore50`</ph> target.</source>
          <target state="translated">このステートメントは、ツールの復元処理に影響し、ツールが所有しているターゲットのフレームワークだけでなく、<ph id="ph1">`dnxcore50`</ph> ターゲットとも互換性があることを示します。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For more information you can consult the <bpt id="p1">[</bpt>project.json reference<ept id="p1">](project-json.md)</ept>.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>project.json 参照<ept id="p1">](project-json.md)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Building tools</source>
          <target state="translated">ツールのビルド</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>As mentioned, tools are just portable console applications.</source>
          <target state="translated">前述のように、ツールは、単なるポータブル コンソール アプリケーションです。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You would build one as you would build any console application.</source>
          <target state="translated">お客様はコンソール アプリケーションをビルドするように、ツールをビルドします。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>After you build it, you would use <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> command to create a NuGet package (nupkg) that contains your code, information about its dependencies and so on.</source>
          <target state="translated">ビルドした後、<bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> コマンドを使用して、コード、その依存関係に関する情報などを含む NuGet パッケージ (nupkg) を作成します。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The package name can be whatever the author wants, but the application inside, the actual tool binary, has to conform to the convention of <ph id="ph1">`dotnet-&lt;command&gt;`</ph> in order for <ph id="ph2">`dotnet`</ph> to be able to invoke it.</source>
          <target state="translated">パッケージ名は、作成者が必要な内容であることがありますが、アプリケーション内 (実際のツール バイナリ) は、<ph id="ph2">`dotnet`</ph> がそれを起動できるように、<ph id="ph1">`dotnet-&lt;command&gt;`</ph> の規則に準拠している必要があります。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Since tools are portable applications, the user consuming the tool has to have the version of the .NET Core libraries that the tool was built against in order to run the tool.</source>
          <target state="translated">ツールはポータブル アプリケーションであるため、ツールを利用しているユーザーは、ツールを実行するためにツールをビルドするバージョンの .NET Core ライブラリを所有している必要があります。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Any other dependency that the tool uses and that is not contained within the .NET Core libraries is restored and placed in the NuGet cache.</source>
          <target state="translated">ツールを使用し、.NET Core ライブラリ内に含まれない任意のその他の依存関係は、NuGet キャッシュに復元および配置されます。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The entire tool is, therefore, run using the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache.</source>
          <target state="translated">そのため、ツール全体が、.NET Core ライブラリからのアセンブリ、および NuGet キャッシュからのアセンブリを使用して実行されます。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>These kind of tools have a dependency graph that is completely separate from the dependency graph of the project that uses them.</source>
          <target state="translated">このようなツールには、それらのツールを使用するプロジェクトの依存関係グラフから完全に切り離された依存関係グラフがあります。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The restore process will first restore the project's dependencies, and will then restore each of the tools and their dependencies.</source>
          <target state="translated">復元処理では、最初にプロジェクトの依存関係を復元し、その後、各ツールとその依存関係を復元します。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can find richer examples and different combinations of this in the <bpt id="p1">[</bpt>.NET Core CLI repo<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.</source>
          <target state="translated">豊富な例やさまざまな組み合わせを <bpt id="p1">[</bpt>.NET Core CLI リポジトリ<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept> で見つけることができます。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You can also see the <bpt id="p1">[</bpt>implementation of tools used<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> in the same repo.</source>
          <target state="translated">また、同じリポジトリで<bpt id="p1">[</bpt>使用されたツールの実装<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept>を確認することもできます。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Building tools that load project's build outputs for execution is slightly different.</source>
          <target state="translated">実行するためにプロジェクトのビルド出力を読み込むツールのビルドは、少し異なります。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>As stated, for these kinds of tools there are two components:</source>
          <target state="translated">前述したように、これらのツールには、次の 2 つのコンポーネントがあります。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>A dispatcher tool that the user invokes</source>
          <target state="translated">ユーザーが起動するディスパッチャー ツール</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>A framework-specific dependency that contains the logic on how to find the build outputs and what to do with it</source>
          <target state="translated">ビルド出力を検索する方法と、操作する内容のロジックを含むフレームワーク固有の依存関係</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A prime example of this are <bpt id="p1">[</bpt>Entity Framework (EF)<ept id="p1">](https://github.com/aspnet/EntityFramework)</ept> commands as well as the <bpt id="p2">[</bpt><ph id="ph1">`dotnet test`</ph><ept id="p2">](dotnet-test.md)</ept> command.</source>
          <target state="translated"><bpt id="p1">[</bpt>Entity Framework (EF)<ept id="p1">](https://github.com/aspnet/EntityFramework)</ept> コマンドおよび <bpt id="p2">[</bpt><ph id="ph1">`dotnet test`</ph><ept id="p2">](dotnet-test.md)</ept> コマンドが、この主な例です。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In both cases, there is a tool that is referenced in the <ph id="ph1">`tools`</ph> node of the <ph id="ph2">`project.json`</ph> and that is the main dispatcher.</source>
          <target state="translated">どちらの場合も、<ph id="ph2">`project.json`</ph> の <ph id="ph1">`tools`</ph> ノードで参照されるツールがあります。このツールが主要なディスパッチャーです。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The user invokes this tool on the command line.</source>
          <target state="translated">ユーザーは、コマンドラインでこのツールを起動します。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The second piece of the puzzle is the dependency that is given in the project's main dependencies (either root ones or framework-specific ones).</source>
          <target state="translated">2 つ目のピースは、プロジェクトの主要な依存関係 (root の依存関係またはフレームワーク固有の依存関係) で指定される依存関係です。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This package contains the actual logic of the tool.</source>
          <target state="translated">このパッケージには、ツールの実際のロジックが含まれます。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The package is a normal dependency, thus it will be restored as part of the restore process for the project.</source>
          <target state="translated">このパッケージは標準の依存関係であるため、プロジェクトの復元処理の一部として復元されます。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Unlike the previous kind of tools, these tool are actually part of the graph of the project that consumes them.</source>
          <target state="translated">以前の種類のツールとは異なり、これらのツールは、実際にツールを利用するプロジェクトのグラフの一部です。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This is because they need access to the project's code and potentially all of its dependencies.</source>
          <target state="translated">これは、プロジェクトのコードおよび可能性があるすべてのその依存関係へのアクセス権が必要であるためです。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For instance, the EF tools need this because they need to scan the assemblies to find the code they need, such as migrations.</source>
          <target state="translated">たとえば、EF ツールは、ツールが必要なコードを検索するアセンブリ (移行など) をスキャンする必要があるため、このアクセス権が必要です。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Another reason why this two-pronged solution exists is to allow a cleaner invocation model.</source>
          <target state="translated">この 2 つに分かれたソリューションが存在するもう 1 つの理由は、より洗練された呼び出しモデルを可能にするためです。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Most CLI commands that drop certain artifacts on disk (for example, <ph id="ph1">`dotnet build`</ph>, <ph id="ph2">`dotnet publish`</ph>) allow users to redirect the outputs to a different path using the <ph id="ph3">`--output`</ph> argument or <ph id="ph4">`--build-base-path`</ph> argument or <ph id="ph5">`--configuration`</ph> argument.</source>
          <target state="translated">ディスク上の特定の成果物を削除する CLI コマンドのほとんど (<ph id="ph1">`dotnet build`</ph>、<ph id="ph2">`dotnet publish`</ph> など) で、ユーザーが <ph id="ph3">`--output`</ph> 引数、<ph id="ph4">`--build-base-path`</ph> 引数、または <ph id="ph5">`--configuration`</ph> 引数を使用して、別のパスに出力をリダイレクトできるようにします。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For EF tools, for example, to be able to find the build output of your project, you would have to provide the same arguments with the same values to <bpt id="p1">*</bpt>both<ept id="p1">*</ept> <ph id="ph1">`dotnet`</ph> driver as well as the <ph id="ph2">`ef`</ph> command.</source>
          <target state="translated">たとえば、EF ツールの場合、プロジェクトのビルド出力を検索できるようにするには、<ph id="ph1">`dotnet`</ph> ドライバーと <ph id="ph2">`ef`</ph> コマンドの<bpt id="p1">*</bpt>両方<ept id="p1">*</ept>に同じ値の同じ引数を指定する必要があります。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>With the invocation model, the users pass any arguments to the dispatcher tool which can then use that to find the needed binary that contains the logic in the output directories.</source>
          <target state="translated">呼び出しモデルでは、ユーザーは任意の引数をディスパッチャー ツールに渡します。これにより、出力ディレクトリでロジックを含む必要なバイナリを検索するために使用できます。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>A good example of this approach can be found in the <bpt id="p1">[</bpt>.NET Core CLI repo<ept id="p1">](https://github.com/dotnet/cli)</ept>:</source>
          <target state="translated">この手法の例を次の <bpt id="p1">[</bpt>.NET Core CLI リポジトリ<ept id="p1">](https://github.com/dotnet/cli)</ept>で確認することができます。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Sample project.json file<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/TestAssets/DesktopTestProjects/AppWithDirectDependencyDesktopAndPortable/project.json)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>project.json ファイルの例<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/TestAssets/DesktopTestProjects/AppWithDirectDependencyDesktopAndPortable/project.json)</ept></target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Implementation of the dispatcher<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-dependency-tool-invoker)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ディスパッチャーの実装<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-dependency-tool-invoker)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Implementation of the framework-specific dependency<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-desktop-and-portable)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>フレームワーク固有の依存関係の実装<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-desktop-and-portable)</ept></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility</source>
          <target state="translated">パス ベースの拡張機能</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more than a single project.</source>
          <target state="translated">通常、パス ベースの拡張機能は、概念的に複数のプロジェクトに対応するツールが必要な開発用コンピューターに使用されます。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The main drawback of this extensions mechanism is that it is tied to the machine where the tool exists.</source>
          <target state="translated">この拡張機能のメカニズムの主なデメリットは、ツールが存在するマシンに関連付けられていることです。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If you need it on another machine, you would have to deploy it.</source>
          <target state="translated">別のコンピューターで拡張機能が必要な場合は、それを展開する必要があります。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This pattern of CLI toolset extensibility is very simple.</source>
          <target state="translated">このパターンの CLI ツールセットの拡張は、非常に単純です。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>As covered in the <bpt id="p1">[</bpt>.NET Core CLI overview<ept id="p1">](index.md)</ept>, <ph id="ph1">`dotnet`</ph> driver can run any command that is named after the <ph id="ph2">`dotnet-&lt;command&gt;`</ph> convention.</source>
          <target state="translated"><bpt id="p1">[</bpt>.NET Core CLI の概要<ept id="p1">](index.md)</ept>に関するページにあるように、<ph id="ph1">`dotnet`</ph> ドライバーは、<ph id="ph2">`dotnet-&lt;command&gt;`</ph> 規則にふさわしい名前が付けられた任意のコマンドを実行することができます。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The default resolution logic will first probe several locations and will finally fall to the system PATH.</source>
          <target state="translated">この既定の解決ロジックは、最初にいくつかの場所をプローブし、最後にシステム パスに取りかかります。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If the requested command exists in the system PATH and is a binary that can be invoked, <ph id="ph1">`dotnet`</ph> driver will invoke it.</source>
          <target state="translated">要求されたコマンドがシステム パスに存在し、起動することができるバイナリである場合、<ph id="ph1">`dotnet`</ph> ドライバーでそれを起動します。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The binary can be pretty much anything that the operating system can execute.</source>
          <target state="translated">オペレーティング システムが実行できるほぼすべてがバイナリです。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>On Unix systems, this means anything that has the execute bit set via <ph id="ph1">`chmod +x`</ph>.</source>
          <target state="translated">Unix システムでは、<ph id="ph1">`chmod +x`</ph> によって実行ビット セットがあるすべてを意味します。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>On Windows it means anything that Windows knows how to run.</source>
          <target state="translated">Windows では、Windows が実行方法を理解しているすべてのことです。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>As an example, let's take a look at a very simple implementation of a <ph id="ph1">`dotnet clean`</ph> command.</source>
          <target state="translated">例として、<ph id="ph1">`dotnet clean`</ph> コマンドの単純な実装を見てみましょう。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>We will use <ph id="ph1">`bash`</ph> to implement this command.</source>
          <target state="translated">このコマンドを実装するには、<ph id="ph1">`bash`</ph> を使用します。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The command will simply delete the <ph id="ph1">`bin/`</ph> and <ph id="ph2">`obj/`</ph> directories in the current directory.</source>
          <target state="translated">このコマンドは、単純に現在のディレクトリ内の <ph id="ph1">`bin/`</ph> と <ph id="ph2">`obj/`</ph> ディレクトリを削除します。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`--lock`</ph> argument is passed to it, it will also delete <ph id="ph2">`project.lock.json`</ph> file.</source>
          <target state="translated"><ph id="ph1">`--lock`</ph> 引数が渡された場合、これは <ph id="ph2">`project.lock.json`</ph> ファイルも削除します。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The entirety of the command is given below.</source>
          <target state="translated">コマンドの全体は次のとおりです。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>On macOS, we can save this script as <ph id="ph1">`dotnet-clean`</ph> and set its executable bit with <ph id="ph2">`chmod +x dotnet-clean`</ph>.</source>
          <target state="translated">macOS では、このスクリプトを <ph id="ph1">`dotnet-clean`</ph> として保存し、その実行可能ビットを <ph id="ph2">`chmod +x dotnet-clean`</ph> に設定します。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>We can then create a symbolic link to it in <ph id="ph1">`/usr/local/bin`</ph> using the command <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph>.</source>
          <target state="translated">これで、コマンド <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph> を使用して、<ph id="ph1">`/usr/local/bin`</ph> でこのスクリプトへのシンボリック リンクを作成できます。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This will make it possible to invoke the clean command using the <ph id="ph1">`dotnet clean`</ph> syntax.</source>
          <target state="translated">これにより、<ph id="ph1">`dotnet clean`</ph> 構文を使用して、クリーン コマンドを起動できるようになります。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>You can test this by creating an app, running <ph id="ph1">`dotnet build`</ph> on it and then running <ph id="ph2">`dotnet clean`</ph>.</source>
          <target state="translated">アプリを作成し、そのアプリで <ph id="ph1">`dotnet build`</ph> を実行して、<ph id="ph2">`dotnet clean`</ph> を実行し、これをテストできます。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">まとめ</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The .NET Core CLI tools allow two main extensibility points.</source>
          <target state="translated">.NET Core CLI ツールでは、2 つの主な拡張ポイントを許可します。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The per-project tools are contained within the project's context, but they allow easy installation through restoration.</source>
          <target state="translated">各プロジェクトのツールはプロジェクトのコンテキスト内に含まれますが、復元によって簡単にインストールできます。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>PATH-based tools are good for general, cross-project tools that are usable on a single machine.</source>
          <target state="translated">パス ベースのツールは、一般的に単一のコンピューターで使用できるプロジェクト間のツールに適しています。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>