<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fba870a93784b579da1065a07d82974951ac7e28</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">95b746403eed8e13100defe90c42c880febbf750</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d8d70bd22979ff7663a27372887eb04ebd6c598f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">.NET Primer</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">.NET Primer</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">.NET Primer</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>"Getting Started with .NET Core" tutorials<ept id="p1">](../core/getting-started.md)</ept> to learn how to create a simple .NET Core application.</source>
          <target state="translated">「<bpt id="p1">[</bpt>Getting Started with .NET Core<ept id="p1">](../core/getting-started.md)</ept>」 (.NET Core の概要) では、単純な .NET Core アプリケーションを作成する方法を学習できます。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It only takes a few minutes to get your first app up and running.</source>
          <target state="translated">最初のアプリを、ほんの数分で起動および実行できます。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>.NET is a general purpose development platform.</source>
          <target state="translated">.NET は、汎用的な開発プラットフォームです。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>It can be used for any kind of app type or workload where general purpose solutions are used.</source>
          <target state="translated">汎用的なソリューションが使用される、あらゆる種類のアプリまたはワークロードに使用できます。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>It has several key features that are attractive to many developers, including automatic memory management and modern programming languages, that make it easier to efficiently build high-quality applications.</source>
          <target state="translated">自動メモリ管理や、高品質なアプリケーションの効率的な構築が簡単になる最新のプログラミング言語など、多くの開発者にとって魅力的な主要機能が含まれています。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>.NET enables a high-level programming environment with many convenience features, while providing low-level access to native memory and APIs.</source>
          <target state="translated">.NET では、多くの便利な機能によって高度なプログラミング環境が有効になり、同時にネイティブ メモリおよび API へのローレベル アクセスも提供されます。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Multiple implementations of .NET are available, based on open <bpt id="p1">[</bpt>.NET Standards<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)</ept> that specify the fundamentals of the platform.</source>
          <target state="translated">プラットフォームの基礎を指定するオープンな <bpt id="p1">[</bpt>.NET 標準<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)</ept>に基づき、複数の .NET 実装を使用できます。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>They are separately optimized for different application types (for example, desktop, mobile, gaming, cloud) and support many chips (for example, x86/x64, ARM) and operating systems (for example, Windows, Linux, iOS, Android, macOS).</source>
          <target state="translated">これらはアプリケーションの種類 (デスクトップ、モバイル、ゲーム、クラウドなど) ごとに個別に最適化されており、多くのチップ (x86/x64、ARM など) およびオペレーティング システム (Windows、Linux、iOS、Android、macOS など) をサポートしています。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Open source is also an important part of the .NET ecosystem, with multiple .NET implementations and many libraries available under OSI-approved licenses.</source>
          <target state="translated">.NET エコシステムでは、オープン ソースが重要な要素です。OSI 承認ライセンスによって複数の .NET 実装および多くのライブラリが利用できます。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>Overview of .NET implementations<ept id="p1">](../about/products.md)</ept> document to figure out all of the different editions of .NET that are available, both Microsoft's and others.</source>
          <target state="translated">Microsoft の .NET とそれ以外の .NET で利用できるすべてのエディションを確認するには、<bpt id="p1">[</bpt>.NET の実装の概要<ept id="p1">](../about/products.md)</ept>に関するドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This Primer will help you understand some of the key concepts in the .NET Platform and point you to more resources for each given topic.</source>
          <target state="translated">この Primer は .NET プラットフォームの主要概念の一部を理解するために役立ち、指定された各トピックの他のリソースの場所を示しています。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>By the end of it, you should have enough information to be able to recognize significant terms and concepts in the .NET Platform and to know how to further your knowledge about them.</source>
          <target state="translated">最後まで読むと、.NET プラットフォームの重要な用語と概念について理解するための十分な情報を入手でき、その知識をさらに深める方法を知ることができます。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A stroll through .NET</source>
          <target state="translated">.NET の概要</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>As any mature and advanced application development framework, .NET has many powerful features that make the developer's job easier and aim to make writing code more powerful and expressive.</source>
          <target state="translated">.NET は成熟した高度なアプリケーション開発フレームワークとして、開発者の業務を簡単にし、強力で表現力豊かなコードの記述を支援する、優れた機能を備えています。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This section will outline the basics of the most salient features and provide pointers to more detailed discussions where needed.</source>
          <target state="translated">このセクションでは特に重要な機能の基礎について概説し、必要に応じて詳細な説明のある場所を示します。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>After finishing this stroll, you should have enough information to be able to read the samples on our GitHub repos as well as other code and understand what is going on.</source>
          <target state="translated">概要を読み終わると、GitHub リポジトリのサンプルだけでなくその他のコードを読むために十分な情報を入手でき、最新の情報について理解できます。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Programming languages<ept id="p1">](#programming-languages)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>プログラミング言語<ept id="p1">](#programming-languages)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Automatic memory management<ept id="p1">](#automatic-memory-management)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>自動メモリ管理<ept id="p1">](#automatic-memory-management)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type safety<ept id="p1">](#type-safety)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>タイプ セーフ<ept id="p1">](#type-safety)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](#delegates-and-lambdas)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>デリゲートとラムダ<ept id="p1">](#delegates-and-lambdas)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types (Generics)<ept id="p1">](#generic-types-generics)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ジェネリック型 (ジェネリック)<ept id="p1">](#generic-types-generics)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Language Integrated Query (LINQ)<ept id="p1">](#language-integrated-query-linq)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>統合言語クエリ (LINQ)<ept id="p1">](#language-integrated-query-linq)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Async programming<ept id="p1">](#async-programming)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>非同期プログラミング<ept id="p1">](#async-programming)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Native interoperability<ept id="p1">](#native-interoperability)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ネイティブ相互運用性<ept id="p1">](#native-interoperability)</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Unsafe code<ept id="p1">](#unsafe-code)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>アンセーフ コード<ept id="p1">](#unsafe-code)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Programming languages</source>
          <target state="translated">プログラミング言語</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>As a developer, you can choose any programming language that supports .NET to create your application.</source>
          <target state="translated">開発者は、アプリケーションを作成するために .NET をサポートする任意のプログラミング言語を選択できます。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Because .NET provides language independence and interoperability, you can interact with other .NET applications and components regardless of the language with which they were developed.</source>
          <target state="translated">.NET は言語への依存性がなく、相互運用性があるので、開発に使用した言語に関係なく、他の .NET アプリケーションおよびコンポーネントと対話できます。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Languages that allow you to develop applications for the .NET Platform adhere to the <bpt id="p1">[</bpt>Common Language Infrastructure (CLI) specification<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>.</source>
          <target state="translated">.NET プラットフォームのアプリケーションを開発できる言語は、<bpt id="p1">[</bpt>共通言語基盤 (CLI) 仕様<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>に準拠します。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Microsoft languages that .NET supports include C#, F#, and Visual Basic.</source>
          <target state="translated">.NET がサポートする Microsoft 言語には、C#、F#、および Visual Basic が含まれます。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages.</source>
          <target state="translated">C# はシンプル、強力、タイプセーフ、そしてオブジェクト指向でありながらも、C スタイル言語の表現力と簡潔さが維持されています。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Anyone familiar with C and similar languages will find few problems in adapting to C#.</source>
          <target state="translated">C や類似の言語を使い慣れている人であれば、ほとんど問題なく C# に適応できるでしょう。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</source>
          <target state="translated">F# はクロスプラットフォームの関数型プログラミング言語ですが、従来のオブジェクト指向および命令型プログラミングもサポートしています。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.</source>
          <target state="translated">Visual Basic は、学習しやすい言語で、.NET 上で実行されるさまざまなアプリケーションの構築に使用できます。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In the current release of .NET Core, only C# is fully supported across all Microsoft tools.</source>
          <target state="translated">最新のリリースの .NET Core において、すべての Microsoft ツールで完全にサポートされている唯一の言語が C# です。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>F# is supported in the .NET Core SDK, but does not have Visual Studio tooling yet.</source>
          <target state="translated">F# は .NET Core SDK ではサポートされていますが、まだ Visual Studio ツールが含まれていません。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Visual Basic support for the SDK and Visual Studio tooling are coming.</source>
          <target state="translated">間もなく Visual Basic で SDK と Visual Studio ツールのサポートが始まります。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Automatic memory management</source>
          <target state="translated">自動メモリ管理</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Garbage collection is the most well-known of .NET features.</source>
          <target state="translated">ガベージ コレクションは、最もよく知られた .NET の機能です。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Developers do not need to actively manage memory, although there are mechanisms to provide more information to the garbage collector (GC).</source>
          <target state="translated">ガベージ コレクター (GC) に詳しい情報を提供する方法はありますが、開発者がメモリを積極的に管理する必要はありません。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>C# includes the <ph id="ph1">`new`</ph> keyword to allocate memory in terms of a particular type, and the <ph id="ph2">`using`</ph> keyword to provide scope for the usage of the object.</source>
          <target state="translated">C# には、特定の型でメモリを割り当てる <ph id="ph1">`new`</ph> キーワードや、オブジェクトの使用範囲を提供する <ph id="ph2">`using`</ph> キーワードが含まれています。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.</source>
          <target state="translated">GC はメモリ管理に対する遅延アプローチで動作します。この場合、メモリの即時収集よりもアプリケーションのスループットが優先されます。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following two lines both allocate memory:</source>
          <target state="translated">以下の 2 つの行はどちらもメモリを割り当てています。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>There is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled running.</source>
          <target state="translated">ガベージ コレクターがスケジュールされた実行によってメモリを解放する際に割り当て解除が自動的に行われるため、メモリの割り当てを解除するための類似したキーワードはありません。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Method variables normally go out of scope once a method completes, at which point they can be collected.</source>
          <target state="translated">通常、メソッドの変数は、メソッドが完了して、収集が可能になった時点で、スコープ外に移動します。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the <ph id="ph1">`using`</ph> statement.</source>
          <target state="translated">ただし、<ph id="ph1">`using`</ph> ステートメントを使用して、メソッドの終了よりも早く、特定のオブジェクトがスコープ外に移動するように GC に指定することができます。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Once the <ph id="ph1">`using`</ph> block completes, the GC will know that the <ph id="ph2">`stream`</ph> object in the example above is free to be collected and its memory reclaimed.</source>
          <target state="translated"><ph id="ph1">`using`</ph> ブロックが完了すると、上の例の <ph id="ph2">`stream`</ph> オブジェクトを自由に収集でき、メモリが解放できることが GC に伝わります。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>One of the less obvious but quite far-reaching features that a garbage collector enables is memory safety.</source>
          <target state="translated">ガベージ コレクターによって可能になる機能のうち、これほど目立たないものの、非常に広範囲に及ぶものの 1 つが、メモリの安全性です。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).</source>
          <target state="translated">メモリの安全性の不変性は非常に単純です。プログラムが割り当てられている (そして解放されていない) メモリのみにアクセスする場合、そのプログラムはメモリ セーフです。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Dangling pointers are always bugs, and tracking them down is often quite difficult.</source>
          <target state="translated">付随的なポインターは常にバグになり、多くの場合、これらを見つけ出すことはとても困難です。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The .NET runtime provides additional services, to complete the promise of memory safety, not naturally offered by a GC.</source>
          <target state="translated">.NET ランタイムでは、GC から元々提供されるものではない、メモリの安全性を確保するための追加のサービスを提供しています。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>It ensures that programs do not index off the end of an array or accessing a phantom field off the end of an object.</source>
          <target state="translated">プログラムが配列の最後にインデックス処理を行ったり、オブジェクトの最後にある実在しないフィールドにアクセスしたりすることがなくなります。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The following example will throw an exception as a result of memory safety.</source>
          <target state="translated">次の例では、メモリの安全性の結果として、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Type safety</source>
          <target state="translated">タイプ セーフ</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Objects are allocated in terms of types.</source>
          <target state="translated">オブジェクトには、型が割り当てられます。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The only operations allowed for a given object, and the memory it consumes, are those of its type.</source>
          <target state="translated">指定のオブジェクトが許可される操作、および使用するメモリは、その型から決まります。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dog`</ph> type may have <ph id="ph2">`Jump`</ph> and <ph id="ph3">`WagTail`</ph> methods, but not likely a <ph id="ph4">`SumTotal`</ph> method.</source>
          <target state="translated"><ph id="ph1">`Dog`</ph> 型には <ph id="ph2">`Jump`</ph> と <ph id="ph3">`WagTail`</ph> メソッドを含むことができますが、<ph id="ph4">`SumTotal`</ph> メソッドが含まれることはないでしょう。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A program can only call the declared methods of a given type.</source>
          <target state="translated">プログラムは、指定された型の宣言されたメソッドのみを呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or <ph id="ph1">`object`</ph>).</source>
          <target state="translated">それ以外のどの呼び出しを行っても、コンパイル時エラーまたはランタイム例外が発生します (動的機能または <ph id="ph1">`object`</ph> を使用した場合)。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>.NET languages are object-oriented, with hierarchies of base and derived classes.</source>
          <target state="translated">.NET 言語は、オブジェクト指向で、基本クラスと派生クラスの階層を含みます。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The .NET runtime will only allow object casts and calls that align with the object hierarchy.</source>
          <target state="translated">.NET ランタイムではオブジェクトの階層に応じたオブジェクトのキャストと呼び出しのみが許可されます。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Remember that every type defined in any .NET language derives from the base <ph id="ph1">`object`</ph> type.</source>
          <target state="translated">.NET 言語で定義されているすべての型が、基本の <ph id="ph1">`object`</ph> 型から派生していることを覚えておいてください。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</source>
          <target state="translated">タイプ セーフは、アクセサー キーワードの忠実性を保証することで、カプセル化の支援を行うためにも使用されます。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Accessor keywords are artifacts which control access to members of a given type by other code.</source>
          <target state="translated">アクセサー キーワードは、指定した型のメンバーへのアクセスを他のコードによって制御する成果物です。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>These are usually used for various kinds of data within a type that are used to manage its behavior.</source>
          <target state="translated">これらは通常、その動作を管理するために使用される型に含まれる、さまざまな種類のデータに使用されます。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Some .NET languages support <bpt id="p1">**</bpt>type inference<ept id="p1">**</ept>.</source>
          <target state="translated">一部の .NET 言語では、<bpt id="p1">**</bpt>型推論<ept id="p1">**</ept>がサポートされます。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side.</source>
          <target state="translated">型推論は、コンパイラが右側にある式から左側にある式の型を推論するという意味です。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This doesn't mean that the type safety is broken or avoided.</source>
          <target state="translated">タイプ セーフの破損、または回避を意味するわけではありません。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The resulting type <bpt id="p1">**</bpt>has<ept id="p1">**</ept> a strong type with everything that implies.</source>
          <target state="translated">結果の型には、推論されるすべてを含む厳密な型が<bpt id="p1">**</bpt>含まれます<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Let's rewrite the first two lines of the previous example to introduce type inference.</source>
          <target state="translated">前の例の最初の 2 行を、型推論を示すように書き換えてみましょう。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You will note that the rest of the example is completely the same.</source>
          <target state="translated">例の残りの部分がまったく同じであることに気づくはずです。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">デリゲートとラムダ</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Delegates are like C++ function pointers, with a big difference that they are type safe.</source>
          <target state="translated">デリゲートは C++ の関数ポインターに似ていますが、大きな違いはタイプ セーフであることです。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>They are a kind of disconnected method within the CLR type system.</source>
          <target state="translated">CLR 型システム内で接続されていないメソッドの一種です。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Regular methods are attached to a class and only directly callable through static or instance calling conventions.</source>
          <target state="translated">通常のメソッドはクラスに接続されており、静的な、またはインスタンスが呼び出す規則によってのみ直接呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Delegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.</source>
          <target state="translated">デリゲートは、.NET の世界のさまざまな API や場所で使用されます。このうち、特に使用されるのが、LINQ の要となるラムダ式です。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept> document.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept>」(デリゲートとラムダ) のドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Generic types (Generics)</source>
          <target state="translated">ジェネリック型 (ジェネリック)</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Generic types, also commonly called "generics", are a feature that was added in .NET Framework 2.0.</source>
          <target state="translated">一般に "ジェネリック" とも呼ばれるジェネリック型は、.NET Framework 2.0 で追加された機能です。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In short, generics allow the programmer to introduce a "type parameter" when designing their classes, that will allow the client code (the users of the type) to specify the exact type to use in place of the type parameter.</source>
          <target state="translated">簡単に言えば、ジェネリックを使用することで、プログラマがクラスを設計する際に "型パラメーター" を導入することができ、これによってクライアント コード (その型のユーザー) が型パラメーターの代わりに使用する正確な型を指定できるようになります。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Generics were added in order to help programmers implement generic data structures.</source>
          <target state="translated">ジェネリックは、プログラマが汎用的なデータ構造を実装するために追加されました。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Before their arrival, in order for a, say, <bpt id="p1">_</bpt>List<ept id="p1">_</ept> type to be generic, it would have to work with elements that were of type <bpt id="p2">_</bpt>object<ept id="p2">_</ept>.</source>
          <target state="translated">それ以前は、たとえば <bpt id="p1">_</bpt>List<ept id="p1">_</ept> 型をジェネリックにするには、<bpt id="p2">_</bpt>Object<ept id="p2">_</ept> 型の要素を使用する必要がありました。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This would have various performance as well as semantic problems, not to mention possible subtle runtime errors.</source>
          <target state="translated">これにより、軽微なランタイム エラーの可能性があることは言うまでもなく、パフォーマンスやセマンティックのさまざまな問題が発生することがありました。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <bpt id="p1">_</bpt>InvalidCastException<ept id="p1">_</ept> is thrown on working with the list's members.</source>
          <target state="translated">セマンティックに関して特に問題だったのは、データ構造にたとえば整数と文字列の両方が含まれる場合にリストのメンバーを操作すると <bpt id="p1">_</bpt>InvalidCastException<ept id="p1">_</ept> がスローされるということです。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The below sample shows a basic program running using an instance of <ph id="ph1">@System.Collections.Generic.List%601</ph> types.</source>
          <target state="translated">以下のサンプルに、<ph id="ph1">@System.Collections.Generic.List%601</ph> 型のインスタンスを使用して実行される基本的なプログラムを示します。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept> article.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept>」(ジェネリック型 (ジェネリック) の概要) の記事を参照してください。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Async programming</source>
          <target state="translated">非同期プログラミング</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Async programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs.</source>
          <target state="translated">非同期プログラミングは、ランタイムでの非同期サポート、フレームワーク ライブラリ、.NET 言語構成要素が含まれる、.NET のファースト クラスの概念です。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Internally, they are based off of objects (such as <ph id="ph1">`Task`</ph>) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</source>
          <target state="translated">内部は、オペレーティング システムを利用して可能な限り効率的に I/O バウンドなジョブを実行する、(<ph id="ph1">`Task`</ph> などの) オブジェクトに基づいています。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>To learn more about async programming in .NET, start with the <bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept>.</source>
          <target state="translated">.NET の非同期プログラミングの詳細を理解するには、最初に「<bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept>」(非同期の概要) を参照してください。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ)</source>
          <target state="translated">統合言語クエリ (LINQ)</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</source>
          <target state="translated">LINQ は、データ操作のための単純な宣言型コードを記述できる、C# および VB の強力な一連の機能です。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!</source>
          <target state="translated">データは (メモリ内オブジェクト、SQL データベース、XML ドキュメントなどの) さまざまな形式にすることができますが、記述する LINQ コードは通常、どのデータ ソースでも違いがないように見えます。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>To learn more and see some samples, check out <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</source>
          <target state="translated">詳細および一部のサンプルを確認するには、「<bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>」(LINQ (統合言語クエリ)) を参照してください。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">ネイティブ相互運用性</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Every operating system in current use provides a lot of platform support for various programming tasks.</source>
          <target state="translated">現在使用されているどのオペレーティング システムでも、さまざまなプログラミング タスクのための多くのプラットフォーム サポートを提供しています。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>.NET provides several ways to tap into those APIs.</source>
          <target state="translated">.NET には、その API を利用するためのいくつかの方法が用意されています。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Collectively, this support is called "native interoperability" and in this section we will take a look at how to access native APIs from managed, .NET code.</source>
          <target state="translated">このサポートをまとめて「ネイティブ相互運用性」と呼びます。このセクションでは、.NET のマネージ コードからネイティブの API にアクセスする方法を説明します。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The main way to do native interoperability is via "platform invoke" or P/Invoke for short.</source>
          <target state="translated">ネイティブの相互運用を行う主な方法が、"プラットフォーム呼び出し" (略してP/Invoke) を使用するものです。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This support in .NET Core is available across Linux and Windows platforms.</source>
          <target state="translated">.NET Core におけるこのサポートは Linux と Windows プラットフォーム間で使用できます。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Another, Windows-only way of doing native interoperability is known as "COM interop" which is used to work with <bpt id="p1">[</bpt>COM components<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in managed code.</source>
          <target state="translated">また、Windows 限定でネイティブの相互運用を行う方法が "COM 相互運用" です。これは、マネージ コードで <bpt id="p1">[</bpt>COM コンポーネント<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept>を操作する場合に使用します。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It is built on top of P/Invoke infrastructure, but it works in subtly different ways.</source>
          <target state="translated">これは、P/Invoke インフラストラクチャ上に構築されますが、動作は少し異なります。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</source>
          <target state="translated">Java および Objective-C に対する Mono (つまり Xamarin) の相互運用性サポートの多くが同じようにして構築されています。つまり、同じ原則を使用しているということです。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept> document.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept>」(ネイティブ相互運用性) のドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Unsafe code</source>
          <target state="translated">アンセーフ コード</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The CLR enables the ability to access native memory and do pointer arithmetic via <ph id="ph1">`unsafe`</ph> code.</source>
          <target state="translated">CLR の<ph id="ph1">`unsafe`</ph> コードによって、ネイティブ メモリにアクセスしたり、ポインターの算術演算を実行したりできるようになります。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>These operations are needed for certain algorithms and system interoperability.</source>
          <target state="translated">この操作は、特定のアルゴリズムおよびシステム相互運用性のために必要です。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm.</source>
          <target state="translated">アンセーフ コードの使用は強力ですが、システム API との相互運用を行ったり、最も効率的なアルゴリズムを実装したりする必要がなければ、推奨されません。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety.</source>
          <target state="translated">アンセーフ コードは、環境が異なると同じように実行されない可能性があり、さらにガベージ コレクターとタイプ セーフの利点が得られない場合があります。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.</source>
          <target state="translated">可能な限りアンセーフ コードのみに制限し、そのコードを徹底的にテストすることをお勧めします。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ToString()`</ph> method from the <bpt id="p1">[</bpt>StringBuilder class<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327)</ept> illustrates how using <ph id="ph2">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:</source>
          <target state="translated"><bpt id="p1">[</bpt>StringBuilder クラス<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327)</ept>の <ph id="ph1">`ToString()`</ph> メソッドは、次のように <ph id="ph2">`unsafe`</ph> コードを使用してメモリのチャンクを直接移動して、アルゴリズムを効率的に実装する方法を示しています。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">ノート</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The term ".NET runtime" is used throughout the document to accommodate for the multiple implementations of .NET, such as CLR, Mono, IL2CPP and others.</source>
          <target state="translated">".NET ランタイム" という用語は、CLR、Mono、IL2CPP などの .NET の複数の実装に対応する文書で使用されています。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The more specific names are only used if needed.</source>
          <target state="translated">より具体的な名前は、必要な場合にのみ使用されます。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>This document is not intended to be historical in nature, but describe the .NET platform as it is now.</source>
          <target state="translated">このドキュメントは、現状に即した .NET プラットフォームを説明したものであり、本質的にこれまでの流れについて説明することは意図していません。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It isn't important whether a .NET feature has always been available or was only recently introduced, only that it is important enough to highlight and discuss.</source>
          <target state="translated">その .NET 機能が常に利用可能か、また最近導入されたばかりかではなく、その機能を取り上げ、説明すべきかどうかのみを重視しています。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>