<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">649dfd6752f0589eb396b00e7d0b5184bb65d488</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\backtracking.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3c3f4b81cf190742fd47a71d366c45ef3d12d49</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">44f9547568980ddd9867439669c8bc02c62fd81a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Backtracking in regular expressions</source>
          <target state="translated">正規表現におけるバックトラッキング</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Backtracking in regular expressions</source>
          <target state="translated">正規表現におけるバックトラッキング</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Backtracking in regular expressions</source>
          <target state="translated">正規表現におけるバックトラッキング</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Backtracking occurs when a regular expression pattern contains optional <bpt id="p1">[</bpt>quantifiers<ept id="p1">](quantifiers.md)</ept> or <bpt id="p2">[</bpt>alternation constructs<ept id="p2">](alternation.md)</ept>, and the regular expression engine returns to a previous saved state to continue its search for a match.</source>
          <target state="translated">バックトラッキングは、正規表現パターンに省略可能な<bpt id="p1">[</bpt>量指定子<ept id="p1">](quantifiers.md)</ept>または<bpt id="p2">[</bpt>代替構成体<ept id="p2">](alternation.md)</ept>が含まれている場合に発生します。この場合、正規表現エンジンは、一致の検索を継続するために、以前に保存した状態に戻ります。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</source>
          <target state="translated">バックトラッキングは、正規表現を強力にするための中心的な機能で、これにより、非常に複雑なパターンを照合できる強力かつ柔軟な正規表現を作成できるようになります。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>At the same time, this power comes at a cost.</source>
          <target state="translated">その一方で、バックトラッキングにはマイナス面もあり、</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Backtracking is often the single most important factor that affects the performance of the regular expression engine.</source>
          <target state="translated">多くの場合、正規表現エンジンのパフォーマンスを左右する最大の要因になります。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</source>
          <target state="translated">さいわい、正規表現エンジンの動作とバックトラッキングの使用方法は開発者が制御できます。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This topic explains how backtracking works and how it can be controlled.</source>
          <target state="translated">ここでは、バックトラッキングの動作のしくみと、バックトラッキングを制御する方法について説明します。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In general, a Nondeterministic Finite Automaton (NFA) engine like the  regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</source>
          <target state="translated">一般に、正規表現エンジンのような非決定性有限オートマトン (NFA: Nondeterministic Finite Automaton) エンジンでは、効率的かつ高速な正規表現を作成する責任は開発者にあります。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections:</source>
          <target state="translated">このトピックは、次のセクションで構成されています。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Linear comparison without backtracking<ept id="p1">](#linear-comparison-without-backtracking)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>バックトラッキングを使用しない直線的な比較<ept id="p1">](#linear-comparison-without-backtracking)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking with optional quantifiers or alternation constructs<ept id="p1">](#backtracking-with-optional-quantifiers-or-alternation-constructs)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>省略可能な量指定子または代替構成体によるバックトラッキング<ept id="p1">](#backtracking-with-optional-quantifiers-or-alternation-constructs)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking with nested optional quantifiers<ept id="p1">](#backtracking-with-nested-optional-quantifiers)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>入れ子になった省略可能な量指定子によるバックトラッキング<ept id="p1">](#backtracking-with-nested-optional-quantifiers)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Controlling backtracking<ept id="p1">](#controlling-backtracking)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>バックトラッキングの制御<ept id="p1">](#controlling-backtracking)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Linear comparison without backtracking</source>
          <target state="translated">バックトラッキングを使用しない直線的な比較</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</source>
          <target state="translated">正規表現パターンに省略可能な量指定子や代替構成体が含まれていない場合、正規表現エンジンは線形時間で実行されます。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</source>
          <target state="translated">つまり、パターンの最初の言語要素を入力文字列のテキストと照合し、パターンの次の言語要素を入力文字列の次の文字または文字グループと照合するという操作が、</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This continues until the match either succeeds or fails.</source>
          <target state="translated">照合が最終的に成功または失敗するまで繰り返されます。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In either case, the regular expression engine advances by one character at a time in the input string.</source>
          <target state="translated">いずれの場合も、正規表現エンジンは入力文字列内を 1 文字ずつ進みます。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">具体的な例を次に示します。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`e{2}\w\b`</ph> looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</source>
          <target state="translated">正規表現 <ph id="ph1">`e{2}\w\b`</ph> は、文字 "e" が 2 回出現した後に任意の単語文字とワード境界が続くパターンを検索します。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Although this regular expression includes the quantifier <ph id="ph1">`{2}`</ph>, it is evaluated in a linear manner.</source>
          <target state="translated">この正規表現には量指定子 <ph id="ph1">`{2}`</ph> が含まれていますが、この量指定子は直線的に評価されます。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The regular expression engine does not backtrack because <ph id="ph1">`{2}`</ph> is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</source>
          <target state="translated">正規表現エンジンがバックトラックしないのは、<ph id="ph1">`{2}`</ph> が省略可能な量指定子ではないからです。この量指定子は、前の部分式が一致する必要がある正確な回数 (可変の回数ではなく) を指定しています。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</source>
          <target state="translated">結果として、正規表現エンジンは、次の表に示すような方法でこの正規表現パターンを入力文字列と照合します。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">操作</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Position in pattern</source>
          <target state="translated">パターン内の位置</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Position in string</source>
          <target state="translated">文字列内の位置</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">結果</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>"needing a reed" (index 0)</source>
          <target state="translated">"needing a reed" (インデックス 0)</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">一致なし。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>"eeding a reed" (index 1)</source>
          <target state="translated">"eeding a reed" (インデックス 1)</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">一致候補。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>e{2}</source>
          <target state="translated">e{2}</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>"eding a reed" (index 2)</source>
          <target state="translated">"eding a reed" (インデックス 2)</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">一致候補。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>\w</source>
          <target state="translated">\w</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>"ding a reed" (index 3)</source>
          <target state="translated">"ding a reed" (インデックス 3)</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">一致候補。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="translated">5</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>\b</source>
          <target state="translated">\b</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>"ing a reed" (index 4)</source>
          <target state="translated">"ing a reed" (インデックス 4)</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Possible match fails.</source>
          <target state="translated">一致候補の失敗。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>6</source>
          <target state="translated">6</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>"eding a reed" (index 2)</source>
          <target state="translated">"eding a reed" (インデックス 2)</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">一致候補。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>7</source>
          <target state="translated">7</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>e{2}</source>
          <target state="translated">e{2}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>"ding a reed" (index 3)</source>
          <target state="translated">"ding a reed" (インデックス 3)</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Possible match fails.</source>
          <target state="translated">一致候補の失敗。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>8</source>
          <target state="translated">8</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>"ding a reed" (index 3)</source>
          <target state="translated">"ding a reed" (インデックス 3)</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Match fails.</source>
          <target state="translated">照合の失敗。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>9</source>
          <target state="translated">9</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>"ing a reed" (index 4)</source>
          <target state="translated">"ing a reed" (インデックス 4)</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">一致なし。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>10</source>
          <target state="translated">10</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>"ng a reed" (index 5)</source>
          <target state="translated">"ng a reed" (インデックス 5)</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">一致なし。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>11</source>
          <target state="translated">11</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>"g a reed" (index 6)</source>
          <target state="translated">"g a reed" (インデックス 6)</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">一致なし。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>12</source>
          <target state="translated">12</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>" a reed" (index 7)</source>
          <target state="translated">" a reed" (インデックス 7)</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">一致なし。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>13</source>
          <target state="translated">13</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>"a reed" (index 8)</source>
          <target state="translated">"a reed" (インデックス 8)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">一致なし。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>" reed" (index 9)</source>
          <target state="translated">" reed" (インデックス 9)</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">一致なし。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>15</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>"reed" (index 10)</source>
          <target state="translated">"reed" (インデックス 10)</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>No match</source>
          <target state="translated">一致なし。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>"eed" (index 11)</source>
          <target state="translated">"eed" (インデックス 11)</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">一致候補。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>e{2}</source>
          <target state="translated">e{2}</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>"ed" (index 12)</source>
          <target state="translated">"ed" (インデックス 12)</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">一致候補。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>\w</source>
          <target state="translated">\w</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>"d" (index 13)</source>
          <target state="translated">"d" (インデックス 13)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">一致候補。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>\b</source>
          <target state="translated">\b</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>"" (index 14)</source>
          <target state="translated">"" (インデックス 14)</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Match.</source>
          <target state="translated">一致。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</source>
          <target state="translated">正規表現パターンに省略可能な量指定子や代替構成体が含まれていない場合、正規表現パターンと入力文字列の照合に必要な比較の最大数は、入力文字列の文字数にほぼ等しくなります。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</source>
          <target state="translated">この場合、正規表現エンジンは、この 13 文字の文字列の一致候補を特定するために 19 回の比較を使用します。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</source>
          <target state="translated">つまり、正規表現エンジンは、省略可能な量指定子や代替構成体が含まれていない場合にはほぼ線形時間で実行されます。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Backtracking with optional quantifiers or alternation constructs</source>
          <target state="translated">省略可能な量指定子または代替構成体によるバックトラッキング</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</source>
          <target state="translated">正規表現に省略可能な量指定子または代替構成体が含まれている場合、入力文字列の評価は直線的ではなくなります。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</source>
          <target state="translated">NFA エンジンによるパターン一致の動作は、照合する入力文字列内の文字ではなく、正規表現内の言語要素によって決まります。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</source>
          <target state="translated">したがって、正規表現エンジンは、省略可能な部分式や代替の部分式を完全に照合しようとします。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</source>
          <target state="translated">部分式内の次の言語要素に進んで照合が失敗した場合は、正規表現全体を入力文字列と照合するために、それまでに見つかった部分的な一致を放棄して、以前に保存した状態に戻ることもあります。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This process of returning to a previous saved state to find a match is known as backtracking.</source>
          <target state="translated">このように、一致を見つけるために以前に保存した状態に戻るプロセスを、バックトラッキングと呼びます。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>For example, consider the regular expression pattern <ph id="ph1">`.*(es)`</ph>, which matches the characters "es" and all the characters that precede it.</source>
          <target state="translated">例として、<ph id="ph1">`.*(es)`</ph> という正規表現パターンについて見てみましょう。この正規表現パターンは、文字 "es" と、それに先行するすべての文字に一致します。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</source>
          <target state="translated">次の例に示すように、入力文字列が "Essential services are provided by regular expressions." の場合、このパターンは、"expressions" の "es" までの文字列全体に一致します。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>To do this, the regular expression engine uses backtracking as follows:</source>
          <target state="translated">この場合、正規表現エンジンでは次のようにバックトラッキングが使用されます。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It matches the <ph id="ph1">`.*`</ph> (which matches zero, one, or more occurrences of any character) with the whole input string.</source>
          <target state="translated"><ph id="ph1">`.*`</ph> (任意の文字の 0 回以上の出現に一致します) を入力文字列全体と照合します。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It attempts to match "e" in the regular expression pattern.</source>
          <target state="translated">正規表現パターンの "e" との照合を試みますが、</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>However, the input string has no remaining characters available to match.</source>
          <target state="translated">入力文字列にはもう照合する文字がありません。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</source>
          <target state="translated">最後に成功した照合 ("Essential services are provided by regular expressions.") にバックトラックして、"e" を文末のピリオドと照合します。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The match fails.</source>
          <target state="translated">照合に失敗します。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</source>
          <target state="translated">成功した前の照合へのバックトラッキングを一度に 1 文字ずつ繰り返して、暫定的に一致する部分文字列 "Essential services are provided by regular expr" に到達します。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</source>
          <target state="translated">その後、パターンの "e" を "expressions" の 2 つ目の "e" と比較して、一致を見つけます。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</source>
          <target state="translated">パターンの "s" を、一致した文字 "e" の後の "s" ("expressions" の 1 つ目の "s") と比較します。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The match is successful.</source>
          <target state="translated">照合に成功します。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</source>
          <target state="translated">バックトラッキングを使用した場合、この正規表現パターンを 55 文字の入力文字列と照合するのに 67 回の比較操作が必要になります。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Interestingly, if the regular expression pattern included a lazy quantifier, <ph id="ph1">`.*?(es),`</ph> matching the regular expression would require additional comparisons.</source>
          <target state="translated">興味深いことに、この正規表現パターンに最短一致の量指定子、<ph id="ph1">`.*?(es),`</ph> が含まれていた場合は、照合に必要な比較が増加します。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>In this case, instead of having to backtrack from the end of the string to the "r" in "expressions", the regular expression engine would have to backtrack all the way to the beginning of the string to match "Es" and would require 113 comparisons.</source>
          <target state="translated">この場合、正規表現エンジンは、文字列の末尾から "expressions" の "r" までではなく、文字列の先頭までバックトラックして "Es" を見つけなければなりません。その結果、113 回の比較が必要になります。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</source>
          <target state="translated">一般に、正規表現パターンに 1 つの代替構成体または省略可能な量指定子が含まれている場合、パターンの照合に必要な比較操作の回数は入力文字列の文字数の 2 倍以上になります。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Backtracking with nested optional quantifiers</source>
          <target state="translated">入れ子になった省略可能な量指定子によるバックトラッキング</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</source>
          <target state="translated">パターンに多数の代替構成体、入れ子になった代替構成体、または (最もよくあるケースとして) 入れ子になった省略可能な量指定子が含まれていると、正規表現パターンの照合に必要な比較操作の回数は指数関数的に増加する可能性があります。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`^(a+)+$`</ph> is designed to match a complete string that contains one or more "a" characters.</source>
          <target state="translated">例として、1 つ以上の文字 "a" から成る文字列全体に一致するように作られた <ph id="ph1">`^(a+)+$`</ph> という正規表現パターンについて見てみましょう。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The example provides two input strings of identical length, but only the first string matches the pattern.</source>
          <target state="translated">次の例では、同じ長さの 2 つの入力文字列が渡されていますが、パターンに一致するのは 1 つ目の文字列だけです。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>System.Diagnostics.Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> class is used to determine how long the match operation takes.</source>
          <target state="translated"><bpt id="p1">[</bpt>System.Diagnostics.Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> クラスは、照合操作にかかる時間を調べるために使用されています。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</source>
          <target state="translated">出力を見るとわかるように、入力文字列がパターンに一致しない場合の処理時間は一致する場合の約 2 倍になります。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This is because an unsuccessful match always represents a worst-case scenario.</source>
          <target state="translated">これは、照合の失敗は常に最悪のシナリオに相当するためです。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</source>
          <target state="translated">正規表現エンジンは、照合の失敗という結論に到達するまでに、正規表現を使用してデータのすべての可能なパスを辿らなければなりません。かっこが入れ子になっていると、データのパスは大幅に増加します。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The regular expression engine concludes that the second string did not match the pattern by doing the following:</source>
          <target state="translated">2 つ目の文字列がパターンに一致しないという結論に到達するまでに正規表現エンジンによって行われる操作を以下に示します。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern a+.</source>
          <target state="translated">文字列の先頭にいることを確認し、文字列の最初の 5 文字をパターン a+ と照合します。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>It then determines that there are no additional groups of "a" characters in the string.</source>
          <target state="translated">次に、文字 "a" のグループが文字列内にそれ以上ないことを特定します。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Finally, it tests for the end of the string.</source>
          <target state="translated">最後に、文字列の終わりをテストします。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Because one additional character remains in the string, the match fails.</source>
          <target state="translated">文字列にまだ文字が 1 文字残っているため、照合は失敗します。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>This failed match requires 9 comparisons.</source>
          <target state="translated">この照合の失敗に必要な比較は 9 回です。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</source>
          <target state="translated">正規表現エンジンは、"a" (以降は照合 1 と呼びます)、"aa" (照合 2)、"aaa" (照合 3)、および "aaaa" (照合 4) の各照合の状態情報を保存します。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>It returns to the previously saved match 4.</source>
          <target state="translated">以前に保存した照合 4 に戻ります。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>It determines that there is one additional "a" character to assign to an additional captured group.</source>
          <target state="translated">追加のキャプチャ グループに割り当てる必要がある文字 "a" があと 1 つあることを特定します。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Finally, it tests for the end of the string.</source>
          <target state="translated">最後に、文字列の終わりをテストします。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Because one additional character remains in the string, the match fails.</source>
          <target state="translated">文字列にまだ文字が 1 文字残っているため、照合は失敗します。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This failed match requires 4 comparisons.</source>
          <target state="translated">この照合の失敗に必要な比較は 4 回です。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>So far, a total of 13 comparisons have been performed.</source>
          <target state="translated">これまでに実行された比較は合計 13 回になります。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>It returns to the previously saved match 3.</source>
          <target state="translated">以前に保存した照合 3 に戻ります。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>It determines that there are two additional "a" characters to assign to an additional captured group.</source>
          <target state="translated">追加のキャプチャ グループに割り当てる必要がある文字 "a" があと 2 つあることを特定しますが、</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>However, the end-of-string test fails.</source>
          <target state="translated">文字列の終わりのテストに失敗します。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</source>
          <target state="translated">その後、照合 3 に戻り、2 つの追加のキャプチャ グループの 2 つの追加の文字 "a" を照合しようとしますが、</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The end-of-string test still fails.</source>
          <target state="translated">ここでも文字列の終わりのテストに失敗します。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>These failed matches require 12 comparisons.</source>
          <target state="translated">これらの照合の失敗に必要な比較は 12 回です。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>So far, a total of 25 comparisons have been performed.</source>
          <target state="translated">これまでに実行された比較は合計 25 回になります。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</source>
          <target state="translated">このようにして、正規表現エンジンがすべての可能な一致の組み合わせを試行し終わるまで入力文字列と正規表現の比較が続けられます。一致しないという結論に到達するのはその後です。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Because of the nested quantifiers, this comparison is an O(2n) or an exponential operation, where n is the number of characters in the input string.</source>
          <target state="translated">この比較は、入れ子になった量指定子があるため、O(2n) (指数演算、n は入力文字列の文字数) です。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</source>
          <target state="translated">そのため、最悪のケースでは、30 文字の入力文字列で約 1,073,741,824 回、40 文字の入力文字列では約 1,099,511,627,776 回の比較が必要になります。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</source>
          <target state="translated">使用する文字列の長さがこのレベル以上になると、正規表現パターンに一致しない入力を処理するときに、正規表現メソッドの完了までに膨大な時間がかかる可能性があります。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Controlling backtracking</source>
          <target state="translated">バックトラッキングの制御</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Backtracking lets you create powerful, flexible regular expressions.</source>
          <target state="translated">バックトラッキングを使用すると、強力かつ柔軟な正規表現を作成できますが、</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</source>
          <target state="translated">前のセクションで見たように、受け入れられないほどのパフォーマンスの低下が伴うことがあります。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>To prevent excessive backtracking, you should define a time-out interval when you instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object or call a static regular expression matching method.</source>
          <target state="translated">過度なバックトラッキングを回避するには、<bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> オブジェクトをインスタンス化したり静的な正規表現の一致メソッドを呼び出したりするときに、タイムアウト間隔を定義する必要があります。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>This is discussed in the next section.</source>
          <target state="translated">これについては、次のセクションで説明します。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>In addition, .NET Core supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: <bpt id="p1">[</bpt>nonbacktracking subexpressions<ept id="p1">](#nonbacktracking-subexpression)</ept>, <bpt id="p2">[</bpt>lookbehind assertions<ept id="p2">](#lookbehind-assertions)</ept>, and <bpt id="p3">[</bpt>lookahead assertions<ept id="p3">](#lookahead-assertions)</ept>.</source>
          <target state="translated">また、.NET Core では、バックトラッキングを制限または抑制する 3 つの正規表現言語要素がサポートされています。これらを使用すると、パフォーマンスをほとんど低下させずに複雑な正規表現を使用できます。それらの言語要素とは、<bpt id="p1">[</bpt>非バックトラッキング部分式<ept id="p1">](#nonbacktracking-subexpression)</ept>、<bpt id="p2">[</bpt>後読みアサーション<ept id="p2">](#lookbehind-assertions)</ept>、および<bpt id="p3">[</bpt>先読みアサーション<ept id="p3">](#lookahead-assertions)</ept>です。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>For more information about each language element, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">各言語要素の詳細については、「<bpt id="p1">[</bpt>正規表現でのグループ化構成体<ept id="p1">](grouping.md)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Defining a time-out interval</source>
          <target state="translated">タイムアウト間隔の定義</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>You can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> exception.</source>
          <target state="translated">正規表現エンジンが単一の一致を検索する最長間隔を表すタイムアウト値を設定できます。それを超えると試行が中止され、<bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> 例外がスローされます。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>You specify the time-out interval by supplying a <bpt id="p1">[</bpt>TimeSpan<ept id="p1">](xref:System.TimeSpan)</ept> value to the <ph id="ph1">`Regex(String, RegexOptions, TimeSpan)`</ph> constructor for instance regular expressions.</source>
          <target state="translated">タイムアウト間隔を指定するには、インスタンス正規表現の <ph id="ph1">`Regex(String, RegexOptions, TimeSpan)`</ph> コンストラクターに <bpt id="p1">[</bpt>TimeSpan<ept id="p1">](xref:System.TimeSpan)</ept> 値を指定します。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>In addition, each static pattern matching method has an overload with a <bpt id="p1">[</bpt>TimeSpan<ept id="p1">](xref:System.TimeSpan)</ept> value to the [Regex.Regex(String, RegexOptions, TimeSpan)] parameter that allows you to specify a time-out value.</source>
          <target state="translated">また、各静的パターン一致メソッドには、[Regex.Regex(String, RegexOptions, TimeSpan)] パラメーターに対する <bpt id="p1">[</bpt>TimeSpan<ept id="p1">](xref:System.TimeSpan)</ept> 値を持つオーバーロードがあり、これを使用してタイムアウト値を指定できます。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>By default, the time-out interval is set to <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept> and the regular expression engine does not time out.</source>
          <target state="translated">既定のタイムアウト間隔は <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept> に設定されており、正規表現エンジンはタイムアウトしません。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>We recommend th&gt;at you always set a time-out interval if your regular expression relies on backtracking.</source>
          <target state="translated">正規表現がバックトラッキングに依存する場合は、常にタイムアウト間隔を設定することをお勧めします。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept>n exception indicates that the regular expression engine was unable to find a match within in the specified time-out interval but does not indicate why the exception was thrown.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> 例外は、指定されたタイムアウト間隔中に正規表現エンジンが一致を見つけられなかったことを示しますが、例外がスローされた原因は示しません。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</source>
          <target state="translated">原因は、通常は過度なバックトラッキングですが、例外がスローされたときのシステムの負荷に対して、タイムアウト間隔の設定が短すぎた可能性もあります。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</source>
          <target state="translated">例外を処理するときに、入力文字列との一致の検索をやめるか、タイムアウト間隔を延長して一致操作を再試行するかを選択できます。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>For example, the following code calls the <ph id="ph1">`Regex(String, RegexOptions, TimeSpan)`</ph> constructor to instantiate a Regex object with a time-out value of one second.</source>
          <target state="translated">たとえば、次のコードは <ph id="ph1">`Regex(String, RegexOptions, TimeSpan)`</ph> コンストラクターを呼び出して、1 秒のタイムアウト値を持つ Regex オブジェクトをインスタンス化します。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(a+)+$`</ph>, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</source>
          <target state="translated">正規表現パターン <ph id="ph1">`(a+)+$`</ph> は、行の末尾にある 1 つ以上の "a" 文字の 1 つ以上のシーケンスに一致しますが、過度なバックトラッキングの対象になります。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If a <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</source>
          <target state="translated">この例では、<bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> がスローされたら、タイムアウト値を 3 秒の最大間隔まで大きくします。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>After that, it abandons the attempt to match the pattern.</source>
          <target state="translated">その後、パターンに一致させる試行を中止します。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpression</source>
          <target state="translated">非バックトラッキング部分式</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept> <bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element suppresses backtracking in a subexpression.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept> <bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> 言語要素を使用すると、部分式でバックトラッキングがなされないようにすることができます。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>It is useful for preventing the performance problems associated with failed matches.</source>
          <target state="translated">これは、照合の失敗に関連するパフォーマンスの問題の防止に役立ちます。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</source>
          <target state="translated">次の例は、入れ子になった量指定子を使用している場合にバックトラッキングを抑制すると、いかにパフォーマンスが向上するかを示しています。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</source>
          <target state="translated">この例では、入力文字列が 2 つの正規表現に一致しないことが正規表現エンジンによって確認されるまでの時間を測定しています。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</source>
          <target state="translated">1 つ目の正規表現は、1 つ以上の 16 進数、コロン、1 つ以上の 16 進数、2 つのコロンというパターンを 1 つ以上含む文字列を、バックトラッキングを使用して照合します。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The second regular expression is identical to the first, except that it disables backtracking.</source>
          <target state="translated">2 つ目の正規表現は、バックトラッキングを無効にする以外は 1 つ目と同じです。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the performance improvement from disabling backtracking is significant.</source>
          <target state="translated">出力を見るとわかるように、バックトラッキングを無効にするとパフォーマンスが大幅に向上します。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Lookbehind assertions</source>
          <target state="translated">後読みアサーション</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>.NET includes two language elements, <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> and <bpt id="p4">**</bpt>(?&lt;!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept>, that match the previous character or characters in the input string.</source>
          <target state="translated">.NET には、入力文字列の前の文字と一致する 2 つの言語要素 <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> と <bpt id="p4">**</bpt>(?&lt;!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> が含まれています。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, without advancing or backtracking.</source>
          <target state="translated">これらの言語要素は、どちらもゼロ幅アサーションです。つまり、現在の文字の直前にある文字が <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> に一致するかどうかを、前進もバックトラッキングもせずに確認します。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a positive lookbehind assertion; that is, the character or characters before the current position must match <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> は肯定後読みアサーションで、現在の位置の前にある文字が <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept> に一致する必要があります。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a negative lookbehind assertion; that is, the character or characters before the current position must not match <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> は否定後読みアサーションで、現在の位置の前にある文字が <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept> に一致しない必要があります。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Both positive and negative lookbehind assertions are most useful when <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is a subset of the previous <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>.</source>
          <target state="translated">否定と肯定のどちらの後読みアサーションも、<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> が前の <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> のサブセットである場合に特に役立ちます。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The following example uses two equivalent regular expression patterns that validate the user name in an e-mail address.</source>
          <target state="translated">次の例では、電子メール アドレスのユーザー名を検証する 2 つの同等の正規表現パターンが使用されています。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The first pattern is subject to poor performance because of excessive backtracking.</source>
          <target state="translated">1 つ目のパターンでは、過度なバックトラッキングのためにパフォーマンスが低下します。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</source>
          <target state="translated">2 つ目のパターンでは、1 つ目の正規表現に変更を加えて、入れ子になった量指定子を肯定後読みアサーションに置き換えています。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The output from the example displays the execution time of the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method.</source>
          <target state="translated">この例の出力には、<bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> メソッドの実行時間が表示されます。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The first regular expression pattern, <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*@, is defined as shown in the following table.`</ph></source>
          <target state="translated">最初の正規表現パターンは次のとおりです。<ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*@, is defined as shown in the following table.`</ph></target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">パターン</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
          <target state="translated">文字列の先頭から照合を開始します。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">英数字 1 文字に一致します。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option.</source>
          <target state="translated"><bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> メソッドが <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> オプションを使用して呼び出されているため、この比較では大文字と小文字が区別されません。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Match zero, one, or more occurrences of a hyphen, period, or word character.</source>
          <target state="translated">ハイフン、ピリオド、または単語文字の 0 回以上の出現に一致します。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">英数字 1 文字に一致します。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</source>
          <target state="translated">0 個以上のハイフン、ピリオド、または単語文字の後に英数字が続く組み合わせの 0 回以上の出現に一致します。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">これが最初のキャプチャ グループです。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Match an at sign ("@").</source>
          <target state="translated">アット マーク ("@") に一致します。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The second regular expression pattern, <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])@`</ph>, uses a positive lookbehind assertion.</source>
          <target state="translated">2 つ目の正規表現パターン <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])@`</ph> では、肯定後読みアサーションが使用されています。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
          <target state="translated">このパターンは、次の表に示すように定義されています。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">パターン</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
          <target state="translated">文字列の先頭から照合を開始します。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">英数字 1 文字に一致します。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option.</source>
          <target state="translated"><bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> メソッドが <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> オプションを使用して呼び出されているため、この比較では大文字と小文字が区別されません。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of a hyphen, period, or word character.</source>
          <target state="translated">ハイフン、ピリオド、または単語文字の 0 回以上の出現と一致します。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Look back at the last matched character and continue the match if it is alphanumeric.</source>
          <target state="translated">最後に照合された文字を後読みして、英数字だった場合は照合を継続します。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</source>
          <target state="translated">英数字は、ピリオド、ハイフン、およびすべての単語文字から成るセットのサブセットです。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Match an at sign ("@").</source>
          <target state="translated">アット マーク ("@") に一致します。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Lookahead assertions</source>
          <target state="translated">先読みアサーション</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>.NET includes two language elements, <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> and <bpt id="p4">**</bpt>(?!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept>, that match the next character or characters in the input string.</source>
          <target state="translated">.NET には、入力文字列の次の文字と一致する 2 つの言語要素 <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> と <bpt id="p4">**</bpt>(?!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> が含まれています。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, without advancing or backtracking.</source>
          <target state="translated">これらの言語要素は、どちらもゼロ幅アサーションです。つまり、現在の文字の直後にある文字が <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> に一致するかどうかを、前進もバックトラッキングもせずに確認します。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a positive lookahead assertion; that is, the character or characters after the current position must match <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> は肯定先読みアサーションで、現在の位置の後にある文字が <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept> に一致する必要があります。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a negative lookahead assertion; that is, the character or characters after the current position must not match <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> は否定先読みアサーションで、現在の位置の後にある文字が <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept> に一致しない必要があります。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Both positive and negative lookahead assertions are most useful when <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is a subset of the next <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>.</source>
          <target state="translated">肯定と否定のどちらの先読みアサーションも、<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> が次の <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> のサブセットである場合に特に役立ちます。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</source>
          <target state="translated">次の例では、完全修飾型名を検証する 2 つの同等の正規表現パターンが使用されています。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The first pattern is subject to poor performance because of excessive backtracking.</source>
          <target state="translated">1 つ目のパターンでは、過度なバックトラッキングのためにパフォーマンスが低下します。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</source>
          <target state="translated">2 つ目のパターンでは、1 つ目の正規表現に変更を加えて、入れ子になった量指定子を肯定先読みアサーションに置き換えています。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The output from the example displays the execution time of the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method.</source>
          <target state="translated">この例の出力には、<bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> メソッドの実行時間が表示されます。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The first regular expression pattern, <ph id="ph1">`^(([A-Z]\w*)+\.)*[A-Z]\w*$`</ph>, is defined as shown in the following table.</source>
          <target state="translated">最初の正規表現パターン <ph id="ph1">`^(([A-Z]\w*)+\.)*[A-Z]\w*$`</ph> は、次の表に示すように定義されています。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">パターン</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
          <target state="translated">文字列の先頭から照合を開始します。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</source>
          <target state="translated">1 個の英文字 (A-Z) の後に 0 個以上の単語文字が続くパターンの 1 回以上の繰り返しの後にピリオドが続くパターンに一致します。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option.</source>
          <target state="translated"><bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> メソッドが <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> オプションを使用して呼び出されているため、この比較では大文字と小文字が区別されません。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Match the previous pattern zero or more times.</source>
          <target state="translated">前のパターンの 0 回以上の繰り返しに一致します。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Match an alphabetical character followed by zero or more word characters.</source>
          <target state="translated">1 個の英文字の後に 0 個以上の単語文字が続くパターンに一致します。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>End the match at the end of the input string.</source>
          <target state="translated">入力文字列の末尾で照合を終了します。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The second regular expression pattern, <ph id="ph1">`^((?=[A-Z])\w+\.)*[A-Z]\w*$`</ph>, uses a positive lookahead assertion.</source>
          <target state="translated">2 つ目の正規表現パターン <ph id="ph1">`^((?=[A-Z])\w+\.)*[A-Z]\w*$`</ph> では、肯定先読みアサーションが使用されています。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
          <target state="translated">このパターンは、次の表に示すように定義されています。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">パターン</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
          <target state="translated">文字列の先頭から照合を開始します。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Look ahead to the first character and continue the match if it is alphabetical (A-Z).</source>
          <target state="translated">先頭の文字を先読みして、英文字 (A-Z) だった場合は照合を継続します。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option.</source>
          <target state="translated"><bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> メソッドが <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> オプションを使用して呼び出されているため、この比較では大文字と小文字が区別されません。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a period.</source>
          <target state="translated">1 個以上の単語文字の後にピリオドが続くパターンに一致します。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters followed by a period zero or more times.</source>
          <target state="translated">1 個以上の単語文字の後にピリオドが続くパターンの 0 回以上の繰り返しと一致します。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The initial word character must be alphabetical.</source>
          <target state="translated">最初の単語文字は英文字でなければなりません。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Match an alphabetical character followed by zero or more word characters.</source>
          <target state="translated">1 個の英文字の後に 0 個以上の単語文字が続くパターンに一致します。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>End the match at the end of the input string.</source>
          <target state="translated">入力文字列の末尾で照合を終了します。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">関連項目</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET regular expressions<ept id="p1">](regular-expressions.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>.NET 正規表現<ept id="p1">](regular-expressions.md)</ept></target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>正規表現言語 - クイック リファレンス<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Quantifiers in regular expressions<ept id="p1">](quantifiers.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>正規表現での量指定子<ept id="p1">](quantifiers.md)</ept></target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Alternation constructs in regular expressions<ept id="p1">](alternation.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>正規表現での代替構成体<ept id="p1">](alternation.md)</ept></target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>正規表現でのグループ化構成体<ept id="p1">](grouping.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>