<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0c73fb0a12092877ff5b54221f4a80693d1d1152</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\exceptions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4039eb59d735cb586da4b617c06c78c4c56de430</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9296088cb345ca8e749cc7c98a39bacca0772227</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Handling and throwing exceptions in .NET</source>
          <target state="translated">.NET での例外の処理とスロー</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Understand how to use exceptions in .NET</source>
          <target state="translated">.NET で例外を使用する方法を理解する</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Handling and throwing exceptions in .NET</source>
          <target state="translated">.NET での例外の処理とスロー</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Applications must be able to handle errors that occur during execution in a consistent manner.</source>
          <target state="translated">アプリケーションは、実行中に発生するエラーを一貫した方法で処理できなければなりません。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>.NET provides a model for notifying applications of errors in a uniform way: .NET operations indicate failure by throwing exceptions.</source>
          <target state="translated">.NET では、一貫した方法でアプリケーションにエラーを通知するためのモデルが用意されています。 .NET 操作では、例外をスローすることによって障害の発生を示します。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">例外</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>An exception is any error condition or unexpected behavior that is encountered by an executing program.</source>
          <target state="translated">例外とは、プログラムを実行することによって発生するエラー状態または予期しない動作のことです。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Exceptions can be thrown because of a fault in your code or in code that you call (such as a shared library), unavailable operating system resources, unexpected conditions that the runtime encounters (such as code that cannot be verified), and so on.</source>
          <target state="translated">例外がスローされる原因として、コードまたは呼び出したコード (たとえば共有ライブラリ) 内に障害がある、オペレーティング システム リソースを使用できない、予期しない状態 (たとえば検証できないコード) をランタイムが検出したなどがあります。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Your application can recover from some of these conditions, but not from others.</source>
          <target state="translated">アプリケーションは、他の状態からではなく、これらの状態のうちのいくつかから回復できます。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Although you can recover from most application exceptions, you cannot recover from most runtime exceptions.</source>
          <target state="translated">ほとんどのアプリケーション例外から回復できますが、ほとんどのランタイム例外からは回復できません。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In .NET, an exception is an object that inherits from the <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept> class.</source>
          <target state="translated">.NET では、例外は <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept> クラスから継承されるオブジェクトです。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>An exception is thrown from an area of code where a problem has occurred.</source>
          <target state="translated">例外は問題が発生したコード領域からスローされます。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The exception is passed up the stack until the application handles it or the program terminates.</source>
          <target state="translated">例外は、アプリケーションが処理するかプログラムが終了するまで、スタックに渡されます。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Exceptions vs. traditional error-handling methods</source>
          <target state="translated">例外と従来のエラー処理メソッド</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Traditionally, a language's error-handling model relied on either the language's unique way of detecting errors and locating handlers for them, or on the error-handling mechanism provided by the operating system.</source>
          <target state="translated">言語のエラー処理モデルは従来、エラーを検出してそれに対応したハンドラーを見つける言語固有の方法か、オペレーティング システムが備えているエラー処理機構のいずれかを使用していました。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The way .NET implements exception handling provides the following advantages:</source>
          <target state="translated">.NET が例外処理を実装する方法は、次の利点をもたらします。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Exception throwing and handling works the same for .NET programming languages.</source>
          <target state="translated">例外のスローと処理は、.NET プログラミング言語では同じように機能します。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Does not require any particular language syntax for handling exceptions, but allows each language to define its own syntax.</source>
          <target state="translated">例外を処理するための特定の言語構文を必要とせず、各言語が独自の構文を定義できます。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Exceptions can be thrown across process and even machine boundaries.</source>
          <target state="translated">例外は、プロセス間、さらにはコンピューターの境界を越えてスローできます。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Exception-handling code can be added to an application to increase program reliability.</source>
          <target state="translated">プログラムの信頼性を高めるための例外処理コードをアプリケーションに追加できます。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Exceptions offer advantages over other methods of error notification, such as return codes.</source>
          <target state="translated">例外には、リターン コードなどの他のエラー通知メソッドに優る利点があります。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Failures do not go unnoticed because if an exception is thrown and you don't handle it, the runtime terminates your application.</source>
          <target state="translated">例外がスローされ、それを処理しないと、ランタイムによってアプリケーションが終了されるため、エラーが見過ごされることはありません。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Invalid values do not continue to propagate through the system as a result of code that fails to check for a failure return code.</source>
          <target state="translated">無効な値は、エラーのリターン コードの確認に失敗したコードの結果として、システムを経由した伝達を続行しません。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Exception class and properties</source>
          <target state="translated">Exception クラスとプロパティ</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">@System.Exception</ph> class is the base class from which exceptions inherit.</source>
          <target state="translated"><ph id="ph1">@System.Exception</ph> クラスは、例外の継承元となる基底クラスです。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">@System.InvalidCastException</ph> class hierarchy is as follows:</source>
          <target state="translated">たとえば、<ph id="ph1">@System.InvalidCastException</ph> クラスの階層は次のようになります。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">@System.Exception</ph> class has the following properties that help make understanding an exception easier.</source>
          <target state="translated"><ph id="ph1">@System.Exception</ph> クラスには、簡単に例外を理解することに役立つ次のプロパティがあります。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Property Name</source>
          <target state="translated">プロパティ名</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">@System.Collections.IDictionary</ph> that holds arbitrary data in key-value pairs.</source>
          <target state="translated">キーと値のペアの任意のデータを保持する <ph id="ph1">@System.Collections.IDictionary</ph> です。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Can hold a URL (or URN) to a help file that provides extensive information about the cause of an exception.</source>
          <target state="translated">例外の原因に関する詳細情報を提供するヘルプ ファイルには、URL (または URN) を保持できます。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>This property can be used to create and preserve a series of exceptions during exception handling.</source>
          <target state="translated">このプロパティを使用すると、例外処理中に一連の例外を作成して保持することができます。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You can use it to create a new exception that contains previously caught exceptions.</source>
          <target state="translated">既にキャッチされた例外を含む新しい例外を作成するのにも使用できます。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The original exception can be captured by the second exception in the <ph id="ph1">@System.Exception.InnerException</ph> property, allowing code that handles the second exception to examine the additional information.</source>
          <target state="translated"><ph id="ph1">@System.Exception.InnerException</ph> プロパティの 2 つ目の例外によって、元の例外をキャプチャできます。これにより、2 つ目の例外を処理するコードが追加の情報を調べることができます。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a method that receives an argument that's improperly formatted.</source>
          <target state="translated">たとえば、形式が正しくない引数を受け取るメソッドがあるとします。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The code tries to read the argument, but an exception is thrown.</source>
          <target state="translated">コードは、引数の読み取りを試みますが、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The method catches the exception and throws a <ph id="ph1">@System.FormatException.</ph> To improve the caller's ability to determine the reason an exception is thrown, it is sometimes desirable for a method to catch an exception thrown by a helper routine and then throw an exception more indicative of the error that has occurred.</source>
          <target state="translated">このメソッドは例外をキャッチし､<ph id="ph1">@System.FormatException.</ph> をスローします。例外がスローされた原因を判断するための呼び出し元の機能を向上させるには、ヘルパー ルーチンによってスローされた例外をキャッチし、発生したエラーの内容を示す例外をスローするメソッドが望ましい場合があります。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A new and more meaningful exception can be created, where the inner exception reference can be set to the original exception.</source>
          <target state="translated">内部例外の参照を元の例外に設定できる、新しいより意味のある例外を作成できます。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This more meaningful exception can then be thrown to the caller.</source>
          <target state="translated">この意味のある例外は、呼び出し元にスローすることができます。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Note that with this functionality, you can create a series of linked exceptions that ends with the exception that was thrown first.</source>
          <target state="translated">この機能により、最初にスローされた例外で終了する一連のリンクされた例外を作成することができます。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Provides details about the cause of an exception.</source>
          <target state="translated">例外の原因に関する詳細を提供します。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of the application or the object that causes the error.</source>
          <target state="translated">エラーの原因となるアプリケーションまたはオブジェクトの名前を取得または設定します。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Contains a stack trace that can be used to determine where an error occurred.</source>
          <target state="translated">エラーが発生した場所を判断するために使用できるスタック トレースが含まれています。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The stack trace includes the source file name and program line number if debugging information is available.</source>
          <target state="translated">デバッグ情報が使用できる場合には、スタック トレースにソース ファイル名とプログラム行番号が記述されます。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Most of the classes that inherit from <ph id="ph1">@System.Exception</ph> do not implement additional members or provide additional functionality; they simply inherit from <ph id="ph2">@System.Exception.</ph> Therefore, the most important information for an exception can be found in the hierarchy of exception classes, the exception name, and the information contained in the exception.</source>
          <target state="translated"><ph id="ph1">@System.Exception</ph> から継承したクラスのほとんどは追加メンバーを実装したり追加機能を提供したりしません。単に <ph id="ph2">@System.Exception.</ph> から継承するのみです。したがって、例外の最も重要な情報は例外クラス、例外の名前と例外に含まれる情報の階層で検出されます。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>It is recommended to throw and catch only objects that derive from <ph id="ph1">@System.Exception,</ph> but you can throw any object that derives from the <ph id="ph2">@System.Object</ph> class as an exception.</source>
          <target state="translated"><ph id="ph1">@System.Exception,</ph> から派生したオブジェクトだけをスローおよびキャッチすることをお勧めしますが、<ph id="ph2">@System.Object</ph> クラスから派生したオブジェクトはすべて例外としてスローすることができます。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Note that not all languages support throwing and catching objects that do not derive from <ph id="ph1">@System.Exception.</ph></source>
          <target state="translated"><ph id="ph1">@System.Exception.</ph> から派生していないオブジェクトのスローとキャッチは、すべての言語ではサポートされていないことに注意してください。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Common Exceptions</source>
          <target state="translated">一般的な例外</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The following table lists some common exceptions with examples of what can cause them.</source>
          <target state="translated">次の表は、一般的な例外とそれらの原因の例をいくつか示しています。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Exception type</source>
          <target state="translated">例外の種類</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Base type</source>
          <target state="translated">基本型</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">例</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Base class for all exceptions.</source>
          <target state="translated">すべての例外の基底クラスです。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>None (use a derived class of this exception).</source>
          <target state="translated">なし (この例外の派生クラスを使用)。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Thrown by the runtime only when an array is indexed improperly.</source>
          <target state="translated">配列のインデックスが誤っている場合にのみ、ランタイムによってスローされます。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Indexing an array outside its valid range: <ph id="ph1">`arr[arr.Length+1]`</ph></source>
          <target state="translated">次のように、配列に対して配列の有効範囲外のインデックスを付けた場合。<ph id="ph1">`arr[arr.Length+1]`</ph></target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Thrown by the runtime only when a null object is referenced.</source>
          <target state="translated">null オブジェクトが参照された場合にのみ、ランタイムによってスローされます。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Thrown by methods when in an invalid state.</source>
          <target state="translated">無効な状態の場合にメソッドによってスローされます。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Calling <ph id="ph1">`Enumerator.GetNext()`</ph> after removing an Item from the underlying collection.</source>
          <target state="translated">基になるコレクションからアイテムを削除した後での、<ph id="ph1">`Enumerator.GetNext()`</ph> の呼び出しです。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Base class for all argument exceptions.</source>
          <target state="translated">すべての引数の例外の基底クラスです。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>None (use a derived class of this exception).</source>
          <target state="translated">なし (この例外の派生クラスを使用)。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Thrown by methods that do not allow an argument to be null.</source>
          <target state="translated">null の引数を許可しないメソッドによってスローされます。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Thrown by methods that verify that arguments are in a given range.</source>
          <target state="translated">引数が特定の範囲内にあることを検査するメソッドによってスローされます。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>How to use the try/catch block to catch exceptions</source>
          <target state="translated">Try ブロックと Catch ブロックを使用して例外をキャッチする方法</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Place the sections of code that might throw exceptions in a <ph id="ph1">`try`</ph> block and place code that handles exceptions in a <ph id="ph2">`catch`</ph> block.</source>
          <target state="translated">例外をスローする可能性のあるコードのセクションを <ph id="ph1">`try`</ph> ブロックに配置し、例外を処理するコードを <ph id="ph2">`catch`</ph> ブロックに配置します。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`catch`</ph> block is a series of statements beginning with the keyword <ph id="ph2">`catch`</ph>, followed by an exception type and an action to be taken.</source>
          <target state="translated"><ph id="ph1">`catch`</ph> ブロックは、キーワード <ph id="ph2">`catch`</ph> で始まり、その後に例外の種類と実行するアクションが続く一連のステートメントです。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The following code example uses a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block to catch a possible exception.</source>
          <target state="translated">次のコード例では、<ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> ブロックを使用して可能性のある例外をキャッチします。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Main`</ph> method contains a <ph id="ph2">`try`</ph> block with a <ph id="ph3">@System.IO.StreamReader</ph> statement that opens a data file called <ph id="ph4">`data.txt`</ph> and writes a string from the file.</source>
          <target state="translated"><ph id="ph1">`Main`</ph> メソッドには、<ph id="ph2">`try`</ph> ブロックと、<ph id="ph4">`data.txt`</ph> と呼ばれるデータ ファイルを開き、ファイルから文字列を書き込む <ph id="ph3">@System.IO.StreamReader</ph> ステートメントが含まれます。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Following the <ph id="ph1">`try`</ph> block is a <ph id="ph2">`catch`</ph> block that catches any exception that results from the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">次の <ph id="ph1">`try`</ph> ブロックは、<ph id="ph3">`try`</ph> によって生成される任意の例外をキャッチする <ph id="ph2">`catch`</ph> ブロックです。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The common language runtime catches exceptions that are not caught by a catch block.</source>
          <target state="translated">共通言語ランタイムは、catch ブロックでキャッチされなかった例外をキャッチします。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Depending on how the runtime is configured, a debug dialog box appears, or the program stops executing and a dialog box with exception information appears, or an error is printed out to STDERR.</source>
          <target state="translated">ランタイムの構成方法に応じて、デバッグ ダイアログ ボックスが表示されるか、プログラムの実行が停止され、例外情報を含むダイアログ ボックスが表示されるか、または STDERR にエラーが出力されます。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Almost any line of code can cause an exception, particularly exceptions that are thrown by the common language runtime itself, such as <ph id="ph1">@System.OutOfMemoryException.</ph> Most applications don't have to deal with these exceptions, but you should be aware of this possibility when writing libraries to be used by others.</source>
          <target state="translated">ほぼすべてのコード行で、特に <ph id="ph1">@System.OutOfMemoryException.</ph> などのように共通言語ランタイム自体によってスローされるなどの例外が発生することがあります。ほとんどのアプリケーションではこれらの例外に対処する必要はありませんが、他のユーザーが使用するライブラリ書き込むとき、この可能性があることに注意してください。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For suggestions on when to set code in a Try block, see <bpt id="p1">[</bpt>Best Practices for Exceptions<ept id="p1">](#best-practices-for-exceptions)</ept>.</source>
          <target state="translated">Try ブロック内でコードを設定するタイミングに関しては、「<bpt id="p1">[</bpt>例外の推奨事項<ept id="p1">](#best-practices-for-exceptions)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>How to use specific exceptions in a Catch block</source>
          <target state="translated">catch ブロックで特定の例外を使用する方法</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The preceding code example illustrates a basic <ph id="ph1">`catch`</ph> statement that catches any exception.</source>
          <target state="translated">上記のコード例は、任意の例外をキャッチする基本的な <ph id="ph1">`catch`</ph> ステートメントを示しています。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>In general, though, it's good programming practice to catch a specific type of exception rather than use a basic <ph id="ph1">`catch`</ph> statement.</source>
          <target state="translated">ただし、一般的には、基本的な <ph id="ph1">`catch`</ph> ステートメントを使用するよりも、特定の種類の例外をキャッチするプログラミング手法を勧めします。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>When an exception occurs, it is passed up the stack and each catch block is given the opportunity to handle it.</source>
          <target state="translated">例外が発生すると、スタックに渡され、各 catch ブロックが処理する機会を与えられます。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The order of catch statements is important.</source>
          <target state="translated">catch ステートメントの順序が重要です。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Put catch blocks targeted to specific exceptions before a general exception catch block or the compiler might issue an error.</source>
          <target state="translated">一般的な例外 catch ブロックまたはコンパイラがエラーを発行する前に、特定の例外を対象とした catch ブロックを配置します。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The proper catch block is determined by matching the type of the exception to the name of the exception specified in the catch block.</source>
          <target state="translated">適切な catch ブロックは、例外の種類を catch ブロックで指定された例外の名前に一致させることで決まります。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If there is no specific catch block, the exception is caught by a general catch block, if one exists.</source>
          <target state="translated">特定の catch ブロックがない場合は、汎用 catch ブロック (ある場合) によってキャッチされます。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The following code example uses a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block to catch an <ph id="ph4">@System.InvalidCastException.</ph> The sample creates a class called <ph id="ph5">`Employee`</ph> with a single property, employee level (<ph id="ph6">`Emlevel`</ph>).</source>
          <target state="translated">次のコード例では、<ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> ブロックを使用して <ph id="ph4">@System.InvalidCastException.</ph> をキャッチします。このサンプルは単一プロパティ、従業員レベル (<ph id="ph6">`Emlevel`</ph>) で <ph id="ph5">`Employee`</ph> というクラスを作成します。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A method, <ph id="ph1">`PromoteEmployee`</ph>, takes an object and increments the employee level.</source>
          <target state="translated">メソッド <ph id="ph1">`PromoteEmployee`</ph> は、オブジェクトを受け取って、従業員レベルをインクリメントします。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">@System.InvalidCastException</ph> occurs when a <ph id="ph2">@System.DateTime</ph> instance is passed to the <ph id="ph3">`PromoteEmployee`</ph> method.</source>
          <target state="translated"><ph id="ph2">@System.DateTime</ph> インスタンスが <ph id="ph3">`PromoteEmployee`</ph> メソッドに渡されたとき、<ph id="ph1">@System.InvalidCastException</ph> が発生します。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>How to use finally blocks</source>
          <target state="translated">finally ブロックを使用する方法</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>When an exception occurs, execution stops and control is given to the appropriate exception handler.</source>
          <target state="translated">例外が発生すると、実行が停止され、コントロールが適切な例外ハンドラーに付与されます。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>This often means that lines of code you expect to be executed are bypassed.</source>
          <target state="translated">これは、多くの場合、実行されるはずのコード行がバイパスされることを意味します。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Some resource cleanup, such as closing a file, needs to be done even if an exception is thrown.</source>
          <target state="translated">ファイルを閉じるなどのいくつかのリソースのクリーンアップは、例外がスローされた場合でも実行する必要があります。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>To do this, you can use a <ph id="ph1">`finally`</ph> block.</source>
          <target state="translated">これを行うために、<ph id="ph1">`finally`</ph> ブロックを使用することができます。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`finally`</ph> block always executes, regardless of whether an exception is thrown.</source>
          <target state="translated"><ph id="ph1">`finally`</ph> ブロックは、例外がスローされるかどうかに関係なく、常に実行されます。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The following code example uses a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block to catch an <ph id="ph4">@System.ArgumentOutOfRangeException.</ph> The <ph id="ph5">`Main`</ph> method creates two arrays and attempts to copy one to the other.</source>
          <target state="translated">次のコード例では、<ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> ブロックを使用して <ph id="ph4">@System.ArgumentOutOfRangeException.</ph> をキャッチします。<ph id="ph5">`Main`</ph> の方法は 2 つの配列を作成し、　片方をもう一方にコピーしようと試みます。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The action generates an <ph id="ph1">@System.ArgumentOutOfRangeException</ph> and the error is written to the console.</source>
          <target state="translated">アクションが、<ph id="ph1">@System.ArgumentOutOfRangeException</ph> を生成し、エラーは、コンソールに書き込まれます。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`finally`</ph> block executes regardless of the outcome of the copy action.</source>
          <target state="translated"><ph id="ph1">`finally`</ph> ブロックは、コピー操作の結果に関係なく実行されます。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>How to explicitly throw exceptions</source>
          <target state="translated">例外を明示的にスローする方法</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can explicitly throw an exception using the <ph id="ph1">`throw`</ph> statement.</source>
          <target state="translated"><ph id="ph1">`throw`</ph> ステートメントを使用して、例外を明示的にスローできます。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>You can also throw a caught exception again using the <ph id="ph1">`throw`</ph> statement.</source>
          <target state="translated"><ph id="ph1">`throw`</ph> ステートメントを使って、キャッチした例外をもう一度スローすることもできます。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>It is good coding practice to add information to an exception that is re-thrown to provide more information when debugging.</source>
          <target state="translated">再スローされる例外に情報を追加して、デバッグ時により多くの情報を提供するコーディング手法をお勧めします。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The following code example uses a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block to catch a possible <ph id="ph4">@System.IO.FileNotFoundException.</ph> Following the <ph id="ph5">`try`</ph> block is a <ph id="ph6">`catch`</ph> block that catches the <ph id="ph7">@System.IO.FileNotFoundException</ph> and writes a message to the console if the data file is not found.</source>
          <target state="translated">次のコード例は <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> ブロックを使い、<ph id="ph4">@System.IO.FileNotFoundException.</ph> だと思われるものをキャッチします。次の <ph id="ph5">`try`</ph> ブロックは、<ph id="ph7">@System.IO.FileNotFoundException</ph> をキャッチし、データ ファイルが見つからない場合に、メッセージをコンソールに出力する <ph id="ph6">`catch`</ph> ブロックです。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The next statement is the <ph id="ph1">`throw`</ph> statement that throws a new <ph id="ph2">@System.IO.FileNotFoundException</ph> and adds text information to the exception.</source>
          <target state="translated">次のステートメントは、新しい <ph id="ph2">@System.IO.FileNotFoundException</ph> をスローして、テキスト情報を例外に追加する <ph id="ph1">`throw`</ph> ステートメントです。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>How to create user-defined exceptions</source>
          <target state="translated">ユーザー定義の例外を作成する方法</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>.NET provides a hierarchy of exception classes ultimately derived from the base class <ph id="ph1">@System.Exception.</ph> However, if none of the predefined exceptions meets your needs, you can create your own exception classes by deriving from the <ph id="ph2">@System.Exception</ph> class.</source>
          <target state="translated">.NET 基本クラス <ph id="ph1">@System.Exception.</ph> から最終的に派生した例外クラスの階層構造を提供します。ただし、定義済みの例外のいずれも要件を満たさない場合は、<ph id="ph2">@System.Exception</ph> クラスから派生することによって、独自の例外クラスを作成できます。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>When creating your own exceptions, end the class name of the user-defined exception with the word "Exception," and implement the three common constructors, as shown in the following example.</source>
          <target state="translated">独自の例外を作成するときに、ユーザー定義の例外のクラス名の末尾に "Exception" という単語を付加し、次の例で示すように、3 つの共通コンストラクターを実装します。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The example defines a new exception class named <ph id="ph1">`EmployeeListNotFoundException`</ph>.</source>
          <target state="translated">例では、<ph id="ph1">`EmployeeListNotFoundException`</ph> という名前の新しい例外クラスを定義します。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The class is derived from <ph id="ph1">@System.Exception</ph> and includes three constructors.</source>
          <target state="translated">このクラスは <ph id="ph1">@System.Exception</ph> から派生し、次の 3 つのコンストラクターが含まれています。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In situations where you are using remoting, you must ensure that the metadata for any user-defined exceptions is available at the server (callee) and to the client (the proxy object or caller).</source>
          <target state="translated">リモート処理を使用している場合は、任意のユーザー定義の例外のメタデータがサーバー側 (呼び出し先) とクライアント (プロキシ オブジェクトまたは呼び出し元) で使用できることを保証する必要があります。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Best practices for exceptions<ept id="p1">](#best-practices-for-exceptions)</ept>.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>例外の推奨事項<ept id="p1">](#best-practices-for-exceptions)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Best practices for exceptions</source>
          <target state="translated">例外の推奨事項</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>A well-designed app handles exceptions and errors to prevent app crashes.</source>
          <target state="translated">適切にデザインされたアプリケーションは、アプリケーションのクラッシュを防ぐために、例外やエラーを処理します。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This section describes best practices for handling and creating exceptions.</source>
          <target state="translated">このセクションでは、例外の処理と作成のためのベスト プラクティスについて説明します。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Use try/catch/finally blocks</source>
          <target state="translated">try/catch/finally ブロックを使用する</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph><ph id="ph4">/</ph><ph id="ph5">`finally`</ph> blocks around code that can potentially generate an exception.</source>
          <target state="translated"><ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph><ph id="ph4">/</ph><ph id="ph5">`finally`</ph> ブロックを使用して、例外を生成する可能性のあるコードを囲みます。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">`catch`</ph> blocks, always order exceptions from the most specific to the least specific.</source>
          <target state="translated"><ph id="ph1">`catch`</ph> ブロックでは、常に特定の例外から一般的な例外の順に例外を配置します。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Use a <ph id="ph1">`finally`</ph> block to clean up resources, whether you can recover or not.</source>
          <target state="translated">回復できるかどうかに関わらず、<ph id="ph1">`finally`</ph> ブロックを使用してリソースをクリーンアップします。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Handle common conditions without throwing exceptions</source>
          <target state="translated">例外をスローせずに一般的な状態を処理する</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For conditions that are likely to occur but might trigger an exception, consider handling them in a way that will avoid the exception.</source>
          <target state="translated">発生する可能性があり、例外をトリガーする可能性がある状態に対し、例外を回避する方法で処理することを検討します。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For example, if you try to close a connection that is already closed, you'll get an <ph id="ph1">`InvalidOperationException`</ph>.</source>
          <target state="translated">たとえば、既に終了している接続を終了しようとすると、<ph id="ph1">`InvalidOperationException`</ph> を受け取ります。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>You can avoid that by using an <ph id="ph1">`if`</ph> statement to check the connection state before trying to close it.</source>
          <target state="translated"><ph id="ph1">`if`</ph> ステートメントを使用して、終了しようとする前に接続状態を確認することで、これを回避することができます。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>If you don't check connection state before closing, you can catch the <ph id="ph1">`InvalidOperationException`</ph> exception.</source>
          <target state="translated">終了する前に接続状態を確認しない場合は、<ph id="ph1">`InvalidOperationException`</ph> 例外をキャッチする可能性があります。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The method to choose depends on how often you expect the event to occur.</source>
          <target state="translated">選択するメソッドは、予期されるイベント発生頻度によって決まります。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Use exception handling if the event doesn't occur very often, that is, if the event is truly exceptional and indicates an error (such as an unexpected end-of-file).</source>
          <target state="translated">イベントが頻繁には発生しない場合、つまり、イベントが本当に例外的であり、エラー (予期しないファイルの終端の検出など) を示す場合に、例外処理を使用します。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>When you use exception handling, less code is executed in normal conditions.</source>
          <target state="translated">例外処理を使用すると、通常の状況では、実行されるコードが少なくなります。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Check for error conditions in code if the event happens routinely and could be considered part of normal execution.</source>
          <target state="translated">イベントが定期的に発生し、通常の実行の一部であると見なせる場合は、コード内でエラー条件をチェックします。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>When you check for common error conditions, less code is executed because you avoid exceptions.</source>
          <target state="translated">一般的なエラー条件をチェックするときに、例外を回避するためにより少ないコードが実行されます。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Design classes so that exceptions can be avoided</source>
          <target state="translated">例外を回避するようにクラスを設計する</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>A class can provide methods or properties that enable you to avoid making a call that would trigger an exception.</source>
          <target state="translated">クラスは、例外をトリガーする呼び出しを行うことを回避できるようにするメソッドとプロパティを提供できます。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>For example, a <ph id="ph1">@System.IO.FileStream</ph> class provides methods that help determine whether the end of the file has been reached.</source>
          <target state="translated">たとえば、<ph id="ph1">@System.IO.FileStream</ph> クラスには、ファイルの終端に到達したかどうかを判別するために役立つメソッドが用意されています。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>These can be used to avoid the exception that is thrown if you read past the end of the file.</source>
          <target state="translated">これらは、ファイルの終端を越えて読み取りを実行しようとした場合にも例外がスローされないようにするために使用できます。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The following example shows how to read to the end of a file without triggering an exception.</source>
          <target state="translated">次の例では、例外をトリガーすることなく、ファイルの末尾まで読み取る方法を示します。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Another way to avoid exceptions is to return null for extremely common error cases instead of throwing an exception.</source>
          <target state="translated">例外が返されるのを回避するもう 1 つの方法は、非常に一般的なエラーの場合に、例外をスローする代わりに null を返すことです。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>An extremely common error case can be considered normal flow of control.</source>
          <target state="translated">非常に一般的なエラーは、通常の制御の流れと見なすことができます。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>By returning null in these cases, you minimize the performance impact to an app.</source>
          <target state="translated">このような場合は、null を返すことによって、アプリケーションのパフォーマンスへの影響を最小限に抑えることができます。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Throw exceptions instead of returning an error code</source>
          <target state="translated">エラー コードを返す代わりに、例外をスローする</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Exceptions ensure that failures do not go unnoticed because calling code didn't check a return code.</source>
          <target state="translated">呼び出しのコードはリターン コードを確認しないので、例外によって、エラーを見過ごさないようにします。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Use the predefined .NET exception types</source>
          <target state="translated">事前定義済みの .NET の例外の種類を使用する</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Introduce a new exception class only when a predefined one doesn't apply.</source>
          <target state="translated">事前定義の例外クラスが適用されない場合に限り、新しい例外クラスを導入します。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">次に例を示します。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Throw an <ph id="ph1">@System.InvalidOperationException</ph> exception if a property set or method call is not appropriate given the object's current state.</source>
          <target state="translated">オブジェクトの現在の状態に対して、プロパティの設定またはメソッドの呼び出しが適切でない場合は、<ph id="ph1">@System.InvalidOperationException</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Throw an <ph id="ph1">@System.ArgumentException</ph> exception or one of the predefined classes that derive from <ph id="ph2">@System.ArgumentException</ph> if invalid parameters are passed.</source>
          <target state="translated"><ph id="ph1">@System.ArgumentException</ph> 例外または <ph id="ph2">@System.ArgumentException</ph> から派生する定義済みのクラスの 1 つをスローします。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>End exception class names with the word <ph id="ph1">`Exception`</ph></source>
          <target state="translated">例外クラス名の末尾に <ph id="ph1">`Exception`</ph> という単語を付加する</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>When a custom exception is necessary, name it appropriately and derive it from the <ph id="ph1">@System.Exception</ph> class.</source>
          <target state="translated">カスタム例外が必要な場合は、適切に名前を付け、<ph id="ph1">@System.Exception</ph> クラスから派生させます。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">次に例を示します。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Include three constructors in custom exception classes</source>
          <target state="translated">カスタム例外クラスに 3 つのコンストラクターを含める</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Use at least the three common constructors when creating your own exception classes: the default constructor, a constructor that takes a string message, and a constructor that takes a string message and an inner exception.</source>
          <target state="translated">独自の例外クラスを作成するときに、少なくとも 3 つの共通コンストラクターを使用します。それらは、既定のコンストラクター、文字列メッセージを受け取るコンストラクター、および文字列メッセージと内部例外を受け取るコンストラクターです。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Exception.%23ctor,</ph> which uses default values.</source>
          <target state="translated">既定の値を使用する <ph id="ph1">@System.Exception.%23ctor,</ph>。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Exception.%23ctor(System.String),</ph> which accepts a string message.</source>
          <target state="translated">文字列メッセージを受け取る <ph id="ph1">@System.Exception.%23ctor(System.String),</ph>。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Exception.%23ctor(System.String,System.Exception),</ph> which accepts a string message and an inner exception.</source>
          <target state="translated">文字列メッセージと内部例外を受け取る <ph id="ph1">@System.Exception.%23ctor(System.String,System.Exception),</ph>。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>For an example, see <bpt id="p1">[</bpt>How to: Create User-Defined Exceptions<ept id="p1">](#how-to-create-user-defined-exceptions)</ept>.</source>
          <target state="translated">例については、「<bpt id="p1">[</bpt>方法: ユーザー定義の例外を作成する<ept id="p1">](#how-to-create-user-defined-exceptions)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Ensure that exception data is available when code executes remotely</source>
          <target state="translated">コードがリモートで実行されるときに、例外データが利用できるようにする</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>When you create user-defined exceptions, ensure that the metadata for the exceptions is available to code that is executing remotely.</source>
          <target state="translated">ユーザー定義例外を作成するときには、リモートで実行されるコードで例外のメタデータを使用できるようにします。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example, on .NET runtimes that implement App Domains, exceptions may occur across App domains.</source>
          <target state="translated">たとえば、アプリ ドメインを実装する .NET ランタイムでは、アプリ ドメイン間で例外が発生する可能性があります。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Suppose App Domain A creates App Domain B, which executes code that throws an exception.</source>
          <target state="translated">アプリ ドメイン A が、例外をスローするコードを実行するアプリ ドメイン B を作成するとします。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>For App Domain A to properly catch and handle the exception, it must be able to find the assembly that contains the exception thrown by App Domain B. If App Domain B throws an exception that is contained in an assembly under its application base, but not under App Domain A's application base, App Domain A will not be able to find the exception, and the common language runtime will throw a <ph id="ph1">@System.IO.FileNotFoundException</ph> exception.</source>
          <target state="translated">アプリ ドメイン A が例外を適切にキャッチして処理するには、アプリ ドメイン B によりスローされた例外が含まれているアセンブリを検出できる必要があります。アプリ ドメイン B が、アプリ ドメイン A のアプリケーション ベースではなく、自身のアプリケーション ベースの下のアセンブリに含まれている例外をスローする場合、アプリ ドメイン A は、例外を検出できなくなり、共通言語ランタイムが <ph id="ph1">@System.IO.FileNotFoundException</ph> 例外をスローします。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>To avoid this situation, you can deploy the assembly that contains the exception information in two ways:</source>
          <target state="translated">このような状況を回避するには、例外情報が格納されているアセンブリを次のいずれかの方法で配置します。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Put the assembly into a common application base shared by both app domains.</source>
          <target state="translated">2 つのアプリ ドメインが共有する共通アプリケーション ベースにアセンブリを配置する。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> または</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>If the domains do not share a common application base, sign the assembly that contains the exception information with a strong name and deploy the assembly into the global assembly cache.</source>
          <target state="translated">ドメインが共通アプリケーション ベースを共有していない場合には、例外情報が格納されているアセンブリに厳密な名前で署名し、グローバル アセンブリ キャッシュにこのアセンブリを配置する。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Include a localized description string in every exception</source>
          <target state="translated">すべての例外に、ローカライズした説明文字列を含める</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The error message that the user sees is derived from the description string of the exception that was thrown, and not from the name of the exception class.</source>
          <target state="translated">ユーザーに対して表示されるエラー メッセージは、例外クラスの名前ではなく、スローされた例外の説明文字列から派生されます。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Use grammatically correct error messages</source>
          <target state="translated">文法的に正しいエラー メッセージを使用する</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Write clear sentences and include ending punctuation.</source>
          <target state="translated">明確な文を記述し、末尾に句点を含めます。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Each sentence in a description string of an exception should end in a period.</source>
          <target state="translated">例外の説明文字列の文の末尾には、必ず句点を使用します。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>For example, "The log table has overflowed.”</source>
          <target state="translated">たとえば、"ログ テーブルがオーバーフローしました。" は、</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>would be an appropriate description string.</source>
          <target state="translated">適切な説明文字列です。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>In custom exceptions, provide additional properties as needed</source>
          <target state="translated">カスタム例外で、必要に応じて追加のプロパティを提供する</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Provide additional properties for an exception (in addition to the description string) only when there's a programmatic scenario where the additional information is useful.</source>
          <target state="translated">プログラミングの点で追加情報が役立つ場合にだけ、(説明文字列以外の) 例外の追加プロパティを含めてください。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">@System.IO.FileNotFoundException</ph> provides the <ph id="ph2">@System.IO.FileNotFoundException.FileName</ph> property.</source>
          <target state="translated">たとえば、<ph id="ph1">@System.IO.FileNotFoundException</ph> には <ph id="ph2">@System.IO.FileNotFoundException.FileName</ph> プロパティがあります。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Place throw statements so that the stack trace will be helpful</source>
          <target state="translated">スタック トレースが役に立つように throw ステートメントを配置する</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The stack trace begins at the statement where the exception is thrown and ends at the <ph id="ph1">`catch`</ph> statement that catches the exception.</source>
          <target state="translated">例外がスローされたステートメントからスタック トレースが開始され、例外をキャッチした <ph id="ph1">`catch`</ph> ステートメントでトレースが終了します。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Use exception builder methods</source>
          <target state="translated">例外ビルダー メソッドを使用する</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>It is common for a class to throw the same exception from different places in its implementation.</source>
          <target state="translated">一般に、クラスはクラス実装内の複数の位置で同一の例外をスローします。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>To avoid excessive code, use helper methods that create the exception and return it.</source>
          <target state="translated">コードが長くなることを防ぐため、例外を作成して返すヘルパー メソッドを使用します。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例:</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In some cases, it's more appropriate to use the exception's constructor to build the exception.</source>
          <target state="translated">場合によっては、例外のコンストラクターを使用して例外を作成する方が適切な場合もあります。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>An example is a global exception class such as <ph id="ph1">@System.ArgumentException,</ph></source>
          <target state="translated"><ph id="ph1">@System.ArgumentException,</ph> などのグローバル例外クラスはその一例です。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Clean up intermediate results when throwing an exception</source>
          <target state="translated">例外をスローするときに、中間結果を削除する</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Callers should be able to assume that there are no side effects when an exception is thrown from a method.</source>
          <target state="translated">呼び出し元が、メソッドから例外がスローされるときに副作用が発生しないと仮定できる必要があります。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>For example, if you have code that transfers money by withdrawing from one account and depositing in another account, and an exception is thrown while executing the deposit, you don't want the withdrawal to remain in effect.</source>
          <target state="translated">たとえば、ある口座から現金を引き出して別の口座に預金することで送金を行うコードがあって、預金の実行中に例外がスローされた場合、引き出しが有効のままにしておきたくはないはずです。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>One way to handle this situation is to catch any exceptions thrown by the deposit transaction and roll back the withdrawal.</source>
          <target state="translated">この状況に対処する方法の 1 つは、預金トランザクションによってスローされた例外をキャッチし、引き出しをロールバックすることです。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>This example illustrates the use of <ph id="ph1">`throw`</ph> to re-throw the original exception, which can make it easier for callers to see the real cause of the problem without having to examine the <ph id="ph2">@System.Exception.InnerException</ph> property.</source>
          <target state="translated">この例では、<ph id="ph1">`throw`</ph> を使用して、元の例外を再スローすることを示しています。これにより、呼び出し元が <ph id="ph2">@System.Exception.InnerException</ph> プロパティを確認することなく、問題の本当の原因を容易に確認できるようになります。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>An alternative is to throw a new exception and include the original exception as the inner exception:</source>
          <target state="translated">別の方法は、新しい例外をスローして元の例外を内部例外として含めることです。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">参照</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>To learn more about how exceptions work in .NET, see <bpt id="p1">[</bpt>What Every Dev needs to Know About Exceptions in the Runtime<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/exceptions.md)</ept>.</source>
          <target state="translated">.NET での例外の動作の詳細については、「<bpt id="p1">[</bpt>What Every Dev needs to Know About Exceptions in the Runtime<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/exceptions.md)</ept>」(ランタイム時の例外についてすべての開発者が知っておくべきこと) を参照してください。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>