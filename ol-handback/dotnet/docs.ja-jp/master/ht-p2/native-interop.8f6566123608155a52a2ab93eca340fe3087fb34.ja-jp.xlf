<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0d7415b10d6f247c30b3da508eb8fc9e0007f824</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\native-interop.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0350b8bceb01c1f5eed3e52a53eadd29fd462567</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9ea9e719c5c83ae17dca2a2dd106197ba1772cfe</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">ネイティブ相互運用性</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">ネイティブ相互運用性</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Native Interoperability</source>
          <target state="translated">ネイティブ相互運用性</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In this document, we will dive a little bit deeper into all three ways of doing “native interoperability” that are available on the .NET platform.</source>
          <target state="translated">このドキュメントでは、.NET プラットフォームで使用可能な "ネイティブ相互運用性" を実行する 3 つのすべての方法についてもう少し深く掘り下げます。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>There are a few of reasons why you would want to call into native code:</source>
          <target state="translated">ネイティブ コードを呼び出す理由はいくつかあります。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Operating Systems come with a large volume of APIs that are not present in the managed class libraries.</source>
          <target state="translated">オペレーティング システムには、マネージ クラス ライブラリに存在しない大量の API が付属しています。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A prime example for this would be access to hardware or operating system management functions.</source>
          <target state="translated">この主な例には、ハードウェアまたはオペレーティング システム管理機能へのアクセスがあります。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Communicating with other components that have or can produce C-style ABIs (native ABIs).</source>
          <target state="translated">C スタイル ABI (ネイティブ ABI) があるか、または生成できるその他のコンポーネントと通信します。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This covers, for example, Java code that is exposed via <bpt id="p1">[</bpt>Java Native Interface (JNI)<ept id="p1">](http://docs.oracle.com/javase/8/docs/technotes/guides/jni/)</ept> or any other managed language that could produce a native component.</source>
          <target state="translated">これはたとえば、<bpt id="p1">[</bpt>Java ネイティブ インターフェイス (JNI)<ept id="p1">](http://docs.oracle.com/javase/8/docs/technotes/guides/jni/)</ept> によって公開されている Java コードまたはネイティブ コンポーネントを生成できる他のマネージ言語を対象とします。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>On Windows, most of the software that gets installed, such as Microsoft Office suite, registers COM components that represent their programs and allow developers to automate them or use them.</source>
          <target state="translated">Windows では、Microsoft Office スイートなどのインストールされるソフトウェアのほとんどが、それらのプログラムを表し、開発者が自動化したり、使用したりできる COM コンポーネントを登録します。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This also requires native interoperability.</source>
          <target state="translated">これも、ネイティブ相互運用性を必要とします。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Of course, the list above does not cover all of the potential situations and scenarios in which the developer would want/like/need to interface with native components.</source>
          <target state="translated">もちろん、上の一覧は、開発者がネイティブ コンポーネントとやり取りしたいと考える、またはその必要があるすべての可能性のある状況やシナリオを取り上げていません。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>.NET class library, for instance, uses the native interoperability support to implement a fair number of its APIs, like console support and manipulation, file system access and others.</source>
          <target state="translated">たとえば、.NET クラス ライブラリは、ネイティブ相互運用性サポートを使用して、コンソールのサポートと操作、ファイル システムのアクセスなど、そのかなりの数の API を実装しています。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>However, it is important to note that there is an option, should one need it.</source>
          <target state="translated">ただし、それを必要とする場合に、オプションがあることに注意することが重要です。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Most of the examples in this document will be presented for all three supported platforms for .NET Core (Windows, Linux and macOS).</source>
          <target state="translated">このドキュメントのほとんどの例は、.NET Core でサポートされる 3 つすべてのプラットフォーム (Windows、Linux、macOS) について提示しています。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>However, for some short and illustrative examples, just one sample is shown that uses Windows filenames and extensions (that is, “dll” for libraries).</source>
          <target state="translated">ただし、短い解説的な例については、Windows ファイル名と拡張子 (つまり、ライブラリの場合は "dll") を使用する 1 つのサンプルだけを示します。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This does not mean that those features are not available on Linux or macOS, it was done merely for convenience sake.</source>
          <target state="translated">これは、それらの機能が Linux や macOS で使用できないわけではなく、単に便宜上のためにのみそうしています。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Platform Invoke (P/Invoke)</source>
          <target state="translated">プラットフォーム呼び出し (P/Invoke)</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>P/Invoke is a technology that allows you to access structs, callbacks and functions in unmanaged libraries from your managed code.</source>
          <target state="translated">P/invoke は、アンマネージ ライブラリ内の構造体、コールバック、および関数をマネージ コードからアクセスできるようにするテクノロジです。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Most of the P/Invoke API is contained in two namespaces: <ph id="ph1">`System`</ph> and <ph id="ph2">`System.Runtime.InteropServices`</ph>.</source>
          <target state="translated">P/Invoke API のほとんどは、<ph id="ph1">`System`</ph> と <ph id="ph2">`System.Runtime.InteropServices`</ph> の 2 つの名前空間に含まれます。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Using these two namespaces will allow you access to the attributes that describe how you want to communicate with the native component.</source>
          <target state="translated">これらの 2 つの名前空間を使用して、ネイティブ コンポーネントと通信する方法を記述する属性にアクセスできます。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Let’s start from the most common example, and that is calling unmanaged functions in your managed code.</source>
          <target state="translated">最も一般的な例から始めましょう。これはマネージ コードでアンマネージ関数を呼び出します。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Let’s show a message box from a command-line application:</source>
          <target state="translated">コマンドライン アプリケーションからメッセージ ボックスを表示してみましょう。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The example above is pretty simple, but it does show off what is needed to invoke unmanaged functions from managed code.</source>
          <target state="translated">上の例はとても簡単ですが、マネージ コードからアンマネージ関数を呼び出すために必要なことを示しています。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Let’s step through the example:</source>
          <target state="translated">この例の手順を説明します。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Line #1 shows the using statement for the <ph id="ph1">`System.Runtime.InteropServices`</ph> which is the namespace that holds all of the items we need.</source>
          <target state="translated">1 行目は、必要なすべての項目を保持する名前空間 <ph id="ph1">`System.Runtime.InteropServices`</ph> のステートメントの使用を示しています。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Line #5 introduces the <ph id="ph1">`DllImport`</ph> attribute.</source>
          <target state="translated">5 行目で <ph id="ph1">`DllImport`</ph> 属性を導入しています。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL.</source>
          <target state="translated">この属性は、ランタイムにアンマネージ DLL を読み込むように伝えるため、きわめて重要です。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This is the DLL into which we wish to invoke.</source>
          <target state="translated">これは、呼び出したい DLL です。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Line #6 is the crux of the P/Invoke work.</source>
          <target state="translated">6 行目は、P/Invoke 作業の最も重要な箇所です。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>It defines a managed method that has the <bpt id="p1">**</bpt>exact same signature<ept id="p1">**</ept> as the unmanaged one.</source>
          <target state="translated">ここでは、アンマネージと<bpt id="p1">**</bpt>正確に同じシグネチャ<ept id="p1">**</ept>を持つマネージ メソッドを定義しています。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The declaration has a new keyword that you can notice, <ph id="ph1">`extern`</ph>, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in <ph id="ph2">`DllImport`</ph> attribute.</source>
          <target state="translated">宣言には新しいキーワード <ph id="ph1">`extern`</ph> があることがわかります。これはランタイムに、これが外部メソッドであり、それを呼び出したときに、ランタイムが <ph id="ph2">`DllImport`</ph> 属性に指定された DLL からそれを見つける必要があることを伝えます。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The rest of the example is just invoking the method as you would any other managed method.</source>
          <target state="translated">例の残りの部分は、その他のマネージ メソッドと同じように、メソッドを呼び出しているだけです。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The sample is similar for macOS.</source>
          <target state="translated">サンプルは、macOS の場合も似ています。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>One thing that needs to change is, of course, the name of the library in the <ph id="ph1">`DllImport`</ph> attribute, as macOS has a different scheme of naming dynamic libraries.</source>
          <target state="translated">変更する必要がある唯一の点が、当然ながら、<ph id="ph1">`DllImport`</ph> 属性内のライブラリの名前です。macOS のダイナミック ライブラリの名前付けのスキームが異なるからです。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The sample below uses the <ph id="ph1">`getpid(2)`</ph> function to get the process ID of the application and print it out to the console.</source>
          <target state="translated">下のサンプルでは、<ph id="ph1">`getpid(2)`</ph> 関数を使用して、アプリケーションのプロセス ID を取得し、それをコンソールに出力しています。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>It is similar on Linux, of course.</source>
          <target state="translated">これはもちろん Linux でも似ています。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The function name is same, since <ph id="ph1">`getpid(2)`</ph> is <bpt id="p1">[</bpt>POSIX<ept id="p1">](https://en.wikipedia.org/wiki/POSIX)</ept> system call.</source>
          <target state="translated"><ph id="ph1">`getpid(2)`</ph> は <bpt id="p1">[</bpt>POSIX<ept id="p1">](https://en.wikipedia.org/wiki/POSIX)</ept> システム コールであるため、関数名が同じです。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Invoking managed code from unmanaged code</source>
          <target state="translated">アンマネージ コードからのマネージ コードの呼び出し</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Of course, the runtime allows communication to flow both ways which enables you to call into managed artifacts from native functions, using function pointers.</source>
          <target state="translated">もちろん、ランタイムは、通信が双方向にフローすることを許可しているため、関数ポインターを使用して、ネイティブ関数からマネージ成果物を呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The closest thing to a function pointer in managed code is a <bpt id="p1">**</bpt>delegate<ept id="p1">**</ept>, so this is what is used to allow callbacks from native code into managed code.</source>
          <target state="translated">マネージ コードで、関数ポインターに最も近いものが、<bpt id="p1">**</bpt>デリゲート<ept id="p1">**</ept>であるため、これをネイティブ コードからマネージ コードへのコールバックを許可するために使います。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The way to use this feature is similar to managed to native process described above.</source>
          <target state="translated">この機能を使用する方法は、先述のマネージからネイティブへのプロセスに似ています。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For a given callback, you define a delegate that matches the signature, and pass that into the external method.</source>
          <target state="translated">指定されたコールバックに対し、ユーザーがシグネチャと一致するデリゲートを定義し、それを外部メソッドに渡します。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The runtime will take care of everything else.</source>
          <target state="translated">ランタイムは、他のすべてのことを処理します。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Before we walk through our example, it is good to go over the signatures of the unmanaged functions we need to work with.</source>
          <target state="translated">例の手順に従う前に、使用する必要があるアンマネージ関数のシグネチャについて見直しておくのはよいことです。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The function we want to call to enumerate all of the windows has the following signature: <ph id="ph1">`BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</ph></source>
          <target state="translated">すべてのウィンドウを列挙するために呼び出す関数は、次のシグネチャを持ちます。<ph id="ph1">`BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</ph></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The first parameter is a callback.</source>
          <target state="translated">最初のパラメーターでは、コールバックです。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The said callback has the following signature: <ph id="ph1">`BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</ph></source>
          <target state="translated">上記のコールバックのシグネチャは次のとおりです。<ph id="ph1">`BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</ph></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>With this in mind, let’s walk through the example:</source>
          <target state="translated">これを踏まえて、例の手順を追っていきましょう。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Line #8 in the example defines a delegate that matches the signature of the callback from unmanaged code.</source>
          <target state="translated">例の 8 行目では、アンマネージ コードからのコールバックのシグネチャと一致するデリゲートを定義しています。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Notice how the LPARAM and HWND types are represented using <ph id="ph1">`IntPtr`</ph> in the managed code.</source>
          <target state="translated">マネージ コードで <ph id="ph1">`IntPtr`</ph> を使用して、LPARAM および HWND 型を表す方法に注意してください。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Lines #10 and #11 introduce the <ph id="ph1">`EnumWindows`</ph> function from the user32.dll library.</source>
          <target state="translated">10 行目と 11 行目では、user32.dll ライブラリから <ph id="ph1">`EnumWindows`</ph> 関数を導入しています。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Lines #13 - 16 implement the delegate.</source>
          <target state="translated">13 ～ 16 行目は、デリゲートを実装しています。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For this simple example, we just want to output the handle to the console.</source>
          <target state="translated">この簡単な例では、ハンドルだけコンソールに出力します。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Finally, in line #19 we invoke the external method and pass in the delegate.</source>
          <target state="translated">最後に、19 行目で、外部メソッドを呼び出し、デリゲートを渡しています。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The Linux and macOS examples are shown below.</source>
          <target state="translated">Linux と macOS の例を、以下に示します。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For them, we use the <ph id="ph1">`ftw`</ph> function that can be found in <ph id="ph2">`libc`</ph>, the C library.</source>
          <target state="translated">それらの場合、<ph id="ph2">`libc`</ph> C ライブラリに見つかる <ph id="ph1">`ftw`</ph> 関数を使用します。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters.</source>
          <target state="translated">この関数は、ディレクトリ階層をスキャンするために使用し、そのパラメーターの 1 つとして、関数へのポインターを受け取ります。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The said function has the following signature: <ph id="ph1">`int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`</ph>.</source>
          <target state="translated">上記のメソッドのシグネチャは次のとおりです。<ph id="ph1">`int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`</ph></target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>macOS example uses the same function, and the only difference is the argument to the <ph id="ph1">`DllImport`</ph> attribute, as macOS keeps <ph id="ph2">`libc`</ph> in a different place.</source>
          <target state="translated">macOS の例では、同じ関数を使用していますが、唯一の違いは <ph id="ph1">`DllImport`</ph> 属性への引数です。macOS は <ph id="ph2">`libc`</ph> を別の場所で保持しているためです。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Both of the above examples depend on parameters, and in both cases, the parameters are given as managed types.</source>
          <target state="translated">上記の例のどちらも、パラメーターに依存し、どちらの場合もパラメーターは、マネージ型として指定されています。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Runtime does the “right thing” and processes these into its equivalents on the other side.</source>
          <target state="translated">ランタイムは、"正しいこと" を実行し、これらを他方の側で同等のものに処理します。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Since this process is really important to writing quality native interop code, let’s take a look at what happens when the runtime <bpt id="p1">_</bpt>marshals<ept id="p1">_</ept> the types.</source>
          <target state="translated">このプロセスでは、高品質なネイティブ相互運用コードを記述することがきわめて重要であるため、ランタイムが型を<bpt id="p1">_</bpt>マーシャリング<ept id="p1">_</ept>する際に何が起こるかを見てみましょう。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Type marshalling</source>
          <target state="translated">型のマーシャリング</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Marshalling<ept id="p1">**</ept> is the process of transforming types when they need to cross the managed boundary into native and vice versa.</source>
          <target state="translated"><bpt id="p1">**</bpt>マーシャ リング<ept id="p1">**</ept>はマネージの境界を越えてネイティブに、またはその逆の必要がある場合に、型を変換するプロセスです。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The reason marshalling is needed is because the types in the managed and unmanaged code are different.</source>
          <target state="translated">マーシャリングが必要な理由は、マネージ コードとアンマネージ コード内の型が異なるためです。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In managed code, for instance, you have a <ph id="ph1">`String`</ph>, while in the unmanaged world strings can be Unicode (“wide”), non-Unicode, null-terminated, ASCII, etc. By default, the P/Invoke subsystem will try to do the Right Thing based on the default behavior which you can see on <bpt id="p1">[</bpt>MSDN<ept id="p1">](https://msdn.microsoft.com/library/zah6xy75.aspx)</ept>.</source>
          <target state="translated">マネージ コードで、たとえば、<ph id="ph1">`String`</ph> があるとします。アンマネージ環境では、文字列は Unicode ("ワイド")、Unicode 以外、Null 終了、ASCII などです。既定で、P/Invoke サブシステムは既定の動作に基づいて "正しいこと" をしようと試みますが、それらについては <bpt id="p1">[</bpt>MSDN<ept id="p1">](https://msdn.microsoft.com/library/zah6xy75.aspx)</ept> で確認できます。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>However, for those situations where you need extra control, you can employ the <ph id="ph1">`MarshalAs`</ph> attribute to specify what is the expected type on the unmanaged side.</source>
          <target state="translated">ただし、特別な制御が必要な場合、<ph id="ph1">`MarshalAs`</ph> 属性を採用して、アンマネージ側で期待する型を指定します。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For instance, if we want the string to be sent as a null-terminated ANSI string, we could do it like this:</source>
          <target state="translated">たとえば、文字列を NULL で終わる ANSI 文字列として送信させる場合は、次のように指定できます。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Marshalling classes and structs</source>
          <target state="translated">クラスと構造体のマーシャリング</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Another aspect of type marshalling is how to pass in a struct to an unmanaged method.</source>
          <target state="translated">型のマーシャリングの別の側面は、構造体をアンマネージ メソッドに渡す方法です。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For instance, some of the unmanaged methods require a struct as a parameter.</source>
          <target state="translated">たとえば、一部のアンマネージ メソッドでは、パラメーターとして構造体が必要です。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In these cases, we need to create a corresponding struct or a class in managed part of the world to use it as a parameter.</source>
          <target state="translated">このような場合、環境のマネージ部分に対応する構造体またはクラスを作成し、それをパラメーターとして使用する必要があります。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>However, just defining the class is not enough, we also need to instruct the marshaler how to map fields in the class to the unmanaged struct.</source>
          <target state="translated">ただし、クラスを定義するだけでは不十分で、マーシャラーに、クラス内のフィールドをアンマネージ構造体にマップする方法を指示する必要もあります。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>This is where the <ph id="ph1">`StructLayout`</ph> attribute comes into play.</source>
          <target state="translated">これは、<ph id="ph1">`StructLayout`</ph> 属性が関与する箇所です。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The example above shows off a simple example of calling into <ph id="ph1">`GetSystemTime()`</ph> function.</source>
          <target state="translated">上の例は、<ph id="ph1">`GetSystemTime()`</ph> 関数を呼び出す簡単な例を示しています。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The interesting bit is on line 4<ph id="ph1">\.</ph> The attribute specifies that the fields of the class should be mapped sequentially to the struct on the other (unmanaged) side.</source>
          <target state="translated">興味深い部分は 4 行目にあります。<ph id="ph1">\.</ph>この属性は、他方 (アンマネージ) の側でクラスのフィールドを構造体に順番にマップする必要があることを指定します。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This means that the naming of the fields is not important, only their order is important, as it needs to correspond to the unmanaged struct, shown below:</source>
          <target state="translated">このことは、下に示すアンマネージ構造体に対応する必要があるため、フィールドの名前付けは重要でなく、それらの順番だけが重要であることを意味します。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>We already saw the Linux and macOS example for this in the previous example.</source>
          <target state="translated">前の例で、これの Linux と macOS の例について既に説明しました。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>It is shown again below.</source>
          <target state="translated">下にもう一度示します。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`StatClass`</ph> class represents a structure that is returned by the <ph id="ph2">`stat`</ph> system call on UNIX systems.</source>
          <target state="translated"><ph id="ph1">`StatClass`</ph> クラスは、UNIX システムで <ph id="ph2">`stat`</ph> システム コールによって返される構造体を表します。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>It represents information about a given file.</source>
          <target state="translated">これは、指定したファイルに関する情報を表します。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The class above is the stat struct representation in managed code.</source>
          <target state="translated">上のクラスは、マネージ コードでの stat 構造体表現です。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Again, the fields in the class have to be in the same order as the native struct (you can find these by perusing man pages on your favorite UNIX implementation) and they have to be of the same underlying type.</source>
          <target state="translated">ここでも、クラス内のフィールドはネイティブ構造体と同じ順番である必要があり (これらについては、任意の UNIX 実装の man ページを調べて参照できます)、基になる型が同じである必要があります。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>More resources</source>
          <target state="translated">その他のリソース</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>PInvoke.net wiki<ept id="p1">](http://www.pinvoke.net)</ept> an excellent Wiki with information on common Win32 APIs and how to call them.</source>
          <target state="translated"><bpt id="p1">[</bpt>PInvoke.net wiki<ept id="p1">](http://www.pinvoke.net)</ept> は、一般的な Win32 API とそれらを呼び出す方法に関する情報を記載した優れた Wiki です。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>P/Invoke on MSDN<ept id="p1">](https://msdn.microsoft.com/library/zbz07712.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>MSDN の P/Invoke<ept id="p1">](https://msdn.microsoft.com/library/zbz07712.aspx)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Mono documentation on P/Invoke<ept id="p1">](http://www.mono-project.com/docs/advanced/pinvoke/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>P/invoke に関する Mono のドキュメント<ept id="p1">](http://www.mono-project.com/docs/advanced/pinvoke/)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>