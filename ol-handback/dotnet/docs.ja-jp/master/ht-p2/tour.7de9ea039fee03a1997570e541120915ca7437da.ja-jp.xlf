<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02e2fa22e36fd2f6618527ad3c89cbbd8587dfe2</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\tour.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b5d2ad1e76f36733598999f425a89b00a11b9cd</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">486574494fd69fdc2cf6ac253f6e6e902ee27923</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Tour of .NET</source>
          <target state="translated">.NET のツアー</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>A guided tour through some of the prominent features of the .NET platform.</source>
          <target state="translated">.NET プラットフォームのいくつかの優れた機能についてのガイド付きツアーです。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, Tour, Programming Languages, Unsafe, Memory Management, Type Safety, Async</source>
          <target state="translated">.NET, .NET Core, ツアー, プログラミング言語, アンセーフ, メモリ管理, タイプ セーフ, 非同期</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Tour of .NET</source>
          <target state="translated">.NET のツアー</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>.NET is a general purpose development platform.</source>
          <target state="translated">.NET は、汎用的な開発プラットフォームです。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It has several key features, such as multiple programming languages, asynchronous and concurrent programming models, and native interoperability which enable a wide range of scenarios across multiple platforms.</source>
          <target state="translated">.NET には、複数のプラットフォームでのさまざまなシナリオを可能にする、複数のプログラミング言語、非同期および同時実行のプログラミング モデル、ネイティブな相互運用性など、重要な機能がいくつかあります。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This article offers a guided tour through some of the key features of the .NET platform.</source>
          <target state="translated">この記事は、.NET プラットフォームのいくつかの重要な機能についてのガイド付きツアーです。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>.NET Architectural Components<ept id="p1">](components.md)</ept> to learn about each of the architectural "pieces" of .NET and what they're used for.</source>
          <target state="translated">.NET アーキテクチャの "構成要素" とそれらの用途については、「<bpt id="p1">[</bpt>.NET アーキテクチャ コンポーネント<ept id="p1">](components.md)</ept>」をご覧ください。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>How to run the code samples</source>
          <target state="translated">コード サンプルの実行方法</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To learn how to set up a development environment to run the code samples, check out <bpt id="p1">[</bpt>Getting Started<ept id="p1">](getting-started.md)</ept>.</source>
          <target state="translated">コード サンプルを実行できるように開発環境を設定する方法については、「<bpt id="p1">[</bpt>Getting Started<ept id="p1">](getting-started.md)</ept>」 (概要) をご覧ください。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can copy and paste code samples from this page into your environment to execute them.</source>
          <target state="translated">このページのコード サンプルをコピーして環境に貼り付け、実行することができます。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In the future, this documentation site will have the ability to run these code samples in your browser.</source>
          <target state="translated">将来的には、このドキュメント サイトからブラウザーでコード サンプルを実行できるようにします。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Programming languages</source>
          <target state="translated">プログラミング言語</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>.NET supports multiple programming languages.</source>
          <target state="translated">.NET は複数のプログラミング言語をサポートしています。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>.NET runtimes implement the <bpt id="p1">[</bpt>Common Language Infrastructure (CLI)<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>, which (among other things) specifies a language-independent runtime and language interoperability.</source>
          <target state="translated">.NET ランタイムでは、<bpt id="p1">[</bpt>共通言語基盤 (CLI)<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept> が実装されています。CLI では特に、言語に依存しないランタイムと言語の相互運用性が指定されています。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This means that you can choose any .NET language to build apps and services on .NET.</source>
          <target state="translated">つまり、任意の .NET 言語を選んで、.NET でアプリとサービスを作成できます。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic .NET.</source>
          <target state="translated">Microsoft が開発とサポートに力を注いでいる .NET 言語は、C#、F#、Visual Basic .NET の 3 つです。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages.</source>
          <target state="translated">C# はシンプル、強力、タイプセーフ、そしてオブジェクト指向でありながらも、C スタイル言語の表現力と簡潔さが維持されています。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Anyone familiar with C and similar languages will find few problems in adapting to C#.</source>
          <target state="translated">C や類似の言語を使い慣れている人であれば、ほとんど問題なく C# に適応できるでしょう。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>C# Guide<ept id="p1">](../csharp/index.md)</ept> to learn more about C#.</source>
          <target state="translated">C# について詳しくは、「<bpt id="p1">[</bpt>C# Guide<ept id="p1">](../csharp/index.md)</ept>」 (C# ガイド) をご覧ください。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</source>
          <target state="translated">F# はクロスプラットフォームの関数型プログラミング言語ですが、従来のオブジェクト指向および命令型プログラミングもサポートしています。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>F# Guide<ept id="p1">](../fsharp/index.md)</ept> to learn more about F#.</source>
          <target state="translated">F# について詳しくは、「<bpt id="p1">[</bpt>F# Guide<ept id="p1">](../fsharp/index.md)</ept>」 (F# ガイド) をご覧ください。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.</source>
          <target state="translated">Visual Basic は、学習しやすい言語で、.NET 上で実行されるさまざまなアプリケーションの構築に使用できます。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Automatic memory management</source>
          <target state="translated">自動メモリ管理</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>.NET uses <bpt id="p1">[</bpt>garbage collection<ept id="p1">](garbagecollection/index.md)</ept> to provide automatic memory management for programs.</source>
          <target state="translated">.NET は、<bpt id="p1">[</bpt>ガベージ コレクション<ept id="p1">](garbagecollection/index.md)</ept>を使ってプログラムの自動メモリ管理を行います。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.</source>
          <target state="translated">GC はメモリ管理に対する遅延アプローチで動作します。この場合、メモリの即時収集よりもアプリケーションのスループットが優先されます。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To learn more about the .NET GC, check out <bpt id="p1">[</bpt>Fundamentals of garbage collection (GC)<ept id="p1">](garbagecollection/fundamentals.md)</ept>.</source>
          <target state="translated">.NET GC について詳しくは、「<bpt id="p1">[</bpt>ガベージ コレクションの基礎<ept id="p1">](garbagecollection/fundamentals.md)</ept>」をご覧ください。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following two lines both allocate memory:</source>
          <target state="translated">以下の 2 つの行はどちらもメモリを割り当てています。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>There is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</source>
          <target state="translated">ガベージ コレクターがスケジュールされた実行によってメモリを解放する際に割り当て解除が自動的に行われるため、メモリの割り当てを解除するための類似したキーワードはありません。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Types within a given scope normally go out of scope once a method completes, at which point they can be collected.</source>
          <target state="translated">通常、特定のスコープ内の型は、メソッドが完了して、収集が可能になった時点で、スコープ外に移動します。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the <ph id="ph1">`using`</ph> statement:</source>
          <target state="translated">ただし、<ph id="ph1">`using`</ph> ステートメントを使用して、メソッドの終了よりも早く、特定のオブジェクトがスコープ外に移動するように GC に指定することができます。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L6-L9)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L6-L9)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Once the <ph id="ph1">`using`</ph> block completes, the GC will know that the <ph id="ph2">`stream`</ph> object in the previous example is free to be collected and its memory reclaimed.</source>
          <target state="translated"><ph id="ph1">`using`</ph> ブロックが完了すると、上の例の <ph id="ph2">`stream`</ph> オブジェクトを自由に収集でき、メモリが解放できることが GC に伝わります。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Rules for this have slightly different semantics in F#.</source>
          <target state="translated">このルールのセマンティクスは、F# では若干異なります。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>To learn more about resource management in F#, check out <bpt id="p1">[</bpt>Resource Management: The <ph id="ph1">`use`</ph> Keyword<ept id="p1">](../fsharp/language-reference/resource-management-the-use-keyword.md)</ept></source>
          <target state="translated">F# でのリソース管理について詳しくは、「<bpt id="p1">[</bpt>リソースの管理: <ph id="ph1">`use`</ph> キーワード<ept id="p1">](../fsharp/language-reference/resource-management-the-use-keyword.md)</ept>」をご覧ください。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>One of the less obvious but quite far-reaching features that a garbage collector enables is memory safety.</source>
          <target state="translated">ガベージ コレクターによって可能になる機能のうち、これほど目立たないものの、非常に広範囲に及ぶものの 1 つが、メモリの安全性です。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).</source>
          <target state="translated">メモリの安全性の不変性は非常に単純です。プログラムが割り当てられている (そして解放されていない) メモリのみにアクセスする場合、そのプログラムはメモリ セーフです。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Dangling pointers are always bugs, and tracking them down is often quite difficult.</source>
          <target state="translated">付随的なポインターは常にバグになり、多くの場合、これらを見つけ出すことはとても困難です。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The .NET runtime provides additional services, to complete the promise of memory safety, not naturally offered by a GC.</source>
          <target state="translated">.NET ランタイムでは、GC から元々提供されるものではない、メモリの安全性を確保するための追加のサービスを提供しています。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>It ensures that programs do not index off the end of an array or accessing a phantom field off the end of an object.</source>
          <target state="translated">プログラムが配列の最後にインデックス処理を行ったり、オブジェクトの最後にある実在しないフィールドにアクセスしたりすることがなくなります。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following example will throw an exception as a result of memory safety.</source>
          <target state="translated">次の例では、メモリの安全性の結果として、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L11-L12)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>MemoryManagement<ept id="p2">](../../samples/csharp/snippets/tour/MemoryManagement.csx#L11-L12)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Type safety</source>
          <target state="translated">タイプ セーフ</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Objects are allocated in terms of types.</source>
          <target state="translated">オブジェクトには、型が割り当てられます。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The only operations allowed for a given object, and the memory it consumes, are those of its type.</source>
          <target state="translated">指定のオブジェクトが許可される操作、および使用するメモリは、その型から決まります。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dog`</ph> type may have <ph id="ph2">`Jump`</ph> and <ph id="ph3">`WagTail`</ph> methods, but not likely a <ph id="ph4">`SumTotal`</ph> method.</source>
          <target state="translated"><ph id="ph1">`Dog`</ph> 型には <ph id="ph2">`Jump`</ph> と <ph id="ph3">`WagTail`</ph> メソッドを含むことができますが、<ph id="ph4">`SumTotal`</ph> メソッドが含まれることはないでしょう。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A program can only call the declared methods of a given type.</source>
          <target state="translated">プログラムは、指定された型の宣言されたメソッドのみを呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or <ph id="ph1">`object`</ph>).</source>
          <target state="translated">それ以外のどの呼び出しを行っても、コンパイル時エラーまたはランタイム例外が発生します (動的機能または <ph id="ph1">`object`</ph> を使用した場合)。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>.NET languages are object-oriented, with hierarchies of base and derived classes.</source>
          <target state="translated">.NET 言語は、オブジェクト指向で、基本クラスと派生クラスの階層を含みます。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The .NET runtime will only allow object casts and calls that align with the object hierarchy.</source>
          <target state="translated">.NET ランタイムではオブジェクトの階層に応じたオブジェクトのキャストと呼び出しのみが許可されます。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Remember that every type defined in any .NET language derives from the base <ph id="ph1">`object`</ph> type.</source>
          <target state="translated">.NET 言語で定義されているすべての型が、基本の <ph id="ph1">`object`</ph> 型から派生していることを覚えておいてください。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</source>
          <target state="translated">タイプ セーフは、アクセサー キーワードの忠実性を保証することで、カプセル化の支援を行うためにも使用されます。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Accessor keywords are artifacts which control access to members of a given type by other code.</source>
          <target state="translated">アクセサー キーワードは、指定した型のメンバーへのアクセスを他のコードによって制御する成果物です。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>These are usually used for various kinds of data within a type that are used to manage its behavior.</source>
          <target state="translated">これらは通常、その動作を管理するために使用される型に含まれる、さまざまな種類のデータに使用されます。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>C#, Visual Basic, and F# support local <bpt id="p1">**</bpt>type inference<ept id="p1">**</ept>.</source>
          <target state="translated">C#、Visual Basic、F# は、ローカルな<bpt id="p1">**</bpt>型推論<ept id="p1">**</ept>をサポートします。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side.</source>
          <target state="translated">型推論は、コンパイラが右側にある式から左側にある式の型を推論するという意味です。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This doesn't mean that the type safety is broken or avoided.</source>
          <target state="translated">タイプ セーフの破損、または回避を意味するわけではありません。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The resulting type <bpt id="p1">**</bpt>has<ept id="p1">**</ept> a strong type with everything that implies.</source>
          <target state="translated">結果の型には、推論されるすべてを含む厳密な型が<bpt id="p1">**</bpt>含まれます<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Let's rewrite the first two lines of the previous example to introduce type inference.</source>
          <target state="translated">前の例の最初の 2 行を、型推論を示すように書き換えてみましょう。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Note that the rest of the example is completely the same.</source>
          <target state="translated">例の残りの部分はまったく同じであることに注意してください。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TypeSafety<ept id="p2">](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>F# has even further type inference capabilities than method-local type inference found in C# and Visual Basic.</source>
          <target state="translated">F# は、C# や Visual Basic のメソッド ローカルな型推論よりさらに進んだ型推論機能を備えています。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>To learn more, check out <bpt id="p1">[</bpt>Type Inference<ept id="p1">](../fsharp/language-reference/type-inference.md)</ept>.</source>
          <target state="translated">詳しくは、「<bpt id="p1">[</bpt>Type Inference<ept id="p1">](../fsharp/language-reference/type-inference.md)</ept>」 (型推論) をご覧ください。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">デリゲートとラムダ</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Delegates are like C++ function pointers, with a big difference that they are type safe.</source>
          <target state="translated">デリゲートは C++ の関数ポインターに似ていますが、大きな違いはタイプ セーフであることです。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>They are a kind of disconnected method within the CLR type system.</source>
          <target state="translated">CLR 型システム内で接続されていないメソッドの一種です。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Regular methods are attached to a class and only directly callable through static or instance calling conventions.</source>
          <target state="translated">通常のメソッドはクラスに接続されており、静的な、またはインスタンスが呼び出す規則によってのみ直接呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Delegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.</source>
          <target state="translated">デリゲートは、.NET の世界のさまざまな API や場所で使用されます。このうち、特に使用されるのが、LINQ の要となるラムダ式です。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept> document.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept>」(デリゲートとラムダ) のドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">ジェネリック</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Generics are a feature that was added in .NET Framework 2.0.</source>
          <target state="translated">ジェネリックは、.NET Framework 2.0 で追加された機能です。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In short, generics allow the programmer to introduce a "type parameter" when designing their classes, that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</source>
          <target state="translated">簡単に言えば、ジェネリックを使用することで、プログラマがクラスを設計する際に "型パラメーター" を導入することができ、これによってクライアント コード (その型のユーザー) が型パラメーターの代わりに使用する正確な型を指定できるようになります。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Generics were added to help programmers implement generic data structures.</source>
          <target state="translated">ジェネリックは、プログラマが汎用的なデータ構造を実装するために追加されました。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Before their arrival, in order for a, say, <ph id="ph1">`List`</ph> type to be generic, it would have to work with elements that were of type <ph id="ph2">`object`</ph>.</source>
          <target state="translated">それ以前は、たとえば <ph id="ph1">`List`</ph> 型をジェネリックにするには、<ph id="ph2">`object`</ph> 型の要素を使用する必要がありました。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This would have various performance as well as semantic problems, not to mention possible subtle runtime errors.</source>
          <target state="translated">これにより、軽微なランタイム エラーの可能性があることは言うまでもなく、パフォーマンスやセマンティックのさまざまな問題が発生することがありました。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <ph id="ph1">`InvalidCastException`</ph> is thrown on working with the list's members.</source>
          <target state="translated">セマンティックに関して特に問題だったのは、データ構造にたとえば整数と文字列の両方が含まれる場合にリストのメンバーを操作すると <ph id="ph1">`InvalidCastException`</ph> がスローされるということです。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following sample shows a basic program running using an instance of <ph id="ph1">@System.Collections.Generic.List%601</ph> types.</source>
          <target state="translated">以下のサンプルに、<ph id="ph1">@System.Collections.Generic.List%601</ph> 型のインスタンスを使用して実行される基本的なプログラムを示します。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GenericsShort<ept id="p2">](../../samples/csharp/snippets/tour/GenericsShort.csx)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GenericsShort<ept id="p2">](../../samples/csharp/snippets/tour/GenericsShort.csx)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept> article.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept>」(ジェネリック型 (ジェネリック) の概要) の記事を参照してください。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Async programming</source>
          <target state="translated">非同期プログラミング</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Async programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs.</source>
          <target state="translated">非同期プログラミングは、ランタイムでの非同期サポート、フレームワーク ライブラリ、.NET 言語構成要素が含まれる、.NET のファースト クラスの概念です。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Internally, they are based off of objects (such as <ph id="ph1">`Task`</ph>) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</source>
          <target state="translated">内部は、オペレーティング システムを利用して可能な限り効率的に I/O バウンドなジョブを実行する、(<ph id="ph1">`Task`</ph> などの) オブジェクトに基づいています。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To learn more about async programming in .NET, start with the <bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept>.</source>
          <target state="translated">.NET の非同期プログラミングの詳細を理解するには、最初に「<bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept>」(非同期の概要) を参照してください。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ)</source>
          <target state="translated">統合言語クエリ (LINQ)</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</source>
          <target state="translated">LINQ は、データ操作のための単純な宣言型コードを記述できる、C# および VB の強力な一連の機能です。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!</source>
          <target state="translated">データは (メモリ内オブジェクト、SQL データベース、XML ドキュメントなどの) さまざまな形式にすることができますが、記述する LINQ コードは通常、どのデータ ソースでも違いがないように見えます。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>To learn more and see some samples, check out <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</source>
          <target state="translated">詳細および一部のサンプルを確認するには、「<bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>」(LINQ (統合言語クエリ)) を参照してください。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">ネイティブ相互運用性</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Every operating system in current use provides a lot of platform support for various programming tasks.</source>
          <target state="translated">現在使用されているどのオペレーティング システムでも、さまざまなプログラミング タスクのための多くのプラットフォーム サポートを提供しています。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>.NET provides several ways to tap into those APIs.</source>
          <target state="translated">.NET には、その API を利用するためのいくつかの方法が用意されています。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Collectively, this support is called "native interoperability" and in this section we will take a look at how to access native APIs from managed, .NET code.</source>
          <target state="translated">このサポートをまとめて「ネイティブ相互運用性」と呼びます。このセクションでは、.NET のマネージ コードからネイティブの API にアクセスする方法を説明します。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The main way to do native interoperability is via "platform invoke" or P/Invoke for short.</source>
          <target state="translated">ネイティブの相互運用を行う主な方法が、"プラットフォーム呼び出し" (略してP/Invoke) を使用するものです。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>This support in .NET Core is available across Linux and Windows platforms.</source>
          <target state="translated">.NET Core におけるこのサポートは Linux と Windows プラットフォーム間で使用できます。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Another, Windows-only way of doing native interoperability is known as "COM interop" which is used to work with <bpt id="p1">[</bpt>COM components<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in managed code.</source>
          <target state="translated">また、Windows 限定でネイティブの相互運用を行う方法が "COM 相互運用" です。これは、マネージ コードで <bpt id="p1">[</bpt>COM コンポーネント<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept>を操作する場合に使用します。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>It is built on top of P/Invoke infrastructure, but it works in subtly different ways.</source>
          <target state="translated">これは、P/Invoke インフラストラクチャ上に構築されますが、動作は少し異なります。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</source>
          <target state="translated">Java および Objective-C に対する Mono (つまり Xamarin) の相互運用性サポートの多くが同じようにして構築されています。つまり、同じ原則を使用しているということです。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept> document.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept>」(ネイティブ相互運用性) のドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Unsafe code</source>
          <target state="translated">アンセーフ コード</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The CLR enables the ability to access native memory and do pointer arithmetic via <ph id="ph1">`unsafe`</ph> code.</source>
          <target state="translated">CLR の<ph id="ph1">`unsafe`</ph> コードによって、ネイティブ メモリにアクセスしたり、ポインターの算術演算を実行したりできるようになります。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>These operations are needed for certain algorithms and system interoperability.</source>
          <target state="translated">この操作は、特定のアルゴリズムおよびシステム相互運用性のために必要です。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm.</source>
          <target state="translated">アンセーフ コードの使用は強力ですが、システム API との相互運用を行ったり、最も効率的なアルゴリズムを実装したりする必要がなければ、推奨されません。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety.</source>
          <target state="translated">アンセーフ コードは、環境が異なると同じように実行されない可能性があり、さらにガベージ コレクターとタイプ セーフの利点が得られない場合があります。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.</source>
          <target state="translated">可能な限りアンセーフ コードのみに制限し、そのコードを徹底的にテストすることをお勧めします。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The following example is a modified version of the <ph id="ph1">`ToString()`</ph> method from the <ph id="ph2">`StringBuilder`</ph> class.</source>
          <target state="translated"><ph id="ph2">`StringBuilder`</ph> クラスから <ph id="ph1">`ToString()`</ph> メソッドを変更した例を次に示します。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>It illustrates how using <ph id="ph1">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:</source>
          <target state="translated">次のように <ph id="ph1">`unsafe`</ph> コードを使用してメモリのチャンクを直接移動して、アルゴリズムを効率的に実装する方法を示しています。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Unsafe<ept id="p2">](../../samples/csharp/snippets/tour/Unsafe.csx)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Unsafe<ept id="p2">](../../samples/csharp/snippets/tour/Unsafe.csx)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">次の手順</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If you're interested in a tour of C# features, check out <bpt id="p1">[</bpt>Tour of C#<ept id="p1">](../csharp/tour-of-csharp/index.md)</ept>.</source>
          <target state="translated">C# の機能については、「<bpt id="p1">[</bpt>C# のツアー<ept id="p1">](../csharp/tour-of-csharp/index.md)</ept>」をご覧ください。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If you're interested in a tour of F# features, check out <bpt id="p1">[</bpt>Tour of F#<ept id="p1">](../fsharp/tour.md)</ept>.</source>
          <target state="translated">F# の機能については、「<bpt id="p1">[</bpt>F# のツアー<ept id="p1">](../fsharp/tour.md)</ept>」をご覧ください。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>If you want to get started with writing code of your own, check out <bpt id="p1">[</bpt>Getting Started<ept id="p1">](getting-started.md)</ept>.</source>
          <target state="translated">独自のコードの記述を開始する場合は、「<bpt id="p1">[</bpt>作業の開始<ept id="p1">](getting-started.md)</ept>」をご覧ください。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>To learn about important components of .NET, check out <bpt id="p1">[</bpt>.NET Architectural Components<ept id="p1">](components.md)</ept>.</source>
          <target state="translated">.NET の重要なコンポーネントについては、「<bpt id="p1">[</bpt>.NET アーキテクチャ コンポーネント<ept id="p1">](components.md)</ept>」をご覧ください。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>