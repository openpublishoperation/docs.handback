<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ef2a63115f1efbe2418c348a3379fe7dd2face86</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\anchors.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d2e25c2b175059780bad8d84610bac5dd45943c9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">94ae0e65a6ef73d01b61abaca196f9a10a7fd773</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Anchors in regular expressions</source>
          <target state="translated">정규식의 앵커</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Anchors in regular expressions</source>
          <target state="translated">정규식의 앵커</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Anchors in regular expressions</source>
          <target state="translated">정규식의 앵커</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Anchors, or atomic zero-width assertions, specify a position in the string where a match must occur.</source>
          <target state="translated">앵커 또는 원자성 너비가 0인 어설션은 문자열에서 일치 항목이 나타나야 하는 위치를 지정합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>When you use an anchor in your search expression, the regular expression engine does not advance through the string or consume characters; it looks for a match in the specified position only.</source>
          <target state="translated">검색 식에서 앵커를 사용하면 정규식 엔진은 문자열을 통과하거나 문자를 사용하지 않고, 지정된 위치에서만 일치 항목을 검색합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> specifies that the match must start at the beginning of a line or string.</source>
          <target state="translated">예를 들어 <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> 기호는 줄 또는 문자열의 시작 부분에서 일치 항목 찾기를 시작하도록 지정합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Therefore, the regular expression <ph id="ph1">`^http:`</ph> matches "http:" only when it occurs at the beginning of a line.</source>
          <target state="translated">따라서 정규식 <ph id="ph1">`^http:`</ph>은 줄의 시작 부분에 나타날 때만 "http:"을 찾습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The following table lists the anchors supported by the regular expressions in .NET.</source>
          <target state="translated">다음 표에서는 .NET의 정규식에서 지원하는 앵커를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Anchor</source>
          <target state="translated">앵커</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The match must occur at the beginning of the string or line.</source>
          <target state="translated">일치 항목이 문자열 또는 줄의 시작 부분에서 시작해야 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string or line, or before \n at the end of the string or line.</source>
          <target state="translated">문자열 또는 줄의 끝 부분이나 문자열 또는 줄의 끝에 있는 \n 앞에서 일치 항목 찾기를 수행해야 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\A<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\A<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The match must occur at the beginning of the string only (no multiline support)</source>
          <target state="translated">문자열의 시작 부분에서만 일치 항목 찾기를 수행해야 합니다(여러 줄 지원 없음).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string, or before \n at the end of the string.</source>
          <target state="translated">문자열의 끝 부분이나 문자열의 끝에 있는 \n 앞에서 일치 항목 찾기를 수행해야 합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\z<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\z<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string only.</source>
          <target state="translated">일치 항목이 문자열의 끝 부분에만 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\G<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\G<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The match must start at the position where the previous match ended.</source>
          <target state="translated">일치 항목이 이전 일치 항목이 종료된 위치에서 시작해야 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\b<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\b<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The match must occur on a word boundary.</source>
          <target state="translated">일치 항목이 단어 경계에 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\B<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\B<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The match must not occur on a word boundary.</source>
          <target state="translated">일치 항목이 단어 경계에 있으면 안 됩니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Start of String or Line: ^</source>
          <target state="translated">문자열 또는 줄의 시작: ^</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> anchor specifies that the following pattern must begin at the first character position of the string.</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> 앵커는 다음 패턴이 문자열의 첫 번째 문자 위치에서 시작하도록 지정합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> with the <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option (see <bpt id="p3">[</bpt>Regular expression options<ept id="p3">](options.md)</ept>), the match must occur at the beginning of each line.</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept>를 <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 옵션과 함께 사용하는 경우(<bpt id="p3">[</bpt>정규식 옵션<ept id="p3">](options.md)</ept> 참조) 일치 항목이 각 줄의 시작 부분에서 발생해야 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">다음 예제에서는 일부 전문 야구팀이 있던 기간(년)에 대한 정보를 추출하는 정규식에서 <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> 앵커를 사용합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The example calls two overloads of the <ph id="ph1">`Regex.Matches`</ph> method:</source>
          <target state="translated">이 예제에서는 <ph id="ph1">`Regex.Matches`</ph> 메서드의 오버로드 두 개를 호출합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The call to the <bpt id="p1">[</bpt>Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> overload finds only the first substring in the input string that matches the regular expression pattern.</source>
          <target state="translated"><bpt id="p1">[</bpt>Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> 오버로드 호출은 입력 문자열에서 정규식 패턴과 일치하는 첫 번째 부분 문자열만 찾습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The call to the <bpt id="p1">[</bpt>Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> overload with the options parameter set to <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> finds all five substrings.</source>
          <target state="translated">options 매개 변수를 <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>으로 설정하여 <bpt id="p1">[</bpt>Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> 오버로드를 호출하면 부분 문자열 5개를 모두 찾습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+`</ph> is defined as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+`</ph>는 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the input string (or the beginning of the line if the method is called with the <ph id="ph1">`RegexOptions.Multiline`</ph> option).</source>
          <target state="translated">입력 문자열의 시작 부분(또는 메서드가 <ph id="ph1">`RegexOptions.Multiline`</ph> 옵션과 함께 호출될 경우 줄의 시작 부분)에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed either by zero or by one space exactly two times.</source>
          <target state="translated">단어 문자 하나 이상과 0 또는 공백 하나 순으로 정확히 두 번 나타내는 일치 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">이 그룹은 첫 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This expression also defines a second and third capturing group: The second consists of the captured word, and the third consists of the captured spaces.</source>
          <target state="translated">이 식은 두 번째 및 세 번째 캡처링 그룹도 정의합니다. 두 번째 캡처 도구는 캡처된 단어로 구성되고 세 번째는 캡처된 공백으로 구성됩니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Match a comma followed by a white-space character.</source>
          <target state="translated">쉼표, 공백 문자 순의 일치 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a space, followed by one or more word characters.</source>
          <target state="translated">단어 문자 하나 이상, 공백, 단어 문자 하나 이상 순의 일치 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This is the fourth capturing group.</source>
          <target state="translated">이 그룹은 네 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Match a comma.</source>
          <target state="translated">쉼표 하나를 찾습니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Match a space followed by four decimal digits.</source>
          <target state="translated">공백, 10 진수 4개 순의 일치 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?`</ph></source>
          <target state="translated"><ph id="ph1">`(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?`</ph></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a hyphen followed by four decimal digits or the string "present".</source>
          <target state="translated">하이픈과 10진수 4개 또는 문자열 "present" 순으로 나타나는 일치 항목 0개 또는 하나를 찾습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This is the sixth capturing group.</source>
          <target state="translated">이 그룹은 6번째 캡처 그룹입니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>It also includes a seventh capturing group.</source>
          <target state="translated">7번째 캡처 그룹도 포함됩니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a comma.</source>
          <target state="translated">쉼표 0개 또는 1개를 찾습니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(\s\d{4}(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?,?)+`</ph></source>
          <target state="translated"><ph id="ph1">`(\s\d{4}(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?,?)+`</ph></target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of the following: a space, four decimal digits, zero or one occurrence of a hyphen followed by four decimal digits or the string "present", and zero or one comma.</source>
          <target state="translated">공백, 10진수 4개, 하이픈과 10진수 4개 또는 문자열 "present", 쉼표 0개 또는 하나 순으로 나타나는 일치 항목 하나 이상을 찾습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This is the fifth capturing group.</source>
          <target state="translated">이 그룹은 5번째 캡처 그룹입니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>End of String or Line: $</source>
          <target state="translated">문자열 또는 줄의 끝: $</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string.</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> 앵커는 입력 문자열의 끝 부분이나 입력 문자열의 끝에 있는 \n 앞에서 선행 패턴을 수행하도록 지정합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> with the <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, the match can also occur at the end of a line.</source>
          <target state="translated"><bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 옵션과 함께 <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept>를 사용하면 줄의 끝 부분에서 일치 항목을 찾을 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Note that <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> matches <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> but does not match <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (the combination of carriage return and newline characters, or CR/LF).</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept>는 <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>과 일치하지만 <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept>(캐리지 리턴 및 줄 바꿈 문자 조합 또는 CR/LF)과는 일치하지 않습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To match the CR/LF character combination, include <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> in the regular expression pattern.</source>
          <target state="translated">CR/LF 문자 조합을 찾으려면 정규식 패턴에 <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept>를 포함합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following example adds the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> anchor to the regular expression pattern used in the example in the previous "Start of String or Line" section.</source>
          <target state="translated">다음 예제에서는 <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> 앵커를 이전 "문자열 또는 줄의 시작" 섹션의 예제에서 사용된 정규식 패턴에 추가합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When used with the original input string, which includes five lines of text, the <bpt id="p1">[</bpt>Regex.Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> method is unable to find a match, because the end of the first line does not match the <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept> pattern.</source>
          <target state="translated">텍스트 5줄을 포함하는 원래 입력 문자열에서 사용될 경우 <bpt id="p1">[</bpt>Regex.Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> 메서드는 일치 항목을 찾을 수 없습니다. 이는 첫째 줄의 끝 부분이 <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept> 패턴과 일치하지 않기 때문입니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>When the original input string is split into a string array, the <ph id="ph1">`Regex.Matches(String, String)`</ph> method succeeds in matching each of the five lines.</source>
          <target state="translated">원래 입력 문자열을 문자열 배열로 분할하면 <ph id="ph1">`Regex.Matches(String, String)`</ph> 메서드는 5줄의 각 줄을 찾는 데 성공합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When the <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">*</bpt>options<ept id="p2">*</ept> parameter set to <ph id="ph1">`RegexOptions.Multiline`</ph>, no matches are found because the regular expression pattern does not account for the carriage return element (\u+000D).</source>
          <target state="translated"><bpt id="p2">*</bpt>options<ept id="p2">*</ept> 매개 변수를 <ph id="ph1">`RegexOptions.Multiline`</ph>으로 설정하여 <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> 메서드를 호출하면 정규식 패턴에서 캐리지 리턴 요소(\u+000D)를 고려하지 않으므로 일치 항목이 발견되지 않습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>However, when the regular expression pattern is modified by replacing <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> with <bpt id="p2">**</bpt>\r?$<ept id="p2">**</ept>, calling the <ph id="ph2">`Regex.Matches(String, String, RegexOptions)`</ph> method with the <bpt id="p3">*</bpt>options<ept id="p3">*</ept> parameter set to <ph id="ph3">`RegexOptions.Multiline`</ph> again finds five matches.</source>
          <target state="translated">그러나 <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept>를 <bpt id="p2">**</bpt>\r?$<ept id="p2">**</ept>로 바꿔서 정규식 패턴을 수정할 경우 <bpt id="p3">*</bpt>options<ept id="p3">*</ept> 매개 변수를 <ph id="ph3">`RegexOptions.Multiline`</ph>으로 설정하여 <ph id="ph2">`Regex.Matches(String, String, RegexOptions)`</ph> 메서드를 다시 호출하면 일치 항목 5개가 발견됩니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Start of String Only: \A</source>
          <target state="translated">문자열의 시작만: \A</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> anchor specifies that a match must occur at the beginning of the input string.</source>
          <target state="translated"><bpt id="p1">**</bpt>\A<ept id="p1">**</ept> 앵커는 일치 항목 찾기가 입력 문자열의 시작 부분에서 수행되도록 지정합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>It is identical to the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> anchor, except that <bpt id="p2">**</bpt>\A<ept id="p2">**</ept> ignores the <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option.</source>
          <target state="translated"><bpt id="p2">**</bpt>\A<ept id="p2">**</ept>는 <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 옵션을 무시한다는 점을 제외하고 <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> 앵커와 동일합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Therefore, it can only match the start of the first line in a multiline input string.</source>
          <target state="translated">따라서 여러 줄 입력 문자열에서 첫 번째 줄의 시작 부분만 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The following example is similar to the examples for the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> anchors.</source>
          <target state="translated">다음 예제는 <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> 및 <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> 앵커에 대한 예제와 비슷합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">일부 전문 야구팀이 있던 기간(년)에 대한 정보를 추출하는 정규식에서 <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> 앵커를 사용합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The input string includes five lines.</source>
          <target state="translated">입력 문자열은 5줄을 포함합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The call to the <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method finds only the first substring in the input string that matches the regular expression pattern.</source>
          <target state="translated"><bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> 메서드 호출은 입력 문자열에서 정규식 패턴과 일치하는 첫 번째 부분 문자열만 찾습니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>As the example shows, the <ph id="ph1">`Multiline`</ph> option has no effect.</source>
          <target state="translated">예제에서 볼 수 있듯이 <ph id="ph1">`Multiline`</ph> 옵션은 아무 영향도 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>End of String or Before Ending Newline: \Z</source>
          <target state="translated">문자열의 끝 또는 줄 바꿈 종료 전: \Z</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> anchor specifies that a match must occur at the end of the input string, or before <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> at the end of the input string.</source>
          <target state="translated"><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> 앵커는 입력 문자열의 끝 부분이나 입력 문자열의 끝에 있는 <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> 앞에서 일치 항목 찾기를 수행하도록 지정합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>It is identical to the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> anchor, except that <bpt id="p2">**</bpt>\Z<ept id="p2">**</ept> ignores the <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option.</source>
          <target state="translated"><bpt id="p2">**</bpt>\Z<ept id="p2">**</ept>는 <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 옵션을 무시한다는 점을 제외하고 <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> 앵커와 동일합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Therefore, in a multiline string, it can only match the end of the last line, or the last line before <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</source>
          <target state="translated">따라서 여러 줄 문자열에서는 마지막 줄의 끝이나 <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> 앞의 마지막 줄만 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Note that <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> matches <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> but does not match <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (the CR/LF character combination).</source>
          <target state="translated"><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept>는 <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>과 일치하지만 <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept>(CR/LF 문자 조합)과는 일치하지 않습니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>To match CR/LF, include <bpt id="p1">**</bpt>\r?\Z<ept id="p1">**</ept> in the regular expression pattern.</source>
          <target state="translated">CR/LF를 찾으려면 정규식 패턴에 <bpt id="p1">**</bpt>\r?\Z<ept id="p1">**</ept>를 포함합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> anchor in a regular expression that is similar to the example in the previous "Start of String or Line" section, which extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">다음 예제에서는 일부 전문 야구팀이 있던 기간(년)에 대한 정보를 추출하는 이전 "문자열 또는 줄의 시작" 섹션의 예제와 비슷한 정규식에서 <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> 앵커를 사용합니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The subexpression <ph id="ph1">`\r?\Z`</ph> in the regular expression <ph id="ph2">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z`</ph> matches the end of a string, and also matches a string that ends with <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> or <bpt id="p2">**</bpt>\r\n<ept id="p2">**</ept>.</source>
          <target state="translated">정규식 <ph id="ph2">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z`</ph>의 하위 식 <ph id="ph1">`\r?\Z`</ph>는 문자열 끝과 일치하고 <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> 또는 <bpt id="p2">**</bpt>\r\n<ept id="p2">**</ept>으로 끝나는 문자열과도 일치합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>As a result, each element in the array matches the regular expression pattern.</source>
          <target state="translated">따라서 배열의 각 요소는 정규식 패턴과 일치합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>End of String Only: \z</source>
          <target state="translated">문자열의 끝만: \z</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> anchor specifies that a match must occur at the end of the input string.</source>
          <target state="translated"><bpt id="p1">**</bpt>\z<ept id="p1">**</ept> 앵커는 입력 문자열의 끝 부분에서 일치 항목 찾기를 수행하도록 지정합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Like the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> language element, <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> ignores the <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option.</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> 언어 요소와 같이 <bpt id="p2">**</bpt>\z<ept id="p2">**</ept>는 <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 옵션을 무시합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Unlike the <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> language element, <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> does not match a <bpt id="p3">**</bpt>\n<ept id="p3">**</ept> character at the end of a string.</source>
          <target state="translated"><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> 언어 요소와 달리 <bpt id="p2">**</bpt>\z<ept id="p2">**</ept>는 문자열의 끝에서 <bpt id="p3">**</bpt>\n<ept id="p3">**</ept> 문자를 찾지 않습니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Therefore, it can only match the last line of the input string.</source>
          <target state="translated">따라서 입력 문자열의 마지막 줄만 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> anchor in a regular expression that is otherwise identical to the example in the previous section, which extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">다음 예제에서는 일부 전문 야구팀이 있던 기간(년)에 대한 정보를 추출하는 이전 섹션의 예제와 동일한 정규식에서 <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> 앵커를 사용합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The example tries to match each of five elements in a string array with the regular expression pattern <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`</ph>.</source>
          <target state="translated">예제에서는 정규식 패턴 <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`</ph>를 사용하여 문자열 배열에서 요소 5개를 각각 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Two of the strings end with carriage return and line feed characters, one ends with a line feed character, and two end with neither a carriage return nor a line feed character.</source>
          <target state="translated">문자열 중 두 개는 캐리지 리턴 및 줄 바꿈 문자로 끝나고, 하나는 줄 바꿈 문자로 끝나고, 두 개는 캐리지 리턴과 줄 바꿈 문자가 둘 다 없이 끝납니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>As the output shows, only the strings without a carriage return or line feed character match the pattern.</source>
          <target state="translated">출력과 같이 캐리지 리턴이나 줄 바꿈 문자가 없는 문자열만 패턴과 일치합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Contiguous Matches: \G</source>
          <target state="translated">연속 일치: \G</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\G<ept id="p1">**</ept> anchor specifies that a match must occur at the point where the previous match ended.</source>
          <target state="translated"><bpt id="p1">**</bpt>\G<ept id="p1">**</ept> 앵커는 이전 일치 항목 찾기가 끝난 지점에서 일치 항목 찾기를 수행하도록 지정합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>When you use this anchor with the <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> or <bpt id="p2">[</bpt>Match.NextMatch<ept id="p2">](xref:System.Text.RegularExpressions.Match.NextMatch)</ept> method, it ensures that all matches are contiguous.</source>
          <target state="translated">이 앵커를 <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> 또는 <bpt id="p2">[</bpt>Match.NextMatch<ept id="p2">](xref:System.Text.RegularExpressions.Match.NextMatch)</ept> 메서드와 함께 사용하면 모든 일치 항목이 연속으로 나타납니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The following example uses a regular expression to extract the names of rodent species from a comma-delimited string.</source>
          <target state="translated">다음 예제에서는 정규식을 사용하여 쉼표로 구분된 문자열에서 설치류의 이름을 추출합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\G(\w+\s?\w*),?`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">정규식 <ph id="ph1">`\G(\w+\s?\w*),?`</ph>는 다음 테이블과 같이 해석됩니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Begin where the last match ended.</source>
          <target state="translated">마지막 일치 항목 찾기가 종료된 위치에서 시작합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Match zero or one space.</source>
          <target state="translated">0개 또는 1개의 공백을 찾습니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
          <target state="translated">0개 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by zero or one space, followed by zero or more word characters.</source>
          <target state="translated">단어 문자 하나 이상, 공백 0개 이상, 단어 문자 0개 이상 순의 일치 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">이 그룹은 첫 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a literal comma character.</source>
          <target state="translated">리터럴 쉼표 문자 0개 또는 하나를 찾습니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Word Boundary: \b</source>
          <target state="translated">단어 경계: \b</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> anchor specifies that the match must occur on a boundary between a word character (the <bpt id="p2">**</bpt>\w<ept id="p2">**</ept> language element) and a non-word character (the <bpt id="p3">**</bpt>\W<ept id="p3">**</ept> language element).</source>
          <target state="translated"><bpt id="p1">**</bpt>\b<ept id="p1">**</ept> 앵커는 단어 문자(<bpt id="p2">**</bpt>\w<ept id="p2">**</ept> 언어 요소)와 비단어 문자(<bpt id="p3">**</bpt>\W<ept id="p3">**</ept> 언어 요소) 사이 경계에서 일치 항목 찾기를 수행하도록 지정합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore.</source>
          <target state="translated">단어 문자는 영숫자 문자 및 밑줄로 구성되고, 비단어 문자는 영숫자나 밑줄이 아닌 문자입니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>(For more information, see <bpt id="p1">[</bpt>Character classes in regular expressions<ept id="p1">](classes.md)</ept>.) The match may also occur on a word boundary at the beginning or end of the string.</source>
          <target state="translated">(자세한 내용은 <bpt id="p1">[</bpt>정규식의 문자 클래스<ept id="p1">](classes.md)</ept>를 참조하세요.) 일치 항목은 문자열의 시작 또는 끝의 단어 경계에 있을 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
          <target state="translated"><bpt id="p1">**</bpt>\b<ept id="p1">**</ept> 앵커는 하위 식이 단어의 시작이나 끝이 아닌 전체 단어와 일치하는지 확인하는 데 자주 사용됩니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\bare\w*\b`</ph> in the following example illustrates this usage.</source>
          <target state="translated">다음 예제의 정규식 <ph id="ph1">`\bare\w*\b`</ph>는 이 사용법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>It matches any word that begins with the substring "are".</source>
          <target state="translated">하위 문자열 "are"로 시작하는 단어를 찾습니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The output from the example also illustrates that <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> matches both the beginning and the end of the input string.</source>
          <target state="translated">예제 출력에서는 <bpt id="p1">**</bpt>\b<ept id="p1">**</ept>가 입력 문자열의 시작 및 끝과 둘 다 일치함을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">정규식 패턴은 다음 테이블과 같이 해석됩니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match the substring "are".</source>
          <target state="translated">"are"를 찾습니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
          <target state="translated">0개 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Non-Word Boundary: \B</source>
          <target state="translated">비단어 경계: \B</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> anchor specifies that the match must not occur on a word boundary.</source>
          <target state="translated"><bpt id="p1">**</bpt>\B<ept id="p1">**</ept> 앵커는 단어 경계에서 일치 항목 찾기를 수행하지 않도록 지정합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>It is the opposite of the <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> anchor.</source>
          <target state="translated"><bpt id="p1">**</bpt>\b<ept id="p1">**</ept> 앵커와 반대 작업을 수행합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> anchor to locate occurrences of the substring "qu" in a word.</source>
          <target state="translated">다음 예제에서는 <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> 앵커를 사용하여 단어에서 부분 문자열 "qu"를 찾습니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\Bqu\w+`</ph> matches a substring that begins with a "qu" that does not start a word and that continues to the end of the word.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\Bqu\w+`</ph>는 단어를 시작하지 않고 단어의 끝으로 계속되는 "qu"로 시작하는 하위 문자열을 찾습니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">정규식 패턴은 다음 테이블과 같이 해석됩니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Do not begin the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작하지 않습니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Match the substring "qu".</source>
          <target state="translated">"qu" 하위 문자열을 찾습니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>정규식 언어 - 빠른 참조<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>정규식 옵션<ept id="p1">](options.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>