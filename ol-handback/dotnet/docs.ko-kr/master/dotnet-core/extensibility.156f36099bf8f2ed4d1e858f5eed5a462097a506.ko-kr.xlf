<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-4a95368" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7df8b8bd4ae96a344b279a2673906962beaf29a4</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\preview3\tools\extensibility.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b9b9e19d016b2cc173e1211366b205f79fe40af</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b327a2008c99637d8b87e520b68bad5ec4849bf1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model | Microsoft Docs</source>
          <target state="translated">.NET Core CLI 확장성 모델 | Microsoft 문서</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">.NET Core CLI 확장성 모델</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>CLI, extensibility, custom commands, .NET Core</source>
          <target state="translated">CLI, 확장성, 사용자 지정 명령, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model (Tooling Preview 4)</source>
          <target state="translated">.NET Core CLI 확장성 모델(Tooling Preview 4)</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic applies to Visual Studio 2017 RC - .NET Core Tools Preview 4.</source>
          <target state="translated">이 항목은 Visual Studio 2017 RC - .NET Core Tools Preview 4에 적용됩니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For the .NET Core Tools Preview 2 version, see the <bpt id="p1">[</bpt>.NET Core CLI extensibility model<ept id="p1">](../../tools/dotnet-test.md)</ept> topic.</source>
          <target state="translated">.NET Core Tools Preview 2 버전의 경우 <bpt id="p1">[</bpt>.NET Core CLI 확장성 모델<ept id="p1">](../../tools/dotnet-test.md)</ept> 항목을 참조하세요.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">개요</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This document will cover the main ways how to extend the CLI tools and explain the scenarios that drive each of them.</source>
          <target state="translated">이 문서에서는 CLI 도구를 확장하는 주요 방법 및 각 방법을 구동하는 시나리오에 대해 설명합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>It will the outline how to consume the tools as well as provide short notes on how to build both types of tools.</source>
          <target state="translated">도구를 사용하는 방법에 대해 간략하게 설명할 뿐만 아니라 두 종류의 도구를 빌드하는 방법에 대한 간단한 메모를 제공합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>How to extend CLI tools</source>
          <target state="translated">CLI 도구를 확장하는 방법</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The Preview 4 CLI tools can be extended in three main ways:</source>
          <target state="translated">Preview 4 CLI 도구는 세 가지 주요 방법으로 확장할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Via NuGet packages on a per-project basis</source>
          <target state="translated">프로젝트 단위로 NuGet 패키지 사용</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Via NuGet packages with custom targets</source>
          <target state="translated">사용자 지정 대상을 사용하여 NuGet 패키지 사용</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Via the system's PATH</source>
          <target state="translated">시스템의 PATH 사용</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The three extensibility mechanisms outlined above are not exclusive; you can use all or just one or combine them.</source>
          <target state="translated">위에서 간략하게 설명한 세 가지 확장성 메커니즘은 전체를 사용하거나, 하나만 사용하거나, 조합해서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Which one to pick depends largely on what is the goal you are trying to achieve with your extension.</source>
          <target state="translated">선택하는 방법은 확장을 통해 달성하려는 목표에 따라 크게 달라집니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Per-project based extensibility</source>
          <target state="translated">프로젝트 단위 기반 확장성</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Per-project tools are <bpt id="p1">[</bpt>framework-dependented deployments<ept id="p1">](../deploying/index.md)</ept> that are distributed as NuGet packages.</source>
          <target state="translated">프로젝트 단위 도구는 NuGet 패키지로 배포되는 <bpt id="p1">[</bpt>프레임워크 종속 배포<ept id="p1">](../deploying/index.md)</ept>입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Tools are only available in the context of the project that references them and for which they are restored; invocation outside of the context of the project (for example, outside of the directory that contains the project) will fail as the command will not be able to be found.</source>
          <target state="translated">도구는 해당 도구를 참조하고 도구가 복원되는 프로젝트의 컨텍스트에서만 사용할 수 있습니다. 프로젝트 컨텍스트 외부(예: 프로젝트를 포함하는 디렉터리 외부)에서 호출하면 명령을 찾을 수 없기 때문에 실패합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>These tools are perfect for build servers, since nothing outside of the project file is needed.</source>
          <target state="translated">이러한 도구는 빌드 서버에도 완벽한데, 프로젝트 파일 외부의 항목이 필요하지 않기 때문입니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The build process runs restore for the project it builds and tools will be available.</source>
          <target state="translated">빌드 프로세스에서는 빌드하는 프로젝트에 대해 복원을 실행하므로 도구를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Language projects, such as F#, are also in this category; after all, each project can only be written in one specific language.</source>
          <target state="translated">F#과 같은 언어 프로젝트도 이 범주에 속합니다. 결국 각 프로젝트는 하나의 특정 언어로만 작성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Finally, this extensibility model provides support for creation of tools that need access to the built output of the project.</source>
          <target state="translated">마지막으로 이 확장성 모델에서는 프로젝트의 빌드된 출력에 액세스해야 하는 도구를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For instance, various Razor view tools in <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC applications fall into this category.</source>
          <target state="translated">예를 들어 <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC 응용 프로그램의 다양한 Razor 보기 도구는 이 범주에 속합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Consuming per-project tools</source>
          <target state="translated">프로젝트 단위 도구 사용</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Consuming these tools requires you to add a <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element for each tool you want to use to your project file.</source>
          <target state="translated">이러한 도구를 사용하려면 사용할 도구 각각에 대한 <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> 요소를 프로젝트 파일에 추가해야 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Inside the <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element, you reference the package in which the tool resides and you specify the version you need.</source>
          <target state="translated"><ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> 요소 내에서는 도구가 상주하는 패키지를 참조하고 필요한 버전을 지정합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>After running <ph id="ph1">`dotnet restore`</ph>, the tool and its dependencies are restored.</source>
          <target state="translated"><ph id="ph1">`dotnet restore`</ph>를 실행하면 도구 및 해당 종속성이 복원됩니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For tools that need to load the build output of the project for execution, there is usually another dependency which is listed under the regular dependencies in the project file.</source>
          <target state="translated">프로젝트의 빌드 출력을 로드하여 실행해야 하는 도구의 경우 일반적으로 프로젝트 파일의 일반 종속성 아래에 나열되는 다른 종속성이 있습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Since the Preview 4 version of the CLI uses MSBuild as its build engine, it is recommended that these parts of the tool be written as custom MSBuild targets and tasks since that way they can take part in the overall build process.</source>
          <target state="translated">CLI의 Preview 4 버전에서는 빌드 엔진으로 MSBuild를 사용하기 때문에 전반적인 빌드 프로세스에서 포함될 수 있는 방식으로 이러한 도구 부분을 사용자 지정 MSBuild 대상 및 작업으로 작성하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Also, they can get any and all data easily that is produced via the build, for example the location of the output files, the current configuration being built etc. All of this information in Preview 4 becomes a set of MSBuild properties that can be read from any target.</source>
          <target state="translated">또한 빌드를 통해 생성된 데이터를 모두 쉽게 가져올 수 있습니다(예: 출력 파일 위치, 빌드 중인 현재 구성 등). Preview 4에서 이 정보는 모두 어떤 대상에서도 읽을 수 있는 MSBuild 속성 집합이 됩니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>We will see how to add a custom target using NuGet later in this document.</source>
          <target state="translated">이 문서의 뒷부분에 나오는 NuGet을 사용하여 사용자 지정 대상을 추가하는 방법을 살펴보겠습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Let's review an example of adding a simple tools-only tool to a simple project.</source>
          <target state="translated">간단한 도구를 추가하는 예제를 검토해 보겠습니다. 간단한 프로젝트에 도구만 추가합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Given an example command called <ph id="ph1">`dotnet-api-search`</ph> that allows you to search through the NuGet packages for the specified API, here is a console application's project file that uses that tool:</source>
          <target state="translated">다음은 NuGet 패키지에서 지정된 API를 검색할 수 있는 <ph id="ph1">`dotnet-api-search`</ph>라는 예제 명령이 지정된 경우 해당 도구를 사용하는 콘솔 응용 프로그램의 프로젝트 파일입니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element is structured in a similar way as the <ph id="ph2">`&lt;PackageReference&gt;`</ph> element.</source>
          <target state="translated"><ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> 요소는 <ph id="ph2">`&lt;PackageReference&gt;`</ph> 요소와 비슷한 방식으로 구성됩니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>It needs the package ID of the package containing the tool and its version at the very least.</source>
          <target state="translated">이 노드에는 도구와 최소 버전을 포함하는 패키지의 패키지 ID가 필요합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Building tools</source>
          <target state="translated">도구 빌드</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>As mentioned, tools are just portable console applications.</source>
          <target state="translated">앞에서 설명한 대로 도구는 단순히 이식 가능한 콘솔 응용 프로그램입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You would build one as you would build any console application.</source>
          <target state="translated">모든 콘솔 응용 프로그램을 빌드하는 것처럼 도구도 빌드합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>After you build it, you would use <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> command to create a NuGet package (nupkg) that contains your code, information about its dependencies and so on.</source>
          <target state="translated">도구를 빌드한 후에는 <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> 명령을 사용하여 코드, 종속성에 대한 정보 등을 포함하는 NuGet 패키지(nupkg)를 만듭니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The package name can be whatever the author wants, but the application inside, the actual tool binary, has to conform to the convention of <ph id="ph1">`dotnet-&lt;command&gt;`</ph> in order for <ph id="ph2">`dotnet`</ph> to be able to invoke it.</source>
          <target state="translated">패키지 이름은 작성자가 원하는 대로 지정할 수 있지만 응용 프로그램 내부 실제 도구 이진은 <ph id="ph1">`dotnet-&lt;command&gt;`</ph>의 규칙을 준수해야 <ph id="ph2">`dotnet`</ph>을 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In Preview 4 bits, the <ph id="ph1">`dotnet pack`</ph> command will not pack the <ph id="ph2">`runtimeconfig.json`</ph> file that is needed to run the tool.</source>
          <target state="translated">Preview 4 비트에서 <ph id="ph1">`dotnet pack`</ph> 명령은 도구를 실행하는 데 필요한 <ph id="ph2">`runtimeconfig.json`</ph> 파일을 압축하지 않습니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In order to package this file, you have two options:</source>
          <target state="translated">이 파일을 패키징하는 방법에는 두 가지 옵션이 있습니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Create a <ph id="ph1">`nuspec`</ph> file and use <ph id="ph2">`dotnet nuget pack`</ph> command newly available to Preview 4 CLI to include the file</source>
          <target state="translated"><ph id="ph1">`nuspec`</ph> 파일을 만들고 Preview 4 CLI에서 새로 제공되는 <ph id="ph2">`dotnet nuget pack`</ph> 명령을 사용하여 파일 포함</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Use the new <ph id="ph1">`&lt;Content&gt;`</ph> element in an <ph id="ph2">`&lt;ItemGroup&gt;`</ph> in your project file to include the file manually</source>
          <target state="translated">프로젝트 파일의 <ph id="ph2">`&lt;ItemGroup&gt;`</ph>에서 새로운 <ph id="ph1">`&lt;Content&gt;`</ph> 요소를 사용하여 파일을 수동으로 포함</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Working with nuspec files is beyond the scope of this article, however you can find a lot of good information in the <bpt id="p1">[</bpt>official NuGet docs<ept id="p1">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#the-role-and-structure-of-the-nuspec-file)</ept>.</source>
          <target state="translated">nuspec 파일을 사용하는 것은 이 문서의 범위를 벗어나지만 <bpt id="p1">[</bpt>공식 NuGet 문서<ept id="p1">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#the-role-and-structure-of-the-nuspec-file)</ept>에서 유용한 정보를 다양하게 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If you decide on the second approach, you can see the example <ph id="ph1">`csproj`</ph> file and how it is configured below:</source>
          <target state="translated">두 번째 방식을 선택하는 경우 <ph id="ph1">`csproj`</ph> 파일 예제와 아래와 같이 구성하는 방식을 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">`&lt;ItemGroup&gt;`</ph> instructs the <ph id="ph2">`dotnet pack`</ph> command to pack any <ph id="ph3">`runtimeconfig.json`</ph> files in the build output directory (designated by the <ph id="ph4">`$(OutputPath)`</ph> variable) and place it into the <ph id="ph5">`lib`</ph> folder for the built target framework.</source>
          <target state="translated">이 <ph id="ph1">`&lt;ItemGroup&gt;`</ph>은 <ph id="ph2">`dotnet pack`</ph> 명령을 사용하여 빌드 출력 디렉터리(<ph id="ph4">`$(OutputPath)`</ph> 변수에 지정됨)에서 임의의 <ph id="ph3">`runtimeconfig.json`</ph> 파일을 압축한 다음 빌드된 대상 프레임워크에 대한 <ph id="ph5">`lib`</ph> 폴더로 배치합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The built target framework is designated similarly to the output path by using a MSBuild property.</source>
          <target state="translated">빌드된 대상 프레임워크는 MSBuild 속성을 사용하여 출력 경로로 비슷하게 지정됩니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>After this is set, the resulting tool nupkg file will contain all that is needed for running the tool.</source>
          <target state="translated">이렇게 설정되면 그 결과로 도구 nupkg 파일에 도구 실행에 필요한 모든 항목이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Since tools are portable applications, the user consuming the tool has to have the version of the .NET Core libraries that the tool was built against in order to run the tool.</source>
          <target state="translated">도구는 이식 가능한 응용 프로그램이므로 도구 사용자가 도구를 실행하려면 도구가 빌드된 버전의 .NET Core 라이브러리가 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Any other dependency that the tool uses and that is not contained within the .NET Core libraries is restored and placed in the NuGet cache.</source>
          <target state="translated">도구에서 사용하고 .NET Core 라이브러리 내에서 포함되지 않은 다른 모든 종속성은 NuGet 캐시에서 복원되고 배치됩니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The entire tool is, therefore, run using the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache.</source>
          <target state="translated">따라서 전체 도구는 .NET Core 라이브러리의 어셈블리뿐만 아니라 NuGet 캐시의 어셈블리를 사용하여 실행됩니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>These kind of tools have a dependency graph that is completely separate from the dependency graph of the project that uses them.</source>
          <target state="translated">이러한 종류의 도구에는 해당 도구를 사용하는 프로젝트의 종속성 그래프와 완전히 구분되는 종속성 그래프가 있습니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The restore process will first restore the project's dependencies, and will then restore each of the tools and their dependencies.</source>
          <target state="translated">복원 프로세스에서는 먼저 프로젝트의 종속성을 복원한 다음 각 도구 및 해당 종속성을 복원합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can find richer examples and different combinations of this in the <bpt id="p1">[</bpt>.NET Core CLI repo<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.</source>
          <target state="translated">보다 풍부한 예제 및 다양한 조합은 <bpt id="p1">[</bpt>.NET Core CLI 리포지토리<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>에서 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You can also see the <bpt id="p1">[</bpt>implementation of tools used<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> in the same repo.</source>
          <target state="translated">동일한 리포지토리에서 <bpt id="p1">[</bpt>사용된 도구의 구현<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept>도 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Custom targets</source>
          <target state="translated">사용자 지정 대상</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>NuGet has had the capability to package custom MSBuild target and props files for a while now and you can find the official documentation on this on the <bpt id="p1">[</bpt>NuGet documentation site<ept id="p1">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>.</source>
          <target state="translated">NuGet에서는 현재 잠시 동안 사용자 지정 MSBuild 대상 및 속성 파일을 패키지할 수 있으며, <bpt id="p1">[</bpt>NuGet 설명서 사이트<ept id="p1">](https://docs.microsoft.com/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>에서 이에 대한 공식 설명서를 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>With the move in the CLI to using MSBuild, the same mechanism of extensibility applies to .NET Core projects.</source>
          <target state="translated">CLI에서 MSBuild를 사용하는 것으로 변환됨에 따라 확장성에 대한 동일한 메커니즘이 .NET Core 프로젝트에 적용됩니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You would use this type of extensiblity when you want to extend the build process or when you want to access any of the artifacts in the build process, such as generated files or inspect the configuration under which the build is invoked etc.</source>
          <target state="translated">빌드 프로세스를 확장하거나 빌드 프로세스에서 생성된 파일과 같은 아티팩트에 액세스하거나 빌드 호출 시 구성을 검사하려는 경우 이 유형의 확장성을 사용하게 됩니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The sample target's project file is included below for reference.</source>
          <target state="translated">참조를 위해 아래 샘플 대상의 프로젝트 파일이 표시됩니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>It shows how to use the new <ph id="ph1">`csproj`</ph> syntax for instructing <ph id="ph2">`dotnet pack`</ph> command what to package to place the targets files as well as assemblies into the <ph id="ph3">`build`</ph> folder inside the package.</source>
          <target state="translated">다음은 패키지할 항목을 지정하라는 <ph id="ph2">`dotnet pack`</ph> 명령에 대해 새로운 <ph id="ph1">`csproj`</ph> 구문을 사용하여 대상 파일과 어셈블리를 패키지 내부의 <ph id="ph3">`build`</ph> 폴더에 배치하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Take note of the <ph id="ph1">`&lt;ItemGroup&gt;`</ph> below that has the <ph id="ph2">`Label`</ph> property set to "dotnet pack instructions".</source>
          <target state="translated">아래의 <ph id="ph1">`&lt;ItemGroup&gt;`</ph>에는 "dotnet 팩 지침"으로 설정된 <ph id="ph2">`Label`</ph> 속성이 있습니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Consuming custom targets is done by providing a <ph id="ph1">`&lt;PackageReference&gt;`</ph> that points to the package and its version inside the project that is being extended.</source>
          <target state="translated">사용자 지정 대상을 사용하는 작업은 확장되고 있는 프로젝트 내부 버전과 패키지를 가리키는 <ph id="ph1">`&lt;PackageReference&gt;`</ph>를 제공함으로써 수행됩니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Unlike the tools, the custom targets package does get included into the consuming project's dependency closure.</source>
          <target state="translated">도구와 달리 사용자 지정 대상 패키지는 사용하는 프로젝트의 종속성 종료 항목에 포함됩니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Using the custom target depends solely on how you configure it.</source>
          <target state="translated">사용자 지정 대상을 사용하는 작업은 구성하는 방법에 따라 전적으로 달라집니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Since it is the usual MSBuild target, it can depend on a given target, run after another target and can also be manually invoked using the <ph id="ph1">`dotnet msbuild /t:&lt;target-name&gt;`</ph> command.</source>
          <target state="translated">일반적인 MSBuild 대상이므로 지정된 대상에 따라 달라지고, 다른 대상 이후에 실행할 수 있으며 <ph id="ph1">`dotnet msbuild /t:&lt;target-name&gt;`</ph> 명령을 사용하여 수동으로 호출할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>However, if you wish to provide a better user experience to your users, you can combine per-project tools and custom targets.</source>
          <target state="translated">그러나 사용자에게 더 나은 사용자 환경을 제공 하려는 경우 프로젝트별 도구 및 사용자 지정 대상을 결합할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In this scenario, the per-project tool would essentially just accept whatever needed parameters and would translate that into the required <ph id="ph1">`dotnet msbuild`</ph> invocation that would execute the target.</source>
          <target state="translated">이 시나리오에서 프로젝트별 도구는 기본적으로 매개 변수가 필요한 항목은 허용하고, 대상을 실행할 필수 <ph id="ph1">`dotnet msbuild`</ph> 호출로 변환합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>You can see a sample of this kind of sinergy on the <bpt id="p1">[</bpt>MVP Summit 2016 Hackathon samples<ept id="p1">](https://github.com/dotnet/MVPSummitHackathon2016)</ept> repo in the <bpt id="p2">[</bpt><ph id="ph1">`dotnet-packer`</ph><ept id="p2">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept> project.</source>
          <target state="translated">이러한 종류의 시너지 효과는 <bpt id="p2">[</bpt><ph id="ph1">`dotnet-packer`</ph><ept id="p2">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept> 프로젝트의 <bpt id="p1">[</bpt>MVP Summit 2016 Hackathon 샘플<ept id="p1">](https://github.com/dotnet/MVPSummitHackathon2016)</ept> 리포지토리에서 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility</source>
          <target state="translated">PATH 기반 확장성</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more than a single project.</source>
          <target state="translated">일반적으로 PATH 기반 확장성은 개념적으로 둘 이상의 프로젝트를 포함하는 도구가 필요한 개발 컴퓨터에 사용됩니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The main drawback of this extensions mechanism is that it is tied to the machine where the tool exists.</source>
          <target state="translated">이 확장 메커니즘의 주요 단점은 도구가 있는 컴퓨터에 연결되어 있다는 점입니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If you need it on another machine, you would have to deploy it.</source>
          <target state="translated">따라서 다른 컴퓨터에서 필요한 경우에는 배포해야 합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>This pattern of CLI toolset extensibility is very simple.</source>
          <target state="translated">CLI 도구 집합 확장성의 이 패턴은 매우 간단합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>As covered in the <bpt id="p1">[</bpt>.NET Core CLI overview<ept id="p1">](index.md)</ept>, <ph id="ph1">`dotnet`</ph> driver can run any command that is named after the <ph id="ph2">`dotnet-&lt;command&gt;`</ph> convention.</source>
          <target state="translated"><bpt id="p1">[</bpt>.NET Core CLI 개요<ept id="p1">](index.md)</ept>에서 설명한 대로 <ph id="ph1">`dotnet`</ph> 드라이버는 <ph id="ph2">`dotnet-&lt;command&gt;`</ph> 규칙에 따라 명명된 모든 명령을 실행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The default resolution logic will first probe several locations and will finally fall to the system PATH.</source>
          <target state="translated">기본 해결 논리에서는 여러 위치를 먼저 검색하고 마지막으로 시스템 PATH를 검색합니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>If the requested command exists in the system PATH and is a binary that can be invoked, <ph id="ph1">`dotnet`</ph> driver will invoke it.</source>
          <target state="translated">요청한 명령이 시스템 PATH에 있고 호출할 수 있는 이진인 경우 <ph id="ph1">`dotnet`</ph> 드라이버에서 호출합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The binary can be pretty much anything that the operating system can execute.</source>
          <target state="translated">이진은 운영 체제에서 실행할 수 있는 거의 모든 항목이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>On Unix systems, this means anything that has the execute bit set via <ph id="ph1">`chmod +x`</ph>.</source>
          <target state="translated">Unix 시스템에서는 <ph id="ph1">`chmod +x`</ph>를 통해 실행 비트를 설정하는 모든 항목을 의미하고,</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>On Windows it means anything that Windows knows how to run.</source>
          <target state="translated">Windows에서는 Windows가 실행 방법을 알고 있는 모든 항목을 의미합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>As an example, let's take a look at a very simple implementation of a <ph id="ph1">`dotnet clean`</ph> command.</source>
          <target state="translated">예를 들어 <ph id="ph1">`dotnet clean`</ph> 명령의 매우 간단한 구현을 살펴보겠습니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>We will use <ph id="ph1">`bash`</ph> to implement this command.</source>
          <target state="translated"><ph id="ph1">`bash`</ph>를 사용하여 이 명령을 구현합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The command will simply delete the <ph id="ph1">`bin/`</ph> and <ph id="ph2">`obj/`</ph> directories in the current directory.</source>
          <target state="translated">이 명령은 현재 디렉터리에서 <ph id="ph1">`bin/`</ph> 및 <ph id="ph2">`obj/`</ph> 디렉터리를 삭제하기만 합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`--lock`</ph> argument is passed to it, it will also delete <ph id="ph2">`project.lock.json`</ph> file.</source>
          <target state="translated"><ph id="ph1">`--lock`</ph> 인수가 전달되면 <ph id="ph2">`project.lock.json`</ph> 파일도 삭제합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The entirety of the command is given below.</source>
          <target state="translated">전체 명령은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>On macOS, we can save this script as <ph id="ph1">`dotnet-clean`</ph> and set its executable bit with <ph id="ph2">`chmod +x dotnet-clean`</ph>.</source>
          <target state="translated">MacOS에서는 이 스크립트를 <ph id="ph1">`dotnet-clean`</ph>으로 저장하고 <ph id="ph2">`chmod +x dotnet-clean`</ph>을 사용하여 실행 파일 비트를 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>We can then create a symbolic link to it in <ph id="ph1">`/usr/local/bin`</ph> using the command <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph>.</source>
          <target state="translated">그런 다음 <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph> 명령을 사용하여 <ph id="ph1">`/usr/local/bin`</ph>에 바로 가기 링크를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>This will make it possible to invoke the clean command using the <ph id="ph1">`dotnet clean`</ph> syntax.</source>
          <target state="translated">그러면 <ph id="ph1">`dotnet clean`</ph> 구문을 사용하여 정리 명령을 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can test this by creating an app, running <ph id="ph1">`dotnet build`</ph> on it and then running <ph id="ph2">`dotnet clean`</ph>.</source>
          <target state="translated">앱을 만들고 해당 앱에서 <ph id="ph1">`dotnet build`</ph>를 실행한 다음 <ph id="ph2">`dotnet clean`</ph>을 실행하여 테스트할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">결론</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The .NET Core CLI tools allow three main extensibility points.</source>
          <target state="translated">.NET Core CLI 도구는 세 가지 주요 확장 포인트를 허용합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The per-project tools are contained within the project's context, but they allow easy installation through restoration.</source>
          <target state="translated">프로젝트 단위 도구는 프로젝트의 컨텍스트 내에 포함되지만 복원을 통해 간편한 설치를 허용합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Custom targets allow you to easily extend the build process with custom tasks.</source>
          <target state="translated">사용자 지정 대상을 사용하면 사용자 지정 작업을 사용하여 빌드 프로세스를 쉽게 확장할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>PATH-based tools are good for general, cross-project tools that are usable on a single machine.</source>
          <target state="translated">PATH 기반 도구는 단일 컴퓨터에서 사용할 수 있는 일반적인 프로젝트 간 도구에 적합합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>