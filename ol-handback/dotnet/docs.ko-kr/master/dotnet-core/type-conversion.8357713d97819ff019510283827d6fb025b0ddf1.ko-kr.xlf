<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9f3f0dc381f8892dfb24d027ccc1f46a9b89135a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\type-conversion.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df8bad09de4109d5c7593cc8eb9155894e15738d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2fbf7b584be3088b013f751f100d30a7c7ebb1cb</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Type conversion</source>
          <target state="translated">형식 변환</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Type conversion</source>
          <target state="translated">형식 변환</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Type conversion</source>
          <target state="translated">형식 변환</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Every value has an associated type, which defines attributes such as the amount of space allocated to the value, the range of possible values it can have, and the members that it makes available.</source>
          <target state="translated">모든 값에는 연결된 형식이 있으며, 이러한 형식은 값에 할당되는 공간, 포함할 수 있는 값의 범위, 값을 통해 사용할 수 있는 멤버 등의 특성을 정의합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Many values can be expressed as more than one type.</source>
          <target state="translated">대부분의 값들은 하나 이상의 형식으로 표현될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, the value <ph id="ph1">`4`</ph> can be expressed as an integer or a floating-point value.</source>
          <target state="translated">예를 들어, <ph id="ph1">`4`</ph>라는 값은 정수 값 또는 부동 소수점 값으로 표현될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Type conversion creates a value in a new type that is equivalent to the value of an old type, but does not necessarily preserve the identity (or exact value) of the original object.</source>
          <target state="translated">형식 변환을 수행하면 이전 형식과 동일한 값을 가지는 새 형식이 만들어지지만, 원래 개체의 ID(또는 실제 값)가 항상 동일하게 유지되지는 않습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>.NET automatically supports the following conversions:</source>
          <target state="translated">.NET는 다음과 같은 변환을 자동으로 지원합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Conversion from a derived class to a base class.</source>
          <target state="translated">파생 클래스에서 기본 클래스로 변환.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This means, for example, that an instance of any class or structure can be converted to an <bpt id="p1">[</bpt>Object<ept id="p1">](xref:System.Object)</ept> instance.</source>
          <target state="translated">예를 들어, 클래스 또는 구조체 인스턴스가 <bpt id="p1">[</bpt>Object<ept id="p1">](xref:System.Object)</ept> 인스턴스로 변환될 수 있다는 의미입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This conversion does not require a casting operator.</source>
          <target state="translated">이러한 변환에는 캐스팅 연산자가 필요하지 않습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Conversion from a base class back to the original derived class.</source>
          <target state="translated">기본 클래스에서 원본 파생 클래스로 다시 변환.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>In C#, this conversion requires a casting operator.</source>
          <target state="translated">C#에서는 이러한 변환에 캐스팅 연산자가 필요합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In Visual Basic, it requires the <ph id="ph1">`CType`</ph> operator if <ph id="ph2">`Option Strict`</ph> is on.</source>
          <target state="translated">Visual Basic에서는 <ph id="ph2">`Option Strict`</ph>가 on이면 <ph id="ph1">`CType`</ph> 연산자가 필요합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Conversion from a type that implements an interface to an interface object that represents that interface.</source>
          <target state="translated">인터페이스를 구현하는 형식에서 그 인터페이스를 나타내는 인터페이스 개체로 변환.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This conversion does not require a casting operator.</source>
          <target state="translated">이러한 변환에는 캐스팅 연산자가 필요하지 않습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Conversion from an interface object back to the original type that implements that interface.</source>
          <target state="translated">인터페이스 개체에서 그 인터페이스를 구현하는 원래 형식으로 다시 변환.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In C#, this conversion requires a casting operator.</source>
          <target state="translated">C#에서는 이러한 변환에 캐스팅 연산자가 필요합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In Visual Basic, it requires the <ph id="ph1">`CType`</ph> operator if <ph id="ph2">`Option Strict`</ph> is on.</source>
          <target state="translated">Visual Basic에서는 <ph id="ph2">`Option Strict`</ph>가 on이면 <ph id="ph1">`CType`</ph> 연산자가 필요합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In addition to these automatic conversions, .NET provides several features that support custom type conversion.</source>
          <target state="translated">이러한 자동 변환 외에 .NET는 사용자 지정 형식 변환을 지원하는 몇 가지 기능을 제공합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>These include the following:</source>
          <target state="translated">이러한 요구 사항은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Implicit`</ph> operator, which defines the available widening conversions between types.</source>
          <target state="translated">사용 가능한 형식 간 확대 변환을 정의하는 <ph id="ph1">`Implicit`</ph> 연산자.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implicit conversion with the Implicit operator<ept id="p1">](#implicit-conversion-with-the-implicit-operator)</ept> section.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>암시적 연산자를 사용한 암시적 변환<ept id="p1">](#implicit-conversion-with-the-implicit-operator)</ept> 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Explicit`</ph> operator, which defines the available narrowing conversions between types.</source>
          <target state="translated">사용 가능한 형식 간 축소 변환을 정의하는 <ph id="ph1">`Explicit`</ph> 연산자.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Explicit conversion with the Explicit operator<ept id="p1">](#explicit-conversion-with-the-explicit-operator)</ept> section.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>명시적 연산자를 사용한 명시적 변환<ept id="p1">](#explicit-conversion-with-the-explicit-operator)</ept> 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface, which defines conversions to each of the base .NET data types.</source>
          <target state="translated">기본 .NET Framework 데이터 형식 각각에 대한 변환을 정의하는 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 인터페이스.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>The IConvertible interface<ept id="p1">](#the-iconvertible-interface)</ept> section.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>IConvertible 인터페이스<ept id="p1">](#the-iconvertible-interface)</ept> 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class, which provides a set of methods that implement the methods in the <ph id="ph1">`IConvertible`</ph> interface.</source>
          <target state="translated"><ph id="ph1">`IConvertible`</ph> 인터페이스의 메서드를 구현하는 메서드 집합을 제공하는 <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> 클래스.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>The Convert class<ept id="p1">](#the-convert-class)</ept> section.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>Convert 클래스<ept id="p1">](#the-convert-class)</ept> 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept> class, which is a base class that can be extended to support the conversion of a specified type to any other type.</source>
          <target state="translated">지정된 형식을 임의의 형식으로 변환하는 작업을 지원하도록 확장될 수 있는 기본 클래스인 <bpt id="p1">[</bpt>TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept> 클래스.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>The TypeConverter class<ept id="p1">](#the-typeconverter-class)</ept> section.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>TypeConverter 클래스<ept id="p1">](#the-typeconverter-class)</ept> 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Implicit conversion with the Implicit operator</source>
          <target state="translated">암시적 연산자를 사용한 암시적 변환</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Widening conversions involve the creation of a new value from the value of an existing type that has either a more restrictive range or a more restricted member list than the target type.</source>
          <target state="translated">확대 변환에는 대상 형식보다 제한적인 범위나 제한적인 멤버 목록이 있는 기존 형식의 값에서 새 값을 만드는 작업이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Widening conversions cannot result in data loss (although they may result in a loss of precision).</source>
          <target state="translated">확대 변환을 수행하면 정밀도 손실은 발생할 수 있어도 데이터 손실은 발생할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Because data cannot be lost, compilers can handle the conversion implicitly or transparently, without requiring the use of an explicit conversion method or a casting operator.</source>
          <target state="translated">데이터 손실이 발생할 수 없기 때문에 컴파일러에서 명시적 변환 메서드나 캐스팅 연산자를 사용할 필요 없이 변환을 암시적이나 투명하게 처리할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Although code that performs an implicit conversion can call a conversion method or use a casting operator, their use is not required by compilers that support implicit conversions.</source>
          <target state="translated">암시적 변환을 수행하는 코드에서 변환 메서드를 호출하거나 캐스팅 연산자를 사용할 수 있지만 암시적 변환을 지원하는 컴파일러에서는 이렇게 할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept> type supports implicit conversions from <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>Int16<ept id="p4">](xref:System.Int16)</ept>, <bpt id="p5">[</bpt>Int32<ept id="p5">](xref:System.Int32)</ept>, <bpt id="p6">[</bpt>Int64<ept id="p6">](xref:System.Int64)</ept>, <bpt id="p7">[</bpt>SByte<ept id="p7">](xref:System.SByte)</ept>, <bpt id="p8">[</bpt>UInt16<ept id="p8">](xref:System.UInt16)</ept>, <bpt id="p9">[</bpt>UInt32<ept id="p9">](xref:System.UInt32)</ept>, and <bpt id="p10">[</bpt>UInt64<ept id="p10">](xref:System.UInt64)</ept> values.</source>
          <target state="translated">예를 들어 <bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept> 형식은 <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>Int16<ept id="p4">](xref:System.Int16)</ept>, <bpt id="p5">[</bpt>Int32<ept id="p5">](xref:System.Int32)</ept>, <bpt id="p6">[</bpt>Int64<ept id="p6">](xref:System.Int64)</ept>, <bpt id="p7">[</bpt>SByte<ept id="p7">](xref:System.SByte)</ept>, <bpt id="p8">[</bpt>UInt16<ept id="p8">](xref:System.UInt16)</ept>, <bpt id="p9">[</bpt>UInt32<ept id="p9">](xref:System.UInt32)</ept> 및 <bpt id="p10">[</bpt>UInt64<ept id="p10">](xref:System.UInt64)</ept> 값에서 암시적 변환을 지원합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The following example illustrates some of these implicit conversions in assigning values to a <ph id="ph1">`Decimal`</ph> variable.</source>
          <target state="translated">다음 예제에서는 값을 <ph id="ph1">`Decimal`</ph> 변수에 할당할 때의 이러한 암시적 변환을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If a particular language compiler supports custom operators, you can also define implicit conversions in your own custom types.</source>
          <target state="translated">특정 언어 컴파일러에서 오버로드된 사용자 지정 연산자를 지원하는 경우 고유한 사용자 지정 형식에서 암시적 변환을 정의할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The following example provides a partial implementation of a signed byte data type named <ph id="ph1">`ByteWithSign`</ph> that uses sign-and-magnitude representation.</source>
          <target state="translated">다음 예제에서는 부호 및 크기 표현을 사용하는 <ph id="ph1">`ByteWithSign`</ph>이라는 부호 있는 바이트 데이터 형식을 부분적으로 구현합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>It supports implicit conversion of <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> and <bpt id="p2">[</bpt>SByte<ept id="p2">](xref:System.SByte)</ept> values to <ph id="ph1">`ByteWithSign`</ph> values.</source>
          <target state="translated">이 예제에서는 <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> 및 <bpt id="p2">[</bpt>SByte<ept id="p2">](xref:System.SByte)</ept> 값을 <ph id="ph1">`ByteWithSign`</ph> 값으로 암시적으로 변환하는 작업을 지원합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Client code can then declare a <ph id="ph1">`ByteWithSign`</ph> variable and assign it <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> and <bpt id="p2">[</bpt>SByte<ept id="p2">](xref:System.SByte)</ept> values without performing any explicit conversions or using any casting operators, as the following example shows.</source>
          <target state="translated">클라이언트 코드에서는 다음 예제와 같이 명시적 변환을 수행하거나 캐스팅 연산자를 사용하지 않고 <ph id="ph1">`ByteWithSign`</ph> 변수를 선언하여 <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> 및 <bpt id="p2">[</bpt>SByte<ept id="p2">](xref:System.SByte)</ept> 값에 할당할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Explicit conversion with the Explicit operator</source>
          <target state="translated">명시적 연산자를 사용한 명시적 변환</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Narrowing conversions involve the creation of a new value from the value of an existing type that has either a greater range or a larger member list than the target type.</source>
          <target state="translated">축소 변환에는 대상 형식보다 큰 범위나 큰 멤버 목록이 있는 기존 형식의 값에서 새 값을 만드는 작업이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Because a narrowing conversion can result in a loss of data, compilers often require that the conversion be made explicit through a call to a conversion method or a casting operator.</source>
          <target state="translated">축소 변환을 수행하면 데이터 손실이 발생할 수 있기 때문에 컴파일러에서 변환 메서드 호출이나 캐스팅 연산자를 통해 명시적으로 변환을 수행하도록 요구하는 경우가 많습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>That is, the conversion must be handled explicitly in developer code.</source>
          <target state="translated">즉, 개발자 코드에서 변환이 명시적으로 처리되어야 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The major purpose of requiring a conversion method or casting operator for narrowing conversions is to make the developer aware of the possibility of data loss or an <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept> so that it can be handled in code.</source>
          <target state="translated">축소 변환에 변환 메서드나 캐스팅 연산자를 요구하는 주요 목적은 개발자가 데이터 손실이나 <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept>의 가능성을 인식하여 코드에서 처리할 수 있게 하는 것입니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>However, some compilers can relax this requirement.</source>
          <target state="translated">그러나 일부 컴파일러에서는 이 요구 사항을 완화할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For example, in Visual Basic, if <ph id="ph1">`Option Strict`</ph> is off (its default setting), the Visual Basic compiler tries to perform narrowing conversions implicitly.</source>
          <target state="translated">예를 들어, Visual Basic에서 <ph id="ph1">`Option Strict`</ph>가 해제(기본 설정)되면 Visual Basic 컴파일러에서 축소 변환을 암시적으로 수행하려고 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept>, <bpt id="p2">[</bpt>Int64<ept id="p2">](xref:System.Int64)</ept>, and <bpt id="p3">[</bpt>UInt64<ept id="p3">](xref:System.UInt64)</ept> data types have ranges that exceed that the <bpt id="p4">[</bpt>Int32<ept id="p4">](xref:System.Int32)</ept> data type, as the following table shows.</source>
          <target state="translated">예를 들어, 다음 표와 같이 <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept>, <bpt id="p2">[</bpt>Int64<ept id="p2">](xref:System.Int64)</ept> 및 <bpt id="p3">[</bpt>UInt64<ept id="p3">](xref:System.UInt64)</ept> 데이터 형식은 <bpt id="p4">[</bpt>Int32<ept id="p4">](xref:System.Int32)</ept> 데이터 형식을 초과하는 범위를 포함합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">형식</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Comparison with range of Int32</source>
          <target state="translated">Int32 범위와 비교</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int64.MaxValue<ept id="p1">](xref:System.Int64.MaxValue)</ept> is greater than <bpt id="p2">[</bpt>Int32.MaxValue<ept id="p2">](xref:System.Int32#System_Int32_MaxValue)</ept>, and <bpt id="p3">[</bpt>Int64.MinValue<ept id="p3">](xref:System.Int64.MinValue)</ept> is less than (has a greater negative range than) <bpt id="p4">[</bpt>Int32.MinValue<ept id="p4">](xref:System.Int32#System_Int32_MinValue)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Int64.MaxValue<ept id="p1">](xref:System.Int64.MaxValue)</ept>는 <bpt id="p2">[</bpt>Int32.MaxValue<ept id="p2">](xref:System.Int32#System_Int32_MaxValue)</ept>보다 크고 <bpt id="p3">[</bpt>Int64.MinValue<ept id="p3">](xref:System.Int64.MinValue)</ept>는 <bpt id="p4">[</bpt>Int32.MinValue<ept id="p4">](xref:System.Int32#System_Int32_MinValue)</ept>보다 작습니다(즉, 큰 음의 범위를 가짐).</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept></target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt32.MaxValue<ept id="p1">](xref:System.UInt32.MaxValue)</ept> is greater than <bpt id="p2">[</bpt>Int32.MaxValue<ept id="p2">](xref:System.Int32.MaxValue)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>UInt32.MaxValue<ept id="p1">](xref:System.UInt32.MaxValue)</ept>는 <bpt id="p2">[</bpt>Int32.MaxValue<ept id="p2">](xref:System.Int32.MaxValue)</ept>보다 큽니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt64<ept id="p1">](xref:System.UInt64)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UInt64<ept id="p1">](xref:System.UInt64)</ept></target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt64.MaxValue<ept id="p1">](xref:System.UInt64.MaxValue)</ept> is greater than <bpt id="p2">[</bpt>Int32.MaxValue<ept id="p2">](xref:System.Int32.MaxValue)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>UInt64.MaxValue<ept id="p1">](xref:System.UInt64.MaxValue)</ept>는 <bpt id="p2">[</bpt>Int32.MaxValue<ept id="p2">](xref:System.Int32.MaxValue)</ept>보다 큽니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To handle such narrowing conversions, .NET allows types to define an <ph id="ph1">`Explicit`</ph> operator.</source>
          <target state="translated">이러한 축소 변환을 처리하기 위해 .NET에서는 형식에서 <ph id="ph1">`Explicit`</ph> 연산자를 정의할 수 있게 합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Individual language compilers can then implement this operator using their own syntax, or a member of the <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class can be called to perform the conversion.</source>
          <target state="translated">그러면 개별 언어 컴파일러에서 고유 구문을 사용하여 이 연산자를 구현할 수 있거나 변환을 수행하기 위해 <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> 클래스의 멤버가 호출될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>(For more information about the <ph id="ph1">`Convert`</ph> class, see <bpt id="p1">[</bpt>The Convert class<ept id="p1">](#the-convert-class)</ept> later in this topic.) The following example illustrates the use of language features to handle the explicit conversion of these potentially out-of-range integer values to <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept> values.</source>
          <target state="translated">(<ph id="ph1">`Convert`</ph> 클래스에 대한 자세한 내용은 이 항목의 뒷부분에서 <bpt id="p1">[</bpt>Convert 클래스<ept id="p1">](#the-convert-class)</ept>를 참조하세요.) 다음 예제에서는 언어 기능을 사용하여 범위를 벗어날 수 있는 이러한 정수 값을 <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept> 값으로 명시적으로 변환하는 작업을 처리하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Explicit conversions can produce different results in different languages, and these results can differ from the value returned by the corresponding <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> method.</source>
          <target state="translated">명시적 변환의 결과는 언어마다 다를 수 있으며 해당 <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> 메서드에서 반환하는 값에 따라서도 다를 수 있습니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For example, if the <bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept> value <bpt id="p2">**</bpt>12.63251<ept id="p2">**</ept> is converted to an <bpt id="p3">[</bpt>Int32<ept id="p3">](xref:System.Int32)</ept>, both the .NET <bpt id="p4">[</bpt>Convert.ToInt32(Double)<ept id="p4">](xref:System.Convert.ToInt32(System.Double))</ept> and the Visual Basic <ph id="ph1">`CInt`</ph> method method rounds the <bpt id="p5">[</bpt>Double<ept id="p5">](xref:System.Double)</ept> to return a value of <bpt id="p6">**</bpt>13<ept id="p6">**</ept>, but the C# <ph id="ph2">`(int)`</ph> operator truncates the <bpt id="p7">[</bpt>Double<ept id="p7">](xref:System.Double)</ept> to return a value of <bpt id="p8">**</bpt>12<ept id="p8">**</ept>.</source>
          <target state="translated">예를 들어, <bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept> 값 <bpt id="p2">**</bpt>12.63251<ept id="p2">**</ept>이 <bpt id="p3">[</bpt>Int32<ept id="p3">](xref:System.Int32)</ept>로 변환되면 .NET <bpt id="p4">[</bpt>Convert.ToInt32(Double)<ept id="p4">](xref:System.Convert.ToInt32(System.Double))</ept> 메서드 및 Visual Basic <ph id="ph1">`CInt`</ph> 메서드는 <bpt id="p5">[</bpt>Double<ept id="p5">](xref:System.Double)</ept>을 반올림하여 값 <bpt id="p6">**</bpt>13<ept id="p6">**</ept>을 반환하지만 C# <ph id="ph2">`(int)`</ph> 연산자는 <bpt id="p7">[</bpt>Double<ept id="p7">](xref:System.Double)</ept>을 잘라 값 <bpt id="p8">**</bpt>12<ept id="p8">**</ept>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Similarly, the C# <ph id="ph1">`(int)`</ph> operator does not support Boolean-to-integer conversion, but the Visual Basic <ph id="ph2">`CInt`</ph> method converts a value of <ph id="ph3">`true`</ph> to <bpt id="p1">**</bpt>-1<ept id="p1">**</ept>.</source>
          <target state="translated">마찬가지로 C# <ph id="ph1">`(int)`</ph> 연산자는 부울을 정수로 변환하는 것을 지원하지만 Visual Basic <ph id="ph2">`CInt`</ph> 메서드는 값 <ph id="ph3">`true`</ph>를 <bpt id="p1">**</bpt>-1<ept id="p1">**</ept>로 변환합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>On the other hand, the <bpt id="p1">[</bpt>Convert.ToInt32(Boolean)<ept id="p1">](xref:System.Convert.ToInt32(System.Boolean))</ept> method converts a value of <ph id="ph1">`true`</ph> to <bpt id="p2">**</bpt>1<ept id="p2">**</ept>.</source>
          <target state="translated">반면에 <bpt id="p1">[</bpt>Convert.ToInt32(Boolean)<ept id="p1">](xref:System.Convert.ToInt32(System.Boolean))</ept> 메서드는 값 <ph id="ph1">`true`</ph>를 <bpt id="p2">**</bpt>1<ept id="p2">**</ept>로 변환합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Most compilers allow explicit conversions to be performed in a checked or unchecked manner.</source>
          <target state="translated">대부분의 컴파일러에서는 검사 변환 방식이나 비검사 변환 방식으로 명시적 변환을 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>When a checked conversion is performed, an <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept> is thrown when the value of the type to be converted is outside the range of the target type.</source>
          <target state="translated">검사 변환을 수행하는 경우 변환할 형식의 값이 대상 형식의 범위를 벗어나면 <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept>이 throw됩니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When an unchecked conversion is performed under the same conditions, the conversion might not throw an exception, but the exact behavior becomes undefined and an incorrect value might result.</source>
          <target state="translated">같은 조건에서 비검사 변환을 수행하면 예외가 throw되지는 않지만 정확한 동작이 정의되지 않으며 잘못된 결과 값이 생성될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In C#, checked conversions can be performed by using the <ph id="ph1">`checked`</ph> keyword together with a casting operator, or by specifying the <ph id="ph2">`/checked+`</ph> compiler option.</source>
          <target state="translated">C#에서 검사 변환을 수행하려면 캐스팅 연산자와 함께 <ph id="ph1">`checked`</ph> 키워드를 사용하거나 <ph id="ph2">`/checked+`</ph> 컴파일러 옵션을 지정합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Conversely, unchecked conversions can be performed by using the <ph id="ph1">`unchecked`</ph> keyword together with the casting operator, or by specifying the <ph id="ph2">`/checked-`</ph> compiler option.</source>
          <target state="translated">반대로 비검사 변환을 수행하려면 캐스팅 연산자와 함께 <ph id="ph1">`unchecked`</ph> 키워드를 사용하거나 <ph id="ph2">`/checked-`</ph> 컴파일러 옵션을 지정합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>By default, explicit conversions are unchecked.</source>
          <target state="translated">기본적으로 명시적 변환은 검사되지 않습니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In Visual Basic, checked conversions can be performed by specifying the <ph id="ph1">`/removeintchecks-`</ph> compiler option.</source>
          <target state="translated">Visual Basic에서 확인된 변환은 <ph id="ph1">`/removeintchecks-`</ph> 컴파일러 옵션을 지정하여 수행될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Conversely, unchecked conversions can be performed by specifying the <ph id="ph1">`/removeintchecks+`</ph> compiler option.</source>
          <target state="translated">반대로 확인되지 않은 변환은 <ph id="ph1">`/removeintchecks+`</ph> 컴파일러 옵션을 지정하여 수행될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>By default, explicit conversions are checked.</source>
          <target state="translated">기본적으로 명시적 변환은 검사됩니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The following C# example uses the <ph id="ph1">`checked`</ph> and <ph id="ph2">`unchecked`</ph> keywords to illustrate the difference in behavior when a value outside the range of a <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> is converted to a <ph id="ph3">`Byte`</ph>.</source>
          <target state="translated">다음 C# 예제에서는 <ph id="ph1">`checked`</ph> 및 <ph id="ph2">`unchecked`</ph> 키워드를 사용하여 <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> 범위 밖에 있는 값을 <ph id="ph3">`Byte`</ph>로 변환할 때 동작이 어떻게 다른지 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The checked conversion throws an exception, but the unchecked conversion assigns <bpt id="p1">[</bpt>Byte.MaxValue<ept id="p1">](xref:System.Byte.MaxValue)</ept> to the <ph id="ph1">`Byte`</ph> variable.</source>
          <target state="translated">검사 변환은 예외를 throw하지만 비검사 변환은 <bpt id="p1">[</bpt>Byte.MaxValue<ept id="p1">](xref:System.Byte.MaxValue)</ept>를 <ph id="ph1">`Byte`</ph> 변수에 할당합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If a particular language compiler supports custom overloaded operators, you can also define explicit conversions in your own custom types.</source>
          <target state="translated">특정 언어 컴파일러에서 오버로드된 사용자 지정 연산자를 지원하는 경우 고유한 사용자 지정 형식에서 명시적 변환을 정의할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The following example provides a partial implementation of a signed byte data type named <ph id="ph1">`ByteWithSign`</ph> that uses sign-and-magnitude representation.</source>
          <target state="translated">다음 예제에서는 부호 및 크기 표현을 사용하는 <ph id="ph1">`ByteWithSign`</ph>이라는 부호 있는 바이트 데이터 형식을 부분적으로 구현합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>It supports explicit conversion of <bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept> and <bpt id="p2">[</bpt>UInt32<ept id="p2">](xref:System.UInt32)</ept> values to <ph id="ph1">`ByteWithSign`</ph> values.</source>
          <target state="translated">이 예제에서는 <bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept> 및 <bpt id="p2">[</bpt>UInt32<ept id="p2">](xref:System.UInt32)</ept> 값을 <ph id="ph1">`ByteWithSign`</ph> 값으로 명시적으로 변환하는 작업을 지원합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Client code can then declare a <ph id="ph1">`ByteWithSign`</ph> variable and assign it <bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept> and <bpt id="p2">[</bpt>UInt32<ept id="p2">](xref:System.UInt32)</ept> values if the assignments include a casting operator, as the following example shows.</source>
          <target state="translated">클라이언트 코드에서는 할당에 캐스팅 연산자나 변환 메서드가 포함된 경우 다음 예제와 같이 <ph id="ph1">`ByteWithSign`</ph> 변수를 선언하여 <bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept> 및 <bpt id="p2">[</bpt>UInt32<ept id="p2">](xref:System.UInt32)</ept> 값에 할당할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The IConvertible interface</source>
          <target state="translated">IConvertible 인터페이스</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>To support the conversion of any type to a common language runtime base type, .NET provides the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface.</source>
          <target state="translated">형식을 공용 언어 런타임 기본 형식으로 변환하는 작업을 지원하기 위해 .NET에서는 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 인터페이스를 제공합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The implementing type is required to provide the following:</source>
          <target state="translated">구현하는 형식은 다음을 제공해야 합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A method that returns the <bpt id="p1">[</bpt>TypeCode<ept id="p1">](xref:System.TypeCode)</ept> of the implementing type.</source>
          <target state="translated">구현하는 형식의 <bpt id="p1">[</bpt>TypeCode<ept id="p1">](xref:System.TypeCode)</ept>를 반환하는 메서드.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Methods to convert the implementing type to each common language runtime base type (<bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>DateTime<ept id="p3">](xref:System.DateTime)</ept>, <bpt id="p4">[</bpt>Decimal<ept id="p4">](xref:System.Decimal)</ept>, <bpt id="p5">[</bpt>Double<ept id="p5">](xref:System.Double)</ept>, and so on).</source>
          <target state="translated">구현하는 형식을 각 공용 언어 런타임 기본 형식(<bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>DateTime<ept id="p3">](xref:System.DateTime)</ept>, <bpt id="p4">[</bpt>Decimal<ept id="p4">](xref:System.Decimal)</ept>, <bpt id="p5">[</bpt>Double<ept id="p5">](xref:System.Double)</ept> 등)으로 변환하는 메서드.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>A generalized conversion method to convert an instance of the implementing type to another specified type.</source>
          <target state="translated">구현하는 형식의 인스턴스를 다른 지정된 형식으로 변환하는 일반화된 변환 메서드.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Conversions that are not supported should throw an <bpt id="p1">[</bpt>InvalidCastException<ept id="p1">](xref:System.InvalidCastException)</ept>.</source>
          <target state="translated">지원되지 않는 변환은 <bpt id="p1">[</bpt>InvalidCastException<ept id="p1">](xref:System.InvalidCastException)</ept>을 throw해야 합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Each common language runtime base type (that is, the <bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>DateTime<ept id="p4">](xref:System.DateTime)</ept>, <bpt id="p5">[</bpt>Decimal<ept id="p5">](xref:System.Decimal)</ept>, <bpt id="p6">[</bpt>Double<ept id="p6">](xref:System.Double)</ept>, <bpt id="p7">[</bpt>Int16<ept id="p7">](xref:System.Int16)</ept>, <bpt id="p8">[</bpt>Int32<ept id="p8">](xref:System.Int32)</ept>, <bpt id="p9">[</bpt>Int64<ept id="p9">](xref:System.Int64)</ept>, <bpt id="p10">[</bpt>SByte<ept id="p10">](xref:System.SByte)</ept>, <bpt id="p11">[</bpt>Single<ept id="p11">](xref:System.Single)</ept>, <bpt id="p12">[</bpt>String<ept id="p12">](xref:System.String)</ept>, <bpt id="p13">[</bpt>UInt16<ept id="p13">](xref:System.UInt16)</ept>, <bpt id="p14">[</bpt>UInt32<ept id="p14">](xref:System.UInt32)</ept>, and <bpt id="p15">[</bpt>UInt64<ept id="p15">](xref:System.UInt64)</ept>, as well as the <bpt id="p16">[</bpt>DBNull<ept id="p16">](xref:System.DBNull)</ept> and <bpt id="p17">[</bpt>Enum<ept id="p17">](xref:System.Enum)</ept> types, implement the <bpt id="p18">[</bpt>IConvertible<ept id="p18">](xref:System.IConvertible)</ept> interface.</source>
          <target state="translated">각 공용 언어 런타임 기본 형식(즉, <bpt id="p16">[</bpt>DBNull<ept id="p16">](xref:System.DBNull)</ept> 및 <bpt id="p17">[</bpt>Enum<ept id="p17">](xref:System.Enum)</ept> 형식뿐만 아니라 <bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>DateTime<ept id="p4">](xref:System.DateTime)</ept>, <bpt id="p5">[</bpt>Decimal<ept id="p5">](xref:System.Decimal)</ept>, <bpt id="p6">[</bpt>Double<ept id="p6">](xref:System.Double)</ept>, <bpt id="p7">[</bpt>Int16<ept id="p7">](xref:System.Int16)</ept>, <bpt id="p8">[</bpt>Int32<ept id="p8">](xref:System.Int32)</ept>, <bpt id="p9">[</bpt>Int64<ept id="p9">](xref:System.Int64)</ept>, <bpt id="p10">[</bpt>SByte<ept id="p10">](xref:System.SByte)</ept>, <bpt id="p11">[</bpt>Single<ept id="p11">](xref:System.Single)</ept>, <bpt id="p12">[</bpt>String<ept id="p12">](xref:System.String)</ept>, <bpt id="p13">[</bpt>UInt16<ept id="p13">](xref:System.UInt16)</ept>, <bpt id="p14">[</bpt>UInt32<ept id="p14">](xref:System.UInt32)</ept> 및 <bpt id="p15">[</bpt>UInt64<ept id="p15">](xref:System.UInt64)</ept>)은 <bpt id="p18">[</bpt>IConvertible<ept id="p18">](xref:System.IConvertible)</ept> 인터페이스를 구현합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>However, these are explicit interface implementations; the conversion method can be called only through an <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface variable, as the following example shows.</source>
          <target state="translated">그러나 이러한 구현은 명시적 인터페이스 구현입니다. 변환 메서드는 다음 예제와 같이 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 인터페이스 변수를 통해서만 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>This example converts an <bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept> value to its equivalent <bpt id="p2">[</bpt>Char<ept id="p2">](xref:System.Char)</ept> value.</source>
          <target state="translated">이 예제에서는 <bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept> 값을 해당하는 <bpt id="p2">[</bpt>Char<ept id="p2">](xref:System.Char)</ept> 값으로 변환합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The requirement to call the conversion method on its interface rather than on the implementing type makes explicit interface implementations relatively expensive.</source>
          <target state="translated">구현하는 형식이 아니라 인터페이스에 대해 변환 메서드를 호출해야 하기 때문에 명시적 인터페이스 구현 비용이 비교적 높아집니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Instead, we recommend that you call the appropriate member of the <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class to convert between common language runtime base types.</source>
          <target state="translated">따라서 공용 언어 런타임 기본 형식 간에 변환하려면 이 방법 대신 <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> 클래스의 적절한 멤버를 호출하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For more information, see the next section, <bpt id="p1">[</bpt>The Convert class<ept id="p1">](#the-convert-class)</ept>.</source>
          <target state="translated">자세한 내용은 다음에 나오는 <bpt id="p1">[</bpt>Convert 클래스<ept id="p1">](#the-convert-class)</ept> 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>In addition to the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface and the <bpt id="p2">[</bpt>Convert<ept id="p2">](xref:System.Convert)</ept> class provided by .NET, individual languages may also provide ways to perform conversions.</source>
          <target state="translated">.NET에서 제공하는 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 인터페이스와 <bpt id="p2">[</bpt>Convert<ept id="p2">](xref:System.Convert)</ept> 클래스 외에도 개별 언어에서 변환을 수행하는 방법을 제공할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For example, C# uses casting operators; Visual Basic uses compiler-implemented conversion functions such as <ph id="ph1">`CType`</ph>, <ph id="ph2">`CInt`</ph>, and <ph id="ph3">`DirectCast`</ph>.</source>
          <target state="translated">예를 들어, C#에서는 캐스팅 연산자가 사용되고, Visual Basic에서는 <ph id="ph1">`CType`</ph>, <ph id="ph2">`CInt`</ph> 및 <ph id="ph3">`DirectCast`</ph> 등의 컴파일러 구현 변환 함수가 사용됩니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>For the most part, the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface is designed to support conversion between the base types in .NET.</source>
          <target state="translated">대부분의 경우 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 인터페이스는 .NET에서 기본 형식 간의 변환을 지원하도록 설계되었습니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>However, the interface can also be implemented by a custom type to support conversion of that type to other custom types.</source>
          <target state="translated">그러나 사용자 지정 형식에서도 이 인터페이스를 구현하여 해당 사용자 지정 형식을 다른 사용자 지정 형식으로 변환하는 작업을 지원할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For more information, see the section <bpt id="p1">[</bpt>Custom conversions with the ChangeType method<ept id="p1">](#custom-conversions-with-the-changetype-method)</ept> later in this topic.</source>
          <target state="translated">자세한 내용은 이 항목의 뒷부분에 나오는 <bpt id="p1">[</bpt>ChangeType 메서드를 사용한 사용자 지정 변환<ept id="p1">](#custom-conversions-with-the-changetype-method)</ept> 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The Convert class</source>
          <target state="translated">Convert 클래스</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Although each base type's <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface implementation can be called to perform a type conversion, calling the methods of the <bpt id="p2">[</bpt>System.Convert<ept id="p2">](xref:System.Convert)</ept> class is the recommended language-neutral way to convert from one base type to another.</source>
          <target state="translated">각 기본 형식의 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 인터페이스 구현을 호출하여 형식 변환을 수행할 수 있지만 <bpt id="p2">[</bpt>System.Convert<ept id="p2">](xref:System.Convert)</ept> 클래스의 메서드를 호출하는 것이 한 기본 형식에서 다른 형식으로 변환하는 데 권장되는 언어와 무관한 방법입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>In addition, the <bpt id="p1">[</bpt>Convert.ChangeType(Object, Type, IFormatProvider)<ept id="p1">](xref:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider))</ept> method can be used to convert from a specified custom type to another type.</source>
          <target state="translated">또한 <bpt id="p1">[</bpt>Convert.ChangeType(Object, Type, IFormatProvider)<ept id="p1">](xref:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider))</ept> 메서드를 사용하여 지정된 사용자 지정 형식을 다른 형식으로 변환할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Conversions between base types</source>
          <target state="translated">기본 형식 간 변환</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class provides a language-neutral way to perform conversions between base types and is available to all languages that target the common language runtime.</source>
          <target state="translated"><bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> 클래스를 사용하여 언어와 무관하게 기본 형식 간의 변환을 수행할 수 있으므로 공용 언어 런타임을 대상으로 하는 모든 언어에서 이 클래스를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>It provides a complete set of methods for both widening and narrowing conversions, and throws an <bpt id="p1">[</bpt>InvalidCastException<ept id="p1">](xref:System.InvalidCastException)</ept> for conversions that are not supported (such as the conversion of a <bpt id="p2">[</bpt>DateTime<ept id="p2">](xref:System.DateTime)</ept> value to an integer value).</source>
          <target state="translated">이 클래스는 확대 및 축소 변환을 위한 전체 메서드 집합을 제공하며 지원되지 않는 변환(<bpt id="p2">[</bpt>DateTime<ept id="p2">](xref:System.DateTime)</ept> 값을 정수 값으로 변환하는 등)의 경우 <bpt id="p1">[</bpt>InvalidCastException<ept id="p1">](xref:System.InvalidCastException)</ept>을 throw합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Narrowing conversions are performed in a checked context, and an <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept> is thrown if the conversion fails.</source>
          <target state="translated">축소 변환은 확인된 컨텍스트에서 수행되며 변환이 실패하는 경우 <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept>이 throw됩니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class includes methods to convert to and from each base type, it eliminates the need to call each base type's <bpt id="p2">[</bpt>IConvertible<ept id="p2">](xref:System.IConvertible)</ept> explicit interface implementation.</source>
          <target state="translated"><bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> 클래스에 각 기본 형식으로 변환하거나 각 기본 형식에서 변환하는 메서드가 포함되어 있기 때문에 각 기본 형식의 <bpt id="p2">[</bpt>IConvertible<ept id="p2">](xref:System.IConvertible)</ept> 명시적 인터페이스 구현을 호출할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The following example illustrates the use of the <bpt id="p1">[</bpt>System.Convert<ept id="p1">](xref:System.Convert)</ept> class to perform several widening and narrowing conversions between .NET base types.</source>
          <target state="translated">다음 예제에서는 <bpt id="p1">[</bpt>System.Convert<ept id="p1">](xref:System.Convert)</ept> 클래스를 사용하여 .NET 기본 형식 간의 몇 가지 축소 및 확대 변환을 수행하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In some cases, particularly when converting to and from floating-point values, a conversion may involve a loss of precision, even though it does not throw an <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept>.</source>
          <target state="translated">부동 소수점 값으로 변환하거나 부동 소수점 값에서 변환하는 등의 경우에는 변환을 수행할 때 <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept>이 throw되지 않아도 정밀도가 손실될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The following example illustrates this loss of precision.</source>
          <target state="translated">다음 예제에서는 이러한 정밀도 손실을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In the first case, a <bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept> value has less precision (fewer significant digits) when it is converted to a <bpt id="p2">[</bpt>Double<ept id="p2">](xref:System.Double)</ept>.</source>
          <target state="translated">첫 번째 경우에 <bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept> 값은 <bpt id="p2">[</bpt>Double<ept id="p2">](xref:System.Double)</ept>로 변환될 때 정밀도가 낮아집니다(유효 자릿수가 적어짐).</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In the second case, a <bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept> value is rounded from <bpt id="p2">**</bpt>42.72<ept id="p2">**</ept> to <bpt id="p3">**</bpt>43<ept id="p3">**</ept> in order to complete the conversion.</source>
          <target state="translated">두 번째 경우에 <bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept> 값은 변환을 완료하기 위해 <bpt id="p2">**</bpt>42.72<ept id="p2">**</ept>에서 <bpt id="p3">**</bpt>43<ept id="p3">**</ept>으로 반올림됩니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For a table that lists both the widening and narrowing conversions supported by the <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class, see <bpt id="p2">[</bpt>Type conversion tables<ept id="p2">](conversion-tables.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> 클래스에서 지원하는 확대 및 축소 변환의 목록이 포함된 표는 <bpt id="p2">[</bpt>형식 변환표<ept id="p2">](conversion-tables.md)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Custom conversions with the ChangeType method</source>
          <target state="translated">ChangeType 메서드를 사용한 사용자 지정 변환</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>In addition to supporting conversions to each of the base types, the <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class can be used to convert a custom type to one or more predefined types.</source>
          <target state="translated">각 기본 형식에 대한 변환을 지원하는 것 외에도 <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> 클래스를 사용하여 사용자 지정 형식을 하나 이상의 미리 정의된 형식으로 변환할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This conversion is performed by the <bpt id="p1">[</bpt>Convert.ChangeType(Object, Type, IFormatProvider)<ept id="p1">](xref:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider))</ept> method, which in turn wraps a call to the <bpt id="p2">[</bpt>IConvertible.ToType<ept id="p2">](xref:System.IConvertible.ToType(System.Type,System.IFormatProvider))</ept> method of the value parameter.</source>
          <target state="translated">이 변환은<bpt id="p1">[</bpt>Convert.ChangeType(Object, Type, IFormatProvider)<ept id="p1">](xref:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider))</ept> 메서드에서 수행되면 값 매개 변수의 <bpt id="p2">[</bpt>IConvertible.ToType<ept id="p2">](xref:System.IConvertible.ToType(System.Type,System.IFormatProvider))</ept> 메서드에 대한 호출을 래핑합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>This means that the object represented by the value parameter must provide an implementation of the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface.</source>
          <target state="translated">즉, 값 매개 변수가 나타내는 개체가 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 인터페이스의 구현을 제공해야 합니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>Convert.ChangeType(Object, Type)<ept id="p1">](xref:System.Convert.ChangeType(System.Object,System.Type))</ept> and <bpt id="p2">[</bpt>Convert.ChangeType(Object, Type, IFormatProvider)<ept id="p2">](xref:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider))</ept> methods use a <bpt id="p3">[</bpt>Type<ept id="p3">](xref:System.Type)</ept> object to specify the target type to which value is converted, they can be used to perform a dynamic conversion to an object whose type is not known at compile time.</source>
          <target state="translated"><bpt id="p1">[</bpt>Convert.ChangeType(Object, Type)<ept id="p1">](xref:System.Convert.ChangeType(System.Object,System.Type))</ept> 및 <bpt id="p2">[</bpt>Convert.ChangeType(Object, Type, IFormatProvider)<ept id="p2">](xref:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider))</ept> 메서드는 <bpt id="p3">[</bpt>Type<ept id="p3">](xref:System.Type)</ept> 개체를 사용하여 값이 변환되는 대상 값을 지정하기 때문에, 이런 메서드를 사용하여 컴파일 타임에 형식을 알 수 없는 개체로 동적 변환을 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>However, note that the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> implementation of value must still support this conversion.</source>
          <target state="translated">하지만, 값의 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 구현에서는 이 변환을 계속 지원해야 합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The following example illustrates a possible implementation of the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface that allows a <ph id="ph1">`TemperatureCelsius`</ph> object to be converted to a <ph id="ph2">`TemperatureFahrenheit`</ph> object and vice versa.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">`TemperatureCelsius`</ph> 개체와 <ph id="ph2">`TemperatureFahrenheit`</ph> 개체 간을 변환할 수 있게 하는 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 인터페이스의 가능한 구현을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The example defines a base class, <ph id="ph1">`Temperature`</ph>, that implements the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface and overrides the <bpt id="p2">[</bpt>Object.ToString<ept id="p2">](xref:System.Object.ToString)</ept> method.</source>
          <target state="translated">이 예제에서는 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 인터페이스를 구현하고 <bpt id="p2">[</bpt>Object.ToString<ept id="p2">](xref:System.Object.ToString)</ept> 메서드를 재정의하는 기본 클래스 <ph id="ph1">`Temperature`</ph>를 정의합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The derived <ph id="ph1">`TemperatureCelsius`</ph> and <ph id="ph2">`TemperatureFahrenheit`</ph> classes each override the <ph id="ph3">`ToType`</ph> and the <ph id="ph4">`ToString`</ph> methods of the base class.</source>
          <target state="translated">파생된 <ph id="ph1">`TemperatureCelsius`</ph> 및 <ph id="ph2">`TemperatureFahrenheit`</ph> 클래스는 기본 클래스의 <ph id="ph3">`ToType`</ph> 및 <ph id="ph4">`ToString`</ph> 메서드를 각각 재정의합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The following example illustrates several calls to these <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> implementations to convert <ph id="ph1">`TemperatureCelsius`</ph> objects to <ph id="ph2">`TemperatureFahrenheit`</ph> objects and vice versa.</source>
          <target state="translated">다음 예제에서는 이러한 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 구현을 몇 번 호출하여 <ph id="ph1">`TemperatureCelsius`</ph> 개체와 <ph id="ph2">`TemperatureFahrenheit`</ph> 개체 간에 변환하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The TypeConverter class</source>
          <target state="translated">TypeConverter 클래스</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>.NET also allows you to define a type converter for a custom type by extending the <bpt id="p1">[</bpt>System.ComponentModel.TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept> class and associating the type converter with the type through a <bpt id="p2">[</bpt>System.ComponentModel.TypeConverterAttribute<ept id="p2">](xref:System.ComponentModel.TypeConverterAttribute)</ept> attribute.</source>
          <target state="translated">.NET에서는 <bpt id="p1">[</bpt>System.ComponentModel.TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept> 클래스를 확장하고 <bpt id="p2">[</bpt>System.ComponentModel.TypeConverterAttribute<ept id="p2">](xref:System.ComponentModel.TypeConverterAttribute)</ept> 특성을 통해 형식 변환기를 해당 형식과 연결하여 사용자 지정 형식에 대한 형식 변환기를 정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The following table highlights the differences between this approach and implementing the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface for a custom type.</source>
          <target state="translated">다음 테이블에는 이 방법과 사용자 지정 형식에 대한 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 인터페이스를 구현하는 방법의 차이점이 나와 있습니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Design-time support can be provided for a custom type only if it has a type converter defined for it.</source>
          <target state="translated">사용자 지정 형식에 대해 형식 변환기가 정의되어 있는 경우에만 사용자 지정 형식에 디자인 타임 지원이 제공될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Conversion using TypeConverter</source>
          <target state="translated">TypeConverter를 사용한 변환</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Conversion using IConvertible</source>
          <target state="translated">IConvertible를 사용한 변환</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Is implemented for a custom type by deriving a separate class from <bpt id="p1">[</bpt>TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept>에서 별도의 클래스를 파생시켜 사용자 지정 형식에 대해 구현됩니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This derived class is associated with the custom type by applying a <bpt id="p1">[</bpt>TypeConverterAttribute<ept id="p1">](xref:System.ComponentModel.TypeConverterAttribute)</ept> attribute.</source>
          <target state="translated">이 파생 클래스는 <bpt id="p1">[</bpt>TypeConverterAttribute<ept id="p1">](xref:System.ComponentModel.TypeConverterAttribute)</ept> 특성을 적용하여 사용자 지정 형식과 연결됩니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Is implemented by a custom type to perform conversion.</source>
          <target state="translated">변환을 수행하기 위해 사용자 지정 형식에 의해 구현됩니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>A user of the type invokes an <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> conversion method on the type.</source>
          <target state="translated">형식의 사용자가 해당 형식에 대해 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> 변환 메서드를 호출합니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Can be used both at design time and at run time.</source>
          <target state="translated">디자인 타임 및 런타임 모두에서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Can be used only at run time.</source>
          <target state="translated">런타임에서만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Uses reflection; therefore, is slower than conversion enabled by <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept>.</source>
          <target state="translated">리플렉션을 사용합니다. 따라서 <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept>로 활성화된 변환보다 느립니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Does not use reflection.</source>
          <target state="translated">리플렉션을 사용하지 않습니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Allows two-way type conversions from the custom type to other data types, and from other data types to the custom type.</source>
          <target state="translated">사용자 지정 형식에서 다른 데이터 형식으로, 다른 데이터 형식에서 사용자 지정 형식으로의 양방향 형식 변환을 허용합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>For example, a <bpt id="p1">[</bpt>TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept> defined for <ph id="ph1">`MyType`</ph> allows conversions from <ph id="ph2">`MyType`</ph> to <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept>, and from <bpt id="p3">[</bpt>String<ept id="p3">](xref:System.String)</ept> to <ph id="ph3">`MyType`</ph>.</source>
          <target state="translated">예를 들어 <ph id="ph1">`MyType`</ph>에 대해 정의된 <bpt id="p1">[</bpt>TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept>를 사용하면 <ph id="ph2">`MyType`</ph>를 <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept>으로 변환하고 <bpt id="p3">[</bpt>String<ept id="p3">](xref:System.String)</ept>을 <ph id="ph3">`MyType`</ph>로 변환할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Allows conversion from a custom type to other data types, but not from other data types to the custom type.</source>
          <target state="translated">사용자 지정 형식에서 다른 데이터 형식으로의 변환은 허용하지만, 다른 데이터 형식에서 사용자 지정 형식으로의 변환은 허용하지 않습니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For more information about using type converters to perform conversions, see <bpt id="p1">[</bpt>System.ComponentModel.TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept>.</source>
          <target state="translated">변환기를 사용하여 변환을 수행하는 방법에 대한 자세한 내용은 <bpt id="p1">[</bpt>System.ComponentModel.TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Convert<ept id="p1">](xref:System.Convert)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Convert<ept id="p1">](xref:System.Convert)</ept></target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept></target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type conversion tables<ept id="p1">](conversion-tables.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>형식 변환표<ept id="p1">](conversion-tables.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>