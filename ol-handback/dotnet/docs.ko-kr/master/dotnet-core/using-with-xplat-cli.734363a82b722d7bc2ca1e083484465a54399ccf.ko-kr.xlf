<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b5c25fc" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">240061d2515c14ba7ab733f4cc9e7e38fb2a5c7c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tutorials\using-with-xplat-cli.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">50f255f8880345510e614e3e132acf26be8dcb51</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">841571b86aa8d1a6231726592248ae06e34dfb1d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Getting started with .NET Core using the CLI | Microsoft Docs</source>
          <target state="translated">CLI를 사용하여 .NET Core 시작 | Microsoft 문서</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>A step-by-step tutorial showing how to get started with .NET Core on Windows, Linux, or macOS using the .NET Core command-line interface (CLI).</source>
          <target state="translated">.NET Core CLI(명령줄 인터페이스)를 사용하여 Windows, Linux 또는 macOS에서 .NET Core를 시작하는 방법을 보여 주는 단계별 자습서입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET Core, CLI</source>
          <target state="translated">.NET Core, CLI</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Getting started with .NET Core on Windows/Linux/macOS using the command line</source>
          <target state="translated">명령줄을 사용하여 Windows/Linux/macOS에서 .NET Core 시작</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic will show you how to start developing cross-platforms apps in your machine using the .NET Core CLI tools.</source>
          <target state="translated">이 항목에서는 .NET Core CLI 도구를 사용하여 컴퓨터에서 플랫폼 간 앱 개발을 시작하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>If you're unfamiliar with the .NET Core CLI toolset, read the <bpt id="p1">[</bpt>.NET Core SDK overview<ept id="p1">](../tools/index.md)</ept>.</source>
          <target state="translated">.NET Core CLI 도구 집합에 익숙하지 않은 경우 <bpt id="p1">[</bpt>.NET Core SDK 개요<ept id="p1">](../tools/index.md)</ept>를 읽어 보세요.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">필수 조건</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET Core SDK 1.0.0<ept id="p1">](https://www.microsoft.com/net/download/core)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>.NET Core SDK 1.0.0<ept id="p1">](https://www.microsoft.com/net/download/core)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A text editor or code editor of your choice.</source>
          <target state="translated">선택하는 텍스트 편집기 또는 코드 편집기입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Hello, Console App!</source>
          <target state="translated">Hello, 콘솔 앱!</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>First, navigate to or create a new folder with a name you like.</source>
          <target state="translated">먼저, 원하는 이름의 폴더로 이동하거나 폴더를 새로 만듭니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Hello<ept id="p1">*</ept> is the name chosen for the sample code, which can be found <bpt id="p2">[</bpt>here<ept id="p2">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/HelloMsBuild)</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>Hello<ept id="p1">*</ept>는 샘플 코드에 대해 선택한 이름으로, <bpt id="p2">[</bpt>여기<ept id="p2">](https://github.com/dotnet/docs/tree/master/samples/core/console-apps/HelloMsBuild)</ept>서 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Open up a command prompt and type the following:</source>
          <target state="translated">명령 프롬프트를 열고 다음을 입력합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Let's do a quick walkthrough:</source>
          <target state="translated">이제 간단한 연습을 해보겠습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet new`</ph><ept id="p1">](../tools/dotnet-new.md)</ept> creates an up-to-date <ph id="ph2">`Hello.csproj`</ph> project file with the dependencies necessary to build a console app.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`dotnet new`</ph><ept id="p1">](../tools/dotnet-new.md)</ept>는 콘솔 앱을 빌드하는 데 필요한 종속성이 있는 최신 <ph id="ph2">`Hello.csproj`</ph> 프로젝트 파일입니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>It also creates a <ph id="ph1">`Program.cs`</ph>, a basic file containing the entry point for the application.</source>
          <target state="translated">응용 프로그램에 대한 진입점을 포함하는 기본 파일인 <ph id="ph1">`Program.cs`</ph>도 만듭니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Hello.csproj`</ph>:</source>
          <target state="translated"><ph id="ph1">`Hello.csproj`</ph>:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The project file specifies everything that's needed to restore dependencies and build the program.</source>
          <target state="translated">프로젝트 파일은 종속성을 복원하고 프로그램을 빌드하는 데 필요한 모든 항목을 지정합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`OutputType`</ph> tag specifies that we're building an executable, in other words a console application.</source>
          <target state="translated"><ph id="ph1">`OutputType`</ph> 태그에서는 실행 파일, 즉 콘솔 응용 프로그램을 빌드하고 있음을 지정합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`TargetFramework`</ph> tag specifies what .NET runtime we're targeting.</source>
          <target state="translated"><ph id="ph1">`TargetFramework`</ph> 태그는 대상으로 지정한 .NET 런타임을 지정합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In an advance scenario, you can specify multiple target frameworks and build to all those in a single operation.</source>
          <target state="translated">고급 시나리오에서는 여러 대상 프레임워크를 지정하고 이 모든 프레임워크를 단일 작업으로 빌드할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In this tutorial, we'll stick to building only for .NET Core 1.0.</source>
          <target state="translated">이 자습서에서는 .NET Core 1.0에 대해서만 빌드합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Program.cs`</ph>:</source>
          <target state="translated"><ph id="ph1">`Program.cs`</ph>:</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Program.cs<ept id="p2">](../../../samples/core/console-apps/HelloMsBuild/Program.cs)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Program.cs<ept id="p2">](../../../samples/core/console-apps/HelloMsBuild/Program.cs)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The program starts by <ph id="ph1">`using System`</ph>, which means "bring everything in the <ph id="ph2">`System`</ph> namespace into scope for this file".</source>
          <target state="translated">프로그램은 <ph id="ph1">`using System`</ph>으로 시작됩니다. 즉, "<ph id="ph2">`System`</ph> 네임스페이스의 모든 항목을 이 파일 범위로 가져옵니다".</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`System`</ph> namespace includes basic constructs such as <ph id="ph2">`string`</ph>, or numeric types.</source>
          <target state="translated"><ph id="ph1">`System`</ph> 네임스페이스에는 <ph id="ph2">`string`</ph> 또는 숫자 형식과 같은 기본 구문이 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>We then define a namespace called <ph id="ph1">`Hello`</ph>.</source>
          <target state="translated">그런 다음 <ph id="ph1">`Hello`</ph>라는 네임스페이스를 정의합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You can change this to anything you want.</source>
          <target state="translated">이 이름은 원하는 값으로 변경할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A class named <ph id="ph1">`Program`</ph> is defined within that namespace, with a <ph id="ph2">`Main`</ph> method that takes an array of strings as its argument.</source>
          <target state="translated"><ph id="ph1">`Program`</ph>이라는 클래스는 해당 네임스페이스 내에서 인수로 문자열 배열을 사용하는 <ph id="ph2">`Main`</ph> 메서드로 정의됩니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This array contains the list of arguments passed in when the compiled program is called.</source>
          <target state="translated">이 배열에는 컴파일된 프로그램을 호출할 때 전달된 인수 목록이 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>As it is, this array is not used: all the program is doing is to write "Hello World!"</source>
          <target state="translated">이 배열은 그대로 사용되지 않습니다. 프로그램은 모두 "Hello World!"를 작성합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>to the console.</source>
          <target state="translated">표시합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Later, we'll make changes to the code that will make use of this argument.</source>
          <target state="translated">나중에 이 인수를 사용하는 코드를 변경할 예정입니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet restore`</ph><ept id="p1">](../tools/dotnet-restore.md)</ept> calls into <bpt id="p2">[</bpt>NuGet<ept id="p2">](http://nuget.org)</ept> (.NET package manager) to restore the tree of dependencies.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`dotnet restore`</ph><ept id="p1">](../tools/dotnet-restore.md)</ept>는 <bpt id="p2">[</bpt>NuGet<ept id="p2">](http://nuget.org)</ept>(.NET 패키지 관리자)을 호출하여 종속성 트리를 복원합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>NuGet analyzes the <bpt id="p1">*</bpt>Hello.csproj<ept id="p1">*</ept> file, downloads the dependencies stated in the file (or grabs them from a cache on your machine), and writes the <bpt id="p2">*</bpt>obj/project.assets.json<ept id="p2">*</ept> file.</source>
          <target state="translated">NuGet은 <bpt id="p1">*</bpt>Hello.csproj<ept id="p1">*</ept> 파일을 분석하고, 파일에 명시된 종속성을 다운로드하고(또는 컴퓨터의 캐시에서 종속성을 가져오고), <bpt id="p2">*</bpt>obj/project.assets.json<ept id="p2">*</ept> 파일을 작성합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>project.assets.json<ept id="p1">*</ept> file is necessary to be able to compile and run.</source>
          <target state="translated"><bpt id="p1">*</bpt>project.assets.json<ept id="p1">*</ept> 파일은 컴파일 및 실행하려면 필요합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>project.assets.json<ept id="p1">*</ept> file is a persisted and complete set of the graph of NuGet dependencies and other information describing an app.</source>
          <target state="translated"><bpt id="p1">*</bpt>project.assets.json<ept id="p1">*</ept> 파일은 NuGet 종속성 및 앱을 설명하는 기타 정보로 구성된 그래프의 지속적이고 전체적인 집합입니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This file is read by other tools, such as <bpt id="p1">[</bpt><ph id="ph1">`dotnet build`</ph><ept id="p1">](../tools/dotnet-build.md)</ept> and <bpt id="p2">[</bpt><ph id="ph2">`dotnet run`</ph><ept id="p2">](../tools/dotnet-run.md)</ept>, enabling them to process the source code with a correct set of NuGet dependencies and binding resolutions.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`dotnet build`</ph><ept id="p1">](../tools/dotnet-build.md)</ept> 및 <bpt id="p2">[</bpt><ph id="ph2">`dotnet run`</ph><ept id="p2">](../tools/dotnet-run.md)</ept> 같은 다른 도구에서는 이 파일을 읽고, NuGet 종속성 및 바인딩 확인의 올바른 집합으로 소스 코드를 처리합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet run`</ph><ept id="p1">](../tools/dotnet-run.md)</ept> calls <bpt id="p2">[</bpt><ph id="ph2">`dotnet build`</ph><ept id="p2">](../tools/dotnet-build.md)</ept> to ensure that the build targets have been built, and then calls <ph id="ph3">`dotnet &lt;assembly.dll&gt;`</ph> to run the target application.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`dotnet run`</ph><ept id="p1">](../tools/dotnet-run.md)</ept>은 <bpt id="p2">[</bpt><ph id="ph2">`dotnet build`</ph><ept id="p2">](../tools/dotnet-build.md)</ept>를 호출하여 빌드 대상이 빌드되었는지를 확인하고 <ph id="ph3">`dotnet &lt;assembly.dll&gt;`</ph>을 호출하여 대상 응용 프로그램을 실행합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Alternatively, you can also execute <bpt id="p1">[</bpt><ph id="ph1">`dotnet build`</ph><ept id="p1">](../tools/dotnet-build.md)</ept> to compile the code without running the build console applications.</source>
          <target state="translated">또한 <bpt id="p1">[</bpt><ph id="ph1">`dotnet build`</ph><ept id="p1">](../tools/dotnet-build.md)</ept>를 실행하여 빌드 콘솔 응용 프로그램을 실행하지 않고 코드를 컴파일할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This results in a compiled application as a DLL file that can be run with <ph id="ph1">`dotnet bin\Debug\netcoreapp1.0\Hello.dll`</ph> on Windows (use <ph id="ph2">`/`</ph> for non-Windows systems).</source>
          <target state="translated">이로 인해 Windows에서는 <ph id="ph1">`dotnet bin\Debug\netcoreapp1.0\Hello.dll`</ph>로, 다른 시스템에서는 <ph id="ph2">`/`</ph>로 실행할 수 있는 컴파일된 응용 프로그램이 DLL 파일로 만들어집니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You may specify also specify arguments to the application as you'll see later on the topic.</source>
          <target state="translated">이 항목의 뒷부분에서 살펴보겠지만, 응용 프로그램에 인수를 지정할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>As an advanced scenario, it's possible to build the application as a self-contained set of platform-specific files that can be deployed and run to a machine that doesn't necessarily have .NET Core installed.</source>
          <target state="translated">고급 시나리오에서는 .NET Core를 설치하지 않아도 되는 컴퓨터에 배포하고 실행할 수 있는 자체 포함된 플랫폼별 파일로 응용 프로그램을 빌드할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>.NET Core Application Deployment<ept id="p1">](../deploying/index.md)</ept> for details.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>.NET Core 응용 프로그램 배포<ept id="p1">](../deploying/index.md)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Augmenting the program</source>
          <target state="translated">프로그램 보강</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Let's change the program a bit.</source>
          <target state="translated">프로그램을 조금 변경해 봅시다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Fibonacci numbers are fun, so let's add that in addition to use the argument to greet the person running the app.</source>
          <target state="translated">피보나치 숫자가 흥미로우므로, 인수 사용과 함께 피보나치 숫자를 추가하여 앱을 실행하는 사람을 맞이해 봅시다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Replace the contents of your <bpt id="p1">*</bpt>Program.cs<ept id="p1">*</ept>  file with the following code:</source>
          <target state="translated"><bpt id="p1">*</bpt>Program.cs<ept id="p1">*</ept> 파일의 내용을 다음 코드로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Fibonacci<ept id="p2">](../../../samples/core/console-apps/fibonacci-msbuild/Program.cs)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>피보나치<ept id="p2">](../../../samples/core/console-apps/fibonacci-msbuild/Program.cs)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Execute <bpt id="p1">[</bpt><ph id="ph1">`dotnet build`</ph><ept id="p1">](../tools/dotnet-build.md)</ept> to compile the changes.</source>
          <target state="translated"><bpt id="p1">[</bpt> <ph id="ph1">`dotnet build`</ph> <ept id="p1">](../tools/dotnet-build.md)</ept>를 실행하여 변경 내용을 컴파일합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Run the program passing a parameter to the app:</source>
          <target state="translated">앱에 매개 변수를 전달하는 프로그램을 실행합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">됐습니다!</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You can augment <ph id="ph1">`Program.cs`</ph> any way you like.</source>
          <target state="translated">원하는 대로 <ph id="ph1">`Program.cs`</ph>를 보강할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Working with multiple files</source>
          <target state="translated">여러 파일 작업</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Single files are fine for simple one-off programs, but if you're building a more complex app, you're probably going to have multiple source files on your project Let's build off of the previous Fibonacci example by caching some Fibonacci values and add some recursive features.</source>
          <target state="translated">단순한 일회용 프로그램의 경우 단일 파일이 괜찮지만, 좀 더 복잡한 앱을 빌드하는 경우 프로젝트에 소스 파일이 여러 개 있을 수 있습니다. 일부 피보나치 값을 캐시하고 일부 재귀적 기능을 추가하여 이전의 피보나치 예제를 빌드해 봅시다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Add a new file inside the <bpt id="p1">*</bpt>Hello<ept id="p1">*</ept> directory named <bpt id="p2">*</bpt>FibonacciGenerator.cs<ept id="p2">*</ept> with the following code:</source>
          <target state="translated">다음 코드를 사용하여 <bpt id="p1">*</bpt>Hello<ept id="p1">*</ept> 디렉터리 내에 <bpt id="p2">*</bpt>FibonacciGenerator.cs<ept id="p2">*</ept>라는 새 파일을 추가합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Fibonacci Generator<ept id="p2">](../../../samples/core/console-apps/FibonacciBetterMsBuild/FibonacciGenerator.cs)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>피보나치 생성기<ept id="p2">](../../../samples/core/console-apps/FibonacciBetterMsBuild/FibonacciGenerator.cs)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Change the <ph id="ph1">`Main`</ph> method in your <bpt id="p1">*</bpt>Program.cs<ept id="p1">*</ept> file to instantiate the new class and call its method as in the following example:</source>
          <target state="translated">다음 예제에서처럼 <bpt id="p1">*</bpt>Program.cs<ept id="p1">*</ept> 파일의 <ph id="ph1">`Main`</ph> 메서드를 변경하여 새 클래스를 인스턴스화하고 메서드를 호출합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>New Program.cs<ept id="p2">](../../../samples/core/console-apps/FibonacciBetterMsBuild/Program.cs)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>New Program.cs<ept id="p2">](../../../samples/core/console-apps/FibonacciBetterMsBuild/Program.cs)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Execute <bpt id="p1">[</bpt><ph id="ph1">`dotnet build`</ph><ept id="p1">](../tools/dotnet-build.md)</ept> to compile the changes.</source>
          <target state="translated"><bpt id="p1">[</bpt> <ph id="ph1">`dotnet build`</ph> <ept id="p1">](../tools/dotnet-build.md)</ept>를 실행하여 변경 내용을 컴파일합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Run your app by executing <bpt id="p1">[</bpt><ph id="ph1">`dotnet run`</ph><ept id="p1">](../tools/dotnet-run.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`dotnet run`</ph><ept id="p1">](../tools/dotnet-run.md)</ept>을 실행하여 앱을 실행합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The following shows the program output:</source>
          <target state="translated">다음은 프로그램 출력을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">됐습니다!</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Now, you can start using the basic concepts learned here to create your own programs.</source>
          <target state="translated">이제 여기에서 배운 기본 개념을 활용하여 고유의 프로그램을 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Note that the commands and steps shown in this tutorial to run your application are used during development time only.</source>
          <target state="translated">이 자습서에 나와 있는 응용 프로그램 실행을 위한 명령과 단계는 개발하는 동안에만 사용됩니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Once you're ready to deploy your app, you'll want to take a look at the different <bpt id="p1">[</bpt>deployment strategies<ept id="p1">](../deploying/index.md)</ept> for .NET Core apps and the <bpt id="p2">[</bpt><ph id="ph1">`dotnet publish`</ph><ept id="p2">](../tools/dotnet-publish.md)</ept> command.</source>
          <target state="translated">앱을 배포할 준비가 되면 .NET Core 앱에 대한 여러 <bpt id="p1">[</bpt>배포 전략<ept id="p1">](../deploying/index.md)</ept> 및 <bpt id="p2">[</bpt> <ph id="ph1">`dotnet publish`</ph> <ept id="p2">](../tools/dotnet-publish.md)</ept> 명령을 살펴볼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Organizing and testing projects with the .NET Core CLI tools<ept id="p1">](testing-with-cli.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>.NET Core CLI 도구를 사용하여 프로젝트 구성 및 테스트<ept id="p1">](testing-with-cli.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>