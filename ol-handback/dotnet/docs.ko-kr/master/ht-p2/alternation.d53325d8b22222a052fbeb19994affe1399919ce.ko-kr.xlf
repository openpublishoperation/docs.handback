<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05b72d6a3d8ebdfb3808ba2f9a47476942686de2</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\alternation.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2346f420e8bbef8241c357ca7b884aee9e99c0b2</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6ebcecf7d7738608e1cefd169b6cd086948aeed3</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Alternation constructs in regular expressions</source>
          <target state="translated">정규식의 교체 구문</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Alternation constructs in regular expressions</source>
          <target state="translated">정규식의 교체 구문</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Alternation constructs in regular expressions</source>
          <target state="translated">정규식의 교체 구문</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Alternation constructs modify a regular expression to enable either/or or conditional matching.</source>
          <target state="translated">교체 구문은 either/or 또는 조건부 일치를 허용하도록 정규식을 수정합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>.NET supports three alternation constructs:</source>
          <target state="translated">.NET에서는 다음 세 가지 교체 구문을 지원합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Pattern matching with <bpt id="p1">**</bpt><ph id="ph1">|</ph><ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">|</ph><ept id="p1">**</ept>를 사용한 패턴 일치</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Conditional matching with <bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept>를 사용한 조건부 일치</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Conditional matching based on a valid captured group</source>
          <target state="translated">유효한 캡처 그룹을 기준으로 조건부 일치</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Pattern matching with |</source>
          <target state="translated">|를 사용한 패턴 일치</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.</source>
          <target state="translated">세로 막대(|) 문자를 사용하여 일련의 패턴 중 하나를 찾을 수 있습니다. 여기서 | 문자는 각 패턴을 구분합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Like the positive character class, the | character can be used to match any one of a number of single characters.</source>
          <target state="translated">긍정 문자 클래스처럼 | 문자를 사용하여 여러 단일 문자 중 하나를 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The following example uses both a positive character class and either/or pattern matching with the | character to locate occurrences of the words "gray" or "grey" in a string.</source>
          <target state="translated">다음 예제에서는 긍정 문자 클래스 및 either/or 패턴 일치 둘 다를 | 문자와 함께 사용하여 문자열에서 단어 "gray" 또는 "grey"를 찾습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>In this case, the | character produces a regular expression that is more verbose.</source>
          <target state="translated">이 경우 | 문자는 더 자세한 정규식을 생성합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The regular expression that uses the | character, <ph id="ph1">`\bgr(a|e)y\b,`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">| 문자를 사용하는 정규식인 <ph id="ph1">`\bgr(a|e)y\b,`</ph>는 다음 표와 같이 해석됩니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">단어 경계를 시작합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Match the characters "gr".</source>
          <target state="translated">문자 "gr"을 찾습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>`(a</source>
          <target state="translated">`(a</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>e)`</source>
          <target state="translated">e)`</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Match either an "a" or an "e".</source>
          <target state="translated">"a" 또는 "e"를 찾습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Match a "y" on a word boundary.</source>
          <target state="translated">단어 경계에서 "y"를 찾습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The | character can also be used to perform an either/or match with multiple characters or subexpressions, which can include any combination of character literals and regular expression language elements.</source>
          <target state="translated">| 문자를 사용하여 문자 리터럴과 정규식 언어 요소의 조합을 포함할 수 있는 여러 문자나 하위 식을 통해 either/or 일치 항목을 찾을 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>(The character class does not provide this functionality.) The following example uses the | character to extract either a U.S. Social Security Number (SSN), which is a 9-digit number with the format <bpt id="p1">*</bpt>ddd-dd-dddd<ept id="p1">*</ept>, or a U.S. Employer Identification Number (EIN), which is a 9-digit number with the format <bpt id="p2">*</bpt>dd-ddddddd<ept id="p2">*</ept>.</source>
          <target state="translated">문자 클래스는 이 기능을 제공하지 않습니다. 다음 예제에서는 | 문자를 사용하여 미국 SSN(사회 보장 번호)(<bpt id="p1">*</bpt>ddd-dd-dddd<ept id="p1">*</ept> 형식의 9자리 숫자) 또는 미국 EIN(고용주 식별 번호)(<bpt id="p2">*</bpt>dd-ddddddd<ept id="p2">*</ept> 형식의 9자리 숫자)을 추출합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b(\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">정규식 <ph id="ph1">`\b(\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b`</ph>는 다음 테이블과 같이 해석됩니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">단어 경계를 시작합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>`(\d{2}-\d{7}</source>
          <target state="translated">`(\d{2}-\d{7}</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>;\d{3}-\d{2}-\d{4})`</source>
          <target state="translated">;\d{3}-\d{2}-\d{4})`</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Match either of the following: two decimal digits followed by a hyphen followed by seven decimal digits; or three decimal digits, a hyphen, two decimal digits, another hyphen, and four decimal digits.</source>
          <target state="translated">10진수 2개, 하이픈, 10진수 7개 순의 일치 항목이나 10진수 3개, 하이픈, 10진수 2개, 또 다른 하이픈, 10진수 4개 순의 일치 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Conditional matching with an expression</source>
          <target state="translated">식을 사용한 조건부 일치</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.</source>
          <target state="translated">이 언어 요소는 초기 패턴을 찾을지 여부에 따라 두 패턴의 하나를 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Its syntax is:</source>
          <target state="translated">사용되는 구문은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> is the initial pattern to match, <bpt id="p2">*</bpt>yes<ept id="p2">*</ept> is the pattern to match if expression is matched, and <bpt id="p3">*</bpt>no<ept id="p3">*</ept> is the optional pattern to match if <bpt id="p4">*</bpt>expression<ept id="p4">*</ept> is not matched.</source>
          <target state="translated">여기서 <bpt id="p1">*</bpt>expression<ept id="p1">*</ept>은 일치 항목을 찾을 초기 패턴이고, <bpt id="p2">*</bpt>yes<ept id="p2">*</ept>는 expression과 일치할 경우 일치 항목을 찾을 패턴이고, <bpt id="p3">*</bpt>no<ept id="p3">*</ept>는 <bpt id="p4">*</bpt>expression<ept id="p4">*</ept>이 일치하지 않을 경우 일치 항목을 찾을 선택적 패턴입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The regular expression engine treats <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> as a zero-width assertion; that is, the regular expression engine does not advance in the input stream after it evaluates <bpt id="p2">*</bpt>expression<ept id="p2">*</ept>.</source>
          <target state="translated">정규식 엔진은 <bpt id="p1">*</bpt>expression<ept id="p1">*</ept>을 너비가 0인 어설션으로 처리합니다. 즉, 정규식 엔진은 <bpt id="p2">*</bpt>expression<ept id="p2">*</ept>을 계산한 후 입력 스트림에서 앞으로 이동하지 않습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Therefore, this construct is equivalent to the following:</source>
          <target state="translated">따라서 이 구문은 다음 구문과 같습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph2">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph2">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a zero-width assertion construct.</source>
          <target state="translated">여기서 <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>은 너비가 0인 어설션 구문입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.) Because the regular expression engine interprets <bpt id="p2">*</bpt>expression<ept id="p2">*</ept> as an anchor (a zero-width assertion), <bpt id="p3">*</bpt>expression<ept id="p3">*</ept> must either be a zero-width assertion (for more information, see <bpt id="p4">[</bpt>Anchors in regular expressions<ept id="p4">](anchors.md)</ept>) or a subexpression that is also contained in <bpt id="p5">*</bpt>yes<ept id="p5">*</ept>.</source>
          <target state="translated">(자세한 내용은 <bpt id="p1">[</bpt>정규식의 그룹화 구문<ept id="p1">](grouping.md)</ept>을 참조하세요.) 정규식 엔진이 <bpt id="p2">*</bpt>expression<ept id="p2">*</ept>을 앵커(너비가 0인 어설션)로 해석하므로 <bpt id="p3">*</bpt>expression<ept id="p3">*</ept>은 너비가 0인 어설션(자세한 내용은 <bpt id="p4">[</bpt>정규식의 앵커<ept id="p4">](anchors.md)</ept> 참조) 또는 <bpt id="p5">*</bpt>yes<ept id="p5">*</ept>에도 포함되는 하위 식이어야 합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Otherwise, the <bpt id="p1">*</bpt>yes<ept id="p1">*</ept> pattern cannot be matched.</source>
          <target state="translated">그렇지 않으면 <bpt id="p1">*</bpt>yes<ept id="p1">*</ept> 패턴을 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>expression<ept id="p1">*</ept> is a named or numbered capturing group, the alternation construct is interpreted as a capture test; for more information, see the next section, <bpt id="p2">[</bpt>Conditional matching based on a valid captured group<ept id="p2">](#conditional-matching-based-on-a-valid-captured-group)</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>expression<ept id="p1">*</ept>이 이름이나 숫자가 지정된 캡처링 그룹인 경우 교체 구문은 캡처 테스트로 해석됩니다. 자세한 내용은 다음 섹션인 <bpt id="p2">[</bpt>유효한 캡처 그룹을 기준으로 조건부 일치<ept id="p2">](#conditional-matching-based-on-a-valid-captured-group)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>In other words, the regular expression engine does not attempt to match the captured substring, but instead tests for the presence or absence of the group.</source>
          <target state="translated">즉, 정규식 엔진은 캡처된 하위 문자열을 찾으려고 하지 않지만, 대신 그룹의 존재 여부를 테스트합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following example is a variation of the example that appears in the previous section.</source>
          <target state="translated">다음 예제는 이전 섹션에 있는 예제의 변형입니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>It uses conditional matching to determine whether the first three characters after a word boundary are two digits followed by a hyphen.</source>
          <target state="translated">조건부 일치를 사용하여 단어 경계 뒤의 처음 문자 3개가 숫자 2개, 하이픈 순의 문자열인지를 확인합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>If they are, it attempts to match a U.S. Employer Identification Number (EIN).</source>
          <target state="translated">해당 문자열이면 미국 EIN(고용주 식별 번호)을 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If not, it attempts to match a U.S. Social Security Number (SSN).</source>
          <target state="translated">그러지 않으면 미국 SSN(사회 보장 번호)을 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(?(\d{2}-)\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\b(?(\d{2}-)\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b`</ph>는 다음 테이블과 같이 해석됩니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">단어 경계를 시작합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Determine whether the next three characters consist of two digits followed by a hyphen.</source>
          <target state="translated">다음 문자 3개가 숫자 2개, 하이픈 순으로 구성되는지를 확인합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If the previous pattern matches, match two digits followed by a hyphen followed by seven digits.</source>
          <target state="translated">이전 패턴이 일치하면 숫자 2개, 하이픈, 숫자 7개 순의 일치 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If the previous pattern does not match, match three decimal digits, a hyphen, two decimal digits, another hyphen, and four decimal digits.</source>
          <target state="translated">이전 패턴이 일치하지 않으면 10진수 3개, 하이픈, 10진수 2개, 또 다른 하이픈, 10진수 4개 순의 일치 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Match a word boundary.</source>
          <target state="translated">단어 경계를 찾습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Conditional matching based on a valid captured group</source>
          <target state="translated">유효한 캡처 그룹을 기준으로 조건부 일치</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.</source>
          <target state="translated">이 언어 요소는 지정된 캡처링 그룹에 일치시켰는지 여부에 따라 두 패턴 중 하나에 일치시키려고 시도합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Its syntax is:</source>
          <target state="translated">사용되는 구문은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">|</ph><ept id="p5">**</ept><bpt id="p6">_</bpt>no<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is the name and <bpt id="p2">*</bpt>number<ept id="p2">*</ept> is the number of a capturing group, <bpt id="p3">*</bpt>yes<ept id="p3">*</ept> is the expression to match if name or number has a match, and <bpt id="p4">*</bpt>no<ept id="p4">*</ept> is the optional expression to match if it does not.</source>
          <target state="translated">여기서 <bpt id="p1">*</bpt>name<ept id="p1">*</ept>은 이름이고, <bpt id="p2">*</bpt>number<ept id="p2">*</ept>는 캡처링 그룹 수이고, <bpt id="p3">*</bpt>yes<ept id="p3">*</ept>는 name 또는 number에 일치 항목이 있을 경우 일치 항목을 찾을 식이고, <bpt id="p4">*</bpt>no<ept id="p4">*</ept>는 일치 항목이 없을 경우 일치 항목을 찾을 선택적 식입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>name<ept id="p1">*</ept> does not correspond to the name of a capturing group that is used in the regular expression pattern, the alternation construct is interpreted as an expression test, as explained in the previous section.</source>
          <target state="translated"><bpt id="p1">*</bpt>name<ept id="p1">*</ept>이 정규식 패턴에서 사용되는 캡처링 그룹의 이름에 해당하지 않는 경우에는 교체 구문이 앞 섹션에서 설명한 대로 식 테스트로 해석됩니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Typically, this means that expression evaluates to <ph id="ph1">`false`</ph>.</source>
          <target state="translated">일반적으로 이는 expression이 <ph id="ph1">`false`</ph>로 계산됨을 의미합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`number`</ph> does not correspond to a numbered capturing group that is used in the regular expression pattern, the regular expression engine throws an <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept>.</source>
          <target state="translated"><ph id="ph1">`number`</ph>가 정규식 패턴에 사용되는 번호가 매겨진 캡처링 그룹에 해당하지 않는 경우 정규식 엔진이 <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept>을 throw합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The following example is a variation of the example that appears in the previous section.</source>
          <target state="translated">다음 예제는 이전 섹션에 있는 예제의 변형입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>It uses a capturing group named <ph id="ph1">`n2`</ph> that consists of two digits followed by a hyphen.</source>
          <target state="translated">숫자 2개, 하이픈 순으로 구성된 <ph id="ph1">`n2`</ph>라는 캡처 그룹을 사용합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The alternation construct tests whether this capturing group has been matched in the input string.</source>
          <target state="translated">교체 구문은 입력 문자열에서 이 캡처 그룹이 일치했는지를 테스트합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If it has, the alternation construct attempts to match the last seven digits of a nine-digit U.S. Employer Identification Number (EIN).</source>
          <target state="translated">일치한다면 교체 구문은 9자리 미국 EIN(고용주 식별 번호)을 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If it has not, it attempts to match a nine-digit U.S. Social Security Number (SSN).</source>
          <target state="translated">일치하지 않는다면 9자리 미국 SSN(사회 보장 번호)을 찾으려고 합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(?&lt;n2&gt;\d{2}-)*(?(n2)\d{7}|\d{3}-\d{2}-\d{4})\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\b(?&lt;n2&gt;\d{2}-)*(?(n2)\d{7}|\d{3}-\d{2}-\d{4})\b`</ph>는 다음 테이블과 같이 해석됩니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Start at a word boundary.</source>
          <target state="translated">단어 경계를 시작합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of two digits followed by a hyphen.</source>
          <target state="translated">숫자 2개, 하이픈 순의 일치 항목 0개 또는 1개를 찾습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`n2`</ph>.</source>
          <target state="translated">이 캡처링 그룹의 이름을 <ph id="ph1">`n2`</ph>로 지정합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Test whether <ph id="ph1">`n2`</ph> was matched in the input string.</source>
          <target state="translated"><ph id="ph1">`n2`</ph>가 입력 문자열에서 일치하는지 여부를 테스트합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`n2`</ph> was matched, match seven decimal digits.</source>
          <target state="translated"><ph id="ph1">`n2`</ph>가 일치하는 경우 일곱 개의 10진수를 일치시킵니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>;\d{3}-\d{2}-\d{4}`</source>
          <target state="translated">;\d{3}-\d{2}-\d{4}`</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`n2`</ph> was not matched, match three decimal digits, a hyphen, two decimal digits, another hyphen, and four decimal digits.</source>
          <target state="translated"><ph id="ph1">`n2`</ph>가 일치하지 않는 경우 세 10진수, 하이픈, 두 10진수, 다른 하이픈 및 네 10진수를 일치시킵니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Match a word boundary.</source>
          <target state="translated">단어 경계를 찾습니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A variation of this example that uses a numbered group instead of a named group is shown in the following example.</source>
          <target state="translated">다음 예제에서는 명명된 그룹 대신 번호가 있는 그룹을 사용하는 이 예제의 변형을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Its regular expression pattern is <ph id="ph1">`\b(\d{2}-)*(?(1)\d{7}|\d{3}-\d{2}-\d{4})\b`</ph>.</source>
          <target state="translated">정규식 패턴은 <ph id="ph1">`\b(\d{2}-)*(?(1)\d{7}|\d{3}-\d{2}-\d{4})\b`</ph>입니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>정규식 언어 - 빠른 참조<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>