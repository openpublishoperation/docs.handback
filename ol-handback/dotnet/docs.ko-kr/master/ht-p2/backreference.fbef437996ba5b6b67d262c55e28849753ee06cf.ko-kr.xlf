<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f55ea60d11abcfce4b5fb502e66c513646707bef</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\backreference.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">691d2bcc2a0c4c50077ae53c30668b5a43354d9d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">23fb9a7caca026521deb9b9604f4d568d9e3fb7a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Backreference constructs in regular expressions</source>
          <target state="translated">정규식의 역참조 구문</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Backreference constructs in regular expressions</source>
          <target state="translated">정규식의 역참조 구문</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Backreference constructs in regular expressions</source>
          <target state="translated">정규식의 역참조 구문</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Backreferences provide a convenient way to identify a repeated character or substring within a string.</source>
          <target state="translated">역참조는 문자열 내에서 반복된 문자 또는 부분 문자열을 식별하는 편리한 방법을 제공합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, if the input string contains multiple occurrences of an arbitrary substring, you can match the first occurrence with a capturing group, and then use a backreference to match subsequent occurrences of the substring.</source>
          <target state="translated">예를 들어 입력 문자열에 임의의 부분 문자열이 여러 번 포함되어 있으면 첫 번째 발생을 캡처링 그룹과 일치시킨 다음 역참조를 사용하여 부분 문자열의 후속 발생을 일치시킬 수 있습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A separate syntax is used to refer to named and numbered capturing groups in replacement strings.</source>
          <target state="translated">대체 문자열에서 명명된 캡처링 그룹과 번호가 매겨진 캡처링 그룹을 참조하기 위해 별도의 구문이 사용됩니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Substitutions in regular expressions<ept id="p1">](substitutions.md)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>정규식의 대체<ept id="p1">](substitutions.md)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>.NET defines separate language elements to refer to numbered and named capturing groups.</source>
          <target state="translated">.NET에서는 번호가 매겨진 캡처링 그룹과 명명된 캡처링 그룹을 참조하기 위해 별도의 언어 요소를 정의합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For more information about capturing groups, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">캡처링 그룹에 대한 자세한 내용은 <bpt id="p1">[</bpt>정규식의 그룹화 구문<ept id="p1">](grouping.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Numbered Backreferences</source>
          <target state="translated">번호가 매겨진 역참조</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A numbered backreference uses the following syntax:</source>
          <target state="translated">번호가 매겨진 역참조에는 다음 구문이 사용됩니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><ph id="ph1">*</ph><bpt id="p1">*</bpt><ph id="ph2">\*</ph><ept id="p1">*</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept></source>
          <target state="translated"><ph id="ph1">*</ph><bpt id="p1">*</bpt><ph id="ph2">\*</ph><ept id="p1">*</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>number<ept id="p1">*</ept> is the ordinal position of the capturing group in the regular expression.</source>
          <target state="translated">여기서 <bpt id="p1">*</bpt>number<ept id="p1">*</ept>는 정규식에서 캡처링 그룹의 서수 위치입니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`\4`</ph> matches the contents of the fourth capturing group.</source>
          <target state="translated">예를 들어 <ph id="ph1">`\4`</ph>는 네 번째 캡처링 그룹의 내용을 찾습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>number<ept id="p1">*</ept> is not defined in the regular expression pattern, a parsing error occurs, and the regular expression engine throws an <bpt id="p2">[</bpt>ArgumentException<ept id="p2">](xref:System.ArgumentException)</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>number<ept id="p1">*</ept>가 정규식 패턴에서 정의되지 않은 경우 구문 분석 오류가 발생하고 정규식 엔진이 <bpt id="p2">[</bpt>ArgumentException<ept id="p2">](xref:System.ArgumentException)</ept>을 throw합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b(\w+)\s\1`</ph> is valid, because <ph id="ph2">`(\w+)`</ph> is the first and only capturing group in the expression.</source>
          <target state="translated">예를 들어 <ph id="ph1">`\b(\w+)\s\1`</ph> 정규식은 <ph id="ph2">`(\w+)`</ph>가 식의 첫 번째이자 유일한 캡처링 그룹이기 때문에 유효합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>On the other hand, <ph id="ph1">`\b(\w+)\s\2`</ph> is invalid and throws an argument exception, because there is no capturing group numbered <ph id="ph2">`\2`</ph>.</source>
          <target state="translated">반면에 <ph id="ph1">`\b(\w+)\s\2`</ph>는 <ph id="ph2">`\2`</ph>로 번호가 매겨진 캡처링 그룹이 없기 때문에 유효하지 않으며 인수 예외를 throw합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Note the ambiguity between octal escape codes (such as <ph id="ph1">`\16`</ph>) and *<bpt id="p1">*</bpt><ph id="ph2">\*</ph><ept id="p1">*</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> backreferences that use the same notation.</source>
          <target state="translated">8진수 이스케이프 코드(예: <ph id="ph1">`\16`</ph>)와 동일한 표기법을 사용하는 *<bpt id="p1">*</bpt><ph id="ph2">\*</ph><ept id="p1">*</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> 역참조 간의 모호성에 유의하세요.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This ambiguity is resolved as follows:</source>
          <target state="translated">이러한 모호성은 다음과 같이 해결됩니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The expressions <ph id="ph1">`\1`</ph> through <ph id="ph2">`\9`</ph> are always interpreted as backreferences, and not as octal codes.</source>
          <target state="translated"><ph id="ph1">`\1`</ph>에서 <ph id="ph2">`\9`</ph> 사이의 식은 항상 8진수 코드가 아니라 역참조로 해석됩니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>If the first digit of a multidigit expression is 8 or 9 (such as <ph id="ph1">`\80`</ph> or <ph id="ph2">`\91`</ph>), the expression as interpreted as a literal.</source>
          <target state="translated">다중 숫자 식의 첫 번째 숫자가 8 또는 9이면(예: <ph id="ph1">`\80`</ph> 또는 <ph id="ph2">`\91`</ph>) 식은 리터럴로 해석됩니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Expressions from <ph id="ph1">`\10`</ph> and greater are considered backreferences if there is a backreference corresponding to that number; otherwise, they are interpreted as octal codes.</source>
          <target state="translated"><ph id="ph1">`\10`</ph> 이상인 식은 이 숫자에 해당하는 역참조가 있을 경우 역참조로 간주되고, 없을 경우 8진수 코드로 해석됩니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If a regular expression contains a backreference to an undefined group number, a parsing error occurs, and the regular expression engine throws an <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept>.</source>
          <target state="translated">정규식에 정의되지 않은 그룹 번호에 대한 역참조가 포함되어 있으면 구문 분석 오류가 발생하고 정규식 엔진이 <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept>을 throw합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If the ambiguity is a problem, you can use the <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> notation, which is unambiguous and cannot be confused with octal character codes.</source>
          <target state="translated">모호성 문제가 발생하는 경우 명확하고 8진수 문자 코드와 혼동되지 않는 <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> 표기법을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Similarly, hexadecimal codes such as <ph id="ph1">`\xdd`</ph> are unambiguous and cannot be confused with backreferences.</source>
          <target state="translated">마찬가지로, <ph id="ph1">`\xdd`</ph> 등의 16진수 코드는 명확하며 역참조와 혼동되지 않습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The following example finds doubled word characters in a string.</source>
          <target state="translated">다음 예제에서는 문자열에서 2배 워드 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>It defines a regular expression, <ph id="ph1">`(\w)\1,`</ph> which consists of the following elements.</source>
          <target state="translated">다음과 같은 요소로 구성된 <ph id="ph1">`(\w)\1,`</ph> 정규식을 정의합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Element</source>
          <target state="translated">요소</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Match a word character and assign it to the first capturing group.</source>
          <target state="translated">단어 문자를 찾아 첫 번째 캡처링 그룹에 할당합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Match the next character that is the same as the value of the first capturing group.</source>
          <target state="translated">첫 번째 캡처링 그룹의 값과 일치하는 다음 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Named Backreferences</source>
          <target state="translated">명명된 역참조</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A named backreference is defined by using the following syntax:</source>
          <target state="translated">명명된 역참조는 다음 구문을 사용하여 정의됩니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\k'<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>'<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\k'<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>'<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is the name of a capturing group defined in the regular expression pattern.</source>
          <target state="translated">여기서 <bpt id="p1">*</bpt>name<ept id="p1">*</ept>은 정규식 패턴에 정의된 캡처링 그룹의 이름입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is not defined in the regular expression pattern, a parsing error occurs, and the regular expression engine throws an <bpt id="p2">[</bpt>ArgumentException<ept id="p2">](xref:System.ArgumentException)</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>name<ept id="p1">*</ept>이 정규식 패턴에서 정의되지 않은 경우 구문 분석 오류가 발생하고 정규식 엔진이 <bpt id="p2">[</bpt>ArgumentException<ept id="p2">](xref:System.ArgumentException)</ept>을 throw합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The following example finds doubled word characters in a string.</source>
          <target state="translated">다음 예제에서는 문자열에서 2배 워드 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>It defines a regular expression, <ph id="ph1">`(?&lt;char&gt;\w)\k&lt;char&gt;`</ph>, which consists of the following elements.</source>
          <target state="translated">다음과 같은 요소로 구성된 <ph id="ph1">`(?&lt;char&gt;\w)\k&lt;char&gt;`</ph> 정규식을 정의합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Element</source>
          <target state="translated">요소</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Match a word character and assign it to a capturing group named char.</source>
          <target state="translated">단어 문자를 찾아 이름이 char인 캡처링 그룹에 할당합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Match the next character that is the same as the value of the char capturing group.</source>
          <target state="translated">char 캡처링 그룹의 값과 일치하는 다음 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Note that <bpt id="p1">*</bpt>name<ept id="p1">*</ept> can also be the string representation of a number.</source>
          <target state="translated"><bpt id="p1">*</bpt>name<ept id="p1">*</ept>은 숫자의 문자열 표현일 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For example, the following example uses the regular expression <ph id="ph1">`(?&lt;2&gt;\w)\k&lt;2&gt;`</ph> to find doubled word characters in a string.</source>
          <target state="translated">예를 들어 다음 예제에서는 <ph id="ph1">`(?&lt;2&gt;\w)\k&lt;2&gt;`</ph> 정규식을 사용하여 문자열에서 2배 워드 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>What Backreferences Match</source>
          <target state="translated">역참조에서 찾는 대상</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A backreference refers to the most recent definition of a group (the definition most immediately to the left, when matching left to right).</source>
          <target state="translated">역참조는 그룹의 가장 최근 정의(왼쪽에서 오른쪽으로 찾을 경우 가장 왼쪽에 있는 정의)를 가리킵니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>When a group makes multiple captures, a backreference refers to the most recent capture.</source>
          <target state="translated">그룹에서 여러 개의 캡처를 만드는 경우 역참조는 가장 최근 캡처를 가리킵니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The following example includes a regular expression pattern, <ph id="ph1">`(?&lt;1&gt;a)(?&lt;1&gt;\1b)*`</ph>, which redefines the \1 named group.</source>
          <target state="translated">다음 예제에는 이름이 \1인 그룹을 다시 정의하는 정규식 패턴 <ph id="ph1">`(?&lt;1&gt;a)(?&lt;1&gt;\1b)*`</ph>가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following table describes each pattern in the regular expression.</source>
          <target state="translated">다음 표에서는 정규식의 각 패턴에 대해 설명합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Match the character "a" and assign the result to the capturing group named 1.</source>
          <target state="translated">문자 "a"를 찾은 다음 이름이 1인 캡처링 그룹에 결과를 할당합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Match 0 or 1 occurrence of the group named 1 along with a "b", and assign the result to the capturing group named 1.</source>
          <target state="translated">이름이 1과 "b"로 구성된 그룹을 0번 또는 1번 찾은 다음 이름이 1인 캡처링 그룹에 결과를 할당합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In comparing the regular expression with the input string ("aababb"), the regular expression engine performs the following operations:</source>
          <target state="translated">입력 문자열("aababb")과 정규식을 비교할 때 정규식 엔진은 다음 작업을 수행합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>It starts at the beginning of the string, and successfully matches "a" with the expression <ph id="ph1">`(?&lt;1&gt;a)`</ph>.</source>
          <target state="translated">문자열의 시작 부분에서 시작하여 <ph id="ph1">`(?&lt;1&gt;a)`</ph> 식으로 "a"를 찾습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The value of the 1 group is now "a".</source>
          <target state="translated">1 그룹의 값이 이제 "a"입니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It advances to the second character, and successfully matches the string "ab" with the expression <ph id="ph1">`\1b`</ph>, or "ab".</source>
          <target state="translated">두 번째 문자로 진행하여 <ph id="ph1">`\1b`</ph> 또는 "ab" 식으로 "ab" 문자열을 찾습니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>It then assigns the result, "ab" to <ph id="ph1">`\1`</ph>.</source>
          <target state="translated">그런 다음 결과 "ab"를 <ph id="ph1">`\1`</ph>에 할당합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>It advances to the fourth character.</source>
          <target state="translated">네 번째 문자로 진행합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The expression <ph id="ph1">`(?&lt;1&gt;\1b)`</ph> is to be matched zero or more times, so it successfully matches the string "abb" with the expression <ph id="ph2">`\1b`</ph>.</source>
          <target state="translated"><ph id="ph1">`(?&lt;1&gt;\1b)`</ph> 식은 0번 이상 일치할 수 있으므로 <ph id="ph2">`\1b`</ph> 식으로 "abb" 문자열을 찾습니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>It assigns the result, "abb", back to <ph id="ph1">`\1`</ph>.</source>
          <target state="translated">결과 "abb"를 <ph id="ph1">`\1`</ph>에 다시 할당합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In this example, <ph id="ph1">\*</ph> is a looping quantifier -- it is evaluated repeatedly until the regular expression engine cannot match the pattern it defines.</source>
          <target state="translated">이 예제에서 <ph id="ph1">\*</ph>는 반복 수량자로, 정규식 엔진이 정의되는 패턴을 찾을 수 없을 때까지 반복해서 평가됩니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Looping quantifiers do not clear group definitions.</source>
          <target state="translated">반복 수량자는 그룹 정의를 지우지 않습니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>If a group has not captured any substrings, a backreference to that group is undefined and never matches.</source>
          <target state="translated">그룹에서 부분 문자열을 캡처하지 않은 경우 해당 그룹에 대한 역참조가 정의되지 않으며 일치되지 않습니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>This is illustrated by the regular expression pattern <ph id="ph1">`\b(\p{Lu}{2})(\d{2})?(\p{Lu}{2})\b,`</ph> which is defined as follows:</source>
          <target state="translated">이 내용은 다음과 같이 정의된 정규식 패턴 <ph id="ph1">`\b(\p{Lu}{2})(\d{2})?(\p{Lu}{2})\b,`</ph>를 통해 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Begin the match on a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 시작합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Match two uppercase letters.</source>
          <target state="translated">두 개의 대문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">이 그룹은 첫 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of two decimal digits.</source>
          <target state="translated">두 개의 10진수를 0번 또는 한 번 찾습니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">이 그룹은 두 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Match two uppercase letters.</source>
          <target state="translated">두 개의 대문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This is the third capturing group.</source>
          <target state="translated">이 그룹은 세 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>End the match on a word boundary.</source>
          <target state="translated">단어 경계에서 일치 항목 찾기를 끝냅니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>An input string can match this regular expression even if the two decimal digits that are defined by the second capturing group are not present.</source>
          <target state="translated">두 번째 캡처링 그룹에서 정의된 두 개의 10진수가 없는 경우에도 입력 문자열이 이 정규식과 일치할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following example shows that even though the match is successful, an empty capturing group is found between two successful capturing groups.</source>
          <target state="translated">다음 예제에서는 일치가 성공해도 성공적인 두 캡처링 그룹 사이에 빈 캡처링 그룹이 있음을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>정규식 언어 - 빠른 참조<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>