<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b40f13e" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d5827f8b8ade216a365fd53f9d4547819188fe9b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\best-practices-strings.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c81d8a27487e9976f7a08297fa532bddfa7767d5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b203361d9dc5f5bb1f63cb49e42fe0c043cc3bbb</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Best practices for using strings</source>
          <target state="translated">문자열 사용에 대한 모범 사례</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Best practices for using strings</source>
          <target state="translated">문자열 사용에 대한 모범 사례</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Best practices for using strings</source>
          <target state="translated">문자열 사용에 대한 모범 사례</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>.NET provides extensive support for developing localized and globalized applications, and makes it easy to apply the conventions of either the current culture or a specific culture when performing common operations such as sorting and displaying strings.</source>
          <target state="translated">.NET에서는 지역화된 응용 프로그램과 전역화된 응용 프로그램을 개발하기 위한 광범위한 지원을 제공하고 문자열 정렬 및 표시와 같은 일반적인 작업을 수행할 때 현재 문화권이나 특정 문화권의 규칙을 쉽게 적용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>But sorting or comparing strings is not always a culture-sensitive operation.</source>
          <target state="translated">그러나 문자열 정렬 및 비교가 항상 문화권이 구분되는 작업은 아닙니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, strings that are used internally by an application typically should be handled identically across all cultures.</source>
          <target state="translated">예를 들어 응용 프로그램에서 내부적으로 사용되는 문자열은 대기 모든 문화권에서 동일하게 처리해야 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When culturally independent string data, such as XML tags, HTML tags, user names, file paths, and the names of system objects, are interpreted as if they were culture-sensitive, application code can be subject to subtle bugs, poor performance, and, in some cases, security issues.</source>
          <target state="translated">XML 태그, HTML 태그, 사용자 이름, 파일 경로 및 시스템 개체 이름과 같이 문화권을 구분하지 않는 문자열 데이터가 문화권이 구분되는 것처럼 해석되면 응용 프로그램 코드에는 감지하기 어려운 버그, 성능 저하 및 경우에 따라 보안 문제가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This article examines the string sorting, comparison, and casing methods in .NET, presents recommendations for selecting an appropriate string-handling method, and provides additional information about string-handling methods.</source>
          <target state="translated">이 문서에서는 .NET의 문자열 정렬, 비교 및 대/소문자 구분 방법을 살펴보고, 적절한 문자열 처리 방법 선택을 위한 권장 사항을 제공하고, 문자열 처리 방법에 대한 추가 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It also examines how formatted data, such as numeric data and date and time data, is handled for display and for storage.</source>
          <target state="translated">또한 숫자 데이터 및 날짜/시간 데이터와 같은 형식이 지정된 데이터를 표시 및 저장을 위해 처리하는 방법을 살펴봅니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This article contains the following sections:</source>
          <target state="translated">이 자료에는 다음과 같은 섹션이 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Recommendations for string usage<ept id="p1">](#recommendations-for-string-usage)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>문자열 사용에 대한 권장 사항<ept id="p1">](#recommendations-for-string-usage)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Specifying string comparisons explicitly<ept id="p1">](#specifying-string-comparisons-explicitly)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>명시적으로 문자열 비교 지정<ept id="p1">](#specifying-string-comparisons-explicitly)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The details of string comparison<ept id="p1">](#the-details-of-string-comparison)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>문자열 비교 세부 정보<ept id="p1">](#the-details-of-string-comparison)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Choosing a StringComparison member for your method call<ept id="p1">](#choosing-a-stringcomparison-member-for-your-method-call)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>메서드 호출을 위한 StringComparison 멤버 선택<ept id="p1">](#choosing-a-stringcomparison-member-for-your-method-call)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Common string comparison methods<ept id="p1">](#common-string-comparison-methods)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>일반적인 문자열 비교 방법<ept id="p1">](#common-string-comparison-methods)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Methods that perform string comparison indirectly<ept id="p1">](#methods-that-perform-string-comparison-indirectly)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>문자열 비교를 간접적으로 수행하는 방법<ept id="p1">](#methods-that-perform-string-comparison-indirectly)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Displaying and persisting formatted data<ept id="p1">](#displaying-and-persisting-formatted-data)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>서식이 지정된 데이터 표시 및 유지<ept id="p1">](#displaying-and-persisting-formatted-data)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Recommendations for string usage</source>
          <target state="translated">문자열 사용에 대한 권장 사항</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>When you develop with .NET, follow these simple recommendations when you use strings:</source>
          <target state="translated">.NET으로 개발하는 경우 문자열을 사용할 때 다음과 같은 간단한 권장 사항을 따르세요.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Use overloads that explicitly specify the string comparison rules for string operations.</source>
          <target state="translated">문자열 작업에 대한 문자열 비교 규칙을 명시적으로 지정하는 오버로드를 사용합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Typically, this involves calling a method overload that has a parameter of type <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>.</source>
          <target state="translated">일반적으로 이 작업은 <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> 형식 매개 변수가 포함된 메서드 오버로드를 호출하는 작업입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> or <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> for comparisons as your safe default for culture-agnostic string matching.</source>
          <target state="translated">문화권에 독립적인 문자열 일치를 위한 안전한 기본값으로 <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> 또는 <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept>를 비교에 사용합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Use comparisons with <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> or <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> for better performance.</source>
          <target state="translated">성능을 향상시키려면 <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> 또는 <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept>를 비교에 사용합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Use string operations that are based on <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept> when you display output to the user.</source>
          <target state="translated">사용자에게 출력을 표시하는 경우 <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>를 기반으로 하는 문자열 작업을 사용합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Use the non-linguistic <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> or <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> values instead of string operations based on <bpt id="p3">[</bpt>CultureInfo.InvariantCulture<ept id="p3">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> when the comparison is linguistically irrelevant (symbolic, for example).</source>
          <target state="translated">비교에 언어적 관련성이 없을 경우(예: 기호) <bpt id="p3">[</bpt>CultureInfo.InvariantCulture<ept id="p3">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept>를 기반으로 하는 문자열 작업 대신 비언어적인 <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> 또는 <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> 값을 사용합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>String.ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> method instead of the <bpt id="p2">[</bpt>String.ToLowerInvariant<ept id="p2">](xref:System.String.ToLowerInvariant)</ept> method when you normalize strings for comparison.</source>
          <target state="translated">비교할 문자열을 정규화하는 경우 <bpt id="p2">[</bpt>String.ToLowerInvariant<ept id="p2">](xref:System.String.ToLowerInvariant)</ept> 메서드 대신 <bpt id="p1">[</bpt>String.ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> 메서드를 사용합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Use an overload of the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Equals`</ph> method to test whether two strings are equal.</source>
          <target state="translated"><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Equals`</ph> 메서드의 오버로드를 사용하여 두 문자열이 같은지를 테스트합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Use an overload of the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> and <bpt id="p2">[</bpt>String.CompareTo<ept id="p2">](xref:System.String.CompareTo(System.String))</ept> methods to sort strings, not to check for equality.</source>
          <target state="translated"><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> 및 <bpt id="p2">[</bpt>String.CompareTo<ept id="p2">](xref:System.String.CompareTo(System.String))</ept> 메서드의 오버로드를 사용하여 문자열이 같은지 확인하지 않고 문자열을 정렬합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Use culture-sensitive formatting to display non-string data, such as numbers and dates, in a user interface.</source>
          <target state="translated">문화권이 구분되는 형식 지정을 사용하여 사용자 인터페이스에서 숫자 및 날짜와 같이 문자열이 아닌 데이터를 표시합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Use formatting with the invariant culture to persist non-string data in string form.</source>
          <target state="translated">고정 문화권과 함께 형식 지정을 사용하여 문자열 양식에서 문자열이 아닌 데이터를 유지합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Avoid the following practices when you use strings:</source>
          <target state="translated">문자열을 사용할 때 다음 사례를 사용하지 마세요.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Do not use overloads that do not explicitly or implicitly specify the string comparison rules for string operations.</source>
          <target state="translated">문자열 작업에 대한 문자열 비교 규칙을 명시적 또는 암시적으로 지정하지 않는 오버로드를 사용하지 마세요.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Do not use an overload of the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> or <bpt id="p2">[</bpt>String.CompareTo<ept id="p2">](xref:System.String.CompareTo(System.String))</ept> methods and test for a return value of zero to determine whether two strings are equal.</source>
          <target state="translated">두 문자열이 같은지를 확인하기 위해 <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> 또는 <bpt id="p2">[</bpt>String.CompareTo<ept id="p2">](xref:System.String.CompareTo(System.String))</ept> 메서드의 오버로드 및 반환 값 0 테스트를 사용하지 마세요.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Do not use culture-sensitive formatting to persist numeric data or date and time data in string form.</source>
          <target state="translated">문자열 양식에서 숫자 데이터나 날짜 및 시간 데이터를 유지하는 데 문화권이 구분되는 형식 지정을 사용하지 마세요.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Specifying string comparisons explicitly</source>
          <target state="translated">명시적으로 문자열 비교 지정</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Most of the string manipulation methods in .NET are overloaded.</source>
          <target state="translated">.NET의 문자열 조작 메서드는 대부분 오버로드됩니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Typically, one or more overloads accept default settings, whereas others accept no defaults and instead define the precise way in which strings are to be compared or manipulated.</source>
          <target state="translated">일반적으로 오버로드 하나 이상은 기본 설정을 그대로 사용하지만, 다른 오버로드는 기본값을 사용하지 않고 문자열을 비교 및 조작하는 정확한 방법을 정의합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Most of the methods that do not rely on defaults include a parameter of type <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept>, which is an enumeration that explicitly specifies rules for string comparison by culture and case.</source>
          <target state="translated">기본값을 사용하지 않는 메서드에는 대부분 문화권 및 사례별로 문자열 비교 규칙을 명시적으로 지정하는 열거형인 <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> 형식의 매개 변수가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The following table describes the <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> enumeration members.</source>
          <target state="translated">다음 표에서는 <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> 열거형 멤버에 대해 설명합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>StringComparison member</source>
          <target state="translated">StringComparison 멤버</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept></target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Performs a case-sensitive comparison using the current culture.</source>
          <target state="translated">현재 문화권을 사용하여 대/소문자를 구분하는 비교를 수행합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CurrentCultureIgnoreCase<ept id="p1">](xref:System.StringComparison.CurrentCultureIgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>CurrentCultureIgnoreCase<ept id="p1">](xref:System.StringComparison.CurrentCultureIgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Performs a case-insensitive comparison using the current culture.</source>
          <target state="translated">현재 문화권을 사용하여 대/소문자를 구분하지 않는 비교를 수행합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Performs an ordinal comparison.</source>
          <target state="translated">서수 비교를 수행합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Performs a case-insensitive ordinal comparison.</source>
          <target state="translated">대소문자를 구분하지 않는 서수 비교를 수행합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> method, which returns the index of a substring in a <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> object that matches either a character or a string, has nine overloads:</source>
          <target state="translated">예를 들어 문자 또는 문자열과 일치하는 <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> 개체의 부분 문자열 인덱스를 반환하는 <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> 메서드에는 다음과 같은 오버로드 9개가 있습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IndexOf(Char)<ept id="p1">](xref:System.String.IndexOf(System.Char))</ept>, <bpt id="p2">[</bpt>IndexOf(Char, Int32)<ept id="p2">](xref:System.String.IndexOf(System.Char,System.Int32))</ept>, and <bpt id="p3">[</bpt>IndexOf(Char, Int32, Int32)<ept id="p3">](xref:System.String.IndexOf(System.Char,System.Int32,System.Int32))</ept>, which by default perform an ordinal (case-sensitive and culture-insensitive) search for a character in the string.</source>
          <target state="translated"><bpt id="p1">[</bpt>IndexOf(Char)<ept id="p1">](xref:System.String.IndexOf(System.Char))</ept>, <bpt id="p2">[</bpt>IndexOf(Char, Int32)<ept id="p2">](xref:System.String.IndexOf(System.Char,System.Int32))</ept> 및 <bpt id="p3">[</bpt>IndexOf(Char, Int32, Int32)<ept id="p3">](xref:System.String.IndexOf(System.Char,System.Int32,System.Int32))</ept> - 기본적으로 문자열에서 문자에 대한 서수 검색(대/소문자 구분 및 문화권을 구분하지 않음)을 수행합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IndexOf(String)<ept id="p1">](xref:System.String.IndexOf(System.String))</ept>, <bpt id="p2">[</bpt>IndexOf(String, Int32)<ept id="p2">](xref:System.String.IndexOf(System.String,System.Int32))</ept>, and <bpt id="p3">[</bpt>IndexOf(String, Int32, Int32)<ept id="p3">](xref:System.String.IndexOf(System.String,System.Int32,System.Int32))</ept>, which by default perform a case-sensitive and culture-sensitive search for a substring in the string.</source>
          <target state="translated"><bpt id="p1">[</bpt>IndexOf(String)<ept id="p1">](xref:System.String.IndexOf(System.String))</ept>, <bpt id="p2">[</bpt>IndexOf(String, Int32)<ept id="p2">](xref:System.String.IndexOf(System.String,System.Int32))</ept> 및 <bpt id="p3">[</bpt>IndexOf(String, Int32, Int32)<ept id="p3">](xref:System.String.IndexOf(System.String,System.Int32,System.Int32))</ept> - 기본적으로 문자열에서 부분 문자열에 대한 대/소문자 구분 및 문화권 구분 검색을 수행합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IndexOf(String, StringComparison)<ept id="p1">](xref:System.String.IndexOf(System.String,System.StringComparison))</ept>, <bpt id="p2">[</bpt>IndexOf(String, Int32, StringComparison)<ept id="p2">](xref:System.String.IndexOf(System.String,System.Int32,System.StringComparison))</ept>, and <bpt id="p3">[</bpt>IndexOf(String, Int32, Int32, StringComparison)<ept id="p3">](xref:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison))</ept>, which include a parameter of type StringComparison that allows the form of the comparison to be specified.</source>
          <target state="translated"><bpt id="p1">[</bpt>IndexOf(String, StringComparison)<ept id="p1">](xref:System.String.IndexOf(System.String,System.StringComparison))</ept>, <bpt id="p2">[</bpt>IndexOf(String, Int32, StringComparison)<ept id="p2">](xref:System.String.IndexOf(System.String,System.Int32,System.StringComparison))</ept> 및 <bpt id="p3">[</bpt>IndexOf(String, Int32, Int32, StringComparison)<ept id="p3">](xref:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison))</ept> - 비교 형식을 지정할 수 있는 StringComparison 형식의 매개 변수를 포함합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>We recommend that you select an overload that does not use default values, for the following reasons:</source>
          <target state="translated">다음 이유로 기본값을 사용하지 않는 오버로드를 선택하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Some overloads with default parameters (those that search for a <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept> in the string instance) perform an ordinal comparison, whereas others (those that search for a string in the string instance) are culture-sensitive.</source>
          <target state="translated">기본 매개 변수가 있는 일부 오버로드(문자열 인스턴스에서 <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept>를 검색하는 오버로드)는 서수 비교를 수행하지만, 다른 오버로드(문자열 인스턴스에서 문자열을 검색하는 오버로드)는 문화권이 구분됩니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It is difficult to remember which method uses which default value, and easy to confuse the overloads.</source>
          <target state="translated">어떤 메서드가 어떤 기본값을 사용하는지 기억하기 어렵고 오버로드를 혼동하기 쉽습니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The intent of the code that relies on default values for method calls is not clear.</source>
          <target state="translated">메서드 호출에 대해 기본값을 사용하는 코드의 의도는 분명하지 않습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In the following example, which relies on defaults, it is difficult to know whether the developer actually intended an ordinal or a linguistic comparison of two strings, or whether a case difference between <ph id="ph1">`protocol`</ph> and "http" might cause the test for equality to return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">기본값을 사용하는 다음 예제에서는 개발자가 실제로 두 문자열의 서수 또는 언어 비교를 의도했는지 또는 <ph id="ph1">`protocol`</ph>과 "http" 간의 대/소문자 차이로 인해 같음 테스트에서 <ph id="ph2">`false`</ph>가 반환될 수 있는지를 잘 알 수 없습니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you call a method that does not rely on defaults, because it makes the intent of the code unambiguous.</source>
          <target state="translated">일반적으로 기본값을 사용하지 않는 메서드를 사용하면 코드의 의도가 분명해지므로 이 메서드를 호출하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This, in turn, makes the code more readable and easier to debug and maintain.</source>
          <target state="translated">이 메서드를 사용하면 코드를 더 쉽게 읽을 수 있고 더 쉽게 디버그 및 유지 관리할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The following example addresses the questions raised about the previous example.</source>
          <target state="translated">다음 예제에서는 이전 예제와 관련된 질문을 해결합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>It makes it clear that ordinal comparison is used and that differences in case are ignored.</source>
          <target state="translated">예제에서는 서수 비교가 사용되고 대/소문자 차이가 무시됩니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The details of string comparison</source>
          <target state="translated">문자열 비교 세부 정보</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>String comparison is the heart of many string-related operations, particularly sorting and testing for equality.</source>
          <target state="translated">문자열 비교는 특히 정렬 및 같음 테스트와 같은 다양한 문자열 관련 작업의 핵심입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Strings sort in a determined order: If "my" appears before "string" in a sorted list of strings, "my" must compare less than or equal to "string".</source>
          <target state="translated">결정된 순서의 문자열 정렬: 정렬된 문자열 목록에서 "my"가 "string" 앞에 나타나면 "my"가 "string"과 같거나 작은지 비교해야 합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Additionally, comparison implicitly defines equality.</source>
          <target state="translated">또한 비교는 암시적으로 같음을 정의합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The comparison operation returns zero for strings it deems equal.</source>
          <target state="translated">비교 작업은 같은 것으로 판단되는 문자열에 대해 0을 반환합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A good interpretation is that neither string is less than the other.</source>
          <target state="translated">다른 문자열보다 작은 문자열이 없다고 해석하는 것이 적절합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Most meaningful operations involving strings include one or both of these procedures: comparing with another string, and executing a well-defined sort operation.</source>
          <target state="translated">문자열과 관련된 대부분 의미 있는 작업에는 다른 문자열과 비교 및 잘 정의된 정렬 작업 실행이라는 두 가지 절차가 둘 다 또는 두 가지 중 하나가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>However, evaluating two strings for equality or sort order does not yield a single, correct result; the outcome depends on the criteria used to compare the strings.</source>
          <target state="translated">그러나 두 문자열의 같음 또는 정렬 순서를 평가할 때 하나의 올바른 결과가 생성되지는 않습니다. 결과는 문자열 비교에 사용되는 기준에 따라 다릅니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>In particular, string comparisons that are ordinal or that are based on the casing and sorting conventions of the current culture or the invariant culture (a locale-agnostic culture based on the English language) may produce different results.</source>
          <target state="translated">특히 서수 문자열 비교나 현재 문화권이나 고정 문화권(영어를 기준으로 로캘을 구분하지 않는 문화권)의 대/소문자 구분 및 정렬 규칙을 기준으로 한 문자열 비교에서는 다른 결과가 생성될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>String comparisons that use the current culture</source>
          <target state="translated">현재 문화권을 사용하는 문자열 비교</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>One criterion involves using the conventions of the current culture when comparing strings.</source>
          <target state="translated">문자열 비교 시 현재 문화권의 규칙을 사용하는 한 가기 기준이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Comparisons that are based on the current culture use the thread's current culture or locale.</source>
          <target state="translated">현재 문화권을 기준으로 한 비교에는 스레드의 현재 문화권 또는 로캘이 사용됩니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You should always use comparisons that are based on the current culture when data is linguistically relevant, and when it reflects culture-sensitive user interaction.</source>
          <target state="translated">데이터가 언어적으로 관련되는 경우와 문화권이 구분되는 사용자 조작을 반영하는 경우에는 항상 현재 문화권을 기준으로 한 비교를 사용해야 합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, comparison and casing behavior in .NET changes when the culture changes.</source>
          <target state="translated">그러나 문화권이 변경되면 .NET의 비교 및 대/소문자 지정 동작도 바뀝니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This happens when an application executes on a computer that has a different culture than the computer on which the application was developed, or when the executing thread changes its culture.</source>
          <target state="translated">응용 프로그램이 개발된 컴퓨터와 다른 문화권을 포함하는 컴퓨터에서 응용 프로그램을 실행하거나 실행 스레드가 문화권을 변경할 경우 이 동작이 수행됩니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This behavior is intentional, but it remains non-obvious to many developers.</source>
          <target state="translated">이 동작은 의도적이지만 대부분 개발자가 이해하기가 분명하지는 않습니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following example illustrates differences in sort order between the U.S. English ("en-US") and Swedish ("sv-SE") cultures.</source>
          <target state="translated">다음 예제에서는 미국 영어("en-US") 및 스웨덴어("sv-SE") 문화권의 정렬 순서 차이를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Note that the words "ångström", "Windows", and "Visual Studio" appear in different positions in the sorted string arrays.</source>
          <target state="translated">정렬된 문자열 배열에서 단어 "ångström", "Windows" 및 "Visual Studio"가 다른 위치에 나타남을 알 수 있습니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Case-insensitive comparisons that use the current culture are the same as culture-sensitive comparisons, except that they ignore case as dictated by the thread's current culture.</source>
          <target state="translated">현재 문화권을 사용하는 대/소문자를 구분하지 않는 비교는 스레드의 현재 문화권에 지정된 대/소문자를 무시한다는 점을 제외하고 문화권 구분 비교와 같습니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This behavior may manifest itself in sort orders as well.</source>
          <target state="translated">이 동작은 정렬 순서에서도 나타날 수 있습니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Comparisons that use current culture semantics are the default for the following methods:</source>
          <target state="translated">현재 문화권 의미 체계를 사용하는 비교는 다음 메서드의 기본값입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> overloads that do not include a <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> parameter.</source>
          <target state="translated"><bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> 매개 변수를 포함하지 않는 <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> 오버로드</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String.CompareTo<ept id="p1">](xref:System.String.CompareTo(System.String))</ept> overloads.</source>
          <target state="translated"><bpt id="p1">[</bpt>String.CompareTo<ept id="p1">](xref:System.String.CompareTo(System.String))</ept> 오버로드</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The default <bpt id="p1">[</bpt>String.StartsWith(String)<ept id="p1">](xref:System.String.StartsWith(System.String))</ept> method.</source>
          <target state="translated">기본 <bpt id="p1">[</bpt>String.StartsWith(String)<ept id="p1">](xref:System.String.StartsWith(System.String))</ept> 메서드</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The default <bpt id="p1">[</bpt>String.EndsWith(String)<ept id="p1">](xref:System.String.EndsWith(System.String))</ept> method.</source>
          <target state="translated">기본 <bpt id="p1">[</bpt>String.EndsWith(String)<ept id="p1">](xref:System.String.EndsWith(System.String))</ept> 메서드</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> overloads that accept a <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> as a search parameter and that do not have a <bpt id="p3">[</bpt>StringComparison<ept id="p3">](xref:System.StringComparison)</ept> parameter.</source>
          <target state="translated"><bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept>을 검색 매개 변수로 사용하고 <bpt id="p3">[</bpt>StringComparison<ept id="p3">](xref:System.StringComparison)</ept> 매개 변수를 포함하지 않는 <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> 오버로드</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`LastIndexOf`</ph> overloads that accept a <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> as a search parameter and that do not have a <bpt id="p3">[</bpt>StringComparison<ept id="p3">](xref:System.StringComparison)</ept> parameter.</source>
          <target state="translated"><bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept>을 검색 매개 변수로 사용하고 <bpt id="p3">[</bpt>StringComparison<ept id="p3">](xref:System.StringComparison)</ept> 매개 변수를 포함하지 않는 <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`LastIndexOf`</ph> 오버로드</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>In any case, we recommend that you call an overload that has a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> parameter to make the intent of the method call clear.</source>
          <target state="translated">어떤 경우든지 메서드 호출의 의도가 분명하게 나타나도록 <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> 매개 변수가 있는 오버로드를 호출하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Subtle and not so subtle bugs can emerge when non-linguistic string data is interpreted linguistically, or when string data from a particular culture is interpreted using the conventions of another culture.</source>
          <target state="translated">비언어적인 문자열 데이터가 언어적으로 해석되거나 특정 문화권의 문자열 데이터가 다른 문화권의 규칙을 통해 해석되면 감지하기 어려운 버그와 감지할 수 있는 버그가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The canonical example is the Turkish-I problem.</source>
          <target state="translated">대표적인 예는 Turkish-I 문제입니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For nearly all Latin alphabets, including U.S. English, the character "i" (\u0069) is the lowercase version of the character "I" (\u0049).</source>
          <target state="translated">미국 영어를 포함한 거의 모든 라틴어 알파벳에서 문자 "i"(\u0069)는 문자 "I"(\u0049)의 소문자 버전입니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This casing rule quickly becomes the default for someone programming in such a culture.</source>
          <target state="translated">이 대/소문자 구분 규칙은 해당 문화권에서 프로그래밍하는 사용자에게 빠르게 기본 규칙이 되었습니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>However, the Turkish ("tr-TR") alphabet includes an "I with a dot" character "İ" (\u0130), which is the capital version of "i".</source>
          <target state="translated">그러나 터키어("tr-TR") 알파벳에는 "i"의 대문자 버전인 "점이 있는 I" 문자 "İ"(\u0130)가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Turkish also includes a lowercase "i without a dot" character, "ı" (\u0131), which capitalizes to "I".</source>
          <target state="translated">터키어에는 대문자 버전이 "I"인 "점이 없는 i" 문자 , "ı"(\u0131)도 포함됩니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This behavior occurs in the Azerbaijani ("az") culture as well.</source>
          <target state="translated">이 동작은 아제르바이잔어("az") 문화권에서도 발생합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Therefore, assumptions made about capitalizing "i" or lowercasing "I" are not valid among all cultures.</source>
          <target state="translated">따라서 "i"를 대문자로 변환하거나 "I"를 소문자로 변환하는 방법에 대한 가정이 모든 문화권에서 유효한 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>If you use the default overloads for string comparison routines, they will be subject to variance between cultures.</source>
          <target state="translated">문자열 비교 루틴에 대해 기본 오버로드를 사용하면 이 오버로드에는 문화권 간의 차이가 적용됩니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If the data to be compared is non-linguistic, using the default overloads can produce undesirable results, as the following attempt to perform a case-insensitive comparison of the strings "file" and "FILE" illustrates.</source>
          <target state="translated">문자열 "file" 및 "FILE"의 대/소문자를 구분하지 않는 비교를 수행하는 다음 시도와 같이, 비교할 데이터가 비언어적일 경우 기본 오버로드를 사용하면 원하지 않는 결과가 생성될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This comparison could cause significant problems if the culture is inadvertently used in security-sensitive settings, as in the following example.</source>
          <target state="translated">다음 예제와 같이 보안 관련 설정에서 문화권이 의도치 않게 사용되면 이 비교로 인해 큰 문제가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>A method call such as <ph id="ph1">`IsFileURI("file:")`</ph> returns <ph id="ph2">`true`</ph> if the current culture is U.S. English, but <ph id="ph3">`false`</ph> if the current culture is Turkish.</source>
          <target state="translated"><ph id="ph1">`IsFileURI("file:")`</ph>와 같은 메서드 호출은 현재 문화권이 미국 영어이면 <ph id="ph2">`true`</ph>를 반환하지만 현재 문화권이 터키어이면 <ph id="ph3">`false`</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Thus, on Turkish systems, someone could circumvent security measures that block access to case-insensitive URIs that begin with "FILE:".</source>
          <target state="translated">따라서 터키어 시스템에서는 누군가 "FILE:"으로 시작하는 대/소문자를 구분하지 않는 URI에 대한 액세스를 차단하는 보안 조치를 회피할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>In this case, because "file:" is meant to be interpreted as a non-linguistic, culture-insensitive identifier, the code should instead be written as shown in the following example.</source>
          <target state="translated">이 경우 "file:"은 비언어적, 문화권을 구분하지 않는 식별자로 해석되므로 코드를 다음 예제와 같이 작성해야 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Ordinal String Operations</source>
          <target state="translated">서수 문자열 작업</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Specifying the <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> or <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> value in a method call signifies a non-linguistic comparison in which the features of natural languages are ignored.</source>
          <target state="translated">메서드 호출에서 <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> 또는 <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> 값을 지정하는 것은 자연어의 특징이 무시되는 비언어적인 비교를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Methods that are invoked with these <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> values base string operation decisions on simple byte comparisons instead of casing or equivalence tables that are parameterized by culture.</source>
          <target state="translated">이러한 <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> 값을 사용하여 호출되는 메서드는 문화권별로 매개 변수화되는 대/소문자 구분 또는 동일성 테이블이 아닌 단순 바이트 비교를 기반으로 하여 문자열 작업을 결정합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In most cases, this approach best fits the intended interpretation of strings while making code faster and more reliable.</source>
          <target state="translated">대부분 경우에 이 접근 방법은 의도된 문자열 해석에 가장 적합하지만 코드를 더 빠르고 더 안정적으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Ordinal comparisons are string comparisons in which each byte of each string is compared without linguistic interpretation; for example, "windows" does not match "Windows".</source>
          <target state="translated">서수 비교는 언어적 해석 없이 각 문자열의 각 바이트가 비교되는 문자열 비교입니다. 예를 들어 "windows"는 "Windows"와 일치하지 않습니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Use this comparison when the context dictates that strings should be matched exactly or demands conservative matching policy.</source>
          <target state="translated">컨텍스트가 문자열이 정확히 일치해야 함을 나타내거나 보수적인 일치 정책을 요구할 경우 이 비교를 사용합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Additionally, ordinal comparison is the fastest comparison operation because it applies no linguistic rules when determining a result.</source>
          <target state="translated">또한 서수 비교는 결과를 결정할 때 언어 규칙을 적용하지 않으므로 가장 빠른 비교 작업입니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Strings in .NET can contain embedded null characters.</source>
          <target state="translated">.NET의 문자열에는 포함된 null 문자가 있을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>One of the clearest differences between ordinal and culture-sensitive comparison (including comparisons that use the invariant culture) concerns the handling of embedded null characters in a string.</source>
          <target state="translated">서수 비교와 문화권 구분 비교(고정 문화권을 사용하는 비교 포함) 간 가장 분명한 차이의 하나는 문자열의 포함된 null 문자 처리와 관련됩니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>These characters are ignored when you use the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> and <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph2">`Equals`</ph> methods to perform culture-sensitive comparisons (including comparisons that use the invariant culture).</source>
          <target state="translated"><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> 및 <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph2">`Equals`</ph> 메서드를 사용하여 문화권 구분 비교(고정 문화권을 사용하는 비교 포함)를 수행하는 경우에는 이러한 문자가 무시됩니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>As a result, in culture-sensitive comparisons, strings that contain embedded null characters can be considered equal to strings that do not.</source>
          <target state="translated">따라서 문화권 구분 비교에서 포함된 null 문자가 들어 있는 문자열은 해당 문자가 들어 있지 않은 문자열과 같은 것으로 간주할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Although string comparison methods disregard embedded null characters, string search methods such as <bpt id="p1">[</bpt>String.Contains<ept id="p1">](xref:System.String.Contains(System.String))</ept>, <bpt id="p2">[</bpt>String.EndsWith<ept id="p2">](xref:System.String.EndsWith(System.String))</ept>, <bpt id="p3">[</bpt>String.IndexOf<ept id="p3">](xref:System.String.IndexOf(System.Char))</ept>, <bpt id="p4">[</bpt>String.LastIndexOf<ept id="p4">](xref:System.String.LastIndexOf(System.String))</ept>, and <bpt id="p5">[</bpt>String.StartsWith<ept id="p5">](xref:System.String.StartsWith(System.String))</ept> do not.</source>
          <target state="translated">문자열 비교 메서드는 포함된 null 문자를 무시하지만 <bpt id="p1">[</bpt>String.Contains<ept id="p1">](xref:System.String.Contains(System.String))</ept>, <bpt id="p2">[</bpt>String.EndsWith<ept id="p2">](xref:System.String.EndsWith(System.String))</ept>, <bpt id="p3">[</bpt>String.IndexOf<ept id="p3">](xref:System.String.IndexOf(System.Char))</ept>, <bpt id="p4">[</bpt>String.LastIndexOf<ept id="p4">](xref:System.String.LastIndexOf(System.String))</ept> 및 <bpt id="p5">[</bpt>String.StartsWith<ept id="p5">](xref:System.String.StartsWith(System.String))</ept>와 같은 문자열 검색 메서드는 무시하지 않습니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following example performs a culture-sensitive comparison of the string "Aa" with a similar string that contains several embedded null characters between "A" and "a", and shows how the two strings are considered equal.</source>
          <target state="translated">다음 예제에서는 문자열 "Aa" 및 "A"와 "a" 사이에 여러 포함된 null 문자를 포함하는 비슷한 문자열의 문화권 구분 비교를 수행하고 두 문자열을 어떻게 같은 것으로 간주하는지 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>However, the strings are not considered equal when you use ordinal comparison, as the following example shows.</source>
          <target state="translated">그러나 다음 예제와 같이 서수 비교를 사용할 경우 문자열을 같은 것으로 간주하지 않습니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Case-insensitive ordinal comparisons are the next most conservative approach.</source>
          <target state="translated">대/소문자를 구분하지 않는 서수 비교는 다음으로 가장 보수적인 접근 방법입니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>These comparisons ignore most casing; for example, "windows" matches "Windows".</source>
          <target state="translated">이들 비교는 대부분 대/소문자 구분을 무시합니다. 예를 들어 "windows"는 "Windows"와 일치합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>When dealing with ASCII characters, this policy is equivalent to <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>, except that it ignores the usual ASCII casing.</source>
          <target state="translated">ASCII 문자를 처리할 때 이 정책은 사용 가능한 ASCII 대/소문자 구분을 무시한다는 점을 제외하고 <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>과 같습니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Therefore, any character in [A, Z] (\u0041-\u005A) matches the corresponding character in [a,z] (\u0061-\007A).</source>
          <target state="translated">따라서 [A, Z](\u0041-\u005A)의 모든 문자는 [a,z](\u0061-\007A)의 해당 문자와 일치합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Casing outside the ASCII range uses the invariant culture's tables.</source>
          <target state="translated">ASCII 범위를 벗어난 대/소문자 구분에는 고정 문화권 테이블이 사용됩니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Therefore, the following comparison:</source>
          <target state="translated">따라서 다음 비교는</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>is equivalent to (but faster than) this comparison:</source>
          <target state="translated">다음 비교와 같지만 더 빠릅니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>These comparisons are still very fast.</source>
          <target state="translated">이들 비교는 매우 빠릅니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Both <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> and <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> use the binary values directly, and are best suited for matching.</source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>과 <bpt id="p2">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparison.OrdinalIgnoreCase)</ept>는 둘 다 이진 값을 직접 사용하며 일치에 가장 적합합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>When you are not sure about your comparison settings, use one of these two values.</source>
          <target state="translated">사용 중인 비교 설정을 확신할 수 없으면 다음 두 값의 하나를 사용하세요.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>However, because they perform a byte-by-byte comparison, they do not sort by a linguistic sort order (like an English dictionary) but by a binary sort order.</source>
          <target state="translated">그러나 이들 값은 바이트 단위 비교를 수행하므로 영어 사전처럼 언어 정렬 순서별로 정렬하는 것이 아니라 이진 정렬 순서별로 정렬합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The results may look odd in most contexts if displayed to users.</source>
          <target state="translated">사용자에게 표시되는 결과가 대부분 컨텍스트에서 이상하게 표시될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Ordinal semantics are the default for <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Equals`</ph> overloads that do not include a <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> argument (including the equality operator).</source>
          <target state="translated">서수 의미 체계는 <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> 인수(같음 연산자 포함)를 포함하지 않는 <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`Equals`</ph> 오버로드의 기본값입니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>In any case, we recommend that you call an overload that has a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> parameter.</source>
          <target state="translated">어떤 경우든지 <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> 매개 변수가 있는 오버로드를 호출하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>String operations that use the invariant culture</source>
          <target state="translated">고정 문화권을 사용하는 문자열 작업</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Comparisons with the invariant culture use the <bpt id="p1">[</bpt>CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> property returned by the static <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> property.</source>
          <target state="translated">고정 문화권을 사용한 비교에는 정적 <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> 속성에서 반환되는 <bpt id="p1">[</bpt>CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> 속성이 사용됩니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>This behavior is the same on all systems; it translates any characters outside its range into what it believes are equivalent invariant characters.</source>
          <target state="translated">이 동작은 모든 시스템에서 동일하며, 범위 밖의 모든 문자를 동일한 고정 문화권으로 간주하는 문자로 변환합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>This policy can be useful for maintaining one set of string behavior across cultures, but it often provides unexpected results.</source>
          <target state="translated">이 정책은 문화권에 걸쳐 단일 문자열 동작 집합을 유지 관리할 경우 유용하지만 예기치 않은 경과를 제공하기도 합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Case-insensitive comparisons with the invariant culture use the static <bpt id="p1">[</bpt>CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> property returned by the static <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> property for comparison information as well.</source>
          <target state="translated">고정 문화권을 사용한 대/소문자를 비교하지 않는 비교에는 비교 정보를 위해 정적 <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> 속성에서 반환되는 정적 <bpt id="p1">[</bpt>CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> 속성이 사용됩니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Any case differences among these translated characters are ignored.</source>
          <target state="translated">모든 경우에 변환된 문자 간의 차이는 무시됩니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>CultureInfo.InvariantCulture<ept id="p1">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> object makes a <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> method interpret certain sets of characters as equivalent.</source>
          <target state="translated"><bpt id="p1">[</bpt>CultureInfo.InvariantCulture<ept id="p1">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> 개체를 사용하면 <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph1">`Compare`</ph> 메서드가 특정 문자 집합을 동일한 것으로 해석합니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For example, the following equivalence is valid under the invariant culture:</source>
          <target state="translated">예를 들어 다음 동일성은 고정 문화권에서 유효합니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>InvariantCulture: a + ̊ = å</source>
          <target state="translated">InvariantCulture: a + ̊ = å</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The latin small lette A character "a" (\u0061), when it is next to the combining ring above character "+ " ̊" (\u030a), is interpreted as the latin small letter A with ring above character "å" (\u00e5).</source>
          <target state="translated">Latin Small Letter A 문자 "a"(\u0061)는 Combining Ring Above 문자 "+ " ̊"(\u030a) 옆에 있을 경우 Latin Small Letter A With Ring Above 문자 "å"(\u00e5)로 해석됩니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>As the following example shows, this behavior differs from ordinal comparison.</source>
          <target state="translated">다음 예제와 같이 이 동작은 서수 비교와 다릅니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>When interpreting file names, cookies, or anything else where a combination such as "å" can appear, ordinal comparisons still offer the most transparent and fitting behavior.</source>
          <target state="translated">파일 이름, 쿠키 또는 "å"와 같은 조합이 나타날 수 있는 다른 항목을 해석할 때 서수 비교는 가장 투명하고 적합한 동작을 제공합니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>On balance, the invariant culture has very few properties that make it useful for comparison.</source>
          <target state="translated">모든 것을 고려해 보면 고정 문화권에는 비교에 유용할 수 있는 속성이 거의 없습니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>It does comparison in a linguistically relevant manner, which prevents it from guaranteeing full symbolic equivalence, but it is not the choice for display in any culture.</source>
          <target state="translated">고정 문화권은 완전한 기호 동일성을 보장하지 못하게 하는 언어 관련 방식으로 비교를 수행하지만 모든 문화권에서 표시하기에 적합하지 않습니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>For example, if a large data file that contains a list of sorted identifiers for display accompanies an application, adding to this list would require an insertion with invariant-style sorting.</source>
          <target state="translated">예를 들어 표시하기 위한 정렬된 식별자 목록을 포함하는 큰 데이터 파일이 응용 프로그램과 함께 제공될 경우 이 목록에 추가하려면 고정 스타일 정렬을 사용한 삽입이 필요합니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Choosing a StringComparison member for your method call</source>
          <target state="translated">메서드 호출을 위한 StringComparison 멤버 선택</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The following table outlines the mapping from semantic string context to a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> enumeration member.</source>
          <target state="translated">다음 표에서는 의미 체계 문자열 컨텍스트에서 <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> 열거형 멤버로의 매핑을 간략하게 설명합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Data</source>
          <target state="translated">데이터</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">동작</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Corresponding System.StringComparison value</source>
          <target state="translated">해당 System.StringComparison 값</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Case-sensitive internal identifiers, case-sensitive identifiers in standards such as XML and HTTP, or case-sensitive security-related settings.</source>
          <target state="translated">대/소문자 구분 내부 식별자, 표준의 대/소문자 구분 식별자(예: XML 및 HTTP) 또는 대/소문자 구분 보안 관련 설정입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>A non-linguistic identifier, where bytes match exactly.</source>
          <target state="translated">바이트가 정확히 일치하는 비언어적 식별자.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept></target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Case-insensitive internal identifiers, case-insensitive identifiers in standards such as XML and HTTP, file paths, registry keys and values, environment variables, resource identifiers (for example, handle names), or case-insensitive security-related settings.</source>
          <target state="translated">대/소문자를 구분하지 않는 내부 식별자, 표준의 대/소문자를 구분하지 않는 식별자(예: XML 및 HTTP), 파일 경로, 레지스트리 키 및 값, 환경 변수, 리소스 식별자(예: 핸들 이름) 또는 대/소문자를 구분하지 않는 보안 관련 설정입니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>A non-linguistic identifier, where case is irrelevant.</source>
          <target state="translated">대/소문자와 관련이 없는 비언어적 식별자입니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Data displayed to the user or most user input.</source>
          <target state="translated">사용자 또는 대부분의 사용자 입력에 표시되는 데이터입니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Data that requires local linguistic customs.</source>
          <target state="translated">로컬 언어적 사용자 지정이 필요한 데이터.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept> or <bpt id="p2">[</bpt>CurrentCultureIgnoreCase<ept id="p2">](xref:System.StringComparison.CurrentCultureIgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept> 또는 <bpt id="p2">[</bpt>CurrentCultureIgnoreCase<ept id="p2">](xref:System.StringComparison.CurrentCultureIgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Common string comparison methods</source>
          <target state="translated">일반적인 문자열 비교 방법</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The following sections describe the methods that are most commonly used for string comparison.</source>
          <target state="translated">다음 섹션에서는 문자열 비교에 가장 일반적으로 사용되는 메서드에 대해 설명합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>String.Compare</source>
          <target state="translated">String.Compare</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">기본 해석: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>As the operation most central to string interpretation, all instances of these method calls should be examined to determine whether strings should be interpreted according to the current culture, or dissociated from the culture (symbolically).</source>
          <target state="translated">문자열 해석의 가장 중심적인 작업으로, 이들 메서드 호출의 모든 인스턴스를 검사하여 문자열이 현재 문화권에 따라 해석되는지, 아니면 문화권과 관계가 없는지를 결정해야 합니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Typically, it is the latter, and a <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> comparison should be used instead.</source>
          <target state="translated">일반적으로 이는 후자이고 <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept> 비교를 사용해야 합니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>System.Globalization.CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> class, which is returned by the <bpt id="p2">[</bpt>CultureInfo.CompareInfo<ept id="p2">](xref:System.Globalization.CultureInfo.CompareInfo)</ept> property, also includes a <bpt id="p3">[</bpt>Compare<ept id="p3">](xref:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32,System.Globalization.CompareOptions))</ept> method that provides a large number of matching options (ordinal, ignoring white space, ignoring kana type, and so on) by means of the <bpt id="p4">[</bpt>CompareOptions<ept id="p4">](xref:System.Globalization.CompareOptions)</ept> flag enumeration.</source>
          <target state="translated"><bpt id="p2">[</bpt>CultureInfo.CompareInfo<ept id="p2">](xref:System.Globalization.CultureInfo.CompareInfo)</ept> 속성에서 반환되는 <bpt id="p1">[</bpt>System.Globalization.CompareInfo<ept id="p1">](xref:System.Globalization.CompareInfo)</ept> 클래스에는 <bpt id="p4">[</bpt>CompareOptions<ept id="p4">](xref:System.Globalization.CompareOptions)</ept> 플래그 열거형을 통해 다양한 일치 항목 찾기 옵션(서수, 공백 무시, 가나 형식 무시 등)을 제공하는 <bpt id="p3">[</bpt>Compare<ept id="p3">](xref:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32,System.Globalization.CompareOptions))</ept> 메서드도 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>String.CompareTo</source>
          <target state="translated">String.CompareTo</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">기본 해석: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>This method does not currently offer an overload that specifies a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> type.</source>
          <target state="translated">이 메서드는 현재 <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> 형식을 지정하는 오버로드를 제공하지 않습니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>It is usually possible to convert this method to the recommended <bpt id="p1">[</bpt>String.Compare(String, String, StringComparison)<ept id="p1">](xref:System.String.Compare(System.String,System.String,System.StringComparison))</ept> form.</source>
          <target state="translated">일반적으로 이 메서드를 권장되는 <bpt id="p1">[</bpt>String.Compare(String, String, StringComparison)<ept id="p1">](xref:System.String.Compare(System.String,System.String,System.StringComparison))</ept> 형식으로 변환할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Types that implement the <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> and <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept> interfaces implement this method.</source>
          <target state="translated"><bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> 및 <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept> 인터페이스를 구현하는 형식이 이 메서드를 구현합니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Because it does not offer the option of a <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> parameter, implementing types often let the user specify a <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> in their constructor.</source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> 매개 변수의 옵션이 제공되지 않으므로 사용자는 대체로 구현 형식을 통해 생성자에서 <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept>를 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`FileName`</ph> class whose class constructor includes a <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> parameter.</source>
          <target state="translated">다음 예제에서는 클래스 생성자에 <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> 매개 변수가 포함된 <ph id="ph1">`FileName`</ph> 클래스를 정의합니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is then used in the <ph id="ph1">`FileName.CompareTo`</ph> method.</source>
          <target state="translated">그런 다음 <ph id="ph1">`FileName.CompareTo`</ph> 메서드에서 이 <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> 개체를 사용합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>String.Equals</source>
          <target state="translated">String.Equals</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>.</source>
          <target state="translated">기본 해석: <bpt id="p1">[</bpt>StringComparison.Ordinal<ept id="p1">](xref:System.StringComparison.Ordinal)</ept>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> class lets you test for equality by calling either the static or instance <ph id="ph1">`Equals`</ph> method overloads, or by using the static equality operator.</source>
          <target state="translated"><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> 클래스를 통해 정적 또는 인스턴스 <ph id="ph1">`Equals`</ph> 메서드 오버로드를 호출하거나 정적 같음 연산자를 사용하여 같음 여부를 테스트할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The overloads and operator use ordinal comparison by default.</source>
          <target state="translated">오버로드 및 연산자에는 기본적으로 서수 비교가 사용됩니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>However, we still recommend that you call an overload that explicitly specifies the <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> type even if you want to perform an ordinal comparison; this makes it easier to search code for a certain string interpretation.</source>
          <target state="translated">그러나 서수 비교를 수행하려는 경우에도 <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> 형식을 명시적으로 지정하는 오버로드를 호출하는 것이 좋습니다. 이렇게 하면 특정 문자열 해석을 위해 코드를 더 쉽게 검색할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>String.ToUpper and String.ToLower</source>
          <target state="translated">String.ToUpper 및 String.ToLower</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">기본 해석: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>You should be careful when you use these methods, because forcing a string to a uppercase or lowercase is often used as a small normalization for comparing strings regardless of case.</source>
          <target state="translated">문자열을 대문자 또는 소문자에 적용하는 방법은 대/소문자와 관계없이 문자열 비교 시 작은 정규화로 사용되므로 이들 메서드를 사용할 때 주의해야 합니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>If so, consider using a case-insensitive comparison.</source>
          <target state="translated">이들 메서드를 사용할 경우 대/소문자를 구분하지 않는 비교를 사용하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>String.ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> and <bpt id="p2">[</bpt>String.ToLowerInvariant<ept id="p2">](xref:System.String.ToLowerInvariant)</ept> methods are also available.</source>
          <target state="translated"><bpt id="p1">[</bpt>String.ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> 및 <bpt id="p2">[</bpt>String.ToLowerInvariant<ept id="p2">](xref:System.String.ToLowerInvariant)</ept> 메서드도 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept> is the standard way to normalize case.</source>
          <target state="translated"><bpt id="p1">[</bpt>ToUpperInvariant<ept id="p1">](xref:System.String.ToUpperInvariant)</ept>는 대/소문자를 정규화하는 표준 방법입니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Comparisons made using <bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept> are behaviorally the composition of two calls: calling <bpt id="p2">[</bpt>ToUpperInvariant<ept id="p2">](xref:System.String.ToUpperInvariant)</ept> on both string arguments, and doing a comparison using <bpt id="p3">[</bpt>StringComparison.Ordinal<ept id="p3">](xref:System.StringComparison.Ordinal)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparison.OrdinalIgnoreCase<ept id="p1">](xref:System.StringComparison.OrdinalIgnoreCase)</ept>를 사용한 비교의 동작은 두 가지 호출(두 문자열 인수에 대한 <bpt id="p2">[</bpt>ToUpperInvariant<ept id="p2">](xref:System.String.ToUpperInvariant)</ept> 호출 및 <bpt id="p3">[</bpt>StringComparison.Ordinal<ept id="p3">](xref:System.StringComparison.Ordinal)</ept>을 사용한 비교 수행)의 컴퍼지션입니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Overloads are also available for converting to uppercase and lowercase in a specific culture, by passing a <bpt id="p1">[</bpt>CultureInfo<ept id="p1">](xref:System.Globalization.CultureInfo)</ept> object that represents that culture to the method.</source>
          <target state="translated">문화권을 나타내는 <bpt id="p1">[</bpt>CultureInfo<ept id="p1">](xref:System.Globalization.CultureInfo)</ept> 개체를 메서드에 전달하여 특정 문화권에서 대문자 및 소문자로 변환하는 데도 오버로드를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Char.ToUpper and Char.ToLower</source>
          <target state="translated">Char.ToUpper 및 Char.ToLower</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">기본 해석: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>These methods work similarly to the <bpt id="p1">[</bpt>String.ToUpper<ept id="p1">](xref:System.String.ToUpper)</ept> and <bpt id="p2">[</bpt>String.ToLower<ept id="p2">](xref:System.String.ToLower)</ept> methods described in the previous section.</source>
          <target state="translated">이 메서드는 이전 섹션에서 설명된 <bpt id="p1">[</bpt>String.ToUpper<ept id="p1">](xref:System.String.ToUpper)</ept> 및 <bpt id="p2">[</bpt>String.ToLower<ept id="p2">](xref:System.String.ToLower)</ept> 메서드와 비슷하게 작동합니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>String.StartsWith and String.EndsWith</source>
          <target state="translated">String.StartsWith 및 String.EndsWith</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">기본 해석: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>By default, both of these methods perform a culture-sensitive comparison.</source>
          <target state="translated">기본적으로 이들 메서드는 둘 다 문화권 구분 비교를 수행합니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>String.IndexOf and String.LastIndexOf</source>
          <target state="translated">String.IndexOf 및 String.LastIndexOf</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">기본 해석: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>There is a lack of consistency in how the default overloads of these methods perform comparisons.</source>
          <target state="translated">이들 메서드의 기본 오버로드가 비교를 수행하는 방식에는 일관성이 없습니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>All <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> and <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph2">`LastIndexOf`</ph> methods that include a <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept> parameter perform an ordinal comparison, but the default <bpt id="p4">[</bpt>String<ept id="p4">](xref:System.String)</ept> <ph id="ph3">`IndexOf`</ph> and [String<ph id="ph4">`](xref:System.String) `</ph>LastIndexOf` methods that include a <bpt id="p5">[</bpt>String<ept id="p5">](xref:System.String)</ept> parameter perform a culture-sensitive comparison.</source>
          <target state="translated"><bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept> 매개 변수를 포함하는 모든 <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> <ph id="ph1">`IndexOf`</ph> and <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> <ph id="ph2">`LastIndexOf`</ph> 메서드는 서수 비교를 수행하지만, <bpt id="p5">[</bpt>String<ept id="p5">](xref:System.String)</ept> 매개 변수를 포함하는 기본 <bpt id="p4">[</bpt>String<ept id="p4">](xref:System.String)</ept> <ph id="ph3">`IndexOf`</ph> 및 [String<ph id="ph4">`](xref:System.String) `</ph>LastIndexOf` 메서드는 문화권 구분 비교를 수행합니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>If you call <ph id="ph1">` `</ph>IndexOf<ph id="ph2">` or `</ph>LastIndexOf` method and pass it a string to locate in the current instance, we recommend that you call an overload that explicitly specifies the <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> type.</source>
          <target state="translated"><ph id="ph1">` `</ph>IndexOf<ph id="ph2">` or `</ph>LastIndexOf` 메서드를 호출하고 현재 인스턴스에서 찾을 문자열을 전달할 경우 <bpt id="p1">[</bpt>StringComparison<ept id="p1">](xref:System.StringComparison)</ept> 형식을 명시적으로 지정하는 오버로드를 호출하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The overloads that include a <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept> argument do not allow you to specify a <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> type.</source>
          <target state="translated"><bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept> 인수를 포함하는 오버로드에서는 <bpt id="p2">[</bpt>StringComparison<ept id="p2">](xref:System.StringComparison)</ept> 형식을 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Methods that perform string comparison indirectly</source>
          <target state="translated">문자열 비교를 간접적으로 수행하는 방법</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Some non-string methods that have string comparison as a central operation use the <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> type.</source>
          <target state="translated">문자열 비교를 중심 작업으로 포함하는 일부 문자열이 아닌 메서드에는 <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> 형식이 사용됩니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> class includes four static properties that return <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> instances whose <ph id="ph1">`Compare`</ph> methods perform the following types of string comparisons:</source>
          <target state="translated"><bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> 클래스에는 해당 <ph id="ph1">`Compare`</ph> 메서드가 다음 형식의 문자열 비교를 수행하는 <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> 인스턴스를 반환하는 정적 속성 4개가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Culture-sensitive string comparisons using the current culture.</source>
          <target state="translated">현재 문화권을 사용한 문화권 구분 문자열 비교.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is returned by the <bpt id="p2">[</bpt>StringComparer.CurrentCulture<ept id="p2">](xref:System.StringComparer.CurrentCulture)</ept> property.</source>
          <target state="translated">이 <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> 개체는 <bpt id="p2">[</bpt>StringComparer.CurrentCulture<ept id="p2">](xref:System.StringComparer.CurrentCulture)</ept> 속성에서 반환됩니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Case-insensitive comparisons using the current culture.</source>
          <target state="translated">현재 문화권을 사용한 대/소문자를 구분하지 않는 문자열 비교.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is returned by the <bpt id="p2">[</bpt>StringComparer.CurrentCultureIgnoreCase<ept id="p2">](xref:System.StringComparer.CurrentCultureIgnoreCase)</ept> property.</source>
          <target state="translated">이 <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> 개체는 <bpt id="p2">[</bpt>StringComparer.CurrentCultureIgnoreCase<ept id="p2">](xref:System.StringComparer.CurrentCultureIgnoreCase)</ept> 속성에서 반환됩니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Ordinal comparison.</source>
          <target state="translated">서수 비교.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is returned by the <bpt id="p2">[</bpt>StringComparer.Ordinal<ept id="p2">](xref:System.StringComparer.Ordinal)</ept> property.</source>
          <target state="translated">이 <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> 개체는 <bpt id="p2">[</bpt>StringComparer.Ordinal<ept id="p2">](xref:System.StringComparer.Ordinal)</ept> 속성에서 반환됩니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Case-insensitive ordinal comparison.</source>
          <target state="translated">대소문자를 구분하지 않는 서수 비교.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> object is returned by the <bpt id="p2">[</bpt>StringComparer.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparer.OrdinalIgnoreCase)</ept> property.</source>
          <target state="translated">이 <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> 개체는 <bpt id="p2">[</bpt>StringComparer.OrdinalIgnoreCase<ept id="p2">](xref:System.StringComparer.OrdinalIgnoreCase)</ept> 속성에서 반환됩니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Array.Sort and Array.BinarySearch</source>
          <target state="translated">Array.Sort 및 Array.BinarySearch</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Default interpretation: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</source>
          <target state="translated">기본 해석: <bpt id="p1">[</bpt>StringComparison.CurrentCulture<ept id="p1">](xref:System.StringComparison.CurrentCulture)</ept>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>When you store any data in a collection, or read persisted data from a file or database into a collection, switching the current culture can invalidate the invariants in the collection.</source>
          <target state="translated">컬렉션에 데이터를 저장하거나 영구 데이터를 파일이나 데이터베이스에서 컬렉션으로 읽을 때 현재 문화권을 전환하면 컬렉션에서 고정이 무효화될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Array.BinarySearch<ept id="p1">](xref:System.Array.BinarySearch(System.Array,System.Object))</ept> method assumes that the elements in the array to be searched are already sorted.</source>
          <target state="translated"><bpt id="p1">[</bpt>Array.BinarySearch<ept id="p1">](xref:System.Array.BinarySearch(System.Array,System.Object))</ept> 메서드는 검색할 배열의 요소가 이미 정렬되었다고 가정합니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>To sort any string element in the array, the <bpt id="p1">[</bpt>Array.Sort<ept id="p1">](xref:System.Array.Sort(System.Array))</ept> method calls the [String] <ph id="ph1">`Compare`</ph> method to order individual elements.</source>
          <target state="translated">배열에서 문자열 요소를 정렬하기 위해 <bpt id="p1">[</bpt>Array.Sort<ept id="p1">](xref:System.Array.Sort(System.Array))</ept> 메서드는 [String] <ph id="ph1">`Compare`</ph> 메서드를 호출하여 개별 요소의 순서를 지정합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Using a culture-sensitive comparer can be dangerous if the culture changes between the time that the array is sorted and its contents are searched.</source>
          <target state="translated">배열이 정렬된 시간과 콘텐츠가 검색된 시간 사이에 문화권이 변경될 경우 문화권 구분 비교자 사용이 위험할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>For example, in the following code, storage and retrieval operate on the comparer that is provided implicitly by the <ph id="ph1">`Thread.CurrentThread.CurrentCulture`</ph> property.</source>
          <target state="translated">예를 들어 다음 코드에서 저장 및 검색은 <ph id="ph1">`Thread.CurrentThread.CurrentCulture`</ph> 속성을 통해 명시적으로 제공된 비교자에서 작동합니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>If the culture can change between the calls to <ph id="ph1">`StoreNames`</ph> and <ph id="ph2">`DoesNameExist`</ph>, and especially if the array contents are persisted somewhere between the two method calls, the binary search may fail.</source>
          <target state="translated"><ph id="ph1">`StoreNames`</ph> 및 <ph id="ph2">`DoesNameExist`</ph>에 대한 호출 사이에 문화권이 변경되고 특히 배열 콘텐츠가 두 메서드 호출 사이에 지속되면 이진 검색이 실패할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>A recommended variation appears in the following example, which uses the same ordinal (culture-insensitive) comparison method both to sort and to search the array.</source>
          <target state="translated">배열을 정렬 및 검색할 때 둘 다 같은 서수(문화권을 구분하지 않는) 비교 메서드를 사용하는 다음 예제에서 권장되는 변형을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The change code is reflected in the lines labeled <ph id="ph1">`Line A`</ph> and <ph id="ph2">`Line B`</ph> in the two examples.</source>
          <target state="translated">변경 코드는 두 예제의 <ph id="ph1">`Line A`</ph> 및 <ph id="ph2">`Line B`</ph> 줄에 반영됩니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>If this data is persisted and moved across cultures, and sorting is used to present this data to the user, you might consider using <ph id="ph1">`StringComparison.InvariantCulture`</ph>, which operates linguistically for better user output but is unaffected by changes in culture.</source>
          <target state="translated">이 데이터가 문화권에 걸쳐 지속 및 이동되고 이 데이터를 사용자에게 제공할 때 정렬을 사용할 경우 향상된 사용자 출력을 위해 언어적으로 작동하지만 문화권 변경의 영향을 받지 않는 <ph id="ph1">`StringComparison.InvariantCulture`</ph>를 사용하는 것이 좋을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The following example modifies the two previous examples to use the invariant culture for sorting and searching the array.</source>
          <target state="translated">다음 예제에서는 두 가지 이전 예제에서 배열 정렬 및 검색에 고정 문화권을 사용하도록 수정합니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Collections Example: Hashtable Constructor</source>
          <target state="translated">컬렉션 예제: 해시 가능한 생성자</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Hashing strings provides a second example of an operation that is affected by the way in which strings are compared.</source>
          <target state="translated">문자열 비교 방법이 영향을 미치는 작업의 두 번째 예로는 문자열 해시가 있습니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following example instantiates a <bpt id="p1">[</bpt>Hashtable<ept id="p1">](xref:System.Collections.Hashtable)</ept> object by passing it the <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> object that is returned by the <bpt id="p3">[</bpt>StringComparer.OrdinalIgnoreCase<ept id="p3">](xref:System.StringComparer.OrdinalIgnoreCase)</ept> property.</source>
          <target state="translated">다음 예제에서는 <bpt id="p3">[</bpt>StringComparer.OrdinalIgnoreCase<ept id="p3">](xref:System.StringComparer.OrdinalIgnoreCase)</ept> 속성에서 반환되는 <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> 개체를 전달하여 <bpt id="p1">[</bpt>Hashtable<ept id="p1">](xref:System.Collections.Hashtable)</ept> 개체를 인스턴스화합니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Because a class <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> that is derived from <bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept> implements the <bpt id="p3">[</bpt>IEqualityComparer<ept id="p3">](xref:System.Collections.IEqualityComparer)</ept> interface, its <bpt id="p4">[</bpt>GetHashCode<ept id="p4">](xref:System.Collections.IEqualityComparer)</ept> method is used to compute the hash code of strings in the hash table.</source>
          <target state="translated"><bpt id="p2">[</bpt>StringComparer<ept id="p2">](xref:System.StringComparer)</ept>에서 파생된 <bpt id="p1">[</bpt>StringComparer<ept id="p1">](xref:System.StringComparer)</ept> 클래스는 <bpt id="p3">[</bpt>IEqualityComparer<ept id="p3">](xref:System.Collections.IEqualityComparer)</ept> 인터페이스를 구현하므로 해당 <bpt id="p4">[</bpt>GetHashCode<ept id="p4">](xref:System.Collections.IEqualityComparer)</ept> 메서드는 해시 테이블에서 문자열의 해시 코드를 계산하는 데 사용됩니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Displaying and persisting formatted data</source>
          <target state="translated">서식이 지정된 데이터 표시 및 유지</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>When you display non-string data such as numbers and dates and times to users, format them by using the user's cultural settings.</source>
          <target state="translated">숫자와 날짜 및 시간과 같은 문자열이 아닌 데이터를 사용자에게 표시할 때 사용자의 문화권 설정을 사용하여 형식을 지정합니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>By default, the <bpt id="p1">[</bpt>String.Format<ept id="p1">](xref:System.String.Format(System.IFormatProvider,System.String,System.Object))</ept> method and the <ph id="ph1">`ToString`</ph> methods of the numeric types and the date and time types use the current thread culture for formatting operations.</source>
          <target state="translated">기본적으로 <bpt id="p1">[</bpt>String.Format<ept id="p1">](xref:System.String.Format(System.IFormatProvider,System.String,System.Object))</ept> 메서드와 숫자 형식 및 날짜/시간 형식의 <ph id="ph1">`ToString`</ph> 메서드는 형식 지정 작업에 현재 스레드 문화권을 사용합니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>To explicitly specify that the formatting method should use the current culture, you can call an overload of a formatting method that has a provider parameter, such as <bpt id="p1">[</bpt>String.Format(IFormatProvider, String, Object[])<ept id="p1">](xref:System.String.Format(System.IFormatProvider,System.String,System.Object))</ept> or <bpt id="p2">[</bpt>DateTime.ToString(IFormatProvider)<ept id="p2">](xref:System.DateTime.ToString(System.IFormatProvider))</ept>, and pass it the <bpt id="p3">[</bpt>CultureInfo.CurrentCulture<ept id="p3">](xref:System.Globalization.CultureInfo.CurrentCulture)</ept> property.</source>
          <target state="translated">형식 지정 메서드가 현재 문화권을 사용하도록 명시적으로 지정하려면 <bpt id="p1">[</bpt>String.Format(IFormatProvider, String, Object[])<ept id="p1">](xref:System.String.Format(System.IFormatProvider,System.String,System.Object))</ept> 또는 <bpt id="p2">[</bpt>DateTime.ToString(IFormatProvider)<ept id="p2">](xref:System.DateTime.ToString(System.IFormatProvider))</ept>와 같은 provider 매개 변수가 있는 형식 지정 메서드의 오버로드를 호출하고 <bpt id="p3">[</bpt>CultureInfo.CurrentCulture<ept id="p3">](xref:System.Globalization.CultureInfo.CurrentCulture)</ept> 속성을 전달하면 됩니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>You can persist non-string data either as binary data or as formatted data.</source>
          <target state="translated">문자열이 아닌 데이터를 이진 데이터 또는 형식이 지정된 데이터로 유지할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>If you choose to save it as formatted data, you should call a formatting method overload that includes a <bpt id="p1">*</bpt>provider<ept id="p1">*</ept> parameter and pass it the <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> property.</source>
          <target state="translated">형식이 지정된 데이터로 저장하는 경우 <bpt id="p1">*</bpt>provider<ept id="p1">*</ept> 매개 변수를 포함하는 형식 지정 메서드 오버로드를 호출하고 <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> 속성을 전달해야 합니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The invariant culture provides a consistent format for formatted data that is independent of culture and machine.</source>
          <target state="translated">고정 문화권은 문화권 및 컴퓨터와 관계없는 형식이 지정된 데이터에 대해 일관된 형식을 제공합니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>In contrast, persisting data that is formatted by using cultures other than the invariant culture has a number of limitations:</source>
          <target state="translated">반대로 고정 문화권이 아닌 문화권을 사용하여 형식이 지정된 영구 데이터에는 많은 제한 사항이 있습니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The data is likely to be unusable if it is retrieved on a system that has a different culture, or if the user of the current system changes the current culture and tries to retrieve the data.</source>
          <target state="translated">다른 문화권이 포함된 시스템에서 데이터를 검색하거나 현재 시스템의 사용자가 현재 문화권을 변경하고 데이터를 검색하려고 하면 데이터를 사용하지 못할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The properties of a culture on a specific computer can differ from standard values.</source>
          <target state="translated">특정 컴퓨터의 문화권 속성은 표준 값과 다를 수 있습니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>At any time, a user can customize culture-sensitive display settings.</source>
          <target state="translated">언제든지 사용자가 문화권 구분 표시 설정을 사용자 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Because of this, formatted data that is saved on a system may not be readable after the user customizes cultural settings.</source>
          <target state="translated">이로 인해 사용자가 문화권 설정을 사용자 지정한 후에는 시스템에 저장된 형식이 지정된 데이터를 읽지 못할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The portability of formatted data across computers is likely to be even more limited.</source>
          <target state="translated">컴퓨터 간에 형식이 지정된 데이터의 이식성은 훨씬 더 제한적일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>International, regional, or national standards that govern the formatting of numbers or dates and times change over time, and these changes are incorporated into operating system updates.</source>
          <target state="translated">숫자 또는 날짜/시간의 형식 지정을 관리하는 국제, 지역 또는 국가 표준은 시간에 지나면서 변경되고 이러한 변경 내용은 운영 체제 업데이트에 통합됩니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>When formatting conventions change, data that was formatted by using the previous conventions may become unreadable.</source>
          <target state="translated">형식 지정 규칙이 변경될 때 이전 규칙을 사용하여 형식이 지정된 데이터를 읽지 못하게 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The following example illustrates the limited portability that results from using culture-sensitive formatting to persist data.</source>
          <target state="translated">다음 예제에서는 문화권 구분 형식 지정을 사용하여 데이터를 유지함으로 인해 제한된 이식성을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The example saves an array of date and time values to a file.</source>
          <target state="translated">예제에서는 날짜 및 시간 값 배열을 파일에 저장합니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>These are formatted by using the conventions of the English (United States) culture.</source>
          <target state="translated">이들 값은 영어(미국) 문화권의 규칙을 사용하여 형식이 지정됩니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>After the application changes the current thread culture to French (Switzerland), it tries to read the saved values by using the formatting conventions of the current culture.</source>
          <target state="translated">응용 프로그램이 현재 스레드 문화권을 프랑스어(스위스)로 변경하고 나면 현재 문화권의 형식 지정 규칙을 사용하여 저장된 값을 읽으려고 합니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The attempt to read two of the data items throws a <bpt id="p1">[</bpt>FormatException<ept id="p1">](xref:System.FormatException)</ept> exception, and the array of dates now contains two incorrect elements that are equal to <bpt id="p2">[</bpt>MinValue<ept id="p2">](xref:System.DateTime.MinValue)</ept>.</source>
          <target state="translated">두 데이터 항목을 읽으려는 시도로 인해 <bpt id="p1">[</bpt>FormatException<ept id="p1">](xref:System.FormatException)</ept> 예외가 throw되고 날짜 배열에는 <bpt id="p2">[</bpt>MinValue<ept id="p2">](xref:System.DateTime.MinValue)</ept>와 같은 잘못된 두 가지 요소가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>However, if you replace the <bpt id="p1">[</bpt>CultureInfo.CurrentCulture<ept id="p1">](xref:System.Globalization.CultureInfo.CurrentCulture)</ept> property with <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept> in the calls to <bpt id="p3">[</bpt>DateTime.ToString(String, IFormatProvider)<ept id="p3">](xref:System.DateTime.ToString(System.String,System.IFormatProvider))</ept> and <bpt id="p4">[</bpt>DateTime.Parse(String, IFormatProvider)<ept id="p4">](xref:System.DateTime.Parse(System.String,System.IFormatProvider))</ept>, the persisted date and time data is successfully restored, as the following output shows.</source>
          <target state="translated">그러나 <bpt id="p3">[</bpt>DateTime.ToString(String, IFormatProvider)<ept id="p3">](xref:System.DateTime.ToString(System.String,System.IFormatProvider))</ept> 및 <bpt id="p4">[</bpt>DateTime.Parse(String, IFormatProvider)<ept id="p4">](xref:System.DateTime.Parse(System.String,System.IFormatProvider))</ept> 호출에서 <bpt id="p1">[</bpt>CultureInfo.CurrentCulture<ept id="p1">](xref:System.Globalization.CultureInfo.CurrentCulture)</ept> 속성을 <bpt id="p2">[</bpt>CultureInfo.InvariantCulture<ept id="p2">](xref:System.Globalization.CultureInfo.InvariantCulture)</ept>로 바꾸면 다음 출력과 같이 보관된 날짜 및 시간 데이터가 복원됩니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Manipulating strings<ept id="p1">](manipulating-strings.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>문자열 조작<ept id="p1">](manipulating-strings.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>