<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fd610bdba56679dd522149d8e91dc91858c7f7ed</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\docker\console.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02fa0bc4ba65f75936d48f81291b670aaf3252bd</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">162574602fe8f99a96301753884af51f1a88574c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Running Console applications in Docker</source>
          <target state="translated">Docker에서 콘솔 응용 프로그램 실행</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn how to take an existing .NET Framework console application and run it in a Windows Docker container.</source>
          <target state="translated">기존 .NET Framework 콘솔 응용 프로그램을 가져와 Windows Docker 컨테이너에서 실행하는 방법을 알아봅니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, Container, Console, Applications</source>
          <target state="translated">.NET, 컨테이너, 콘솔, 응용 프로그램</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Running console applications in Windows containers</source>
          <target state="translated">Windows 컨테이너에서 콘솔 응용 프로그램 실행</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Console applications are used for many purposes; from simple querying of a status to long running document image processing tasks.</source>
          <target state="translated">콘솔 응용 프로그램은 간단한 상태 쿼리에서 장기 실행 문서 이미지 처리 태스크에 이르기까지 다양한 용도로 사용됩니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In any case, the ability to start up and scale these applications are met with limitations of hardware acquisitions, startup times or running multiple instances.</source>
          <target state="translated">어떤 경우든지 이러한 응용 프로그램을 시작하고 크기를 조정하는 기능은 하드웨어 취득, 시작 시간 또는 여러 인스턴스 실행의 제약을 받습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Moving your console applications to use Docker and Windows Server containers allows for starting these applications from a clean state, enabling them to perform the operation and then shutdown cleanly.</source>
          <target state="translated">Docker 및 Windows Server 컨테이너를 사용하도록 콘솔 응용 프로그램을 이동하면 이러한 응용 프로그램을 클린 상태에서 시작하고 작업을 수행한 다음 정상적으로 종료되도록 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This topic will show the steps needed to move a console application to a Windows based container and start it using a PowerShell script.</source>
          <target state="translated">이 항목에서는 콘솔 응용 프로그램을 Windows 기반 컨테이너로 이동하고 PowerShell 스크립트를 사용하여 시작하는 데 필요한 단계를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The sample console application is a simple example which takes an argument, a question in this case, and returns a random answer.</source>
          <target state="translated">샘플 콘솔 응용 프로그램은 인수(이 경우 질문)를 사용하고 임의의 대답을 반환하는 간단한 예제입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This could take a <ph id="ph1">`customer_id`</ph> and process their taxes, or create a thumbnail for an <ph id="ph2">`image_url`</ph> argument.</source>
          <target state="translated">이 응용 프로그램은 <ph id="ph1">`customer_id`</ph>를 가져와 해당 세금을 처리하거나 <ph id="ph2">`image_url`</ph> 인수에 대한 미리 보기를 만듭니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In addition to the answer, the <ph id="ph1">`Environment.MachineName`</ph> has been added to the response to show the difference between running the application locally and in a Windows container.</source>
          <target state="translated">대답 외에도 <ph id="ph1">`Environment.MachineName`</ph>이 응답에 추가되어 로컬과 Windows 컨테이너에서 실행 중인 응용 프로그램 간의 차이를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>When running the application locally, your local machine name should be returned and when running in a Windows Container; the container session id is returned.</source>
          <target state="translated">로컬에서 응용 프로그램을 실행하는 경우 로컬 컴퓨터 이름이 반환되어야 하며, Windows 컨테이너에서 실행하는 경우 컨테이너 세션 ID가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The complete example is available in the <bpt id="p1">[</bpt>dotnet/core-docs repository on GitHub<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/framework/docker/ConsoleRandomAnswerGenerator)</ept>.</source>
          <target state="translated">전체 예제는 <bpt id="p1">[</bpt>GitHub의 dotnet/core-docs 리포지토리<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/framework/docker/ConsoleRandomAnswerGenerator)</ept>에서 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You need to be familiar with some Docker terms before you begin working on moving your application to a container.</source>
          <target state="translated">응용 프로그램을 컨테이너로 이동하는 작업을 시작하기 전에 몇 가지 Docker 용어를 알고 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>Docker image<ept id="p1">*</ept> is a read-only template that defines the environment for a running container, including the operating system (OS), system components, and application(s).</source>
          <target state="translated"><bpt id="p1">*</bpt>Docker 이미지<ept id="p1">*</ept>는 OS(운영 체제), 시스템 구성 요소 및 응용 프로그램을 포함하여 실행 중인 컨테이너에 대한 환경을 정의하는 읽기 전용 템플릿입니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>One important feature of Docker images is that images are composed from a base image.</source>
          <target state="translated">Docker 이미지의 중요한 특징 중 하나는 기본 이미지에서 이미지가 작성된다는 것입니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Each new image adds a small set of features to an existing image.</source>
          <target state="translated">새 이미지를 작성할 때마다 기존 이미지에 소수의 특징이 추가됩니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>Docker container<ept id="p1">*</ept> is a running instance of an image.</source>
          <target state="translated"><bpt id="p1">*</bpt>Docker 컨테이너<ept id="p1">*</ept>는 실행 중인 이미지 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You scale an application by running the same image in many containers.</source>
          <target state="translated">많은 컨테이너에서 동일한 이미지를 실행하여 응용 프로그램을 확장합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Conceptually, this is similar to running the same application in multiple hosts.</source>
          <target state="translated">개념상, 이 작업은 여러 호스트에서 동일한 응용 프로그램을 실행하는 것과 비슷합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You can learn more about the Docker architecture by reading the <bpt id="p1">[</bpt>Docker Overview<ept id="p1">](https://docs.docker.com/engine/understanding-docker/)</ept> on the Docker site.</source>
          <target state="translated">Docker 사이트에서 <bpt id="p1">[</bpt>Docker 개요<ept id="p1">](https://docs.docker.com/engine/understanding-docker/)</ept>를 확인하여 Docker 아키텍처에 대해 자세히 알아볼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Moving your console application is a matter of a few steps.</source>
          <target state="translated">몇 단계만 수행하면 콘솔 응용 프로그램을 이동할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Build the application<ept id="p1">](#building-the-application)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>응용 프로그램 빌드<ept id="p1">](#building-the-application)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Creating a Dockerfile for the image<ept id="p1">](#creating-the-dockerfile)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>이미지에 대한 Dockerfile 만들기<ept id="p1">](#creating-the-dockerfile)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Process to build and run the Docker container<ept id="p1">](#creating-the-image)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Docker 컨테이너를 빌드 및 실행하는 프로세스<ept id="p1">](#creating-the-image)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">필수 구성 요소</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Windows containers are supported on <bpt id="p1">[</bpt>Windows 10 Anniversary Update<ept id="p1">](https://www.microsoft.com/en-us/software-download/windows10/)</ept> or <bpt id="p2">[</bpt>Windows Server 2016<ept id="p2">](https://www.microsoft.com/en-us/cloud-platform/windows-server)</ept>.</source>
          <target state="translated">Windows 컨테이너는 <bpt id="p1">[</bpt>Windows 10 1주년 업데이트<ept id="p1">](https://www.microsoft.com/en-us/software-download/windows10/)</ept> 또는 <bpt id="p2">[</bpt>Windows Server 2016<ept id="p2">](https://www.microsoft.com/en-us/cloud-platform/windows-server)</ept>에서 지원됩니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you are using Windows Server 2016, you must enable containers manually since the Docker for Windows installer will not enable the feature.</source>
          <target state="translated">Windows Server 2016을 사용하는 경우 Windows용 Docker 설치 관리자에서 해당 기능을 사용하도록 설정되지 않기에, 수동으로 컨테이너를 사용하도록 설정해야 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Make sure all updates have run for the OS and then follow the instructions from the <bpt id="p1">[</bpt>Container Host Deployment<ept id="p1">](https://msdn.microsoft.com/en-us/virtualization/windowscontainers/deployment/deployment)</ept> article to install the containers and Docker features.</source>
          <target state="translated">OS에 대한 업데이트가 모두 실행되었는지 확인한 다음 <bpt id="p1">[</bpt>컨테이너 호스트 배포<ept id="p1">](https://msdn.microsoft.com/en-us/virtualization/windowscontainers/deployment/deployment)</ept> 문서의 지침에 따라 컨테이너 및 Docker 기능을 설치합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You need to have Docker for Windows, version 1.12 Beta 26 or higher to support Windows containers.</source>
          <target state="translated">Windows 컨테이너를 지원하려면 Windows용 Docker 버전 1.12 베타 26 이상이 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>By default, Docker enables Linux based containers; switch to Windows containers by right clicking the Docker icon in the system tray and select <bpt id="p1">**</bpt>Switch to Windows containers<ept id="p1">**</ept>.</source>
          <target state="translated">기본적으로 Docker는 Linux 기반 컨테이너를 사용합니다. 시스템 트레이에서 Docker 아이콘을 마우스 오른쪽 단추로 클릭하고 <bpt id="p1">**</bpt>Windows 컨테이너로 전환<ept id="p1">**</ept>을 선택하여 Windows 컨테이너로 전환합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Docker will run the process to change and a restart may be required.</source>
          <target state="translated">Docker에서 변경 프로세스가 실행되며 다시 시작해야 할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Windows-Containers</source>
          <target state="translated">Windows-Containers</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Building the application</source>
          <target state="translated">응용 프로그램 빌드</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Typically console applications are distributed through an installer, FTP, or File Share deployment.</source>
          <target state="translated">일반적으로 콘솔 응용 프로그램은 설치 관리자, FTP 또는 파일 공유 배포를 통해 배포됩니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>When deploying to a container, the assets need to be compiled and staged to a location that can be used when the Docker image is created.</source>
          <target state="translated">컨테이너에 배포하는 경우 자산을 컴파일하고 Docker 이미지를 만들 때 사용할 수 있는 위치에 스테이징해야 합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In <bpt id="p1">*</bpt>build.ps1<ept id="p1">*</ept>, the script uses <bpt id="p2">[</bpt>MSBuild<ept id="p2">](https://msdn.microsoft.com/en-us/library/dd393574.aspx)</ept> to compile the application to complete the task of building the assets.</source>
          <target state="translated"><bpt id="p1">*</bpt>build.ps1<ept id="p1">*</ept>에서 스크립트는 <bpt id="p2">[</bpt>MSBuild<ept id="p2">](https://msdn.microsoft.com/en-us/library/dd393574.aspx)</ept>를 통해 응용 프로그램을 컴파일하여 자산 빌드 태스크를 완료합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>There are a few parameters passed to MSBuild to finalize the needed assets.</source>
          <target state="translated">필요한 자산을 마무리하기 위해 MSBuild에 몇 개의 매개 변수가 전달됩니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The name of the project file or solution to be compiled, the location for the output and finally the configuration (Release or Debug).</source>
          <target state="translated">컴파일할 프로젝트 파일 또는 솔루션의 이름, 출력 위치, 마지막으로 구성(릴리스 또는 디버그)입니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the call to <ph id="ph1">`Invoke-MSBuild`</ph> the <ph id="ph2">`OutputPath`</ph> is set to <bpt id="p1">**</bpt>publish<ept id="p1">**</ept> and  <ph id="ph3">`Configuration`</ph> set to <bpt id="p2">**</bpt>Release<ept id="p2">**</ept>.</source>
          <target state="translated"><ph id="ph1">`Invoke-MSBuild`</ph> 호출에서 <ph id="ph2">`OutputPath`</ph>는 <bpt id="p1">**</bpt>publish<ept id="p1">**</ept>로 설정되고 <ph id="ph3">`Configuration`</ph>은 <bpt id="p2">**</bpt>릴리스<ept id="p2">**</ept>로 설정됩니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Creating the Dockerfile</source>
          <target state="translated">Dockerfile 만들기</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The base image used for a console .NET Framework application is <ph id="ph1">`microsoft/windowsservercore`</ph>, publicly available on <bpt id="p1">[</bpt>Docker Hub<ept id="p1">](https://hub.docker.com/r/microsoft/windowsservercore/)</ept>.</source>
          <target state="translated">콘솔 .NET Framework 응용 프로그램에 사용되는 기본 이미지는 <bpt id="p1">[</bpt>Docker 허브<ept id="p1">](https://hub.docker.com/r/microsoft/windowsservercore/)</ept>에서 공개적으로 사용할 수 있는 <ph id="ph1">`microsoft/windowsservercore`</ph>입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The base image contains a minimal installation of Windows Server 2016, .NET Framework 4.6.2 and serves as the base OS image for Windows Containers.</source>
          <target state="translated">기본 이미지에는 Windows Server 2016 최소 설치와 .NET Framework 4.6.2가 포함되어 있으며 Windows 컨테이너의 기본 OS 이미지 역할을 합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The first line in the Dockerfile designates the base image using the <bpt id="p1">[</bpt><ph id="ph1">`FROM`</ph><ept id="p1">](https://docs.docker.com/engine/reference/builder/#/from)</ept> instruction.</source>
          <target state="translated">Dockerfile의 첫 번째 줄에서는 <bpt id="p1">[</bpt><ph id="ph1">`FROM`</ph><ept id="p1">](https://docs.docker.com/engine/reference/builder/#/from)</ept> 명령을 사용하여 기본 이미지를 지정합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Next, <bpt id="p1">[</bpt><ph id="ph1">`ADD`</ph><ept id="p1">](https://docs.docker.com/engine/reference/builder/#/add)</ept> in the file copies the application assets from the <bpt id="p2">**</bpt>publish<ept id="p2">**</ept> folder to root folder of the container and last; setting the <bpt id="p3">[</bpt><ph id="ph2">`ENTRYPOINT`</ph><ept id="p3">](https://docs.docker.com/engine/reference/builder/#/entrypoint)</ept> of the image states that this is the command or application that will run when the container starts.</source>
          <target state="translated">파일에 있는 <bpt id="p1">[</bpt><ph id="ph1">`ADD`</ph><ept id="p1">](https://docs.docker.com/engine/reference/builder/#/add)</ept>는 <bpt id="p2">**</bpt>publish<ept id="p2">**</ept> 폴더의 응용 프로그램 자산을 컨테이너의 루트 폴더에 복사합니다. 마지막으로, 이미지의 <bpt id="p3">[</bpt><ph id="ph2">`ENTRYPOINT`</ph><ept id="p3">](https://docs.docker.com/engine/reference/builder/#/entrypoint)</ept> 설정은 컨테이너를 시작할 때 실행할 명령 또는 응용 프로그램을 지정합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Creating the image</source>
          <target state="translated">이미지 만들기</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>In order to create the Docker image, the following code is added to the <bpt id="p1">*</bpt>build.ps1<ept id="p1">*</ept> script.</source>
          <target state="translated">Docker 이미지를 만들기 위해 다음 코드가 <bpt id="p1">*</bpt>build.ps1<ept id="p1">*</ept> 스크립트에 추가되었습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>When the script is run, the <ph id="ph1">`console-random-answer-generator`</ph> image is created using the assets compiled from MSBuild defined in the <bpt id="p1">[</bpt>Building the application<ept id="p1">](#building-the-application)</ept> section.</source>
          <target state="translated">스크립트를 실행하면 <bpt id="p1">[</bpt>응용 프로그램 빌드<ept id="p1">](#building-the-application)</ept> 섹션에서 정의된 MSBuild를 통해 컴파일된 자산을 사용하여 <ph id="ph1">`console-random-answer-generator`</ph> 이미지가 생성됩니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Run the script using <ph id="ph1">`.\build.ps1`</ph> from the PowerShell command prompt.</source>
          <target state="translated">PowerShell 명령 프롬프트에서 <ph id="ph1">`.\build.ps1`</ph>을 사용하여 스크립트를 실행합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>When the build is complete, using the <ph id="ph1">`docker images`</ph> command from a command line or PowerShell prompt; you'll see that the image is created and ready to be run.</source>
          <target state="translated">빌드가 완료된 후 명령줄 또는 PowerShell 프롬프트에서 <ph id="ph1">`docker images`</ph> 명령을 사용하면 이미지가 생성되고 실행할 준비가 완료됩니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Running the container</source>
          <target state="translated">컨테이너 실행</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can start the container from the command line using the Docker commands.</source>
          <target state="translated">Docker 명령을 사용하여 명령줄에서 컨테이너를 시작할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The output is</source>
          <target state="translated">출력은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If you run the <ph id="ph1">`docker ps -a`</ph> command from PowerShell, you can see that the container still exists.</source>
          <target state="translated">PowerShell에서 <ph id="ph1">`docker ps -a`</ph> 명령을 실행하면 해당 컨테이너가 여전히 있음을 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The STATUS column shows at "About a minute ago", the application was complete and could be shut down.</source>
          <target state="translated">STATUS 열에 "약 1분 전"이 표시되면 응용 프로그램이 완료된 것이며 종료할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If the command was run a hundred times, there would be a hundred containers left static with no work to do.</source>
          <target state="translated">명령을 백 번 실행한 경우 수행할 작업 없이 정적으로 유지되는 100개의 컨테이너가 있습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the beginning scenario the ideal operation was to do the work and shutdown or cleanup.</source>
          <target state="translated">시작 시나리오에서는 작업을 수행한 후 종료하거나 정리하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>To accomplish that workflow, adding the <ph id="ph1">`--rm`</ph> option to the <ph id="ph2">`docker run`</ph> command will remove the container as soon as the <ph id="ph3">`Exited`</ph> signal is received.</source>
          <target state="translated">해당 워크플로를 얻기 위해 <ph id="ph2">`docker run`</ph> 명령에 <ph id="ph1">`--rm`</ph> 옵션을 추가하면 <ph id="ph3">`Exited`</ph> 신호를 받는 즉시 컨테이너가 제거됩니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Running the command with this option and then looking at the output of <ph id="ph1">`docker ps -a`</ph> command; notice that the container id (the <ph id="ph2">`Environment.MachineName`</ph>) is not in the list.</source>
          <target state="translated">이 옵션으로 명령을 실행한 다음 <ph id="ph1">`docker ps -a`</ph> 명령의 출력을 살펴보면 컨테이너 ID(<ph id="ph2">`Environment.MachineName`</ph>)가 목록에 없는 것을 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Running the container using PowerShell</source>
          <target state="translated">PowerShell을 사용하여 컨테이너 실행</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>In the sample project files there is also a <bpt id="p1">*</bpt>run.ps1<ept id="p1">*</ept> which is an example of how to use PowerShell to run the application accepting the arguments.</source>
          <target state="translated">샘플 프로젝트 파일에는 PowerShell을 사용하여 인수를 수락하는 응용 프로그램을 실행하는 방법의 예인 <bpt id="p1">*</bpt>run.ps1<ept id="p1">*</ept>도 있습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>To run, open PowerShell and use the following command:</source>
          <target state="translated">실행하려면 PowerShell을 열고 다음 명령을 사용합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">요약</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Just by adding a Dockerfile and publishing the application, you can containerize your .NET Framework console applications and now take the advantage of running multiple instances, clean start and stop and more Windows Server 2016 capabilities without making any changes to the application code at all.</source>
          <target state="translated">Dockerfile을 추가하고 응용 프로그램을 게시하기만 하면 .NET Framework 콘솔 응용 프로그램을 컨테이너화할 수 있으며, 이제 응용 프로그램 코드를 변경하지 않고 여러 인스턴스 실행, 클린 시작 및 중지 등의 Windows Server 2016 기능을 활용할 수 있습니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>