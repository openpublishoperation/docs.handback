<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dfe2cebfbcf1f4c2697683ebda8c1e11567fd015</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\garbagecollection\implementing-dispose.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9c767e094bcc0eeef3aa68e876ddf7c6b336dc37</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a104a3574d5165774f427301e61a67f85eb2407f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Implementing a dispose method</source>
          <target state="translated">Dispose 메서드 구현</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Implementing a dispose method</source>
          <target state="translated">Dispose 메서드 구현</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Implementing a dispose method</source>
          <target state="translated">Dispose 메서드 구현</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You implement a <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> method to release unmanaged resources used by your application.</source>
          <target state="translated">응용 프로그램에서 사용하는 관리되지 않는 리소스를 해제하려면 <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> 메서드를 구현합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The .NET garbage collector does not allocate or release unmanaged memory.</source>
          <target state="translated">.NET 가비지 수집기는 관리되지 않는 메모리를 할당하거나 해제하지 않습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The pattern for disposing an object, referred to as a dispose pattern, imposes order on the lifetime of an object.</source>
          <target state="translated">삭제 패턴이라고도 하는 개체 삭제 패턴에서는 개체의 수명에 순서를 적용합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The dispose pattern is used only for objects that access unmanaged resources, such as file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</source>
          <target state="translated">삭제 패턴은 파일 핸들, 파이프 핸들, 레지스트리 핸들, 대기 핸들 또는 관리되지 않는 메모리의 블록에 대한 포인터와 같이 관리되지 않는 리소스에 액세스하는 개체에만 사용됩니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This is because the garbage collector is very efficient at reclaiming unused managed objects, but it is unable to reclaim unmanaged objects.</source>
          <target state="translated">이는 가비지 수집기가 사용되지 않은 관리되는 개체를 회수하는 데 매우 효율적이지만, 관리되지 않는 개체는 회수할 수 없기 때문입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The dispose pattern has two variations:</source>
          <target state="translated">삭제 패턴에는 두 가지 변형이 있습니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You wrap each unmanaged resource that a type uses in a safe handle (that is, in a class derived from <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept>).</source>
          <target state="translated">SafeHandle, 즉 <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept>에서 파생된 클래스에서 사용하는 형식의 관리되지 않는 리소스마다 각각 래핑합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In this case, you implement the <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> interface and an additional <ph id="ph1">`Dispose(Boolean)`</ph> method.</source>
          <target state="translated">이 경우 <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> 인터페이스와 추가 <ph id="ph1">`Dispose(Boolean)`</ph> 메서드를 구현합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This is the recommended variation and doesn't require overriding the <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> method.</source>
          <target state="translated">이는 권장되는 변형이며, <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> 메서드를 재정의할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Microsoft.Win32.SafeHandles<ept id="p1">](xref:Microsoft.Win32.SafeHandles)</ept> namespace provides a set of classes derived from <bpt id="p2">[</bpt>SafeHandle<ept id="p2">](xref:System.Runtime.InteropServices.SafeHandle)</ept>, which are listed in the <bpt id="p3">[</bpt>Using safe handles<ept id="p3">](#using-safe-handles)</ept> section.</source>
          <target state="translated"><bpt id="p1">[</bpt>Microsoft.Win32.SafeHandles<ept id="p1">](xref:Microsoft.Win32.SafeHandles)</ept> 네임스페이스는 <bpt id="p2">[</bpt>SafeHandle<ept id="p2">](xref:System.Runtime.InteropServices.SafeHandle)</ept>에서 파생된 클래스 집합을 제공합니다. 이러한 클래스는 <bpt id="p3">[</bpt>SafeHandle 사용<ept id="p3">](#using-safe-handles)</ept> 섹션에서 나열하고 있습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept>.</source>
          <target state="translated">관리되지 않는 리소스를 해제하는 데 적합한 클래스를 찾을 수 없는 경우 직접 <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> 서브클래스를 구현할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You implement the <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> interface and an additional <ph id="ph1">`Dispose(Boolean`</ph>) method, and you also override the <bpt id="p2">[</bpt>Object.Finalize<ept id="p2">](xref:System.Object.Finalize)</ept> method.</source>
          <target state="translated"><bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> 인터페이스와 추가 <ph id="ph1">`Dispose(Boolean`</ph> 메서드를 구현하고 <bpt id="p2">[</bpt>Object.Finalize<ept id="p2">](xref:System.Object.Finalize)</ept> 메서드도 재정의합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You must override <bpt id="p1">[</bpt>Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> to ensure that unmanaged resources are disposed of if your <bpt id="p2">[</bpt>IDisposable.Dispose<ept id="p2">](xref:System.IDisposable.Dispose)</ept> implementation is not called by a consumer of your type.</source>
          <target state="translated">사용자 지정 형식의 소비자에서 <bpt id="p2">[</bpt>IDisposable.Dispose<ept id="p2">](xref:System.IDisposable.Dispose)</ept> 구현을 호출하지 않는 경우 관리되지 않는 리소스를 삭제하도록 <bpt id="p1">[</bpt>Finalize<ept id="p1">](xref:System.Object.Finalize)</ept>를 재정의해야 합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you use the recommended technique discussed in the previous bullet, the <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> class does this on your behalf.</source>
          <target state="translated">이전 글머리 기호에서 설명된 권장 방법을 사용하는 경우 사용자를 대신하여 <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> 클래스에서 이 작업을 수행합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To help ensure that resources are always cleaned up appropriately, a <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> method should be callable multiple times without throwing an exception.</source>
          <target state="translated">항상 리소스가 적절히 정리되도록 하려면 예외를 throw하지 않은 채 <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> 메서드를 여러 번 호출할 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The code example provided for the <bpt id="p1">[</bpt>GC.KeepAlive<ept id="p1">](xref:System.GC.KeepAlive(System.Object))</ept> method shows how aggressive garbage collection can cause a finalizer to run while a member of the reclaimed object is still executing.</source>
          <target state="translated"><bpt id="p1">[</bpt>GC.KeepAlive<ept id="p1">](xref:System.GC.KeepAlive(System.Object))</ept> 메서드의 코드 예제에서는 적극적인 가비지 수집으로 인해 회수되는 개체의 멤버가 아직 실행되고 있어도 종료자를 실행할 수 있게 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>It is a good idea to call the <bpt id="p1">[</bpt>KeepAlive<ept id="p1">](xref:System.GC.KeepAlive(System.Object))</ept> method at the end of a lengthy <ph id="ph1">`Dispose`</ph> method.</source>
          <target state="translated"><ph id="ph1">`Dispose`</ph> 메서드를 오래 실행한 후에 <bpt id="p1">[</bpt>KeepAlive<ept id="p1">](xref:System.GC.KeepAlive(System.Object))</ept> 메서드를 호출하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Dispose() and Dispose(Boolean)</source>
          <target state="translated">Dispose() 및 Dispose(Boolean)</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> interface requires the implementation of a single parameterless method, <bpt id="p2">[</bpt>Dispose<ept id="p2">](xref:System.IDisposable.Dispose)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> 인터페이스에서는 매개 변수가 없는 단일 메서드인 <bpt id="p2">[</bpt>Dispose<ept id="p2">](xref:System.IDisposable.Dispose)</ept>를 구현해야 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>However, the dispose pattern requires two <ph id="ph1">`Dispose`</ph> methods to be implemented:</source>
          <target state="translated">그러나 삭제 패턴을 사용하려면 다음과 같은 두 가지 <ph id="ph1">`Dispose`</ph> 메서드를 구현해야 합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A public non-virtual (<ph id="ph1">`NonInheritable`</ph> in Visual Basic) <bpt id="p1">[</bpt>IDisposable.Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> implementation that has no parameters.</source>
          <target state="translated">매개 변수가 없는 공용 비가상(Visual Basic의 경우 <ph id="ph1">`NonInheritable`</ph>) <bpt id="p1">[</bpt>IDisposable.Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> 구현</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>A protected virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic) <ph id="ph2">`Dispose`</ph> method whose signature is:</source>
          <target state="translated">시그니처가 다음과 같은 보호된 가상(Visual Basic의 <ph id="ph1">`Overridable`</ph>) <ph id="ph2">`Dispose`</ph> 메서드:</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The Dispose() overload</source>
          <target state="translated">Dispose() 오버로드</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Because the public, non-virtual (<ph id="ph1">`NonInheritable`</ph> in Visual Basic), parameterless <ph id="ph2">`Dispose`</ph> method is called by a consumer of the type, its purpose is to free unmanaged resources and to indicate that the finalizer, if one is present, doesn't have to run.</source>
          <target state="translated">공용, 비가상(Visual Basic의 경우 <ph id="ph1">`NonInheritable`</ph>), 매개 변수가 없는 <ph id="ph2">`Dispose`</ph> 메서드는 형식의 소비자에 의해 호출되므로, 관리되지 않는 리소스를 해제하고 종료자(있는 경우)를 실행할 필요가 없음을 나타내기 위한 것입니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Because of this, it has a standard implementation:</source>
          <target state="translated">이로 인해 다음과 같은 표준 구현이 수행됩니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Dispose`</ph> method performs all object cleanup, so the garbage collector no longer needs to call the objects' <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> override.</source>
          <target state="translated"><ph id="ph1">`Dispose`</ph> 메서드에서 모든 개체를 정리하므로 가비지 수집기에서 개체의 <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> 재정의를 더 이상 호출할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Therefore, the call to the <bpt id="p1">[</bpt>GC.SuppressFinalize<ept id="p1">](xref:System.GC.SuppressFinalize(System.Object))</ept> method prevents the garbage collector from running the finalizer.</source>
          <target state="translated">따라서 <bpt id="p1">[</bpt>GC.SuppressFinalize<ept id="p1">](xref:System.GC.SuppressFinalize(System.Object))</ept> 메서드를 호출하면 가비지 수집기에서 종료자를 실행하지 않도록 차단합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If the type has no finalizer, the call to <bpt id="p1">[</bpt>SuppressFinalize<ept id="p1">](xref:System.GC.SuppressFinalize(System.Object))</ept> has no effect.</source>
          <target state="translated">종료자가 형식에 없는 경우 <bpt id="p1">[</bpt>SuppressFinalize<ept id="p1">](xref:System.GC.SuppressFinalize(System.Object))</ept>를 호출하더라도 아무런 영향을 미치지 않습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Note that the actual work of releasing unmanaged resources is performed by the second overload of the <ph id="ph1">`Dispose`</ph> method.</source>
          <target state="translated"><ph id="ph1">`Dispose`</ph> 메서드의 두 번째 오버로드에서 실제로 관리되지 않는 리소스를 해제하는 작업이 수행됩니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The Dispose(Boolean) overload</source>
          <target state="translated">Dispose(Boolean) 오버로드</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In the second overload, the <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> parameter is a <bpt id="p2">[</bpt>Boolean<ept id="p2">](xref:System.Boolean)</ept> that indicates whether the method call comes from a <bpt id="p3">[</bpt>Dispose<ept id="p3">](xref:System.IDisposable.Dispose)</ept> method (its value is <ph id="ph1">`true`</ph>) or from a finalizer (its value is <ph id="ph2">`false`</ph>).</source>
          <target state="translated">두 번째 오버로드에서 메서드 호출이 <bpt id="p3">[</bpt>Dispose<ept id="p3">](xref:System.IDisposable.Dispose)</ept>(<ph id="ph1">`true`</ph> 값)에서 나오는지 또는 종료자(<ph id="ph2">`false`</ph> 값)에서 나오는지를 나타내는 <bpt id="p2">[</bpt>Boolean<ept id="p2">](xref:System.Boolean)</ept>이 <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The body of the method consists of two blocks of code:</source>
          <target state="translated">메서드 본문은 다음과 같은 두 가지 코드 블록으로 구성됩니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>A block that frees unmanaged resources.</source>
          <target state="translated">관리되지 않는 리소스를 해제하는 블록.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This block executes regardless of the value of the <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> parameter.</source>
          <target state="translated"><bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> 매개 변수의 값에 관계없이 실행되는 블록입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A conditional block that frees managed resources.</source>
          <target state="translated">관리되는 리소스를 해제하는 조건부 블록.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This block executes if the value of <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> is <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> 값이 <ph id="ph1">`true`</ph>일 때 실행되는 블록입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The managed resources that it frees can include:</source>
          <target state="translated">해제되는 관리되는 리소스는 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Managed objects that implement IDisposable<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>IDisposable을 구현하는 관리되는 개체<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The conditional block can be used to call their <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> implementation.</source>
          <target state="translated">조건부 블록을 사용하여 <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> 구현을 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If you have used a safe handle to wrap your unmanaged resource, you should call the <bpt id="p1">[</bpt>SafeHandle.Dispose(Boolean<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean))</ept> implementation here.</source>
          <target state="translated">관리되지 않는 리소스를 래핑하기 위해 SafeHandle을 사용한 경우에는 여기서 <bpt id="p1">[</bpt>SafeHandle.Dispose(Boolean<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean))</ept>) 구현을 호출해야 합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Managed objects that consume large amounts of memory or consume scarce resources.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>많은 메모리를 사용하거나 부족한 리소스를 사용하는 관리되는 개체.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Freeing these objects explicitly in the <ph id="ph1">`Dispose`</ph> method releases them faster than if they were reclaimed non-deterministically by the garbage collector.</source>
          <target state="translated">이러한 개체를 <ph id="ph1">`Dispose`</ph> 메서드에서 명시적으로 해제하면 가비지 수집기에서 명확하지 않게 회수한 경우보다 빠르게 해제할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If the method call comes from a finalizer (that is, if <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> is <ph id="ph1">`false`</ph>), only the code that frees unmanaged resources executes.</source>
          <target state="translated">메서드 호출이 종료자에서 나오는 경우, 즉 <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept>이 <ph id="ph1">`false`</ph>인 경우 관리되지 않는 리소스를 해제하는 코드만 실행됩니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Because the order in which the garbage collector destroys managed objects during finalization is not defined, calling this <ph id="ph1">`Dispose`</ph> overload with a value of <ph id="ph2">`false`</ph> prevents the finalizer from trying to release managed resources that may have already been reclaimed.</source>
          <target state="translated">종료하는 동안 가비지 수집기가 관리되는 개체를 제거하는 순서가 정의되어 있지 않기 때문에 <ph id="ph1">`Dispose`</ph> 값으로 이 <ph id="ph2">`false`</ph> 오버로드를 호출하면 종료자가 이미 회수된 관리되는 리소스를 해제하려고 시도하지 못합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Implementing the dispose pattern for a base class</source>
          <target state="translated">기본 클래스에 대한 삭제 패턴 구현</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If you implement the dispose pattern for a base class, you must provide the following:</source>
          <target state="translated">기본 클래스에 대한 삭제 패턴을 구현하는 경우 다음을 제공해야 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You should implement this pattern for all base classes that implement <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> and are not <ph id="ph1">`sealed`</ph>.</source>
          <target state="translated"><bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept>을 구현하고 <ph id="ph1">`sealed`</ph>가 아닌 모든 기본 클래스에서 이 패턴을 구현해야 합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> implementation that calls the <ph id="ph1">`Dispose(Boolean)`</ph> method.</source>
          <target state="translated"><ph id="ph1">`Dispose(Boolean)`</ph> 메서드를 호출하는 <bpt id="p1">[</bpt>Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept> 구현</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dispose(Boolean)`</ph> method that performs the actual work of releasing resources.</source>
          <target state="translated">실제로 리소스를 해제하는 작업을 수행하는 <ph id="ph1">`Dispose(Boolean)`</ph> 메서드</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Either a class derived from <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> that wraps your unmanaged resource (recommended), or an override to the <bpt id="p2">[</bpt>Object.Finalize<ept id="p2">](xref:System.Object.Finalize)</ept> method.</source>
          <target state="translated">관리되지 않는 리소스를 래핑하는 <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept>에서 파생된 클래스(권장) 또는 <bpt id="p2">[</bpt>Object.Finalize<ept id="p2">](xref:System.Object.Finalize)</ept> 메서드 재정의.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept>SafeHandle class provides a finalizer that frees you from having to code one.</source>
          <target state="translated"><bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> 클래스는 코딩할 필요가 없는 종료자를 제공합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</source>
          <target state="translated">SafeHandle을 사용하는 기본 클래스에 대한 삭제 패턴을 구현하는 일반적인 패턴은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The previous example uses a <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> object to illustrate the pattern; any object derived from <bpt id="p2">[</bpt>SafeHandle<ept id="p2">](xref:System.Runtime.InteropServices.SafeHandle)</ept> could be used instead.</source>
          <target state="translated">이전 예제에서는 <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> 개체를 사용하여 패턴을 보여 줍니다. <bpt id="p2">[</bpt>SafeHandle<ept id="p2">](xref:System.Runtime.InteropServices.SafeHandle)</ept>에서 파생된 개체를 대신 사용할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Note that the example does not properly instantiate its <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> object.</source>
          <target state="translated">예제에서는 해당 <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> 개체를 제대로 인스턴스화하지 않습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Here's the general pattern for implementing the dispose pattern for a base class that overrides <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept>를 재정의하는 기본 클래스의 삭제 패턴을 구현하는 일반적인 패턴은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In C#, you override <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> by defining a <ph id="ph1">`destructor`</ph>.</source>
          <target state="translated">C#의 경우 <ph id="ph1">`destructor`</ph>를 정의하여 <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept>를 재정의합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Implementing the dispose pattern for a derived class</source>
          <target state="translated">파생된 클래스에 대한 삭제 패턴 구현</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A class derived from a class that implements the <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> interface shouldn't implement <bpt id="p2">[</bpt>IDisposable<ept id="p2">](xref:System.IDisposable)</ept>, because the base class implementation of <bpt id="p3">[</bpt>IDisposable.Dispose<ept id="p3">](xref:System.IDisposable.Dispose)</ept> is inherited by its derived classes.</source>
          <target state="translated">파생된 클래스에서 <bpt id="p3">[</bpt>IDisposable.Dispose<ept id="p3">](xref:System.IDisposable.Dispose)</ept>의 기본 클래스 구현을 상속하므로 <bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept> 인터페이스를 구현하는 클래스로부터 파생된 클래스에서 <bpt id="p2">[</bpt>IDisposable<ept id="p2">](xref:System.IDisposable)</ept>을 구현하지 않아야 합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Instead, to implement the dispose pattern for a derived class, you provide the following:</source>
          <target state="translated">대신 파생된 클래스에 대한 삭제 패턴을 구현하려면 다음을 제공합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`protected Dispose(Boolean)`</ph> method that overrides the base class method and performs the actual work of releasing the resources of the derived class.</source>
          <target state="translated">기본 클래스 메서드를 재정의하고 파생된 클래스의 리소스를 해제하는 실제 작업을 수행하는 <ph id="ph1">`protected Dispose(Boolean)`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This method should also call the <ph id="ph1">`Dispose(Boolean)`</ph> method of the base class and pass it a value of <ph id="ph2">`true`</ph> for the <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> argument.</source>
          <target state="translated">이 메서드도 기본 클래스의 <ph id="ph1">`Dispose(Boolean)`</ph> 메서드를 호출하여 <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> 인수의 <ph id="ph2">`true`</ph> 값을 전달합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Either a class derived from <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> that wraps your unmanaged resource (recommended), or an override to the <bpt id="p2">[</bpt>Object.Finalize<ept id="p2">](xref:System.Object.Finalize)</ept> method.</source>
          <target state="translated">관리되지 않는 리소스를 래핑하는 <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept>에서 파생된 클래스(권장) 또는 <bpt id="p2">[</bpt>Object.Finalize<ept id="p2">](xref:System.Object.Finalize)</ept> 메서드 재정의.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> class provides a finalizer that frees you from having to code one.</source>
          <target state="translated"><bpt id="p1">[</bpt>SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> 클래스는 코딩할 필요가 없는 종료자를 제공합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If you do provide a finalizer, it should call the <ph id="ph1">`Dispose(Boolean)`</ph> overload with a <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> argument of <ph id="ph2">`false`</ph>.</source>
          <target state="translated">종료자를 제공하는 경우 <bpt id="p1">*</bpt>disposing<ept id="p1">*</ept> 인수가 <ph id="ph2">`false`</ph>인 <ph id="ph1">`Dispose(Boolean)`</ph> 오버로드를 호출해야 합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</source>
          <target state="translated">SafeHandle을 사용하는 파생된 클래스에 대한 삭제 패턴을 구현하는 일반적인 패턴은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The previous example uses a <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> object to illustrate the pattern; any object derived from <bpt id="p2">[</bpt>SafeHandle<ept id="p2">](xref:System.Runtime.InteropServices.SafeHandle)</ept> could be used instead.</source>
          <target state="translated">이전 예제에서는 <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> 개체를 사용하여 패턴을 보여 줍니다. <bpt id="p2">[</bpt>SafeHandle<ept id="p2">](xref:System.Runtime.InteropServices.SafeHandle)</ept>에서 파생된 개체를 대신 사용할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Note that the example does not properly instantiate its <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> object.</source>
          <target state="translated">예제에서는 해당 <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> 개체를 제대로 인스턴스화하지 않습니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Here's the general pattern for implementing the dispose pattern for a derived class that overrides <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept>:</source>
          <target state="translated"><bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept>를 재정의하는 파생된 클래스의 삭제 패턴을 구현하는 일반적인 패턴은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In C#, you override <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept> by defining a <ph id="ph1">`destructor`</ph>.</source>
          <target state="translated">C#의 경우 <ph id="ph1">`destructor`</ph>를 정의하여 <bpt id="p1">[</bpt>Object.Finalize<ept id="p1">](xref:System.Object.Finalize)</ept>를 재정의합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Using safe handles</source>
          <target state="translated">SafeHandle 사용</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</source>
          <target state="translated">개체 종료자에 대한 코드를 작성하는 작업은 올바르게 수행되지 않을 경우 문제를 일으킬 수 있는 복잡한 작업입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Therefore, we recommend that you construct <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> objects instead of implementing a finalizer.</source>
          <target state="translated">따라서 종료자를 구현하는 대신 <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> 개체를 생성하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Classes derived from the <bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> class simplify object lifetime issues by assigning and releasing handles without interruption.</source>
          <target state="translated"><bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept> 클래스에서 파생된 클래스는 중단 없이 핸들을 할당하고 해제하여 개체 수명 문제를 단순화합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>They contain a critical finalizer that is guaranteed to run while an application domain is unloading.</source>
          <target state="translated">여기에는 응용 프로그램 도메인을 언로드하는 동안 실행이 보장되는 중요한 종료자가 포함됩니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The following derived classes in the <bpt id="p1">[</bpt>Microsoft.Win32.SafeHandles<ept id="p1">](xref:Microsoft.Win32.SafeHandles)</ept> namespace provide safe handles:</source>
          <target state="translated"><bpt id="p1">[</bpt>Microsoft.Win32.SafeHandles<ept id="p1">](xref:Microsoft.Win32.SafeHandles)</ept> 네임스페이스에서 SafeHandle을 제공하는 파생된 클래스는 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept>, <bpt id="p2">[</bpt>SafeMemoryMappedFileHandle<ept id="p2">](xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle)</ept>, and <bpt id="p3">[</bpt>SafePipeHandle<ept id="p3">](xref:Microsoft.Win32.SafeHandles.SafePipeHandle)</ept> class, for files, memory mapped files, and pipes.</source>
          <target state="translated">파일, 메모리 매핑된 파일 및 파이프에 대한 <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept>, <bpt id="p2">[</bpt>SafeMemoryMappedFileHandle<ept id="p2">](xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle)</ept> 및 <bpt id="p3">[</bpt>SafePipeHandle<ept id="p3">](xref:Microsoft.Win32.SafeHandles.SafePipeHandle)</ept> 클래스</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeMemoryMappedViewHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle)</ept> class, for memory views.</source>
          <target state="translated">메모리 뷰에 대한 <bpt id="p1">[</bpt>SafeMemoryMappedViewHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle)</ept> 클래스</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeNCryptKeyHandle<ept id="p1">](https://msdn.microsoft.com/en-us/library/microsoft.win32.safehandles.safencryptkeyhandle(v=vs.110).aspx)</ept>, <bpt id="p2">[</bpt>SafeNCryptProviderHandle<ept id="p2">](https://msdn.microsoft.com/en-us/library/microsoft.win32.safehandles.safencryptproviderhandle(v=vs.110).aspx)</ept>, and <bpt id="p3">[</bpt>SafeNCryptSecretHandle<ept id="p3">](https://msdn.microsoft.com/en-us/library/microsoft.win32.safehandles.safencryptsecrethandle(v=vs.110).aspx)</ept> classes, for cryptography constructs.</source>
          <target state="translated">암호화 구문에 대한 <bpt id="p1">[</bpt>SafeNCryptKeyHandle<ept id="p1">](https://msdn.microsoft.com/en-us/library/microsoft.win32.safehandles.safencryptkeyhandle(v=vs.110).aspx)</ept>, <bpt id="p2">[</bpt>SafeNCryptProviderHandle<ept id="p2">](https://msdn.microsoft.com/en-us/library/microsoft.win32.safehandles.safencryptproviderhandle(v=vs.110).aspx)</ept> 및 <bpt id="p3">[</bpt>SafeNCryptSecretHandle<ept id="p3">](https://msdn.microsoft.com/en-us/library/microsoft.win32.safehandles.safencryptsecrethandle(v=vs.110).aspx)</ept> 클래스</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeRegistryHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle)</ept> class, for registry keys.</source>
          <target state="translated">레지스트리 키에 대한 <bpt id="p1">[</bpt>SafeRegistryHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle)</ept> 클래스</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>SafeWaitHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeWaitHandle)</ept> class, for wait handles.</source>
          <target state="translated">대기 핸들에 대한 <bpt id="p1">[</bpt>SafeWaitHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeWaitHandle)</ept> 클래스</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Using a safe handle to implement the dispose pattern for a base class</source>
          <target state="translated">SafeHandle을 사용하여 기본 클래스에 대한 삭제 패턴 구현</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The following example illustrates the dispose pattern for a base class, <ph id="ph1">`DisposableStreamResource`</ph>, that uses a safe handle to encapsulate unmanaged resources.</source>
          <target state="translated">다음 예제는 SafeHandle을 사용하여 관리되지 않는 리소스를 캡슐화하는 기본 클래스에 대한 삭제 패턴인 <ph id="ph1">`DisposableStreamResource`</ph>를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>It defines a <ph id="ph1">`DisposableResource`</ph> class that uses a <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> to wrap a <bpt id="p2">[</bpt>Stream<ept id="p2">](xref:System.IO.Stream)</ept> object that represents an open file.</source>
          <target state="translated">이는 <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept>을 사용하여 열려 있는 파일을 나타내는 <bpt id="p2">[</bpt>Stream<ept id="p2">](xref:System.IO.Stream)</ept> 개체를 래핑하는 <ph id="ph1">`DisposableResource`</ph> 클래스를 정의합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`DisposableResource`</ph> method also includes a single property, <ph id="ph2">`Size`</ph>, that returns the total number of bytes in the file stream.</source>
          <target state="translated">또한 <ph id="ph1">`DisposableResource`</ph> 메서드에는 파일 스트림에서 총 바이트 수를 반환하는 단일 속성인 <ph id="ph2">`Size`</ph>도 포함됩니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Using a safe handle to implement the dispose pattern for a derived class</source>
          <target state="translated">SafeHandle을 사용하여 파생된 클래스에 대한 삭제 패턴 구현</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The following example illustrates the dispose pattern for a derived class, <ph id="ph1">`DisposableStreamResource2`</ph>, that inherits from the <ph id="ph2">`DisposableStreamResource`</ph> class presented in the previous example.</source>
          <target state="translated">다음 예제는 이전 예제에 제공된 <ph id="ph1">`DisposableStreamResource2`</ph> 클래스에서 상속되는 파생된 클래스에 대한 삭제 패턴인 <ph id="ph2">`DisposableStreamResource`</ph>를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The class adds an additional method, <ph id="ph1">`WriteFileInfo`</ph>, and uses a <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> object to wrap the handle of the writable file.</source>
          <target state="translated">클래스에서 <ph id="ph1">`WriteFileInfo`</ph> 추가 메서드를 추가하고 <bpt id="p1">[</bpt>SafeFileHandle<ept id="p1">](xref:Microsoft.Win32.SafeHandles.SafeFileHandle)</ept> 개체를 사용하여 쓰기 가능 파일의 핸들을 래핑합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SuppressFinalize<ept id="p1">](xref:System.GC.SuppressFinalize(System.Object))</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>SuppressFinalize<ept id="p1">](xref:System.GC.SuppressFinalize(System.Object))</ept></target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IDisposable<ept id="p1">](xref:System.IDisposable)</ept></target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IDisposable.Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IDisposable.Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept></target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Microsoft.Win32.SafeHandles<ept id="p1">](xref:Microsoft.Win32.SafeHandles)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Microsoft.Win32.SafeHandles<ept id="p1">](xref:Microsoft.Win32.SafeHandles)</ept></target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Runtime.InteropServices.SafeHandle<ept id="p1">](xref:System.Runtime.InteropServices.SafeHandle)</ept></target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IDisposable.Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IDisposable.Dispose<ept id="p1">](xref:System.IDisposable.Dispose)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>