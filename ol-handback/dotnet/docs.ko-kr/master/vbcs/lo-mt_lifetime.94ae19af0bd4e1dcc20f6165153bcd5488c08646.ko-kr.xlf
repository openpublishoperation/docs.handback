<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fa0cbdf4a8fe5e8fc41e4e4f373c79451fb7b75f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\declared-elements\lifetime.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">022c43d985d495bbb7731dabddd51b970ba41534</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8cc4415f003b59929429da4b12a080048e739a02</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Lifetime in Visual Basic | Microsoft Docs</source>
          <target state="translated">Visual Basic의 수명 | Microsoft 문서</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Lifetime in Visual Basic</source>
          <target state="translated">Visual Basic의 수명</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>lifetime<ept id="p1">*</ept> of a declared element is the period of time during which it is available for use.</source>
          <target state="translated"><bpt id="p1">*</bpt>수명<ept id="p1">*</ept> 선언 요소의 시간 동안 어떤 용도로 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Variables are the only elements that have lifetime.</source>
          <target state="translated">변수는 수명이 있는 유일한 요소입니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For this purpose, the compiler treats procedure parameters and function returns as special cases of variables.</source>
          <target state="translated">이 위해 컴파일러는 프로시저 매개 변수를 처리 및 변수의 특별 한 경우로 함수를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The lifetime of a variable represents the period of time during which it can hold a value.</source>
          <target state="translated">변수의 수명 값을 저장할 수 있는 기간을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Its value can change over its lifetime, but it always holds some value.</source>
          <target state="translated">해당 값은 해당 수명 동안 변경 될 수 있지만 항상 어떤 값을 가집니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Different Lifetimes</source>
          <target state="translated">다른 수명</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>member variable<ept id="p1">*</ept> (declared at module level, outside any procedure) typically has the same lifetime as the element in which it is declared.</source>
          <target state="translated">A <bpt id="p1">*</bpt>멤버 변수<ept id="p1">*</ept> (다른 프로시저 외부의 모듈 수준에서 선언 됨) 일반적으로 수명이 같은 선언 된 요소입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>A nonshared variable declared in a class or structure exists as a separate copy for each instance of the class or structure in which it is declared.</source>
          <target state="translated">클래스 또는 구조체에 선언 된 비공유 변수 선언 된 구조체의 각 인스턴스에 대해 별도 복사본으로 존재 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Each such variable has the same lifetime as its instance.</source>
          <target state="translated">각 변수는 해당 인스턴스로 수명이 동일 합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>However, a <ph id="ph1">`Shared`</ph> variable has only a single lifetime, which lasts for the entire time your application is running.</source>
          <target state="translated">그러나 한 <ph id="ph1">`Shared`</ph> 변수는 응용 프로그램을 실행 하는 전체 기간 동안 지속 되는 단일 수명이 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>local variable<ept id="p1">*</ept> (declared inside a procedure) exists only while the procedure in which it is declared is running.</source>
          <target state="translated">A <bpt id="p1">*</bpt>지역 변수<ept id="p1">*</ept> (프로시저 내에 선언 된) 선언 된 프로시저를 실행 하는 동안에 존재 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This applies also to that procedure's parameters and to any function return.</source>
          <target state="translated">또한 모든 함수 반환 값 및 해당 프로시저의 매개 변수에 적용 됩니다이.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>However, if that procedure calls other procedures, the local variables retain their values while the called procedures are running.</source>
          <target state="translated">그러나 해당 프로시저가 다른 프로시저를 호출 하는 경우 지역 변수 값을 유지 호출된 프로시저를 실행 하는 동안.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Beginning of Lifetime</source>
          <target state="translated">수명의 시작</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A local variable's lifetime begins when control enters the procedure in which it is declared.</source>
          <target state="translated">로컬 변수의 수명 제어가 선언 되는 프로시저를 입력할 때 시작 됩니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Every local variable is initialized to the default value for its data type as soon as the procedure begins running.</source>
          <target state="translated">프로시저를 시작 하는 즉시 모든 지역 변수 데이터 형식에 대 한 기본 값으로 초기화 됩니다를 실행 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>When the procedure encounters a <ph id="ph1">`Dim`</ph> statement that specifies initial values, it sets those variables to those values, even if your code had already assigned other values to them.</source>
          <target state="translated">프로시저가 발견 하는 경우는 <ph id="ph1">`Dim`</ph> 초기 값을 지정 하는 문을 해당 변수를 설정 하려면 이러한 값을 코드에 이미 다른 값을 할당 한 경우에 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Each member of a structure variable is initialized as if it were a separate variable.</source>
          <target state="translated">구조체 변수의 각 멤버는 마치는 별도 변수인 것 처럼 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Similarly, each element of an array variable is initialized individually.</source>
          <target state="translated">마찬가지로, 배열 변수의 각 요소는 개별적으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Variables declared within a block inside a procedure (such as a <ph id="ph1">`For`</ph> loop) are initialized on entry to the procedure.</source>
          <target state="translated">프로시저 내의 블록 내에서 선언 된 변수 (예:는 <ph id="ph1">`For`</ph> 루프) 프로시저에는 항목에 대해 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>These initializations take effect whether or not your code ever executes the block.</source>
          <target state="translated">이러한 초기화 코드 블록 실행 여부를 적용 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>End of Lifetime</source>
          <target state="translated">수명의 끝</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>When a procedure terminates, the values of its local variables are not preserved, and <ph id="ph1">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> reclaims their memory.</source>
          <target state="translated">프로시저 종료 되 면 해당 지역 변수의 값 유지 되지 않습니다, 그리고 및 <ph id="ph1">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> 해당 메모리를 회수 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The next time you call the procedure, all its local variables are created afresh and reinitialized.</source>
          <target state="translated">다음에 프로시저를 호출할 때 모든 지역 변수가 다시 만들고 다시 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>When an instance of a class or structure terminates, its nonshared variables lose their memory and their values.</source>
          <target state="translated">클래스 또는 구조체의 인스턴스를 종료 하는 경우의 메모리와 해당 값 비공유 변수의 손실 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Each new instance of the class or structure creates and reinitializes its nonshared variables.</source>
          <target state="translated">클래스 또는 구조체의 각 새 인스턴스를 만들고 비공유 변수의 다시 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>However, <ph id="ph1">`Shared`</ph> variables are preserved until your application stops running.</source>
          <target state="translated">그러나 <ph id="ph1">`Shared`</ph> 변수는 응용 프로그램의 실행이 중지 될 때까지 유지 됩니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Extension of Lifetime</source>
          <target state="translated">수명의 연장</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If you declare a local variable with the <ph id="ph1">`Static`</ph> keyword, its lifetime is longer than the execution time of its procedure.</source>
          <target state="translated">사용 하 여 로컬 변수를 선언 하는 경우는 <ph id="ph1">`Static`</ph> 키워드를 수명 보다 길면 해당 프로시저의 실행 시간입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following table shows how the procedure declaration determines how long a <ph id="ph1">`Static`</ph> variable exists.</source>
          <target state="translated">다음 표에서 프로시저 선언 기간 결정 하는 방법을 보여 줍니다.는 <ph id="ph1">`Static`</ph> 변수가 존재 합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Procedure location and sharing</source>
          <target state="translated">프로시저 위치 및 공유</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Static variable lifetime begins</source>
          <target state="translated">정적 변수 수명을 시작합니다</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Static variable lifetime ends</source>
          <target state="translated">정적 변수 수명 끝</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>In a module (shared by default)</source>
          <target state="translated">(기본적으로 공유) 모듈에서</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The first time the procedure is called</source>
          <target state="translated">처음에 프로시저 호출 될 때</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>When your application stops running</source>
          <target state="translated">응용 프로그램 실행이 중지 될 때</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In a class, <ph id="ph1">`Shared`</ph> (procedure is not an instance member)</source>
          <target state="translated">클래스에서 <ph id="ph1">`Shared`</ph> (절차는 인스턴스 멤버가 아님)</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The first time the procedure is called either on a specific instance or on the class or structure name itself</source>
          <target state="translated">처음으로 프로시저를 호출할 특정 인스턴스 또는 자체 클래스 또는 구조체 이름</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>When your application stops running</source>
          <target state="translated">응용 프로그램 실행이 중지 될 때</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In an instance of a class, not <ph id="ph1">`Shared`</ph> (procedure is an instance member)</source>
          <target state="translated">클래스의 인스턴스에 하지 <ph id="ph1">`Shared`</ph> (절차는 인스턴스 멤버는)</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The first time the procedure is called on the specific instance</source>
          <target state="translated">프로시저 라고 하는 특정 인스턴스에 처음으로</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When the instance is released for garbage collection (GC)</source>
          <target state="translated">가비지 수집 (GC)에 인스턴스가 해제 되는 경우</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Static Variables of the Same Name</source>
          <target state="translated">이름이 같은 정적 변수</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can declare static variables with the same name in more than one procedure.</source>
          <target state="translated">둘 이상의 프로시저에 같은 이름의 정적 변수를 선언할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If you do this, the <ph id="ph1">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> compiler considers each such variable to be a separate element.</source>
          <target state="translated">이 작업을 수행 하는 경우는 <ph id="ph1">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> 컴파일러는 각 변수를 별도 요소로 간주 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The initialization of one of these variables does not affect the values of the others.</source>
          <target state="translated">이러한 변수 중 하나를 초기화할 때 다른 값 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The same applies if you define a procedure with a set of overloads and declare a static variable with the same name in each overload.</source>
          <target state="translated">오버 로드 집합이 있는 프로시저를 정의 하 고 각 오버 로드에 동일한 이름 가진 정적 변수를 선언 하는 경우에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Containing Elements for Static Variables</source>
          <target state="translated">정적 변수에 대 한 요소가 포함 된</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can declare a static local variable within a class, that is, inside a procedure in that class.</source>
          <target state="translated">해당 클래스의 프로시저 즉, 클래스 내의 정적 지역 변수를 선언할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>However, you cannot declare a static local variable within a structure, either as a structure member or as a local variable of a procedure within that structure.</source>
          <target state="translated">그러나 구조체 멤버 또는 해당 구조 내에서 프로시저의 지역 변수로 구조체에 정적 지역 변수를 선언할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">예제</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The following example declares a variable with the <bpt id="p1">[</bpt>Static<ept id="p1">](../../../../visual-basic/language-reference/modifiers/static.md)</ept> keyword.</source>
          <target state="translated">다음 예제에서는 사용 하 여 변수를 선언 된 <bpt id="p1">[</bpt>정적<ept id="p1">](../../../../visual-basic/language-reference/modifiers/static.md)</ept> 키워드입니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>(Note that you do not need the <ph id="ph1">`Dim`</ph> keyword when the <bpt id="p1">[</bpt>Dim Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/dim-statement.md)</ept> uses a modifier such as <ph id="ph2">`Static`</ph>.)</source>
          <target state="translated">(참고 필요 하지 않은 <ph id="ph1">`Dim`</ph> 키워드 때는 <bpt id="p1">[</bpt>Dim<ept id="p1">](../../../../visual-basic/language-reference/statements/dim-statement.md)</ept> 와 같은 한정자를 사용 하 여 <ph id="ph2">`Static`</ph>.)</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">코드</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrKeywords#13<ept id="p2">](../../../../visual-basic/language-reference/codesnippet/VisualBasic/lifetime_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrKeywords #&amp;13;<ept id="p2">](../../../../visual-basic/language-reference/codesnippet/VisualBasic/lifetime_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In the preceding example, the variable <ph id="ph1">`applesSold`</ph> continues to exist after the procedure <ph id="ph2">`runningTotal`</ph> returns to the calling code.</source>
          <target state="translated">위의 예제에서는 변수에서에서 <ph id="ph1">`applesSold`</ph> 계속 존재는 절차를 수행한 후 <ph id="ph2">`runningTotal`</ph> 호출 코드로 반환 합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The next time <ph id="ph1">`runningTotal`</ph> is called, <ph id="ph2">`applesSold`</ph> retains its previously calculated value.</source>
          <target state="translated">다음에 <ph id="ph1">`runningTotal`</ph> 이라고 <ph id="ph2">`applesSold`</ph> 는 이전에 계산 된 값을 유지 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`applesSold`</ph> had been declared without using <ph id="ph2">`Static`</ph>, the previous accumulated values would not be preserved across calls to <ph id="ph3">`runningTotal`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`applesSold`</ph> 선언 되었으면 네임 스페이스를 사용 하지 않고 <ph id="ph2">`Static`</ph>, 이전의 누적된 값에 대 한 호출에서 유지 되지는 것 <ph id="ph3">`runningTotal`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The next time <ph id="ph1">`runningTotal`</ph> was called, <ph id="ph2">`applesSold`</ph> would have been recreated and initialized to 0, and <ph id="ph3">`runningTotal`</ph> would have simply returned the same value with which it was called.</source>
          <target state="translated">다음에 <ph id="ph1">`runningTotal`</ph> 를 호출 했지만 <ph id="ph2">`applesSold`</ph> 다시 및 0으로 초기화 된 것 및 <ph id="ph3">`runningTotal`</ph> 호출 된 동일한 값 단순히 반환는 합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Compiling the Code</source>
          <target state="translated">코드 컴파일</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>You can initialize the value of a static local variable as part of its declaration.</source>
          <target state="translated">정적 지역 변수 선언의 일부로 값을 초기화할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If you declare an array to be <ph id="ph1">`Static`</ph>, you can initialize its rank (number of dimensions), the length of each dimension, and the values of the individual elements.</source>
          <target state="translated">배열을 선언 하는 경우 <ph id="ph1">`Static`</ph>, 해당 순위 (차원의 수), 각 차원의 길이 및 개별 요소의 값을 초기화할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="translated">보안</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In the preceding example, you can produce the same lifetime by declaring <ph id="ph1">`applesSold`</ph> at module level.</source>
          <target state="translated">앞의 예제에서 선언 하 여 동일한 수명 주기를 생성할 수 있습니다 <ph id="ph1">`applesSold`</ph> 모듈 수준입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>If you changed the scope of a variable this way, however, the procedure would no longer have exclusive access to it.</source>
          <target state="translated">그러나 변수의 범위를 이러한 방식으로 변경 하면 프로시저가 더 이상 있을 경우 단독으로 액세스할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Because other procedures could access <ph id="ph1">`applesSold`</ph> and change its value, the running total could be unreliable and the code could be more difficult to maintain.</source>
          <target state="translated">다른 프로시저에 액세스할 수 있으므로 <ph id="ph1">`applesSold`</ph> 및 해당 값을 변경, 누적 합계를 신뢰할 수 및 코드를 유지 하기 위해 더욱 어려워질 수 있습니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Shared<ept id="p1">](../../../../visual-basic/language-reference/modifiers/shared.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>공유<ept id="p1">](../../../../visual-basic/language-reference/modifiers/shared.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Nothing<ept id="p1">](../../../../visual-basic/language-reference/nothing.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>아무 것도<ept id="p1">](../../../../visual-basic/language-reference/nothing.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Declared Element Names<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/declared-element-names.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>선언된 요소 이름<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/declared-element-names.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>References to Declared Elements<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/references-to-declared-elements.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>선언 된 요소에 대 한 참조<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/references-to-declared-elements.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Scope in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Visual Basic의 범위<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Access Levels in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/access-levels.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Visual Basic의 액세스 수준<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/access-levels.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Variables<ept id="p1">](../../../../visual-basic/programming-guide/language-features/variables/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>변수<ept id="p1">](../../../../visual-basic/programming-guide/language-features/variables/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Variable Declaration<ept id="p1">](../../../../visual-basic/programming-guide/language-features/variables/variable-declaration.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>변수 선언<ept id="p1">](../../../../visual-basic/programming-guide/language-features/variables/variable-declaration.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Troubleshooting Data Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>데이터 형식 문제 해결<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Static<ept id="p1">](../../../../visual-basic/language-reference/modifiers/static.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>정적<ept id="p1">](../../../../visual-basic/language-reference/modifiers/static.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>