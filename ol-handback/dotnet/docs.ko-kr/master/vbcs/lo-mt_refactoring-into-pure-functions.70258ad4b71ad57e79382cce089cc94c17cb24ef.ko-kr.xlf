<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e622436905893872521994f6dc1a5bc1c8b3d06a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\refactoring-into-pure-functions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a3c178ff6c32487001cf6e01c8ab97ff0838655a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">734c77ad98f910cf0ab62e09062b2bbf519350b4</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Refactoring Into Pure Functions (Visual Basic) | Microsoft Docs</source>
          <target state="translated">(Visual Basic) 순수 함수로 리팩터링 | Microsoft 문서</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Refactoring Into Pure Functions (Visual Basic)</source>
          <target state="translated">(Visual Basic) 순수 함수로 리팩터링</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>An important aspect of pure functional transformations is learning how to refactor code using pure functions.</source>
          <target state="translated">순수 함수 변형의 중요한 측면은 순수 함수를 사용하여 코드를 리팩터링하는 방법을 습득하는 것입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>As noted previously in this section, a pure function has two useful characteristics:</source>
          <target state="translated">이 단원의 앞 부분에서 설명한 것처럼 순수 함수에는 두 가지 유용한 특징이 있습니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>It has no side effects.</source>
          <target state="translated">순수 함수는 의도하지 않은 결과를 발생시키지 않습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The function does not change any variables or the data of any type outside of the function.</source>
          <target state="translated">함수는 함수 외부에 있는 형식의 데이터나 변수를 변경하지 않습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It is consistent.</source>
          <target state="translated">순수 함수는 일관성이 있습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Given the same set of input data, it will always return the same output value.</source>
          <target state="translated">동일한 입력 데이터의 집합이 제공되는 경우 항상 동일한 출력 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>One way of transitioning to functional programming is to refactor existing code to eliminate unnecessary side effects and external dependencies.</source>
          <target state="translated">함수형 프로그래밍으로 전환하는 한 가지 방법은 기존 코드를 리팩터링하여 의도하지 않은 불필요한 결과와 외부 종속성을 없애는 것입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In this way, you can create pure function versions of existing code.</source>
          <target state="translated">이런 식으로 기존 코드의 순수 함수 버전을 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This topic discusses what a pure function is and what it is not.</source>
          <target state="translated">이 항목에서는 순수 함수의 개념과 순수 함수가 의미하지 않는 것에 대해 설명합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Tutorial: Manipulating Content in a WordprocessingML Document (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md)</ept> tutorial shows how to manipulate a WordprocessingML document, and includes two examples of how to refactor using a pure function.</source>
          <target state="translated"><bpt id="p1">[</bpt>자습서: WordprocessingML 문서 (Visual Basic)에서 내용 조작<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md)</ept> 자습서 WordprocessingML 문서를 조작 하는 방법을 보여 주고 순수 함수를 사용 하 여 리팩터링 하는 방법의 두 가지 예입니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Eliminating Side Effects and External Dependencies</source>
          <target state="translated">의도하지 않은 결과 및 외부 종속성 제거</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The following examples contrast two non-pure functions and a pure function.</source>
          <target state="translated">다음 예제에서는 두 가지 비순수 함수와 순수 함수를 대조합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Non-Pure Function that Changes a Class Member</source>
          <target state="translated">클래스 멤버를 변경하는 비순수 함수</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In the following code, the <ph id="ph1">`HypenatedConcat`</ph> function is not a pure function, because it modifies the <ph id="ph2">`aMember`</ph> data member in the class:</source>
          <target state="translated">다음 코드에서 <ph id="ph1">`HypenatedConcat`</ph> 함수는 클래스에서 <ph id="ph2">`aMember`</ph> 데이터 멤버를 수정하기 때문에 순수 함수가 아닙니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This code produces the following output:</source>
          <target state="translated">이 코드의 결과는 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Note that it is irrelevant whether the data being modified has <ph id="ph1">`public`</ph> or <ph id="ph2">`private`</ph> access, or is a  <ph id="ph3">`shared`</ph> member or an instance member.</source>
          <target state="translated">참고 아닌지 관련 수정 되는 데이터가 있는지 여부 <ph id="ph1">`public`</ph> 또는 <ph id="ph2">`private`</ph> 되었거나, 액세스는 <ph id="ph3">`shared`</ph> 멤버 또는 인스턴스 멤버입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>A pure function does not change any data outside of the function.</source>
          <target state="translated">순수 함수는 함수 외부에 있는 데이터를 변경하지 않습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Non-Pure Function that Changes an Argument</source>
          <target state="translated">인수를 변경하는 비순수 함수</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Furthermore, the following version of this same function is not pure because it modifies the contents of its parameter, <ph id="ph1">`sb`</ph>.</source>
          <target state="translated">또한 이 동일한 함수의 다음 버전은 매개 변수 <ph id="ph1">`sb`</ph>의 내용을 수정하기 때문에 순수 함수가 아닙니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This version of the program produces the same output as the first version, because the <ph id="ph1">`HypenatedConcat`</ph> function has changed the value (state) of its first parameter by invoking the &lt;xref:System.Text.StringBuilder.Append%2A&gt; member function.</source>
          <target state="translated">이 버전의 프로그램에서는 때문에 동일한 출력을 첫 번째 버전의 <ph id="ph1">`HypenatedConcat`</ph> 함수를 호출 하 여 첫 번째 매개 변수의 값 (상태) 변경 되었습니다는 &lt;xref:System.Text.StringBuilder.Append%2A&gt;멤버 함수입니다.&lt;/xref:System.Text.StringBuilder.Append%2A&gt;</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Note that this alteration occurs despite that fact that <ph id="ph1">`HypenatedConcat`</ph> uses call-by-value parameter passing.</source>
          <target state="translated">이러한 변경은 <ph id="ph1">`HypenatedConcat`</ph>에서 값에 의한 호출(call-by-value) 매개 변수 전달을 사용함에도 불구하고 발생합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For reference types, if you pass a parameter by value, it results in a copy of the reference to an object being passed.</source>
          <target state="translated">참조 형식의 경우 값에 의해 매개 변수를 전달하면 개체에 대한 참조의 복사본이 전달됩니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This copy is still associated with the same instance data as the original reference (until the reference variable is assigned to a new object).</source>
          <target state="translated">이 복사본은 참조 변수가 새 개체에 할당될 때까지 원래 참조와 동일한 인스턴스 데이터와 연결되어 있습니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Call-by-reference is not necessarily required for a function to modify a parameter.</source>
          <target state="translated">참조에 의한 호출(call-by-reference)을 사용하는 경우 함수에서 반드시 매개 변수를 수정해야 할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Pure Function</source>
          <target state="translated">순수 함수</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This next version of the program hows how to implement the <ph id="ph1">`HypenatedConcat`</ph> function as a pure function.</source>
          <target state="translated">이 다음 버전의 프로그램에서는 <ph id="ph1">`HypenatedConcat`</ph> 함수를 순수 함수로 구현하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Again, this version produces the same line of output: <ph id="ph1">`StringOne-StringTwo`</ph>.</source>
          <target state="translated">이 버전은 동일한 출력 <ph id="ph1">`StringOne-StringTwo`</ph>를 생성합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Note that to retain the concatenated value, it is stored in the intermediate variable <ph id="ph1">`s2`</ph>.</source>
          <target state="translated">연결된 값을 유지하기 위해 해당 값은 중간 변수 <ph id="ph1">`s2`</ph>에 저장됩니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>One approach that can be very useful is to write functions that are locally impure (that is, they declare and modify local variables) but are globally pure.</source>
          <target state="translated">매우 유용할 수 있는 한 가지 방법은 로컬로는 순수하지 않지만(즉, 지역 변수를 선언하고 수정함) 전역적으로는 순수한 함수를 작성하는 것입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Such functions have many of the desirable composability characteristics, but avoid some of the more convoluted functional programming idioms, such as having to use recursion when a simple loop would accomplish the same thing.</source>
          <target state="translated">이러한 함수는 유용한 조합성(composability) 특징을 많이 갖고 있지만 간단한 루프가 동일한 작업을 수행하는 경우 재귀를 사용해야 하는 등의 더욱 꼬인(convoluted) 함수형 프로그래밍 특징을 방지합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Standard Query Operators</source>
          <target state="translated">표준 쿼리 연산자</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>An important characteristic of the standard query operators is that they are implemented as pure functions.</source>
          <target state="translated">표준 쿼리 연산자의 중요한 특징은 순수 함수로 구현된다는 점입니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Standard Query Operators Overview (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>표준 쿼리 연산자 개요 (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Introduction to Pure Functional Transformations (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>순수 함수 변환 (Visual Basic) 소개<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Functional Programming vs. Imperative Programming (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/functional-programming-vs-imperative-programming.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>함수형 프로그래밍과 명령형 프로그래밍 비교 (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/functional-programming-vs-imperative-programming.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>