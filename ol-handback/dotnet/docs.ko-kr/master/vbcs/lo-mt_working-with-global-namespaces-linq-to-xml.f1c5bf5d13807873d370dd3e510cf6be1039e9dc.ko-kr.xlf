<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e20d0c0b670d63ebe2be137a48dc1a1a9a861b9f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\working-with-global-namespaces-linq-to-xml.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0b010bc7f6108c589fd01051178e84abc5f60da4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">048484c76bb61bc8958b394500bd64f240f71704</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Working with Global Namespaces (Visual Basic) (LINQ to XML) | Microsoft Docs</source>
          <target state="translated">전역 네임 스페이스 (Visual Basic) (LINQ to XML) 작업 | Microsoft 문서</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Working with Global Namespaces (Visual Basic) (LINQ to XML)</source>
          <target state="translated">전역 네임스페이스 작업(Visual Basic)(LINQ to XML)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>One of the key features of XML literals in Visual Basic is the capability to declare XML namespaces by using the <ph id="ph1">`Imports`</ph> statement.</source>
          <target state="translated">사용 하 여 XML 네임 스페이스를 선언 하는 기능에는 Visual Basic에서 XML 리터럴의 주요 기능 중 하나는 <ph id="ph1">`Imports`</ph> 문입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Using this feature, you can declare an XML namespace that uses a prefix, or you can declare a default XML namespace.</source>
          <target state="translated">이 기능을 사용하여 접두사를 사용하는 XML 네임스페이스를 선언하거나 기본 XML 네임스페이스를 선언할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This capability is useful in two situations.</source>
          <target state="translated">이 기능은 두 가지 상황에서 유용합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>First, namespaces declared in XML literals do not carry over into embedded expressions.</source>
          <target state="translated">첫째, XML 리터럴에서 선언된 네임스페이스는 포함 식에까지 영향을 미치지 않습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Declaring global namespaces reduces the amount of work that you have to do to use embedded expressions with namespaces.</source>
          <target state="translated">전역 네임스페이스를 선언하면 네임스페이스와 함께 포함 식을 사용하기 위해 수행해야 하는 작업량이 줄어듭니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Second, you must declare global namespaces in order to use namespaces with XML properties.</source>
          <target state="translated">둘째, XML 속성과 함께 네임스페이스를 사용하기 위해 전역 네임스페이스를 선언해야 합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You can declare global namespaces at the project level.</source>
          <target state="translated">프로젝트 수준에서 전역 네임스페이스를 선언할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can also declare global namespaces at the module level, which overrides the project-level global namespaces.</source>
          <target state="translated">또한 모듈 수준에서 전역 네임스페이스를 선언할 수도 있습니다. 모듈 수준 전역 네임스페이스는 프로젝트 수준 전역 네임스페이스를 무시합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Finally, you can override global namespaces in an XML literal.</source>
          <target state="translated">마지막으로 XML 리터럴에서 전역 네임스페이스를 재정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>When using XML literals or XML properties that are in globally-declared namespaces, you can see the expanded name of XML literals or properties by hovering over them in Visual Studio.</source>
          <target state="translated">전역적으로 선언된 네임스페이스에 있는 XML 속성이나 XML 리터럴을 사용하는 경우 Visual Studio에서 XML 속성이나 XML 리터럴을 마우스로 가리키면 확장된 이름을 볼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You will see the expanded name in a tooltip.</source>
          <target state="translated">도구 설명에 확장된 이름이 표시됩니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can get an &lt;xref:System.Xml.Linq.XNamespace&gt; object that corresponds to a global namespace using the <ph id="ph1">`GetXmlNamespace`</ph> method.</source>
          <target state="translated">가져올 수는 &lt;xref:System.Xml.Linq.XNamespace&gt;사용 하 여 전역 네임 스페이스에 해당 하는 개체는 <ph id="ph1">`GetXmlNamespace`</ph> 메서드.&lt;/xref:System.Xml.Linq.XNamespace&gt;</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Examples of Global Namespaces</source>
          <target state="translated">전역 네임스페이스의 예제</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The following example declares a default global namespace by using the <ph id="ph1">`Imports`</ph> statement, and then uses an XML literal to initialize an &lt;xref:System.Xml.Linq.XElement&gt; object in that namespace:</source>
          <target state="translated">사용 하 여 기본 전역 네임 스페이스를 선언 하는 다음 예제는 <ph id="ph1">`Imports`</ph> 문 및 XML 리터럴을 사용 하 여 초기화 하는 &lt;xref:System.Xml.Linq.XElement&gt;해당 네임 스페이스의 개체:&lt;/xref:System.Xml.Linq.XElement&gt;</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following example declares a global namespace with a prefix, and then uses an XML literal to initialize an element:</source>
          <target state="translated">다음 예제에서는 접두사가 포함된 전역 네임스페이스를 선언한 다음 XML 리터럴을 사용하여 요소를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Global Namespaces and Embedded Expressions</source>
          <target state="translated">전역 네임스페이스 및 포함 식</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Namespaces that are declared in XML literals do not carry over into embedded expressions.</source>
          <target state="translated">XML 리터럴에서 선언된 네임스페이스는 포함 식에까지 영향을 미치지 않습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The following example declares a default namespace.</source>
          <target state="translated">다음 예제에서는 기본 네임스페이스를 선언한 다음</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>It then uses an embedded expression for the <ph id="ph1">`Child`</ph> element.</source>
          <target state="translated"><ph id="ph1">`Child`</ph> 요소에 대한 포함 식을 사용합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>As you can see, the resulting XML includes a declaration of a default namespace so that the <ph id="ph1">`Child`</ph> element is in no namespace.</source>
          <target state="translated">보다시피 생성되는 XML에는 기본 네임스페이스의 선언이 포함됩니다. 따라서 <ph id="ph1">`Child`</ph> 요소는 네임스페이스에 없습니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You could re-declare the namespace in the embedded expression, as follows:</source>
          <target state="translated">포함 식에서 다음과 같이 네임스페이스를 다시 선언할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>However, this is more cumbersome to use than the global default namespace, which is a better approach.</source>
          <target state="translated">그러나 이 방법은 전역 기본 네임스페이스보다 사용하기가 더 불편합니다. 따라서 전역 기본 네임스페이스를 사용하는 것이 더 좋습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>With the global default namespace, you can use XML literals without declaring namespaces.</source>
          <target state="translated">전역 기본 네임스페이스를 사용하면 네임스페이스를 선언하지 않고 XML 리터럴을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The resulting XML will be in the globally-declared default namespace.</source>
          <target state="translated">생성되는 XML은 전역적으로 선언된 기본 네임스페이스에 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Using Namespaces with XML Properties</source>
          <target state="translated">XML 속성과 함께 네임스페이스 사용</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If you are working with an XML tree that is in a namespace, and you use XML properties, then you must use a global namespace so that the XML properties will also be in the correct namespace.</source>
          <target state="translated">네임스페이스에 있는 XML 트리로 작업하는 경우 XML 속성을 사용하고 있으면 XML 속성도 올바른 네임스페이스에 있도록 전역 네임스페이스를 사용해야 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The following example declares an XML tree in a namespace.</source>
          <target state="translated">다음 예제에서는 네임스페이스에 XML 트리를 선언한 다음</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>It then prints the count of <ph id="ph1">`Child`</ph> elements.</source>
          <target state="translated"><ph id="ph1">`Child`</ph> 요소의 수를 출력합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This example indicates that there are no <ph id="ph1">`Child`</ph> elements.</source>
          <target state="translated">이 예제는 <ph id="ph1">`Child`</ph> 요소가 없음을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">이 예제의 결과는 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If, however, you declare a default global namespace, then both the XML literal and the XML property are in the default global namespace:</source>
          <target state="translated">그러나 기본 전역 네임스페이스를 선언하는 경우 XML 리터럴과 XML 속성이 모두 기본 전역 네임스페이스에 있습니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This example indicates that there is one <ph id="ph1">`Child`</ph> element.</source>
          <target state="translated">이 예제는 <ph id="ph1">`Child`</ph> 요소가 하나 있음을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">이 예제의 결과는 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If you declare a global namespace that has a prefix, you can use the prefix for both XML literals and XML properties:</source>
          <target state="translated">접두사가 포함된 전역 네임스페이스를 선언하면 XML 리터럴과 XML 속성 모두에 접두사를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>XNamespace and Global Namespaces</source>
          <target state="translated">XNamespace 및 전역 네임스페이스</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can get an &lt;xref:System.Xml.Linq.XNamespace&gt; object by using the <ph id="ph1">`GetXmlNamespace`</ph> method:</source>
          <target state="translated">가져올 수는 &lt;xref:System.Xml.Linq.XNamespace&gt;사용 하 여 개체는 <ph id="ph1">`GetXmlNamespace`</ph> 메서드:&lt;/xref:System.Xml.Linq.XNamespace&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Working with XML Namespaces (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/working-with-xml-namespaces.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>XML 네임 스페이스 (Visual Basic) 작업<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/working-with-xml-namespaces.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>