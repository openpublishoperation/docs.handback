<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2cf58161a75894a12f47cf67a5760dc26f9d261c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\preview3\tools\extensibility.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c6027d635ba3454a483ac32629c011aad800c521</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7edf32b1af566baa06e2dfa6fb876fc6e9bb9b6d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">Modelo de extensibilidade da CLI do .NET Core</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">Modelo de extensibilidade da CLI do .NET Core</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>CLI, extensibility, custom commands, .NET Core</source>
          <target state="translated">CLI, extensibilidade, comandos personalizados, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI extensibility model</source>
          <target state="translated">Modelo de extensibilidade da CLI do .NET Core</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Visão Geral</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This document will cover the main ways how to extend the CLI tools and explain the scenarios that drive each of them.</source>
          <target state="translated">Este documento abordará as principais maneiras de estender as ferramentas da CLI e explica os cenários que orientam a cada uma delas.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It will the outline how to consume the tools as well as provide short notes on how to build both types of tools.</source>
          <target state="translated">Ele descreverá como consumir as ferramentas, bem como fornecerá breves anotações sobre como compilar ambos os tipos de ferramentas.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How to extend CLI tools</source>
          <target state="translated">Como estender as ferramentas da CLI</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Preview 3 CLI tools can be extended in three main ways:</source>
          <target state="translated">As ferramentas da CLI da Visualização 3 podem ser estendidas de três maneiras:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Via NuGet packages on a per-project basis</source>
          <target state="translated">Por meio de pacotes NuGet por projeto</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Via NuGet packages with custom targets</source>
          <target state="translated">Por meio de pacotes do NuGet com destinos personalizados</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Via the system's PATH</source>
          <target state="translated">Por meio do PATH do sistema</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The three extensibility mechanisms outlined above are not exclusive; you can use all or just one or combine them.</source>
          <target state="translated">Os três mecanismos de extensibilidade descritos acima não são exclusivos; você pode usar todos ou apenas um deles ou combiná-los.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Which one to pick depends largely on what is the goal you are trying to achieve with your extension.</source>
          <target state="translated">Qual deles escolher depende muito da meta que você está tentando alcançar com a extensão.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Per-project based extensibility</source>
          <target state="translated">Extensibilidade por projeto</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Per-project tools are <bpt id="p1">[</bpt>framework-dependented deployments<ept id="p1">](../deploying/index.md)</ept> that are distributed as NuGet packages.</source>
          <target state="translated">Ferramentas por projeto são <bpt id="p1">[</bpt>implantações dependentes de estrutura<ept id="p1">](../deploying/index.md)</ept> distribuídas como pacotes NuGet.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Tools are only available in the context of the project that references them and for which they are restored; invocation outside of the context of the project (for example, outside of the directory that contains the project) will fail as the command will not be able to be found.</source>
          <target state="translated">Ferramentas só estão disponíveis no contexto do projeto que faz referência a eles e para os quais eles são restaurados; a invocação fora do contexto do projeto (por exemplo, fora do diretório que contém o projeto) falhará, pois o comando não poderá ser encontrado.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>These tools are perfect for build servers, since nothing outside of the project file is needed.</source>
          <target state="translated">Essas ferramentas são perfeitas para criar servidores, desde que nada fora do arquivo de projeto seja necessário.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The build process runs restore for the project it builds and tools will be available.</source>
          <target state="translated">O processo de build executa a restauração para o projeto compilado e as ferramentas disponíveis.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Language projects, such as F#, are also in this category; after all, each project can only be written in one specific language.</source>
          <target state="translated">Projetos de linguagem, como F#, também estão nesta categoria, afinal, cada projeto só pode ser escrito em um idioma específico.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Finally, this extensibility model provides support for creation of tools that need access to the built output of the project.</source>
          <target state="translated">Por fim, esse modelo de extensibilidade dá suporte à criação de ferramentas que precisam acessar a saída da compilação do projeto.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For instance, various Razor view tools in <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC applications fall into this category.</source>
          <target state="translated">Por exemplo, diversas ferramentas de exibição Razor em aplicativos <bpt id="p1">[</bpt>ASP.NET<ept id="p1">](https://www.asp.net/)</ept> MVC se enquadram nesta categoria.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consuming per-project tools</source>
          <target state="translated">Consumir ferramentas por projeto</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Consuming these tools requires you to add a <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element for each tool you want to use to your project file.</source>
          <target state="translated">Consumir essas ferramentas requer a adição de um elemento <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> para cada ferramenta que você deseja usar para o arquivo de projeto.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Inside the <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element, you reference the package in which the tool resides and you specify the version you need.</source>
          <target state="translated">Dentro do elemento <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph>, você referencia o pacote no qual a ferramenta reside e especifica a versão necessária.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>After running <ph id="ph1">`dotnet restore`</ph>, the tool and its dependencies are restored.</source>
          <target state="translated">Após executar <ph id="ph1">`dotnet restore`</ph>, a ferramenta e suas dependências são restauradas.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For tools that need to load the build output of the project for execution, there is usually another dependency which is listed under the regular dependencies in the project file.</source>
          <target state="translated">Para ferramentas que precisam carregar a saída do build do projeto para execução, geralmente há outra dependência listada nas dependências regulares no arquivo de projeto.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Since the Preview 3 version of the CLI uses MSBuild as its build engine, it is recommended that these parts of the tool be written as custom MSBuild targets and tasks since that way they can take part in the overall build process.</source>
          <target state="translated">Como a versão de Visualização 3 da CLI usa o MSBuild como mecanismo de compilação, é recomendável que essas partes da ferramenta sejam gravadas como destinos personalizados do MSBuild e tarefas, pois, dessa forma, eles podem participar do processo geral de compilação.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Also, they can get any and all data easily that is produced via the build, for example the location of the output files, the current configuration being built etc. All of this information in Preview 3 becomes a set of MSBuild properties that can be read from any target.</source>
          <target state="translated">Além disso, eles podem obter todos os dados produzido por meio de build facilmente, por exemplo, o local dos arquivos de saída, a configuração atual que está sendo compilada etc. Todas essas informações na Visualização 3 se tornam um conjunto de propriedades do MSBuild que pode ser lido em qualquer destino.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>We will see how to add a custom target using NuGet later in this document.</source>
          <target state="translated">Veremos como adicionar um destino personalizado usando o NuGet mais adiante neste documento.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Let's review an example of adding a simple tools-only tool to a simple project.</source>
          <target state="translated">Vamos examinar um exemplo de como adicionar uma ferramenta única simples a um projeto simples.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Given an example command called <ph id="ph1">`dotnet-api-search`</ph> that allows you to search through the NuGet packages for the specified API, here is a console application's project file that uses that tool:</source>
          <target state="translated">Dado um exemplo de comando chamado <ph id="ph1">`dotnet-api-search`</ph> que permite que você pesquise os pacotes NuGet para a API especificada, veja este arquivo de projeto do aplicativo de console que usa essa ferramenta:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> element is structured in a similar way as the <ph id="ph2">`&lt;PackageReference&gt;`</ph> element.</source>
          <target state="translated">O elemento <ph id="ph1">`&lt;DotNetCliToolReference&gt;`</ph> é estruturado de forma semelhante ao elemento <ph id="ph2">`&lt;PackageReference&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>It needs the package ID of the package containing the tool and its version at the very least.</source>
          <target state="translated">Ele precisa no mínimo da ID do pacote que contém a ferramenta e sua versão.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Building tools</source>
          <target state="translated">Compilando ferramentas</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>As mentioned, tools are just portable console applications.</source>
          <target state="translated">Como mencionado anteriormente, ferramentas são apenas aplicativos de console portáteis.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You would build one as you would build any console application.</source>
          <target state="translated">Você poderia compilar uma delas da mesma maneira que qualquer aplicativo de console.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>After you build it, you would use <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> command to create a NuGet package (nupkg) that contains your code, information about its dependencies and so on.</source>
          <target state="translated">Depois de compilá-la, você usaria o comando <bpt id="p1">[</bpt><ph id="ph1">`dotnet pack`</ph><ept id="p1">](dotnet-pack.md)</ept> para criar um pacote NuGet (nupkg) que contém o código, as informações sobre suas dependências e assim por diante.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The package name can be whatever the author wants, but the application inside, the actual tool binary, has to conform to the convention of <ph id="ph1">`dotnet-&lt;command&gt;`</ph> in order for <ph id="ph2">`dotnet`</ph> to be able to invoke it.</source>
          <target state="translated">O nome do pacote pode ser o que o autor desejar, mas o aplicativo dentro dele, a real ferramenta binária, precisa estar em conformidade com a convenção de <ph id="ph1">`dotnet-&lt;command&gt;`</ph> para que <ph id="ph2">`dotnet`</ph> consiga invocá-lo.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In Preview 3 bits, the <ph id="ph1">`dotnet pack`</ph> command will not pack the <ph id="ph2">`runtimeconfig.json`</ph> file that is needed to run the tool.</source>
          <target state="translated">Nos bits da Visualização 3, o comando <ph id="ph1">`dotnet pack`</ph> não empacotará o arquivo <ph id="ph2">`runtimeconfig.json`</ph> necessário para executar a ferramenta.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In order to package the this file, you have two options:</source>
          <target state="translated">Para empacotar esse arquivo, você tem duas opções:</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Create a <ph id="ph1">`nuspec`</ph> file and use <ph id="ph2">`dotnet nuget pack`</ph> command newly available to Preview 3 CLI to include the file</source>
          <target state="translated">Criar um arquivo <ph id="ph1">`nuspec`</ph> e usar o comando <ph id="ph2">`dotnet nuget pack`</ph> recentemente disponível para a CLI da Visualização 3 para incluir o arquivo</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Use the new <ph id="ph1">`&lt;Content&gt;`</ph> element in an <ph id="ph2">`&lt;ItemGroup&gt;`</ph> in your project file to include the file manually</source>
          <target state="translated">Usar o novo elemento <ph id="ph1">`&lt;Content&gt;`</ph> em um <ph id="ph2">`&lt;ItemGroup&gt;`</ph> em seu arquivo de projeto para incluir o arquivo manualmente</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Working with nuspec files is beyond the scope of this article, however you can find a lot of good information in the <bpt id="p1">[</bpt>official NuGet docs<ept id="p1">](https://docs.nuget.org/ndocs/create-packages/creating-a-package#the-role-and-structure-of-the--nuspec-file)</ept>.</source>
          <target state="translated">Trabalhar com arquivos nuspec não está no escopo deste artigo, no entanto, é possível encontrar muitas informações úteis no <bpt id="p1">[</bpt>documentos oficiais do NuGet<ept id="p1">](https://docs.nuget.org/ndocs/create-packages/creating-a-package#the-role-and-structure-of-the--nuspec-file)</ept>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If you decide on the second approach, you can see the example <ph id="ph1">`csproj`</ph> file and how it is configured below:</source>
          <target state="translated">Se escolher a segunda abordagem, você poderá ver o exemplo de arquivo <ph id="ph1">`csproj`</ph> e sua configuração abaixo:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">`&lt;ItemGroup&gt;`</ph> instructs the <ph id="ph2">`dotnet pack`</ph> command to pack any <ph id="ph3">`runtimeconfig.json`</ph> files in the build output directory (designated by the <ph id="ph4">`$(OutputPath)`</ph> variable) and place it into the <ph id="ph5">`lib`</ph> folder for the built target framework.</source>
          <target state="translated">Esse <ph id="ph1">`&lt;ItemGroup&gt;`</ph> instrui o comando <ph id="ph2">`dotnet pack`</ph> a empacotar arquivos <ph id="ph3">`runtimeconfig.json`</ph> no diretório de saída do build (designado pela variável <ph id="ph4">`$(OutputPath)`</ph>) e colocá-lo na pasta <ph id="ph5">`lib`</ph> para a estrutura de destino compilada.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The built target framework is designated similarly to the output path by using a MSBuild property.</source>
          <target state="translated">A estrutura de destino compilada é designada de forma semelhante ao caminho de saída, usando uma propriedade do MSBuild.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>After this is set, the resulting tool nupkg file will contain all that is needed for running the tool.</source>
          <target state="translated">Após essa definição, o arquivo resultante da ferramenta nupkg conterá tudo o que é necessário para executar a ferramenta.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Since tools are portable applications, the user consuming the tool has to have the version of the .NET Core libraries that the tool was built against in order to run the tool.</source>
          <target state="translated">Como ferramentas são aplicativos portáteis, o usuário que a consume precisa ter a versão das bibliotecas do .NET Core para as quais a biblioteca foi criada para executar a ferramenta.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Any other dependency that the tool uses and that is not contained within the .NET Core libraries is restored and placed in the NuGet cache.</source>
          <target state="translated">Qualquer outra dependência que a ferramenta usa e que não está contida em bibliotecas do .NET Core é restaurada e colocada no cache do NuGet.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The entire tool is, therefore, run using the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache.</source>
          <target state="translated">Toda a ferramenta é, portanto, executada usando os assemblies de bibliotecas .NET Core, bem como assemblies do cache do NuGet.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>These kind of tools have a dependency graph that is completely separate from the dependency graph of the project that uses them.</source>
          <target state="translated">Esses tipos de ferramentas têm um gráfico de dependência completamente separado do gráfico de dependência do projeto que as utiliza.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The restore process will first restore the project's dependencies, and will then restore each of the tools and their dependencies.</source>
          <target state="translated">O processo de restauração restaurará primeiro as dependências do projeto e, em seguida, cada uma das ferramentas e suas dependências.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You can find richer examples and different combinations of this in the <bpt id="p1">[</bpt>.NET Core CLI repo<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.</source>
          <target state="translated">Você pode encontrar exemplos mais sofisticados e diferentes combinações disso no <bpt id="p1">[</bpt>repositório da CLI do .NET Core<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You can also see the <bpt id="p1">[</bpt>implementation of tools used<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> in the same repo.</source>
          <target state="translated">Você também pode ver a <bpt id="p1">[</bpt>implementação das ferramentas utilizadas<ept id="p1">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> no mesmo repositório.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Custom targets</source>
          <target state="translated">Destinos personalizados</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>NuGet has had the capability to package custom MSBuild target and props files for a while now and you can find the official documentation on this on the <bpt id="p1">[</bpt>NuGet documentation site<ept id="p1">](https://docs.nuget.org/ndocs/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>.</source>
          <target state="translated">O NuGet tem a capacidade de empacotar arquivos personalizados de destino e propriedade do MSBuild há algum tempo e é possível encontrar a documentação oficial sobre esse tema no <bpt id="p1">[</bpt>site de documentação do NuGet<ept id="p1">](https://docs.nuget.org/ndocs/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>With the move in the CLI to using MSBuild, the same mechanism of extensibility applies to .NET Core projects.</source>
          <target state="translated">Com a mudança da CLI para o MSBuild, o mesmo mecanismo de extensibilidade se aplica a projetos do .NET Core.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You would use this type of extensiblity when you want to extend the build process or when you want to access any of the artifacts in the build process, such as generated files or inspect the configuration under which the build is invoked etc.</source>
          <target state="translated">Esse tipo de extensibilidade seria usada se você desejasse estender o processo de build ou quando você quiser acessar os artefatos no processo de build, como arquivos gerados ou inspecionar a configuração pela qual o build é invocado etc.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The sample target's project file is included below for reference.</source>
          <target state="translated">O exemplo de arquivo de projeto de destino está incluído abaixo para referência.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>It shows how to use the new <ph id="ph1">`csproj`</ph> syntax for instructing <ph id="ph2">`dotnet pack`</ph> command what to package to place the targets files as well as assemblies into the <ph id="ph3">`build`</ph> folder inside the package.</source>
          <target state="translated">Ele mostra como usar a nova sintaxe <ph id="ph1">`csproj`</ph> para instruir o comando <ph id="ph2">`dotnet pack`</ph> sobre o que empacotar a fim de colocar os arquivos de destino e os assemblies na pasta <ph id="ph3">`build`</ph> dentro do pacote.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Take note of the <ph id="ph1">`&lt;ItemGroup&gt;`</ph> below that has the <ph id="ph2">`Label`</ph> property set to "dotnet pack instructions".</source>
          <target state="translated">Anote o <ph id="ph1">`&lt;ItemGroup&gt;`</ph> abaixo, que tem a propriedade <ph id="ph2">`Label`</ph> definida como "instruções de pacote dotnet".</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Consuming custom targets is done by providing a <ph id="ph1">`&lt;PackageReference&gt;`</ph> that points to the package and its version inside the project that is being extended.</source>
          <target state="translated">O consumo de destinos personalizados é realizado por meio de um <ph id="ph1">`&lt;PackageReference&gt;`</ph> que aponta para o pacote e sua versão dentro do projeto que está sendo estendido.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Unlike the tools, the custom targets package does get included into the consuming project's dependency closure.</source>
          <target state="translated">Diferentemente das ferramentas, o pacote de destinos personalizados será incluído no fechamento de dependência do projeto de consumo.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Using the custom target depends solely on how you configure it.</source>
          <target state="translated">Usar o destino personalizado depende exclusivamente como você o configura.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Since it is the usual MSBuild target, it can depend on a given target, run after another target and can also be manually invoked using the <ph id="ph1">`dotnet msbuild /t:&lt;target-name&gt;`</ph> command.</source>
          <target state="translated">Como é o destino habitual do MSBuild, ele pode depender de um determinado destino, executar após outro destino e também pode ser invocado manualmente usando o comando <ph id="ph1">`dotnet msbuild /t:&lt;target-name&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>However, if you wish to provide a better user experience to your users, you can combine per-project tools and custom targets.</source>
          <target state="translated">No entanto, se você quiser fornecer uma experiência melhor para seus usuários, será possível combinar ferramentas por projeto e destinos personalizados.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In this scenario, the per-project tool would essentially just accept whatever needed parameters and would translate that into the required <ph id="ph1">`dotnet msbuild`</ph> invocation that would execute the target.</source>
          <target state="translated">Nesse cenário, a ferramenta por projeto apenas aceitaria os parâmetros necessários e os converteria para a invocação <ph id="ph1">`dotnet msbuild`</ph> necessária, que executaria o destino.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You can see a sample of this kind of sinergy on the <bpt id="p1">[</bpt>MVP Summit 2016 Hackathon samples<ept id="p1">](https://github.com/dotnet/MVPSummitHackathon2016)</ept> repo in the <bpt id="p2">[</bpt><ph id="ph1">`dotnet-packer`</ph><ept id="p2">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept> project.</source>
          <target state="translated">Veja um exemplo desse tipo de sinergia no repositório <bpt id="p1">[</bpt>Exemplos do MVP Summit 2016 Hackathon<ept id="p1">](https://github.com/dotnet/MVPSummitHackathon2016)</ept> do projeto <bpt id="p2">[</bpt><ph id="ph1">`dotnet-packer`</ph><ept id="p2">](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer)</ept>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility</source>
          <target state="translated">Extensibilidade baseada em PATH</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more than a single project.</source>
          <target state="translated">A extensibilidade do PATH geralmente é usada para computadores de desenvolvimento em que você precisa de uma ferramenta que abrange conceitualmente mais de um único projeto.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The main drawback of this extensions mechanism is that it is tied to the machine where the tool exists.</source>
          <target state="translated">A principal desvantagem desse mecanismo de extensões é que ele está vinculado ao computador no qual a ferramenta existe.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If you need it on another machine, you would have to deploy it.</source>
          <target state="translated">Se você precisar dela em outro computador, precisará implantá-la.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>This pattern of CLI toolset extensibility is very simple.</source>
          <target state="translated">Esse padrão de extensibilidade do conjunto de ferramentas da CLI é muito simples.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>As covered in the <bpt id="p1">[</bpt>.NET Core CLI overview<ept id="p1">](index.md)</ept>, <ph id="ph1">`dotnet`</ph> driver can run any command that is named after the <ph id="ph2">`dotnet-&lt;command&gt;`</ph> convention.</source>
          <target state="translated">Conforme abordado na <bpt id="p1">[</bpt>Visão geral da CLI do .NET Core<ept id="p1">](index.md)</ept>, o driver <ph id="ph1">`dotnet`</ph> pode executar qualquer comando nomeado segundo a convenção <ph id="ph2">`dotnet-&lt;command&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The default resolution logic will first probe several locations and will finally fall to the system PATH.</source>
          <target state="translated">A lógica de resolução padrão primeiro investigará os vários locais e finalmente recairá sobre o PATH do sistema.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If the requested command exists in the system PATH and is a binary that can be invoked, <ph id="ph1">`dotnet`</ph> driver will invoke it.</source>
          <target state="translated">Se o comando solicitado existir no PATH do sistema e for um binário que pode ser invocado, o driver <ph id="ph1">`dotnet`</ph> o invocará.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The binary can be pretty much anything that the operating system can execute.</source>
          <target state="translated">O binário pode ser praticamente qualquer coisa que o sistema operacional puder executar.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>On Unix systems, this means anything that has the execute bit set via <ph id="ph1">`chmod +x`</ph>.</source>
          <target state="translated">Em sistemas Unix, isso significa tudo que tiver o conjunto de bits execute por meio de <ph id="ph1">`chmod +x`</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>On Windows it means anything that Windows knows how to run.</source>
          <target state="translated">No Windows, isso significa qualquer coisa que o Windows souber executar.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>As an example, let's take a look at a very simple implementation of a <ph id="ph1">`dotnet clean`</ph> command.</source>
          <target state="translated">Por exemplo, vejamos uma implementação muito simples de um comando <ph id="ph1">`dotnet clean`</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>We will use <ph id="ph1">`bash`</ph> to implement this command.</source>
          <target state="translated">Usaremos o <ph id="ph1">`bash`</ph> para implementar esse comando.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The command will simply delete the <ph id="ph1">`bin/`</ph> and <ph id="ph2">`obj/`</ph> directories in the current directory.</source>
          <target state="translated">O comando simplesmente excluirá os diretório <ph id="ph1">`bin/`</ph> e <ph id="ph2">`obj/`</ph> no diretório atual.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`--lock`</ph> argument is passed to it, it will also delete <ph id="ph2">`project.lock.json`</ph> file.</source>
          <target state="translated">Se o argumento <ph id="ph1">`--lock`</ph> for passado para ele, o arquivo <ph id="ph2">`project.lock.json`</ph> também será excluído.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The entirety of the command is given below.</source>
          <target state="translated">Todo o comando é fornecido abaixo.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>On macOS, we can save this script as <ph id="ph1">`dotnet-clean`</ph> and set its executable bit with <ph id="ph2">`chmod +x dotnet-clean`</ph>.</source>
          <target state="translated">No macOS, podemos eliminar esse script como <ph id="ph1">`dotnet-clean`</ph> e definir o bit executável com <ph id="ph2">`chmod +x dotnet-clean`</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>We can then create a symbolic link to it in <ph id="ph1">`/usr/local/bin`</ph> using the command <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph>.</source>
          <target state="translated">Podemos então criar um link simbólico para ele em <ph id="ph1">`/usr/local/bin`</ph> usando o comando <ph id="ph2">`ln -s dotnet-clean /usr/local/bin/`</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This will make it possible to invoke the clean command using the <ph id="ph1">`dotnet clean`</ph> syntax.</source>
          <target state="translated">Isso tornará possível invocar o comando limpo usando a sintaxe <ph id="ph1">`dotnet clean`</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>You can test this by creating an app, running <ph id="ph1">`dotnet build`</ph> on it and then running <ph id="ph2">`dotnet clean`</ph>.</source>
          <target state="translated">Você pode testar isso criando um aplicativo, executando o <ph id="ph1">`dotnet build`</ph> nele e então executando <ph id="ph2">`dotnet clean`</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusão</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The .NET Core CLI tools allow three main extensibility points.</source>
          <target state="translated">As ferramentas da CLI do .NET Core permitem três pontos de extensibilidade principais.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The per-project tools are contained within the project's context, but they allow easy installation through restoration.</source>
          <target state="translated">As ferramentas por projeto estão contidas no contexto do projeto, mas permitem uma fácil instalação por meio da restauração.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Custom targets allow you to easily extend the build process with custom tasks.</source>
          <target state="translated">Destinos personalizados permitem que você amplie facilmente o processo de build com tarefas personalizadas.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>PATH-based tools are good for general, cross-project tools that are usable on a single machine.</source>
          <target state="translated">Ferramentas baseadas em PATH são boas para ferramentas gerais de vários projetos que são usadas em um único computador.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>