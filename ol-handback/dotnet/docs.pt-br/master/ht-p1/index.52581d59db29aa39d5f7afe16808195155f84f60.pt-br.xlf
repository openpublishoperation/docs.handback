<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2e5059a56a91dc6350fc5277257eb06963cda4e4</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\fsharp\language-reference\values\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a80da9f972c22c6241de6cf11da0b95e94032034</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bf8f5e0e97aa1e2f13876133014f24d458b9eec2</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Values (F#)</source>
          <target state="translated">Valores (F#)</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Values (F#)</source>
          <target state="translated">Valores (F#)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>visual f#, f#, functional programming</source>
          <target state="translated">visual f#, f#, programação funcional</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Valores</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</source>
          <target state="translated">Os valores em F# podem ser números inteiros ou de ponto flutuante, caracteres ou texto, listas, sequências, matrizes, tuplas, uniões discriminadas, registros, tipos de classe ou valores de função.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Binding a Value</source>
          <target state="translated">Associação de valor</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The term <bpt id="p1">*</bpt>binding<ept id="p1">*</ept> means associating a name with a definition.</source>
          <target state="translated">O termo <bpt id="p1">*</bpt>associação<ept id="p1">*</ept> significa associar um nome a uma definição.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`let`</ph> keyword binds a value, as in the following examples:</source>
          <target state="translated">A palavra-chave <ph id="ph1">`let`</ph> associa um valor, como nos exemplos a seguir:</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The type of a value is inferred from the definition.</source>
          <target state="translated">O tipo de um valor é inferido da definição.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</source>
          <target state="translated">Para um tipo primitivo, como um número de ponto flutuante ou integral, o tipo é determinado pelo tipo do literal.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Therefore, in the previous example, the compiler infers the type of <ph id="ph1">`b`</ph> to be <ph id="ph2">`unsigned int`</ph>, whereas the compiler infers the type of <ph id="ph3">`a`</ph> to be <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Portanto, no exemplo anterior, o compilador infere o tipo de <ph id="ph1">`b`</ph> como <ph id="ph2">`unsigned int`</ph>, enquanto o compilador infere o tipo de <ph id="ph3">`a`</ph> como <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The type of a function value is determined from the return value in the function body.</source>
          <target state="translated">O tipo de valor de uma função é determinado pelo valor de retorno no corpo da função.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For more information about function value types, see <bpt id="p1">[</bpt>Functions<ept id="p1">](../functions/index.md)</ept>.</source>
          <target state="translated">Para saber mais sobre tipos de valor de função, veja <bpt id="p1">[</bpt>Funções<ept id="p1">](../functions/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For more information about literal types, see <bpt id="p1">[</bpt>Literals<ept id="p1">](../literals.md)</ept>.</source>
          <target state="translated">Para saber mais sobre tipos de literal, veja <bpt id="p1">[</bpt>Literais<ept id="p1">](../literals.md)</ept>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Why Immutable?</source>
          <target state="translated">Por que imutável?</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Immutable values are values that cannot be changed throughout the course of a program's execution.</source>
          <target state="translated">Valores imutáveis são valores que não podem ser alterados durante a execução de um programa.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</source>
          <target state="translated">Se você estiver acostumado com linguagens como C++, Visual Basic ou X#, talvez se surpreenda por F# dar prioridade para valores imutáveis em vez de variáveis que podem receber novos valores durante a execução de um programa.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Immutable data is an important element of functional programming.</source>
          <target state="translated">Dados imutáveis são um elemento importante da programação funcional.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</source>
          <target state="translated">Em um ambiente multithread, é difícil gerenciar variáveis mutáveis compartilhadas que podem ser alteradas por muitos threads diferentes.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</source>
          <target state="translated">Além disso, com as variáveis mutáveis, às vezes pode ser difícil dizer se uma variável pode ser alterada quando ela é passada para outra função.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</source>
          <target state="translated">Em linguagens funcionais puras, não há variáveis, e as funções se comportam estritamente como funções matemáticas.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</source>
          <target state="translated">Quando um código em uma linguagem de procedimento usa uma atribuição de variável para alterar um valor, o código equivalente em uma linguagem funcional tem um valor imutável, que é a entrada, uma função imutável e valores imutáveis diferentes como saída.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This mathematical strictness allows for tighter reasoning about the behavior of the program.</source>
          <target state="translated">Essa limitação matemática permite uma raciocínio mais firme sobre o comportamento do programa.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</source>
          <target state="translated">Esse raciocínio mais firme é o que permite aos compiladores verificar o código de forma mais rigorosa e otimizar com mais efetividade, além de ajudar os desenvolvedores a entender e a escrever o código corretamente.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Functional code is therefore likely to be easier to debug than ordinary procedural code.</source>
          <target state="translated">Portanto, provavelmente o código funcional é mais fácil de depurar do que o código de procedimento comum.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>F# is not a pure functional language, yet it fully supports functional programming.</source>
          <target state="translated">F# não é uma linguagem funcional pura, ainda assim é totalmente compatível com a programação funcional.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</source>
          <target state="translated">O uso de valores imutáveis é uma prática recomendada, pois isso permite que seu código se beneficie de um aspecto importante da programação funcional.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Mutable Variables</source>
          <target state="translated">Variáveis mutáveis</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You can use the keyword <ph id="ph1">`mutable`</ph> to specify a variable that can be changed.</source>
          <target state="translated">Você pode usar a palavra-chave <ph id="ph1">`mutable`</ph> para especificar uma variável que pode ser alterada.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</source>
          <target state="translated">As variáveis mutáveis em F# geralmente devem ter um escopo limitado, como um campo de um tipo ou um valor local.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</source>
          <target state="translated">Variáveis mutáveis com um escopo limitado são mais fáceis de controlar e têm uma probabilidade menor de serem modificadas de maneira incorreta.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You can assign an initial value to a mutable variable by using the <ph id="ph1">`let`</ph> keyword in the same way as you would define a value.</source>
          <target state="translated">Você pode atribuir um valor inicial para uma variável mutável usando a palavra-chave <ph id="ph1">`let`</ph> da mesma maneira que você definira um valor.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>However, the difference is that you can subsequently assign new values to mutable variables by using the <ph id="ph1">`&lt;-`</ph> operator, as in the following example.</source>
          <target state="translated">No entanto, a diferença é que você pode atribuir posteriormente novos valores a variáveis mutáveis usando o operador <ph id="ph1">`&lt;-`</ph>, como no exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Related Topics</source>
          <target state="translated">Tópicos relacionados</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Título</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>let Bindings<ept id="p1">](../functions/let-bindings.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Associações let<ept id="p1">](../functions/let-bindings.md)</ept></target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Provides information about using the <ph id="ph1">`let`</ph>keyword to bind names to values and functions.</source>
          <target state="translated">Fornece informações sobre como usar a palavra-chave <ph id="ph1">`let`</ph> para associar nomes a valores e funções.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Functions<ept id="p1">](../functions/index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Funções<ept id="p1">](../functions/index.md)</ept></target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Provides an overview of functions in F#.</source>
          <target state="translated">Fornece uma visão geral das funções em F#.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Consulte também</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Null Values<ept id="p1">](null-Values.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Valores Nulos<ept id="p1">](null-Values.md)</ept></target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>F# Language Reference<ept id="p1">](../index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Referência da Linguagem F#<ept id="p1">](../index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>