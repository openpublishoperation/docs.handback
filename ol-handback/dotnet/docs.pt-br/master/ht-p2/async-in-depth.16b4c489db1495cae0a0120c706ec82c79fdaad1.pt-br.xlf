<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c8ff0f81054feddb4ee7042926c817de525034f9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\async-in-depth.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4a59cc5bc6b7d68b057f06623b3cc2f09799a72f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6ad464a4806ef09df47b4d06900d8102ffaf398b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Async in depth</source>
          <target state="translated">Assincronia detalhada</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>In-depth explanation of how asynchronous code works in .NET</source>
          <target state="translated">Explicação detalhada de como o código assíncrono funciona no .NET</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, .NET Standard</source>
          <target state="translated">.NET, .NET Core, .NET Standard</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Async in depth</source>
          <target state="translated">Assincronia detalhada</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</source>
          <target state="translated">Escrever código assíncrono vinculado à CPU ou à E/S é simples usando o modelo assíncrono baseado em Tarefas do .NET.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The model is exposed by the <ph id="ph1">`Task`</ph> and <ph id="ph2">`Task&lt;T&gt;`</ph> types and the <ph id="ph3">`async`</ph> and <ph id="ph4">`await`</ph> language keywords.</source>
          <target state="translated">O modelo é exposto pelos tipos <ph id="ph1">`Task`</ph> e <ph id="ph2">`Task&lt;T&gt;`</ph> e as palavras-chave de linguagem <ph id="ph3">`async`</ph> e <ph id="ph4">`await`</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This article explains how to use .NET async and provides insight into the async framework used under the covers.</source>
          <target state="translated">Este artigo explica como usar a assincronia do .NET e fornece informações sobre a estrutura de assincronia usada nos bastidores.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Task and Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph></source>
          <target state="translated">Task e Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Tasks are constructs used to implement what is known as the <bpt id="p1">[</bpt>Promise Model of Concurrency<ept id="p1">](https://en.wikipedia.org/wiki/Futures_and_promises)</ept>.</source>
          <target state="translated">Tarefas são constructos usados para implementar o que é conhecido como o <bpt id="p1">[</bpt>modelo de promessa de simultaneidade<ept id="p1">](https://en.wikipedia.org/wiki/Futures_and_promises)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</source>
          <target state="translated">Em resumo, elas oferecem a você uma “promessa” de que o trabalho será concluído em um momento posterior, permitindo que você coordene a promessa com uma API limpa.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task`</ph> represents a single operation which does not return a value.</source>
          <target state="translated"><ph id="ph1">`Task`</ph> representa uma única operação que não retorna um valor.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task&lt;T&gt;`</ph> represents a single operation which returns a value of type <ph id="ph2">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Task&lt;T&gt;`</ph> representa uma única operação que retorna um valor do tipo <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It’s important to reason about tasks as abstractions of work happening asynchronously, and <bpt id="p1">*</bpt>not<ept id="p1">*</ept> an abstraction over threading.</source>
          <target state="translated">É importante pensar nas tarefas como abstrações do trabalho ocorrendo de maneira assíncrona e <bpt id="p1">*</bpt>não<ept id="p1">*</ept> uma abstração de threading.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</source>
          <target state="translated">Por padrão, as tarefas são executadas no thread atual e delegam o trabalho para o sistema operacional, conforme apropriado.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Optionally, tasks can be be explicitly requested to run on a separate thread via the <ph id="ph1">`Task.Run`</ph> API.</source>
          <target state="translated">Opcionalmente, as tarefas podem ser explicitamente solicitadas a serem executadas em um thread separado por meio da API <ph id="ph1">`Task.Run`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of <ph id="ph1">`Task&lt;T&gt;`</ph>) of a task.</source>
          <target state="translated">As tarefas expõem um protocolo de API para monitoramento, aguardando e acessando o valor do resultado (no caso de <ph id="ph1">`Task&lt;T&gt;`</ph>) de uma tarefa.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Language integration, with the <ph id="ph1">`await`</ph> keyword, provides a higher-level abstraction for using tasks.</source>
          <target state="translated">A integração de linguagem, com a palavra-chave <ph id="ph1">`await`</ph>, fornece uma abstração de nível mais alto para o uso de tarefas.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Using <ph id="ph1">`await`</ph> allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</source>
          <target state="translated">O uso de <ph id="ph1">`await`</ph> permite que seu aplicativo ou serviço realize um trabalho útil enquanto uma tarefa estiver em execução gerando o controle para seu chamador até que a tarefa seja concluída.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</source>
          <target state="translated">Seu código não precisa contar com retornos de chamada ou eventos para continuar a execução após a tarefa ter sido concluída.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The language and task API integration does that for you.</source>
          <target state="translated">A integração da API da tarefa e da linguagem faz isso para você.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If you’re using <ph id="ph1">`Task&lt;T&gt;`</ph>, the <ph id="ph2">`await`</ph> keyword will additionally “unwrap” the value returned when the Task is complete.</source>
          <target state="translated">Se você estiver usando <ph id="ph1">`Task&lt;T&gt;`</ph>, a palavra-chave <ph id="ph2">`await`</ph> “desencapsulará” adicionalmente o valor retornado quando a tarefa for concluída.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The details of how this works are explained further below.</source>
          <target state="translated">Os detalhes de como isso funciona são explicados mais abaixo.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can learn more about tasks and the different ways to interact with them in the <bpt id="p1">[</bpt>Task-based Asynchronous Pattern (TAP) Article<ept id="p1">](https://msdn.microsoft.com/library/hh873175.aspx)</ept>.</source>
          <target state="translated">Você pode aprender mais sobre as tarefas e as diferentes maneiras de interagir com elas no <bpt id="p1">[</bpt>artigo Task-based Asynchronous Pattern (TAP)<ept id="p1">](https://msdn.microsoft.com/library/hh873175.aspx)</ept> (TAP (Padrão Assíncrono Baseado em Tarefa)).</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Deeper Dive into Tasks for an I/O-Bound Operation</source>
          <target state="translated">Aprofundamento em tarefas para uma operação vinculada à E/S</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following section describes a 10,000 foot view of what happens with a typical async I/O call.</source>
          <target state="translated">A seção a seguir descreve uma exibição de 10.000 pés do que acontece com uma chamada de E/S assíncrona típica.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Let's start with a couple examples.</source>
          <target state="translated">Vamos começar com alguns exemplos.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The first example calls an async method and returns an active task, likely yet to complete.</source>
          <target state="translated">O primeiro exemplo chama um método assíncrono e retorna uma tarefa ativa, provavelmente ainda para ser concluída.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The second example adds the use of he <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords to operate on the task.</source>
          <target state="translated">O segundo exemplo adiciona o uso das palavras-chave <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph> para operar na tarefa.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The call to <ph id="ph1">`GetStringAsync()`</ph> calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</source>
          <target state="translated">A chamada para <ph id="ph1">`GetStringAsync()`</ph> realiza a chamada por bibliotecas .NET de níveis inferiores (talvez chamando outros métodos assíncronos) até atingir uma chamada de interoperabilidade P/Invoke em uma biblioteca de rede nativa.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The native library may subsequently call into a System API call (such as <ph id="ph1">`write()`</ph> to a socket on Linux).</source>
          <target state="translated">A biblioteca nativa pode chamar subsequentemente uma chamada à API do sistema (como <ph id="ph1">`write()`</ph> para um soquete no Linux).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A task object will be created at the native/managed boundary, possibly using <bpt id="p1">[</bpt>TaskCompletionSource<ept id="p1">](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))</ept>.</source>
          <target state="translated">Um objeto de tarefa será criado no limite nativo/gerenciado, possivelmente usando <bpt id="p1">[</bpt>TaskCompletionSource<ept id="p1">](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))</ept>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</source>
          <target state="translated">O objeto de tarefa será passado pelas camadas, possivelmente operado ou retornado diretamente, finalmente retornado ao chamador inicial.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In the second example above, a <ph id="ph1">`Task&lt;T&gt;`</ph> object will be returned from <ph id="ph2">`GetStringAsync`</ph>.</source>
          <target state="translated">No segundo exemplo acima, um objeto <ph id="ph1">`Task&lt;T&gt;`</ph> será retornado de <ph id="ph2">`GetStringAsync`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The use of the <ph id="ph1">`await`</ph> keyword causes the method to return a newly created task object.</source>
          <target state="translated">O uso da palavra-chave <ph id="ph1">`await`</ph> faz com que o método retorne um objeto de tarefa recém-criado.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Control returns to the caller from this location in the <ph id="ph1">`GetFirstCharactersCountAsync`</ph> method.</source>
          <target state="translated">O controle retorna para o chamador desse local no método <ph id="ph1">`GetFirstCharactersCountAsync`</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The methods and properties of the <bpt id="p1">[</bpt>Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Threading.Tasks.Task%601)</ept> object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</source>
          <target state="translated">Os métodos e propriedades do objeto <bpt id="p1">[</bpt>Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Threading.Tasks.Task%601)</ept> permitem que os chamadores monitorem o progresso da tarefa, que será concluída quando o código restante em GetFirstCharactersCountAsync for executado.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as <ph id="ph1">`/net`</ph> in the Linux Kernel).</source>
          <target state="translated">Após a chamada à API do sistema, a solicitação está no espaço de kernel, trilhando seu caminho para o subsistema de rede do sistema operacional (como <ph id="ph1">`/net`</ph> no Kernel do Linux).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Here the OS will handle the networking request <bpt id="p1">*</bpt>asynchronously<ept id="p1">*</ept>.</source>
          <target state="translated">Aqui, o sistema operacional tratará a solicitação de rede <bpt id="p1">*</bpt>assincronamente<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and <bpt id="p1">*</bpt>then<ept id="p1">*</ept> a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</source>
          <target state="translated">Os detalhes podem ser diferentes dependendo do sistema operacional usado (a chamada de driver de dispositivo pode ser agendada como um sinal enviado de volta para o tempo de execução ou pode ser feita uma chamada de driver de dispositivo e <bpt id="p1">*</bpt>em seguida,<ept id="p1">*</ept> um sinal enviado de volta), mas, no fim, o tempo de execução será informado de que a solicitação de rede está em andamento.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</source>
          <target state="translated">Neste momento, o trabalho para o driver de dispositivo estará agendado, em andamento ou já finalizado (a solicitação já está “durante a transmissão”), mas como tudo isso está ocorrendo assincronamente, o driver do dispositivo pode manipular outra coisa imediatamente.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</source>
          <target state="translated">Por exemplo, no Windows, um thread de sistema operacional faz uma chamada para o driver de dispositivo de rede e solicita que ele realize a operação de rede por meio de um IRP (Pacote de Solicitação de Interrupção), que representa a operação.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</source>
          <target state="translated">O driver de dispositivo recebe o IRP, faz a chamada para a rede, marca o IRP como "pendente" e retorna para o sistema operacional.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</source>
          <target state="translated">Como o thread do sistema operacional agora sabe que o IRP está "pendente", ele não tem mais nenhum trabalho para fazer para esse trabalho e “retorna” para que possa ser usado para realizar outro trabalho.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</source>
          <target state="translated">Quando a solicitação é atendida e os dados voltam por meio do driver de dispositivo, ele notifica a CPU sobre os novos dados recebidos por meio de uma interrupção.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</source>
          <target state="translated">Como essa interrupção é tratada variará dependendo do sistema operacional, mas, no fim, os dados serão passados pelo sistema operacional até atingirem uma chamada de interoperabilidade do sistema (por exemplo, no Linux um manipulador de interrupção agendará a metade inferior da IRQ para passar os dados pelo sistema operacional assincronamente).</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Note that this <bpt id="p1">*</bpt>also<ept id="p1">*</ept> happens asynchronously!</source>
          <target state="translated">Observe que isso <bpt id="p1">*</bpt>também<ept id="p1">*</ept> ocorre assincronamente.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The result is queued up until the next available thread is able execute the async method and "unwrap" the result of the completed task.</source>
          <target state="translated">O resultado é colocado na fila até que o próximo thread disponível possa executar o método assíncrono e “desencapsular” o resultado da tarefa concluída.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Throughout this entire process, a key takeaway is that <bpt id="p1">**</bpt>no thread is dedicated to running the task<ept id="p1">**</ept>.</source>
          <target state="translated">Durante todo esse processo, uma consideração importante é que <bpt id="p1">**</bpt>nenhum thread é dedicado a executar a tarefa<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Although work is executed in some context (i.e. the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to <bpt id="p1">*</bpt>waiting<ept id="p1">*</ept> for data from the request to come back.</source>
          <target state="translated">Embora o trabalho seja executado em algum contexto (ou seja, o sistema operacional tem de passar os dados para um driver de dispositivo e responder a uma interrupção), nenhum thread é dedicado a <bpt id="p1">*</bpt>esperar<ept id="p1">*</ept> os dados da solicitação voltarem.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</source>
          <target state="translated">Isso permite que o sistema lide com um volume muito maior de trabalho em vez de esperar que alguma chamada de E/S seja concluída.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</source>
          <target state="translated">Embora o descrito acima possa parecer muito trabalho a ser feito, quando medido em termos de tempo total, ele é minúsculo em comparação com o tempo necessário para realizar o trabalho real de E/S.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Although not at all precise, a potential timeline for such a call would look like this:</source>
          <target state="translated">Embora não seja precisa, uma linha do tempo possível para essa chamada teria esta aparência:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>0-1————————————————————————————————————————————————–2-3</source>
          <target state="translated">0-1————————————————————————————————————————————————–2-3</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Time spent from points <ph id="ph1">`0`</ph> to <ph id="ph2">`1`</ph> is everything up until an async method yields control to its caller.</source>
          <target state="translated">O tempo gasto dos pontos <ph id="ph1">`0`</ph> até <ph id="ph2">`1`</ph> é tudo até um método assíncrono gerar o controle para seu chamador.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Time spent from points <ph id="ph1">`1`</ph> to <ph id="ph2">`2`</ph> is the time spent on I/O, with no CPU cost.</source>
          <target state="translated">O tempo gasto dos pontos <ph id="ph1">`1`</ph> até <ph id="ph2">`2`</ph> é o tempo gasto na E/S, sem custo de CPU.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Finally, time spent from points <ph id="ph1">`2`</ph> to <ph id="ph2">`3`</ph> is passing control back (and potentially a value) to the async method, at which point it is executing again.</source>
          <target state="translated">Por fim, o tempo gasto dos pontos <ph id="ph1">`2`</ph> até <ph id="ph2">`3`</ph> está passando o controle de volta (e potencialmente um valor) para o método assíncrono, ponto no qual está sendo executado novamente.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>What does this mean for a server scenario?</source>
          <target state="translated">O que isso significa para um cenário de servidor?</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This model works well with a typical server scenario workload.</source>
          <target state="translated">Esse modelo funciona bem com uma carga de trabalho de cenário de servidor típica.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</source>
          <target state="translated">Como não há nenhum thread dedicado para bloquear tarefas não concluídas, o pool de threads do servidor pode atender a um volume muito maior de solicitações da Web.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Consider two servers: one that runs async code, and one that does not.</source>
          <target state="translated">Considere dois servidores: um que executa o código assíncrono e que não faz isso.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For the purpose of this example, each server only has 5 threads available to service requests.</source>
          <target state="translated">Para esse exemplo, cada servidor tem apenas cinco threads disponíveis para solicitações de serviço.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Note that these numbers are imaginarily small and serve only in a demonstrative context.</source>
          <target state="translated">Observe que esses números são imaginariamente pequenos e servem apenas em um contexto de demonstração.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Assume both servers receive 6 concurrent requests.</source>
          <target state="translated">Suponha que ambos os servidores recebem seis solicitações simultâneas.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Each request performs an I/O operation.</source>
          <target state="translated">Cada solicitação executa uma operação de E/S.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The server <bpt id="p1">*</bpt>without<ept id="p1">*</ept> async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</source>
          <target state="translated">O servidor <bpt id="p1">*</bpt>sem<ept id="p1">*</ept> o código assíncrono precisa enfileirar a sexta solicitação até que um dos cinco threads tenham concluído o trabalho vinculado à E/S e escrito uma resposta.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</source>
          <target state="translated">No ponto em que a 20ª solicitação chega, o servidor pode começar a ficar lento, pois a fila está ficando muito longa.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The server <bpt id="p1">*</bpt>with<ept id="p1">*</ept> async code running on it still queues up the 6th request, but because it uses <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph>, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</source>
          <target state="translated">O servidor <bpt id="p1">*</bpt>com<ept id="p1">*</ept> o código assíncrono em execução ainda enfileira a sexta solicitação, mas como ele usa <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph>, cada um de seus threads é liberado quando o trabalho vinculado à E/S começa, em vez de quando ele é concluído.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</source>
          <target state="translated">No momento em que a 20ª solicitação chega, a fila para as solicitações recebidas é muito menor (se ela tiver algo em absoluto) e o servidor não fica lento.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Although this is a contrived example, it works in a very similar fashion in the real world.</source>
          <target state="translated">Embora esse seja um exemplo inventado, ele funciona de maneira muito semelhante no mundo real.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In fact, you can expect a server to be able to handle an order of magnitude more requests using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> than if it were dedicating a thread for each request it receives.</source>
          <target state="translated">Na verdade, você pode esperar que um servidor seja capaz de lidar com uma ordem de grandeza de mais solicitações usando <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph> do que se ele estivesse dedicando um thread para cada solicitação recebida.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>What does this mean for client scenario?</source>
          <target state="translated">O que isso significa para um cenário de cliente?</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The biggest gain for using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> for a client app is an increase in responsiveness.</source>
          <target state="translated">O maior ganho do uso do <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph> para um aplicativo cliente é um aumento na capacidade de resposta.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph>.</source>
          <target state="translated">Embora você possa fazer um aplicativo responsivo gerando threads manualmente, o ato de gerar um thread é uma operação cara em relação a apenas usar o <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</source>
          <target state="translated">Especialmente para algo como um jogo para dispositivos móveis, afetar o thread da interface do usuário o mínimo possível no que concerne à E/S é crucial.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</source>
          <target state="translated">Mais importante, como o trabalho vinculado à E/S passa praticamente nenhum tempo na CPU, dedicar um thread de CPU inteiro para realizar quase nenhum trabalho útil seria um uso inadequado dos recursos.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with <ph id="ph1">`async`</ph> methods, and does not require extra work (such as calling a thread-safe delegate).</source>
          <target state="translated">Além disso, distribuir o trabalho para o thread de interface do usuário (como atualizar uma interface do usuário) é muito simples com os métodos <ph id="ph1">`async`</ph> e não requer trabalho extra (como chamar um delegado thread-safe).</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Deeper Dive into Task and Task<ph id="ph1">&lt;T&gt;</ph> for a CPU-Bound Operation</source>
          <target state="translated">Aprofundamento em Task e Task<ph id="ph1">&lt;T&gt;</ph> para uma operação vinculada à CPU</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>CPU-bound <ph id="ph1">`async`</ph> code is a bit different than I/O-bound <ph id="ph2">`async`</ph> code.</source>
          <target state="translated">O código <ph id="ph1">`async`</ph> vinculado à CPU é um pouco diferente do código <ph id="ph2">`async`</ph> vinculado à E/S.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</source>
          <target state="translated">Como o trabalho é feito na CPU, não há como contornar a dedicação de um thread à computação.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The use of <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</source>
          <target state="translated">O uso de <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph> fornece uma maneira simples de interagir com thread em segundo plano e manter o chamador do método assíncrono responsivo.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Note that this does not provide any protection for shared data.</source>
          <target state="translated">Observe que isso não fornece nenhuma proteção para dados compartilhados.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If you are using shared data, you will still need to apply an appropriate synchronization strategy.</source>
          <target state="translated">Se você estiver usando dados compartilhados, ainda precisará aplicar uma estratégia de sincronização apropriada.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Here's a 10,000 foot view of a CPU-bound async call:</source>
          <target state="translated">Esta é uma exibição de 10.000 pés de uma chamada assíncrona vinculada à CPU:</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CalculateResult()`</ph> executes on the thread it was called on.</source>
          <target state="translated"><ph id="ph1">`CalculateResult()`</ph> executa no thread no qual foi chamado.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When it calls <ph id="ph1">`Task.Run`</ph>, it queues the expensive CPU-bound operation, <ph id="ph2">`DoExpensiveCalculation()`</ph>, on the thread pool and receives a <ph id="ph3">`Task&lt;int&gt;`</ph> handle.</source>
          <target state="translated">Quando ele chama <ph id="ph1">`Task.Run`</ph>, coloca na fila cara operação vinculada à CPU, <ph id="ph2">`DoExpensiveCalculation()`</ph>, no pool de threads e recebe um identificador <ph id="ph3">`Task&lt;int&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`DoExpensiveCalculation()`</ph> is eventually run concurrently on the next available thread, likely on another CPU core.</source>
          <target state="translated"><ph id="ph1">`DoExpensiveCalculation()`</ph> é finalmente executado simultaneamente no próximo thread disponível, provavelmente em outro núcleo da CPU.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>It's possible to do concurrent work while <ph id="ph1">`DoExpensiveCalculation()`</ph> is busy on another thread, because the thread which called <ph id="ph2">`CalculateResult()`</ph> is still executing.</source>
          <target state="translated">É possível fazer o trabalho simultâneo enquanto <ph id="ph1">`DoExpensiveCalculation()`</ph> está ocupado em outro thread, pois o thread que chamou <ph id="ph2">`CalculateResult()`</ph> ainda está em execução.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Once <ph id="ph1">`await`</ph> is encountered, the execution of <ph id="ph2">`CalculateResult()`</ph> is yielded to its caller, allowing other work to be done with the current thread while <ph id="ph3">`DoExpensiveCalculation()`</ph> is churning out a result.</source>
          <target state="translated">Uma vez que <ph id="ph1">`await`</ph> é encontrado, a execução de <ph id="ph2">`CalculateResult()`</ph> é gerada para seu chamador, permitindo que outro trabalho seja realizado com o thread atual enquanto <ph id="ph3">`DoExpensiveCalculation()`</ph> está produzindo um resultado.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Once it has finished, the result is queued up to run on the main thread.</source>
          <target state="translated">Ao terminar, o resultado é enfileirado para ser executado no thread principal.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Eventually, the main thread will return to executing <ph id="ph1">`CalculateResult()`</ph>, at which point it will have the result of <ph id="ph2">`DoExpensiveCalculation()`</ph>.</source>
          <target state="translated">No fim, o thread principal retornará para a execução de <ph id="ph1">`CalculateResult()`</ph>, ponto em que ele terá o resultado de <ph id="ph2">`DoExpensiveCalculation()`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Why does async help here?</source>
          <target state="translated">Por que a assincronia ajuda aqui?</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> are the best practice managing CPU-bound work when you need responsiveness.</source>
          <target state="translated"><ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph> são a melhor prática para gerenciar o trabalho vinculado à CPU quando você precisar de capacidade de resposta.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>There are multiple patterns for using async with CPU-bound work.</source>
          <target state="translated">Existem vários padrões para usar a assincronia com o trabalho vinculado à CPU.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>It's important to note that there is a small cost to using async and it's not recommended for tight loops.</source>
          <target state="translated">É importante observar que há um pequeno custo para usar a assincronia e não é recomendado para loops estreitos.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>It's up to you to determine how you write your code around this new capability.</source>
          <target state="translated">Cabe a você determinar como escrever seu código em torno dessa nova capacidade.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>