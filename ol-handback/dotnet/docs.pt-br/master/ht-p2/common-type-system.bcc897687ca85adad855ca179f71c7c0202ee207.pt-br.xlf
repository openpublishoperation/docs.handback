<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7d7f869b07d7cf00ffa69da117aa199d1b6e8f20</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\common-type-system.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f66d2394f5af4bc23f5a34be8d74d91b9969f4c7</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f03d101855314514e4afe7575f76c76990f1ab5e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Common type system in depth</source>
          <target state="translated">Sistema de tipo comum detalhado</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Common type system in depth</source>
          <target state="translated">Sistema de tipo comum detalhado</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Common type system in depth</source>
          <target state="translated">Sistema de tipo comum detalhado</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections that explore the common type system in depth:</source>
          <target state="translated">Este tópico contém as seções a seguir que exploram o Common Type System detalhadamente:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types in .NET<ept id="p1">](#types-in-net)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tipos no .NET<ept id="p1">](#types-in-net)</ept></target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type definitions<ept id="p1">](#type-definitions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Definições de tipo<ept id="p1">](#type-definitions)</ept></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type members<ept id="p1">](#type-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Membros de tipos<ept id="p1">](#type-members)</ept></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Characteristics of type members<ept id="p1">](#characteristics-of-type-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Características de membros de tipo<ept id="p1">](#characteristics-of-type-members)</ept></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Types in .NET</source>
          <target state="translated">Tipos no .NET</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>All types in .NET are either value types or reference types.</source>
          <target state="translated">Todos os tipos no .NET são tipos de valor ou tipos de referência.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Value types are data types whose objects are represented by the object's actual value.</source>
          <target state="translated">Tipos de valor são tipos de dados cujos objetos são representados pelo valor real do objeto.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If an instance of a value type is assigned to a variable, that variable is given a fresh copy of the value.</source>
          <target state="translated">Se uma instância de um tipo de valor é atribuída a uma variável, essa variável recebe uma nova cópia do valor.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Reference types are data types whose objects are represented by a reference (similar to a pointer) to the object's actual value.</source>
          <target state="translated">Tipos de referência são tipos de dados cujos objetos são representados por uma referência (semelhante a um ponteiro) para o valor real do objeto.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If a reference type is assigned to a variable, that variable references (points to) the original value.</source>
          <target state="translated">Se um tipo de referência é atribuído a uma variável, essa variável referencia (aponta para) o valor original.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>No copy is made.</source>
          <target state="translated">Nenhuma cópia é feita.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The common type system in .NET supports the following five categories of types:</source>
          <target state="translated">O Common Type System no .NET dá suporte às seguintes cinco categorias de tipos:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Classes<ept id="p1">](#classes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Classes<ept id="p1">](#classes)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Structures<ept id="p1">](#structures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Estruturas<ept id="p1">](#structures)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enumerations<ept id="p1">](#enumerations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Enumerações<ept id="p1">](#enumerations)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates<ept id="p1">](#delegates)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Delegados<ept id="p1">](#delegates)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A class is a reference type that can be derived directly from another class and that is derived implicitly from <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</source>
          <target state="translated">Uma classe é um tipo de referência que pode ser derivado diretamente de outra classe e que é derivada implicitamente de <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The class defines the operations that an object (which is an instance of the class) can perform (methods, events, or properties) and the data that the object contains (fields).</source>
          <target state="translated">A classe define as operações que um objeto (que é uma instância da classe) pode executar (métodos, eventos ou propriedades) e os dados que o objeto contém (campos).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Although a class generally includes both definition and implementation (unlike interfaces, for example, which contain only definition without implementation), it can have one or more members that have no implementation.</source>
          <target state="translated">Embora uma classe geralmente inclua a definição e a implementação (diferente de interfaces, por exemplo, que contêm somente a definição sem implementação), ela pode ter um ou mais membros que não têm implementação.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The following table describes some of the characteristics that a class may have.</source>
          <target state="translated">A tabela a seguir descreve algumas das características que uma classe pode ter.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Each language that supports the runtime provides a way to indicate that a class or class member has one or more of these characteristics.</source>
          <target state="translated">Cada linguagem que dá suporte ao tempo de execução fornece uma maneira para indicar que uma classe ou um membro da classe tem uma ou mais dessas características.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>However, individual programming languages that target .NET may not make all these characteristics available.</source>
          <target state="translated">No entanto, as linguagens de programação individuais que segmentam o .NET não podem disponibilizar todas essas características.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Characteristic</source>
          <target state="translated">Característica</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>sealed</source>
          <target state="translated">sealed</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Specifies that another class cannot be derived from this type.</source>
          <target state="translated">Especifica que outra classe não pode ser derivada desse tipo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>implements</source>
          <target state="translated">implementa</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Indicates that the class uses one or more interfaces by providing implementations of interface members.</source>
          <target state="translated">Indica que a classe usa uma ou mais interfaces, fornecendo implementações de membros da interface.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>abstract</source>
          <target state="translated">abstract</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Indicates that the class cannot be instantiated.</source>
          <target state="translated">Indica que a classe não pode ser instanciada.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>To use it, you must derive another class from it.</source>
          <target state="translated">Para usá-la, você deve derivar outra classe a partir dela.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>inherits</source>
          <target state="translated">herda</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Indicates that instances of the class can be used anywhere the base class is specified.</source>
          <target state="translated">Indica que as instâncias da classe podem ser usadas em qualquer lugar em que a classe base for especificada.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A derived class that inherits from a base class can use the implementation of any public members provided by the base class, or the derived class can override the implementation of the public members with its own implementation.</source>
          <target state="translated">Uma classe derivada que herda de uma classe base pode usar a implementação de todos os membros públicos fornecidos pela classe base ou a classe derivada pode substituir a implementação dos membros públicos com sua própria implementação.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>exported or not exported</source>
          <target state="translated">exportado ou não exportado</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Indicates whether a class is visible outside the assembly in which it is defined.</source>
          <target state="translated">Indica se uma classe está visível fora do assembly em que ela está definida.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This characteristic applies only to top-level classes and not to nested classes.</source>
          <target state="translated">Essa característica só se aplica a classes de nível superior e não a classes aninhadas.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A class can also be nested in a parent class or structure.</source>
          <target state="translated">Uma classe também pode ser aninhada em uma classe ou estrutura pai.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Nested classes also have member characteristics.</source>
          <target state="translated">Classes aninhadas também têm características de membro.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Nested types<ept id="p1">](#nested-types)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Tipos aninhados<ept id="p1">](#nested-types)</ept>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Class members that have no implementation are abstract members.</source>
          <target state="translated">Membros da classe que não tenham implementação são membros abstratos.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A class that has one or more abstract members is itself abstract; new instances of it cannot be created.</source>
          <target state="translated">Uma classe que tenha um ou mais membros abstratos é ela própria abstrata. Não é possível criar novas instâncias dessa classe.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Some languages that target the runtime let you mark a class as abstract even if none of its members are abstract.</source>
          <target state="translated">Algumas linguagens que segmentam o tempo de execução permitem marcar uma classe como abstrata mesmo que nenhum de seus membros seja abstrato.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can use an abstract class when you want to encapsulate a basic set of functionality that derived classes can inherit or override when appropriate.</source>
          <target state="translated">É possível usar uma classe abstrata quando você deseja encapsular um conjunto básico de funcionalidades que as classes derivadas podem herdar ou substituir quando apropriado.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Classes that are not abstract are referred to as concrete classes.</source>
          <target state="translated">Classes que não são abstratas são chamadas de classes concretas.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A class can implement any number of interfaces, but it can inherit from only one base class in addition to <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>, from which all classes inherit implicitly.</source>
          <target state="translated">Uma classe pode implementar qualquer número de interfaces, mas pode herdar apenas uma classe base além de <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>, de que todas as classes herdam implicitamente.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>All classes must have at least one constructor, which initializes new instances of the class.</source>
          <target state="translated">Todas as classes devem ter pelo menos um construtor, que inicializa novas instâncias da classe.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you do not explicitly define a constructor, most compilers will automatically provide a default (parameterless) constructor.</source>
          <target state="translated">Se você não definir explicitamente um construtor, a maioria dos compiladores fornecerá automaticamente um construtor padrão (sem parâmetros).</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Structures</source>
          <target state="translated">Estruturas</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>A structure is a value type that derives implicitly from <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, which in turn is derived from <bpt id="p2">[</bpt>System.Object<ept id="p2">](xref:System.Object)</ept>.</source>
          <target state="translated">Uma estrutura é um tipo de valor que é derivado implicitamente de <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept> que, por sua vez, é derivado de <bpt id="p2">[</bpt>System.Object<ept id="p2">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A structure is very useful for representing values whose memory requirements are small, and for passing values as by-value parameters to methods that have strongly typed parameters.</source>
          <target state="translated">Uma estrutura é muito útil para representar valores cujos requisitos de memória são pequenos e passar valores como parâmetros por valor para os métodos que tenham parâmetros fortemente tipados.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In .NET, all primitive data types (<bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>DateTime<ept id="p4">](xref:System.DateTime)</ept>, <bpt id="p5">[</bpt>Decimal<ept id="p5">](xref:System.Decimal)</ept>, <bpt id="p6">[</bpt>Double<ept id="p6">](xref:System.Double)</ept>, <bpt id="p7">[</bpt>Int16<ept id="p7">](xref:System.Int16)</ept>, <bpt id="p8">[</bpt>Int32<ept id="p8">](xref:System.Int32)</ept>, <bpt id="p9">[</bpt>Int64<ept id="p9">](xref:System.Int64)</ept>, <bpt id="p10">[</bpt>SByte<ept id="p10">](xref:System.SByte)</ept>, <bpt id="p11">[</bpt>Single<ept id="p11">](xref:System.Single)</ept>, <bpt id="p12">[</bpt>UInt16<ept id="p12">](xref:System.UInt16)</ept>, <bpt id="p13">[</bpt>UInt32<ept id="p13">](xref:System.UInt32)</ept>, and <bpt id="p14">[</bpt>UInt64<ept id="p14">](xref:System.UInt64)</ept>) are defined as structures.</source>
          <target state="translated">No .NET, todos os tipos de dados primitivos (<bpt id="p1">[</bpt>Booliano<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>DateTime<ept id="p4">](xref:System.DateTime)</ept>, <bpt id="p5">[</bpt>Decimal<ept id="p5">](xref:System.Decimal)</ept>, <bpt id="p6">[</bpt>Double<ept id="p6">](xref:System.Double)</ept>, <bpt id="p7">[</bpt>Int16<ept id="p7">](xref:System.Int16)</ept>, <bpt id="p8">[</bpt>Int32<ept id="p8">](xref:System.Int32)</ept>, <bpt id="p9">[</bpt>Int64<ept id="p9">](xref:System.Int64)</ept>, <bpt id="p10">[</bpt>SByte<ept id="p10">](xref:System.SByte)</ept>, <bpt id="p11">[</bpt>Single<ept id="p11">](xref:System.Single)</ept>, <bpt id="p12">[</bpt>UInt16<ept id="p12">](xref:System.UInt16)</ept>, <bpt id="p13">[</bpt>UInt32<ept id="p13">](xref:System.UInt32)</ept> e <bpt id="p14">[</bpt>UInt64<ept id="p14">](xref:System.UInt64)</ept>) são definidos como estruturas.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Like classes, structures define both data (the fields of the structure) and the operations that can be performed on that data (the methods of the structure).</source>
          <target state="translated">Assim como as classes, as estruturas definem os dados (os campos da estrutura) e as operações que podem ser executadas nesses dados (os métodos da estrutura).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This means that you can call methods on structures, including the virtual methods defined on the <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> and <bpt id="p2">[</bpt>System.ValueType<ept id="p2">](xref:System.ValueType)</ept> classes, and any methods defined on the value type itself.</source>
          <target state="translated">Isso significa que você pode chamar métodos em estruturas, incluindo os métodos virtuais definidos nas classes <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> e <bpt id="p2">[</bpt>System.ValueType<ept id="p2">](xref:System.ValueType)</ept> e todos os métodos definidos no próprio tipo de valor.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In other words, structures can have fields, properties, and events, as well as static and nonstatic methods.</source>
          <target state="translated">Em outras palavras, as estruturas podem ter campos, propriedades e eventos, bem como métodos estáticos e não estáticos.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You can create instances of structures, pass them as parameters, store them as local variables, or store them in a field of another value type or reference type.</source>
          <target state="translated">É possível criar instâncias de estruturas, passá-las como parâmetros, armazená-las como variáveis locais ou armazená-las em um campo de outro tipo de valor ou tipo de referência.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Structures can also implement interfaces.</source>
          <target state="translated">As estruturas também podem implementar interfaces.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Value types also differ from classes in several respects.</source>
          <target state="translated">Tipos de valor também são diferentes das classes em vários pontos.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>First, although they implicitly inherit from <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, they cannot directly inherit from any type.</source>
          <target state="translated">Primeiro, embora herdem implicitamente de <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, eles não podem herdar diretamente de qualquer tipo.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Similarly, all value types are sealed, which means that no other type can be derived from them.</source>
          <target state="translated">Da mesma forma, todos os tipos de valor são lacrados, o que significa que nenhum outro tipo pode ser derivado deles.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>They also do not require constructors.</source>
          <target state="translated">Eles também não exigem construtores.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For each value type, the common language runtime supplies a corresponding boxed type, which is a class that has the same state and behavior as the value type.</source>
          <target state="translated">Para cada tipo de valor, o Common Language Runtime fornece um tipo disponível demarcado correspondente, que é uma classe com o mesmo estado e comportamento que o tipo de valor.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>An instance of a value type is boxed when it is passed to a method that accepts a parameter of type <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</source>
          <target state="translated">Uma instância de um tipo de valor é demarcada quando é passada para um método que aceita um parâmetro de tipo <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>It is unboxed (that is, converted from an instance of a class back to an instance of a value type) when control returns from a method call that accepts a value type as a by-reference parameter.</source>
          <target state="translated">Ele é não demarcado (ou seja, convertido de uma instância de uma classe de volta para uma instância de um tipo de valor) quando o controle retorna de uma chamada de método que aceita um tipo de valor como um parâmetro por referência.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Some languages require that you use special syntax when the boxed type is required; others automatically use the boxed type when it is needed.</source>
          <target state="translated">Algumas linguagens exigem que você use sintaxe especial quando o tipo demarcado é necessário. Outras usam automaticamente o tipo demarcado quando necessário.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>When you define a value type, you are defining both the boxed and the unboxed type.</source>
          <target state="translated">Ao definir um tipo de valor, você está definindo o tipo demarcado e não demarcado.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Enumerações</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>An enumeration (enum) is a value type that inherits directly from <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept> and that supplies alternate names for the values of an underlying primitive type.</source>
          <target state="translated">Uma enumeração (enum) é um tipo de valor que é herdado diretamente de <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept> e que fornece nomes alternativos para valores de um tipo primitivo subjacente.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>An enumeration type has a name, an underlying type that must be one of the built-in signed or unsigned integer types (such as <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>, or <bpt id="p3">[</bpt>UInt64<ept id="p3">](xref:System.UInt64)</ept>), and a set of fields.</source>
          <target state="translated">Um tipo de enumeração tem um nome, um tipo subjacente que deve ser um dos tipos inteiros com ou sem sinal internos (como <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept> ou <bpt id="p3">[</bpt>UInt64<ept id="p3">](xref:System.UInt64)</ept>) e um conjunto de campos.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The fields are static literal fields, each of which represents a constant.</source>
          <target state="translated">Os campos são campos literais estáticos, cada um deles representa uma constante.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The same value can be assigned to multiple fields.</source>
          <target state="translated">O mesmo valor pode ser atribuído a vários campos.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>When this occurs, you must mark one of the values as the primary enumeration value for reflection and string conversion.</source>
          <target state="translated">Quando isso ocorre, você deve marcar um dos valores como o valor de enumeração primário para reflexão e conversão da cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You can assign a value of the underlying type to an enumeration and vice versa (no cast is required by the runtime).</source>
          <target state="translated">Você pode atribuir um valor de tipo subjacente a uma enumeração e vice-versa (nenhuma conversão é exigida pelo tempo de execução).</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You can create an instance of an enumeration and call the methods of <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept>, as well as any methods defined on the enumeration's underlying type.</source>
          <target state="translated">É possível criar uma instância de uma enumeração e chamar os métodos de <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept>, assim como qualquer método definido no tipo subjacente da enumeração.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>However, some languages might not let you pass an enumeration as a parameter when an instance of the underlying type is required (or vice versa).</source>
          <target state="translated">No entanto, algumas linguagens talvez não deixem passar uma enumeração como um parâmetro quando uma instância do tipo subjacente é necessária (ou vice-versa).</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following additional restrictions apply to enumerations:</source>
          <target state="translated">As seguintes restrições adicionais se aplicam a enumerações:</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>They cannot define their own methods.</source>
          <target state="translated">Elas não podem definir seus próprios métodos.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>They cannot implement interfaces.</source>
          <target state="translated">Elas não podem implementar interfaces.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>They cannot define properties or events.</source>
          <target state="translated">Elas não podem definir propriedades ou eventos.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>They cannot be generic, unless they are generic only because they are nested within a generic type.</source>
          <target state="translated">Elas não podem ser genéricas, a menos que sejam genéricas apenas por estarem aninhadas dentro de um tipo genérico.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>That is, an enumeration cannot have type parameters of its own.</source>
          <target state="translated">Ou seja, uma enumeração não pode ter parâmetros de tipo próprios.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Nested types (including enumerations) created with C# include the type parameters of all enclosing generic types, and are therefore generic even if they do not have type parameters of their own.</source>
          <target state="translated">Tipos aninhados (incluindo enumerações) criados com o C# incluem os parâmetros de tipo de todos os tipos genéricos e, portanto, serão genéricos mesmo se não tiverem parâmetros de tipo próprios.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Type.MakeGenericType<ept id="p1">](xref:System.Type.MakeGenericType(System.Type[]))</ept> reference topic.</source>
          <target state="translated">Para obter mais informações, consulte o tópico de referência <bpt id="p1">[</bpt>Type.MakeGenericType<ept id="p1">](xref:System.Type.MakeGenericType(System.Type[]))</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> attribute denotes a special kind of enumeration called a bit field.</source>
          <target state="translated">O atributo <bpt id="p1">[</bpt>FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> denota um tipo especial de enumeração chamado campo de bits.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The runtime itself does not distinguish between traditional enumerations and bit fields, but your language might do so.</source>
          <target state="translated">O próprio tempo de execução não faz distinção entre enumerações tradicionais e campos de bits, mas a linguagem pode fazer isso.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>When this distinction is made, bitwise operators can be used on bit fields, but not on enumerations, to generate unnamed values.</source>
          <target state="translated">Quando é feita essa distinção, operadores bit a bit podem ser usados em campos de bits, mas não em enumerações, para gerar valores sem nome.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Enumerations are generally used for lists of unique elements, such as days of the week, country or region names, and so on.</source>
          <target state="translated">Enumerações geralmente são usadas para listas de elementos exclusivos, como dias da semana, país ou nomes de região etc.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Bit fields are generally used for lists of qualities or quantities that might occur in combination, such as <ph id="ph1">`Red And Big And Fast`</ph>.</source>
          <target state="translated">Os campos de bits são geralmente usados para listas de qualidades ou quantidades que possam ocorrer em combinação, como <ph id="ph1">`Red And Big And Fast`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following example shows how to use both bit fields and traditional enumerations.</source>
          <target state="translated">O exemplo a seguir mostra como usar campos de bit e enumerações tradicionais.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>An interface defines a contract that specifies a "can do" relationship or a "has a" relationship.</source>
          <target state="translated">Uma interface define um contrato que especifica um relacionamento "possível" ou um relacionamento de "propriedade".</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Interfaces are often used to implement functionality, such as comparing and sorting (the <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> and <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept> interfaces), testing for equality (the <bpt id="p3">[</bpt>IEquatable<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p3">](xref:System.IEquatable%601)</ept> interface), or enumerating items in a collection (the <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept> and <bpt id="p5">[</bpt>IEnumerable<ph id="ph5">&amp;lt;</ph>T<ph id="ph6">&amp;gt;</ph><ept id="p5">](xref:System.Collections.Generic.IEnumerable%601)</ept> interfaces).</source>
          <target state="translated">Interfaces são geralmente usadas para implementar a funcionalidade, como comparação e classificação (interfaces <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> e <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept>), testes de igualdade (a interface <bpt id="p3">[</bpt>IEquatable<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p3">](xref:System.IEquatable%601)</ept>), ou a enumeração de itens em uma coleção (as interfaces <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept> e <bpt id="p5">[</bpt>IEnumerable<ph id="ph5">&amp;lt;</ph>T<ph id="ph6">&amp;gt;</ph><ept id="p5">](xref:System.Collections.Generic.IEnumerable%601)</ept>).</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Interfaces can have properties, methods, and events, all of which are abstract members; that is, although the interface defines the members and their signatures, it leaves it to the type that implements the interface to define the functionality of each interface member.</source>
          <target state="translated">Interfaces podem ter propriedades, métodos, eventos e todos os que são membros abstratos; ou seja, embora a interface defina os membros e suas assinaturas, ela deixa para o tipo que implementa a interface para definir a funcionalidade de cada membro da interface.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This means that any class or structure that implements an interface must supply definitions for the abstract members declared in the interface.</source>
          <target state="translated">Isso significa que qualquer classe ou estrutura que implementa uma interface deve fornecer definições para os membros abstratos declarados na interface.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>An interface can require any implementing class or structure to also implement one or more other interfaces.</source>
          <target state="translated">Uma interface pode exigir qualquer classe de implementação ou estrutura para também implementar uma ou mais outras interfaces.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to interfaces:</source>
          <target state="translated">As restrições a seguir se aplicam a interfaces:</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>An interface can be declared with any accessibility, but interface members must all have public accessibility.</source>
          <target state="translated">Uma interface pode ser declarada com qualquer acessibilidade, mas membros da interface devem ter acessibilidade pública.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Interfaces cannot define constructors.</source>
          <target state="translated">Interfaces não podem definir construtores.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Interfaces cannot define fields.</source>
          <target state="translated">Interfaces não podem definir campos.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Interfaces can define only instance members.</source>
          <target state="translated">Interfaces podem definir apenas membros de instância.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>They cannot define static members.</source>
          <target state="translated">Elas não podem definir membros estáticos.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Each language must provide rules for mapping an implementation to the interface that requires the member, because more than one interface can declare a member with the same signature, and these members can have separate implementations.</source>
          <target state="translated">Cada linguagem deve fornecer regras para mapear uma implementação para a interface que exija o membro, porque mais de uma interface pode declarar um membro com a mesma assinatura e esses membros podem ter implementações separadas.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Delegates</source>
          <target state="translated">Delegados</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Delegates are reference types that serve a purpose similar to that of function pointers in C++.</source>
          <target state="translated">Os delegados são tipos de referência que têm um propósito semelhante aos de ponteiros de função no C++.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>They are used for event handlers and callback functions in .NET.</source>
          <target state="translated">Eles são usados para manipuladores de eventos e funções de retorno de chamada no .NET.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Unlike function pointers, delegates are secure, verifiable, and type safe.</source>
          <target state="translated">Diferentemente de ponteiros de função, delegados são seguros, verificáveis e fortemente tipados.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>A delegate type can represent any instance method or static method that has a compatible signature.</source>
          <target state="translated">Um tipo de delegado pode representar qualquer método de instância ou método estático que tenha uma assinatura compatível.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For example, a delegate that has a parameter of type <bpt id="p1">[</bpt>IEnumerable<ept id="p1">](xref:System.Collections.IEnumerable)</ept> and a return type of <bpt id="p2">[</bpt>Object<ept id="p2">](xref:System.Object)</ept> can represent a method that has a parameter of type <bpt id="p3">[</bpt>Object<ept id="p3">](xref:System.Object)</ept> and a return value of type <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept>.</source>
          <target state="translated">Por exemplo, um delegado que tenha um parâmetro de tipo <bpt id="p1">[</bpt>IEnumerable<ept id="p1">](xref:System.Collections.IEnumerable)</ept> e um tipo de retorno de <bpt id="p2">[</bpt>Object<ept id="p2">](xref:System.Object)</ept> pode representar um método que tenha um parâmetro de tipo <bpt id="p3">[</bpt>Object<ept id="p3">](xref:System.Object)</ept> e um valor retornado de tipo <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>A delegate is said to be bound to the method it represents.</source>
          <target state="translated">Diz-se que um delegado está associado ao método que representa.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In addition to being bound to the method, a delegate can be bound to an object.</source>
          <target state="translated">Além de estar associado ao método, um delegado pode ser associado a um objeto.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The object represents the first parameter of the method, and is passed to the method every time the delegate is invoked.</source>
          <target state="translated">O objeto representa o primeiro parâmetro do método e é passado para o método sempre que o delegado é invocado.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If the method is an instance method, the bound object is passed as the implicit <ph id="ph1">`this`</ph> parameter (<ph id="ph2">`Me`</ph> in Visual Basic); if the method is static, the object is passed as the first formal parameter of the method, and the delegate signature must match the remaining parameters.</source>
          <target state="translated">Se o método for um método de instância, o objeto associado será passado como parâmetro <ph id="ph1">`this`</ph> implícito (<ph id="ph2">`Me`</ph> no Visual Basic). Se o método for estático, o objeto será passado como o primeiro parâmetro formal do método e a assinatura do delegado deverá corresponder aos parâmetros restantes.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>All delegates inherit from <bpt id="p1">[</bpt>System.MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, which inherits from <bpt id="p2">[</bpt>System.Delegate<ept id="p2">](xref:System.Delegate)</ept>.</source>
          <target state="translated">Todos os delegados herdam de <bpt id="p1">[</bpt>System.MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, que herda de <bpt id="p2">[</bpt>System.Delegate<ept id="p2">](xref:System.Delegate)</ept>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The C# and Visual Basic languages don't allow inheritance from these types.</source>
          <target state="translated">As linguagens C# e Visual Basic não permitem a herança desses tipos.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Instead, they provide keywords for declaring delegates.</source>
          <target state="translated">Em vez disso, elas fornecem palavras-chave para declarar delegados.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Because delegates inherit from <bpt id="p1">[</bpt>MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, a delegate has an invocation list, which is a list of methods that the delegate represents and that are executed when the delegate is invoked.</source>
          <target state="translated">Como delegados herdam de <bpt id="p1">[</bpt>MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, um delegado tem uma lista dos métodos que o delegado representa e que são executados quando o delegado é invocado.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>All methods in the list receive the arguments supplied when the delegate is invoked.</source>
          <target state="translated">Todos os métodos na lista recebem os argumentos fornecidos quando o delegado é invocado.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The return value is not defined for a delegate that has more than one method in its invocation list, even if the delegate has a return type.</source>
          <target state="translated">O valor retornado não é definido para um delegado que tenha mais de um método na lista de invocação, mesmo que o delegado tenha um tipo de retorno.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>In many cases, such as with callback methods, a delegate represents only one method, and the only actions you have to take are creating the delegate and invoking it.</source>
          <target state="translated">Em muitos casos, como acontece com métodos de retorno de chamada, um delegado representa apenas um método e as únicas ações que você precisa realizar são criar e invocar o delegado.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>For delegates that represent multiple methods, .NET provides methods of the <bpt id="p1">[</bpt>Delegate<ept id="p1">](xref:System.Delegate)</ept> and <bpt id="p2">[</bpt>MulticastDelegate<ept id="p2">](xref:System.MulticastDelegate)</ept> delegate classes to support operations such as adding a method to a delegate's invocation list (the <bpt id="p3">[</bpt>Delegate.Combine<ept id="p3">](xref:System.Delegate.Combine(System.Delegate,System.Delegate))</ept> method), removing a method (the <bpt id="p4">[</bpt>Delegate.Remove<ept id="p4">](xref:System.Delegate.Remove(System.Delegate,System.Delegate))</ept> method), and getting the invocation list (the <bpt id="p5">[</bpt>Delegate.GetInvocationList<ept id="p5">](xref:System.Delegate.GetInvocationList)</ept> method).</source>
          <target state="translated">Para delegados que representam vários métodos, o .NET fornece métodos das classes de delegado <bpt id="p1">[</bpt>Delegate<ept id="p1">](xref:System.Delegate)</ept> e <bpt id="p2">[</bpt>MulticastDelegate<ept id="p2">](xref:System.MulticastDelegate)</ept> para dar suporte a operações como adicionar um método à lista de invocação de um delegado (o método <bpt id="p3">[</bpt>Delegate.Combine<ept id="p3">](xref:System.Delegate.Combine(System.Delegate,System.Delegate))</ept>), remover um método (o método <bpt id="p4">[</bpt>Delegate.Remove<ept id="p4">](xref:System.Delegate.Remove(System.Delegate,System.Delegate))</ept>) e obter a lista de invocação (o método <bpt id="p5">[</bpt>Delegate.GetInvocationList<ept id="p5">](xref:System.Delegate.GetInvocationList)</ept>).</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>It is not necessary to use these methods for event-handler delegates in C# or Visual Basic, because these languages provide syntax for adding and removing event handlers.</source>
          <target state="translated">Não é necessário usar esses métodos para delegados de manipuladores de eventos em C# ou Visual Basic, porque essas linguagens fornecem sintaxe para adicionar e remover manipuladores de eventos.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Type definitions</source>
          <target state="translated">Definições de tipo</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>A type definition includes the following:</source>
          <target state="translated">Uma definição de tipo inclui o seguinte:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Any attributes defined on the type.</source>
          <target state="translated">Qualquer atributo definido no tipo.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The type's accessibility (visibility).</source>
          <target state="translated">A acessibilidade do tipo (visibilidade).</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The type's name.</source>
          <target state="translated">O nome do tipo.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The type's base type.</source>
          <target state="translated">O tipo de base do tipo.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Any interfaces implemented by the type.</source>
          <target state="translated">Qualquer interface implementada pelo tipo.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Definitions for each of the type's members.</source>
          <target state="translated">Definições para cada um dos membros do tipo.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Atributos</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Attributes provide additional user-defined metadata.</source>
          <target state="translated">Atributos fornecem metadados adicionais definidos pelo usuário.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Most commonly, they are used to store additional information about a type in its assembly, or to modify the behavior of a type member in either the design-time or run-time environment.</source>
          <target state="translated">Com frequência, eles são usados para armazenar informações adicionais sobre um tipo em seu assembly ou para modificar o comportamento de um membro de tipo no ambiente do tempo de design ou do tempo de execução.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Attributes are themselves classes that inherit from <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept>.</source>
          <target state="translated">Os atributos são as próprias classes herdadas de <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Languages that support the use of attributes each have their own syntax for applying attributes to a language element.</source>
          <target state="translated">Linguagens que dão suporte ao uso de atributos têm sua própria sintaxe para aplicar atributos a um elemento de linguagem.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Attributes can be applied to almost any language element; the specific elements to which an attribute can be applied are defined by the <bpt id="p1">[</bpt>AttributeUsageAttribute<ept id="p1">](xref:System.AttributeUsageAttribute)</ept> that is applied to that attribute class.</source>
          <target state="translated">Os atributos podem ser aplicados a praticamente qualquer elemento de linguagem. Os elementos específicos para os quais um atributo pode ser aplicado são definidos pelo <bpt id="p1">[</bpt>AttributeUsageAttribute<ept id="p1">](xref:System.AttributeUsageAttribute)</ept> aplicado à classe de atributo.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Type accessibility</source>
          <target state="translated">Acessibilidade de tipo</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>All types have a modifier that governs their accessibility from other types.</source>
          <target state="translated">Todos os tipos têm um modificador que rege sua acessibilidade de outros tipos.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following table describes the type accessibilities supported by the runtime.</source>
          <target state="translated">A tabela a seguir descreve as acessibilidades de tipo que o tempo de execução dá suporte.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Acessibilidade</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>public</source>
          <target state="translated">public</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The type is accessible by all assemblies.</source>
          <target state="translated">O tipo é acessível por todos os assemblies.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>assembly</source>
          <target state="translated">assembly</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The type is accessible only from within its assembly.</source>
          <target state="translated">O tipo é acessível somente dentro do assembly.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The accessibility of a nested type depends on its accessibility domain, which is determined by both the declared accessibility of the member and the accessibility domain of the immediately containing type.</source>
          <target state="translated">A acessibilidade de um tipo aninhado depende do domínio de acessibilidade, que é determinado pela acessibilidade declarada do membro e pelo domínio da acessibilidade do tipo imediatamente contido.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>However, the accessibility domain of a nested type cannot exceed that of the containing type.</source>
          <target state="translated">Entretanto, o domínio de acessibilidade de um tipo aninhado não pode exceder o do tipo contido.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The accessibility domain of a nested member <ph id="ph1">`M`</ph> declared in a type <ph id="ph2">`T`</ph>within a program <ph id="ph3">`P`</ph> is defined as follows (noting that <ph id="ph4">`M`</ph> might itself be a type):</source>
          <target state="translated">O domínio de acessibilidade de um membro aninhado <ph id="ph1">`M`</ph> declarado em um tipo <ph id="ph2">`T`</ph> em um programa <ph id="ph3">`P`</ph> é definido da seguinte forma (observe que <ph id="ph4">`M`</ph> pode ser um tipo):</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`public`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the accessibility domain of <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Se a acessibilidade declarada de <ph id="ph1">`M`</ph> for <ph id="ph2">`public`</ph>, o domínio de acessibilidade de <ph id="ph3">`M`</ph> será o domínio de acessibilidade de <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`protected internal`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the intersection of the accessibility domain of <ph id="ph4">`T`</ph> with the program text of <ph id="ph5">`P`</ph> and the program text of any type derived from <ph id="ph6">`T`</ph> declared outside <ph id="ph7">`P`</ph>.</source>
          <target state="translated">Se a acessibilidade declarada de <ph id="ph1">`M`</ph> for <ph id="ph2">`protected internal`</ph>, o domínio de acessibilidade de <ph id="ph3">`M`</ph> será a interseção do domínio de acessibilidade de <ph id="ph4">`T`</ph> com o texto de programa de <ph id="ph5">`P`</ph> e o texto de programa de qualquer tipo derivado de <ph id="ph6">`T`</ph> declarado fora de <ph id="ph7">`P`</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`protected`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the intersection of the accessibility domain of <ph id="ph4">`T`</ph> with the program text of <ph id="ph5">`T`</ph> and any type derived from <ph id="ph6">`T`</ph>.</source>
          <target state="translated">Se a acessibilidade declarada de <ph id="ph1">`M`</ph> for <ph id="ph2">`protected`</ph>, o domínio de acessibilidade de <ph id="ph3">`M`</ph> será a interseção do domínio de acessibilidade de <ph id="ph4">`T`</ph> com o texto do programa de <ph id="ph5">`T`</ph> e qualquer tipo derivado de <ph id="ph6">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`internal`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the intersection of the accessibility domain of <ph id="ph4">`T`</ph> with the program text of<ph id="ph5">`P`</ph>.</source>
          <target state="translated">Se a acessibilidade declarada de <ph id="ph1">`M`</ph> for <ph id="ph2">`internal`</ph>, o domínio de acessibilidade de <ph id="ph3">`M`</ph> será a interseção do domínio de acessibilidade de <ph id="ph4">`T`</ph> com o texto de programa de <ph id="ph5">`P`</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`private`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the program text of <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Se a acessibilidade declarada de <ph id="ph1">`M`</ph> for <ph id="ph2">`private`</ph>, o domínio de acessibilidade de <ph id="ph3">`M`</ph> será o texto de programa de <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Type names</source>
          <target state="translated">Nomes de tipo</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The common type system imposes only two restrictions on names:</source>
          <target state="translated">O Common Type System impõe apenas duas restrições de nomes:</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>All names are encoded as strings of Unicode (16-bit) characters.</source>
          <target state="translated">Todos os nomes são codificados como cadeias de caracteres Unicode (16 bits).</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Names are not permitted to have an embedded (16-bit) value of 0x0000.</source>
          <target state="translated">Não são permitidos nomes que tenham um valor (16 bits) inserido de 0x0000.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>However, most languages impose additional restrictions on type names.</source>
          <target state="translated">No entanto, a maioria das linguagens impõe restrições adicionais em nomes de tipo.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>All comparisons are done on a byte-by-byte basis, and are therefore case-sensitive and locale-independent.</source>
          <target state="translated">Todas as comparações são feitas em uma base byte por byte e, assim, diferenciam maiúsculas de minúsculas e são independentes de localidade.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Although a type might reference types from other modules and assemblies, a type must be fully defined within one .NET module.</source>
          <target state="translated">Embora um tipo possa referenciar tipos de outros módulos e assemblies, um tipo deve ser totalmente definido em um módulo do .NET.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>(Depending on compiler support, however, it can be divided into multiple source code files.) Type names need be unique only within a namespace.</source>
          <target state="translated">(Dependendo do suporte do compilador, no entanto, ele pode ser dividido em vários arquivos de código-fonte.) Nomes de tipo precisam ser exclusivos somente dentro de um namespace.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>To fully identify a type, the type name must be qualified by the namespace that contains the implementation of the type.</source>
          <target state="translated">Para identificar totalmente um tipo, o nome de tipo deve ser qualificado pelo namespace que contém a implementação do tipo.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Base types and interfaces</source>
          <target state="translated">Tipos de base e interfaces</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>A type can inherit values and behaviors from another type.</source>
          <target state="translated">Um tipo pode herdar valores e comportamentos de outro tipo.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The common type system does not allow types to inherit from more than one base type.</source>
          <target state="translated">O Common Type System não permite que tipos sejam herdados de mais de um tipo de base.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>A type can implement any number of interfaces.</source>
          <target state="translated">Um tipo pode implementar um número qualquer de interfaces.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>To implement an interface, a type must implement all the virtual members of that interface.</source>
          <target state="translated">Para implementar uma interface, um tipo deve implementar todos os membros virtuais dessa interface.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>A virtual method can be implemented by a derived type and can be invoked either statically or dynamically.</source>
          <target state="translated">Um método virtual pode ser implementado por um tipo derivado e pode ser invocado estática ou dinamicamente.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Type members</source>
          <target state="translated">Membros de tipos</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The runtime enables you to define members of your type, which specifies the behavior and state of a type.</source>
          <target state="translated">O tempo de execução permite que você defina os membros do tipo, o que especifica o comportamento e o estado de um tipo.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Type members include the following:</source>
          <target state="translated">Os membros de tipo incluem o seguinte:</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Fields<ept id="p1">](#fields)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Campos<ept id="p1">](#fields)</ept></target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Propriedades<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Methods<ept id="p1">](#methods)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Métodos<ept id="p1">](#methods)</ept></target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Constructors<ept id="p1">](#constructors)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Construtores<ept id="p1">](#constructors)</ept></target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Eventos<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nested types<ept id="p1">](#nested-types)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tipos aninhados<ept id="p1">](#nested-types)</ept></target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Campos</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>A field describes and contains part of the type's state.</source>
          <target state="translated">Um campo descreve e contém parte do estado do tipo.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Fields can be of any type supported by the runtime.</source>
          <target state="translated">Campos podem ser de qualquer tipo com suporte pelo tempo de execução.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Most commonly, fields are either <ph id="ph1">`private`</ph> or <ph id="ph2">`protected`</ph>, so that they are accessible only from within the class or from a derived class.</source>
          <target state="translated">Geralmente, os campos são <ph id="ph1">`private`</ph> ou <ph id="ph2">`protected`</ph>, de forma que são acessíveis somente de dentro da classe ou de uma classe derivada.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>If the value of a field can be modified from outside its type, a property set accessor is typically used.</source>
          <target state="translated">Se o valor de um campo puder ser modificado fora de seu tipo, um acessador do conjunto de propriedades normalmente será usado.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Publicly exposed fields are usually read-only and can be of two types:</source>
          <target state="translated">Os campos expostos publicamente geralmente são somente leitura e podem ser de dois tipos:</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Constants, whose value is assigned at design time.</source>
          <target state="translated">Constantes, cujo valor é atribuído no tempo de design.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>These are static members of a class, although they are not defined using the <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) keyword.</source>
          <target state="translated">Esses são membros estáticos de uma classe, embora eles não sejam definidos usando a palavra-chave <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> no Visual Basic).</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Read-only variables, whose values can be assigned in the class constructor.</source>
          <target state="translated">Variáveis somente leitura, cujos valores podem ser atribuídos no construtor da classe.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The following example illustrates these two usages of read-only fields.</source>
          <target state="translated">O exemplo a seguir ilustra esses dois usos de campos somente leitura.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Propriedades</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>A property names a value or state of the type and defines methods for getting or setting the property's value.</source>
          <target state="translated">Uma propriedade nomeia um valor ou um estado do tipo e define métodos para obter ou definir o valor da propriedade.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Properties can be primitive types, collections of primitive types, user-defined types, or collections of user-defined types.</source>
          <target state="translated">Propriedades podem ser tipos primitivos, coleções de tipos primitivos, tipos definidos pelo usuário ou coleções de tipos definidos pelo usuário.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Properties are often used to keep the public interface of a type independent from the type's actual representation.</source>
          <target state="translated">Propriedades são, frequentemente, usadas para manter a interface pública de um tipo independente da representação real do tipo.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>This enables properties to reflect values that are not directly stored in the class (for example, when a property returns a computed value) or to perform validation before values are assigned to private fields.</source>
          <target state="translated">Isso permite que as propriedades reflitam os valores que não estão armazenados diretamente na classe (por exemplo, quando uma propriedade retorna um valor computado) ou para realizar uma validação antes de os valores serem atribuídos a campos privados.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The following example illustrates the latter pattern.</source>
          <target state="translated">O exemplo a seguir ilustra o padrão mais recente.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>In addition to including the property itself, the Microsoft intermediate language (MSIL) for a type that contains a readable property includes a <ph id="ph1">`get`</ph><bpt id="p1">*</bpt>_propertyname<ept id="p1">*</ept> method, and the MSIL for a type that contains a writable property includes a <ph id="ph2">`set`</ph><bpt id="p2">*</bpt>_propertyname<ept id="p2">*</ept> method.</source>
          <target state="translated">Além de incluir a própria propriedade, a MSIL (Microsoft Intermediate Language) para um tipo que contém uma propriedade legível inclui um método <ph id="ph1">`get`</ph><bpt id="p1">*</bpt>_propertyname<ept id="p1">*</ept> e a MSIL para um tipo que contém uma propriedade gravável inclui um método <ph id="ph2">`set`</ph><bpt id="p2">*</bpt>_propertyname<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Métodos</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>A method describes operations that are available on the type.</source>
          <target state="translated">Um método descreve as operações disponíveis no tipo.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>A method's signature specifies the allowable types of all its parameters and of its return value.</source>
          <target state="translated">A assinatura do método especifica os tipos permitidos de todos seus parâmetros e o valor retornado.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Although most methods define the precise number of parameters required for method calls, some methods support a variable number of parameters.</source>
          <target state="translated">Embora a maioria dos métodos defina o número exato de parâmetros necessários para chamadas de método, alguns métodos dão suporte a um número variável de parâmetros.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The final declared parameter of these methods is marked with the <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> attribute.</source>
          <target state="translated">O parâmetro final declarado desses métodos é marcado com o atributo <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Language compilers typically provide a keyword, such as <ph id="ph1">`params`</ph> in C# and <ph id="ph2">`ParamArray`</ph> in Visual Basic, that makes explicit use of <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> unnecessary.</source>
          <target state="translated">Compiladores de linguagem normalmente fornecem uma palavra-chave, como <ph id="ph1">`params`</ph> no C# e <ph id="ph2">`ParamArray`</ph> no Visual Basic, que tornam o uso explícito de <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> desnecessário.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Construtores</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>A constructor is a special kind of method that creates new instances of a class or structure.</source>
          <target state="translated">Um construtor é um tipo especial de método que cria novas instâncias de uma classe ou estrutura.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Like any other method, a constructor can include parameters; however, constructors have no return value (that is, they return <ph id="ph1">`void`</ph>).</source>
          <target state="translated">Assim como qualquer outro método, um construtor pode incluir parâmetros. No entanto, os construtores não têm nenhum valor retornado (ou seja, eles retornam <ph id="ph1">`void`</ph>).</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>If the source code for a class does not explicitly define a constructor, the compiler includes a default (parameterless) constructor.</source>
          <target state="translated">Se o código-fonte para uma classe não definir explicitamente um construtor, o compilador incluirá um construtor padrão (sem parâmetros).</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>However, if the source code for a class defines only parameterized constructors, the C# compiler doesn't generate a parameterless constructor.</source>
          <target state="translated">No entanto, se o código-fonte de uma classe definir apenas construtores com parâmetros, o compilador do C# não gerará um construtor sem parâmetros.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>If the source code for a structure defines constructors, they must be parameterized; a structure cannot define a default (parameterless) constructor, and compilers do not generate parameterless constructors for structures or other value types.</source>
          <target state="translated">Se o código-fonte de uma estrutura definir construtores, eles deverão ser parametrizados. Uma estrutura não pode definir um construtor padrão (sem parâmetros) e os compiladores não geram construtores sem parâmetros para estruturas ou outros tipos de valor.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>All value types do have an implicit default constructor.</source>
          <target state="translated">Todos os tipos de valor têm um construtor padrão implícito.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>This constructor is implemented by the common language runtime and initializes all fields of the structure to their default values.</source>
          <target state="translated">Esse construtor é implementado pelo Common Language Runtime e inicializa todos os campos da estrutura com seus valores padrão.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Eventos</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>An event defines an incident that can be responded to, and defines methods for subscribing to, unsubscribing from, and raising the event.</source>
          <target state="translated">Um evento define um incidente que pode ser respondido e define métodos para assinar, cancelar a assinatura e acionar o evento.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Events are often used to inform other types of state changes.</source>
          <target state="translated">Eventos são frequentemente usados para informar outros tipos de alterações de estado.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Nested types</source>
          <target state="translated">Tipos aninhados</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>A nested type is a type that is a member of some other type.</source>
          <target state="translated">Um tipo aninhado é um tipo membro de outros tipos.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Nested types should be tightly coupled to their containing type and must not be useful as a general-purpose type.</source>
          <target state="translated">Os tipos aninhados devem ser unidos ao tipo de contenção e não devem ser utilizados como tipos de uso geral.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Nested types are useful when the declaring type uses and creates instances of the nested type, and use of the nested type is not exposed in public members.</source>
          <target state="translated">Os tipos aninhados são úteis quando o tipo declarativo usa e cria instâncias do tipo aninhado e o uso do tipo aninhado não é exposto em membros públicos.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Nested types are confusing to some developers and should not be publicly visible unless there is a compelling reason for visibility.</source>
          <target state="translated">Os tipos aninhados são confusos para alguns desenvolvedores e não devem ficar publicamente visíveis, a menos que haja um motivo forte para a visibilidade.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>In a well-designed library, developers should rarely have to use nested types to instantiate objects or declare variables.</source>
          <target state="translated">Em uma biblioteca bem projetada, os desenvolvedores raramente precisam usar tipos aninhados para instanciar objetos ou declarar variáveis.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Characteristics of type members</source>
          <target state="translated">Características de membros de tipo</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The common type system allows type members to have a variety of characteristics; however, languages are not required to support all these characteristics.</source>
          <target state="translated">O Common Type System permite que os membros de tipo tenham várias características. No entanto, as linguagens não necessariamente dão suporte a todas elas.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following table describes member characteristics.</source>
          <target state="translated">A tabela a seguir descreve as características de um membro.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Characteristic</source>
          <target state="translated">Característica</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Can apply to</source>
          <target state="translated">Pode ser aplicado a</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>abstract</source>
          <target state="translated">abstract</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events</source>
          <target state="translated">Métodos, propriedades e eventos</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The type does not supply the method's implementation.</source>
          <target state="translated">O tipo não fornece a implementação do método.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Types that inherit or implement abstract methods must supply an implementation for the method.</source>
          <target state="translated">Tipos que herdam ou implementam métodos abstratos devem fornecer uma implementação para o método.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The only exception is when the derived type is itself an abstract type.</source>
          <target state="translated">A única exceção é quando o tipo derivado é um tipo abstrato.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>All abstract methods are virtual.</source>
          <target state="translated">Todos os métodos abstratos são virtuais.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>private</source>
          <target state="translated">private</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todos</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Accessible only from within the same type as the member, or within a nested type.</source>
          <target state="translated">Acessível somente dentro do mesmo tipo que o membro ou de um tipo aninhado.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>family</source>
          <target state="translated">família</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todos</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Accessible from within the same type as the member, and from derived types that inherit from it.</source>
          <target state="translated">Acessível dentro do mesmo tipo que o membro e de tipos derivados herdados dele.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>assemby</source>
          <target state="translated">assembly</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todos</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Accessible only in the assembly in which the type is defined.</source>
          <target state="translated">Acessível somente no assembly no qual o tipo é definido.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>family and assembly</source>
          <target state="translated">família e assembly</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todos</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Accessible only from types that qualify for both family and assembly access.</source>
          <target state="translated">Acessíveis somente em tipos qualificados para acesso de família e assembly.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>family or assemby</source>
          <target state="translated">família ou assembly</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todos</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Accessible only from types that qualify for either family or assembly access.</source>
          <target state="translated">Acessíveis somente dentro de tipos qualificados para acesso de família ou assembly.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>public</source>
          <target state="translated">public</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todos</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Accessible from any type.</source>
          <target state="translated">Acessíveis dentro de qualquer tipo.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>final</source>
          <target state="translated">final</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events</source>
          <target state="translated">Métodos, propriedades e eventos</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The virtual method cannot be overridden in a derived type.</source>
          <target state="translated">Um método virtual não pode ser substituído em um tipo derivado.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>initialize-only</source>
          <target state="translated">initialize-only</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Campos</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The value can only be initialized, and cannot be written after initialization.</source>
          <target state="translated">O valor pode apenas ser inicializado e não pode ser gravado após a inicialização.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>instance</source>
          <target state="translated">instância</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Fields, methods, properties, and events</source>
          <target state="translated">Campos, métodos, propriedades e eventos</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>If a member is not marked as <ph id="ph1">`static`</ph> (C#), <ph id="ph2">`Shared`</ph> (Visual Basic), <ph id="ph3">`virtual`</ph> (C#), or <ph id="ph4">`Overridable`</ph> (Visual Basic),  it is an instance member (there is no instance keyword).</source>
          <target state="translated">Se um membro não estiver marcado como <ph id="ph1">`static`</ph> (C#), <ph id="ph2">`Shared`</ph> (Visual Basic), <ph id="ph3">`virtual`</ph> (C#) ou <ph id="ph4">`Overridable`</ph> (Visual Basic), ele será um membro de instância (não há palavra-chave de instância).</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>There will be as many copies of such members in memory as there are objects that use it.</source>
          <target state="translated">Haverá tantas cópias desses membros na memória quanto objetos que as usam.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>literal</source>
          <target state="translated">literal</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Campos</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The value assigned to the field is a fixed value, known at compile time, of a built-in value type.</source>
          <target state="translated">O valor atribuído ao campo é um valor fixo, conhecido no tempo de compilação, de um tipo de valor interno.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Literal fields are sometimes referred to as constants.</source>
          <target state="translated">Às vezes, campos literais são conhecidos como constantes.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>newslot or override</source>
          <target state="translated">newslot ou override</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Todos</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Defines how the member interacts with inherited members that have the same signature: <ph id="ph1">`newslot`</ph> hides inherited members that have the same signature; <ph id="ph2">`override`</ph> replaces the definition of an inherited virtual method.</source>
          <target state="translated">Define como o membro interage com os membros herdados que têm a mesma assinatura: <ph id="ph1">`newslot`</ph> oculta membros herdados que têm a mesma assinatura; <ph id="ph2">`override`</ph> substitui a definição de um método virtual herdado.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The default is newslot.</source>
          <target state="translated">O padrão é newslot.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>static</source>
          <target state="translated">static</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Fields, methods, properties, and events</source>
          <target state="translated">Campos, métodos, propriedades e eventos</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The member belongs to the type it is defined on, not to a particular instance of the type; the member exists even if an instance of the type is not created, and it is shared among all instances of the type.</source>
          <target state="translated">O membro pertence ao tipo no qual está definido e não a uma instância particular do tipo; o membro existirá mesmo se uma instância do tipo não tiver sido criada e será compartilhado entre todas as instâncias do tipo.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>virtual</source>
          <target state="translated">virtual</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events</source>
          <target state="translated">Métodos, propriedades e eventos</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The method can be implemented by a derived type and can be invoked either statically or dynamically.</source>
          <target state="translated">O método pode ser implementado por um tipo derivado e pode ser invocado estática ou dinamicamente.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>If dynamic invocation is used, the type of the instance that makes the call at run time (rather than the type known at compile time) determines which implementation of the method is called.</source>
          <target state="translated">Se a invocação dinâmica for usada, o tipo da instância que faz a chamada no tempo de execução (em vez do tipo conhecido no tempo de compilação) determinará qual implementação do método será chamada.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>To invoke a virtual method statically, the variable might have to be cast to a type that uses the desired version of the method.</source>
          <target state="translated">Para invocar um método virtual estaticamente, a variável precisará ser convertida em um tipo que usa a versão desejada do método.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Sobrecarga</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Each type member has a unique signature.</source>
          <target state="translated">Cada membro de tipo tem uma assinatura exclusiva.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Method signatures consist of the method name and a parameter list (the order and types of the method's arguments).</source>
          <target state="translated">Assinaturas de método consistem no nome de método e em uma lista de parâmetros (a ordem e os tipos dos argumentos do método).</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Multiple methods with the same name can be defined within a type as long as their signatures differ.</source>
          <target state="translated">Os vários métodos com o mesmo nome podem ser definidos em um tipo desde que suas assinaturas sejam diferentes.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>When two or more methods with the same name are defined, the method is said to be overloaded.</source>
          <target state="translated">Quando dois ou mais métodos com o mesmo nome forem definidos, diz-se que o método está sobrecarregado.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>For example, in <bpt id="p1">[</bpt>System.Char<ept id="p1">](xref:System.Char)</ept>, the <ph id="ph1">`IsDigit`</ph> method is overloaded.</source>
          <target state="translated">Por exemplo, em <bpt id="p1">[</bpt>System.Char<ept id="p1">](xref:System.Char)</ept>, o método <ph id="ph1">`IsDigit`</ph> está sobrecarregado.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>One method takes a <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept>.</source>
          <target state="translated">Um método utiliza um <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The other method takes a <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> and an <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>.</source>
          <target state="translated">O outro método utiliza uma <bpt id="p1">[</bpt>Cadeia de Caracteres<ept id="p1">](xref:System.String)</ept> e um <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>The return type is not considered part of a method's signature.</source>
          <target state="translated">O tipo de retorno não é considerado parte da assinatura do método.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>That is, methods cannot be overloaded if they differ only by return type.</source>
          <target state="translated">Ou seja, os métodos não poderão ser sobrecarregados se diferirem somente pelo tipo de retorno.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Inheriting, overriding, and hiding members</source>
          <target state="translated">Herança, substituição e membros ocultos</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A derived type inherits all members of its base type; that is, these members are defined on, and available to, the derived type.</source>
          <target state="translated">Um tipo derivado herda todos os membros de seu tipo de base; ou seja, esses membros são definidos e disponibilizados para o tipo derivado.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>The behavior or qualities of inherited members can be modified in two ways:</source>
          <target state="translated">O comportamento, ou qualidades, de membros herdados pode ser modificado de duas maneiras:</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>A derived type can hide an inherited member by defining a new member with the same signature.</source>
          <target state="translated">Um tipo derivado pode ocultar um membro herdado definindo um novo membro com a mesma assinatura.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>This might be done to make a previously public member private or to define new behavior for an inherited method that is marked as <ph id="ph1">`final`</ph>.</source>
          <target state="translated">Isso pode ser feito para fazer um membro privado anteriormente público ou para definir o novo comportamento de um método herdado marcado como <ph id="ph1">`final`</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>A derived type can override an inherited virtual method.</source>
          <target state="translated">Um tipo derivado pode substituir um método virtual herdado.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The overriding method provides a new definition of the method that will be invoked based on the type of the value at run time rather than the type of the variable known at compile time.</source>
          <target state="translated">O método de substituição fornece uma nova definição do método que será invocado com base no tipo do valor no tempo de execução em vez do tipo de variável conhecido no tempo de compilação.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>A method can override a virtual method only if the virtual method is not marked as <ph id="ph1">`final`</ph> and the new method is at least as accessible as the virtual method.</source>
          <target state="translated">Um método poderá substituir um método virtual somente se o método virtual não estiver marcado como <ph id="ph1">`final`</ph> e o novo método for tão acessível quanto o método virtual.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Consulte também</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type conversion in the .NET Framework<ept id="p1">](type-conversion.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Conversão de tipos no .NET Framework<ept id="p1">](type-conversion.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>