<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">21672e28d0e76b98f6dac698096fccb2ce4edd03</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\options.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e7ed328ee4fc3ad1c060537e6e61b2ccbfdca11</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">23d388f8fdf51663297ee81b7fb936708875c16b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">Opções de expressões regulares</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">Opções de expressões regulares</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">Opções de expressões regulares</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</source>
          <target state="translated">Por padrão, a comparação de uma cadeia de caracteres de entrada com quaisquer caracteres literais em um padrão de expressão regular diferencia maiúsculas e minúsculas; o espaço em branco em um padrão de expressão regular é interpretado como caracteres de espaço em branco literais e os grupos de captura em uma expressão regular são nomeados implícita e explicitamente.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</source>
          <target state="translated">É possível modificar esses e vários outros aspectos do comportamento de expressão regular especificando opções de expressões regulares.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern matching method as a <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> enumeration value.</source>
          <target state="translated">Essas opções, que estão listadas na tabela a seguir, podem ser incluídas embutidas como parte do padrão de expressão regular ou podem ser fornecidas a um construtor de classe <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> ou método de correspondência padrão estático como um valor de enumeração <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>RegexOptions member</source>
          <target state="translated">Membro de RegexOptions</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Inline character</source>
          <target state="translated">Caractere embutido</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Effect</source>
          <target state="translated">Efeito</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Nenhum<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Não disponível</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Use default behavior.</source>
          <target state="translated">Use o comportamento padrão.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Default options<ept id="p1">](#default-options)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Opções padrão<ept id="p1">](#default-options)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>i<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>i<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Use case-insensitive matching.</source>
          <target state="translated">Use correspondência sem diferenciação de maiúsculas e minúsculas.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Case-insensitive matching<ept id="p1">](#case-insensitive-matching)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Correspondência sem diferenciação de maiúsculas e minúsculas<ept id="p1">](#case-insensitive-matching)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Multilinha<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>m<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Use multiline mode, where <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> match the beginning and end of each line (instead of the beginning and end of the input string).</source>
          <target state="translated">Use o modo multilinha, em que <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> e <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> correspondem ao início e o fim de cada linha (em vez do início e o fim da cadeia de caracteres de entrada).</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Multiline mode<ept id="p1">](#multiline-mode)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Modo multilinha<ept id="p1">](#multiline-mode)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Linha única<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>s<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>s<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Use single-line mode, where the period (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) matches every character (instead of every character except <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>).</source>
          <target state="translated">Use o modo de linha única, em que o ponto (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) corresponde a todos os caracteres (em vez de todos os caracteres, exceto <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Single-line mode<ept id="p1">](#single-line-mode)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Modo de linha única<ept id="p1">](#single-line-mode)</ept>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>n<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>n<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Do not capture unnamed groups.</source>
          <target state="translated">Não capture grupos sem nome.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The only valid captures are explicitly named or numbered groups of the form <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</source>
          <target state="translated">As únicas capturas válidas são grupos explicitamente nomeados ou numerados na forma <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Explicit captures only<ept id="p1">](#explicit-captures-only)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Apenas capturas explícitas<ept id="p1">](#explicit-captures-only)</ept>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Compilado<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Não disponível</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Compile the regular expression to an assembly.</source>
          <target state="translated">Compile a expressão regular para um assembly.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Compiled regular expressions<ept id="p1">](#compiled-regular-expressions)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Expressões regulares compiladas<ept id="p1">](#compiled-regular-expressions)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>x<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>x<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Exclude unescaped white space from the pattern, and enable comments after a number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>).</source>
          <target state="translated">Exclua um espaço em branco sem escape do padrão e habilite comentários após uma tecla de cerquilha (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>).</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Ignore white space<ept id="p1">](#ignore-white-space)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Ignorar espaço em branco<ept id="p1">](#ignore-white-space)</ept>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Não disponível</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Change the search direction.</source>
          <target state="translated">Altera a direção da pesquisa.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Search moves from right to left instead of from left to right.</source>
          <target state="translated">A pesquisa se move da direita para a esquerda, em vez de da esquerda para a direita.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Right-to-left mode<ept id="p1">](#right-to-left-mode)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Modo da direita para a esquerda<ept id="p1">](#right-to-left-mode)</ept>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Não disponível</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Enable ECMAScript-compliant behavior for the expression.</source>
          <target state="translated">Habilite o comportamento compatível com ECMAScript para a expressão.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>ECMAScript matching behavior<ept id="p1">](#ecmascript-matching-behavior)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Comportamento de correspondência de ECMAScript<ept id="p1">](#ecmascript-matching-behavior)</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">Não disponível</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Ignore cultural differences in language.</source>
          <target state="translated">Ignorar diferenças culturais no idioma.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Comparison using the invariant culture<ept id="p1">](#comparison-using-the-invariant-culture)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Comparação usando cultura invariável<ept id="p1">](#comparison-using-the-invariant-culture)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Specifying the options</source>
          <target state="translated">Especificando as opções</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You can specify options for regular expressions in one of three ways:</source>
          <target state="translated">É possível especificar opções para expressões regulares de uma destas três maneiras:</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter of a <bpt id="p2">[</bpt>System.Text.RegularExpressions.Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor such as <bpt id="p3">[</bpt>Regex.Regex(String, RegexOptions)<ept id="p3">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions))</ept> or static (Shared in Visual Basic) pattern-matching method, such as  <bpt id="p4">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</source>
          <target state="translated">No parâmetro <bpt id="p1">*</bpt>options<ept id="p1">*</ept> de um construtor da classe <bpt id="p2">[</bpt>System.Text.RegularExpressions.Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> como <bpt id="p3">[</bpt>Regex.Regex(String, RegexOptions)<ept id="p3">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions))</ept> ou método de correspondência de padrão estático (Compartilhado no Visual Basic), como  <bpt id="p4">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter is a bitwise OR combination of <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> enumerated values.</source>
          <target state="translated">O parâmetro <bpt id="p1">*</bpt>options<ept id="p1">*</ept> é uma combinação OR bit a bit de valores enumerados <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>When options are supplied to a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> instance by using the <bpt id="p2">*</bpt>options<ept id="p2">*</ept> parameter of a class constructor, the options are are assigned to the <bpt id="p3">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property.</source>
          <target state="translated">Quando as opções são fornecidas a uma instância <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> mediante uso do parâmetro <bpt id="p2">*</bpt>options<ept id="p2">*</ept> de um construtor de classe, as opções são designadas para a propriedade <bpt id="p3">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>However, the <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property does not reflect inline options in the regular expression pattern itself.</source>
          <target state="translated">No entanto, a propriedade <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> não reflete opções embutidas no próprio padrão de expressão regular.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">O exemplo a seguir fornece uma ilustração.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter of the <bpt id="p2">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">Ele usa o parâmetro <bpt id="p1">*</bpt>options<ept id="p1">*</ept> do método <bpt id="p2">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> para habilitar a correspondência sem diferenciação de maiúsculas e minúsculas e ignorar o espaço em branco do padrão ao identificar palavras que começam com a letra “d”.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>By applying inline options in a regular expression pattern with the syntax <bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept>.</source>
          <target state="translated">Aplicando opções embutidas em um padrão de expressão regular com a sintaxe <bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</source>
          <target state="translated">A opção se aplica ao padrão do ponto em que a opção é definida até o fim do padrão ou o ponto em que a opção tem é indefinida por outra opção embutida.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Note that the <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> instance does not reflect these inline options.</source>
          <target state="translated">Observe que a propriedade <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> de uma instância <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> não reflete essas opções embutidas.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Miscellaneous constructs in regular expressions<ept id="p1">](miscellaneous.md)</ept> topic.</source>
          <target state="translated">Para obter mais informações, consulte o tópico <bpt id="p1">[</bpt>Constructos diversos em expressões regulares<ept id="p1">](miscellaneous.md)</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">O exemplo a seguir fornece uma ilustração.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">Ele usa opções embutidas para habilitar a correspondência sem diferenciação entre maiúsculas e minúsculas e ignorar o espaço em branco do padrão ao identificar palavras que começam com a letra “d”.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>By applying inline options in a particular grouping construct in a regular expression pattern with the syntax <bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">Aplicando opções embutidas em um constructo de agrupamento em particular em um padrão de expressão regular com a sintaxe <bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</source>
          <target state="translated">Nenhum sinal antes de um conjunto de opções ativa o conjunto; um sinal de subtração antes de um conjunto de opções desativa o conjunto.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>(<bpt id="p1">**</bpt>?<ept id="p1">**</ept></source>
          <target state="translated">(<bpt id="p1">**</bpt>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</source>
          <target state="translated">é uma parte fixa da sintaxe do constructo do idioma exigida com as opções habilitadas ou desabilitadas.) A opção se aplica apenas àquele grupo.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Constructos de agrupamento em expressões regulares<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">O exemplo a seguir fornece uma ilustração.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">Ele usa opções embutidas em um constructo de agrupamento para habilitar a correspondência sem diferenciação entre maiúsculas e minúsculas e ignorar espaço em branco do padrão ao identificar palavras que começam com a letra “d”.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>If options are specified inline, a minus sign (-) before an option or set of options turns off those options.</source>
          <target state="translated">Caso as opções sejam especificadas como embutidas, um sinal de subtração (-) antes de uma opção ou conjunto de opções as desativa.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For example, the inline construct <bpt id="p1">**</bpt>(?ix-ms)<ept id="p1">**</ept> turns on the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> and <bpt id="p3">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> options and turns off the <bpt id="p4">[</bpt>RegexOptions.Multiline<ept id="p4">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> and <bpt id="p5">[</bpt>RegexOptions.Singleline<ept id="p5">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> options.</source>
          <target state="translated">Por exemplo, o constructo embutido <bpt id="p1">**</bpt>(?ix-ms)<ept id="p1">**</ept> ativa as opções <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> e <bpt id="p3">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> e desativa as opções <bpt id="p4">[</bpt>RegexOptions.Multiline<ept id="p4">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> e <bpt id="p5">[</bpt>RegexOptions.Singleline<ept id="p5">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>All regular expression options are turned off by default.</source>
          <target state="translated">Todas as opções de expressões regulares são desativadas por padrão.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If the regular expression options specified in the options parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</source>
          <target state="translated">Se as opções de expressões regulares especificadas no parâmetro options de um construtor ou chamada de método entrarem em conflito com as opções especificadas como embutidas em um padrão de expressão regular, serão usadas as opções embutidas.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The following five regular expression options can be set both with the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter and inline:</source>
          <target state="translated">As cinco opções de expressões regulares a seguir podem ser definidas com o parâmetro <bpt id="p1">*</bpt>options<ept id="p1">*</ept> e embutidas:</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The following five regular expression options can be set using the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter but cannot be set inline:</source>
          <target state="translated">As cinco opções de expressões regulares a seguir podem ser definidas usando o parâmetro <bpt id="p1">*</bpt>options<ept id="p1">*</ept>, mas não podem ser definidas como embutidas:</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Determining the options</source>
          <target state="translated">Determinando as opções</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can determine which options were provided to a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object when it was instantiated by retrieving the value of the read-only <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> property.</source>
          <target state="translated">É possível determinar quais opções foram fornecidas a um objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> quando ele tiver sido instanciado recuperando o valor da propriedade <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> somente leitura.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To test for the presence of any option except <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, perform an AND operation with the value of the <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> property and the <bpt id="p3">[</bpt>RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> value in which you are interested.</source>
          <target state="translated">Para testar a presença de qualquer opção, exceto <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, realize uma operação AND com o valor da propriedade <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> e o valor <bpt id="p3">[</bpt>RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> no qual você está interessado.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Then test whether the result equals that <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> value.</source>
          <target state="translated">Em seguida, teste se o resultado é igual ao valor de <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The following example tests whether the <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option has been set.</source>
          <target state="translated">O exemplo a seguir testa se a opção <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> foi definida.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>To test for <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, determine whether the value of the <bpt id="p2">[</bpt>RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property is equal to <bpt id="p3">[</bpt>RegexOptions.None<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, as the following example illustrates.</source>
          <target state="translated">Para testar <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, determine se o valor da propriedade <bpt id="p2">[</bpt>RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> é igual a <bpt id="p3">[</bpt>RegexOptions.None<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following sections list the options supported by regular expression in  .NET.</source>
          <target state="translated">As seções a seguir listam as opções com suporte na expressão regular no .NET.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Default options</source>
          <target state="translated">Opções padrão</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</source>
          <target state="translated">A opção <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> indica que nenhuma opção foi especificada e o mecanismo de expressões regulares usa seu comportamento padrão.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This includes the following:</source>
          <target state="translated">Isso inclui o seguinte:</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</source>
          <target state="translated">O padrão é interpretado como canônico e não como uma expressão regular ECMAScript.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is matched in the input string from left to right.</source>
          <target state="translated">O padrão da expressão regular é combinado na cadeia de caracteres de entrada da esquerda para a direita.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Comparisons are case-sensitive.</source>
          <target state="translated">As comparações diferenciam maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> language elements match the beginning and end of the input string.</source>
          <target state="translated">Os elementos de linguagem <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> e <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> correspondem ao início e o fim da cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>.<ept id="p1">**</ept></source>
          <target state="translated">O elemento de linguagem <bpt id="p1">**</bpt>.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>language element matches every character except <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</source>
          <target state="translated">corresponde a todos os caracteres, exceto <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Any white space in a regular expression pattern is interpreted as a literal space character.</source>
          <target state="translated">Qualquer espaço em branco em um padrão de expressão regular é interpretado como caractere de espaço literal.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The conventions of the current culture are used when comparing the pattern to the input string.</source>
          <target state="translated">As convenções da cultura atual são usadas ao comparar o padrão com a cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Capturing groups in the regular expression pattern are implicit as well as explicit.</source>
          <target state="translated">Os grupos de capturas no padrão de expressão regular são implícitos e explícitos.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option has no inline equivalent.</source>
          <target state="translated">A opção <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> não tem equivalente embutido.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</source>
          <target state="translated">Quando as opções de expressões regulares são embutidas aplicadas, o comportamento padrão é restaurado de modo opção a opção, desativando uma opção em particular.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`(?i)`</ph> turns on case-insensitive comparison, and <ph id="ph2">`(?-i)`</ph> restores the default case-sensitive comparison.</source>
          <target state="translated">Por exemplo, <ph id="ph1">`(?i)`</ph> ativa a comparação sem diferenciar maiúsculas de minúsculas e <ph id="ph2">`(?-i)`</ph> restaura a comparação que diferencia maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</source>
          <target state="translated">Como a opção <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> representa o comportamento padrão do mecanismo de expressões regulares, ela raramente é especificada de forma explícita em uma chamada de método.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>A constructor or static pattern-matching method without an options parameter is called instead.</source>
          <target state="translated">Em vez disso, é chamado um método de construtor ou de correspondência padrão estático sem um parâmetro options.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Case-insensitive matching</source>
          <target state="translated">Correspondência sem diferenciação entre maiúsculas e minúsculas</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option, or the <bpt id="p2">**</bpt>i<ept id="p2">**</ept> inline option, provides case-insensitive matching.</source>
          <target state="translated">A opção <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> ou a opção embutida <bpt id="p2">**</bpt>i<ept id="p2">**</ept> fornecem correspondência sem diferenciação entre maiúsculas e minúsculas.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>By default, the casing conventions of the current culture are used.</source>
          <target state="translated">Por padrão, são usadas as convenções de diferenciação entre maiúsculas e minúsculas da cultura atual.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression pattern, <ph id="ph1">`\bthe\w*\b`</ph>, that matches all words starting with "the".</source>
          <target state="translated">O exemplo a seguir define um padrão de expressão regular, <ph id="ph1">`\bthe\w*\b`</ph>, que corresponde a todas as palavras que começam com “the”.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Because the first call to the Match method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</source>
          <target state="translated">Como a primeira chamada para o método Match usa a comparação que diferencia maiúsculas de minúsculas padrão, a saída indica que a cadeia de caracteres “The”, que inicia a frase, não tem correspondência.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It is matched when the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with options set to <bpt id="p2">[</bpt>IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>.</source>
          <target state="translated">Ela corresponde quando o método <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> é chamado com opções definidas para <bpt id="p2">[</bpt>IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The following example modifies the regular expression pattern from the previous example to use inline options instead of the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter to provide case-insensitive comparison.</source>
          <target state="translated">O exemplo a seguir modifica o padrão da expressão regular do exemplo anterior para usar opções embutidas, em vez do parâmetro <bpt id="p1">*</bpt>options<ept id="p1">*</ept> para fornecer comparação sem diferenciação entre maiúsculas e minúsculas.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</source>
          <target state="translated">O primeiro padrão define a opção que não diferencia maiúsculas de minúsculas em um constructo de agrupamento que se aplica apenas à letra “t” na cadeia de caracteres “the”.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</source>
          <target state="translated">Como o constructo da opção ocorre no início do padrão, o segundo padrão aplica a opção que não diferencia maiúsculas de minúsculas a toda a expressão regular.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Multiline mode</source>
          <target state="translated">Modo multilinha</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, or the <bpt id="p2">**</bpt>m<ept id="p2">**</ept> inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</source>
          <target state="translated">A opção <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> ou a opção embutida <bpt id="p2">**</bpt>m<ept id="p2">**</ept> habilita o mecanismo de expressões regulares para processar uma cadeia de caracteres de entrada que consiste em várias linhas.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It changes the interpretation of the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</source>
          <target state="translated">Altera a interpretação dos elementos de linguagem <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> e <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> para que correspondam ao início e o fim de uma linha, em vez de o início e o fim da cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>By default, <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> matches only the end of the input string.</source>
          <target state="translated">Por padrão, <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> corresponde apenas ao final da cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>If you specify the <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, it matches either the newline character <bpt id="p2">**</bpt>(\n)<ept id="p2">**</ept> or the end of the input string.</source>
          <target state="translated">Se você especificar a opção <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>, ela corresponde ao caractere de nova linha <bpt id="p2">**</bpt>(\n)<ept id="p2">**</ept> ou ao final da cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>It does not, however, match the carriage return/line feed character combination.</source>
          <target state="translated">Porém, não corresponde à combinação de caractere de retorno de carro/avanço de linha.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>To successfully match them, use the subexpression <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> instead of just <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>.</source>
          <target state="translated">Para uma correspondência bem-sucedida, use a subexpressão <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> em vez de apenas <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The following example extracts bowlers names and scores and adds them to a <bpt id="p1">[</bpt>SortedList<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.SortedList%602)</ept> collection that sorts them in descending order.</source>
          <target state="translated">O exemplo a seguir extrai nomes e pontuações de jogadores de boliche e os adiciona a uma coleção <bpt id="p1">[</bpt>SortedList<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.SortedList%602)</ept>, que os classifica em ordem decrescente.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> method is called twice.</source>
          <target state="translated">O método <bpt id="p1">[</bpt>Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> é chamado duas vezes.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>In the first method call, the regular expression is <ph id="ph1">`^(\w+)\s(\d+)$`</ph> and no options are set.</source>
          <target state="translated">Na primeira chamada do método, a expressão regular é <ph id="ph1">`^(\w+)\s(\d+)$`</ph> e nenhuma opção é definida.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</source>
          <target state="translated">Como a saída mostra, uma vez que o mecanismo de expressões regulares não pode corresponder ao padrão de entrada junto com o início e o fim da cadeia de caracteres de entrada, nenhuma correspondência é encontrada.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>In the second method call, the regular expression is changed to <ph id="ph1">`^(\w+)\s(\d+)\r?$`</ph> and the options are set to <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</source>
          <target state="translated">Na segunda chamada do método, a expressão regular é alterada para <ph id="ph1">`^(\w+)\s(\d+)\r?$`</ph> e as opções são definidas como <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</source>
          <target state="translated">Como a saída mostra, os nomes e pontuações são combinados com sucesso e as pontuações são exibidas em ordem decrescente.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^(\w+)\s(\d+)\r*$`</ph> is defined as shown in the following table.</source>
          <target state="translated">O padrão de expressão regular <ph id="ph1">`^(\w+)\s(\d+)\r*$`</ph> é definido conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Begin at the start of the line.</source>
          <target state="translated">Começar no início da linha.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Fazer a correspondência a um ou mais caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Este é o primeiro grupo de captura.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Corresponde a um caractere de espaço em branco.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Corresponde a um ou mais dígitos decimais.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">Este é o segundo grupo de captura.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Match zero or one carriage return character.</source>
          <target state="translated">Corresponder a zero ou um caractere de retorno de carro.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>End at the end of the line.</source>
          <target state="translated">Terminar no fim da linha.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous one, except that it uses the inline option <bpt id="p1">**</bpt>(?m)<ept id="p1">**</ept> to set the multiline option.</source>
          <target state="translated">O exemplo a seguir é equivalente ao anterior, exceto pelo fato de usar a opção embutida <bpt id="p1">**</bpt>(?m)<ept id="p1">**</ept> para definir a opção de multilinha.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Single-line mode</source>
          <target state="translated">Modo de linha única</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option, or the s inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</source>
          <target state="translated">A opção <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> ou a opção embutida s, faz o mecanismo de expressões regulares tratar a cadeia de caracteres de entrada como se consistisse em uma única linha.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>It does this by changing the behavior of the period (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) language element so that it matches every character, instead of matching every character except for the newline character <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> or \u000A.</source>
          <target state="translated">Isso é feito mudando o comportamento do elemento de linguagem de ponto (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) para que corresponda a todos os caracteres, em vez de corresponder a todo caractere exceto o caractere de nova linha <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> ou \u000A.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The following example illustrates how the behavior of the .</source>
          <target state="translated">O exemplo a seguir ilustra como o comportamento do .</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>language element changes when you use the <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option.</source>
          <target state="translated">elemento de linguagem muda quando se usa a opção <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^.+`</ph> starts at the beginning of the string and matches every character.</source>
          <target state="translated">A expressão regular <ph id="ph1">`^.+`</ph> começa no início da cadeia de caracteres e corresponde a todos os caracteres.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, <bpt id="p1">**</bpt>\r<ept id="p1">**</ept> or \u000D, but it does not match <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</source>
          <target state="translated">Por padrão, a correspondência termina no final da primeira linha; o padrão de expressão regular corresponde ao caractere de retorno de carro, <bpt id="p1">**</bpt>\r<ept id="p1">**</ept> ou \u000D, mas não corresponde a <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option interprets the entire input string as a single line, it matches every character in the input string, including <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</source>
          <target state="translated">Como a opção <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> interpreta toda a cadeia de caracteres de entrada como uma única linha; ela corresponde a cada caractere na cadeia de caracteres de entrada, incluindo <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous one, except that it uses the inline option <bpt id="p1">**</bpt>(?s)<ept id="p1">**</ept> to enable single-line mode.</source>
          <target state="translated">O exemplo a seguir é equivalente ao anterior, exceto por usar a opção embutida <bpt id="p1">**</bpt>(?s)<ept id="p1">**</ept> para habilitar o modo de linha única.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Explicit captures only</source>
          <target state="translated">Apenas capturas explícitas</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</source>
          <target state="translated">Por padrão, grupos de capturas são definidos pelo uso de parênteses no padrão de expressão regular.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Named groups are assigned a name or number by the <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> language option, whereas unnamed groups are accessible by index.</source>
          <target state="translated">Grupos nomeados recebem um nome ou número pela opção de linguagem <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>, enquanto grupos não nomeados são acessíveis por índice.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object, unnamed groups precede named groups.</source>
          <target state="translated">No objeto <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept>, grupos não nomeados antecedem grupos nomeados.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</source>
          <target state="translated">Constructos de agrupamento costumam ser usados apenas para aplicar quantificadores a vários elementos de linguagem; as subcadeias de caracteres capturadas não são de interesse.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>For example, if the following regular expression:</source>
          <target state="translated">Por exemplo, se a seguinte expressão regular:</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> object) is of interest.</source>
          <target state="translated">for feita somente para extrair frases que terminem com um ponto, ponto de exclamação ou ponto de interrogação de um documento, apenas a frase resultante (representada pelo objeto <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept>) é de interesse.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The individual words in the collection are not.</source>
          <target state="translated">As palavras individuais na coleção não são.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collection objects.</source>
          <target state="translated">Capturar grupos que não serão usados posteriormente pode ser caro, pois o mecanismo de expressões regulares precisa preencher os objetos de coleção <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> e <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>As an alternative, you can use either the <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option or the <bpt id="p2">**</bpt>n<ept id="p2">**</ept> inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the <bpt id="p3">**</bpt>(?&lt;<ept id="p3">**</ept><bpt id="p4">_</bpt>name<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">&gt;</ph><ept id="p5">**</ept> <bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept> construct.</source>
          <target state="translated">Como alternativa, você pode usar a opção <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> ou a opção embutida <bpt id="p2">**</bpt>n<ept id="p2">**</ept> para especificar que apenas as capturas válidas são explicitamente nomeadas ou grupos numerados que são designados pelo constructo <bpt id="p3">**</bpt>(?&lt;<ept id="p3">**</ept><bpt id="p4">_</bpt>name<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">&gt;</ph><ept id="p5">**</ept> <bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The following example displays information about the matches returned by the <ph id="ph1">`\b\(?((\w+),?\s?)+[\.!?]\)?`</ph> regular expression pattern when the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept> method is called with and without the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">O exemplo a seguir exibe informações sobre as correspondências retornadas pelo padrão de expressão regular <ph id="ph1">`\b\(?((\w+),?\s?)+[\.!?]\)?`</ph> quando o método <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept> é chamado com e sem a opção <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>As the output from the first method call shows, the regular expression engine fully populates the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collection objects with information about captured substrings.</source>
          <target state="translated">Como mostra a saída da chamada do primeiro método, o mecanismo de expressões regulares preenche totalmente os objetos da coleção <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> e <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> com informações sobre subcadeias de caracteres capturadas.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Because the second method is called with options set to <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>, it does not capture information on groups.</source>
          <target state="translated">Como o segundo método é chamado com as opções definidas como <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>, ele não captura informações sobre grupos.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b\(?((?&gt;\w+),?\s?)+[\.!?]\)?`</ph> is defined as shown in the following table.</source>
          <target state="translated">O padrão de expressão regular <ph id="ph1">`\b\(?((?&gt;\w+),?\s?)+[\.!?]\)?`</ph> é definido conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Begin at a word boundary.</source>
          <target state="translated">Começar em um limite de palavra.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrences of the opening parenthesis ("(").</source>
          <target state="translated">Corresponder zero ou uma ocorrência do parêntese de abertura (“(“).</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Match one or more word characters, followed by zero or one commas.</source>
          <target state="translated">Corresponder um ou mais caracteres de palavra seguidos por zero ou uma vírgula.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Do not backtrack when matching word characters.</source>
          <target state="translated">Não retroceda ao corresponder caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space characters.</source>
          <target state="translated">Corresponder a zero ou a um caractere de espaço em branco.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</source>
          <target state="translated">Corresponder a combinação de um ou mais caracteres de palavra, zero ou mais vírgulas e zero ou um caractere de espaço em branco uma ou mais vezes.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</source>
          <target state="translated">Corresponder qualquer um dos três símbolos de pontuação seguidos por zero ou um parêntese de fechamento (“)”).</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>You can also use the <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> inline element to suppress automatic captures.</source>
          <target state="translated">Você também pode usar o elemento embutido <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> para suprimir capturas automáticas.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous regular expression pattern to use the <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> inline element instead of the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">O exemplo a seguir modifica o padrão de expressão regular anterior para usar o elemento embutido <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> em vez da opção <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Finally, you can use the inline group element <bpt id="p1">**</bpt>(?n:)<ept id="p1">**</ept> to suppress automatic captures on a group-by-group basis.</source>
          <target state="translated">Por fim, é possível usar o elemento do grupo embutido <bpt id="p1">**</bpt>(?n:)<ept id="p1">**</ept> para suprimir capturas automáticas de forma grupo a grupo.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous pattern to suppress unnamed captures in the outer group, <ph id="ph1">`((?&gt;\w+),?\s?)`</ph>.</source>
          <target state="translated">O exemplo a seguir modifica o padrão anterior para suprimir capturas sem nome no grupo externo, <ph id="ph1">`((?&gt;\w+),?\s?)`</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Note that this suppresses unnamed captures in the inner group as well.</source>
          <target state="translated">Observe que isso também suprime capturas sem nome no grupo interno.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Compiled regular expressions</source>
          <target state="translated">Expressões regulares compiladas</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>By default, regular expressions in .NET are interpreted.</source>
          <target state="translated">Por padrão, as expressões regulares no .NET são interpretadas.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>When a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated or a static <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</source>
          <target state="translated">Quando um objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> é instanciado ou um método <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> estático é chamado, o padrão de expressão regular é analisado em um conjunto de opcodes personalizados e um interpretador usa esses opcodes para executar a expressão regular.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</source>
          <target state="translated">Isso envolve uma troca: o custo de inicializar o mecanismo de expressões regulares é minimizado com prejuízo do desempenho do tempo de execução.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You can use compiled instead of interpreted regular expressions by using the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option.</source>
          <target state="translated">Você pode usar expressões regulares compiladas, em vez de interpretadas, usando a opção <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</source>
          <target state="translated">Neste caso, quando um padrão é enviado ao mecanismo de expressões regulares, ele é analisado em um subconjunto de opcodes e convertido para a MSIL (linguagem intermediária da Microsoft), que pode ser enviada diretamente ao Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Compiled regular expressions maximize run-time performance at the expense of initialization time.</source>
          <target state="translated">Expressões regulares compiladas maximizam o desempenho do tempo de execução às custas do tempo de inicialização.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>A regular expression can be compiled only by supplying the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or a static pattern-matching method.</source>
          <target state="translated">Uma expressão regular só pode ser compilada fornecendo o valor <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> ao parâmetro options de um construtor de classe <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> ou um método de correspondência padrão estático.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">Não está disponível como uma opção embutida.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>You can use compiled regular expressions in calls to both static and instance regular expressions.</source>
          <target state="translated">É possível usar expressões regulares compiladas em chamadas para expressões regulares estáticas e de instância.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>In static regular expressions, the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option is passed to the options parameter of the regular expression pattern-matching method.</source>
          <target state="translated">Em expressões regulares estáticas, a opção <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> é enviada ao parâmetro options do método de correspondência padrão de expressão regular.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>In instance regular expressions, it is passed to the options parameter of the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor.</source>
          <target state="translated">Em expressões regulares de instância, é enviada ao parâmetro options do construtor de classe <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>In both cases, it results in enhanced performance.</source>
          <target state="translated">Em ambos os casos, resulta em melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>However, this improvement in performance occurs only under the following conditions:</source>
          <target state="translated">Porém, essa melhoria de desempenho ocorre apenas sob as seguintes condições:</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</source>
          <target state="translated">É usado um objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> que representa uma expressão regular em particular, em várias chamadas para métodos de correspondência padrão de expressão regular.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is not allowed to go out of scope, so it can be reused.</source>
          <target state="translated">O objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> não pode sair do escopo, então pode ser reutilizado.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>A static regular expression is used in multiple calls to regular expression pattern-matching methods.</source>
          <target state="translated">Uma expressão regular estática é usada em várias chamadas para métodos de correspondência padrão de expressão regular.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</source>
          <target state="translated">(A melhoria de desempenho é possível porque as expressões regulares usadas em chamadas de método estático são armazenadas em cache pelo mecanismo de expressões regulares.)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Ignore white space</source>
          <target state="translated">Ignorar espaço em branco</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</source>
          <target state="translated">Por padrão, o espaço em branco em um padrão de expressão regular é significativo; ele força o mecanismo de expressões regulares para combinar um caractere de espaço em branco na cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Because of this, the regular expression <ph id="ph1">`"\b\w+\s"`</ph> and <ph id="ph2">`"\b\w+ "`</ph> are roughly equivalent regular expressions.</source>
          <target state="translated">Devido a isso, as expressões regulares <ph id="ph1">`"\b\w+\s"`</ph> e <ph id="ph2">`"\b\w+ "`</ph> são, de um modo geral, equivalentes.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>In addition, when the number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</source>
          <target state="translated">Além disso, quando a tecla de cerquilha (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) é encontrada em um padrão de expressão regular, ela é interpretada como um caractere literal a ser combinado.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option, or the <bpt id="p2">**</bpt>x<ept id="p2">**</ept> inline option, changes this default behavior as follows:</source>
          <target state="translated">A opção <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> ou a opção embutida <bpt id="p2">**</bpt>x<ept id="p2">**</ept>, altera esse comportamento padrão da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Unescaped white space in the regular expression pattern is ignored.</source>
          <target state="translated">É ignorado o espaço em branco sem escape no padrão de expressão regular.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>To be part of a regular expression pattern, white-space characters must be escaped (for example, as <bpt id="p1">**</bpt>\s<ept id="p1">**</ept> or "*<bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept> ").</source>
          <target state="translated">Para fazer parte de um padrão de expressão regular, os caracteres de espaço em branco devem ter escape (por exemplo, como <bpt id="p1">**</bpt>\s<ept id="p1">**</ept> ou “*<bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept> ”).</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) is interpreted as the beginning of a comment, rather than as a literal character.</source>
          <target state="translated">A tecla de cerquilha (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) é interpretada como o início de um comentário, em vez de um caractere literal.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>All text in the regular expression pattern from the <bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept> character to the end of the string is interpreted as a comment.</source>
          <target state="translated">Todo o texto no padrão de expressão regular do caractere <bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept> até o fim da cadeia de caracteres é interpretado como comentário.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>However, in the following cases, white space characters in a regular expression aren't ignored, even if you use the <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option:</source>
          <target state="translated">Porém, nos seguintes casos, os caracteres de espaço em branco em uma expressão regular não são ignorados, mesmo se você usar a opção <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept>:</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>White space within a character class is always interpreted literally.</source>
          <target state="translated">O espaço em branco dentro de uma classe de caractere sempre é interpretado literalmente.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`[ .,;:]`</ph> matches any single white-space character, period, comma, semicolon, or colon.</source>
          <target state="translated">Por exemplo, o padrão da expressão regular <ph id="ph1">`[ .,;:]`</ph> corresponde a qualquer caractere de espaço em branco, ponto, vírgula, dois pontos ou ponto e vírgula único.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>White space isn't allowed within a bracketed quantifier, such as <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,}<ept id="p6">**</ept>, and <bpt id="p7">**</bpt>{<ept id="p7">**</ept><bpt id="p8">_</bpt>n<ept id="p8">_</ept><bpt id="p9">**</bpt>,<ept id="p9">**</ept><bpt id="p10">_</bpt>m<ept id="p10">_</ept><bpt id="p11">**</bpt>}<ept id="p11">**</ept>.</source>
          <target state="translated">Espaço em branco não é permitido dentro de um quantificador entre colchetes, como <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,}<ept id="p6">**</ept> e <bpt id="p7">**</bpt>{<ept id="p7">**</ept><bpt id="p8">_</bpt>n<ept id="p8">_</ept><bpt id="p9">**</bpt>,<ept id="p9">**</ept><bpt id="p10">_</bpt>m<ept id="p10">_</ept><bpt id="p11">**</bpt>}<ept id="p11">**</ept>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <bpt id="p1">**</bpt>\d{1. 3}<ept id="p1">**</ept> fails to match any sequences of digits from one to three digits because it contains a white-space character.</source>
          <target state="translated">Por exemplo, o padrão de expressão regular <bpt id="p1">**</bpt>\d{1. 3}<ept id="p1">**</ept> falha ao corresponder quaisquer sequências de dígitos de um a três dígitos porque contém um caractere de espaço em branco.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>White space isn't allowed within a character sequence that introduces a language element.</source>
          <target state="translated">Não é permitido espaço em branco dentro da sequência de caracteres que introduz um elemento de linguagem.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por exemplo:</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The language element <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> represents a noncapturing group, and the <bpt id="p4">**</bpt>(?:<ept id="p4">**</ept> portion of the element can't have embedded spaces.</source>
          <target state="translated">O elemento de linguagem <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> representa um grupo sem captura; a parte <bpt id="p4">**</bpt>(?:<ept id="p4">**</ept> do elemento não pode ter espaços inseridos.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The pattern <bpt id="p1">**</bpt>(? :<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> throws an <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept> at run time because the regular expression engine can't parse the pattern, and the pattern <bpt id="p5">**</bpt>(? :<ept id="p5">**</ept><bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept>  fails to match <bpt id="p8">*</bpt>subexpression<ept id="p8">*</ept>.</source>
          <target state="translated">O padrão <bpt id="p1">**</bpt>(? :<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> lança uma <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept> no tempo de execução porque o mecanismo de expressões regulares não consegue analisar o padrão; o padrão <bpt id="p5">**</bpt>(? :<ept id="p5">**</ept><bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept> não consegue corresponder a <bpt id="p8">*</bpt>subexpression<ept id="p8">*</ept>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The language element <bpt id="p1">**</bpt>\p{<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, which represents a Unicode category or named block, can't include embedded spaces in the <bpt id="p4">**</bpt>\p{<ept id="p4">**</ept> portion of the element.</source>
          <target state="translated">O elemento de linguagem <bpt id="p1">**</bpt>\p{<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, que representa uma categoria Unicode ou um bloco nomeado, não pode incluir espaços embutidos na parte <bpt id="p4">**</bpt>\p{<ept id="p4">**</ept> do elemento.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>If you do include a white space, the element throws an <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept> at run time.</source>
          <target state="translated">Se você incluir um espaço em branco, o elemento lança uma <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept> no tempo de execução.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</source>
          <target state="translated">Habilitar essa opção ajuda a simplificar expressões regulares que costumam ser difíceis de analisar e entender.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>It improves readability, and makes it possible to document a regular expression.</source>
          <target state="translated">Melhora a legibilidade e torna possível documentar uma expressão regular.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The following example defines the following regular expression pattern:</source>
          <target state="translated">O exemplo a seguir define o padrão de expressão regular a seguir:</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\b \(? ( (?&gt;\w+) ,?\s? )+ [\.!?] \)? # Matches an entire sentence`</ph>.</source>
          <target state="translated"><ph id="ph1">`\b \(? ( (?&gt;\w+) ,?\s? )+ [\.!?] \)? # Matches an entire sentence`</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>This pattern is similar to the pattern defined in the <bpt id="p1">[</bpt>Explicit captures only<ept id="p1">](#explicit-captures-only)</ept> section, except that it uses the <bpt id="p2">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option to ignore pattern white space.</source>
          <target state="translated">Esse padrão é similar ao padrão definido na seção <bpt id="p1">[</bpt>Apenas capturas explícitas<ept id="p1">](#explicit-captures-only)</ept>, exceto por usar a opção <bpt id="p2">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> para ignorar o espaço em branco padrão.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following example uses the inline option <bpt id="p1">**</bpt>(?x)<ept id="p1">**</ept> to ignore pattern white space.</source>
          <target state="translated">O exemplo a seguir usa a opção embutida <bpt id="p1">**</bpt>(?x)<ept id="p1">**</ept> para ignorar o espaço em branco padrão.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Right-to-left mode</source>
          <target state="translated">Modo da direita para a esquerda</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine searches from left to right.</source>
          <target state="translated">Por padrão, o mecanismo de expressões regulares pesquisa da esquerda para a direita.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>You can reverse the search direction by using the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option.</source>
          <target state="translated">É possível reverter a direção de pesquisa usando a opção <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The search automatically begins at the last character position of the string.</source>
          <target state="translated">A pesquisa inicia automaticamente na última posição de caractere da cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>For pattern-matching methods that include a starting position parameter, such as <bpt id="p1">[</bpt>Regex.Match(String, Int32)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept>, the starting position is the index of the rightmost character position at which the search is to begin.</source>
          <target state="translated">Para métodos de correspondência padrão que incluem um parâmetro de posição inicial, como <bpt id="p1">[</bpt>Regex.Match(String, Int32)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept>, a posição inicial é o índice da posição do caractere mais à direita em que a pesquisa deve iniciar.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Right-to-left pattern mode is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">O modo de padrão da direita para a esquerda está disponível apenas fornecendo o valor <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> para o parâmetro options de um construtor de classe <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> ou o método de correspondência padrão estático.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">Não está disponível como uma opção embutida.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</source>
          <target state="translated">A opção <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> só muda a direção de pesquisa; ela não interpreta o padrão de expressão regular da direita para a esquerda.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\bb\w+\s`</ph> matches words that begin with the letter "b" and are followed by a white-space character.</source>
          <target state="translated">Por exemplo, a expressão regular <ph id="ph1">`\bb\w+\s`</ph> corresponde palavras que começam com a letra “b” e são seguidas por um caractere de espaço em branco.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>In the following example, the input string consists of three words that include one or more "b" characters.</source>
          <target state="translated">No exemplo a seguir, a cadeia de caracteres de entrada consiste em três palavras que incluem um ou mais caracteres “b”.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</source>
          <target state="translated">A primeira palavra começa com “b”, a segunda termina com “b” e a terceira inclui dois caracteres “b” no meio da palavra.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, only the first word matches the regular expression pattern.</source>
          <target state="translated">Como a saída do exemplo mostra, apenas a primeira palavra corresponde ao padrão da expressão regular.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Also note that the lookahead assertion (the <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element) and the lookbehind assertion (the <bpt id="p4">**</bpt>(?&lt;<ept id="p4">**</ept><ph id="ph2">=</ph><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> language element) do not change direction.</source>
          <target state="translated">Observe também que a asserção lookahead (o elemento de linguagem <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> e a asserção lookbehind (o elemento de linguagem <bpt id="p4">**</bpt>(?&lt;<ept id="p4">**</ept><ph id="ph2">=</ph><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> não mudam de direção.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The lookahead assertions look to the right; the lookbehind assertions look to the left.</source>
          <target state="translated">As asserções lookahead buscam à direita; as asserções lookbehind buscam à esquerda.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`(?&lt;=\d{1,2}\s)\w+,?\s\d{4}`</ph> uses the lookbehind assertion to test for a date that precedes a month name.</source>
          <target state="translated">Por exemplo, a expressão regular <ph id="ph1">`(?&lt;=\d{1,2}\s)\w+,?\s\d{4}`</ph> usa a asserção lookbehind para testar uma data que antecede um nome de mês.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The regular expression then matches the month and the year.</source>
          <target state="translated">A expressão regular corresponde ao mês e o ano.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>For information on lookahead and lookbehind assertsions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Para obter informações sobre as asserções lookahead e lookbehind, consulte <bpt id="p1">[</bpt>Constructos de agrupamento em expressões regulares<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">O padrão de expressão regular é definido como mostra a tabela a seguir.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The beginning of the match must be preceded by one or two decimal digits followed by a space.</source>
          <target state="translated">O início da correspondência deve ser antecedido por um ou dois dígitos decimais seguidos por um espaço.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Fazer a correspondência a um ou mais caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Match zero or one comma characters.</source>
          <target state="translated">Corresponder a zero ou um caractere de vírgula.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Corresponde a um caractere de espaço em branco.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Match four decimal digits.</source>
          <target state="translated">Corresponder a quatro dígitos decimais.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>ECMAScript matching behavior</source>
          <target state="translated">Comportamento de correspondência de ECMAScript</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</source>
          <target state="translated">Por padrão, o mecanismo de expressões regulares usa comportamento canônico ao corresponder um padrão de expressão regular a um texto de entrada.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> option.</source>
          <target state="translated">Porém, é possível instruir o mecanismo de expressões regulares a usar o comportamento de correspondência ECMAScript especificando a opção <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>ECMAScript-compliant behavior is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">O comportamento compatível com ECMAScript está disponível apenas fornecendo o valor <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> para o parâmetro options de um construtor de classe <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> ou método de correspondência padrão estático.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">Não está disponível como uma opção embutida.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> option can be combined only with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> and <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> options.</source>
          <target state="translated">A opção <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> pode ser combinada apenas com as opções <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> e <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>The use of any other option in a regular expression results in an <bpt id="p1">[</bpt>ArgumentOutOfRangeException<ept id="p1">](xref:System.ArgumentOutOfRangeException)</ept>.</source>
          <target state="translated">O uso de qualquer outra opção em uma expressão regular resulta em uma <bpt id="p1">[</bpt>ArgumentOutOfRangeException<ept id="p1">](xref:System.ArgumentOutOfRangeException)</ept>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</source>
          <target state="translated">O comportamento das expressões regulares ECMAScript e canônicas difere em três áreas: sintaxe da classe de caractere, grupos de captura autorreferidos e interpretação octal versus de referência inversa.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Character class syntax.</source>
          <target state="translated">Sintaxe da classe de caractere.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</source>
          <target state="translated">Como as expressões regulares canônicas dão suporte a Unicode e o ECMAScrip não, as classes de caractere no ECMAScrip têm uma sintaxe mais limitada e alguns elementos de linguagem da classe de caractere têm um significado diferente.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>For example, ECMAScript does not support language elements such as the Unicode category or block elements <bpt id="p1">*</bpt>\p<ept id="p1">*</ept> and <bpt id="p2">**</bpt>\P<ept id="p2">**</ept>.</source>
          <target state="translated">Por exemplo, o ECMAScript não dá suporte a elementos de linguagem como a categoria Unicode ou elementos de bloco <bpt id="p1">*</bpt>\p<ept id="p1">*</ept> e <bpt id="p2">**</bpt>\P<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Similarly, the <bpt id="p1">**</bpt>\w<ept id="p1">**</ept> element, which matches a word character, is equivalent to the <bpt id="p2">**</bpt>[a-zA-Z_0-9]<ept id="p2">**</ept> character class when using ECMAScript and <bpt id="p3">**</bpt>[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]<ept id="p3">**</ept> when using canonical behavior.</source>
          <target state="translated">De modo similar, o elemento <bpt id="p1">**</bpt>\w<ept id="p1">**</ept>, que corresponde um caractere de palavra, é equivalente à classe de caractere <bpt id="p2">**</bpt>[a-zA-Z_0-9]<ept id="p2">**</ept> ao usar ECMAScript e <bpt id="p3">**</bpt>[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]<ept id="p3">**</ept> ao usar comportamento canônico.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Character classes in regular expressions<ept id="p1">](classes.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Classes de caracteres em expressões regulares<ept id="p1">](classes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between canonical and ECMAScript pattern matching.</source>
          <target state="translated">O exemplo a seguir ilustra a diferença entre correspondência padrão ECMAScript e canônica.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>It defines a regular expression, <ph id="ph1">`\b(\w+\s*)+`</ph>, that matches words followed by white-space characters.</source>
          <target state="translated">Define uma expressão regular, <ph id="ph1">`\b(\w+\s*)+`</ph>, que combina palavras seguidas por caracteres de espaço em branco.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</source>
          <target state="translated">A entrada consiste em duas cadeias de caracteres, uma que usa o conjunto de caracteres latinos e outra que usa o conjunto de caracteres cirílicos.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>As the output shows, the call to the <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</source>
          <target state="translated">Como a saída mostra, a chamada para o método <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> que usa correspondência ECMAScript falha ao combinar as palavras cirílicas, enquanto a chamada de método que usa correspondência canônica corresponde a essas palavras.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Self-referencing capturing groups.</source>
          <target state="translated">Grupos de capturas com autorreferência.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>A regular expression capture class with a backreference to itself must be updated with each capture iteration.</source>
          <target state="translated">Uma classe de captura de expressão regular com uma referência inversa para si mesma deve ser atualizada com cada iteração de captura.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>As the following example shows, this feature enables the regular expression <ph id="ph1">`((a+)(\1) ?)+`</ph> to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</source>
          <target state="translated">Como o exemplo a seguir mostra, esse recurso habilita a expressão regular <ph id="ph1">`((a+)(\1) ?)+`</ph> para corresponder a cadeia de caracteres de entrada “ aa aaaa aaaaaa ” ao usar ECMAScript, mas não ao usar correspondência canônica.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>For more information about string comparisons that are case-sensitive and that use the invariant culture, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](best-practices.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre comparações de cadeias de caracteres que diferenciam maiúsculas de minúsculas e usam cultura invariável, consulte <bpt id="p1">[</bpt>Práticas recomendadas para o uso de cadeias de caracteres<ept id="p1">](best-practices.md)</ept>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Instead of using the case-insensitive comparisons of the current culture, you can specify the <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> option to ignore cultural differences in language and to use the conventions of the invariant culture.</source>
          <target state="translated">Em vez de usar comparações que não diferenciam maiúsculas de minúsculas da cultura atual, é possível especificar a opção <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> para ignorar diferenças culturais no idioma e usar as convenções da cultura invariável.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Comparison using the invariant culture is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">A comparação usando cultura invariável está disponível apenas fornecendo o valor <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> para o parâmetro options de um construtor de classe <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> ou método de correspondência padrão estático.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">Não está disponível como uma opção embutida.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The following example is identical to the previous example, except that the static <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with options that include <bpt id="p2">[</bpt>RegexOptions.CultureInvariant<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept>.</source>
          <target state="translated">O exemplo a seguir é idêntico ao anterior, exceto pelo fato de o método estático <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> ser chamado com opções que incluem <bpt id="p2">[</bpt>RegexOptions.CultureInvariant<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</source>
          <target state="translated">Mesmo quando a cultura atual é definida como turco (Turquia), o mecanismo de expressões regulares consegue corresponder com sucesso “FILE” e “file” e bloquear o acesso ao recurso do arquivo.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Consulte também</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Linguagem de expressão regular – referência rápida<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>