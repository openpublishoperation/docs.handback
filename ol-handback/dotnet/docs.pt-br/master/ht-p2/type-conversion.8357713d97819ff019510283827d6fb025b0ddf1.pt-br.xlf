<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ba4a356921cb43b88d3ad8e6ef7487699f442385</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\type-conversion.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df8bad09de4109d5c7593cc8eb9155894e15738d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fa96a35131a4ba48f37ac78c13b46e5a9d5690f6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Type conversion</source>
          <target state="translated">Conversão de tipos</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Type conversion</source>
          <target state="translated">Conversão de tipos</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Type conversion</source>
          <target state="translated">Conversão de tipos</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Every value has an associated type, which defines attributes such as the amount of space allocated to the value, the range of possible values it can have, and the members that it makes available.</source>
          <target state="translated">Cada valor tem um tipo associado, o qual define atributos como a quantidade de espaço alocado para o valor, o intervalo de valores possíveis que ele pode assumir e os membros que ele disponibiliza.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Many values can be expressed as more than one type.</source>
          <target state="translated">Muitos valores podem ser expressos por mais de um tipo.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, the value <ph id="ph1">`4`</ph> can be expressed as an integer or a floating-point value.</source>
          <target state="translated">Por exemplo, o valor de <ph id="ph1">`4`</ph> pode ser expresso como um inteiro ou um valor de ponto flutuante.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Type conversion creates a value in a new type that is equivalent to the value of an old type, but does not necessarily preserve the identity (or exact value) of the original object.</source>
          <target state="translated">A conversão de tipo cria um valor em um novo tipo que é equivalente ao valor de um tipo antigo, mas que não necessariamente preserva a identidade (ou o valor exato) do objeto original.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>.NET automatically supports the following conversions:</source>
          <target state="translated">O .NET oferece suporte automaticamente às seguintes conversões:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Conversion from a derived class to a base class.</source>
          <target state="translated">Conversão de uma classe derivada em uma classe base.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This means, for example, that an instance of any class or structure can be converted to an <bpt id="p1">[</bpt>Object<ept id="p1">](xref:System.Object)</ept> instance.</source>
          <target state="translated">Isso significa, por exemplo, que uma instância de qualquer classe ou estrutura pode ser convertida em uma instância de <bpt id="p1">[</bpt>Objeto<ept id="p1">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This conversion does not require a casting operator.</source>
          <target state="translated">Essa conversão não exige um operador de conversão.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Conversion from a base class back to the original derived class.</source>
          <target state="translated">Conversão de uma classe base para a classe derivada original.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>In C#, this conversion requires a casting operator.</source>
          <target state="translated">No C#, essa conversão exige um operador de conversão.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In Visual Basic, it requires the <ph id="ph1">`CType`</ph> operator if <ph id="ph2">`Option Strict`</ph> is on.</source>
          <target state="translated">No Visual Basic, ela exige o operador <ph id="ph1">`CType`</ph> quando a <ph id="ph2">`Option Strict`</ph> está ativada.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Conversion from a type that implements an interface to an interface object that represents that interface.</source>
          <target state="translated">Conversão de um tipo que implementa uma interface para um objeto de interface que representa essa interface.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This conversion does not require a casting operator.</source>
          <target state="translated">Essa conversão não exige um operador de conversão.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Conversion from an interface object back to the original type that implements that interface.</source>
          <target state="translated">Conversão de um objeto de interface de volta para o tipo original que implementa essa interface.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In C#, this conversion requires a casting operator.</source>
          <target state="translated">No C#, essa conversão exige um operador de conversão.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In Visual Basic, it requires the <ph id="ph1">`CType`</ph> operator if <ph id="ph2">`Option Strict`</ph> is on.</source>
          <target state="translated">No Visual Basic, ela exige o operador <ph id="ph1">`CType`</ph> quando a <ph id="ph2">`Option Strict`</ph> está ativada.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In addition to these automatic conversions, .NET provides several features that support custom type conversion.</source>
          <target state="translated">Além dessas conversões automáticas, o .NET fornece várias funcionalidades que oferecem suporte à conversão personalizada de tipo.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>These include the following:</source>
          <target state="translated">Eles incluem o seguinte:</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Implicit`</ph> operator, which defines the available widening conversions between types.</source>
          <target state="translated">O operador <ph id="ph1">`Implicit`</ph>, que define as conversões de ampliação disponíveis entre tipos.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implicit conversion with the Implicit operator<ept id="p1">](#implicit-conversion-with-the-implicit-operator)</ept> section.</source>
          <target state="translated">Para obter mais informações, consulte a seção <bpt id="p1">[</bpt>Conversão implícita com o operador implícito<ept id="p1">](#implicit-conversion-with-the-implicit-operator)</ept>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Explicit`</ph> operator, which defines the available narrowing conversions between types.</source>
          <target state="translated">O operador <ph id="ph1">`Explicit`</ph>, que define as conversões de redução disponíveis entre tipos.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Explicit conversion with the Explicit operator<ept id="p1">](#explicit-conversion-with-the-explicit-operator)</ept> section.</source>
          <target state="translated">Para obter mais informações, consulte a seção <bpt id="p1">[</bpt>Conversão explícita com o operador explícito<ept id="p1">](#explicit-conversion-with-the-explicit-operator)</ept>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface, which defines conversions to each of the base .NET data types.</source>
          <target state="translated">A interface <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept>, que define as conversões para cada um dos tipos de dados base do .NET.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>The IConvertible interface<ept id="p1">](#the-iconvertible-interface)</ept> section.</source>
          <target state="translated">Para obter mais informações, consulte a seção <bpt id="p1">[</bpt>A interface IConvertible<ept id="p1">](#the-iconvertible-interface)</ept>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class, which provides a set of methods that implement the methods in the <ph id="ph1">`IConvertible`</ph> interface.</source>
          <target state="translated">A classe <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept>, que fornece um conjunto de métodos que implementam os métodos na interface <ph id="ph1">`IConvertible`</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>The Convert class<ept id="p1">](#the-convert-class)</ept> section.</source>
          <target state="translated">Para obter mais informações, consulte a seção <bpt id="p1">[</bpt>A classe Convert<ept id="p1">](#the-convert-class)</ept>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept> class, which is a base class that can be extended to support the conversion of a specified type to any other type.</source>
          <target state="translated">A classe <bpt id="p1">[</bpt>TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept>, que é uma classe base que pode ser estendida para oferecer suporte à conversão de um tipo especificado em qualquer outro tipo.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>The TypeConverter class<ept id="p1">](#the-typeconverter-class)</ept> section.</source>
          <target state="translated">Para obter mais informações, consulte a seção <bpt id="p1">[</bpt>A classe TypeConverter<ept id="p1">](#the-typeconverter-class)</ept>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Implicit conversion with the Implicit operator</source>
          <target state="translated">Conversão implícita com o operador implícito</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Widening conversions involve the creation of a new value from the value of an existing type that has either a more restrictive range or a more restricted member list than the target type.</source>
          <target state="translated">As conversões de ampliação envolvem a criação de um novo valor do valor de um tipo existente que tem um intervalo mais restritivo ou uma lista de membros mais restrita que o tipo de destino.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Widening conversions cannot result in data loss (although they may result in a loss of precision).</source>
          <target state="translated">As conversões de ampliação não podem resultar na perda de dados (mas podem resultar em uma perda de precisão).</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Because data cannot be lost, compilers can handle the conversion implicitly or transparently, without requiring the use of an explicit conversion method or a casting operator.</source>
          <target state="translated">Como os dados não podem ser perdidos, os compiladores podem tratar a conversão de forma implícita ou transparente, sem exigir o uso de um método de conversão explícita ou de um operador de conversão.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Although code that performs an implicit conversion can call a conversion method or use a casting operator, their use is not required by compilers that support implicit conversions.</source>
          <target state="translated">Embora o código que executa uma conversão implícita possa chamar um método de conversão ou usar um operador de conversão, seu uso não é exigido pelos compiladores que oferecem suporte a conversões implícitas.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept> type supports implicit conversions from <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>Int16<ept id="p4">](xref:System.Int16)</ept>, <bpt id="p5">[</bpt>Int32<ept id="p5">](xref:System.Int32)</ept>, <bpt id="p6">[</bpt>Int64<ept id="p6">](xref:System.Int64)</ept>, <bpt id="p7">[</bpt>SByte<ept id="p7">](xref:System.SByte)</ept>, <bpt id="p8">[</bpt>UInt16<ept id="p8">](xref:System.UInt16)</ept>, <bpt id="p9">[</bpt>UInt32<ept id="p9">](xref:System.UInt32)</ept>, and <bpt id="p10">[</bpt>UInt64<ept id="p10">](xref:System.UInt64)</ept> values.</source>
          <target state="translated">Por exemplo, o tipo <bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept> oferece suporte a conversões implícitas de valores de <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>Int16<ept id="p4">](xref:System.Int16)</ept>, <bpt id="p5">[</bpt>Int32<ept id="p5">](xref:System.Int32)</ept>, <bpt id="p6">[</bpt>Int64<ept id="p6">](xref:System.Int64)</ept>, <bpt id="p7">[</bpt>SByte<ept id="p7">](xref:System.SByte)</ept>, <bpt id="p8">[</bpt>UInt16<ept id="p8">](xref:System.UInt16)</ept>, <bpt id="p9">[</bpt>UInt32<ept id="p9">](xref:System.UInt32)</ept> e <bpt id="p10">[</bpt>UInt64<ept id="p10">](xref:System.UInt64)</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The following example illustrates some of these implicit conversions in assigning values to a <ph id="ph1">`Decimal`</ph> variable.</source>
          <target state="translated">O exemplo a seguir ilustra algumas dessas conversões implícitas ao atribuir valores a uma variável <ph id="ph1">`Decimal`</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If a particular language compiler supports custom operators, you can also define implicit conversions in your own custom types.</source>
          <target state="translated">Se o compilador de uma linguagem específica oferecer suporte a operadores personalizados, você também poderá definir conversões implícitas em seus próprios tipos personalizados.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The following example provides a partial implementation of a signed byte data type named <ph id="ph1">`ByteWithSign`</ph> that uses sign-and-magnitude representation.</source>
          <target state="translated">O exemplo a seguir oferece uma implementação parcial de um tipo de dados de byte assinado chamado <ph id="ph1">`ByteWithSign`</ph> que usa a representação de sinal e magnitude.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>It supports implicit conversion of <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> and <bpt id="p2">[</bpt>SByte<ept id="p2">](xref:System.SByte)</ept> values to <ph id="ph1">`ByteWithSign`</ph> values.</source>
          <target state="translated">Ele oferece suporte à conversão implícita de valores de <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> e <bpt id="p2">[</bpt>SByte<ept id="p2">](xref:System.SByte)</ept> em valores de <ph id="ph1">`ByteWithSign`</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Client code can then declare a <ph id="ph1">`ByteWithSign`</ph> variable and assign it <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> and <bpt id="p2">[</bpt>SByte<ept id="p2">](xref:System.SByte)</ept> values without performing any explicit conversions or using any casting operators, as the following example shows.</source>
          <target state="translated">O código cliente pode então declarar uma variável <ph id="ph1">`ByteWithSign`</ph> e atribuir a ela valores de <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> e <bpt id="p2">[</bpt>SByte<ept id="p2">](xref:System.SByte)</ept> sem executar nenhuma conversão explícita ou usar operadores de conversão, conforme é mostrado no exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Explicit conversion with the Explicit operator</source>
          <target state="translated">Conversão explícita com o operador explícito</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Narrowing conversions involve the creation of a new value from the value of an existing type that has either a greater range or a larger member list than the target type.</source>
          <target state="translated">As conversões de redução envolvem a criação de um novo valor com o valor de um tipo existente que tem um intervalo mais amplo ou uma lista de membros maior do que o tipo de destino.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Because a narrowing conversion can result in a loss of data, compilers often require that the conversion be made explicit through a call to a conversion method or a casting operator.</source>
          <target state="translated">Como uma conversão de redução pode resultar em uma perda de dados, os compiladores geralmente exigem que a conversão se torne explícita por meio da chamada de um método de conversão ou de um operador de conversão.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>That is, the conversion must be handled explicitly in developer code.</source>
          <target state="translated">Ou seja, a conversão deve ser tratada explicitamente no código do desenvolvedor.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The major purpose of requiring a conversion method or casting operator for narrowing conversions is to make the developer aware of the possibility of data loss or an <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept> so that it can be handled in code.</source>
          <target state="translated">A finalidade principal de exigir um método de conversão ou um operador de conversão para reduzir conversões é fazer com que o desenvolvedor saiba sobre a possibilidade de perda de dados ou de uma <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept> para que ela possa ser tratada no código.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>However, some compilers can relax this requirement.</source>
          <target state="translated">No entanto, alguns compiladores podem amenizar esse requisito.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For example, in Visual Basic, if <ph id="ph1">`Option Strict`</ph> is off (its default setting), the Visual Basic compiler tries to perform narrowing conversions implicitly.</source>
          <target state="translated">Por exemplo, no Visual Basic, se a <ph id="ph1">`Option Strict`</ph> estiver desativada (sua configuração padrão), o compilador do Visual Basic tentará executar as conversões de redução de forma implícita.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept>, <bpt id="p2">[</bpt>Int64<ept id="p2">](xref:System.Int64)</ept>, and <bpt id="p3">[</bpt>UInt64<ept id="p3">](xref:System.UInt64)</ept> data types have ranges that exceed that the <bpt id="p4">[</bpt>Int32<ept id="p4">](xref:System.Int32)</ept> data type, as the following table shows.</source>
          <target state="translated">Por exemplo, os tipos de dados <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept>, <bpt id="p2">[</bpt>Int64<ept id="p2">](xref:System.Int64)</ept> e <bpt id="p3">[</bpt>UInt64<ept id="p3">](xref:System.UInt64)</ept> têm intervalos que excedem o do tipo de dados <bpt id="p4">[</bpt>Int32<ept id="p4">](xref:System.Int32)</ept>, conforme é mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Tipo</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Comparison with range of Int32</source>
          <target state="translated">Comparação com intervalo de Int32</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int64.MaxValue<ept id="p1">](xref:System.Int64.MaxValue)</ept> is greater than <bpt id="p2">[</bpt>Int32.MaxValue<ept id="p2">](xref:System.Int32#System_Int32_MaxValue)</ept>, and <bpt id="p3">[</bpt>Int64.MinValue<ept id="p3">](xref:System.Int64.MinValue)</ept> is less than (has a greater negative range than) <bpt id="p4">[</bpt>Int32.MinValue<ept id="p4">](xref:System.Int32#System_Int32_MinValue)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Int64.MaxValue<ept id="p1">](xref:System.Int64.MaxValue)</ept> é maior que <bpt id="p2">[</bpt>Int32.MaxValue<ept id="p2">](xref:System.Int32#System_Int32_MaxValue)</ept> e <bpt id="p3">[</bpt>Int64.MinValue<ept id="p3">](xref:System.Int64.MinValue)</ept> é menor que (tem um intervalo negativo maior que) <bpt id="p4">[</bpt>Int32.MinValue<ept id="p4">](xref:System.Int32#System_Int32_MinValue)</ept>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept></target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt32.MaxValue<ept id="p1">](xref:System.UInt32.MaxValue)</ept> is greater than <bpt id="p2">[</bpt>Int32.MaxValue<ept id="p2">](xref:System.Int32.MaxValue)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>UInt32.MaxValue<ept id="p1">](xref:System.UInt32.MaxValue)</ept> é maior que <bpt id="p2">[</bpt>Int32.MaxValue<ept id="p2">](xref:System.Int32.MaxValue)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt64<ept id="p1">](xref:System.UInt64)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UInt64<ept id="p1">](xref:System.UInt64)</ept></target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt64.MaxValue<ept id="p1">](xref:System.UInt64.MaxValue)</ept> is greater than <bpt id="p2">[</bpt>Int32.MaxValue<ept id="p2">](xref:System.Int32.MaxValue)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>UInt64.MaxValue<ept id="p1">](xref:System.UInt64.MaxValue)</ept> é maior que <bpt id="p2">[</bpt>Int32.MaxValue<ept id="p2">](xref:System.Int32.MaxValue)</ept>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To handle such narrowing conversions, .NET allows types to define an <ph id="ph1">`Explicit`</ph> operator.</source>
          <target state="translated">Para tratar essas conversões de redução, o .NET permite que os tipos definam um operador <ph id="ph1">`Explicit`</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Individual language compilers can then implement this operator using their own syntax, or a member of the <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class can be called to perform the conversion.</source>
          <target state="translated">Os compiladores de linguagens individuais podem então implementar esse operador usando suas próprias sintaxes ou um membro da classe <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> pode ser chamado para executar a conversão.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>(For more information about the <ph id="ph1">`Convert`</ph> class, see <bpt id="p1">[</bpt>The Convert class<ept id="p1">](#the-convert-class)</ept> later in this topic.) The following example illustrates the use of language features to handle the explicit conversion of these potentially out-of-range integer values to <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept> values.</source>
          <target state="translated">(Para obter mais informações sobre a classe <ph id="ph1">`Convert`</ph>, consulte <bpt id="p1">[</bpt>A classe Convert<ept id="p1">](#the-convert-class)</ept> mais adiante neste tópico.) O exemplo a seguir ilustra o uso das funcionalidades de linguagem para lidar com a conversão explícita destes valores inteiros que podem estar fora do intervalo em valores <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Explicit conversions can produce different results in different languages, and these results can differ from the value returned by the corresponding <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> method.</source>
          <target state="translated">As conversões explícitas podem produzir resultados diferentes em linguagens diferentes e esses resultados podem diferir do valor retornado pelo método <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> correspondente.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For example, if the <bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept> value <bpt id="p2">**</bpt>12.63251<ept id="p2">**</ept> is converted to an <bpt id="p3">[</bpt>Int32<ept id="p3">](xref:System.Int32)</ept>, both the .NET <bpt id="p4">[</bpt>Convert.ToInt32(Double)<ept id="p4">](xref:System.Convert.ToInt32(System.Double))</ept> and the Visual Basic <ph id="ph1">`CInt`</ph> method method rounds the <bpt id="p5">[</bpt>Double<ept id="p5">](xref:System.Double)</ept> to return a value of <bpt id="p6">**</bpt>13<ept id="p6">**</ept>, but the C# <ph id="ph2">`(int)`</ph> operator truncates the <bpt id="p7">[</bpt>Double<ept id="p7">](xref:System.Double)</ept> to return a value of <bpt id="p8">**</bpt>12<ept id="p8">**</ept>.</source>
          <target state="translated">Por exemplo, se o valor <bpt id="p2">**</bpt>12.63251<ept id="p2">**</ept> de <bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept> for convertido em um <bpt id="p3">[</bpt>Int32<ept id="p3">](xref:System.Int32)</ept>, tanto o método <bpt id="p4">[</bpt>Convert.ToInt32(Double)<ept id="p4">](xref:System.Convert.ToInt32(System.Double))</ept> do .NET quanto o <ph id="ph1">`CInt`</ph> do Visual Basic arredondarão o <bpt id="p5">[</bpt>Double<ept id="p5">](xref:System.Double)</ept> para retornar o valor <bpt id="p6">**</bpt>13<ept id="p6">**</ept>, mas o operador <ph id="ph2">`(int)`</ph> do C# truncará o <bpt id="p7">[</bpt>Double<ept id="p7">](xref:System.Double)</ept> para retornar o valor <bpt id="p8">**</bpt>12<ept id="p8">**</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Similarly, the C# <ph id="ph1">`(int)`</ph> operator does not support Boolean-to-integer conversion, but the Visual Basic <ph id="ph2">`CInt`</ph> method converts a value of <ph id="ph3">`true`</ph> to <bpt id="p1">**</bpt>-1<ept id="p1">**</ept>.</source>
          <target state="translated">Da mesma forma, o operador <ph id="ph1">`(int)`</ph> do C# não oferece suporte à conversão de booliano em inteiro, mas o método <ph id="ph2">`CInt`</ph> do Visual Basic converte um valor <ph id="ph3">`true`</ph> em <bpt id="p1">**</bpt>-1<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>On the other hand, the <bpt id="p1">[</bpt>Convert.ToInt32(Boolean)<ept id="p1">](xref:System.Convert.ToInt32(System.Boolean))</ept> method converts a value of <ph id="ph1">`true`</ph> to <bpt id="p2">**</bpt>1<ept id="p2">**</ept>.</source>
          <target state="translated">Por outro lado, o método <bpt id="p1">[</bpt>Convert.ToInt32(Boolean)<ept id="p1">](xref:System.Convert.ToInt32(System.Boolean))</ept> converte um valor <ph id="ph1">`true`</ph> em <bpt id="p2">**</bpt>1<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Most compilers allow explicit conversions to be performed in a checked or unchecked manner.</source>
          <target state="translated">A maioria dos compiladores permite que as conversões explícitas sejam executadas de forma verificada ou não verificada.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>When a checked conversion is performed, an <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept> is thrown when the value of the type to be converted is outside the range of the target type.</source>
          <target state="translated">Quando uma conversão verificada é executada, uma <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept> é gerada quando o valor do tipo a ser convertido está fora do intervalo do tipo de destino.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When an unchecked conversion is performed under the same conditions, the conversion might not throw an exception, but the exact behavior becomes undefined and an incorrect value might result.</source>
          <target state="translated">Quando uma conversão não verificada é executada nas mesmas condições, a conversão pode não gerar uma exceção, mas o comportamento exato se tornará indefinido e um valor incorreto poderá ser produzido.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In C#, checked conversions can be performed by using the <ph id="ph1">`checked`</ph> keyword together with a casting operator, or by specifying the <ph id="ph2">`/checked+`</ph> compiler option.</source>
          <target state="translated">No C#, as conversões verificadas podem ser executadas usando a palavra-chave <ph id="ph1">`checked`</ph> juntamente com um operador de conversão ou por meio da especificação da opção do compilador <ph id="ph2">`/checked+`</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Conversely, unchecked conversions can be performed by using the <ph id="ph1">`unchecked`</ph> keyword together with the casting operator, or by specifying the <ph id="ph2">`/checked-`</ph> compiler option.</source>
          <target state="translated">Por outro lado, as conversões não verificadas podem ser executadas usando a palavra-chave <ph id="ph1">`unchecked`</ph> juntamente com o operador de conversão ou especificando a opção do compilador <ph id="ph2">`/checked-`</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>By default, explicit conversions are unchecked.</source>
          <target state="translated">Por padrão, as conversões explícitas são do tipo não verificadas.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In Visual Basic, checked conversions can be performed by specifying the <ph id="ph1">`/removeintchecks-`</ph> compiler option.</source>
          <target state="translated">No Visual Basic, as conversões verificadas podem ser executadas especificando a opção do compilador <ph id="ph1">`/removeintchecks-`</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Conversely, unchecked conversions can be performed by specifying the <ph id="ph1">`/removeintchecks+`</ph> compiler option.</source>
          <target state="translated">Por outro lado, as conversões não verificadas podem ser executadas especificando a opção do compilador <ph id="ph1">`/removeintchecks+`</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>By default, explicit conversions are checked.</source>
          <target state="translated">Por padrão, as conversões explícitas são do tipo verificadas.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The following C# example uses the <ph id="ph1">`checked`</ph> and <ph id="ph2">`unchecked`</ph> keywords to illustrate the difference in behavior when a value outside the range of a <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> is converted to a <ph id="ph3">`Byte`</ph>.</source>
          <target state="translated">O exemplo do C# a seguir usa as palavras-chave <ph id="ph1">`checked`</ph> e <ph id="ph2">`unchecked`</ph> para ilustrar a diferença no comportamento quando um valor fora do intervalo de <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> é convertido em <ph id="ph3">`Byte`</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The checked conversion throws an exception, but the unchecked conversion assigns <bpt id="p1">[</bpt>Byte.MaxValue<ept id="p1">](xref:System.Byte.MaxValue)</ept> to the <ph id="ph1">`Byte`</ph> variable.</source>
          <target state="translated">A conversão verificada gera uma exceção, mas a conversão não verificada atribui <bpt id="p1">[</bpt>Byte.MaxValue<ept id="p1">](xref:System.Byte.MaxValue)</ept> à variável <ph id="ph1">`Byte`</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If a particular language compiler supports custom overloaded operators, you can also define explicit conversions in your own custom types.</source>
          <target state="translated">Se o compilador de uma linguagem específica der suporte a operadores sobrecarregados personalizados, você também poderá definir as conversões explícitas em seus próprios tipos personalizados.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The following example provides a partial implementation of a signed byte data type named <ph id="ph1">`ByteWithSign`</ph> that uses sign-and-magnitude representation.</source>
          <target state="translated">O exemplo a seguir oferece uma implementação parcial de um tipo de dados de byte assinado chamado <ph id="ph1">`ByteWithSign`</ph> que usa a representação de sinal e magnitude.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>It supports explicit conversion of <bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept> and <bpt id="p2">[</bpt>UInt32<ept id="p2">](xref:System.UInt32)</ept> values to <ph id="ph1">`ByteWithSign`</ph> values.</source>
          <target state="translated">Ele oferece suporte à conversão explícita de valores de <bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept> e <bpt id="p2">[</bpt>UInt32<ept id="p2">](xref:System.UInt32)</ept> em valores de <ph id="ph1">`ByteWithSign`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Client code can then declare a <ph id="ph1">`ByteWithSign`</ph> variable and assign it <bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept> and <bpt id="p2">[</bpt>UInt32<ept id="p2">](xref:System.UInt32)</ept> values if the assignments include a casting operator, as the following example shows.</source>
          <target state="translated">O código cliente poderá então declarar uma variável <ph id="ph1">`ByteWithSign`</ph> e atribuir valores de <bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept> e <bpt id="p2">[</bpt>UInt32<ept id="p2">](xref:System.UInt32)</ept> a ela se as atribuições incluírem um operador de conversão, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The IConvertible interface</source>
          <target state="translated">A interface IConvertible</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>To support the conversion of any type to a common language runtime base type, .NET provides the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface.</source>
          <target state="translated">Para oferecer suporte à conversão de qualquer tipo em um tipo base do Common Language Runtime, o .NET oferece a interface <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The implementing type is required to provide the following:</source>
          <target state="translated">O tipo de implementação é necessário para fornecer o seguinte:</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A method that returns the <bpt id="p1">[</bpt>TypeCode<ept id="p1">](xref:System.TypeCode)</ept> of the implementing type.</source>
          <target state="translated">Um método que retorne o <bpt id="p1">[</bpt>TypeCode<ept id="p1">](xref:System.TypeCode)</ept> do tipo de implementação.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Methods to convert the implementing type to each common language runtime base type (<bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>DateTime<ept id="p3">](xref:System.DateTime)</ept>, <bpt id="p4">[</bpt>Decimal<ept id="p4">](xref:System.Decimal)</ept>, <bpt id="p5">[</bpt>Double<ept id="p5">](xref:System.Double)</ept>, and so on).</source>
          <target state="translated">Métodos para converter o tipo de implementação em cada tipo base do Common Language Runtime (<bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>DateTime<ept id="p3">](xref:System.DateTime)</ept>, <bpt id="p4">[</bpt>Decimal<ept id="p4">](xref:System.Decimal)</ept>, <bpt id="p5">[</bpt>Double<ept id="p5">](xref:System.Double)</ept> e assim por diante).</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>A generalized conversion method to convert an instance of the implementing type to another specified type.</source>
          <target state="translated">Um método de conversão generalizado para converter uma instância do tipo de implementação em outro tipo especificado.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Conversions that are not supported should throw an <bpt id="p1">[</bpt>InvalidCastException<ept id="p1">](xref:System.InvalidCastException)</ept>.</source>
          <target state="translated">As conversões sem suporte devem gerar uma <bpt id="p1">[</bpt>InvalidCastException<ept id="p1">](xref:System.InvalidCastException)</ept>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Each common language runtime base type (that is, the <bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>DateTime<ept id="p4">](xref:System.DateTime)</ept>, <bpt id="p5">[</bpt>Decimal<ept id="p5">](xref:System.Decimal)</ept>, <bpt id="p6">[</bpt>Double<ept id="p6">](xref:System.Double)</ept>, <bpt id="p7">[</bpt>Int16<ept id="p7">](xref:System.Int16)</ept>, <bpt id="p8">[</bpt>Int32<ept id="p8">](xref:System.Int32)</ept>, <bpt id="p9">[</bpt>Int64<ept id="p9">](xref:System.Int64)</ept>, <bpt id="p10">[</bpt>SByte<ept id="p10">](xref:System.SByte)</ept>, <bpt id="p11">[</bpt>Single<ept id="p11">](xref:System.Single)</ept>, <bpt id="p12">[</bpt>String<ept id="p12">](xref:System.String)</ept>, <bpt id="p13">[</bpt>UInt16<ept id="p13">](xref:System.UInt16)</ept>, <bpt id="p14">[</bpt>UInt32<ept id="p14">](xref:System.UInt32)</ept>, and <bpt id="p15">[</bpt>UInt64<ept id="p15">](xref:System.UInt64)</ept>, as well as the <bpt id="p16">[</bpt>DBNull<ept id="p16">](xref:System.DBNull)</ept> and <bpt id="p17">[</bpt>Enum<ept id="p17">](xref:System.Enum)</ept> types, implement the <bpt id="p18">[</bpt>IConvertible<ept id="p18">](xref:System.IConvertible)</ept> interface.</source>
          <target state="translated">Cada tipo base do Common Language Runtime, ou seja, os tipos <bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>DateTime<ept id="p4">](xref:System.DateTime)</ept>, <bpt id="p5">[</bpt>Decimal<ept id="p5">](xref:System.Decimal)</ept>, <bpt id="p6">[</bpt>Double<ept id="p6">](xref:System.Double)</ept>, <bpt id="p7">[</bpt>Int16<ept id="p7">](xref:System.Int16)</ept>, <bpt id="p8">[</bpt>Int32<ept id="p8">](xref:System.Int32)</ept>, <bpt id="p9">[</bpt>Int64<ept id="p9">](xref:System.Int64)</ept>, <bpt id="p10">[</bpt>SByte<ept id="p10">](xref:System.SByte)</ept>, <bpt id="p11">[</bpt>Single<ept id="p11">](xref:System.Single)</ept>, <bpt id="p12">[</bpt>String<ept id="p12">](xref:System.String)</ept>, <bpt id="p13">[</bpt>UInt16<ept id="p13">](xref:System.UInt16)</ept>, <bpt id="p14">[</bpt>UInt32<ept id="p14">](xref:System.UInt32)</ept> e <bpt id="p15">[</bpt>UInt64<ept id="p15">](xref:System.UInt64)</ept>, além de <bpt id="p16">[</bpt>DBNull<ept id="p16">](xref:System.DBNull)</ept> e <bpt id="p17">[</bpt>Enum<ept id="p17">](xref:System.Enum)</ept>, implementam a interface <bpt id="p18">[</bpt>IConvertible<ept id="p18">](xref:System.IConvertible)</ept>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>However, these are explicit interface implementations; the conversion method can be called only through an <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface variable, as the following example shows.</source>
          <target state="translated">No entanto, essas são implementações de interfaces explícitas. O método de conversão somente pode ser chamado por meio de uma variável da interface <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept>, conforme é mostrado no exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>This example converts an <bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept> value to its equivalent <bpt id="p2">[</bpt>Char<ept id="p2">](xref:System.Char)</ept> value.</source>
          <target state="translated">Este exemplo converte um valor de <bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept> em seu valor de <bpt id="p2">[</bpt>Char<ept id="p2">](xref:System.Char)</ept> equivalente.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The requirement to call the conversion method on its interface rather than on the implementing type makes explicit interface implementations relatively expensive.</source>
          <target state="translated">O requisito para chamar o método de conversão em sua interface, em vez de no tipo de implementação, torna as implementações de interfaces explícitas relativamente dispendiosas.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Instead, we recommend that you call the appropriate member of the <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class to convert between common language runtime base types.</source>
          <target state="translated">Em vez disso, recomendamos que você chame o membro apropriado da classe <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> para converter entre tipos base do Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For more information, see the next section, <bpt id="p1">[</bpt>The Convert class<ept id="p1">](#the-convert-class)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte a próxima seção: <bpt id="p1">[</bpt>A classe Convert<ept id="p1">](#the-convert-class)</ept>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>In addition to the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface and the <bpt id="p2">[</bpt>Convert<ept id="p2">](xref:System.Convert)</ept> class provided by .NET, individual languages may also provide ways to perform conversions.</source>
          <target state="translated">Além da interface <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> e da classe <bpt id="p2">[</bpt>Convert<ept id="p2">](xref:System.Convert)</ept> fornecidas pelo .NET, as linguagens individuais também podem fornecer formas de executar conversões.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For example, C# uses casting operators; Visual Basic uses compiler-implemented conversion functions such as <ph id="ph1">`CType`</ph>, <ph id="ph2">`CInt`</ph>, and <ph id="ph3">`DirectCast`</ph>.</source>
          <target state="translated">Por exemplo, o C# usa operadores de conversão e Visual Basic usa funções de conversão implementadas no compilador, como <ph id="ph1">`CType`</ph>,<ph id="ph2">`CInt`</ph> e <ph id="ph3">`DirectCast`</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>For the most part, the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface is designed to support conversion between the base types in .NET.</source>
          <target state="translated">Em grande parte, a interface <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> é criada para oferecer suporte à conversão entre os tipos base no NET.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>However, the interface can also be implemented by a custom type to support conversion of that type to other custom types.</source>
          <target state="translated">No entanto, a interface também pode ser implementada por um tipo personalizado para oferecer suporte à conversão desse tipo em outros tipos personalizados.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For more information, see the section <bpt id="p1">[</bpt>Custom conversions with the ChangeType method<ept id="p1">](#custom-conversions-with-the-changetype-method)</ept> later in this topic.</source>
          <target state="translated">Para obter mais informações, consulte a seção <bpt id="p1">[</bpt>Conversões personalizadas com o método ChangeType<ept id="p1">](#custom-conversions-with-the-changetype-method)</ept> mais adiante neste tópico.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The Convert class</source>
          <target state="translated">A classe Convert</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Although each base type's <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface implementation can be called to perform a type conversion, calling the methods of the <bpt id="p2">[</bpt>System.Convert<ept id="p2">](xref:System.Convert)</ept> class is the recommended language-neutral way to convert from one base type to another.</source>
          <target state="translated">Embora a implementação da interface <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> de cada tipo base possa ser chamada para executar uma conversão de tipo, chamar os métodos da classe <bpt id="p2">[</bpt>System.Convert<ept id="p2">](xref:System.Convert)</ept> é a maneira com neutralidade de idioma recomendada para converter de um tipo base em outro.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>In addition, the <bpt id="p1">[</bpt>Convert.ChangeType(Object, Type, IFormatProvider)<ept id="p1">](xref:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider))</ept> method can be used to convert from a specified custom type to another type.</source>
          <target state="translated">Além disso, o método <bpt id="p1">[</bpt>Convert.ChangeType(Object, Type, IFormatProvider)<ept id="p1">](xref:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider))</ept> pode ser usado para converter de um tipo personalizado especificado em outro tipo.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Conversions between base types</source>
          <target state="translated">Conversões entre tipos base</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class provides a language-neutral way to perform conversions between base types and is available to all languages that target the common language runtime.</source>
          <target state="translated">A classe <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> fornece uma maneira com neutralidade de idioma de realizar conversões entre tipos base e está disponível para todas as linguagens que visam o Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>It provides a complete set of methods for both widening and narrowing conversions, and throws an <bpt id="p1">[</bpt>InvalidCastException<ept id="p1">](xref:System.InvalidCastException)</ept> for conversions that are not supported (such as the conversion of a <bpt id="p2">[</bpt>DateTime<ept id="p2">](xref:System.DateTime)</ept> value to an integer value).</source>
          <target state="translated">Ela fornece um conjunto completo de métodos para conversões de ampliação e de redução e gera uma <bpt id="p1">[</bpt>InvalidCastException<ept id="p1">](xref:System.InvalidCastException)</ept> para as conversões que não têm suporte (como a conversão de um valor de <bpt id="p2">[</bpt>DateTime<ept id="p2">](xref:System.DateTime)</ept> em um valor inteiro).</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Narrowing conversions are performed in a checked context, and an <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept> is thrown if the conversion fails.</source>
          <target state="translated">As conversões de redução são executadas em um contexto verificado e uma <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept> será gerada se a conversão falhar.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class includes methods to convert to and from each base type, it eliminates the need to call each base type's <bpt id="p2">[</bpt>IConvertible<ept id="p2">](xref:System.IConvertible)</ept> explicit interface implementation.</source>
          <target state="translated">Como a classe <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> inclui métodos para converter de/para cada tipo base, ela elimina a necessidade de chamar a implementação de interface explicita <bpt id="p2">[</bpt>IConvertible<ept id="p2">](xref:System.IConvertible)</ept> de cada tipo base.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The following example illustrates the use of the <bpt id="p1">[</bpt>System.Convert<ept id="p1">](xref:System.Convert)</ept> class to perform several widening and narrowing conversions between .NET base types.</source>
          <target state="translated">O exemplo a seguir ilustra o uso da classe <bpt id="p1">[</bpt>System.Convert<ept id="p1">](xref:System.Convert)</ept> para executar várias conversões de ampliação e redução entre os tipos base do .NET.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In some cases, particularly when converting to and from floating-point values, a conversion may involve a loss of precision, even though it does not throw an <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept>.</source>
          <target state="translated">Em alguns casos, principalmente na conversão de/para valores de ponto flutuante, uma conversão pode envolver uma perda de precisão, mesmo que não gere uma <bpt id="p1">[</bpt>OverflowException<ept id="p1">](xref:System.OverflowException)</ept>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The following example illustrates this loss of precision.</source>
          <target state="translated">O exemplo a seguir ilustra essa perda de precisão.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In the first case, a <bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept> value has less precision (fewer significant digits) when it is converted to a <bpt id="p2">[</bpt>Double<ept id="p2">](xref:System.Double)</ept>.</source>
          <target state="translated">No primeiro caso, um valor de <bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept> tem menos precisão (menos dígitos significativos) quando é convertido em <bpt id="p2">[</bpt>Double<ept id="p2">](xref:System.Double)</ept>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In the second case, a <bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept> value is rounded from <bpt id="p2">**</bpt>42.72<ept id="p2">**</ept> to <bpt id="p3">**</bpt>43<ept id="p3">**</ept> in order to complete the conversion.</source>
          <target state="translated">No segundo caso, um valor de <bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept> é arredondado de <bpt id="p2">**</bpt>42.72<ept id="p2">**</ept> para <bpt id="p3">**</bpt>43<ept id="p3">**</ept> para concluir a conversão.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For a table that lists both the widening and narrowing conversions supported by the <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class, see <bpt id="p2">[</bpt>Type conversion tables<ept id="p2">](conversion-tables.md)</ept>.</source>
          <target state="translated">Para ver uma tabela que lista as conversões de ampliação e redução com suporte da classe <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept>, consulte <bpt id="p2">[</bpt>Tabelas de conversão de tipos<ept id="p2">](conversion-tables.md)</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Custom conversions with the ChangeType method</source>
          <target state="translated">Conversões personalizadas com o método ChangeType</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>In addition to supporting conversions to each of the base types, the <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> class can be used to convert a custom type to one or more predefined types.</source>
          <target state="translated">Além de oferecer suporte a conversões para cada um dos tipos base, a classe <bpt id="p1">[</bpt>Convert<ept id="p1">](xref:System.Convert)</ept> pode ser usada para converter um tipo personalizado em um ou mais tipos predefinidos.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This conversion is performed by the <bpt id="p1">[</bpt>Convert.ChangeType(Object, Type, IFormatProvider)<ept id="p1">](xref:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider))</ept> method, which in turn wraps a call to the <bpt id="p2">[</bpt>IConvertible.ToType<ept id="p2">](xref:System.IConvertible.ToType(System.Type,System.IFormatProvider))</ept> method of the value parameter.</source>
          <target state="translated">Essa conversão é executada pelo método <bpt id="p1">[</bpt>Convert.ChangeType(Object, Type, IFormatProvider)<ept id="p1">](xref:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider))</ept> que, por sua vez, encapsula uma chamada ao método <bpt id="p2">[</bpt>IConvertible.ToType<ept id="p2">](xref:System.IConvertible.ToType(System.Type,System.IFormatProvider))</ept> do parâmetro de valor.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>This means that the object represented by the value parameter must provide an implementation of the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface.</source>
          <target state="translated">Isso significa que o objeto representado pelo parâmetro de valor deve fornecer uma implementação da interface <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>Convert.ChangeType(Object, Type)<ept id="p1">](xref:System.Convert.ChangeType(System.Object,System.Type))</ept> and <bpt id="p2">[</bpt>Convert.ChangeType(Object, Type, IFormatProvider)<ept id="p2">](xref:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider))</ept> methods use a <bpt id="p3">[</bpt>Type<ept id="p3">](xref:System.Type)</ept> object to specify the target type to which value is converted, they can be used to perform a dynamic conversion to an object whose type is not known at compile time.</source>
          <target state="translated">Como os métodos <bpt id="p1">[</bpt>Convert.ChangeType(Object, Type)<ept id="p1">](xref:System.Convert.ChangeType(System.Object,System.Type))</ept> e <bpt id="p2">[</bpt>Convert.ChangeType(Object, Type, IFormatProvider)<ept id="p2">](xref:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider))</ept> usam um objeto de <bpt id="p3">[</bpt>Tipo<ept id="p3">](xref:System.Type)</ept> para especificar o tipo de destino no qual o valor será convertido, eles podem ser usados para executar uma conversão dinâmica em um objeto cujo tipo não seja conhecido no tempo de compilação.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>However, note that the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> implementation of value must still support this conversion.</source>
          <target state="translated">No entanto, observe que a implementação de valor da <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> ainda deve oferecer suporte a essa conversão.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The following example illustrates a possible implementation of the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface that allows a <ph id="ph1">`TemperatureCelsius`</ph> object to be converted to a <ph id="ph2">`TemperatureFahrenheit`</ph> object and vice versa.</source>
          <target state="translated">O exemplo a seguir ilustra uma possível implementação da interface <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> que permite que um objeto <ph id="ph1">`TemperatureCelsius`</ph> seja convertido em um objeto <ph id="ph2">`TemperatureFahrenheit`</ph> e vice-versa.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The example defines a base class, <ph id="ph1">`Temperature`</ph>, that implements the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface and overrides the <bpt id="p2">[</bpt>Object.ToString<ept id="p2">](xref:System.Object.ToString)</ept> method.</source>
          <target state="translated">O exemplo define uma classe base, <ph id="ph1">`Temperature`</ph>, que implementa a interface <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> e substitui o método <bpt id="p2">[</bpt>Object.ToString<ept id="p2">](xref:System.Object.ToString)</ept>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The derived <ph id="ph1">`TemperatureCelsius`</ph> and <ph id="ph2">`TemperatureFahrenheit`</ph> classes each override the <ph id="ph3">`ToType`</ph> and the <ph id="ph4">`ToString`</ph> methods of the base class.</source>
          <target state="translated">As classes <ph id="ph1">`TemperatureCelsius`</ph> e <ph id="ph2">`TemperatureFahrenheit`</ph> derivadas substituem os métodos <ph id="ph3">`ToType`</ph> e <ph id="ph4">`ToString`</ph> da classe base.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The following example illustrates several calls to these <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> implementations to convert <ph id="ph1">`TemperatureCelsius`</ph> objects to <ph id="ph2">`TemperatureFahrenheit`</ph> objects and vice versa.</source>
          <target state="translated">O exemplo a seguir ilustra várias chamadas a essas implementações da <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> para converter objetos <ph id="ph1">`TemperatureCelsius`</ph> em objetos <ph id="ph2">`TemperatureFahrenheit`</ph> e vice-versa.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The TypeConverter class</source>
          <target state="translated">A classe TypeConverter</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>.NET also allows you to define a type converter for a custom type by extending the <bpt id="p1">[</bpt>System.ComponentModel.TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept> class and associating the type converter with the type through a <bpt id="p2">[</bpt>System.ComponentModel.TypeConverterAttribute<ept id="p2">](xref:System.ComponentModel.TypeConverterAttribute)</ept> attribute.</source>
          <target state="translated">O .NET também permite definir um conversor de tipo para um tipo personalizado, estendendo a classe <bpt id="p1">[</bpt>System.ComponentModel.TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept> e associando o conversor de tipo ao tipo por meio de um atributo <bpt id="p2">[</bpt>System.ComponentModel.TypeConverterAttribute<ept id="p2">](xref:System.ComponentModel.TypeConverterAttribute)</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The following table highlights the differences between this approach and implementing the <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> interface for a custom type.</source>
          <target state="translated">A tabela a seguir realça as diferenças entre esta abordagem e a implementação da interface <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> para um tipo personalizado.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Design-time support can be provided for a custom type only if it has a type converter defined for it.</source>
          <target state="translated">O suporte no tempo de design somente poderá ser fornecido para um tipo personalizado se houver um conversor de tipo definido para ele.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Conversion using TypeConverter</source>
          <target state="translated">Conversão usando TypeConverter</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Conversion using IConvertible</source>
          <target state="translated">Conversão usando IConvertible</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Is implemented for a custom type by deriving a separate class from <bpt id="p1">[</bpt>TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept>.</source>
          <target state="translated">É implementada para um tipo personalizado por meio da derivação de uma classe separada de <bpt id="p1">[</bpt>TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This derived class is associated with the custom type by applying a <bpt id="p1">[</bpt>TypeConverterAttribute<ept id="p1">](xref:System.ComponentModel.TypeConverterAttribute)</ept> attribute.</source>
          <target state="translated">Essa classe derivada é associada ao tipo personalizado aplicando um atributo <bpt id="p1">[</bpt>TypeConverterAttribute<ept id="p1">](xref:System.ComponentModel.TypeConverterAttribute)</ept>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Is implemented by a custom type to perform conversion.</source>
          <target state="translated">É implementada por um tipo personalizado para executar a conversão.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>A user of the type invokes an <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> conversion method on the type.</source>
          <target state="translated">Um usuário do tipo invoca um método de conversão de <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept> no tipo.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Can be used both at design time and at run time.</source>
          <target state="translated">Pode ser usada tanto no tempo de design quanto no tempo de execução.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Can be used only at run time.</source>
          <target state="translated">Somente pode ser usada no tempo de execução.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Uses reflection; therefore, is slower than conversion enabled by <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept>.</source>
          <target state="translated">Usa reflexão e, consequentemente, é mais lenta do que a conversão habilitada por <bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Does not use reflection.</source>
          <target state="translated">Não usa reflexão.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Allows two-way type conversions from the custom type to other data types, and from other data types to the custom type.</source>
          <target state="translated">Permite conversões de tipo bidirecionais do tipo personalizado para outros tipos de dados e de outros tipos de dados para o tipo personalizado.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>For example, a <bpt id="p1">[</bpt>TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept> defined for <ph id="ph1">`MyType`</ph> allows conversions from <ph id="ph2">`MyType`</ph> to <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept>, and from <bpt id="p3">[</bpt>String<ept id="p3">](xref:System.String)</ept> to <ph id="ph3">`MyType`</ph>.</source>
          <target state="translated">Por exemplo, um <bpt id="p1">[</bpt>TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept> definido para <ph id="ph1">`MyType`</ph> permite conversões de <ph id="ph2">`MyType`</ph> em <bpt id="p2">[</bpt>String<ept id="p2">](xref:System.String)</ept> e de <bpt id="p3">[</bpt>String<ept id="p3">](xref:System.String)</ept> em <ph id="ph3">`MyType`</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Allows conversion from a custom type to other data types, but not from other data types to the custom type.</source>
          <target state="translated">Permite a conversão de um tipo personalizado em outros tipos de dados, mas não de outros tipos de dados em um tipo personalizado.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For more information about using type converters to perform conversions, see <bpt id="p1">[</bpt>System.ComponentModel.TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept>.</source>
          <target state="translated">Para obter mais informações de como usar conversores de tipo para realizar conversões, consulte <bpt id="p1">[</bpt>System.ComponentModel.TypeConverter<ept id="p1">](xref:System.ComponentModel.TypeConverter)</ept>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Consulte também</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Convert<ept id="p1">](xref:System.Convert)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Convert<ept id="p1">](xref:System.Convert)</ept></target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IConvertible<ept id="p1">](xref:System.IConvertible)</ept></target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type conversion tables<ept id="p1">](conversion-tables.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tabelas de conversão de tipos<ept id="p1">](conversion-tables.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>