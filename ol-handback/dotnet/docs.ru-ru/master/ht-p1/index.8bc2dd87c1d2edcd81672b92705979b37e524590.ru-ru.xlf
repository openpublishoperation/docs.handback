<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fba870a93784b579da1065a07d82974951ac7e28</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">95b746403eed8e13100defe90c42c880febbf750</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d8d70bd22979ff7663a27372887eb04ebd6c598f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">Учебник по .NET для начинающих</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">Учебник по .NET для начинающих</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">Учебник по .NET для начинающих</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>"Getting Started with .NET Core" tutorials<ept id="p1">](../core/getting-started.md)</ept> to learn how to create a simple .NET Core application.</source>
          <target state="translated">Ознакомьтесь с учебниками <bpt id="p1">[</bpt>Начало работы с .NET Core<ept id="p1">](../core/getting-started.md)</ept>, чтобы узнать, как создать простое приложение .NET Core.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It only takes a few minutes to get your first app up and running.</source>
          <target state="translated">На создание и запуск первого приложения потребуется буквально несколько минут.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>.NET is a general purpose development platform.</source>
          <target state="translated">.NET — это платформа разработки общего назначения.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>It can be used for any kind of app type or workload where general purpose solutions are used.</source>
          <target state="translated">Ее можно использовать для любых типов приложений и рабочих нагрузок, где применяются универсальные решения.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>It has several key features that are attractive to many developers, including automatic memory management and modern programming languages, that make it easier to efficiently build high-quality applications.</source>
          <target state="translated">В ней есть ряд ключевых особенностей, которые высоко ценятся многими разработчиками, включая автоматическое управление памятью и современные языки программирования, которые упрощают эффективное создание высококачественных приложений.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>.NET enables a high-level programming environment with many convenience features, while providing low-level access to native memory and APIs.</source>
          <target state="translated">.NET предлагает среду высокоуровневого программирования с множеством удобных функций, предоставляя при этом низкоуровневый доступ к API и внутренней памяти.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Multiple implementations of .NET are available, based on open <bpt id="p1">[</bpt>.NET Standards<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)</ept> that specify the fundamentals of the platform.</source>
          <target state="translated">Существуют различные реализации .NET, основанные на открытых <bpt id="p1">[</bpt>стандартах .NET<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)</ept>, в которых определяются базовые принципы платформы.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>They are separately optimized for different application types (for example, desktop, mobile, gaming, cloud) and support many chips (for example, x86/x64, ARM) and operating systems (for example, Windows, Linux, iOS, Android, macOS).</source>
          <target state="translated">Они оптимизированы для отдельных типов приложений (например, классических настольных, мобильных, игровых, облачных) и поддерживают многие процессоры (например, x86/x64, ARM) и операционные системы (например, Windows, Linux, iOS, Android, macOS).</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Open source is also an important part of the .NET ecosystem, with multiple .NET implementations and many libraries available under OSI-approved licenses.</source>
          <target state="translated">Не менее важной частью экосистемы .NET является сообщество открытого исходного кода, где имеется множество реализаций .NET и библиотек, доступных по утвержденным OSI лицензиям.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>Overview of .NET implementations<ept id="p1">](../about/products.md)</ept> document to figure out all of the different editions of .NET that are available, both Microsoft's and others.</source>
          <target state="translated">В документе <bpt id="p1">[</bpt>Обзор реализаций .NET<ept id="p1">](../about/products.md)</ept> описаны все доступные выпуски платформы .NET, как корпорации Майкрософт, так и других разработчиков.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This Primer will help you understand some of the key concepts in the .NET Platform and point you to more resources for each given topic.</source>
          <target state="translated">Этот учебник познакомит вас с некоторыми основными понятиями платформы .NET и поможет найти дополнительные материалы по каждой из рассматриваемых тем.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>By the end of it, you should have enough information to be able to recognize significant terms and concepts in the .NET Platform and to know how to further your knowledge about them.</source>
          <target state="translated">Прочитав его полностью, вы получите достаточно информации, чтобы ориентироваться в основных терминах и концепциях платформы .NET и углублять знания в интересующих вас областях.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A stroll through .NET</source>
          <target state="translated">Обзор .NET</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>As any mature and advanced application development framework, .NET has many powerful features that make the developer's job easier and aim to make writing code more powerful and expressive.</source>
          <target state="translated">Как любая зрелая и полнофункциональная платформа разработки приложений, .NET имеет множество эффективных функций, которые облегчают труд разработчиков и делают процесс написания кода более оптимальным и выразительным.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This section will outline the basics of the most salient features and provide pointers to more detailed discussions where needed.</source>
          <target state="translated">В этом разделе приведены общие сведения о наиболее существенных возможностях и даны ссылки на более подробные материалы.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>After finishing this stroll, you should have enough information to be able to read the samples on our GitHub repos as well as other code and understand what is going on.</source>
          <target state="translated">После ознакомления с обзором вы получите достаточно информации для чтения примеров в репозиториях GitHub и другого кода, чтобы понимать, что там происходит.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Programming languages<ept id="p1">](#programming-languages)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Языки программирования<ept id="p1">](#programming-languages)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Automatic memory management<ept id="p1">](#automatic-memory-management)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Автоматическое управление памятью<ept id="p1">](#automatic-memory-management)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type safety<ept id="p1">](#type-safety)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Безопасность типов<ept id="p1">](#type-safety)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](#delegates-and-lambdas)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Делегаты и лямбда-выражения<ept id="p1">](#delegates-and-lambdas)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types (Generics)<ept id="p1">](#generic-types-generics)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Универсальные типы (универсальные шаблоны)<ept id="p1">](#generic-types-generics)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Language Integrated Query (LINQ)<ept id="p1">](#language-integrated-query-linq)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>LINQ<ept id="p1">](#language-integrated-query-linq)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Async programming<ept id="p1">](#async-programming)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Асинхронное программирование<ept id="p1">](#async-programming)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Native interoperability<ept id="p1">](#native-interoperability)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Взаимодействие на уровне машинного кода<ept id="p1">](#native-interoperability)</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Unsafe code<ept id="p1">](#unsafe-code)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Небезопасный код<ept id="p1">](#unsafe-code)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Programming languages</source>
          <target state="translated">Языки программирования</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>As a developer, you can choose any programming language that supports .NET to create your application.</source>
          <target state="translated">Разработчики могут создавать приложения на любом языке программирования, поддерживающем платформу .NET.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Because .NET provides language independence and interoperability, you can interact with other .NET applications and components regardless of the language with which they were developed.</source>
          <target state="translated">Поскольку платформа .NET обеспечивает независимость и взаимодействие языков, вы можете взаимодействовать с другими приложениями и компонентами платформы .NET независимо от языка, с помощью которого они были разработаны.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Languages that allow you to develop applications for the .NET Platform adhere to the <bpt id="p1">[</bpt>Common Language Infrastructure (CLI) specification<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>.</source>
          <target state="translated">Языки программирования, позволяющие разрабатывать приложения для платформы .NET, соответствуют <bpt id="p1">[</bpt>спецификации Common Language Infrastructure (CLI)<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Microsoft languages that .NET supports include C#, F#, and Visual Basic.</source>
          <target state="translated">К языкам корпорации Майкрософт, поддерживаемым платформой .NET, относятся C#, F# и Visual Basic.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages.</source>
          <target state="translated">C# — это простой, эффективный, типобезопасный и объектно-ориентированный язык, сохраняющий выразительность и элегантность, присущую языкам C.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Anyone familiar with C and similar languages will find few problems in adapting to C#.</source>
          <target state="translated">Все, кто знаком с C и схожими языками, смогут без проблем перейти на C#.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</source>
          <target state="translated">F# — это кроссплатформенный и функционально-императивный язык программирования, который также поддерживает объектно-ориентированное и императивное программирование.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.</source>
          <target state="translated">Visual Basic — это простой язык, позволяющий научиться разрабатывать разнообразные приложения на платформе .NET.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In the current release of .NET Core, only C# is fully supported across all Microsoft tools.</source>
          <target state="translated">В текущем выпуске .NET Core для всех инструментов Майкрософт полностью поддерживается только C#.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>F# is supported in the .NET Core SDK, but does not have Visual Studio tooling yet.</source>
          <target state="translated">F# поддерживается в пакете SDK для .NET Core, но пока не имеет инструментов Visual Studio.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Visual Basic support for the SDK and Visual Studio tooling are coming.</source>
          <target state="translated">Поддержка Visual Basic для пакета SDK и инструментов Visual Studio запланирована к реализации.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Automatic memory management</source>
          <target state="translated">Автоматическое управление памятью</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Garbage collection is the most well-known of .NET features.</source>
          <target state="translated">Сборка мусора является наиболее известной функцией .NET.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Developers do not need to actively manage memory, although there are mechanisms to provide more information to the garbage collector (GC).</source>
          <target state="translated">Разработчикам не требуется активно управлять памятью, хотя существуют механизмы для предоставления дополнительных сведений сборщику мусора.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>C# includes the <ph id="ph1">`new`</ph> keyword to allocate memory in terms of a particular type, and the <ph id="ph2">`using`</ph> keyword to provide scope for the usage of the object.</source>
          <target state="translated">C# содержит ключевое слово <ph id="ph1">`new`</ph> для выделения памяти в отношении определенного типа и ключевое слово <ph id="ph2">`using`</ph> для предоставления области использования объекта.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.</source>
          <target state="translated">Сборщик мусора отражает отложенный подход к управлению памятью, когда пропускная способность приложения предпочитается немедленной сборке памяти.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following two lines both allocate memory:</source>
          <target state="translated">Обе приведенные ниже строки выделяют память:</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>There is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled running.</source>
          <target state="translated">Аналогичных ключевых слов для отмены выделения памяти не существует, так как она осуществляется автоматически, когда сборщик мусора освобождает память в рамках запланированного выполнения.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Method variables normally go out of scope once a method completes, at which point they can be collected.</source>
          <target state="translated">Переменные метода обычно выходят за пределы области действия после завершения метода, после чего они могут быть собраны.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the <ph id="ph1">`using`</ph> statement.</source>
          <target state="translated">Однако с помощью оператора <ph id="ph1">`using`</ph> сборщику мусора можно указать, что определенный объект выходит из области действия еще до завершения метода.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Once the <ph id="ph1">`using`</ph> block completes, the GC will know that the <ph id="ph2">`stream`</ph> object in the example above is free to be collected and its memory reclaimed.</source>
          <target state="translated">После завершения блока <ph id="ph1">`using`</ph> сборщик мусора будет знать, что объект <ph id="ph2">`stream`</ph> в приведенном выше примере можно собрать для освобождения памяти.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>One of the less obvious but quite far-reaching features that a garbage collector enables is memory safety.</source>
          <target state="translated">Одной из менее очевидных, но довольно перспективных функций сборщика мусора является безопасность памяти.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).</source>
          <target state="translated">Инвариантность безопасности памяти очень проста: программа является безопасной с точки зрения памяти, если обращается только к выделенной (и не освобожденной) памяти.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Dangling pointers are always bugs, and tracking them down is often quite difficult.</source>
          <target state="translated">Оборванные указатели всегда являются ошибками, и их отслеживание часто затруднено.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The .NET runtime provides additional services, to complete the promise of memory safety, not naturally offered by a GC.</source>
          <target state="translated">Среда выполнения .NET предоставляет дополнительные службы для выполнения обещания по безопасности памяти, чего обычно нет в сборщике мусора.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>It ensures that programs do not index off the end of an array or accessing a phantom field off the end of an object.</source>
          <target state="translated">Она гарантирует, что программы не выйдут за пределы массива и не будут обращаться к фантомным полям после окончания объекта.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The following example will throw an exception as a result of memory safety.</source>
          <target state="translated">Следующий пример вызывает исключение в результате безопасности памяти.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Type safety</source>
          <target state="translated">Безопасность типа</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Objects are allocated in terms of types.</source>
          <target state="translated">Объекты выделяются с учетом типов.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The only operations allowed for a given object, and the memory it consumes, are those of its type.</source>
          <target state="translated">Разрешенные операции и занимаемая память для заданного объекта определяются его типом.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dog`</ph> type may have <ph id="ph2">`Jump`</ph> and <ph id="ph3">`WagTail`</ph> methods, but not likely a <ph id="ph4">`SumTotal`</ph> method.</source>
          <target state="translated">Тип <ph id="ph1">`Dog`</ph> может иметь методы <ph id="ph2">`Jump`</ph> и <ph id="ph3">`WagTail`</ph>, но не метод <ph id="ph4">`SumTotal`</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A program can only call the declared methods of a given type.</source>
          <target state="translated">Программа может вызывать только объявленные методы заданного типа.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or <ph id="ph1">`object`</ph>).</source>
          <target state="translated">Все другие вызовы приведут к ошибке во время компиляции или исключению во время выполнения (при использовании динамических функций или <ph id="ph1">`object`</ph>).</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>.NET languages are object-oriented, with hierarchies of base and derived classes.</source>
          <target state="translated">Языки .NET являются объектно-ориентированными и имеют иерархии базовых и производных классов.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The .NET runtime will only allow object casts and calls that align with the object hierarchy.</source>
          <target state="translated">Среда выполнения .NET допускает только те приведения и вызовы объектов, которые соответствуют иерархии объектов.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Remember that every type defined in any .NET language derives from the base <ph id="ph1">`object`</ph> type.</source>
          <target state="translated">Помните, что любой тип, определенный в любом языке .NET, является производным от базового типа <ph id="ph1">`object`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</source>
          <target state="translated">Безопасность типа также используется для принудительной инкапсуляции, обеспечивая точность ключевых слов метода доступа.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Accessor keywords are artifacts which control access to members of a given type by other code.</source>
          <target state="translated">Ключевые слова метода доступа являются артефактами, которые управляют доступом к членам определенного типа из другого кода.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>These are usually used for various kinds of data within a type that are used to manage its behavior.</source>
          <target state="translated">Обычно они используются для различных видов данных внутри типа, которые позволяют управлять его поведением.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Some .NET languages support <bpt id="p1">**</bpt>type inference<ept id="p1">**</ept>.</source>
          <target state="translated">Некоторые языки .NET поддерживают <bpt id="p1">**</bpt>определение типа<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side.</source>
          <target state="translated">Определение типа означает, что компилятор выводит тип выражения в левой части из выражения в правой части.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This doesn't mean that the type safety is broken or avoided.</source>
          <target state="translated">Это не значит, что безопасность типа нарушается или исключается.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The resulting type <bpt id="p1">**</bpt>has<ept id="p1">**</ept> a strong type with everything that implies.</source>
          <target state="translated">Результирующий тип <bpt id="p1">**</bpt>имеет<ept id="p1">**</ept> строгий тип со всем, что подразумевается.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Let's rewrite the first two lines of the previous example to introduce type inference.</source>
          <target state="translated">Давайте перепишем две первые строки в предыдущем примере, чтобы ввести определение типа.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You will note that the rest of the example is completely the same.</source>
          <target state="translated">Обратите внимание, что остальная часть примера не меняется.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">Делегаты и лямбда-выражения</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Delegates are like C++ function pointers, with a big difference that they are type safe.</source>
          <target state="translated">Делегаты похожи на указатели функций в C++, однако имеют значительное отличие — безопасность типа.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>They are a kind of disconnected method within the CLR type system.</source>
          <target state="translated">Они представляют собой разновидность отключенного метода в системе типов CLR.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Regular methods are attached to a class and only directly callable through static or instance calling conventions.</source>
          <target state="translated">Обычные методы присоединены к классу и вызываются только напрямую с помощью соглашений о статических вызовах или вызовах экземпляров.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Delegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.</source>
          <target state="translated">Делегаты используются в различных API и компонентах .NET, особенно через лямбда-выражения, которые являются основой LINQ.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept> document.</source>
          <target state="translated">Дополнительные сведения см. в документе <bpt id="p1">[</bpt>Делегаты и лямбда-выражения<ept id="p1">](delegates-lambdas.md)</ept>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Generic types (Generics)</source>
          <target state="translated">Универсальные типы (универсальные шаблоны)</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Generic types, also commonly called "generics", are a feature that was added in .NET Framework 2.0.</source>
          <target state="translated">Универсальные типы, которые также называют "универсальными шаблонами", были добавлены в .NET Framework 2.0.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In short, generics allow the programmer to introduce a "type parameter" when designing their classes, that will allow the client code (the users of the type) to specify the exact type to use in place of the type parameter.</source>
          <target state="translated">Проще говоря, универсальные шаблоны позволяют программисту при разработке своих классов ввести "параметр типа", который позволит клиентскому коду (пользователям типа) указать точный тип, используемый вместо параметра типа.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Generics were added in order to help programmers implement generic data structures.</source>
          <target state="translated">Универсальные шаблоны были добавлены, чтобы помочь программистам реализовывать универсальные структуры данных.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Before their arrival, in order for a, say, <bpt id="p1">_</bpt>List<ept id="p1">_</ept> type to be generic, it would have to work with elements that were of type <bpt id="p2">_</bpt>object<ept id="p2">_</ept>.</source>
          <target state="translated">До их появления, чтобы тип <bpt id="p1">_</bpt>List<ept id="p1">_</ept> был универсальным, он должен был работать с элементами, имеющими тип <bpt id="p2">_</bpt>object<ept id="p2">_</ept>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This would have various performance as well as semantic problems, not to mention possible subtle runtime errors.</source>
          <target state="translated">Это бы вызвало различные проблемы, связанные с производительностью и семантикой, а также неочевидные ошибки во время выполнения.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <bpt id="p1">_</bpt>InvalidCastException<ept id="p1">_</ept> is thrown on working with the list's members.</source>
          <target state="translated">Наиболее печально известным вариантом последних является ситуация, когда структура данных содержит, например, как целые числа, так и строки, и при работе с элементами списка возникает <bpt id="p1">_</bpt>InvalidCastException<ept id="p1">_</ept>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The below sample shows a basic program running using an instance of <ph id="ph1">@System.Collections.Generic.List%601</ph> types.</source>
          <target state="translated">В следующем примере показано выполнение простой программы с использованием экземпляра типов <ph id="ph1">@System.Collections.Generic.List%601</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept> article.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Обзор универсальных типов (универсальных шаблонов)<ept id="p1">](generics.md)</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Async programming</source>
          <target state="translated">Асинхронное программирование</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Async programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs.</source>
          <target state="translated">Асинхронное программирование является одной из ключевых концепций на платформе .NET, включающей асинхронную поддержку среды выполнения, библиотек платформы и языковых конструкций .NET.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Internally, they are based off of objects (such as <ph id="ph1">`Task`</ph>) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</source>
          <target state="translated">На внутреннем уровне это основано на объектах (таких как <ph id="ph1">`Task`</ph>), которые используют возможности операционной системы для максимально эффективного выполнения заданий ввода-вывода.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>To learn more about async programming in .NET, start with the <bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об асинхронном программировании в .NET см. в разделе <bpt id="p1">[</bpt>Обзор асинхронной модели<ept id="p1">](async.md)</ept>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ)</source>
          <target state="translated">Синтаксис LINQ</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</source>
          <target state="translated">LINQ — это эффективный набор функций для C# и VB, которые позволяют писать простой и декларативный код для работы с данными.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!</source>
          <target state="translated">Данные могут быть представлены разными формами (например, объектами в памяти, содержимым базы данных SQL или XML-документом), но обычно создаваемый код LINQ не отличается для каждого из источников данных.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>To learn more and see some samples, check out <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</source>
          <target state="translated">Для получения дополнительных сведений и ознакомления с примерами см. раздел <bpt id="p1">[</bpt>Синтаксис LINQ<ept id="p1">](using-linq.md)</ept>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">Взаимодействие на уровне машинного кода</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Every operating system in current use provides a lot of platform support for various programming tasks.</source>
          <target state="translated">Все используемые в настоящее время операционные системы предоставляют значительную платформенную поддержку для различных задач программирования.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>.NET provides several ways to tap into those APIs.</source>
          <target state="translated">.NET предоставляет несколько способов использовать эти API.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Collectively, this support is called "native interoperability" and in this section we will take a look at how to access native APIs from managed, .NET code.</source>
          <target state="translated">В совокупности такая поддержка называется "взаимодействием на уровне машинного кода". В этом разделе мы рассмотрим, как обратиться к собственным API из управляемого кода .NET.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The main way to do native interoperability is via "platform invoke" or P/Invoke for short.</source>
          <target state="translated">Основным способом осуществления такого взаимодействия является вызов неуправляемого кода или сокращенно P/Invoke.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This support in .NET Core is available across Linux and Windows platforms.</source>
          <target state="translated">Такая поддержка в .NET Core доступна на платформах Windows и Linux.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Another, Windows-only way of doing native interoperability is known as "COM interop" which is used to work with <bpt id="p1">[</bpt>COM components<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in managed code.</source>
          <target state="translated">Другой способ, который подходит только для Windows, называется "COM-взаимодействием" и используется для работы с <bpt id="p1">[</bpt>COM-компонентами<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> в управляемом коде.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It is built on top of P/Invoke infrastructure, but it works in subtly different ways.</source>
          <target state="translated">Он основан на инфраструктуре P/Invoke, но работает иначе.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</source>
          <target state="translated">Основная часть поддержки взаимодействия Mono (и, следовательно, Xamarin) для Java и Objective-C построена аналогичным образом, то есть использует схожие принципы.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept> document.</source>
          <target state="translated">Дополнительные сведения см. в документе <bpt id="p1">[</bpt>Взаимодействие на уровне машинного кода<ept id="p1">](native-interop.md)</ept>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Unsafe code</source>
          <target state="translated">Небезопасный код</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The CLR enables the ability to access native memory and do pointer arithmetic via <ph id="ph1">`unsafe`</ph> code.</source>
          <target state="translated">Среда CLR позволяет обращаться к внутренней памяти и выполнять арифметические операции с указателями в коде <ph id="ph1">`unsafe`</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>These operations are needed for certain algorithms and system interoperability.</source>
          <target state="translated">Эти операции необходимы для реализации определенных алгоритмов и системного взаимодействия.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm.</source>
          <target state="translated">Хотя небезопасный код и предоставляет обширные возможности, использовать его не рекомендуется, если только это не требуется для взаимодействия с системными API или реализации максимально эффективного алгоритма.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety.</source>
          <target state="translated">Небезопасный код может выполняться по-разному в разных средах, а также теряет преимущества сборщика мусора и безопасности типов.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.</source>
          <target state="translated">Рекомендуется четко отделить и централизовать небезопасный код, а также тщательно протестировать его.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ToString()`</ph> method from the <bpt id="p1">[</bpt>StringBuilder class<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327)</ept> illustrates how using <ph id="ph2">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:</source>
          <target state="translated">Метод <ph id="ph1">`ToString()`</ph> из <bpt id="p1">[</bpt>класса StringBuilder<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327)</ept> иллюстрирует, как с помощью кода <ph id="ph2">`unsafe`</ph> можно эффективно реализовать алгоритм, перемещая блоки памяти напрямую:</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Примечания</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The term ".NET runtime" is used throughout the document to accommodate for the multiple implementations of .NET, such as CLR, Mono, IL2CPP and others.</source>
          <target state="translated">Используемый в документе термин "среда выполнения .NET" включает в себя несколько разных реализаций .NET, таких как CLR, Mono, IL2CPP и другие.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The more specific names are only used if needed.</source>
          <target state="translated">Конкретные названия указываются только по мере необходимости.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>This document is not intended to be historical in nature, but describe the .NET platform as it is now.</source>
          <target state="translated">Этот документ не предназначен для обзора истории продукта, а описывает платформу .NET в том виде, который она имеет сейчас.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It isn't important whether a .NET feature has always been available or was only recently introduced, only that it is important enough to highlight and discuss.</source>
          <target state="translated">Значение имеет не то, был ли компонент .NET доступен с самого начала или появился лишь недавно, а то, насколько этот компонент важен и заслуживает рассмотрения.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>