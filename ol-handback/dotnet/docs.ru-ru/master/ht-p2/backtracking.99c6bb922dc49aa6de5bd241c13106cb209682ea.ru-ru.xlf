<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">649dfd6752f0589eb396b00e7d0b5184bb65d488</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\backtracking.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3c3f4b81cf190742fd47a71d366c45ef3d12d49</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">44f9547568980ddd9867439669c8bc02c62fd81a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Backtracking in regular expressions</source>
          <target state="translated">Поиск с возвратом в регулярных выражениях</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Backtracking in regular expressions</source>
          <target state="translated">Поиск с возвратом в регулярных выражениях</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Backtracking in regular expressions</source>
          <target state="translated">Поиск с возвратом в регулярных выражениях</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Backtracking occurs when a regular expression pattern contains optional <bpt id="p1">[</bpt>quantifiers<ept id="p1">](quantifiers.md)</ept> or <bpt id="p2">[</bpt>alternation constructs<ept id="p2">](alternation.md)</ept>, and the regular expression engine returns to a previous saved state to continue its search for a match.</source>
          <target state="translated">Поиск с возвратом происходит, если шаблон регулярного выражения содержит переменные <bpt id="p1">[</bpt>квантификаторы<ept id="p1">](quantifiers.md)</ept> или <bpt id="p2">[</bpt>конструкции изменения<ept id="p2">](alternation.md)</ept>, и обработчик регулярных выражений возвращается в предыдущее сохраненное состояние, чтобы продолжить поиск совпадения.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</source>
          <target state="translated">В поиске с возвратом заключена сила регулярных выражений. Благодаря ему выражения могут быть мощными и гибкими, а также совпадать со сложными шаблонами.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>At the same time, this power comes at a cost.</source>
          <target state="translated">С другой стороны, эти возможности дорого обходятся.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Backtracking is often the single most important factor that affects the performance of the regular expression engine.</source>
          <target state="translated">Часто именно поиск с возвратом существенно снижает производительность обработчика регулярных выражений.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</source>
          <target state="translated">К счастью, разработчик может управлять работой обработчика регулярных выражений и тем, как он использует поиск с возвратом.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This topic explains how backtracking works and how it can be controlled.</source>
          <target state="translated">В этом разделе описано, как функционирует поиск с возвратом, и как им можно управлять.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In general, a Nondeterministic Finite Automaton (NFA) engine like the  regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</source>
          <target state="translated">В целом при использовании NFA-машины (недетерминированного конечного автомата), такой как обработчик регулярных выражений .NET, ответственность за создание эффективных и быстро выполняемых регулярных выражений лежит на разработчике.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections:</source>
          <target state="translated">В этом разделе содержатся следующие подразделы.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Linear comparison without backtracking<ept id="p1">](#linear-comparison-without-backtracking)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Линейное сравнение без поиска с возвратом<ept id="p1">](#linear-comparison-without-backtracking)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking with optional quantifiers or alternation constructs<ept id="p1">](#backtracking-with-optional-quantifiers-or-alternation-constructs)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Поиск с возвратом с необязательными квантификаторами и конструкциями чередования<ept id="p1">](#backtracking-with-optional-quantifiers-or-alternation-constructs)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking with nested optional quantifiers<ept id="p1">](#backtracking-with-nested-optional-quantifiers)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Поиск с возвратом со вложенными необязательными квантификаторами<ept id="p1">](#backtracking-with-nested-optional-quantifiers)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Controlling backtracking<ept id="p1">](#controlling-backtracking)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Управление поиском с возвратом<ept id="p1">](#controlling-backtracking)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Linear comparison without backtracking</source>
          <target state="translated">Линейное сравнение без поиска с возвратом</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</source>
          <target state="translated">Если шаблон регулярного выражения не содержит переменных квантификаторов или конструкций изменения, обработчик регулярных выражений работает за линейное время.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</source>
          <target state="translated">Это значит, что когда обработчик регулярных выражений находит совпадение с первым языковым элементом шаблона в тексте входной строки, он сопоставляет следующий языковой элемент шаблона со следующим символом или группой символов входной строки.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This continues until the match either succeeds or fails.</source>
          <target state="translated">Так продолжается, пока поиск совпадения не заканчивается успешно или неуспешно.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In either case, the regular expression engine advances by one character at a time in the input string.</source>
          <target state="translated">В обоих случаях обработчик регулярных выражений продвигается вперед, обрабатывая по одному символу входной строки.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">Ниже приведен пример.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`e{2}\w\b`</ph> looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</source>
          <target state="translated">Регулярное выражение <ph id="ph1">`e{2}\w\b`</ph> ищет следующую строку: два вхождения буквы «e», затем символ слова, затем граница слова.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Although this regular expression includes the quantifier <ph id="ph1">`{2}`</ph>, it is evaluated in a linear manner.</source>
          <target state="translated">Несмотря на то что это регулярное выражение содержит квантификатор <ph id="ph1">`{2}`</ph>, оно обрабатывается линейным образом.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The regular expression engine does not backtrack because <ph id="ph1">`{2}`</ph> is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</source>
          <target state="translated">Обработчик регулярных выражений не выполняет поиск с возвратом, поскольку квантификатор <ph id="ph1">`{2}`</ph> не является переменным квантификатором; он указывает конкретное, а не переменное число вхождений предшествующей части выражения.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</source>
          <target state="translated">В результате обработчик регулярных выражений ищет совпадение с шаблоном во входной строке, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Операция</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Position in pattern</source>
          <target state="translated">Положение в шаблоне</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Position in string</source>
          <target state="translated">Положение в строке</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Результат</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">й</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>"needing a reed" (index 0)</source>
          <target state="translated">"needing a reed" (позиция 0)</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Нет совпадения.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">й</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>"eeding a reed" (index 1)</source>
          <target state="translated">"eeding a reed" (позиция 1)</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Возможное совпадение.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>e{2}</source>
          <target state="translated">e{2}</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>"eding a reed" (index 2)</source>
          <target state="translated">"eding a reed" (позиция 2)</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Возможное совпадение.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>\w</source>
          <target state="translated">\w</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>"ding a reed" (index 3)</source>
          <target state="translated">"ding a reed" (позиция 3)</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Возможное совпадение.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="translated">5</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>\b</source>
          <target state="translated">\b</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>"ing a reed" (index 4)</source>
          <target state="translated">"ing a reed" (позиция 4)</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Possible match fails.</source>
          <target state="translated">Совпадение не подтвердилось.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>6</source>
          <target state="translated">6</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">й</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>"eding a reed" (index 2)</source>
          <target state="translated">"eding a reed" (позиция 2)</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Возможное совпадение.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>7</source>
          <target state="translated">7</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>e{2}</source>
          <target state="translated">e{2}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>"ding a reed" (index 3)</source>
          <target state="translated">"ding a reed" (позиция 3)</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Possible match fails.</source>
          <target state="translated">Совпадение не подтвердилось.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>8</source>
          <target state="translated">8</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">й</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>"ding a reed" (index 3)</source>
          <target state="translated">"ding a reed" (позиция 3)</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Match fails.</source>
          <target state="translated">Совпадение отсутствует.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>9</source>
          <target state="translated">9</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">й</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>"ing a reed" (index 4)</source>
          <target state="translated">"ing a reed" (позиция 4)</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Нет совпадения.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>10</source>
          <target state="translated">10</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">й</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>"ng a reed" (index 5)</source>
          <target state="translated">"ng a reed" (позиция 5)</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Нет совпадения.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>11</source>
          <target state="translated">11</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">й</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>"g a reed" (index 6)</source>
          <target state="translated">"g a reed" (позиция 6)</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Нет совпадения.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>12</source>
          <target state="translated">12</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">й</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>" a reed" (index 7)</source>
          <target state="translated">" a reed" (позиция 7)</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Нет совпадения.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>13</source>
          <target state="translated">13</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">й</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>"a reed" (index 8)</source>
          <target state="translated">a reed (позиция 8)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Нет совпадения.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">й</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>" reed" (index 9)</source>
          <target state="translated">" reed" (позиция 9)</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>No match.</source>
          <target state="translated">Нет совпадения.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">й</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>"reed" (index 10)</source>
          <target state="translated">reed (позиция 10)</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>No match</source>
          <target state="translated">Нет совпадения.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">й</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>"eed" (index 11)</source>
          <target state="translated">"eed" (позиция 11)</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Возможное совпадение.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>e{2}</source>
          <target state="translated">e{2}</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>"ed" (index 12)</source>
          <target state="translated">"ed" (позиция 12)</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Возможное совпадение.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>\w</source>
          <target state="translated">\w</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>"d" (index 13)</source>
          <target state="translated">"d" (позиция 13)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
          <target state="translated">Возможное совпадение.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>\b</source>
          <target state="translated">\b</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>"" (index 14)</source>
          <target state="translated">"" (позиция 14)</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Match.</source>
          <target state="translated">Совпадение.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</source>
          <target state="translated">Если в шаблоне регулярного выражения нет переменных квантификаторов или конструкций изменения, максимальное число сравнений, необходимое для поиска во входной строке совпадения с шаблоном регулярного выражения, примерно равно числу символов во входной строке.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</source>
          <target state="translated">В этом случае обработчик регулярных выражений использует 19 сравнений, чтобы определить возможные совпадения в этой 13-значной строке.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</source>
          <target state="translated">Другими словами, обработчик регулярных выражений работает почти за линейное время, если отсутствуют переменные квантификаторы или конструкции изменения.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Backtracking with optional quantifiers or alternation constructs</source>
          <target state="translated">Поиск с возвратом с необязательными квантификаторами и конструкциями чередования</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</source>
          <target state="translated">Если регулярное выражение содержит переменные квантификаторы или конструкции изменения, оценка входной строки уже не может быть линейной.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</source>
          <target state="translated">При использовании NFA-машины сопоставление шаблонов определяется языковыми элементами регулярного выражения, а не символами входной строки.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</source>
          <target state="translated">Поэтому обработчик регулярных выражений пытается найти полное совпадение для переменных подвыражений или подвыражений выбора.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</source>
          <target state="translated">При переходе к следующему языковому элементу подвыражения и нарушении совпадения обработчик регулярных выражений отбрасывает совпавшую часть и возвращается к ранее сохраненному состоянию; ему снова требуется найти во входной строке совпадение с регулярным выражением целиком.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This process of returning to a previous saved state to find a match is known as backtracking.</source>
          <target state="translated">Процесс возвращения к ранее сохраненному состоянию для поиска совпадения называется "поиск с возвратом".</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>For example, consider the regular expression pattern <ph id="ph1">`.*(es)`</ph>, which matches the characters "es" and all the characters that precede it.</source>
          <target state="translated">Например, рассмотрим шаблон регулярного выражения <ph id="ph1">`.*(es)`</ph>, совпадающий с символами "es" и любыми предшествующими символам.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</source>
          <target state="translated">Как показано в следующем примере, если взять входную строку "Essential services are provided by regular expressions.", совпадать с шаблоном будет вся строка до букв "es" в слове "expressions" включительно.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>To do this, the regular expression engine uses backtracking as follows:</source>
          <target state="translated">В этом случае обработчик регулярных выражений использует поиск с возвратом следующим образом.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It matches the <ph id="ph1">`.*`</ph> (which matches zero, one, or more occurrences of any character) with the whole input string.</source>
          <target state="translated">Обработчик обнаруживает совпадение части выражения <ph id="ph1">`.*`</ph> (что соответствует любому числу любых символов) со всей входной строкой.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It attempts to match "e" in the regular expression pattern.</source>
          <target state="translated">Затем обработчик ищет совпадение для символа "e" шаблона регулярного выражения.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>However, the input string has no remaining characters available to match.</source>
          <target state="translated">Однако во входной строке нет больше символов для поиска совпадения.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</source>
          <target state="translated">Обработчик возвращается к месту последнего успешного совпадения, "Essential services are provided by regular expressions", и сравнивает символ "e" с точкой в конце предложения.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The match fails.</source>
          <target state="translated">Совпадение отсутствует.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</source>
          <target state="translated">Обработчик продолжает возвращаться к предыдущим успешным совпадениям, отступая по одному символу, пока предположительно подходящей подстрокой не становится подстрока "Essential services are provided by regular expr".</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</source>
          <target state="translated">Затем обработчик сравнивает символ "e" шаблона со второй буквой "e" в слове "expressions" и обнаруживает совпадение.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</source>
          <target state="translated">Затем он сравнивает символ "s" шаблона с символом "s" после символа "e" в строке (первая буква "s" в слове "expressions").</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The match is successful.</source>
          <target state="translated">Совпадение успешно.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</source>
          <target state="translated">При использовании поиска с возвратом поиск совпадения шаблона регулярного выражения со входной строкой длиной 55 символов требует 67 операций сравнения.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Interestingly, if the regular expression pattern included a lazy quantifier, <ph id="ph1">`.*?(es),`</ph> matching the regular expression would require additional comparisons.</source>
          <target state="translated">Интересно, что если шаблон регулярного выражения включает ленивый квантификатор <ph id="ph1">`.*?(es),`</ph>, поиск совпадения потребует дополнительных операций сравнения.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>In this case, instead of having to backtrack from the end of the string to the "r" in "expressions", the regular expression engine would have to backtrack all the way to the beginning of the string to match "Es" and would require 113 comparisons.</source>
          <target state="translated">В этом случае вместо обратного поиска от конца строки до символа "r" в слове "expressions" обработчику регулярных выражений придется выполнить обратный поиск до начала строки в поисках "Es", что потребует 113 сравнений.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</source>
          <target state="translated">Как правило, если в шаблоне регулярного выражения есть один переменный квантификатор или одна конструкция изменения, число сравнений, необходимых для поиска во входной строке совпадения с шаблоном регулярного выражения, более чем вдвое превышает число символов во входной строке.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Backtracking with nested optional quantifiers</source>
          <target state="translated">Поиск с возвратом со вложенными необязательными квантификаторами</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</source>
          <target state="translated">Количество сравнений, необходимое для поиска во входной строке совпадения с шаблоном регулярного выражения, может увеличиваться экспоненциально, если шаблон включает большое количество конструкций изменения или вложенные конструкции изменения, или, что случается чаще, вложенные переменные квантификаторы.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`^(a+)+$`</ph> is designed to match a complete string that contains one or more "a" characters.</source>
          <target state="translated">Например, шаблон регулярного выражения <ph id="ph1">`^(a+)+$`</ph> должен совпадать со строкой, состоящей из одного и более символов "a".</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The example provides two input strings of identical length, but only the first string matches the pattern.</source>
          <target state="translated">В примере показаны две входные строки одинаковой длины, только одна из которых совпадает с шаблоном.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>System.Diagnostics.Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> class is used to determine how long the match operation takes.</source>
          <target state="translated">Класс <bpt id="p1">[</bpt>System.Diagnostics.Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> используется для определения времени выполнения операции поиска совпадения.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</source>
          <target state="translated">Как показывают выходные данные примера, у обработчика регулярных выражений установление отсутствия совпадения с шаблоном занимает в два раза больше времени, чем нахождение совпадения.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This is because an unsuccessful match always represents a worst-case scenario.</source>
          <target state="translated">Неуспешное совпадение — худший сценарий.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</source>
          <target state="translated">Обработчик регулярных выражений должен использовать регулярное выражение для проверки всех возможных путей в данных, чтобы заключить, что совпадения нет, а вложенные скобки сильно увеличивают количество таких путей.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The regular expression engine concludes that the second string did not match the pattern by doing the following:</source>
          <target state="translated">Чтобы установить, что вторая строка не совпадает с шаблоном, обработчику регулярных выражений нужно выполнить следующие действия:</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern a+.</source>
          <target state="translated">Он проверяет, что находится в начале строки, после чего проверяет первые пять символов строки на совпадение с шаблоном a+.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>It then determines that there are no additional groups of "a" characters in the string.</source>
          <target state="translated">Затем проверяет, что в строке нет других групп символов "a".</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Finally, it tests for the end of the string.</source>
          <target state="translated">Затем выполняется проверка до конца строки.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Because one additional character remains in the string, the match fails.</source>
          <target state="translated">Поскольку в строке содержится один дополнительный символ, проверка оказывается неудачной.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>This failed match requires 9 comparisons.</source>
          <target state="translated">Этот отрицательный результат требует 9 сравнений.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</source>
          <target state="translated">Обработчик регулярных выражений также сохраняет информацию о состоянии при совпадениях "a" (совпадение 1), "aa" (совпадение 2), "aaa" (совпадение 3) и "aaaa" (совпадение 4).</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>It returns to the previously saved match 4.</source>
          <target state="translated">Затем он возвращается к предварительно сохраненному совпадению 4.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>It determines that there is one additional "a" character to assign to an additional captured group.</source>
          <target state="translated">Далее устанавливается наличие дополнительного символа "a", который назначается дополнительной захваченной группе.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Finally, it tests for the end of the string.</source>
          <target state="translated">Затем выполняется проверка до конца строки.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Because one additional character remains in the string, the match fails.</source>
          <target state="translated">Поскольку в строке содержится один дополнительный символ, проверка оказывается неудачной.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This failed match requires 4 comparisons.</source>
          <target state="translated">Этот отрицательный результат требует 4 сравнений.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>So far, a total of 13 comparisons have been performed.</source>
          <target state="translated">Таким образом, всего выполнено 13 сравнений.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>It returns to the previously saved match 3.</source>
          <target state="translated">Затем он возвращается к предварительно сохраненному совпадению 3.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>It determines that there are two additional "a" characters to assign to an additional captured group.</source>
          <target state="translated">Он устанавливает наличие двух дополнительных символов "a", которые назначаются дополнительной захваченной группе.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>However, the end-of-string test fails.</source>
          <target state="translated">Однако проверка на наличие окончания строки не проходит.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</source>
          <target state="translated">Обработчик возвращается к совпадению 3 и пытается сопоставить два дополнительных символа "a" с двумя дополнительными захваченными группами.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The end-of-string test still fails.</source>
          <target state="translated">Проверка на наличие окончания строки не проходит.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>These failed matches require 12 comparisons.</source>
          <target state="translated">Для получения этих неуспешных совпадений потребовалось 12 сравнений.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>So far, a total of 25 comparisons have been performed.</source>
          <target state="translated">Таким образом, всего выполнено 25 сравнений.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</source>
          <target state="translated">Сравнение входной строки с регулярным выражением продолжается таким же образом, пока обработчик регулярных выражений не переберет все возможные комбинации совпадений, заключив, что совпадений нет.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Because of the nested quantifiers, this comparison is an O(2n) or an exponential operation, where n is the number of characters in the input string.</source>
          <target state="translated">Из-за наличия вложенных квантификаторов это сравнение представляет собой операцию экспоненциальной сложности O(2n), где n — количество символов входной строки.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</source>
          <target state="translated">Это значит, что в худшем случае входная строка, состоящая из 30 символов, требует по примерным подсчетам 1 073 741 824 сравнений, а входная строка длиной 40 символов — 1 099 511 627 776 сравнений.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</source>
          <target state="translated">При использовании строк такого или большего размера методы, выполняющие регулярные выражения, могут выполняться очень долго, прежде чем будет установлено, что входная строка не совпадает с шаблоном регулярного выражения.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Controlling backtracking</source>
          <target state="translated">Управление поиском с возвратом</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Backtracking lets you create powerful, flexible regular expressions.</source>
          <target state="translated">Поиск с возвратом позволяет создавать мощные и гибкие регулярные выражения.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</source>
          <target state="translated">Однако, как было показано в предыдущем разделе, эти преимущества могут сопровождаться неприемлемо низкой производительностью.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>To prevent excessive backtracking, you should define a time-out interval when you instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object or call a static regular expression matching method.</source>
          <target state="translated">Чтобы предотвратить излишнее использование поиска с возвратом, необходимо указать интервал времени ожидания при создании экземпляра объекта <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> или вызвать соответствующий метод статического регулярного выражения.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>This is discussed in the next section.</source>
          <target state="translated">Этот метод будет рассмотрен в следующем разделе.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>In addition, .NET Core supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: <bpt id="p1">[</bpt>nonbacktracking subexpressions<ept id="p1">](#nonbacktracking-subexpression)</ept>, <bpt id="p2">[</bpt>lookbehind assertions<ept id="p2">](#lookbehind-assertions)</ept>, and <bpt id="p3">[</bpt>lookahead assertions<ept id="p3">](#lookahead-assertions)</ept>.</source>
          <target state="translated">Кроме того, в .NET Core поддерживается три элемента языка регулярных выражений, ограничивающих или подавляющих поиск с возвратом, что позволяет выполнять сложные регулярные выражения при небольшом снижении производительности или без такового: <bpt id="p1">[</bpt>невозвращающиеся части выражения<ept id="p1">](#nonbacktracking-subexpression)</ept>, <bpt id="p2">[</bpt>утверждения просмотра назад<ept id="p2">](#lookbehind-assertions)</ept> и <bpt id="p3">[</bpt>утверждения просмотра вперед<ept id="p3">](#lookahead-assertions)</ept>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>For more information about each language element, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об этих элементах языка см. в разделе <bpt id="p1">[</bpt>Конструкции группировки в регулярных выражениях<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Defining a time-out interval</source>
          <target state="translated">Определение интервала времени ожидания</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>You can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> exception.</source>
          <target state="translated">Можно задать значение времени ожидания, которое равняется значению самого длинного интервала, необходимого обработчику регулярных выражений для выполнения поиска до первого совпадения, пока он не приостановит попытки найти соответствие и не вызовет исключение <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>You specify the time-out interval by supplying a <bpt id="p1">[</bpt>TimeSpan<ept id="p1">](xref:System.TimeSpan)</ept> value to the <ph id="ph1">`Regex(String, RegexOptions, TimeSpan)`</ph> constructor for instance regular expressions.</source>
          <target state="translated">Чтобы задать интервал ожидания, укажите значение <bpt id="p1">[</bpt>TimeSpan<ept id="p1">](xref:System.TimeSpan)</ept> в конструкторе <ph id="ph1">`Regex(String, RegexOptions, TimeSpan)`</ph> регулярных выражений экземпляра.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>In addition, each static pattern matching method has an overload with a <bpt id="p1">[</bpt>TimeSpan<ept id="p1">](xref:System.TimeSpan)</ept> value to the [Regex.Regex(String, RegexOptions, TimeSpan)] parameter that allows you to specify a time-out value.</source>
          <target state="translated">Кроме того, каждый статический метод сравнения с шаблоном имеет перегруженную версию значения <bpt id="p1">[</bpt>TimeSpan<ept id="p1">](xref:System.TimeSpan)</ept> с параметром [Regex.Regex(String, RegexOptions, TimeSpan)], который позволяет указать значение времени ожидания.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>By default, the time-out interval is set to <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept> and the regular expression engine does not time out.</source>
          <target state="translated">По умолчанию интервал времени ожидания задается в <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept>, и время ожидания обработчика регулярных выражений не истекает.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>We recommend th&gt;at you always set a time-out interval if your regular expression relies on backtracking.</source>
          <target state="translated">Рекомендуется всегда устанавливать интервал времени ожидания, если регулярное выражение использует поиск с возвратом.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept>n exception indicates that the regular expression engine was unable to find a match within in the specified time-out interval but does not indicate why the exception was thrown.</source>
          <target state="translated">Выражение <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> указывает на то, что обработчику регулярных выражений не удалось найти совпадение в пределах заданного интервала времени ожидания, но не указывает причину создания исключения.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</source>
          <target state="translated">Причина может быть как в излишнем поиске с возвратом, так и в недостаточном значении интервала времени ожидания для текущей загруженности системы на момент создания исключения.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</source>
          <target state="translated">При обработке исключения можно прервать дальнейший поиск совпадений входной строки или увеличить интервал времени ожидания и повторно выполнить операцию поиска.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>For example, the following code calls the <ph id="ph1">`Regex(String, RegexOptions, TimeSpan)`</ph> constructor to instantiate a Regex object with a time-out value of one second.</source>
          <target state="translated">Например, следующий код вызывает конструктор <ph id="ph1">`Regex(String, RegexOptions, TimeSpan)`</ph> для создания экземпляра объекта Regex со значением времени ожидания, равным одной секунде.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(a+)+$`</ph>, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`(a+)+$`</ph>, который сопоставляется с последовательностью из одного или нескольких символов "a" в конце строки, относится к шаблонам с чрезмерным использованием поиска с возвратом.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If a <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</source>
          <target state="translated">Если создается исключение <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept>, интервал времени ожидания в данном примере увеличивается до максимального значения, равного трем секундам.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>After that, it abandons the attempt to match the pattern.</source>
          <target state="translated">После этого попытки найти соответствие шаблону будут прерваны.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpression</source>
          <target state="translated">Невозвращающиеся подвыражения</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept> <bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element suppresses backtracking in a subexpression.</source>
          <target state="translated">Элемент языка <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept> <bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> подавляет поиск с возвратом в части выражения.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>It is useful for preventing the performance problems associated with failed matches.</source>
          <target state="translated">Это полезно для предотвращения проблем с производительностью, связанных с неуспешным совпадением.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</source>
          <target state="translated">В следующем примере показано, как подавление поиска с возвратом улучшает производительность при использовании вложенных квантификаторов.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</source>
          <target state="translated">В нем измеряется время, которое требуется обработчику регулярных выражений, чтобы определить, что входная строка не совпадает с двумя регулярными выражениями.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</source>
          <target state="translated">В первом регулярном выражении поиск с возвратом используется для поиска строки, содержащей последовательно одну и более шестнадцатеричных цифр, двоеточие, одну и более шестнадцатеричных цифр и два двоеточия.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The second regular expression is identical to the first, except that it disables backtracking.</source>
          <target state="translated">Второе регулярное выражение аналогично первому, но в нем отключен поиск с возвратом.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the performance improvement from disabling backtracking is significant.</source>
          <target state="translated">Как показывают выходные данные примера, отключение поиска с возвратом приводит к существенному росту производительности.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Lookbehind assertions</source>
          <target state="translated">Проверочные утверждения с просмотром назад</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>.NET includes two language elements, <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> and <bpt id="p4">**</bpt>(?&lt;!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept>, that match the previous character or characters in the input string.</source>
          <target state="translated">В платформу .NET входят два элемента языка, <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> и <bpt id="p4">**</bpt>(?&lt;!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept>, совпадающие с предыдущими символами во входной строке.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, without advancing or backtracking.</source>
          <target state="translated">Оба элемента языка являются утверждениями нулевой ширины; они определяют, должны ли символы, непосредственно предшествующие текущему, соответствовать <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>. Смещения или поиска с возвратом не происходит.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a positive lookbehind assertion; that is, the character or characters before the current position must match <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> — это утверждение положительного просмотра назад; символы, непосредственно предшествующие текущему, должны соответствовать <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a negative lookbehind assertion; that is, the character or characters before the current position must not match <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> — это утверждение отрицательного просмотра назад; символы, непосредственно предшествующие текущему, не должны соответствовать <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Both positive and negative lookbehind assertions are most useful when <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is a subset of the previous <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>.</source>
          <target state="translated">Утверждения положительного и отрицательного просмотра назад наиболее полезны, если <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> является подмножеством предыдущей <bpt id="p2">*</bpt>части выражения<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The following example uses two equivalent regular expression patterns that validate the user name in an e-mail address.</source>
          <target state="translated">В следующем примере используются два равнозначных шаблона регулярного выражения, проверяющих имя пользователя в адресе электронной почты.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The first pattern is subject to poor performance because of excessive backtracking.</source>
          <target state="translated">Первый шаблон демонстрирует низкую производительность из-за неоправданного использования поиска с возвратом.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</source>
          <target state="translated">Во втором шаблоне то же самое регулярное выражение изменено. Вложенный квантификатор заменен на утверждение положительного просмотра назад.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The output from the example displays the execution time of the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method.</source>
          <target state="translated">Выходные данные примера демонстрируют время выполнения метода <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The first regular expression pattern, <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*@, is defined as shown in the following table.`</ph></source>
          <target state="translated">Первый шаблон регулярного выражения, <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*@, is defined as shown in the following table.`</ph></target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
          <target state="translated">Совпадение с началом строки.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">Совпадение с алфавитно-цифровым символом.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option.</source>
          <target state="translated">Поскольку метод <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> вызывается с параметром <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>, сравнение не зависит от регистра символов.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Match zero, one, or more occurrences of a hyphen, period, or word character.</source>
          <target state="translated">Нуль и более совпадений с дефисом, точкой или символом слова.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">Совпадение с алфавитно-цифровым символом.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</source>
          <target state="translated">Ноль и более совпадений с комбинацией нуля и более дефисов, точек и символов слова, за которыми следует алфавитно-цифровой символ.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Это первая группа записи.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Match an at sign ("@").</source>
          <target state="translated">Совпадение со знаком "@".</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The second regular expression pattern, <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])@`</ph>, uses a positive lookbehind assertion.</source>
          <target state="translated">Второй шаблон регулярного выражения <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])@`</ph> использует утверждение положительного просмотра назад.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
          <target state="translated">Определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
          <target state="translated">Совпадение с началом строки.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">Совпадение с алфавитно-цифровым символом.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option.</source>
          <target state="translated">Поскольку метод <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> вызывается с параметром <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>, сравнение не зависит от регистра символов.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of a hyphen, period, or word character.</source>
          <target state="translated">Нуль и более совпадений с дефисом, точкой или символом слова.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Look back at the last matched character and continue the match if it is alphanumeric.</source>
          <target state="translated">Выполняется просмотр назад последнего совпавшего символа; поиск совпадения продолжается, если этот символ является алфавитно-цифровым.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</source>
          <target state="translated">Обратите внимание, что алфавитно-цифровой символ является подмножеством набора, образованного точкой, дефисом и всеми символами слова.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Match an at sign ("@").</source>
          <target state="translated">Совпадение со знаком "@".</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Lookahead assertions</source>
          <target state="translated">Проверочные утверждения с просмотром вперед</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>.NET includes two language elements, <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> and <bpt id="p4">**</bpt>(?!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept>, that match the next character or characters in the input string.</source>
          <target state="translated">В платформу .NET входят два элемента языка, <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> и <bpt id="p4">**</bpt>(?!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept>, совпадающие со следующими символами во входной строке.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, without advancing or backtracking.</source>
          <target state="translated">Оба элемента языка являются утверждениями нулевой ширины; они определяют, должны ли символы, непосредственно следующие за текущим, соответствовать <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>. Смещения или поиска с возвратом не происходит.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a positive lookahead assertion; that is, the character or characters after the current position must match <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> — это утверждение положительного просмотра вперед; символы, непосредственно следующие за текущим, должны соответствовать <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> is a negative lookahead assertion; that is, the character or characters after the current position must not match <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> — это утверждение отрицательного просмотра вперед; символы, непосредственно следующие за текущим, не должны соответствовать <bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Both positive and negative lookahead assertions are most useful when <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is a subset of the next <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>.</source>
          <target state="translated">Утверждения положительного и отрицательного просмотра вперед наиболее полезны, если <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> является подмножеством следующей <bpt id="p2">*</bpt>части выражения<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</source>
          <target state="translated">В следующем примере используются два одинаковых шаблона регулярного выражения, проверяющих полное имя типа.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The first pattern is subject to poor performance because of excessive backtracking.</source>
          <target state="translated">Первый шаблон демонстрирует низкую производительность из-за неоправданного использования поиска с возвратом.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</source>
          <target state="translated">Во втором шаблоне то же самое регулярное выражение изменено. Вложенный квантификатор заменен на утверждение положительного просмотра вперед.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The output from the example displays the execution time of the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method.</source>
          <target state="translated">Выходные данные примера демонстрируют время выполнения метода <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The first regular expression pattern, <ph id="ph1">`^(([A-Z]\w*)+\.)*[A-Z]\w*$`</ph>, is defined as shown in the following table.</source>
          <target state="translated">Первый шаблон регулярного выражения <ph id="ph1">`^(([A-Z]\w*)+\.)*[A-Z]\w*$`</ph> определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
          <target state="translated">Совпадение с началом строки.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</source>
          <target state="translated">Совпадение с алфавитным символом (A-Z), за которым следует ноль и более символов слова, повторенных ноль и более раз, за которыми следует точка.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option.</source>
          <target state="translated">Поскольку метод <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> вызывается с параметром <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>, сравнение не зависит от регистра символов.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Match the previous pattern zero or more times.</source>
          <target state="translated">Совпадение с предыдущим шаблоном ноль и более раз.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Match an alphabetical character followed by zero or more word characters.</source>
          <target state="translated">Совпадение с алфавитно-цифровым символом, за которым следует ноль и более символов слова.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>End the match at the end of the input string.</source>
          <target state="translated">Совпадение должно заканчиваться в конце входной строки.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The second regular expression pattern, <ph id="ph1">`^((?=[A-Z])\w+\.)*[A-Z]\w*$`</ph>, uses a positive lookahead assertion.</source>
          <target state="translated">Второй шаблон регулярного выражения <ph id="ph1">`^((?=[A-Z])\w+\.)*[A-Z]\w*$`</ph> использует утверждение положительного просмотра вперед.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
          <target state="translated">Определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
          <target state="translated">Совпадение с началом строки.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Look ahead to the first character and continue the match if it is alphabetical (A-Z).</source>
          <target state="translated">Выполняется просмотр вперед к следующему символу; если он является алфавитным (A-Z), продолжается поиск совпадения.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option.</source>
          <target state="translated">Поскольку метод <bpt id="p1">[</bpt>Regex.IsMatch<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> вызывается с параметром <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>, сравнение не зависит от регистра символов.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a period.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова, за которыми следует точка.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters followed by a period zero or more times.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова, за которым следует ноль и более точек.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The initial word character must be alphabetical.</source>
          <target state="translated">Первый символ слова должен быть алфавитным.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Match an alphabetical character followed by zero or more word characters.</source>
          <target state="translated">Совпадение с алфавитно-цифровым символом, за которым следует ноль и более символов слова.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>End the match at the end of the input string.</source>
          <target state="translated">Совпадение должно заканчиваться в конце входной строки.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">См. также</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET regular expressions<ept id="p1">](regular-expressions.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Регулярные выражения .NET<ept id="p1">](regular-expressions.md)</ept></target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Элементы языка регулярных выражений — краткий справочник<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Quantifiers in regular expressions<ept id="p1">](quantifiers.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Квантификаторы в регулярных выражениях<ept id="p1">](quantifiers.md)</ept></target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Alternation constructs in regular expressions<ept id="p1">](alternation.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Конструкции чередования в регулярных выражениях<ept id="p1">](alternation.md)</ept></target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Конструкции группировки в регулярных выражениях<ept id="p1">](grouping.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>