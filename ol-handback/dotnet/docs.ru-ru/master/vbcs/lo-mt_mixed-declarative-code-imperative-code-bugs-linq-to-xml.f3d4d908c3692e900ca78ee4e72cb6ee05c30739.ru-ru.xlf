<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">08edcabc3f0238c499f87c713f205ee5a517a1ea</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\mixed-declarative-code-imperative-code-bugs-linq-to-xml.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0b5c3b5f04c7ede7d1c68c3b5d3b197daa13177c</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">398d7655e38f58b68fa237549a155ad9721e9ce2</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Mixed Declarative Code-Imperative Code Bugs (LINQ to XML) (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Смешанные ошибки декларативного кода императивного кода (LINQ to XML) (Visual Basic) | Документы Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Mixed Declarative Code/Imperative Code Bugs (LINQ to XML) (Visual Basic)</source>
          <target state="translated">Смешанные ошибки декларативного и императивного кода (LINQ to XML) (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> contains various methods that allow you to modify an XML tree directly.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> содержит различные методы, которые позволяют прямо модифицировать XML-дерево.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>You can add elements, delete elements, change the contents of an element, add attributes, and so on.</source>
          <target state="translated">Можно добавить элементы, удалить элементы, изменить содержимое элемента, добавить атрибуты и т. п.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This programming interface is described in <bpt id="p1">[</bpt>Modifying XML Trees (LINQ to XML) (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/modifying-xml-trees-linq-to-xml.md)</ept>.</source>
          <target state="translated">Этот интерфейс программирования описывается в <bpt id="p1">[</bpt>изменение деревьев XML (LINQ to XML) (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/modifying-xml-trees-linq-to-xml.md)</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>If you are iterating through one of the axes, such as &lt;xref:System.Xml.Linq.XContainer.Elements%2A&gt;, and you are modifying the XML tree as you iterate through the axis, you can end up with some strange bugs.</source>
          <target state="translated">При выполнении итерации по одной оси, такие как &lt;xref:System.Xml.Linq.XContainer.Elements%2A&gt;и изменении XML-дерева при просмотре оси, можно в итоге обнаружить некоторые неожиданные ошибки.&lt;/xref:System.Xml.Linq.XContainer.Elements%2A&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This problem is sometimes known as "The Halloween Problem".</source>
          <target state="translated">Этот вид ошибки иногда называется Halloween Problem.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Definition of the Problem</source>
          <target state="translated">Определение этой ошибки</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>When you write some code using LINQ that iterates through a collection, you are writing code in a declarative style.</source>
          <target state="translated">При создании некоего кода с использованием LINQ, при котором выполняется последовательное прохождение по элементам коллекции, код пишется в декларативном стиле.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It is more akin to describing <bpt id="p1">*</bpt>what<ept id="p1">*</ept> you want, rather that <bpt id="p2">*</bpt>how<ept id="p2">*</ept> you want to get it done.</source>
          <target state="translated">Это больше похоже на описание <bpt id="p1">*</bpt>что<ept id="p1">*</ept> требуется, скорее, <bpt id="p2">*</bpt>как<ept id="p2">*</ept> требуется выполнение задачи.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If you write code that 1) gets the first element, 2) tests it for some condition, 3) modifies it, and 4) puts it back into the list, then this would be imperative code.</source>
          <target state="translated">Если написать код, при котором 1) извлекается первый элемент, 2) выполняется его проверка согласно определенному условию, 3) выполняется его изменение и 4) выполняется его помещение назад в список элементов, то это означает, что это был бы императивный код.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You are telling the computer <bpt id="p1">*</bpt>how<ept id="p1">*</ept> to do what you want done.</source>
          <target state="translated">Вы описываете <bpt id="p1">*</bpt>как<ept id="p1">*</ept> делать то, что нужно done.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Mixing these styles of code in the same operation is what leads to problems.</source>
          <target state="translated">Смешение этих стилей кода в одной операции является источником неполадок.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">Рассмотрим следующий пример.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Suppose you have a linked list with three items in it (a, b, and c):</source>
          <target state="translated">Предположим, дан список из трех элементов (a, b и c):</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Now, suppose that you want to move through the linked list, adding three new items (a', b', and c').</source>
          <target state="translated">Теперь предположим, что необходимо пройти по связанному списку, добавив три новых пункта (a', b' и c').</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You want the resulting linked list to look like this:</source>
          <target state="translated">При этом необходимо, чтобы результирующий список выглядел так:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>So you write code that iterates through the list, and for every item, adds a new item right after it.</source>
          <target state="translated">Пишется код, который последовательно обращается к элементам списка и для каждого пункта добавляет новый пункт после него.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>What happens is that your code will first see the <ph id="ph1">`a`</ph> element, and insert <ph id="ph2">`a'`</ph> after it.</source>
          <target state="translated">При этом код распознает элемент <ph id="ph1">`a`</ph> и вставит элемент <ph id="ph2">`a'`</ph> после него.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Now, your code will move to the next node in the list, which is now <ph id="ph1">`a'`</ph>!</source>
          <target state="translated">Теперь код перейдет к следующему узлу списка, которым является <ph id="ph1">`a'`</ph>!</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>It happily adds a new item to the list, <ph id="ph1">`a''`</ph>.</source>
          <target state="translated">После чего он добавляет новый элемент списка - <ph id="ph1">`a''`</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>How would you solve this in the real world?</source>
          <target state="translated">Как это следовало бы решить в реальной ситуации?</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Well, you might make a copy of the original linked list, and create a completely new list.</source>
          <target state="translated">Можно сделать копию оригинального списка, после чего создать полностью новый список.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Or if you are writing purely imperative code, you might find the first item, add the new item, and then advance twice in the linked list, advancing over the element that you just added.</source>
          <target state="translated">Или, если вы пишете чисто императивный код, можно найти первый пункт, добавить новый пункт и перейти на два шага вперед по списку, чтобы перескочить элемент, который был только что добавлен.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Adding While Iterating</source>
          <target state="translated">Добавление при последовательном переходе</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For example, suppose you want to write some code that for every element in a tree, you want to create a duplicate element:</source>
          <target state="translated">Например, требуется написать некоторый код, при помощи которого для каждого элемента дерева создается его дубликат:</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This code goes into an infinite loop.</source>
          <target state="translated">Этот код представляет собой бесконечный цикл.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`foreach`</ph> statement iterates through the <ph id="ph2">`Elements()`</ph> axis, adding new elements to the <ph id="ph3">`doc`</ph> element.</source>
          <target state="translated">Инструкция <ph id="ph1">`foreach`</ph> последовательно применяется ко всей оси <ph id="ph2">`Elements()`</ph>, при этом добавляются новые элементы к элементу <ph id="ph3">`doc`</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>It ends up iterating also through the elements it just added.</source>
          <target state="translated">После этого она переходит на только что добавленные элементы.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>And because it allocates new objects with every iteration of the loop, it will eventually consume all available memory.</source>
          <target state="translated">И поскольку она выделяет память для новых объектов на каждом шаге, она захватит всю доступную память.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>You can fix this problem by pulling the collection into memory using the &lt;xref:System.Linq.Enumerable.ToList%2A&gt; standard query operator, as follows:</source>
          <target state="translated">Данную проблему можно устранить путем извлечения коллекции в памяти с помощью &lt;xref:System.Linq.Enumerable.ToList%2A&gt;стандартного оператора запроса, как показано ниже:&lt;/xref:System.Linq.Enumerable.ToList%2A&gt;</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Now the code works.</source>
          <target state="translated">Теперь код работает, как и положено.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The resulting XML tree is the following:</source>
          <target state="translated">В итоге получается следующее XML-дерево:</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Deleting While Iterating</source>
          <target state="translated">Удаление элементов при последовательном переходе</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you want to delete all nodes at a certain level, you might be tempted to write code like the following:</source>
          <target state="translated">Если требуется удалить все узлы, размещенные на определенном уровне, может возникнуть искушение попробовать реализовать это так:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>However, this does not do what you want.</source>
          <target state="translated">Однако этот код не выполнит поставленной задачи.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In this situation, after you have removed the first element, A, it is removed from the XML tree contained in root, and the code in the Elements method that is doing the iterating cannot find the next element.</source>
          <target state="translated">В такой ситуации после удаления первого элемента A он удаляется из XML-дерева, которое содержится в корне, при этом коду метода элементов (Elements method), который выполняет последовательный переход, не удастся найти следующий элемент.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The preceding code produces the following output:</source>
          <target state="translated">Предыдущий код представит следующий вывод.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The solution again is to call &lt;xref:System.Linq.Enumerable.ToList%2A&gt; to materialize the collection, as follows:</source>
          <target state="translated">Решение снова заключается в вызове &lt;xref:System.Linq.Enumerable.ToList%2A&gt;Чтобы материализовать коллекцию следующим образом:&lt;/xref:System.Linq.Enumerable.ToList%2A&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This produces the following output:</source>
          <target state="translated">Выводятся следующие результаты.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Alternatively, you can eliminate the iteration altogether by calling &lt;xref:System.Xml.Linq.XElement.RemoveAll%2A&gt; on the parent element:</source>
          <target state="translated">Кроме того, можно исключить итерации вообще путем вызова &lt;xref:System.Xml.Linq.XElement.RemoveAll%2A&gt;на родительском элементе:&lt;/xref:System.Xml.Linq.XElement.RemoveAll%2A&gt;</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Why Can't LINQ Automatically Handle This?</source>
          <target state="translated">Почему LINQ не может автоматически обрабатывать такие ошибки?</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>One approach would be to always bring everything into memory instead of doing lazy evaluation.</source>
          <target state="translated">Одним из подходов может быть вызов всех элементов в память, вместо того чтобы проводить неспешное вычисление каждого элемента.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>However, it would be very expensive in terms of performance and memory use.</source>
          <target state="translated">Однако это может негативно отразиться на производительности и загрузить память.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>In fact, if LINQ and (LINQ to XML) were to take this approach, it would fail in real-world situations.</source>
          <target state="translated">Фактически, если бы LINQ и (LINQ to XML) использовали этот подход, он бы оказался неудачным в реальных ситуациях.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Another possible approach would be to put in some sort of transaction syntax into LINQ, and have the compiler attempt to analyze the code and determine if any particular collection needed to be materialized.</source>
          <target state="translated">Другой возможный подход мог бы реализоваться путем введения некоего синтаксиса транзакций в LINQ и использования компилятора для попытки анализа кода и определения того, необходимо ли материализовать какую-то конкретную коллекцию.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>However, attempting to determine all code that has side-effects is incredibly complex.</source>
          <target state="translated">Однако попытка определения всего кода с побочными эффектами чрезвычайно сложна.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Consider the following code:</source>
          <target state="translated">Рассмотрим следующий код.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Such analysis code would need to analyze the methods TestSomeCondition and DoMyProjection, and all methods that those methods called, to determine if any code had side-effects.</source>
          <target state="translated">Такому коду для проведения анализа потребуется анализировать методы TestSomeCondition и DoMyProjection, а также все методы, которые вызывают их, чтобы определить, есть ли у кода какие-либо побочные эффекты.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>But the analysis code could not just look for any code that had side-effects.</source>
          <target state="translated">Однако коду анализа не удавалось просто искать код, в котором есть побочные эффекты.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>It would need to select for just the code that had side-effects on the child elements of <ph id="ph1">`root`</ph> in this situation.</source>
          <target state="translated">Для этого потребовалось бы выбрать только тот код, у которого есть побочные эффекты на дочерних элементах <ph id="ph1">`root`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>LINQ to XML does not attempt to do any such analysis.</source>
          <target state="translated">LINQ to XML не пытается выполнить такой анализ.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>It is up to you to avoid these problems.</source>
          <target state="translated">Поэтому задача избежания таких проблем лежит на вас.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Guidance</source>
          <target state="translated">Руководство</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>First, do not mix declarative and imperative code.</source>
          <target state="translated">Во-первых, не стоит смешивать декларативный и императивный код.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Even if you know exactly the semantics of your collections and the semantics of the methods that modify the XML tree, if you write some clever code that avoids these categories of problems, your code will need to be maintained by other developers in the future, and they may not be as clear on the issues.</source>
          <target state="translated">Даже если вам точно известна семантика ваших коллекций и методов, которые применяются для изменения XML-дерева, если удастся создать некий код, в котором такие категории проблем невозможны, код все равно потребуется поддерживать другим разработчикам в будущем, а для них это не всегда может быть так же ясно, как для вас.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If you mix declarative and imperative coding styles, your code will be more brittle.</source>
          <target state="translated">Если смешать декларативный и императивный стили, то код значительно усложнится.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>If you write code that materializes a collection so that these problems are avoided, note it with comments as appropriate in your code, so that maintenance programmers will understand the issue.</source>
          <target state="translated">Если удастся написать код, который материализует коллекцию таким образом, что эти проблемы удастся избежать, отметьте это в комментариях кода, чтобы другие программисты понимали, как это сделано.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Second, if performance and other considerations allow, use only declarative code.</source>
          <target state="translated">Во-вторых, если требования производительности и другие условия позволяют, используйте только декларативный код.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Don't modify your existing XML tree.</source>
          <target state="translated">Не следует изменять существующее XML-дерево.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Generate a new one.</source>
          <target state="translated">Лучше создать новое.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">См. также</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Advanced LINQ to XML Programming (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Дополнительно программированию LINQ to XML (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>