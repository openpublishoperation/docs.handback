<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fba870a93784b579da1065a07d82974951ac7e28</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">95b746403eed8e13100defe90c42c880febbf750</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d8d70bd22979ff7663a27372887eb04ebd6c598f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">.NET 入门</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">.NET 入门</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">.NET 入门</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>"Getting Started with .NET Core" tutorials<ept id="p1">](../core/getting-started.md)</ept> to learn how to create a simple .NET Core application.</source>
          <target state="translated">请查看<bpt id="p1">[</bpt>“.NET Core 入门”教程<ept id="p1">](../core/getting-started.md)</ept>，了解如何创建简单的 .NET Core 应用程序。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It only takes a few minutes to get your first app up and running.</source>
          <target state="translated">只需几分钟即可生成并运行第一个应用。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>.NET is a general purpose development platform.</source>
          <target state="translated">.NET 是一个通用开发平台。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>It can be used for any kind of app type or workload where general purpose solutions are used.</source>
          <target state="translated">在使用通用解决方案的任何类型的应用或工作负荷中，都可以使用 .NET。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>It has several key features that are attractive to many developers, including automatic memory management and modern programming languages, that make it easier to efficiently build high-quality applications.</source>
          <target state="translated">.NET 提供很多开发人员都会感兴趣的一些重要功能，包括自动内存管理和现代编程语言，可方便开发人员有效构建优质应用程序。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>.NET enables a high-level programming environment with many convenience features, while providing low-level access to native memory and APIs.</source>
          <target state="translated">.NET 可以实现一个具有许多便利功能的高级编程环境，同时提供对本机内存和 API 的低级访问。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Multiple implementations of .NET are available, based on open <bpt id="p1">[</bpt>.NET Standards<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)</ept> that specify the fundamentals of the platform.</source>
          <target state="translated">.NET 提供基于开放式 <bpt id="p1">[</bpt>.NET 标准<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)</ept>（指定平台的基本要素）的多种实现。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>They are separately optimized for different application types (for example, desktop, mobile, gaming, cloud) and support many chips (for example, x86/x64, ARM) and operating systems (for example, Windows, Linux, iOS, Android, macOS).</source>
          <target state="translated">这些实现已针对不同的应用程序类型（例如桌面应用程序、移动应用程序、游戏应用程序和云应用程序）进行优化，支持多种芯片（例如 x86/x64 和 ARM）和操作系统 （例如 Windows、Linux、iOS、Android 和 macOS）。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Open source is also an important part of the .NET ecosystem, with multiple .NET implementations and many libraries available under OSI-approved licenses.</source>
          <target state="translated">开放源代码也是 .NET 生态系统的重要组成部分，其中包含多种 .NET 实现和许多的库，购买 OSI 批准的许可证后即可使用这些库。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>Overview of .NET implementations<ept id="p1">](../about/products.md)</ept> document to figure out all of the different editions of .NET that are available, both Microsoft's and others.</source>
          <target state="translated">请参阅 <bpt id="p1">[</bpt>.NET 实现概述<ept id="p1">](../about/products.md)</ept>文档，了解 Microsoft 和其他开发商提供的所有不同 .NET 版本。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This Primer will help you understand some of the key concepts in the .NET Platform and point you to more resources for each given topic.</source>
          <target state="translated">本入门文档将帮助你了解某些 .NET 平台中的一些重要概念，并提供有关每个特定主题的更多资源的链接。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>By the end of it, you should have enough information to be able to recognize significant terms and concepts in the .NET Platform and to know how to further your knowledge about them.</source>
          <target state="translated">完成本文档后，即可掌握足够的信息，能够认识 .NET 平台中的重要术语和概念，并知道如何进一步学习相关的知识。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A stroll through .NET</source>
          <target state="translated">.NET 漫谈</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>As any mature and advanced application development framework, .NET has many powerful features that make the developer's job easier and aim to make writing code more powerful and expressive.</source>
          <target state="translated">作为一款成熟、高级的应用程序开发框架，.NET 提供许多强大的功能来简化开发人员的工作，使代码编写过程变得更加方便有效。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This section will outline the basics of the most salient features and provide pointers to more detailed discussions where needed.</source>
          <target state="translated">本部分概述最重要功能的基本信息，在必要时还会提供更详细介绍文档的链接。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>After finishing this stroll, you should have enough information to be able to read the samples on our GitHub repos as well as other code and understand what is going on.</source>
          <target state="translated">完成本篇漫谈文章后，你应会掌握足够的信息，可以阅读 GitHub 存储库中的示例和其他代码，并理解其中的原理。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Programming languages<ept id="p1">](#programming-languages)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>编程语言<ept id="p1">](#programming-languages)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Automatic memory management<ept id="p1">](#automatic-memory-management)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>自动内存管理<ept id="p1">](#automatic-memory-management)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type safety<ept id="p1">](#type-safety)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>类型安全<ept id="p1">](#type-safety)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](#delegates-and-lambdas)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>委托和 lambda<ept id="p1">](#delegates-and-lambdas)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types (Generics)<ept id="p1">](#generic-types-generics)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>泛型类型（泛型）<ept id="p1">](#generic-types-generics)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Language Integrated Query (LINQ)<ept id="p1">](#language-integrated-query-linq)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>语言集成查询 (LINQ)<ept id="p1">](#language-integrated-query-linq)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Async programming<ept id="p1">](#async-programming)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>异步编程<ept id="p1">](#async-programming)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Native interoperability<ept id="p1">](#native-interoperability)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>本机互操作性<ept id="p1">](#native-interoperability)</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Unsafe code<ept id="p1">](#unsafe-code)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>不安全代码<ept id="p1">](#unsafe-code)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Programming languages</source>
          <target state="translated">编程语言</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>As a developer, you can choose any programming language that supports .NET to create your application.</source>
          <target state="translated">开发人员可以选择支持 .NET Framework 的任何编程语言来创建应用程序。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Because .NET provides language independence and interoperability, you can interact with other .NET applications and components regardless of the language with which they were developed.</source>
          <target state="translated">由于 .NET 提供语言独立性和互操作性，因此无论使用何种语言开发，你都可以与其他 .NET 应用程序和组件交互。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Languages that allow you to develop applications for the .NET Platform adhere to the <bpt id="p1">[</bpt>Common Language Infrastructure (CLI) specification<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>.</source>
          <target state="translated">用来开发适用于 .NET 平台的应用程序的语言遵守<bpt id="p1">[</bpt>公共语言基础结构 (CLI) 规范<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Microsoft languages that .NET supports include C#, F#, and Visual Basic.</source>
          <target state="translated">.NET 支持的语言包括 C#、F# 和 Visual Basic。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages.</source>
          <target state="translated">C# 是一种简单、强大、类型安全、面向对象的语言，同时保留了 C 语言的表达力度和简洁性。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Anyone familiar with C and similar languages will find few problems in adapting to C#.</source>
          <target state="translated">熟悉 C 和类似语言的任何人在适应 C# 的过程中几乎不会遇到什么问题。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</source>
          <target state="translated">F# 是一种跨平台、功能优先的编程语言，它也支持传统的面向对象的编程和命令式编程。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.</source>
          <target state="translated">Visual Basic 是一种简单易学的语言，可用于构建在 .NET 上运行的各种应用程序。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In the current release of .NET Core, only C# is fully supported across all Microsoft tools.</source>
          <target state="translated">在最新版本的 .NET Core 中，只有 C# 才受到所有 Microsoft 工具的完全支持。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>F# is supported in the .NET Core SDK, but does not have Visual Studio tooling yet.</source>
          <target state="translated">F# 在 .NET Core SDK 中受支持，但尚未提供相应的 Visual Studio 工具。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Visual Basic support for the SDK and Visual Studio tooling are coming.</source>
          <target state="translated">我们即将推出对该 SDK 的 Visual Basic 支持以及 Visual Studio 工具。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Automatic memory management</source>
          <target state="translated">自动内存管理</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Garbage collection is the most well-known of .NET features.</source>
          <target state="translated">垃圾回收是最有名的 .NET 功能。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Developers do not need to actively manage memory, although there are mechanisms to provide more information to the garbage collector (GC).</source>
          <target state="translated">开发人员不需要主动管理内存，不过可以使用相应的机制向垃圾回收器 (GC) 提供更多信息。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>C# includes the <ph id="ph1">`new`</ph> keyword to allocate memory in terms of a particular type, and the <ph id="ph2">`using`</ph> keyword to provide scope for the usage of the object.</source>
          <target state="translated">C# 包含 <ph id="ph1">`new`</ph> 关键字用于分配特定类型的内存，并且包含 <ph id="ph2">`using`</ph> 关键字用于提供对象的使用范围。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.</source>
          <target state="translated">GC 以一种“懒散”的方式进行内存管理，它优先考虑应用程序吞吐量，而不是立即回收内存。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following two lines both allocate memory:</source>
          <target state="translated">以下两行代码都会分配内存：</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>There is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled running.</source>
          <target state="translated">无法使用任何类似的关键字来取消分配内存，因为当垃圾回收器通过其计划的运行规则回收内存时，会自动发生取消分配。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Method variables normally go out of scope once a method completes, at which point they can be collected.</source>
          <target state="translated">当某个方法完成时，方法变量通常会超出范围，此时，便可以回收这些变量。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the <ph id="ph1">`using`</ph> statement.</source>
          <target state="translated">但是，可能使用 <ph id="ph1">`using`</ph> 语句来告诉 GC，要在特定的对象超出范围后才让方法退出。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Once the <ph id="ph1">`using`</ph> block completes, the GC will know that the <ph id="ph2">`stream`</ph> object in the example above is free to be collected and its memory reclaimed.</source>
          <target state="translated"><ph id="ph1">`using`</ph> 块完成后，GC 便会知道可以放心收集上述示例中的 <ph id="ph2">`stream`</ph> 对象，并且可以回收其内存。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>One of the less obvious but quite far-reaching features that a garbage collector enables is memory safety.</source>
          <target state="translated">垃圾回收器实现的一个不太有名但影响广泛的功能就是内存安全。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).</source>
          <target state="translated">内存安全的固定条件非常简单：如果某个程序仅访问分配的内存（未释放），则该程序就是内存安全的。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Dangling pointers are always bugs, and tracking them down is often quite difficult.</source>
          <target state="translated">悬垂指针总会造成麻烦，并且往往难以跟踪。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The .NET runtime provides additional services, to complete the promise of memory safety, not naturally offered by a GC.</source>
          <target state="translated">.NET 运行时提供附加的服务来兑现内存安全，而 GC 不一定总能做到这一点。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>It ensures that programs do not index off the end of an array or accessing a phantom field off the end of an object.</source>
          <target state="translated">它可以确保程序不会为数组的末尾编制索引，或者访问对象末尾的虚构字段。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The following example will throw an exception as a result of memory safety.</source>
          <target state="translated">下面的示例会由于内存安全而引发异常。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Type safety</source>
          <target state="translated">类型安全</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Objects are allocated in terms of types.</source>
          <target state="translated">对象按类型分配。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The only operations allowed for a given object, and the memory it consumes, are those of its type.</source>
          <target state="translated">给定对象允许的唯一操作及其消耗的内存都属于特定的类型。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dog`</ph> type may have <ph id="ph2">`Jump`</ph> and <ph id="ph3">`WagTail`</ph> methods, but not likely a <ph id="ph4">`SumTotal`</ph> method.</source>
          <target state="translated"><ph id="ph1">`Dog`</ph> 类型可能具有 <ph id="ph2">`Jump`</ph> 和 <ph id="ph3">`WagTail`</ph> 方法，但不太可能有 <ph id="ph4">`SumTotal`</ph> 方法。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A program can only call the declared methods of a given type.</source>
          <target state="translated">程序只能调用给定类型的声明方法。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or <ph id="ph1">`object`</ph>).</source>
          <target state="translated">其他所有调用将导致编译时错误或运行时异常（如果使用动态功能或 <ph id="ph1">`object`</ph>）。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>.NET languages are object-oriented, with hierarchies of base and derived classes.</source>
          <target state="translated">.NET 语言面向对象，包含基类和派生类的层次结构。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The .NET runtime will only allow object casts and calls that align with the object hierarchy.</source>
          <target state="translated">.NET 运行时仅允许与对象层次结构相符的对象强制转换和调用。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Remember that every type defined in any .NET language derives from the base <ph id="ph1">`object`</ph> type.</source>
          <target state="translated">请记住，任何 .NET 语言中定义的每个类型都派生自 <ph id="ph1">`object`</ph> 基类型。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</source>
          <target state="translated">使用类型安全还有助于强制实施封装，因为它可以保证访问器关键字的保真度。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Accessor keywords are artifacts which control access to members of a given type by other code.</source>
          <target state="translated">访问器关键字是控制其他代码访问给定类型的成员的项目。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>These are usually used for various kinds of data within a type that are used to manage its behavior.</source>
          <target state="translated">这些关键字通常用于某个类型中用来管理类型行为的各种数据。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Some .NET languages support <bpt id="p1">**</bpt>type inference<ept id="p1">**</ept>.</source>
          <target state="translated">有些 .NET 语言支持<bpt id="p1">**</bpt>类型推理<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side.</source>
          <target state="translated">类型推理是指编译器根据右侧的表达式推断左侧表达式的类型。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This doesn't mean that the type safety is broken or avoided.</source>
          <target state="translated">这并不意味着类型安全遭到破坏或规避。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The resulting type <bpt id="p1">**</bpt>has<ept id="p1">**</ept> a strong type with everything that implies.</source>
          <target state="translated">生成的类型<bpt id="p1">**</bpt>具有<ept id="p1">**</ept>一个隐含所有信息的强类型。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Let's rewrite the first two lines of the previous example to introduce type inference.</source>
          <target state="translated">让我们重新编写上述示例中的前两行代码，以便于介绍类型推理。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You will note that the rest of the example is completely the same.</source>
          <target state="translated">可以看到，该示例的余下内容完全相同。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">委托和 lambda</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Delegates are like C++ function pointers, with a big difference that they are type safe.</source>
          <target state="translated">委托类似于 C++ 函数指针，一个重要差别在于，它们是类型安全的。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>They are a kind of disconnected method within the CLR type system.</source>
          <target state="translated">它们是 CLR 类型系统中某种断开连接的方法。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Regular methods are attached to a class and only directly callable through static or instance calling conventions.</source>
          <target state="translated">正则方法已连接到某个类，只能通过静态或实例调用约定来直接调用。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Delegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.</source>
          <target state="translated">委托可在 .NET 领域的各种 API 和场合中使用，尤其是通过 lambda 表达式（LINQ 的基石）使用。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept> document.</source>
          <target state="translated">在<bpt id="p1">[</bpt>委托和 lambda<ept id="p1">](delegates-lambdas.md)</ept> 文档中了解有关委托的详细信息。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Generic types (Generics)</source>
          <target state="translated">泛型类型（泛型）</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Generic types, also commonly called "generics", are a feature that was added in .NET Framework 2.0.</source>
          <target state="translated">泛型类型通常也称作“泛型”，是 .NET Framework 2.0 中的新增功能。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In short, generics allow the programmer to introduce a "type parameter" when designing their classes, that will allow the client code (the users of the type) to specify the exact type to use in place of the type parameter.</source>
          <target state="translated">简而言之，泛型可让程序员在设计类时引入一个“类型参数”，这样，客户端代码（类型的用户）便可以指定要使用哪个确切的类型来取代类型参数。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Generics were added in order to help programmers implement generic data structures.</source>
          <target state="translated">添加泛型的目的是帮助程序员实现通用数据结构。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Before their arrival, in order for a, say, <bpt id="p1">_</bpt>List<ept id="p1">_</ept> type to be generic, it would have to work with elements that were of type <bpt id="p2">_</bpt>object<ept id="p2">_</ept>.</source>
          <target state="translated">在泛型问世之前，举例来说，要将 <bpt id="p1">_</bpt>List<ept id="p1">_</ept> 类型用作泛型，必须处理 <bpt id="p2">_</bpt>object<ept id="p2">_</ept> 类型的元素。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This would have various performance as well as semantic problems, not to mention possible subtle runtime errors.</source>
          <target state="translated">这就会造成各种性能和语义问题，更不必说那些微妙的运行时错误。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <bpt id="p1">_</bpt>InvalidCastException<ept id="p1">_</ept> is thrown on working with the list's members.</source>
          <target state="translated">例如，当数据结构包含整数和字符串时，如果在处理列表的成员时引发 <bpt id="p1">_</bpt>InvalidCastException<ept id="p1">_</ept>，则就会出现运行时错误这种非常棘手的问题。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The below sample shows a basic program running using an instance of <ph id="ph1">@System.Collections.Generic.List%601</ph> types.</source>
          <target state="translated">以下示例显示了使用 <ph id="ph1">@System.Collections.Generic.List%601</ph> 类型实例运行的基本程序。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept> article.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>泛型类型（泛型）概述<ept id="p1">](generics.md)</ept>一文。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Async programming</source>
          <target state="translated">异步编程</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Async programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs.</source>
          <target state="translated">异步编程是 .NET 中的一个先进概念，它在运行时、框架库和 .NET 语言构造中提供异步支持。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Internally, they are based off of objects (such as <ph id="ph1">`Task`</ph>) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</source>
          <target state="translated">在内部，异步编程基于利用操作系统尽可能高效地执行 I/O 绑定型作业的对象（例如 <ph id="ph1">`Task`</ph>）。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>To learn more about async programming in .NET, start with the <bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept>.</source>
          <target state="translated">若要了解有关 .NET 中异步编程的详细信息，请先阅读<bpt id="p1">[</bpt>异步概述<ept id="p1">](async.md)</ept>。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ)</source>
          <target state="translated">语言集成查询 (LINQ)</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</source>
          <target state="translated">LINQ 是适用于 C# 和 VB 的强大功能集，可用于编写简单的声明性代码来处理数据。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!</source>
          <target state="translated">数据可以采用多种形式（例如，内存中对象、位于 SQL 数据库或 XML 文档中），但针对每个数据源编写的 LINQ 代码看上去往往没有差别！</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>To learn more and see some samples, check out <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</source>
          <target state="translated">若要了解详细信息和查看示例，请参阅 <bpt id="p1">[</bpt>LINQ（语言集成查询）<ept id="p1">](using-linq.md)</ept>。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">本机互操作性</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Every operating system in current use provides a lot of platform support for various programming tasks.</source>
          <target state="translated">当前使用的每种操作系统为各种编程任务提供了众多的平台支持。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>.NET provides several ways to tap into those APIs.</source>
          <target state="translated">.NET 可让用户以多种方式利用这些 API。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Collectively, this support is called "native interoperability" and in this section we will take a look at how to access native APIs from managed, .NET code.</source>
          <target state="translated">总而言之，这种支持称为“本机互操作性”。本部分将会探讨如何从托管的 .NET 代码访问本机 API。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The main way to do native interoperability is via "platform invoke" or P/Invoke for short.</source>
          <target state="translated">实现本机互操作性的主要方式是使用“平台调用”，简称 P/Invoke。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This support in .NET Core is available across Linux and Windows platforms.</source>
          <target state="translated">所有 Linux 和 Windows 平台都在 .NET Core 中提供了这项支持。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Another, Windows-only way of doing native interoperability is known as "COM interop" which is used to work with <bpt id="p1">[</bpt>COM components<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in managed code.</source>
          <target state="translated">实现本机互操作性的另一种方式称为“COM 互操作”（仅限 Windows），用于在托管代码中操作 <bpt id="p1">[</bpt>COM 组件<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It is built on top of P/Invoke infrastructure, but it works in subtly different ways.</source>
          <target state="translated">这种方式建立在 P/Invoke 基础结构之上，但工作原理略有不同。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</source>
          <target state="translated">针对 Java 和 Objective-C 的 Mono（以及 Xamarin）互操作性支持基本上以类似的方式构建，也就是说，它们运用相同的原理。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept> document.</source>
          <target state="translated">有关详细信息，请阅读<bpt id="p1">[</bpt>本机互操作性<ept id="p1">](native-interop.md)</ept>文档。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Unsafe code</source>
          <target state="translated">不安全代码</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The CLR enables the ability to access native memory and do pointer arithmetic via <ph id="ph1">`unsafe`</ph> code.</source>
          <target state="translated">使用 CLR 可以通过 <ph id="ph1">`unsafe`</ph> 代码访问本机内存和执行指针算法。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>These operations are needed for certain algorithms and system interoperability.</source>
          <target state="translated">某些算法和系统互操作性需要这些操作。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm.</source>
          <target state="translated">尽管不安全代码的功能强大，但除非有必要与系统 API 互操作或实现最高效的算法，否则不建议使用。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety.</source>
          <target state="translated">在不同的环境中，不安全代码的执行方式可能不同，使用它还会丧失垃圾回收器和类型安全带来的好处。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.</source>
          <target state="translated">建议尽可能地限制和集中化使用不安全代码，并全面测试该代码。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ToString()`</ph> method from the <bpt id="p1">[</bpt>StringBuilder class<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327)</ept> illustrates how using <ph id="ph2">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:</source>
          <target state="translated"><bpt id="p1">[</bpt>StringBuilder 类<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327)</ept>中的 <ph id="ph1">`ToString()`</ph> 方法演示了如何使用 <ph id="ph2">`unsafe`</ph> 代码直接移动内存区块，从而有效实现某种算法：</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">备注</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The term ".NET runtime" is used throughout the document to accommodate for the multiple implementations of .NET, such as CLR, Mono, IL2CPP and others.</source>
          <target state="translated">术语“.NET 运行时”在本文档中随处可见，使用该术语是因为它与 .NET 的多个实现（例如 CLR、Mono、IL2CPP，等等）比较贴近。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The more specific names are only used if needed.</source>
          <target state="translated">仅在需要时，本文档才使用更具体的名称。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>This document is not intended to be historical in nature, but describe the .NET platform as it is now.</source>
          <target state="translated">本文档的本意并非讲述过去，而是介绍当今的 .NET 平台。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It isn't important whether a .NET feature has always been available or was only recently introduced, only that it is important enough to highlight and discuss.</source>
          <target state="translated">某项 .NET 功能是否一直可用或者是否最近才推出并不重要，唯一重要的是了解它的特点和知识。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>