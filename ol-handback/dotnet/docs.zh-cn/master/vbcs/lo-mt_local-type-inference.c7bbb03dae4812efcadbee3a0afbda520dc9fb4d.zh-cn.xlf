<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2bb673ce871b8e875f62c373404a849c139ab598</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\variables\local-type-inference.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b2cfdb55e891c7878738fb2ef44fc65878176817</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fdf9b1ae136e40d9a92e5b27ea86671c9893c5e7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Local Type Inference (Visual Basic) | Microsoft Docs</source>
          <target state="translated">局部类型推理 (Visual Basic 中) |Microsoft 文档</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Local Type Inference (Visual Basic)</source>
          <target state="translated">局部类型推理 (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The Visual Basic compiler uses <bpt id="p1">*</bpt>type inference<ept id="p1">*</ept> to determine the data types of local variables declared without an <ph id="ph1">`As`</ph> clause.</source>
          <target state="translated">Visual Basic 编译器使用<bpt id="p1">*</bpt>类型推理<ept id="p1">*</ept>来确定未声明的局部变量的数据类型<ph id="ph1">`As`</ph>子句。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The compiler infers the type of the variable from the type of the initialization expression.</source>
          <target state="translated">编译器推断出类型的变量的初始化表达式的类型。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This enables you to declare variables without explicitly stating a type, as shown in the following example.</source>
          <target state="translated">这使您无需显式声明一个类型声明变量，如下面的示例中所示。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>As a result of the declarations, both <ph id="ph1">`num1`</ph> and <ph id="ph2">`num2`</ph> are strongly typed as integers.</source>
          <target state="translated">由于声明，而同时<ph id="ph1">`num1`</ph>和<ph id="ph2">`num2`</ph>强类型化为整数。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrTypeInference#1<ept id="p2">](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/local-type-inference_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrTypeInference #&amp;1;<ept id="p2">](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/local-type-inference_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you do not want <ph id="ph1">`num2`</ph> in the previous example to be typed as an <ph id="ph2">`Integer`</ph>, you can specify another type by using a declaration like <ph id="ph3">`Dim num3 As Object = 3`</ph> or <ph id="ph4">`Dim num4 As Double = 3`</ph>.</source>
          <target state="translated">如果不希望<ph id="ph1">`num2`</ph>在前面的示例，若要将类型化为<ph id="ph2">`Integer`</ph>，您可以使用声明，例如指定另一种类型<ph id="ph3">`Dim num3 As Object = 3`</ph>或<ph id="ph4">`Dim num4 As Double = 3`</ph>。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Local type inference applies at procedure level.</source>
          <target state="translated">局部类型推理适用于过程级。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It cannot be used to declare variables at module level (within a class, structure, module, or interface but not within a procedure or block).</source>
          <target state="translated">它不能用于声明在模块级别 （在类、 结构、 模块或接口中但不是能在过程或块） 的变量。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`num2`</ph> in the previous example were a field of a class instead of a local variable in a procedure, the declaration would cause an error with <ph id="ph2">`Option Strict`</ph> on, and would classify <ph id="ph3">`num2`</ph> as an <ph id="ph4">`Object`</ph> with <ph id="ph5">`Option Strict`</ph> off.</source>
          <target state="translated">如果<ph id="ph1">`num2`</ph>在前面的示例而不是一个过程中的本地变量类的字段，该声明会导致出现错误与<ph id="ph2">`Option Strict`</ph>，并将对其分类<ph id="ph3">`num2`</ph>作为<ph id="ph4">`Object`</ph>与<ph id="ph5">`Option Strict`</ph>关闭。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Similarly, local type inference does not apply to procedure level variables declared as <ph id="ph1">`Static`</ph>.</source>
          <target state="translated">同样，局部类型推理不会应用于过程级变量声明为<ph id="ph1">`Static`</ph>。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Type Inference vs. Late Binding</source>
          <target state="translated">类型推理与。后期绑定</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Code that uses type inference resembles code that relies on late binding.</source>
          <target state="translated">使用类型推理的代码类似于依赖后期绑定的代码。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>However, type inference strongly types the variable instead of leaving it as <ph id="ph1">`Object`</ph>.</source>
          <target state="translated">但是，类型推断为强类型而不是将其保留为变量<ph id="ph1">`Object`</ph>。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The compiler uses a variable's initializer to determine the variable's type at compile time to produce early-bound code.</source>
          <target state="translated">编译器使用变量的初始值设定项来确定在编译时，若要生成早期绑定的代码的变量的类型。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>In the previous example, <ph id="ph1">`num2`</ph>, like <ph id="ph2">`num1`</ph>, is typed as an <ph id="ph3">`Integer`</ph>.</source>
          <target state="translated">在上一示例中， <ph id="ph1">`num2`</ph>、 like <ph id="ph2">`num1`</ph>，类型化为<ph id="ph3">`Integer`</ph>。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The behavior of early-bound variables differs from that of late-bound variables, for which the type is known only at run time.</source>
          <target state="translated">早期绑定的变量的行为不同于，后期绑定的变量，仅在运行时为其已知类型。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Knowing the type early enables the compiler to identify problems before execution, allocate memory precisely, and perform other optimizations.</source>
          <target state="translated">尽早知道的类型使编译器能够识别问题，然后执行、 准确地说，分配内存并执行其他优化。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Early binding also enables the Visual Basic integrated development environment (IDE) to provide IntelliSense Help about the members of an object.</source>
          <target state="translated">早期绑定还可使 Visual Basic 的集成的开发环境 (IDE)，以提供有关对象的成员的 IntelliSense 将帮助。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Early binding is also preferred for performance.</source>
          <target state="translated">早期绑定也是性能的首选分发点。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This is because all data stored in a late-bound variable must be wrapped as type <ph id="ph1">`Object`</ph>, and accessing members of the type at run time makes the program slower.</source>
          <target state="translated">这是因为后期绑定变量中存储的所有数据都必须作为类型都包装<ph id="ph1">`Object`</ph>，并在运行时访问该类型的成员使程序运行较慢。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">示例</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Type inference occurs when a local variable is declared without an <ph id="ph1">`As`</ph> clause and initialized.</source>
          <target state="translated">而无需声明本地变量时，会发生类型推理<ph id="ph1">`As`</ph>子句和初始化。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The compiler uses the type of the assigned initial value as the type of the variable.</source>
          <target state="translated">编译器将使用的初始已赋值的类型作为该变量的类型。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For example, each of the following lines of code declares a variable of type <ph id="ph1">`String`</ph>.</source>
          <target state="translated">例如，下面的代码行的每个声明类型的变量<ph id="ph1">`String`</ph>。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrTypeInference#2<ept id="p2">](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/local-type-inference_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrTypeInference #&amp;2;<ept id="p2">](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/local-type-inference_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following code demonstrates two equivalent ways to create an array of integers.</source>
          <target state="translated">下面的代码演示两个等效的方法来创建整数的数组。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrTypeInference#3<ept id="p2">](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/local-type-inference_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrTypeInference #&amp;3;<ept id="p2">](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/local-type-inference_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>It is convenient to use type inference to determine the type of a loop control variable.</source>
          <target state="translated">它很方便地使用类型推断功能来确定的循环控制变量的类型。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In the following code, the compiler infers that <ph id="ph1">`number`</ph> is an <ph id="ph2">`Integer`</ph> because <ph id="ph3">`someNumbers2`</ph> from the previous example is an array of integers.</source>
          <target state="translated">在下面的代码中，编译器推断<ph id="ph1">`number`</ph>是<ph id="ph2">`Integer`</ph>因为<ph id="ph3">`someNumbers2`</ph>从上一个示例是一个整数数组。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrTypeInference#4<ept id="p2">](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/local-type-inference_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrTypeInference #&amp;4;<ept id="p2">](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/local-type-inference_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Local type inference can be used in <ph id="ph1">`Using`</ph> statements to establish the type of the resource name, as the following example demonstrates.</source>
          <target state="translated">可以在使用局部类型推理<ph id="ph1">`Using`</ph>语句，以建立资源名称的类型，如下面的示例所示。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrTypeInference#7<ept id="p2">](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/local-type-inference_5.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrTypeInference #&amp;7;<ept id="p2">](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/local-type-inference_5.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The type of a variable can also be inferred from the return values of functions, as the following example demonstrates.</source>
          <target state="translated">如以下示例所示，还可以从函数的返回值推断变量类型。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">`pList1`</ph> and <ph id="ph2">`pList2`</ph> are arrays of processes because <ph id="ph3">`Process.GetProcesses`</ph> returns an array of processes.</source>
          <target state="translated">同时<ph id="ph1">`pList1`</ph>和<ph id="ph2">`pList2`</ph>都是进程数组，因为<ph id="ph3">`Process.GetProcesses`</ph>返回的进程的数组。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrTypeInference#5<ept id="p2">](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/local-type-inference_6.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrTypeInference #&amp;5;<ept id="p2">](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/local-type-inference_6.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Option Infer</source>
          <target state="translated">Option Infer</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Option Infer`</ph> enables you specify whether local type inference is allowed in a particular file.</source>
          <target state="translated"><ph id="ph1">`Option Infer`</ph>允许您指定在特定的文件中是否允许局部类型推理。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>To enable or to block the option, type one of the following statements at the start of the file.</source>
          <target state="translated">若要启用或阻止该选项，请在该文件的开头键入以下语句之一。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If you do not specify a value for <ph id="ph1">`Option Infer`</ph> in your code, the compiler default is <ph id="ph2">`Option Infer On`</ph>.</source>
          <target state="translated">如果未指定的值<ph id="ph1">`Option Infer`</ph>在代码中，默认的编译器是<ph id="ph2">`Option Infer On`</ph>。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For projects upgraded from <ph id="ph1">[!INCLUDE[vb_orcas_long](../../../../visual-basic/misc/includes/vb_orcas_long_md.md)]</ph> or earlier, the compiler default is <ph id="ph2">`Option Infer Off`</ph>.</source>
          <target state="translated">从项目升级为<ph id="ph1">[!INCLUDE[vb_orcas_long](../../../../visual-basic/misc/includes/vb_orcas_long_md.md)]</ph>或更早版本，默认的编译器是<ph id="ph2">`Option Infer Off`</ph>。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If the value set for <ph id="ph1">`Option Infer`</ph> in a file conflicts with the value set in the IDE or on the command line, the value in the file has precedence.</source>
          <target state="translated">如果为文件中 <ph id="ph1">`Option Infer`</ph> 设置的值与在 IDE 中或在命令行上设置的值冲突，则文件中的值优先。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Option Infer Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/option-infer-statement.md)</ept> and <bpt id="p2">[</bpt>Compile Page, Project Designer (Visual Basic)<ept id="p2">](https://docs.microsoft.com/visualstudio/ide/reference/compile-page-project-designer-visual-basic)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>Option Infer 语句<ept id="p1">](../../../../visual-basic/language-reference/statements/option-infer-statement.md)</ept>和<bpt id="p2">[</bpt>编译页，项目设计器 (Visual Basic 中)<ept id="p2">](https://docs.microsoft.com/visualstudio/ide/reference/compile-page-project-designer-visual-basic)</ept>。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Restrictions</source>
          <target state="translated">限制</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Type inference can be used only for non-static local variables; it cannot be used to determine the type of class fields, properties, or functions.</source>
          <target state="translated">类型推理可以仅用于非静态局部变量;它不能用于确定类字段、 属性或函数的类型。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">另请参阅</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Anonymous Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>匿名类型<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Early and Late Binding<ept id="p1">](../../../../visual-basic/programming-guide/language-features/early-late-binding/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>早期绑定和后期绑定<ept id="p1">](../../../../visual-basic/programming-guide/language-features/early-late-binding/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>For Each...Next Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>每个...下一条语句<ept id="p1">](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>For...Next Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/for-next-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>有关...下一条语句<ept id="p1">](../../../../visual-basic/language-reference/statements/for-next-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Option Infer Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/option-infer-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Option Infer 语句<ept id="p1">](../../../../visual-basic/language-reference/statements/option-infer-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>/optioninfer<ept id="p1">](../../../../visual-basic/reference/command-line-compiler/optioninfer.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>/optioninfer<ept id="p1">](../../../../visual-basic/reference/command-line-compiler/optioninfer.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Introduction to LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>在 Visual Basic 中的 LINQ 简介<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>