<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-f0362aa" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">694502a105224543063cfc08e9310dc02c1d2319</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\deploying\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">72f7203b0550d1d75f450392db3ca0c8255462d1</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e59b790484a783cf70006b43f4dc3799ba4a3c88</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core Application Deployment</source>
          <target state="translated">.NET Core 應用程式部署</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core Application Deployment</source>
          <target state="translated">.NET Core 應用程式部署</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, .NET Core deployment</source>
          <target state="translated">.NET、.NET Core、.NET Core 部署</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core Application Deployment</source>
          <target state="translated">.NET Core 應用程式部署</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic applies to .NET Core Tools Preview 2.</source>
          <target state="translated">本主題適用於 .NET Core 工具 Preview 2。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For the .NET Core Tools RC4 version, see the <bpt id="p1">[</bpt>.NET Core Application Deployment (.NET Core Tools RC4)<ept id="p1">](../preview3/deploying/index.md)</ept> topic.</source>
          <target state="translated">.NET Core 工具 RC4 版本，請參閱 <bpt id="p1">[</bpt>.NET Core 應用程式部署 (.NET Core 工具 RC4)<ept id="p1">](../preview3/deploying/index.md)</ept> 主題。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can create two types of deployments for .NET Core applications:</source>
          <target state="translated">您可以建立兩種類型的 .NET Core 應用程式部署︰</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Framework-dependent deployment.</source>
          <target state="translated">與 Framework 相依的部署。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>As the name implies, framework-dependent deployment (FDD) relies on a shared system-wide version of .NET Core to be present on the target system.</source>
          <target state="translated">正如其名，與 Framework 相依的部署 (FDD) 要仰賴全系統共用的 .NET Core 版本才能存在於目標系統上。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Because .NET Core is already present, your app is also portable between installations of .NET Core.</source>
          <target state="translated">因為 .NET Core 已存在，所以應用程式也可以在 .NET Core 安裝之間攜帶。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Your app contains only its own code and any third-party dependencies that are outside of the .NET Core libraries.</source>
          <target state="translated">您的應用程式僅包含其自有程式碼和 .NET Core 程式庫以外的所有協力廠商相依性。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>FDDs contain .dll files that can be launched by using the <bpt id="p1">[</bpt>dotnet utility<ept id="p1">](../tools/dotnet.md)</ept> from the command line.</source>
          <target state="translated">FDD 包含的 .dll 檔案，可以使用 <bpt id="p1">[</bpt>dotnet 公用程式<ept id="p1">](../tools/dotnet.md)</ept>從命令列啟動。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`dotnet app.dll`</ph> runs an application named <ph id="ph2">`app`</ph>.</source>
          <target state="translated">例如，<ph id="ph1">`dotnet app.dll`</ph> 執行名為 <ph id="ph2">`app`</ph> 的應用程式。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Self-contained deployment.</source>
          <target state="translated">自封式部署。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Unlike FDD, a self-contained deployment (SCD) does not rely on any shared components to be present on the target system.</source>
          <target state="translated">不同於 FDD，自封式部署 (SCD) 不仰賴任何共用的元件就能存在於目標系統上。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>All components, including both .NET Core libraries and the .NET Core runtime, are included with the application and are isolated from other .NET Core applications.</source>
          <target state="translated">所有的元件，包括 .NET Core 程式庫和 .NET Core 執行階段，都隨附於應用程式，並與其他 .NET Core 應用程式隔離。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>SCDs include an executable (such as <ph id="ph1">`app.exe`</ph> on Windows platforms for an application named <ph id="ph2">`app`</ph>), which is  a renamed version of the platform-specific .NET Core host, and a .dll file (such as <ph id="ph3">`app.dll`</ph>), which is the actual application.</source>
          <target state="translated">SCD 包含可執行檔 (例如，Windows 平台上 <ph id="ph2">`app`</ph> 應用程式的 <ph id="ph1">`app.exe`</ph>)，這是重新命名的特定平台 .NET Core 主應用程式版本，以及實際的應用程式 .dll 檔案 (例如 <ph id="ph3">`app.dll`</ph>)。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Framework-dependent deployments (FDD)</source>
          <target state="translated">與 Framework 相依的部署 (FDD)</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For an FDD, you deploy only your app and any third-party dependencies.</source>
          <target state="translated">在 FDD，您只要部署自己的應用程式和任何協力廠商相依性。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You do not have to deploy .NET Core, since your app will use the version of .NET Core that's present on the target system.</source>
          <target state="translated">您不必部署 .NET Core，因為您的應用程式會使用存在於目標系統上的 .NET Core 版本。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This is the default deployment model for .NET Core apps.</source>
          <target state="translated">這是 .NET Core 應用程式的預設部署模型。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Why create a framework-dependent deployment?</source>
          <target state="translated">為何建立與 Framework 相依的部署？</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Deploying an FDD has a number of advantages:</source>
          <target state="translated">部署 FDD 有許多優點︰</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You do not have to define the target operating systems that your .NET Core app will run on in advance.</source>
          <target state="translated">您不必事先定義 .NET Core 應用程式執行所在的目標作業系統。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Because .NET Core uses a common PE file format for executables and libraries regardless of operating system, .NET Core can execute your app regardless of the underlying operating system.</source>
          <target state="translated">由於不論作業系統為何，.NET Core 對可執行檔和程式庫都使用通用的 PE 檔案格式，所以 .NET Core 可以執行您的應用程式，不理會基礎作業系統。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For more information on the PE file format, see <bpt id="p1">[</bpt>.NET Assembly File Format<ept id="p1">](../../standard/assembly-format.md)</ept>.</source>
          <target state="translated">如需 PE 檔格式的詳細資訊，請參閱 <bpt id="p1">[</bpt>.NET Assembly File Format<ept id="p1">](../../standard/assembly-format.md)</ept> (.NET 組件檔案格式)。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The size of your deployment package is small.</source>
          <target state="translated">部署套件的大小很小。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You only have to deploy your app and its dependencies, not .NET Core itself.</source>
          <target state="translated">您只需要部署您的應用程式及其相依性，不用部署 .NET Core。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Multiple apps use the same .NET Core installation, which reduces both disk space and memory usage on host systems.</source>
          <target state="translated">多個應用程式使用相同的 .NET Core 安裝，這樣可減少主機系統的磁碟空間和記憶體使用量。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>There are also a few disadvantages:</source>
          <target state="translated">另外還有幾個缺點︰</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Your app can run only if the version of .NET Core that you target, or a later version, is already installed on the host system.</source>
          <target state="translated">只有主機系統安裝了目標的 .NET Core 版本或更新版本，您的應用程式才能執行。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>It is possible for the .NET Core runtime and libraries to change without your knowledge in future releases.</source>
          <target state="translated">.NET Core 執行階段和程式庫在未來的版本中可能有所變更，但不會通知您。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In rare cases, this may change the behavior of your app.</source>
          <target state="translated">只有極其罕見的情況，才可能變更應用程式的行為。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Deploying a framework-dependent deployment</source>
          <target state="translated">部署與 Framework 相依的部署</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Deploying a framework-dependent deployment with no third-party dependencies simply involves building, testing, and publishing the app.</source>
          <target state="translated">部署無任何協力廠商相依性的 Framework 相依部署，只涉及建置、測試和發行應用程式。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A simple example written in C# illustrates the process.</source>
          <target state="translated">以 C# 撰寫的簡單範例會說明此程序。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The example uses the <bpt id="p1">[</bpt>dotnet utility<ept id="p1">](../tools/dotnet.md)</ept> from the command line; however, you can also use a development environment, such as Visual Studio or Visual Studio Code, to compile, test, and publish the example.</source>
          <target state="translated">此範例從命令列使用 <bpt id="p1">[</bpt>dotnet 公用程式<ept id="p1">](../tools/dotnet.md)</ept>，但您也可以使用開發環境，例如 Visual Studio 或 Visual Studio Code，來編譯、測試及發行範例。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Create a directory for your project, and from the command line, type <bpt id="p1">[</bpt>dotnet new<ept id="p1">](../tools/dotnet-new.md)</ept> to create a new C# console project.</source>
          <target state="translated">建立專案目錄，並從命令列輸入 <bpt id="p1">[</bpt>dotnet new<ept id="p1">](../tools/dotnet-new.md)</ept> 來建立新的 C# 主控台專案。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Open the <ph id="ph1">`Program.cs`</ph> file in an editor, and replace the auto-generated code with the following code.</source>
          <target state="translated">在編輯器中開啟 <ph id="ph1">`Program.cs`</ph> 檔案，並以下列程式碼取代自動產生的程式碼。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It prompts the user to enter text, and then displays the individual words entered by the user.</source>
          <target state="translated">它會提示使用者輸入文字，然後顯示使用者輸入的個別文字。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>It uses the regular expression <ph id="ph1">`\w+`</ph> to separate the words in the input text.</source>
          <target state="translated">它會使用規則運算式 <ph id="ph1">`\w+`</ph> 分隔輸入文字中的字詞。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Run the <bpt id="p1">[</bpt>dotnet restore<ept id="p1">](../tools/dotnet-restore.md)</ept> command to restore the dependencies specified in your project.</source>
          <target state="translated">執行 <bpt id="p1">[</bpt>dotnet restore<ept id="p1">](../tools/dotnet-restore.md)</ept> 命令還原專案中指定的相依性。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Create a debug build of your app by using the <bpt id="p1">[</bpt>dotnet build<ept id="p1">](../tools/dotnet-build.md)</ept> command.</source>
          <target state="translated">使用 <bpt id="p1">[</bpt>dotnet build<ept id="p1">](../tools/dotnet-build.md)</ept> 命令建立應用程式的偵錯組置。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>After you've debugged and tested the program, you can create the files to be deployed with your app by using the <ph id="ph1">`dotnet publish -f netcoreapp1.0 -c release`</ph> command.</source>
          <target state="translated">偵錯並測試程式之後，您可以使用 <ph id="ph1">`dotnet publish -f netcoreapp1.0 -c release`</ph> 命令建立要隨應用程式一起部署的檔案。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This creates a release (rather than a debug) version of your app.</source>
          <target state="translated">這會建立應用程式的發行 (而非偵錯) 版本。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The resulting files are placed in a directory named <ph id="ph1">`publish`</ph> that is in a subdirectory of your project's <ph id="ph2">`.\bin\release\netcoreapp1.0`</ph> subdirectory.</source>
          <target state="translated">產生的檔案會放在名為 <ph id="ph1">`publish`</ph> 的目錄中，位在您專案的 <ph id="ph2">`.\bin\release\netcoreapp1.0`</ph> 子目錄的子目錄中。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app.</source>
          <target state="translated">隨著應用程式檔案一起，發佈程序會發出程式資料庫 (.pdb) 檔案，其中包含應用程式的偵錯資訊。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.</source>
          <target state="translated">檔案主要用於偵錯例外狀況，您可以選擇應用程式檔案不封裝它。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The complete set of application  files can be deployed in any way you'd like.</source>
          <target state="translated">整組應用程式檔案可以任何您想要的方式部署。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For example, you can package them in a zip file, use a simple <ph id="ph1">`copy`</ph> command, or deploy them with any installation package of your choice.</source>
          <target state="translated">例如，您可以使用簡單的 <ph id="ph1">`copy`</ph> 命令將它們封裝在 zip 檔案中，或與您選擇的任何安裝封裝一起部署。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In addition to the application binaries, the installer should also either bundle the shared framework installer or check for it as a prerequisite as part of the application installation.</source>
          <target state="translated">除了應用程式二進位檔外，安裝程式也應該配套共用的 Framework 安裝程式，或勾選為必要條件當成應用程式安裝的一部分。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Installation of the shared framework requires Administrator/root access since it is machine-wide.</source>
          <target state="translated">共用 Framework 安裝需要系統管理員/根目錄存取權，因為它要通行全機器。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Deploying a framework-dependent deployment with third-party dependencies</source>
          <target state="translated">部署具有協力廠商相依性的 Framework 相依部署</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Deploying a framework-dependent deployment with one or more third-party dependencies involves three additional steps before you can run the <ph id="ph1">`dotnet restore`</ph> command:</source>
          <target state="translated">部署具有一或多個協力廠商相依性的 Framework 相依部署，包含三個額外的步驟，然後才能執行 <ph id="ph1">`dotnet restore`</ph> 命令︰</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Add references to any third-party libraries to the <ph id="ph1">`dependencies`</ph> section of your <ph id="ph2">`project.json`</ph> file.</source>
          <target state="translated">將任何協力廠商程式庫參考加入您 <ph id="ph2">`project.json`</ph> 檔案的 <ph id="ph1">`dependencies`</ph> 區段。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following  <ph id="ph1">`dependencies`</ph> section uses Json.NET as a third-party library.</source>
          <target state="translated">下列 <ph id="ph1">`dependencies`</ph> 區段會使用 Json.NET 當成協力廠商程式庫。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If you haven't already, download the NuGet package containing the third-party dependency.</source>
          <target state="translated">如果尚未如此做，請下載包含協力廠商相依性的 NuGet 封裝。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>To download the package, execute the <ph id="ph1">`dotnet restore`</ph> command after adding the dependency.</source>
          <target state="translated">若要下載封裝，請在加入相依性後執行 <ph id="ph1">`dotnet restore`</ph> 命令。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Because the dependency is resolved out of the local NuGet cache at publish time, it must be available on your system.</source>
          <target state="translated">因為相依性是在發行時於本機 NuGet 快取外解析，所以必須能在系統中取得。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Note that a framework-dependent deployment with third-party dependencies will only be as portable as its third-party dependencies.</source>
          <target state="translated">請注意，具有協力廠商相依性的 Framework 相依部署，可攜性只與其協力廠商相依性一致。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For example, if a third-party library only supports macOS, the app will not be portable to Windows systems.</source>
          <target state="translated">例如，如果協力廠商程式庫只支援 macOS，則應用程式就無法攜至 Windows 系統。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This can happen if the third-party dependency itself depends on native code.</source>
          <target state="translated">如果協力廠商相依性本身依賴於原生程式碼，就可能發生這種情況。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A good example of this is Kestrel server.</source>
          <target state="translated">Kestrel 伺服器即是一個好例子。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>When an FDD is created for an application with this kind of third-party dependency, the published output will contain a folder for each <bpt id="p1">[</bpt>Runtime Identifier (RID)<ept id="p1">](../rid-catalog.md#what-are-rids)</ept> that the native dependency supports (and that exists in its NuGet package).</source>
          <target state="translated">當具有這類協力廠商相依性的應用程式建立了 FDD 時，已發行輸出就會包含原生相依性支援的每個 <bpt id="p1">[</bpt>執行階段識別碼 (RID)<ept id="p1">](../rid-catalog.md#what-are-rids)</ept> 資料夾 (存在其 NuGet 封裝中)。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Self-contained deployments (SCD)</source>
          <target state="translated">自封式部署 (SCD)</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For a self-contained deployment, you deploy not only your app and any third-party dependencies, but the version of .NET Core that you build your app with.</source>
          <target state="translated">針對自封式部署，您不僅要部署自己的應用程式和所有協力廠商相依性，還要部署建置應用程式所用的 .NET Core 版本。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Creating an SCD does not, however, include the <bpt id="p1">[</bpt>native dependencies of .NET Core<ept id="p1">](https://github.com/dotnet/core/blob/master/Documentation/prereqs.md)</ept> itself on various platforms (for example, OpenSSL on macOS) so these need to be installed before running the application.</source>
          <target state="translated">不過，建立 SCD 不包含各種平台上的 <bpt id="p1">[</bpt>.NET Core 原生相依性<ept id="p1">](https://github.com/dotnet/core/blob/master/Documentation/prereqs.md)</ept>本身在 (例如，macOS 上的 OpenSSL)，所以您要先安裝這些，才能執行應用程式。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Why deploy a Self-contained deployment?</source>
          <target state="translated">為什麼要部署自封式部署？</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Deploying a Self-contained deployment has two major advantages:</source>
          <target state="translated">部署自封式部署有兩大優點︰</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>You have sole control of the version of .NET Core that is deployed with your app.</source>
          <target state="translated">您可以獨家控制隨應用程式部署的 .NET Core 版本。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>.NET Core can be serviced only by you.</source>
          <target state="translated">只有您可以提供 .NET Core 服務。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>You can be assured that the target system can run your .NET Core app, since you're providing the version of .NET Core that it will run on.</source>
          <target state="translated">您可以保證目標系統能執行您的 .NET Core 應用程式，因為您提供的是它可以執行的 .NET Core 版本。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It also has a number of disadvantages:</source>
          <target state="translated">它也有一些缺點︰</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Because .NET Core is included in your deployment package, you must select the target platforms for which you build deployment packages in advance.</source>
          <target state="translated">因為 .NET Core 包含在您的部署套件中，所以您必須事先選取部署套件建置所在的目標平台。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The size of your deployment package is relatively large, since you have to include .NET Core as well as your app and its third-party dependencies.</source>
          <target state="translated">您的部署套件的大小相當大，因為您必須包含 .NET Core 以及應用程式及其協力廠商相依性。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Deploying numerous self-contained .NET Core apps to a system can consume significant amounts of disk space, since each app duplicates .NET Core files.</source>
          <target state="translated">將多個自封式 .NET Core 應用程式部署到系統，會消耗大量的磁碟空間，因為每個應用程式都會重複 .NET Core 檔案。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="simpleSelf"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Deploying a simple self-contained deployment</source>
          <target state="translated"><bpt id="p1">&lt;a name="simpleSelf"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> 進行簡單的自封式部署</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Deploying a self-contained deployment with no third-party dependencies involves creating the project, modifying the project.json file, building, testing, and publishing the app.</source>
          <target state="translated">部署無任何協力廠商相依性的自封式部署，涉及建立專案、修改 project.json 檔案、建置、測試以及發行應用程式。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>A simple example written in C# illustrates the process.</source>
          <target state="translated">以 C# 撰寫的簡單範例會說明此程序。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The example uses the <ph id="ph1">`dotnet`</ph> utility from the command line; however, you can also use a development environment, such as Visual Studio or Visual Studio Code, to compile, test, and publish the example.</source>
          <target state="translated">此範例從命令列使用 <ph id="ph1">`dotnet`</ph> 公用程式，但您也可以使用開發環境，例如 Visual Studio 或 Visual Studio Code，來編譯、測試及發行範例。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Create a directory for your project, and from the command line, type <ph id="ph1">`dotnet new`</ph> to create a new C# console project.</source>
          <target state="translated">建立專案目錄，並從命令列輸入 <ph id="ph1">`dotnet new`</ph> 來建立新的 C# 主控台專案。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Open the <ph id="ph1">`Program.cs`</ph> file in an editor, and replace the auto-generated code with the following code.</source>
          <target state="translated">在編輯器中開啟 <ph id="ph1">`Program.cs`</ph> 檔案，並以下列程式碼取代自動產生的程式碼。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>It prompts the user to enter text, and then displays the individual words entered by the user.</source>
          <target state="translated">它會提示使用者輸入文字，然後顯示使用者輸入的個別文字。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>It uses the regular expression <ph id="ph1">`\w+`</ph> to separate the words in the input text.</source>
          <target state="translated">它會使用規則運算式 <ph id="ph1">`\w+`</ph> 分隔輸入文字中的字詞。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Open the <ph id="ph1">`project.json`</ph> file and in the <ph id="ph2">`frameworks`</ph> section, remove the following line:</source>
          <target state="translated">開啟 <ph id="ph2">`frameworks`</ph> 區段的 <ph id="ph1">`project.json`</ph> 檔案，移除下行︰</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The Framework section should appear as follows after you've modified it:</source>
          <target state="translated">修改它後，Framework 區段應會出現，如下所示︰</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Removing the <ph id="ph1">`"type": "platform"`</ph> attribute indicates that the framework is provided as a set of components local to our app, rather than as a system-wide platform package.</source>
          <target state="translated">移除 <ph id="ph1">`"type": "platform"`</ph> 屬性指出 Framework 已提供為應用程式的一組本機元件，而非全系統的平台封裝。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Create a <ph id="ph1">`runtimes`</ph> section in your <ph id="ph2">`project.json`</ph> file that defines the platforms your app targets, and specify the runtime identifier of each platform that you target.</source>
          <target state="translated">在定義應用程式目標平台的 <ph id="ph2">`project.json`</ph> 檔案中建立 <ph id="ph1">`runtimes`</ph> 區段，並指定每個目標平台的執行階段識別碼。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime IDentifier catalog<ept id="p1">](../rid-catalog.md)</ept> for a list of runtime identifiers.</source>
          <target state="translated">如需執行階段識別碼清單，請參閱 <bpt id="p1">[</bpt>Runtime IDentifier catalog<ept id="p1">](../rid-catalog.md)</ept>。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For example, the following <ph id="ph1">`runtimes`</ph> section indicates that the app runs on 64-bit Windows 10 operating systems and the 64-bit OS X Version 10.10 operating system.</source>
          <target state="translated">例如，下列 <ph id="ph1">`runtimes`</ph> 區段指出應用程式在 64 位元 Windows 10 作業系統和 64 位元 OS X 版本 10.10 作業系統上執行。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Note that you also need to add a comma to separate the <ph id="ph1">`runtimes`</ph> section from the previous section.</source>
          <target state="translated">請注意，您也需要加入逗號來分隔 <ph id="ph1">`runtimes`</ph> 區段與上一個區段。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>A complete sample <ph id="ph1">`project.json`</ph> file appears later in this section.</source>
          <target state="translated">本節稍後會提供完整的範例 <ph id="ph1">`project.json`</ph> 檔。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Run the <ph id="ph1">`dotnet restore`</ph> command to restore the dependencies specified in your project.</source>
          <target state="translated">執行 <ph id="ph1">`dotnet restore`</ph> 命令還原專案中指定的相依性。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Create debug builds of your app on each of the target platforms by using the <ph id="ph1">`dotnet build`</ph> command.</source>
          <target state="translated">使用 <ph id="ph1">`dotnet build`</ph> 命令在每個目標平台上建立應用程式的偵錯組建。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Unless you specify the runtime identifier you'd like to build, the <ph id="ph1">`dotnet build`</ph> command creates a build only for the current system's runtime ID.</source>
          <target state="translated">除非您指定想要建置的執行階段識別碼，否則 <ph id="ph1">`dotnet build`</ph> 命令只會建立目前系統的執行階段識別碼。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can build your app for both target platforms with the commands:</source>
          <target state="translated">您可以使用下列命令為兩個目標平台建置應用程式︰</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The debug builds of your app for each platform will be found in the project's <ph id="ph1">`.\bin\Debug\netcoreapp1.0\&lt;runtime_identifier&gt;`</ph> subdirectory.</source>
          <target state="translated">針對每個平台的應用程式偵錯組建位於專案的 <ph id="ph1">`.\bin\Debug\netcoreapp1.0\&lt;runtime_identifier&gt;`</ph> 子目錄。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>After you've debugged and tested the program, you can create the files to be deployed with your app for each platform that it targets by using the <ph id="ph1">`dotnet publish`</ph> command for both target platforms as follows:</source>
          <target state="translated">偵錯並測試完程式之後，您可以對兩個目標平台使用 <ph id="ph1">`dotnet publish`</ph> 命令，建立針對每個目標平台要與應用程式一起部署的檔案，如下所示︰</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This creates a release (rather than a debug) version of your app for each target platform.</source>
          <target state="translated">這會建立每個目標平台的應用程式發行 (而非偵錯) 版本。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The resulting files are placed in a subdirectory named <ph id="ph1">`publish`</ph> that is in a subdirectory of your project's <ph id="ph2">`.\bin\release\netcoreapp1.0\&lt;runtime_identifier&gt;`</ph> subdirectory.</source>
          <target state="translated">產生的檔案會放在名為 <ph id="ph1">`publish`</ph> 的子目錄中，位在您專案的 <ph id="ph2">`.\bin\release\netcoreapp1.0\&lt;runtime_identifier&gt;`</ph> 子目錄的子目錄中。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Note that each subdirectory contains the complete set of files (both your app files and all .NET Core files) needed to launch your app.</source>
          <target state="translated">請注意，每個子目錄都包含啟動應用程式所需的一組完整檔案 (應用程式檔案和所有的 .NET Core 檔案)。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app.</source>
          <target state="translated">隨著應用程式檔案一起，發佈程序會發出程式資料庫 (.pdb) 檔案，其中包含應用程式的偵錯資訊。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.</source>
          <target state="translated">檔案主要用於偵錯例外狀況，您可以選擇應用程式檔案不封裝它。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The published files can be deployed in any way you'd like.</source>
          <target state="translated">您可以任何想要的方式部署已發行的檔案。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For example, you can package them in a zip file, use a simple <ph id="ph1">`copy`</ph> command, or deploy them with any installation package of your choice.</source>
          <target state="translated">例如，您可以使用簡單的 <ph id="ph1">`copy`</ph> 命令將它們封裝在 zip 檔案中，或與您選擇的任何安裝封裝一起部署。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The following is the complete <ph id="ph1">`project.json`</ph> file for this project.</source>
          <target state="translated">下面是此專案的完整 <ph id="ph1">`project.json`</ph> 檔案。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Deploying a self-contained deployment with third-party dependencies</source>
          <target state="translated">部署具有協力廠商相依性的自封式部署</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Deploying a self-contained deployment with one or more third-party dependencies involves adding the third party dependency:</source>
          <target state="translated">部署具有一或多個協力廠商相依性的自封式部署，涉及新增協力廠商相依性︰</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Add references to any third-party libraries to the <ph id="ph1">`dependencies`</ph> section of your <ph id="ph2">`project.json`</ph> file.</source>
          <target state="translated">將任何協力廠商程式庫參考加入您 <ph id="ph2">`project.json`</ph> 檔案的 <ph id="ph1">`dependencies`</ph> 區段。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The following  <ph id="ph1">`dependencies`</ph> section uses Json.NET as a third-party library.</source>
          <target state="translated">下列 <ph id="ph1">`dependencies`</ph> 區段會使用 Json.NET 當成協力廠商程式庫。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If you haven't already, download the NuGet package containing the third-party dependency to your system.</source>
          <target state="translated">如果尚未如此做，請將包含協力廠商相依性的 NuGet 封裝下載至您的系統。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>To make the dependency available to your app, execute the <ph id="ph1">`dotnet restore`</ph> command after adding the dependency.</source>
          <target state="translated">請在加入相依性後執行 <ph id="ph1">`dotnet restore`</ph> 命令，讓應用程式取得相依性。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Because the dependency is resolved out of the local NuGet cache at publish time, it must be available on your system.</source>
          <target state="translated">因為相依性是在發行時於本機 NuGet 快取外解析，所以必須能在系統中取得。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The following is the complete project.json file for this project:</source>
          <target state="translated">下面是此專案的完整 project.json 檔案：</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>When you deploy your application, any third-party dependencies used in your app are also contained with your application files.</source>
          <target state="translated">當您部署應用程式時，應用程式中任何協力廠商相依性也包含在應用程式檔案中。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Third-party libraries do not already have to be present on the system on which the app is running.</source>
          <target state="translated">協力廠商程式庫尚未出現在應用程式執行所在的系統上。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Note that you can only deploy a self-contained deployment with a third-party library to platforms supported by that library.</source>
          <target state="translated">請注意，您只能將具有協力廠商程式庫的自封式部署，部署到該程式庫支援的平台上。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>This is similar to having third-party dependencies with native dependencies in your framework-dependent deployment.</source>
          <target state="translated">這類似在與 Framework 相依的部署中有帶原生相依性的協力廠商相依性。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Deploying a self-contained deployment with a smaller footprint</source>
          <target state="translated">部署使用量較小的自封式部署</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>If the availability of adequate storage space on target systems is likely to be an issue, you can reduce the overall footprint of your app by excluding some system components.</source>
          <target state="translated">如果目標系統上無法取得足夠的儲存空間，您可以排除某些系統元件，以減少應用程式的整體使用量。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>To do this, you explicitly define the .NET Core components that your app includes in your project.json file.</source>
          <target state="translated">若要這樣做，您可以在 project.json 檔案中明確定義應用程式包含的 .NET Core 元件。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>To create a self-contained deployment with a smaller footprint, start by following the first two steps for creating a self-contained deployment.</source>
          <target state="translated">若要建立使用量較小的自封式部署，請從建立自封式部署的前兩個步驟開始。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Once you've run the <ph id="ph1">`dotnet new`</ph> command and added the C# source code to your app, do the following:</source>
          <target state="translated">一旦執行了 <ph id="ph1">`dotnet new`</ph> 命令，並將 C# 原始程式碼加入到您的應用程式中，請執行下列動作︰</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Open the <ph id="ph1">`project.json`</ph> file and replace the <ph id="ph2">`frameworks`</ph> section with the following:</source>
          <target state="translated">開啟 <ph id="ph1">`project.json`</ph> 檔案，並以下列內容取代 <ph id="ph2">`frameworks`</ph> 區段：</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>This does two things:</source>
          <target state="translated">這會執行兩項作業︰</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>It indicates that, instead of using the entire <ph id="ph1">`netcoreapp1.0`</ph> framework, which includes .NET Core CLR, the .NET Core Library, and a number of other system components, our app uses only the .NET Standard Library.</source>
          <target state="translated">它會指出，而不是使用整個 <ph id="ph1">`netcoreapp1.0`</ph> Framework，哪些包括 .NET Core CLR、.NET Core 程式庫和幾個其他系統元件，而我們的應用程式只使用 .NET 標準庫。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>By removing the <ph id="ph1">`"type": "platform"`</ph> attribute, it indicates that the framework is provided as a set of components local to our app, rather than as a system-wide platform package.</source>
          <target state="translated">藉由移除 <ph id="ph1">`"type": "platform"`</ph> 屬性，指出 Framework 已提供為應用程式的一組本機元件，而非全系統的平台封裝。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Replace the <ph id="ph1">`dependencies`</ph> section with the following:</source>
          <target state="translated">以下列內容取代 <ph id="ph1">`dependencies`</ph> 區段：</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>This defines the system components used by our app.</source>
          <target state="translated">這會定義我們應用程式所使用的系統元件。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The system components packaged with our app include the .NET Standard Library, the .NET Core runtime, and the .NET Core host.</source>
          <target state="translated">與我們的應用程式一起封裝的系統元件，包括 .NET 標準程式庫、.NET Core 執行階段和 .NET Core 主應用程式。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This produces a self-contained deployment with a smaller footprint.</source>
          <target state="translated">這會產生使用量較小的自封式部署。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>As you did in the <bpt id="p1">[</bpt>Deploying a simple self-contained deployment<ept id="p1">](#simpleSelf)</ept> example, create a <ph id="ph1">`runtimes`</ph> section in your <ph id="ph2">`project.json`</ph> file that defines the platforms your app targets and specify the runtime identifier of each platform that you target.</source>
          <target state="translated">如您在<bpt id="p1">[</bpt>部署簡單的自封式部署<ept id="p1">](#simpleSelf)</ept>範例中所做的那樣，在定義應用程式目標平台的 <ph id="ph2">`project.json`</ph> 檔案中建立 <ph id="ph1">`runtimes`</ph> 區段，並指定每個目標平台的執行階段識別碼。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Runtime IDentifier catalog<ept id="p1">](../rid-catalog.md)</ept> for a list of runtime identifiers.</source>
          <target state="translated">如需執行階段識別碼清單，請參閱 <bpt id="p1">[</bpt>Runtime IDentifier catalog<ept id="p1">](../rid-catalog.md)</ept>。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For example, the following <ph id="ph1">`runtimes`</ph> section indicates that the app runs on 64-bit Windows 10 operating systems and the 64-bit OS X Version 10.10 operating system.</source>
          <target state="translated">例如，下列 <ph id="ph1">`runtimes`</ph> 區段指出應用程式在 64 位元 Windows 10 作業系統和 64 位元 OS X 版本 10.10 作業系統上執行。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Note that you also need to add a comma to separate the <ph id="ph1">`runtimes`</ph> section from the previous section.</source>
          <target state="translated">請注意，您也需要加入逗號來分隔 <ph id="ph1">`runtimes`</ph> 區段與上一個區段。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>A complete sample <ph id="ph1">`project.json`</ph> file appears later in this section.</source>
          <target state="translated">本節稍後會提供完整的範例 <ph id="ph1">`project.json`</ph> 檔。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Run the <ph id="ph1">`dotnet restore`</ph> command to restore the dependencies specified in your project.</source>
          <target state="translated">執行 <ph id="ph1">`dotnet restore`</ph> 命令還原專案中指定的相依性。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Create debug builds of your app on each of the target platforms by using the <ph id="ph1">`dotnet build`</ph> command.</source>
          <target state="translated">使用 <ph id="ph1">`dotnet build`</ph> 命令在每個目標平台上建立應用程式的偵錯組建。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Unless you specify the runtime identifier you'd like to build, the <ph id="ph1">`dotnet build`</ph> command creates a build only for the current system's runtime ID.</source>
          <target state="translated">除非您指定想要建置的執行階段識別碼，否則 <ph id="ph1">`dotnet build`</ph> 命令只會建立目前系統的執行階段識別碼。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>You can build your app for both target platforms with the commands:</source>
          <target state="translated">您可以使用下列命令為兩個目標平台建置應用程式︰</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>After you've debugged and tested the program, you can create the files to be deployed with your app for each platform that it targets by using the <ph id="ph1">`dotnet publish`</ph> command for both target platforms as follows:</source>
          <target state="translated">偵錯並測試完程式之後，您可以對兩個目標平台使用 <ph id="ph1">`dotnet publish`</ph> 命令，建立針對每個目標平台要與應用程式一起部署的檔案，如下所示︰</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>This creates a release (rather than a debug) version of your app for each target platform.</source>
          <target state="translated">這會建立每個目標平台的應用程式發行 (而非偵錯) 版本。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The resulting files are placed in a subdirectory named <ph id="ph1">`publish`</ph> that is in a subdirectory of your project's <ph id="ph2">`.\bin\release\netstandard1.6\&lt;runtime_identifier&gt;`</ph> subdirectory.</source>
          <target state="translated">產生的檔案會放在名為 <ph id="ph1">`publish`</ph> 的子目錄中，位在您專案的 <ph id="ph2">`.\bin\release\netstandard1.6\&lt;runtime_identifier&gt;`</ph> 子目錄的子目錄中。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Note that each subdirectory contains the complete set of files (both your app files and all .NET Core files) needed to launch your app.</source>
          <target state="translated">請注意，每個子目錄都包含啟動應用程式所需的一組完整檔案 (應用程式檔案和所有的 .NET Core 檔案)。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app.</source>
          <target state="translated">隨著應用程式檔案一起，發佈程序會發出程式資料庫 (.pdb) 檔案，其中包含應用程式的偵錯資訊。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.</source>
          <target state="translated">檔案主要用於偵錯例外狀況，您可以選擇應用程式檔案不封裝它。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The published files can be deployed in any way you'd like.</source>
          <target state="translated">您可以任何想要的方式部署已發行的檔案。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>For example, you can package them in a zip file, use a simple <ph id="ph1">`copy`</ph> command, or deploy them with any installation package of your choice.</source>
          <target state="translated">例如，您可以使用簡單的 <ph id="ph1">`copy`</ph> 命令將它們封裝在 zip 檔案中，或與您選擇的任何安裝封裝一起部署。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The following is the complete <ph id="ph1">`project.json`</ph> file for this project.</source>
          <target state="translated">下面是此專案的完整 <ph id="ph1">`project.json`</ph> 檔案。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>