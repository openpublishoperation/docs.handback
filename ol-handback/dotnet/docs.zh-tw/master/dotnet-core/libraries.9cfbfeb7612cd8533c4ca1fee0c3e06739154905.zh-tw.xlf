<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">de44f103bef6006dd1a952c48c1e172f6277a95b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tutorials\libraries.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6f2b04e8d5c448a63da146c4d53652c491dd6280</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc2affac42c561e4630e4e5f6d52ededbb77a46e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Developing Libraries with Cross Platform Tools</source>
          <target state="translated">使用跨平台工具開發程式庫</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Developing Libraries with Cross Platform Tools</source>
          <target state="translated">使用跨平台工具開發程式庫</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Developing Libraries with Cross Platform Tools</source>
          <target state="translated">使用跨平台工具開發程式庫</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Some details are subject to change as the toolchain evolves.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>部分詳細資料會隨著工具鏈發展而變更。<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This article covers how to write libraries for .NET using cross-platform CLI tools.</source>
          <target state="translated">本文涵蓋如何使用跨平台 CLI 工具撰寫 .NET 的程式庫。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The CLI provides an efficient and low-level experience that works across any supported OS.</source>
          <target state="translated">CLI 提供可在所有支援的作業系統上運作的有效率且低階體驗。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You can still build libraries with Visual Studio, and if that is your preferred experience <bpt id="p1">[</bpt>refer to the Visual Studio guide<ept id="p1">](libraries-with-vs.md)</ept>.</source>
          <target state="translated">您仍然可以使用 Visual Studio 來建置程式庫，而且，如果那是您偏好的體驗，<bpt id="p1">[</bpt>請參閱 Visual Studio 指南<ept id="p1">](libraries-with-vs.md)</ept>。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">必要條件</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You need <bpt id="p1">[</bpt>the .NET Core SDK and CLI<ept id="p1">](https://www.microsoft.com/net/core)</ept> installed on your machine.</source>
          <target state="translated">您需要在電腦上安裝 <bpt id="p1">[</bpt>.NET Core SDK 和 CLI<ept id="p1">](https://www.microsoft.com/net/core)</ept>。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For the sections of this document dealing with .NET Framework versions or Portable Class Libraries (PCL), you need the <bpt id="p1">[</bpt>.NET Framework<ept id="p1">](http://getdotnet.azurewebsites.net/)</ept> installed on a Windows machine.</source>
          <target state="translated">如需這份文件中處理 .NET Framework 版本或可攜式類別庫 (PCL) 的小節，您需要在 Windows 電腦上安裝 <bpt id="p1">[</bpt>.NET Framework<ept id="p1">](http://getdotnet.azurewebsites.net/)</ept>。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Additionally, if you wish to support older .NET Framework targets, you need to install targeting/developer packs for older framework versions from the <bpt id="p1">[</bpt>.NET target platforms page<ept id="p1">](http://getdotnet.azurewebsites.net/target-dotnet-platforms.html)</ept>.</source>
          <target state="translated">此外，如果您想要支援較舊的 .NET Framework 目標，則需要從 <bpt id="p1">[</bpt>.NET target platforms<ept id="p1">](http://getdotnet.azurewebsites.net/target-dotnet-platforms.html)</ept> 頁面安裝較舊 Framework 版本的目標/開發人員套件。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Refer to this table:</source>
          <target state="translated">請參閱這張表格︰</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>.NET Framework Version</source>
          <target state="translated">.NET Framework 版本</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>What to download</source>
          <target state="translated">要下載的項目</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>4.6.1</source>
          <target state="translated">4.6.1</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.6.1 Targeting Pack</source>
          <target state="translated">.NET Framework 4.6.1 目標套件</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>4.6</source>
          <target state="translated">4.6</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.6 Targeting Pack</source>
          <target state="translated">.NET Framework 4.6 目標套件</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>4.5.2</source>
          <target state="translated">4.5.2</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.5.2 Developer Pack</source>
          <target state="translated">.NET Framework 4.5.2 開發人員套件</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>4.5.1</source>
          <target state="translated">4.5.1</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.5.1 Developer Pack</source>
          <target state="translated">.NET Framework 4.5.1 開發人員套件</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>4.5</source>
          <target state="translated">4.5</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Windows Software Development Kit for Windows 8</source>
          <target state="translated">適用於 Windows 8 的 Windows 軟體開發套件</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>4.0</source>
          <target state="translated">4.0</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Windows SDK for Windows 7 and .NET Framework 4</source>
          <target state="translated">適用於 Windows 7 的 Windows SDK 及 .NET Framework 4</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>2.0, 3.0, and 3.5</source>
          <target state="translated">2.0、3.0 和 3.5</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>.NET Framework 3.5 SP1 Runtime (or Windows 8+ version)</source>
          <target state="translated">.NET Framework 3.5 SP1 執行階段 (或 Windows 8+ 版本)</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>How to target the .NET Standard</source>
          <target state="translated">如何將目標設為 .NET Standard</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If you're not quite familiar with the .NET Standard, refer to <bpt id="p1">[</bpt>the .NET Standard Library<ept id="p1">](../../standard/library.md)</ept> to learn more.</source>
          <target state="translated">如果您不是很熟悉 .NET Standard，請參閱 <bpt id="p1">[</bpt>.NET Standard 程式庫<ept id="p1">](../../standard/library.md)</ept>來深入了解。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In that article, there is a table which maps .NET Standard versions to various implementations:</source>
          <target state="translated">在該文中，有一張將 .NET Standard 版本對應至各種實作的表格︰</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Platform Name</source>
          <target state="translated">平台名稱</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>.NET Standard</source>
          <target state="translated">.NET Standard</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>netstandard</source>
          <target state="translated">netstandard</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>1.0</source>
          <target state="translated">1.0</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>1.1</source>
          <target state="translated">1.1</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>1.2</source>
          <target state="translated">1.2</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>1.3</source>
          <target state="translated">1.3</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>1.4</source>
          <target state="translated">1.4</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>1.5</source>
          <target state="translated">1.5</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>1.6</source>
          <target state="translated">1.6</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>.NET Core</source>
          <target state="translated">.NET 核心</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>netcoreapp</source>
          <target state="translated">netcoreapp</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>1.0</source>
          <target state="translated">1.0</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>.NET Framework</source>
          <target state="translated">.NET Framework</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>net</source>
          <target state="translated">net</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>4.5</source>
          <target state="translated">4.5</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>4.5.1</source>
          <target state="translated">4.5.1</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>4.6</source>
          <target state="translated">4.6</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>4.6.1</source>
          <target state="translated">4.6.1</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>4.6.2</source>
          <target state="translated">4.6.2</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>4.6.3</source>
          <target state="translated">4.6.3</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Mono/Xamarin Platforms</source>
          <target state="translated">Mono/Xamarin 平台</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Universal Windows Platform</source>
          <target state="translated">通用 Windows 平台</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>uap</source>
          <target state="translated">uap</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>10.0</source>
          <target state="translated">10.0</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>win</source>
          <target state="translated">win</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>8.0</source>
          <target state="translated">8.0</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>8.1</source>
          <target state="translated">8.1</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Windows Phone</source>
          <target state="translated">Windows Phone</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>wpa</source>
          <target state="translated">wpa</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>8.1</source>
          <target state="translated">8.1</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Windows Phone Silverlight</source>
          <target state="translated">Windows Phone Silverlight</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>wp</source>
          <target state="translated">wp</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>8.0</source>
          <target state="translated">8.0</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Here's what this table means for the purposes of creating a library:</source>
          <target state="translated">以下是這個資料表在建立程式庫時的意義︰</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The version of the .NET Platform Standard you pick will be a tradeoff between access to the newest APIs and ability to target more .NET platforms and Framework versions.</source>
          <target state="translated">您選擇的 .NET Standard 平台版本將會在最新 API 的存取與將目標設為多個 .NET 平台和 Framework 版本的能力之間進行取捨。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>You control the range of targetable platforms and versions by picking a version of <ph id="ph1">`netstandardX.X`</ph> (Where <ph id="ph2">`X.X`</ph> is a version number) and adding it to your <ph id="ph3">`project.json`</ph> file.</source>
          <target state="translated">您可以控制可設為目標之平台和版本的範圍，方法是選擇 <ph id="ph1">`netstandardX.X`</ph> 版本 (其中 <ph id="ph2">`X.X`</ph> 是版本號碼)，並將它新增至 <ph id="ph3">`project.json`</ph> 檔案。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Additionally, the corresponding <bpt id="p1">[</bpt>NuGet package to depend on<ept id="p1">](https://www.nuget.org/packages/NETStandard.Library/)</ept> is <ph id="ph1">`NETStandard.Library`</ph> version <ph id="ph2">`1.6.0`</ph>.</source>
          <target state="translated">此外，<bpt id="p1">[</bpt>要相依的對應 NuGet 套件<ept id="p1">](https://www.nuget.org/packages/NETStandard.Library/)</ept>是 <ph id="ph1">`NETStandard.Library`</ph> <ph id="ph2">`1.6.0`</ph> 版。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Although there's nothing preventing you from depending on <ph id="ph1">`Microsoft.NETCore.App`</ph> like with console apps, it's generally not recommended.</source>
          <target state="translated">雖然沒有任何事項可以防止您相依於 <ph id="ph1">`Microsoft.NETCore.App`</ph> (例如使用主控台應用程式)，但是一般不建議這麼做。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>If you need APIs from a package not specified in <ph id="ph1">`NETStandard.Library`</ph>, you can always specify that package in addition to <ph id="ph2">`NETStandard.Library`</ph> in the <ph id="ph3">`dependencies`</ph> section of your <ph id="ph4">`project.json`</ph> file.</source>
          <target state="translated">如果您需要 <ph id="ph1">`NETStandard.Library`</ph> 中來自未指定套件的 API，則除了 <ph id="ph4">`project.json`</ph> 檔案的 <ph id="ph3">`dependencies`</ph> 區段中的 <ph id="ph2">`NETStandard.Library`</ph> 之外，一律可以指定該套件。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You have three primary options when targeting the .NET Standard, depending on your needs.</source>
          <target state="translated">將目標設為 .NET Standard 時，會有三個主要選項 (視需求而定)。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can use the latest version of the .NET Standard - <ph id="ph1">`netstandard1.6`</ph> - which is for when you want access to the most APIs and don't mind if you have less reach across implementations.</source>
          <target state="translated">您可以使用最新版本的 .NET Standard (<ph id="ph1">`netstandard1.6`</ph>)，這適用於想要存取大部分 API 時，而且較少跨實作時則不用在意。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can use a lower version of the .NET Standard to target earlier .NET implementations.</source>
          <target state="translated">您可以使用較低版本的 .NET Standard，以將目標設為較舊的 .NET 實作。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The cost here is not having access to some of the latest APIs.</source>
          <target state="translated">這裡的成本不包含存取一些最新的 API。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For example, if you wanted to have guaranteed compatibility with .NET Framework 4.6 and higher, you would pick <ph id="ph1">`netstandard1.3`</ph>:</source>
          <target state="translated">例如，如果您想要確保與 .NET Framework 4.6 和更新版本相容，請挑選 <ph id="ph1">`netstandard1.3`</ph>：</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>.NET Standard versions are backward compatible.</source>
          <target state="translated">.NET Standard 版本具備回溯相容。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>That means that <ph id="ph1">`netstandard1.0`</ph> libraries run on <ph id="ph2">`netstandard1.1`</ph> platforms and higher.</source>
          <target state="translated">這表示 <ph id="ph1">`netstandard1.0`</ph> 程式庫是在 <ph id="ph2">`netstandard1.1`</ph> 平台和更高版本上執行。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>However, there is no forward compatibility - lower .NET Standard platforms cannot reference higher ones.</source>
          <target state="translated">不過，沒有往後相容性 - 較低的 .NET Standard 平台無法參考較高的平台。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This means that <ph id="ph1">`netstandard1.0`</ph> libraries cannot reference libraries targeting <ph id="ph2">`netstandard1.1`</ph> or higher.</source>
          <target state="translated">這表示 <ph id="ph1">`netstandard1.0`</ph> 程式庫無法參考目標設為 <ph id="ph2">`netstandard1.1`</ph> 或更高版本的程式庫。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Select the Standard version that has the right mix of APIs and platform support for your needs.</source>
          <target state="translated">針對您的需求，選取正確混合使用 API 與平台支援的標準版本。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>If you want to target the .NET Framework versions 4.0 or below, or you wish to use an API available in the .NET Framework but not in the .NET Standard (for example, <ph id="ph1">`System.Drawing`</ph>), read the following sections and learn how to multitarget.</source>
          <target state="translated">如果您想要將目標設為 .NET Framework 4.0 或以下版本，或者想要使用位在 .NET Framework 中但不在 .NET Standard 中的 API (例如，<ph id="ph1">`System.Drawing`</ph>)，請閱讀下列各節，並了解如何使用多目標。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>How to target the .NET Framework</source>
          <target state="translated">如何將目標設為 .NET Framework</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>These instructions assume you have the .NET Framework installed on your machine.</source>
          <target state="translated">這些指示假設您已在電腦上安裝 .NET Framework。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Refer to the <bpt id="p1">[</bpt>Prerequisites<ept id="p1">](#prerequisites)</ept> to get dependencies installed.</source>
          <target state="translated">請參閱安裝相依性的<bpt id="p1">[</bpt>必要條件<ept id="p1">](#prerequisites)</ept>。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Keep in mind that some of the .NET Framework versions used here are no longer in support.</source>
          <target state="translated">請記住，將不再支援這裡使用的一些 .NET Framework 版本。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Refer to the <bpt id="p1">[</bpt>.NET Framework Support Lifecycle Policy FAQ<ept id="p1">](https://support.microsoft.com/gp/framework_faq/en-us)</ept> about unsupported versions.</source>
          <target state="translated">如需不支援的版本，請參閱 <bpt id="p1">[</bpt>.NET Framework Support Lifecycle Policy FAQ<ept id="p1">](https://support.microsoft.com/gp/framework_faq/en-us)</ept> (.NET Framework 支援週期原則 FAQ)。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>If you want to reach the maximum number of developers and projects, use the .NET Framework 4 as your baseline target.</source>
          <target state="translated">如果您想要達到開發人員和專案數目上限，請使用 .NET Framework 4 作為基準目標。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To target the .NET Framework, you will need to begin by using the correct Target Framework Moniker (TFM) that corresponds to the .NET Framework version you wish to support.</source>
          <target state="translated">若要將目標設為 .NET Framework，您需要從使用對應至所要支援之 .NET Framework 版本的正確目標 Framework Moniker (TFM) 開始。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For example, here's how you would write a library which targets the .NET Framework 4:</source>
          <target state="translated">例如，以下是如何撰寫目標設為 .NET Framework 4 的程式庫：</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">就是這麼容易！</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Although this compiled only for the .NET Framework 4, you can use the library on newer versions of the .NET Framework.</source>
          <target state="translated">雖然這只是針對 .NET Framework 4 所編譯，但是您可以在較新版的 .NET Framework 上使用程式庫。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>How to target a Portable Class Library (PCL)</source>
          <target state="translated">如何將目標設為可攜式類別庫 (PCL)</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>These instructions assume you have the .NET Framework installed on your machine.</source>
          <target state="translated">這些指示假設您已在電腦上安裝 .NET Framework。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Refer to the <bpt id="p1">[</bpt>Prerequisites<ept id="p1">](#prerequisites)</ept> to get dependencies installed.</source>
          <target state="translated">請參閱安裝相依性的<bpt id="p1">[</bpt>必要條件<ept id="p1">](#prerequisites)</ept>。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Targeting a PCL profile is a bit trickier than targeting .NET Standard or the .NET Framework.</source>
          <target state="translated">將目標設為 PCL 設定檔，比將目標設為 .NET Standard 或 .NET Framework 更難處理。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For starters, <bpt id="p1">[</bpt>reference this list of PCL profiles<ept id="p1">](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview)</ept> to find the NuGet target which corresponds to the PCL profile you are targeting.</source>
          <target state="translated">如果是新手，請<bpt id="p1">[</bpt>參考這份 PCL 設定檔清單<ept id="p1">](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview)</ept>，以找到對應至設為目標之 PCL 設定檔的 NuGet 目標。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Then, you need to do the following:</source>
          <target state="translated">接著，您可能需要執行下列動作：</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Create a new entry under <ph id="ph1">`frameworks`</ph> in your <ph id="ph2">`project.json`</ph>, named <ph id="ph3">`.NETPortable,Version=v{version},Profile=Profile{profile}`</ph>, where <ph id="ph4">`{version}`</ph> and <ph id="ph5">`{profile}`</ph> correspond to a PCL version number and Profile number, respectively.</source>
          <target state="translated">在 <ph id="ph2">`project.json`</ph> 的 <ph id="ph1">`frameworks`</ph> 下方建立名為 <ph id="ph3">`.NETPortable,Version=v{version},Profile=Profile{profile}`</ph> 的新項目，其中 <ph id="ph4">`{version}`</ph> 和 <ph id="ph5">`{profile}`</ph> 分別對應至 PCL 版本號碼和設定檔號碼。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In this new entry, list every single assembly used for that target under a <ph id="ph1">`frameworkAssemblies`</ph> entry.</source>
          <target state="translated">在這個新的項目中，列出 <ph id="ph1">`frameworkAssemblies`</ph> 項目下方每個用於該目標的單一組件。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This includes <ph id="ph1">`mscorlib`</ph>, <ph id="ph2">`System`</ph>, and <ph id="ph3">`System.Core`</ph>.</source>
          <target state="translated">這包含 <ph id="ph1">`mscorlib`</ph>、<ph id="ph2">`System`</ph> 和 <ph id="ph3">`System.Core`</ph>。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If you are multitargeting (see the next section), you must explicitly list dependencies for each target under their target entries.</source>
          <target state="translated">如果您是使用多目標 (請參閱下一節)，則必須在其目標項目下方明確列出每個目標的相依性。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>You won't be able to use a global <ph id="ph1">`dependencies`</ph> entry anymore.</source>
          <target state="translated">您將無法再使用全域 <ph id="ph1">`dependencies`</ph> 項目。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The following is an example targeting PCL Profile 328.</source>
          <target state="translated">下列是範例目標 PCL Profile 328。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Profile 328 supports: .NET Standard 1.4, .NET Framework 4, Windows 8, Windows Phone 8.1, Windows Phone Silverlight 8.1, and Silverlight 5.</source>
          <target state="translated">Profile 328 支援：.NET Standard 1.4、.NET Framework 4、Windows 8、Windows Phone 8.1、Windows Phone Silverlight 8.1 和 Silverlight 5。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>When you build a project that includes PCL Profile 328 as a framework in the <bpt id="p1">*</bpt>project.json<ept id="p1">*</ept> file, it will have this subfolder in the <bpt id="p2">*</bpt>/bin/debug<ept id="p2">*</ept> folder:</source>
          <target state="translated">如果您所建置的專案在 <bpt id="p1">*</bpt>project.json<ept id="p1">*</ept> 檔案中包含 PCL Profile 328 作為架構，則在 <bpt id="p2">*</bpt>/bin/debug<ept id="p2">*</ept> 資料夾中會有這個子資料夾︰</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>This folder contains the <ph id="ph1">`.dll`</ph> files necessary to run your library.</source>
          <target state="translated">這個資料夾包含執行您程式庫所需的 <ph id="ph1">`.dll`</ph> 檔案。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>How to Multitarget</source>
          <target state="translated">如何使用多目標</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The following instructions assume you have the .NET Framework installed on your machine.</source>
          <target state="translated">下列指示假設您已在電腦上安裝 .NET Framework。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Refer to the <bpt id="p1">[</bpt>Prerequisites<ept id="p1">](#prerequisites)</ept> section to learn which dependencies you need to install and where to download them from.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>必要條件<ept id="p1">](#prerequisites)</ept>小節，了解您需要安裝的相依性以及其下載位置。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>You may need to target older versions of the .NET Framework when your project supports both the .NET Framework and .NET Core.</source>
          <target state="translated">當您的專案同時支援 .NET Framework 和 .NET Core 時，可能需要將目標設為舊版 .NET Framework。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>In this scenario, if you want to use newer APIs and language constructs for the newer targets, use <ph id="ph1">`#if`</ph> directives in your code.</source>
          <target state="translated">在這個案例中，如果您想要為較新的目標使用較新的 API 和語言建構，請在程式碼中使用 <ph id="ph1">`#if`</ph> 指示詞。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>You also might need to add different packages and dependencies in your <ph id="ph1">`project.json file`</ph> for each platform you're targeting to include the different APIs needed for each case.</source>
          <target state="translated">您也可能需要針對設為目標的每個平台，在 <ph id="ph1">`project.json file`</ph> 中新增不同的套件和相依性，以包含每個案例所需的不同 API。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a library that performs networking operations over HTTP.</source>
          <target state="translated">例如，假設您的程式庫透過 HTTP 執行網路作業。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>For .NET Standard and the .NET Framework versions 4.5 or higher, you can use the <ph id="ph1">`HttpClient`</ph> class from the <ph id="ph2">`System.Net.Http`</ph> namespace.</source>
          <target state="translated">針對 .NET Standard 和 .NET Framework 4.5 版或更高版本，您可以使用 <ph id="ph2">`System.Net.Http`</ph> 命名空間中的 <ph id="ph1">`HttpClient`</ph> 類別。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>However, earlier versions of the .NET Framework don't have the <ph id="ph1">`HttpClient`</ph> class, so you could use the <ph id="ph2">`WebClient`</ph> class from the <ph id="ph3">`System.Net`</ph> namespace for those instead.</source>
          <target state="translated">不過，舊版 .NET Framework 沒有 <ph id="ph1">`HttpClient`</ph> 類別，因此您可以改用這些項目之 <ph id="ph3">`System.Net`</ph> 命名空間中的 <ph id="ph2">`WebClient`</ph> 類別。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>So, the <ph id="ph1">`project.json`</ph> file could look like this:</source>
          <target state="translated">因此，<ph id="ph1">`project.json`</ph> 檔案如下所示：</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Note that the .NET Framework assemblies need to be referenced explicitly in the <ph id="ph1">`net40`</ph> and <ph id="ph2">`net452`</ph> target, and NuGet references are also explicitly listed in the <ph id="ph3">`netstandard1.6`</ph> target.</source>
          <target state="translated">請注意，需要在 <ph id="ph1">`net40`</ph> 和 <ph id="ph2">`net452`</ph> 目標中明確參考 .NET Framework 組件，並且也在 <ph id="ph3">`netstandard1.6`</ph> 目標中明確列出 NuGet 參考。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>This is required in multitargeting scenarios.</source>
          <target state="translated">這在多目標案例中是必要的。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Next, the <ph id="ph1">`using`</ph> statements in your source file can be adjusted like this:</source>
          <target state="translated">接下來，可以如下調整原始程式檔中的 <ph id="ph1">`using`</ph> 陳述式：</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The build system is aware of the following preprocessor symbols used in <ph id="ph1">`#if`</ph> directives:</source>
          <target state="translated">建置系統會得知 <ph id="ph1">`#if`</ph> 指示詞中所使用的下列前置處理器符號︰</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>And in the middle of the source, you can use <ph id="ph1">`#if`</ph> directives to use those libraries conditionally.</source>
          <target state="translated">而且在來源的中間，您可以使用 <ph id="ph1">`#if`</ph> 指示詞有條件地使用這些程式庫。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如: </target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>When you build a project that includes <ph id="ph1">`net40`</ph>, <ph id="ph2">`net45`</ph>, and <ph id="ph3">`netstandard1.6`</ph> as frameworks in the <bpt id="p1">*</bpt>project.json<ept id="p1">*</ept> file, it will have these subfolders in the <bpt id="p2">*</bpt>/bin/debug<ept id="p2">*</ept> folder:</source>
          <target state="translated">如果您所建置的專案在 <bpt id="p1">*</bpt>project.json<ept id="p1">*</ept> 檔案中包含 <ph id="ph1">`net40`</ph>、<ph id="ph2">`net45`</ph> 和 <ph id="ph3">`netstandard1.6`</ph> 作為架構，則在 <bpt id="p2">*</bpt>/bin/debug<ept id="p2">*</ept> 資料夾中會有這些子資料夾︰</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>But What about Multitargeting with Portable Class Libraries?</source>
          <target state="translated">但是具有可攜式類別庫的多目標怎麼辦？</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>If you want to cross-compile with a PCL target, you must add a build definition in your <ph id="ph1">`project.json`</ph> file under <ph id="ph2">`buildOptions`</ph> in your PCL target.</source>
          <target state="translated">如果您想要與 PCL 目標交叉編譯，則必須在 PCL 目標中於 <ph id="ph2">`buildOptions`</ph> 的 <ph id="ph1">`project.json`</ph> 檔案中新增組建定義。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>You can then use <ph id="ph1">`#if`</ph> directives in the source which use the build definition as a preprocessor symbol.</source>
          <target state="translated">您接著可以在來源中使用將組建定義當成前置處理器符號使用的 <ph id="ph1">`#if`</ph> 指示詞。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>For example, if you want to target <bpt id="p1">[</bpt>PCL profile 328<ept id="p1">](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview)</ept> (The .NET Framework 4, Windows 8, Windows Phone Silverlight 8, Windows Phone 8.1, Silverlight 5), you could to refer to it to as "PORTABLE328" when cross-compiling.</source>
          <target state="translated">例如，如果您想要將目標設為 <bpt id="p1">[</bpt>PCL profile 328<ept id="p1">](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview)</ept> (.NET Framework 4、Windows 8、Windows Phone Silverlight 8、Windows Phone 8.1、Silverlight 5)，則可以在跨編譯時以 "PORTABLE328" 形式參照它。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Simply add it to the <ph id="ph1">`project.json`</ph> file as a <ph id="ph2">`buildOptions`</ph> attribute:</source>
          <target state="translated">只要將它當成 <ph id="ph2">`buildOptions`</ph> 屬性新增至 <ph id="ph1">`project.json`</ph> 檔案︰</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Now you can conditionally compile against that target:</source>
          <target state="translated">現在您可以針對該目標有條件地進行編譯︰</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`PORTABLE328`</ph> is now recognized by the compiler, the PCL Profile 328 library generated by a compiler will not include <ph id="ph2">`System.Net.Http`</ph> or <ph id="ph3">`System.Threading.Tasks`</ph>.</source>
          <target state="translated">因為編譯器現在可以辨識 <ph id="ph1">`PORTABLE328`</ph>，所以編譯器所產生的 PCL Profile 328 程式庫將不會包含 <ph id="ph2">`System.Net.Http`</ph> 或 <ph id="ph3">`System.Threading.Tasks`</ph>。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>When you build a project that includes PCL Profile 328 and <ph id="ph1">`netstandard1.6`</ph> as frameworks in the <bpt id="p1">*</bpt>project.json<ept id="p1">*</ept> file, it will have these subfolders in the <bpt id="p2">*</bpt>/bin/debug<ept id="p2">*</ept> folder:</source>
          <target state="translated">如果您所建置的專案在 <bpt id="p1">*</bpt>project.json<ept id="p1">*</ept> 檔案中包含 PCL Profile 328 和 <ph id="ph1">`netstandard1.6`</ph> 作為架構，則在 <bpt id="p2">*</bpt>/bin/debug<ept id="p2">*</ept> 資料夾中會有這些子資料夾︰</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>How to use native dependencies</source>
          <target state="translated">如何使用原生相依性</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>You may wish to write a library which depends on a native <ph id="ph1">`.dll`</ph> file.</source>
          <target state="translated">您可能想要撰寫與原生 <ph id="ph1">`.dll`</ph> 檔案相依的程式庫。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>If you're writing such a library, you have have two options:</source>
          <target state="translated">如果您正在撰寫這類程式庫，則會有兩個選項︰</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Reference the native <ph id="ph1">`.dll`</ph> directly in your <ph id="ph2">`project.json`</ph>.</source>
          <target state="translated">在 <ph id="ph2">`project.json`</ph> 中直接參考原生 <ph id="ph1">`.dll`</ph>。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Package that <ph id="ph1">`.dll`</ph> into its own NuGet package and depend on that package.</source>
          <target state="translated">將該 <ph id="ph1">`.dll`</ph> 封裝到其專屬 NuGet 套件，並與該套件相依。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For the first option, you'll need to include the following in your <ph id="ph1">`project.json`</ph> file:</source>
          <target state="translated">針對第一個選項，您必須在 <ph id="ph1">`project.json`</ph> 檔案中包含下列項目︰</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Setting <ph id="ph1">`allowUnsafe`</ph> to <ph id="ph2">`true`</ph> in a <ph id="ph3">`buildOptions`</ph> section.</source>
          <target state="translated">在 <ph id="ph3">`buildOptions`</ph> 區段中，將 <ph id="ph1">`allowUnsafe`</ph> 設定為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Specifying a <bpt id="p1">[</bpt>Runtime Identifier (RID)<ept id="p1">](../rid-catalog.md)</ept> in a <ph id="ph1">`runtimes`</ph> section.</source>
          <target state="translated">在 <ph id="ph1">`runtimes`</ph> 區段中指定<bpt id="p1">[</bpt>執行階段識別項 (RID)<ept id="p1">](../rid-catalog.md)</ept>。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Specifying the path to the native <ph id="ph1">`.dll`</ph> file(s) that you are referencing.</source>
          <target state="translated">指定所參考之原生 <ph id="ph1">`.dll`</ph> 檔案的路徑。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Here's an example <ph id="ph1">`project.json`</ph> for a native <ph id="ph2">`.dll`</ph> file in the root directory of the project which runs on Windows:</source>
          <target state="translated">以下是在 Windows 上執行之專案根目錄中原生 <ph id="ph2">`.dll`</ph> 檔案的範例 <ph id="ph1">`project.json`</ph>：</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>If you're distributing your library as a package, it's recommended that you place the <ph id="ph1">`.dll`</ph> file at the root level of your project.</source>
          <target state="translated">如果您將程式庫散發為套件，則建議您將 <ph id="ph1">`.dll`</ph> 檔案放在專案的根層級。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For the second option, you'll need to build a NuGet package out of your <ph id="ph1">`.dll`</ph> file(s), host on a NuGet or MyGet feed, and depend on it directly.</source>
          <target state="translated">針對第二個選項，您需要透過 <ph id="ph1">`.dll`</ph> 檔案建置 NuGet 套件、將它裝載於 NuGet 或 MyGet 摘要，並且直接與它相依。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>You'll still need to set <ph id="ph1">`allowUnsafe`</ph> to <ph id="ph2">`true`</ph> in the <ph id="ph3">`buildOptions`</ph> section of your <ph id="ph4">`project.json`</ph>.</source>
          <target state="translated">您仍然需要在 <ph id="ph4">`project.json`</ph> 的 <ph id="ph3">`buildOptions`</ph> 區段中，將 <ph id="ph1">`allowUnsafe`</ph> 設定為 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Here's an example (assuming <ph id="ph1">`MyNativeLib`</ph> is a Nuget package at version <ph id="ph2">`1.2.0`</ph>):</source>
          <target state="translated">以下是範例 (假設 <ph id="ph1">`MyNativeLib`</ph> 是 <ph id="ph2">`1.2.0`</ph> 版的 Nuget 套件)：</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>To see an example of packaging up cross-platform native binaries, check out the <bpt id="p1">[</bpt>ASP.NET Libuv Package<ept id="p1">](https://github.com/aspnet/libuv-package)</ept> and the <bpt id="p2">[</bpt>corresponding reference in KestrelHttpServer<ept id="p2">](https://github.com/aspnet/KestrelHttpServer/blob/1.0.0/src/Microsoft.AspNetCore.Server.Kestrel/project.json#L19)</ept>.</source>
          <target state="translated">若要查看如何封裝跨平台原生二進位檔的範例，請參閱 <bpt id="p1">[</bpt>ASP.NET Libuv Package<ept id="p1">](https://github.com/aspnet/libuv-package)</ept> 和 <bpt id="p2">[</bpt>corresponding reference in KestrelHttpServer<ept id="p2">](https://github.com/aspnet/KestrelHttpServer/blob/1.0.0/src/Microsoft.AspNetCore.Server.Kestrel/project.json#L19)</ept>。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>How to test libraries on .NET Core</source>
          <target state="translated">如何測試 .NET Core 上的程式庫</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>It's important to be able to test across platforms.</source>
          <target state="translated">重要的是一定要可以跨平台進行測試。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>It's easiest to use <bpt id="p1">[</bpt>xUnit<ept id="p1">](http://xunit.github.io/)</ept>, which is also the testing tool used by .NET Core projects.</source>
          <target state="translated"><bpt id="p1">[</bpt>xUnit<ept id="p1">](http://xunit.github.io/)</ept> 的使用十分簡單，而且它也是 .NET Core 專案所使用的測試工具。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>How you set up your solution with test projects will depend on the <bpt id="p1">[</bpt>structure of your solution<ept id="p1">](#structuring-a-solution)</ept>.</source>
          <target state="translated">如何設定具有測試專案的方案，將取決於<bpt id="p1">[</bpt>方案結構<ept id="p1">](#structuring-a-solution)</ept>。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The following example assumes that all source projects are under a top-level <ph id="ph1">`/src`</ph> folder and all test projects are under a top-level <ph id="ph2">`/test`</ph> folder.</source>
          <target state="translated">下列範例假設所有來源專案都是位於最上層 <ph id="ph1">`/src`</ph> 資料夾下方，而所有測試專案都是位於最上層 <ph id="ph2">`/test`</ph> 資料夾下方。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Ensure you have a <ph id="ph1">`global.json`</ph> file at the solution level which understands where the test projects are:</source>
          <target state="translated">請確定您有方案層級的 <ph id="ph1">`global.json`</ph> 檔案，可以了解測試專案所在的位置：</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Your solution folder structure should then look like this:</source>
          <target state="translated">然後，您的方案資料夾結構應該如下︰</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Create a new test project by creating a project folder under your <ph id="ph1">`/test`</ph> folder, and a <ph id="ph2">`project.json`</ph> file in the new project folder.</source>
          <target state="translated">建立新的測試專案，方法是在 <ph id="ph1">`/test`</ph> 資料夾下方建立專案資料夾，並在新的專案資料夾中建立 <ph id="ph2">`project.json`</ph> 檔案。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>To create the <ph id="ph1">`project.json`</ph> file you can run the <ph id="ph2">`dotnet new`</ph> command and modify the <ph id="ph3">`project.json`</ph> file afterwards.</source>
          <target state="translated">若要建立 <ph id="ph1">`project.json`</ph> 檔案，您可以執行 <ph id="ph2">`dotnet new`</ph> 命令，之後即可修改 <ph id="ph3">`project.json`</ph> 檔案。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The file should have the following:</source>
          <target state="translated">檔案應該具有下列項目：</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`netcoreapp1.0`</ph> listed as the only entry under <ph id="ph2">`frameworks`</ph>.</source>
          <target state="translated"><ph id="ph1">`netcoreapp1.0`</ph>列為 <ph id="ph2">`frameworks`</ph> 下方的唯一項目。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>A reference to <ph id="ph1">`Microsoft.NETCore.App`</ph> version <ph id="ph2">`1.0.0`</ph>.</source>
          <target state="translated"><ph id="ph1">`Microsoft.NETCore.App`</ph> <ph id="ph2">`1.0.0`</ph> 版的參考。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>A reference to xUnit version <ph id="ph1">`2.2.0-beta2-build3300`</ph>.</source>
          <target state="translated">xUnit <ph id="ph1">`2.2.0-beta2-build3300`</ph> 版的參考。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>A reference to <ph id="ph1">`dotnet-test-xunit`</ph> version <ph id="ph2">`2.2.0-preview2-build1029`</ph></source>
          <target state="translated"><ph id="ph1">`dotnet-test-xunit`</ph><ph id="ph2">`2.2.0-preview2-build1029`</ph> 版的參考</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>A project reference to the library being tested.</source>
          <target state="translated">正在測試之程式庫的專案參考。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The entry <ph id="ph1">`"testRunner":"xunit"`</ph>.</source>
          <target state="translated">項目 <ph id="ph1">`"testRunner":"xunit"`</ph>。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Here's an example (<ph id="ph1">`LibraryUnderTest`</ph> version <ph id="ph2">`1.0.0`</ph> is the library being tested):</source>
          <target state="translated">以下是範例 (<ph id="ph1">`LibraryUnderTest`</ph> <ph id="ph2">`1.0.0`</ph> 版是正在測試的程式庫)：</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Restore packages by running <ph id="ph1">`dotnet restore`</ph>.</source>
          <target state="translated">執行 <ph id="ph1">`dotnet restore`</ph> 來還原套件。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>You should do this at the solution level if you haven't restored packages yet.</source>
          <target state="translated">如果您尚未還原過套件，則應該在方案層級執行這項作業。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Navigate to your test project and run tests with <ph id="ph1">`dotnet test`</ph>:</source>
          <target state="translated">瀏覽至測試專案，並使用 <ph id="ph1">`dotnet test`</ph> 執行測試：</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">就是這麼容易！</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>You can now test your library across all platforms using command line tools.</source>
          <target state="translated">您現在可以使用命令列工具跨所有平台來測試程式庫。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>To continue testing now that you have everything set up, testing your library is very simple:</source>
          <target state="translated">若要在設定好所有項目之後立即繼續測試，測試程式庫就會非常簡單︰</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Make changes to your library.</source>
          <target state="translated">對程式庫進行變更。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Run tests from the command line, in your test directory, with <ph id="ph1">`dotnet test`</ph> command.</source>
          <target state="translated">在測試目錄中，從命令列中使用 <ph id="ph1">`dotnet test`</ph> 命令來執行測試。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Your code will be automatically rebuilt when you invoke <ph id="ph1">`dotnet test`</ph> command.</source>
          <target state="translated">當您叫用 <ph id="ph1">`dotnet test`</ph> 命令時，將會自動重建程式碼。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Just remember to run <ph id="ph1">`dotnet restore`</ph> from the command line any time you add a new dependency and you'll be good to go!</source>
          <target state="translated">只要新增相依性，就請記得從命令列執行 <ph id="ph1">`dotnet restore`</ph>，這樣您就可以繼續往下進行！</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>How to use multiple projects</source>
          <target state="translated">如何使用多個專案</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>A common need for larger libraries is to place functionality in different projects.</source>
          <target state="translated">較大程式庫的常見需求是將功能放在不同的專案中。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Imagine you wished to build a library which could be consumed in idiomatic C# and F#.</source>
          <target state="translated">假設您想要建置可在慣用 C# 和 F# 中使用的程式庫。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>That would mean that consumers of your library consume them in ways which are natural to C# or F#.</source>
          <target state="translated">這表示您程式庫的消費者透過 C# 或 F# 的原本方式來使用程式庫。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>For example, in C# you might consume the library like this:</source>
          <target state="translated">例如，在 C# 中，您可能會如下使用程式庫︰</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>In F#, it might look like this:</source>
          <target state="translated">在 F# 中，它可能如下所示：</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Consumption scenarios like this mean that the APIs being accessed have to have a different structure for C# and F#.</source>
          <target state="translated">這類使用案例表示針對 C# 和 F#，正在存取的 API 必須具有不同的結構。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>A common approach to accomplishing this is to factor all of the logic of a library into a core project, with C# and F# projects defining the API layers that call into that core project.</source>
          <target state="translated">完成這項作業的常見方法將程式庫的所有邏輯都納入核心專案，而且 C# 和 F# 專案定義呼叫該核心專案的 API 層。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The rest of the section will use the following names:</source>
          <target state="translated">區段的其餘部分將使用下列名稱︰</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AwesomeLibrary.Core<ept id="p1">**</ept> - A core project which contains all logic for the library</source>
          <target state="translated"><bpt id="p1">**</bpt>AwesomeLibrary.Core<ept id="p1">**</ept> - 核心專案，內含程式庫的所有邏輯</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AwesomeLibrary.CSharp<ept id="p1">**</ept> - A project with public APIs intended for consumption in C</source>
          <target state="translated"><bpt id="p1">**</bpt>AwesomeLibrary.CSharp<ept id="p1">**</ept> - 專案，具有公用 API 可供在 C 中使用</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AwesomeLibrary.FSharp<ept id="p1">**</ept> - A project with public APIs intended for consumption in F</source>
          <target state="translated"><bpt id="p1">**</bpt>AwesomeLibrary.FSharp<ept id="p1">**</ept> - 專案，具有公用 API 可供在 F 中使用</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Project-to-project referencing</source>
          <target state="translated">專案對專案參考</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The best way to reference a project is to do the following:</source>
          <target state="translated">參考專案的最佳方式是執行下列動作︰</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Make sure the project you wish to reference has a good name for its containing folder on disk.</source>
          <target state="translated">請確定您想要參考的專案有磁碟上其內含資料夾的不錯名稱。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>This will be the name used to reference your project.</source>
          <target state="translated">這將是用來參考您專案的名稱。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Reference the name from (1) in the <ph id="ph1">`project.json`</ph> file of the consuming project specifying <ph id="ph2">`"target":"project"`</ph>.</source>
          <target state="translated">在指定 <ph id="ph2">`"target":"project"`</ph> 之使用專案的 <ph id="ph1">`project.json`</ph> 檔案中，參考來自 (1) 的名稱。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`project.json`</ph> files for both <bpt id="p1">**</bpt>AwesomeLibrary.CSharp<ept id="p1">**</ept> and <bpt id="p2">**</bpt>AwesomeLibrary.FSharp<ept id="p2">**</ept> now need to reference <bpt id="p3">**</bpt>AwesomeLibrary.Core<ept id="p3">**</ept> as a <ph id="ph2">`project`</ph> target.</source>
          <target state="translated"><bpt id="p1">**</bpt>AwesomeLibrary.CSharp<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>AwesomeLibrary.FSharp<ept id="p2">**</ept> 的 <ph id="ph1">`project.json`</ph> 檔案現在需要參考 <bpt id="p3">**</bpt>AwesomeLibrary.Core<ept id="p3">**</ept> 作為 <ph id="ph2">`project`</ph> 目標。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>If you aren't multitargeting, you can use the global <ph id="ph1">`dependencies`</ph> entry:</source>
          <target state="translated">如果您未使用多目標，則可以使用全域 <ph id="ph1">`dependencies`</ph> 項目：</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>If you are multitargeting, you may not be able to use a global <ph id="ph1">`dependencies`</ph> entry and may have to reference <bpt id="p1">**</bpt>AwesomeLibrary.Core<ept id="p1">**</ept> in a target-level <ph id="ph2">`dependencies`</ph> entry.</source>
          <target state="translated">如果您是使用多目標，則可能無法使用全域 <ph id="ph1">`dependencies`</ph> 項目，而且可能必須參考目標層級 <ph id="ph2">`dependencies`</ph> 項目中的 <bpt id="p1">**</bpt>AwesomeLibrary.Core<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>For example, if you were targeting <ph id="ph1">`netstandard1.6`</ph>, you could do so like this:</source>
          <target state="translated">例如，如果您將目標設為 <ph id="ph1">`netstandard1.6`</ph>，則可以執行下列這類作業：</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Structuring a Solution</source>
          <target state="translated">建構方案</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Another important aspect of multi-project solutions is establishing a good overall project structure.</source>
          <target state="translated">多專案方案的另一個重要部分是建立不錯的整體專案結構。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>To structure a multi-project library, you must use top-level <ph id="ph1">`/src`</ph> and <ph id="ph2">`/test`</ph> folders:</source>
          <target state="translated">若要建構多專案程式庫，您必須使用最上層 <ph id="ph1">`/src`</ph> 和 <ph id="ph2">`/test`</ph> 資料夾︰</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`global.json`</ph> file for this solution would look like this:</source>
          <target state="translated">這個方案的 <ph id="ph1">`global.json`</ph> 檔案如下所示：</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>This approach follows the same pattern established by project templates in the <ph id="ph1">`dotnet new`</ph> command establish, where all projects are placed under a <ph id="ph2">`/src`</ph> directory and all tests are placed under a <ph id="ph3">`/test`</ph> directory.</source>
          <target state="translated">這種方式遵循專案範本在 <ph id="ph1">`dotnet new`</ph> 命令建立中所建立的相同模式，其中所有專案都是放在 <ph id="ph2">`/src`</ph> 目錄下方，而且所有測試都是放在 <ph id="ph3">`/test`</ph> 目錄下方。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Here's how you could restore packages, build, and test your entire project:</source>
          <target state="translated">以下是如何還原套件、建置和測試整個專案︰</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">就是這麼容易！</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>