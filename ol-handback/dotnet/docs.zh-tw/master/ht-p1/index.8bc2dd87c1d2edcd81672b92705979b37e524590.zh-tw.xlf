<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fba870a93784b579da1065a07d82974951ac7e28</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">95b746403eed8e13100defe90c42c880febbf750</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d8d70bd22979ff7663a27372887eb04ebd6c598f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">.NET 入門</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">.NET 入門</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Primer</source>
          <target state="translated">.NET 入門</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Check out the <bpt id="p1">[</bpt>"Getting Started with .NET Core" tutorials<ept id="p1">](../core/getting-started.md)</ept> to learn how to create a simple .NET Core application.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>＜.NET Core 使用者入門＞教學課程<ept id="p1">](../core/getting-started.md)</ept>，以了解如何建立簡單的 .NET Core 應用程式。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It only takes a few minutes to get your first app up and running.</source>
          <target state="translated">只需要幾分鐘，您就可以啟動並執行您的第一個應用程式。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>.NET is a general purpose development platform.</source>
          <target state="translated">.NET 是一般用途開發平台。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>It can be used for any kind of app type or workload where general purpose solutions are used.</source>
          <target state="translated">它可用於使用一般用途方案的任何應用程式類型或工作負載。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>It has several key features that are attractive to many developers, including automatic memory management and modern programming languages, that make it easier to efficiently build high-quality applications.</source>
          <target state="translated">它包含幾項對許多開發人員而言具吸引力的重要功能，包括自動記憶體管理和現代程式語言，可讓您更輕鬆且有效率地建置高品質應用程式。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>.NET enables a high-level programming environment with many convenience features, while providing low-level access to native memory and APIs.</source>
          <target state="translated">.NET 支援具有許多便利功能的高層級程式設計環境，同時提供原生記憶體和 API 的低層級存取。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Multiple implementations of .NET are available, based on open <bpt id="p1">[</bpt>.NET Standards<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)</ept> that specify the fundamentals of the platform.</source>
          <target state="translated">您可以使用以指定平台基礎的開放 <bpt id="p1">[</bpt>.NET 標準<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)</ept>為基礎的多項 .NET 實作。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>They are separately optimized for different application types (for example, desktop, mobile, gaming, cloud) and support many chips (for example, x86/x64, ARM) and operating systems (for example, Windows, Linux, iOS, Android, macOS).</source>
          <target state="translated">這些實作分別針對不同的應用程式類型 (例如傳統型、行動、遊戲、雲端) 進行最佳化，並支援許多晶片 (例如 x86/x64、ARM) 和作業系統 (例如 Windows、Linux、iOS、Android、macOS)。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Open source is also an important part of the .NET ecosystem, with multiple .NET implementations and many libraries available under OSI-approved licenses.</source>
          <target state="translated">開放原始碼也是 .NET 生態系統很重要的一環，具有多項 .NET 實作，並有許多經 OSI 核准授權的程式庫可用。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>Overview of .NET implementations<ept id="p1">](../about/products.md)</ept> document to figure out all of the different editions of .NET that are available, both Microsoft's and others.</source>
          <target state="translated">若要查明 Microsoft 和其他產品可用的所有不同 .NET 版本，請參閱 <bpt id="p1">[</bpt>.NET 實作概觀<ept id="p1">](../about/products.md)</ept>文件。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This Primer will help you understand some of the key concepts in the .NET Platform and point you to more resources for each given topic.</source>
          <target state="translated">本入門將協助您了解 .NET 平台的一些重要概念，並指出每個指定主題的更多資源。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>By the end of it, you should have enough information to be able to recognize significant terms and concepts in the .NET Platform and to know how to further your knowledge about them.</source>
          <target state="translated">本文結束時，您應該具備足夠的資訊，能夠辨識 .NET 平台的重要詞彙和概念，並了解如何進一步擴充相關知識。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A stroll through .NET</source>
          <target state="translated">.NET 概觀</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>As any mature and advanced application development framework, .NET has many powerful features that make the developer's job easier and aim to make writing code more powerful and expressive.</source>
          <target state="translated">如同任何成熟和進階的應用程式開發架構，.NET 具有許多強大的功能，除了讓開發人員的工作更輕鬆之外，主要是為了撰寫出更強大且易懂的程式碼。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This section will outline the basics of the most salient features and provide pointers to more detailed discussions where needed.</source>
          <target state="translated">本節將概述最重要之功能的基本概念，並指出需要更詳細討論的地方。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>After finishing this stroll, you should have enough information to be able to read the samples on our GitHub repos as well as other code and understand what is going on.</source>
          <target state="translated">完成此概觀之後，您應該具備足夠的資訊，能夠閱讀 GitHub 儲存機制上的範例及其他程式碼，並了解運作狀況。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Programming languages<ept id="p1">](#programming-languages)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>程式設計語言<ept id="p1">](#programming-languages)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Automatic memory management<ept id="p1">](#automatic-memory-management)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>自動記憶體管理<ept id="p1">](#automatic-memory-management)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type safety<ept id="p1">](#type-safety)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>型別安全<ept id="p1">](#type-safety)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](#delegates-and-lambdas)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>委派和 Lambda<ept id="p1">](#delegates-and-lambdas)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types (Generics)<ept id="p1">](#generic-types-generics)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>泛型型別 (泛型)<ept id="p1">](#generic-types-generics)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Language Integrated Query (LINQ)<ept id="p1">](#language-integrated-query-linq)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Language-Integrated Query (LINQ)<ept id="p1">](#language-integrated-query-linq)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Async programming<ept id="p1">](#async-programming)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>非同步程式設計<ept id="p1">](#async-programming)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Native interoperability<ept id="p1">](#native-interoperability)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>原生互通性<ept id="p1">](#native-interoperability)</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Unsafe code<ept id="p1">](#unsafe-code)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>不安全的程式碼<ept id="p1">](#unsafe-code)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Programming languages</source>
          <target state="translated">程式語言</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>As a developer, you can choose any programming language that supports .NET to create your application.</source>
          <target state="translated">身為開發人員，您可以選擇任何支援 .NET 的程式語言來建立應用程式。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Because .NET provides language independence and interoperability, you can interact with other .NET applications and components regardless of the language with which they were developed.</source>
          <target state="translated">由於 .NET 提供語言獨立性和互通性，因此不論開發時使用的語言為何，您都可以與其他 .NET 應用程式和元件互動。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Languages that allow you to develop applications for the .NET Platform adhere to the <bpt id="p1">[</bpt>Common Language Infrastructure (CLI) specification<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>.</source>
          <target state="translated">可讓您開發適用於 .NET 平台之應用程式的語言會遵守<bpt id="p1">[</bpt>通用語言基礎結構 (CLI) 規格<ept id="p1">](https://www.visualstudio.com/en-us/mt639507)</ept>。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Microsoft languages that .NET supports include C#, F#, and Visual Basic.</source>
          <target state="translated">.NET 支援的 Microsoft 語言包括 C#、F# 和 Visual Basic。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages.</source>
          <target state="translated">C# 很簡單、強大、型別安全且物件導向，同時保留 C 樣式語言的易讀性與簡潔性。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Anyone familiar with C and similar languages will find few problems in adapting to C#.</source>
          <target state="translated">熟悉 C 和類似語言的任何人在適應 C# 方面很少有問題。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</source>
          <target state="translated">F# 是跨平台、功能優先的程式語言，也支援傳統物件導向和命令式程式設計。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.</source>
          <target state="translated">Visual Basic 是容易學習的語言，您可以使用該語言建置 .NET 上所執行的各種應用程式。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In the current release of .NET Core, only C# is fully supported across all Microsoft tools.</source>
          <target state="translated">在 .NET Core 的目前版本中，只有 C# 受到所有 Microsoft 工具的完整支援。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>F# is supported in the .NET Core SDK, but does not have Visual Studio tooling yet.</source>
          <target state="translated">F# 受到 .NET Core SDK 的支援，但不包括 Visual Studio 工具。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Visual Basic support for the SDK and Visual Studio tooling are coming.</source>
          <target state="translated">未來將推出 SDK 和 Visual Studio 工具的 Visual Basic 支援。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Automatic memory management</source>
          <target state="translated">自動記憶體管理</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Garbage collection is the most well-known of .NET features.</source>
          <target state="translated">記憶體回收是眾所皆知的 .NET 功能。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Developers do not need to actively manage memory, although there are mechanisms to provide more information to the garbage collector (GC).</source>
          <target state="translated">開發人員不需要主動管理記憶體，不過有些機制提供記憶體回收行程 (GC) 的更多資訊。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>C# includes the <ph id="ph1">`new`</ph> keyword to allocate memory in terms of a particular type, and the <ph id="ph2">`using`</ph> keyword to provide scope for the usage of the object.</source>
          <target state="translated">C# 包含 <ph id="ph1">`new`</ph> 關鍵字以依照特定類型配置記憶體，並包含 <ph id="ph2">`using`</ph> 關鍵字以提供物件的使用範圍。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.</source>
          <target state="translated">GC 採用 lazy 方法來管理記憶體，優先考慮應用程式輸送量，而不是立即收集記憶體。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following two lines both allocate memory:</source>
          <target state="translated">下列兩行會配置記憶體：</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>There is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled running.</source>
          <target state="translated">沒有類似的關鍵字可取消配置記憶體，因為當記憶體回收行程透過其排程執行回收記憶體時，就會自動取消配置。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Method variables normally go out of scope once a method completes, at which point they can be collected.</source>
          <target state="translated">方法變數通常會在方法完成之後移出範圍，此時可加以收集。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the <ph id="ph1">`using`</ph> statement.</source>
          <target state="translated">不過，您可以在方法結束之前，使用 <ph id="ph1">`using`</ph> 陳述式對 GC 指出特定物件超出範圍。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Once the <ph id="ph1">`using`</ph> block completes, the GC will know that the <ph id="ph2">`stream`</ph> object in the example above is free to be collected and its memory reclaimed.</source>
          <target state="translated"><ph id="ph1">`using`</ph> 區塊完成之後，GC 就會知道上述範例中的 <ph id="ph2">`stream`</ph> 物件可用，因此可加以收集並回收其記憶體。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>One of the less obvious but quite far-reaching features that a garbage collector enables is memory safety.</source>
          <target state="translated">記憶體回收行程會啟用一項較不明顯、但具有深遠影響的功能，那就是記憶體安全。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).</source>
          <target state="translated">確保記憶體永遠安全並不困難︰如果程式只存取已配置的記憶體 (而不是釋放的記憶體)，就是記憶體安全。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Dangling pointers are always bugs, and tracking them down is often quite difficult.</source>
          <target state="translated">懸置的指標一律是錯誤，而追蹤其來源通常很困難。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The .NET runtime provides additional services, to complete the promise of memory safety, not naturally offered by a GC.</source>
          <target state="translated">.NET 執行階段提供其他服務，來達成記憶體安全的承諾 (GC 原本並未提供)。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>It ensures that programs do not index off the end of an array or accessing a phantom field off the end of an object.</source>
          <target state="translated">它可確保程式不會從陣列結尾編製索引，也不會從物件結尾取出虛設項目欄位。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The following example will throw an exception as a result of memory safety.</source>
          <target state="translated">下列範例會擲回例外狀況，以作為記憶體安全的結果。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Type safety</source>
          <target state="translated">型別安全</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Objects are allocated in terms of types.</source>
          <target state="translated">物件會依照類型配置。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The only operations allowed for a given object, and the memory it consumes, are those of its type.</source>
          <target state="translated">物件的類型會決定該物件所允許的唯一作業，以及所使用的記憶體。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Dog`</ph> type may have <ph id="ph2">`Jump`</ph> and <ph id="ph3">`WagTail`</ph> methods, but not likely a <ph id="ph4">`SumTotal`</ph> method.</source>
          <target state="translated"><ph id="ph1">`Dog`</ph> 類型可能會有 <ph id="ph2">`Jump`</ph> 和 <ph id="ph3">`WagTail`</ph> 方法，但不太可能會有 <ph id="ph4">`SumTotal`</ph> 方法。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>A program can only call the declared methods of a given type.</source>
          <target state="translated">程式只能呼叫指定類型的宣告方法。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or <ph id="ph1">`object`</ph>).</source>
          <target state="translated">所有其他呼叫會導致編譯時期錯誤，或執行階段例外狀況 (如果使用動態功能或 <ph id="ph1">`object`</ph>)。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>.NET languages are object-oriented, with hierarchies of base and derived classes.</source>
          <target state="translated">.NET 語言是物件導向，具有基底和衍生類別的階層架構。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The .NET runtime will only allow object casts and calls that align with the object hierarchy.</source>
          <target state="translated">.NET 執行階段只允許符合物件階層架構的的物件轉換和呼叫。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Remember that every type defined in any .NET language derives from the base <ph id="ph1">`object`</ph> type.</source>
          <target state="translated">請記住，以任何 .NET 語言所定義的每種類型都是衍生自基底 <ph id="ph1">`object`</ph> 類型。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</source>
          <target state="translated">此外也會使用型別安全，藉由確保存取子關鍵字的精確度，來協助強制執行封裝。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Accessor keywords are artifacts which control access to members of a given type by other code.</source>
          <target state="translated">存取子關鍵字是控制其他程式碼存取指定類型成員的成品。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>These are usually used for various kinds of data within a type that are used to manage its behavior.</source>
          <target state="translated">這些關鍵字通常會用於某種類型中用來管理其行為的各種資料。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Some .NET languages support <bpt id="p1">**</bpt>type inference<ept id="p1">**</ept>.</source>
          <target state="translated">有些 .NET 語言支援<bpt id="p1">**</bpt>型別推斷<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side.</source>
          <target state="translated">型別推斷表示編譯器會從右邊的運算式推算左邊的運算式類型。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This doesn't mean that the type safety is broken or avoided.</source>
          <target state="translated">這並不會破壞或規避型別安全。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The resulting type <bpt id="p1">**</bpt>has<ept id="p1">**</ept> a strong type with everything that implies.</source>
          <target state="translated">產生的類型<bpt id="p1">**</bpt>具有<ept id="p1">**</ept>強類型，其中包含其所指的所有項目。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Let's rewrite the first two lines of the previous example to introduce type inference.</source>
          <target state="translated">讓我們重寫上一個範例中的前兩行，以引入型別推斷。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You will note that the rest of the example is completely the same.</source>
          <target state="translated">您會發現，此範例的其餘部分完全相同。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">委派和 Lambda</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Delegates are like C++ function pointers, with a big difference that they are type safe.</source>
          <target state="translated">委派與 C++ 函式指標類似，主要的差別在於委派是型別安全。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>They are a kind of disconnected method within the CLR type system.</source>
          <target state="translated">委派是 CLR 型別系統中一種已中斷連線的方法。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Regular methods are attached to a class and only directly callable through static or instance calling conventions.</source>
          <target state="translated">一般方法是附加到類別，並且只能透過靜態或執行個體呼叫慣例來直接呼叫。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Delegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.</source>
          <target state="translated">委派可用於 .NET 世界中各種不同的 API 和位置，尤其是透過 Lambda 運算式，這是 LINQ 的基石。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Delegates and lambdas<ept id="p1">](delegates-lambdas.md)</ept> document.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>委派和 Lambda<ept id="p1">](delegates-lambdas.md)</ept> 文件。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Generic types (Generics)</source>
          <target state="translated">泛型型別 (泛型)</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Generic types, also commonly called "generics", are a feature that was added in .NET Framework 2.0.</source>
          <target state="translated">泛型型別 (通常也稱為「泛型」) 是 .NET Framework 2.0 中新增的功能。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In short, generics allow the programmer to introduce a "type parameter" when designing their classes, that will allow the client code (the users of the type) to specify the exact type to use in place of the type parameter.</source>
          <target state="translated">簡單來說，泛型可讓程式設計人員在設計其類別時引入「型別參數」，如此即可讓用戶端程式碼 (類型的使用者) 指定正確類型來取代型別參數。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Generics were added in order to help programmers implement generic data structures.</source>
          <target state="translated">新增泛型功能是為了協助程式設計人員實作泛型資料結構。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Before their arrival, in order for a, say, <bpt id="p1">_</bpt>List<ept id="p1">_</ept> type to be generic, it would have to work with elements that were of type <bpt id="p2">_</bpt>object<ept id="p2">_</ept>.</source>
          <target state="translated">在此功能之前，若要讓 <bpt id="p1">_</bpt>List<ept id="p1">_</ept> 類型成為泛型，您必須使用 <bpt id="p2">_</bpt>object<ept id="p2">_</ept> 類型的項目。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This would have various performance as well as semantic problems, not to mention possible subtle runtime errors.</source>
          <target state="translated">這樣做會有各種效能及語意問題，更別提可能會有難以解決的執行階段錯誤。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <bpt id="p1">_</bpt>InvalidCastException<ept id="p1">_</ept> is thrown on working with the list's members.</source>
          <target state="translated">後者最糟的情況是在資料結構同時包含整數和字串時，而且會在使用清單的成員時擲回 <bpt id="p1">_</bpt>InvalidCastException<ept id="p1">_</ept>。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The below sample shows a basic program running using an instance of <ph id="ph1">@System.Collections.Generic.List%601</ph> types.</source>
          <target state="translated">下列範例示範使用 <ph id="ph1">@System.Collections.Generic.List%601</ph> 類型執行個體的基本程式執行。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Generic types (Generics) overview<ept id="p1">](generics.md)</ept> article.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>泛型型別 (泛型) 概觀<ept id="p1">](generics.md)</ept>一文。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Async programming</source>
          <target state="translated">非同步程式設計</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Async programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs.</source>
          <target state="translated">非同步程式設計是 .NET 中的最高階概念，包括執行階段、Framework 程式庫和 .NET 語言建構的非同步支援。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Internally, they are based off of objects (such as <ph id="ph1">`Task`</ph>) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</source>
          <target state="translated">就內部而言，它們是以物件 (例如 <ph id="ph1">`Task`</ph>) 為基礎，可利用作業系統盡可能有效率地執行 I/O-bound 工作。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>To learn more about async programming in .NET, start with the <bpt id="p1">[</bpt>Async overview<ept id="p1">](async.md)</ept>.</source>
          <target state="translated">若要深入了解 .NET 非同步程式設計，請從<bpt id="p1">[</bpt>非同步概觀<ept id="p1">](async.md)</ept>開始。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ)</source>
          <target state="translated">Language Integrated Query (LINQ)</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</source>
          <target state="translated">LINQ 是一組強大的 C# 和 VB 功能，可讓您撰寫簡單的宣告式程式碼來操作資料。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!</source>
          <target state="translated">資料可以是許多形式 (例如 SQL 資料庫中的記憶體內部物件或 XML 文件)，但您通常針對每個資料來源所撰寫的 LINQ 程式碼看起來大同小異！</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>To learn more and see some samples, check out <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>.</source>
          <target state="translated">若要深入了解及查看一些範例，請參閱 <bpt id="p1">[</bpt>LINQ (Language Integrated Query)<ept id="p1">](using-linq.md)</ept>。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">原生互通性</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Every operating system in current use provides a lot of platform support for various programming tasks.</source>
          <target state="translated">目前使用的每個作業系統會針對各種程式設計工作提供許多平台支援。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>.NET provides several ways to tap into those APIs.</source>
          <target state="translated">.NET 提供幾種方式來使用這些 API。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Collectively, this support is called "native interoperability" and in this section we will take a look at how to access native APIs from managed, .NET code.</source>
          <target state="translated">整體而言，這項支援稱為「原生互通性」。在本節中，我們將探討如何從 Managed .NET 程式碼存取原生 API。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The main way to do native interoperability is via "platform invoke" or P/Invoke for short.</source>
          <target state="translated">執行原生互通性的主要方式是透過「平台叫用」(簡稱 P/Invoke)。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This support in .NET Core is available across Linux and Windows platforms.</source>
          <target state="translated">您可以在不同的 Linux 和 Windows 平台之間使用 .NET Core 的這項支援。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Another, Windows-only way of doing native interoperability is known as "COM interop" which is used to work with <bpt id="p1">[</bpt>COM components<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in managed code.</source>
          <target state="translated">另一項僅適用於 Windows 的原生互通性做法稱為 "COM Interop"，可用來處理 Managed 程式碼中的 <bpt id="p1">[</bpt>COM 元件<ept id="p1">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It is built on top of P/Invoke infrastructure, but it works in subtly different ways.</source>
          <target state="translated">它是以 P/Invoke 基礎結構為建置基礎，但運作方式稍有不同。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</source>
          <target state="translated">Mono (以及 Xamarin) 對 Java 和 Objective-C 的互通性支援大致上很類似；也就是說，它們使用相同的原則。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Read more about it in the <bpt id="p1">[</bpt>Native interoperability<ept id="p1">](native-interop.md)</ept> document.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>原生互通性<ept id="p1">](native-interop.md)</ept>文件。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Unsafe code</source>
          <target state="translated">Unsafe 程式碼</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The CLR enables the ability to access native memory and do pointer arithmetic via <ph id="ph1">`unsafe`</ph> code.</source>
          <target state="translated">CLR 可讓您透過 <ph id="ph1">`unsafe`</ph> 程式碼存取原生記憶體及執行指標算術。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>These operations are needed for certain algorithms and system interoperability.</source>
          <target state="translated">特定演算法和系統互通性需要這些作業。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm.</source>
          <target state="translated">Unsafe 程式碼雖然功能強大，但除非是必須與系統 API 互通，或必須實作最有效率的演算法，否則不建議使用。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety.</source>
          <target state="translated">Unsafe 程式碼在不同的環境中執行時可能不盡相同，而且也會失去記憶體回收行程和型別安全的好處。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.</source>
          <target state="translated">建議您盡可能限制和集中使用 Unsafe 程式碼，並徹底測試該程式碼。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ToString()`</ph> method from the <bpt id="p1">[</bpt>StringBuilder class<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327)</ept> illustrates how using <ph id="ph2">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:</source>
          <target state="translated"><bpt id="p1">[</bpt>StringBuilder 類別<ept id="p1">](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327)</ept>中的 <ph id="ph1">`ToString()`</ph> 方法說明使用 <ph id="ph2">`unsafe`</ph> 程式碼時，如何藉由直接四處移動記憶體區塊，以有效率地實作演算法：</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">備註</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The term ".NET runtime" is used throughout the document to accommodate for the multiple implementations of .NET, such as CLR, Mono, IL2CPP and others.</source>
          <target state="translated">文件中使用「.NET 執行階段」一詞來表示 .NET 的多項實作，例如 CLR、Mono、IL2CPP 等等。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The more specific names are only used if needed.</source>
          <target state="translated">只有在必要時，才會使用更特定的名稱。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>This document is not intended to be historical in nature, but describe the .NET platform as it is now.</source>
          <target state="translated">本文件實際上不在回顧過去，而在描述 .NET 平台的現況。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It isn't important whether a .NET feature has always been available or was only recently introduced, only that it is important enough to highlight and discuss.</source>
          <target state="translated">.NET 功能是否一直可用或最近才引入並不重要，重要的是它值得強調及討論。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>