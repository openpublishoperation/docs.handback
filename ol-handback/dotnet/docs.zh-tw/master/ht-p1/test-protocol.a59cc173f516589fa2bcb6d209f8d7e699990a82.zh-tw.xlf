<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">beab195d283fcfcdc454a29498d27bcd290b66c1</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tools\test-protocol.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">571f9ba49be9fc4a0d1dd23f2457b2087630460a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1ea71725bdda8277d7c3a7dd25adcf545941da1c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">.NET Core CLI 測試通訊協定</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">.NET Core CLI 測試通訊協定</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">.NET Core CLI 測試通訊協定</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">簡介</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Anytime you pass a port to dotnet test, the command will run in design time.</source>
          <target state="translated">只要將連接埠傳遞至 dotnet test，就會在設計階段執行命令。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>That means that dotnet test will connect to that port using TCP and will then exchange an established set of messages with whatever else is connected to that port.</source>
          <target state="translated">這表示 dotnet test 會連接到這個使用 TCP 的連接埠，然後與連接到該連接埠的任何其他項目交換已建立的一組訊息。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When this happens, the runner also receives a new port that dotnet test will use to communicate with it.</source>
          <target state="translated">發生這種情況時，執行器也會收到 dotnet test 用來與之通訊的新連接埠。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The reason why the runner also uses TCP to communicate with dotnet test is because in design mode, it is not sufficient to just output results to the console.</source>
          <target state="translated">執行器也使用 TCP 與 dotnet test 通訊的原因是在設計模式中，不足以將結果輸出到主控台。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The command needs to send the adapter structure messages containing the results of the test execution.</source>
          <target state="translated">這個命令需要傳送包含測試執行結果的配接器結構訊息。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Communication protocol at design time.</source>
          <target state="translated">設計階段的通訊協定。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Because during design time, dotnet test connects to a port when it starts up, the adapter needs to be listening on that port otherwise dotnet test will fail.</source>
          <target state="translated">在設計階段期間，因為 dotnet test 會在啟動時連接到連接埠，所以配接器需要接聽該連接埠，否則 dotnet test 將會失敗。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>We did it like this so that the adapter could reserve all the ports it needs by binding and listening to them before dotnet test ran and tried to get ports for the runner.</source>
          <target state="translated">我們會這麼做，以在 dotnet test 執行並嘗試取得配接器的連接埠之前進行繫結和接聽，讓配接器可以保留所需的所有連接埠。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Once dotnet test starts, it sends a TestSession.Connected message to the adapter indicating that it is ready to receive messages.</source>
          <target state="translated">dotnet test 在啟動之後，會將 TestSession.Connected 訊息傳送給配接器，指出已準備好接收訊息。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>It is possible to send an optional <bpt id="p1">[</bpt>version check<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept> message with the adapter version of the protocol in it.</source>
          <target state="translated">可以傳送內含通訊協定之配接器版本的選擇性<bpt id="p1">[</bpt>版本檢查<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept>訊息。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Dotnet test will send back the version of the protocol that it supports.</source>
          <target state="translated">Dotnet test 將會送回所支援通訊協定的版本。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>All messages have the format described here: <bpt id="p1">[</bpt>Message.cs<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>.</source>
          <target state="translated">所有訊息的格式說明如下︰<bpt id="p1">[</bpt>Message.cs<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The payload formats for each message is described in links to the classes used to serialize/deserialize the information in the description of the protocol.</source>
          <target state="translated">每個訊息的承載格式都是以類別的連結描述，而類別用來序列化/還原序列化通訊協定描述中的資訊。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Test Execution</source>
          <target state="translated">測試執行</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Test Execution</source>
          <target state="translated">測試執行</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>After the optional version check, the adapter sends a TestExecution.GetTestRunnerProcessStartInfo, with the <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> it wants to execute inside of it.</source>
          <target state="translated">執行選擇性版本檢查之後，配接器會傳送 TestExecution.GetTestRunnerProcessStartInfo 以及想要在其內執行的 <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept>。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Dotnet test sends back a FileName and Arguments inside a <bpt id="p1">[</bpt>TestStartInfo<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.DotNet.Tools.Test/TestStartInfo.cs)</ept> payload that the adapter can use to start the runner.</source>
          <target state="translated">Dotnet test 會在配接器可用來啟動執行器的 <bpt id="p1">[</bpt>TestStartInfo<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.DotNet.Tools.Test/TestStartInfo.cs)</ept> 承載內傳回 FileName 和引數。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In the past, we would send the list of tests to run as part of that argument, but we were actually going over the command line size limit for some test projects.</source>
          <target state="translated">過去，我們會傳送測試清單當成該引數的一部分來執行，但會實際徹底檢查一些測試專案的命令列大小限制。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>As part of the arguments, we send a port that the runner should connect to and for executing tests, a --wait-command flag, that indicates that the runner should connect to the port and wait for commands, instead of going ahead and executing the tests.</source>
          <target state="translated">我們會傳送執行器應該連接的連接埠，當成引數的一部分，以及，針對執行測試，--wait-command 旗標指出執行器應該連接至連接埠，並等待命令，而不是繼續進行並執行測試。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>At this point, the adapter can launch the runner (and attach to it for debugging if it chooses to).</source>
          <target state="translated">配接器目前可以啟動執行器，並附加到它以進行偵錯 (如果選擇這麼做)。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Once the runner starts, it sends dotnet test a TestRunner.WaitCommand message that indicates it is ready to receive commands, at which point dotnet test sends a TestRunner.Execute with the list of <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> to run.</source>
          <target state="translated">執行器在啟動之後，會將 TestRunner.WaitCommand 訊息傳送給 dotnet test，指出已準備好接收命令，而 dotnet test 在此時會使用要執行的<bpt id="p1">[</bpt>測試<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept>清單來傳送 TestRunner.Execute。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This bypasses the command line size limit described above.</source>
          <target state="translated">這會略過上面所述的命令列大小限制。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The runner then sends dotnet test (and it passes forward to the adapter) a TestExecution.TestStarted for each tests as they start with the <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> information inside of it.</source>
          <target state="translated">執行器接著會針對每個測試將 TestExecution.TestStarted 傳送給 dotnet test (並往前轉遞給配接器)，原因是它們使用其內的<bpt id="p1">[</bpt>測試<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept>資訊開始。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The runner also sends dotnet test (and it forwards to the adapter) a TestExecution.TestResult for each test with the <bpt id="p1">[</bpt>individual result<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept> of the test.</source>
          <target state="translated">執行器也會針對每個測試將 TestExecution.TestResult 與測試的<bpt id="p1">[</bpt>個別結果<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept>傳送給 dotnet test (並將它轉遞給配接器)。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>After all tests finish, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestExecution.Completed to the adapter.</source>
          <target state="translated">所有測試都完成之後，執行器會將 TestRunner.Completed 訊息傳送給 dotnet test，而 dotnet test 會以 TestExecution.Completed 形式傳送給配接器。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.</source>
          <target state="translated">完成配接器之後，會將 TestSession.Terminate 傳送給 dotnet test，以關閉 dotnet test。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Test discovery</source>
          <target state="translated">測試探索</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Test discovery</source>
          <target state="translated">測試探索</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>After the optional version check, the adapter sends a TestDiscovery.Start message.</source>
          <target state="translated">執行選擇性版本檢查之後，配接器會傳送 TestDiscovery.Start 訊息。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Because in this case, the adapter does not need to attach to the process, dotnet test will start the runner itself.</source>
          <target state="translated">在此情況下，因為配接器不需要附加至處理序，所以 dotnet test 會自行啟動執行器。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Also, since there is no long list of arguments to be passed to the runner, no --wait-command flag is needed to be passed to the runner.</source>
          <target state="translated">同時，因為沒有要傳遞給執行器的長引數清單，所以需要將 no --wait-command 旗標傳遞給執行器。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>dotnet test only passes a --list argument to the runner, which means the runner should not run the tests, just list them.</source>
          <target state="translated">dotnet test 只會將 --list 引數傳遞給執行器，這表示執行器不應該執行測試，只是列出它們。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The runner then sends dotnet test (and it passes forward to the adapter) a TestDiscovery.TestFound for each <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> found.</source>
          <target state="translated">執行器接著會針對每個找到的<bpt id="p1">[</bpt>測試<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept>將 TestDiscovery.TestFound 傳送給 dotnet test (並往前轉遞給配接器)。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>After all tests are discovered, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestDiscovery.Completed to the adapter.</source>
          <target state="translated">找到所有測試之後，執行器會將 TestRunner.Completed 訊息傳送給 dotnet test，而 dotnet test 會以 TestDiscovery.Completed 形式傳送給配接器。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.</source>
          <target state="translated">完成配接器之後，會將 TestSession.Terminate 傳送給 dotnet test，以關閉 dotnet test。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>