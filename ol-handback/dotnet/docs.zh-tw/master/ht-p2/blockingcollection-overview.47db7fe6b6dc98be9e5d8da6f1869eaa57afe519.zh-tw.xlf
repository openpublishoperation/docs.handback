<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">991b4b8389cc967881c2c39d29c387687047489f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\collections\threadsafe\blockingcollection-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ee211c059c42480350d31c938f52419524b3332b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8b625a2430b9030f673248de32b487e185b91756</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="translated">BlockingCollection 概觀</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="translated">BlockingCollection 概觀</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="translated">BlockingCollection 概觀</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> is a thread-safe collection class that provides the following features:</source>
          <target state="translated"><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> 是提供下列功能的安全執行緒集合類別︰</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>An implementation of the Producer-Consumer pattern.</source>
          <target state="translated">生產者-消費者模式的實作。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Thread-safe addition and removal of items from a collection.</source>
          <target state="translated">集合中項目的安全執行緒新增和移除。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Optional maximum capacity.</source>
          <target state="translated">最佳最大容量。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Insertion and removal operations that block when collection is empty or full.</source>
          <target state="translated">集合是空的或已滿時封鎖的插入和移除作業。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Insertion and removal "try" operations that do not block or that block up to a specified period of time.</source>
          <target state="translated">不會封鎖或最多封鎖一段指定時間的插入和移除 "try" 作業。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Encapsulates any collection type that implements <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>.</source>
          <target state="translated">封裝任何可實作 <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept> 的集合類別。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Cancellation with cancellation tokens.</source>
          <target state="translated">具有取消語彙基元的取消作業。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Two kinds of enumeration with <ph id="ph1">`foreach`</ph>:</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> 的列舉有兩種：</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Read-only enumeration.</source>
          <target state="translated">唯讀列舉。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Enumeration that removes items as they are enumerated.</source>
          <target state="translated">移除所列舉項目的列舉。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Bounding and Blocking Support</source>
          <target state="translated">界限和封鎖支援</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> supports bounding and blocking.</source>
          <target state="translated"><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> 支援界限和封鎖。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Bounding means you can set the maximum capacity of the collection.</source>
          <target state="translated">界限表示您可以設定集合的最大容量。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.</source>
          <target state="translated">界限在某些情況下十分重要，原因是它可讓您控制記憶體中集合的大小上限，並且防止產生執行緒移到使用執行緒的太前面。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.</source>
          <target state="translated">多個執行緒或工作可以同時將項目新增至集合，如果集合達到其指定的最大容量，則會在移除項目之前封鎖產生執行緒。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.</source>
          <target state="translated">多位消費者可以同時移除項目，如果集合變成空的，則會在生產者新增項目之前封鎖使用執行緒。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>A producing thread can call <ph id="ph1">`CompleteAdding`</ph> to indicate that no more items will be added.</source>
          <target state="translated">產生執行緒可以呼叫 <ph id="ph1">`CompleteAdding`</ph>，表示無法再新增項目。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consumers monitor the <ph id="ph1">`IsCompleted`</ph> property to know when the collection is empty and no more items will be added.</source>
          <target state="translated">消費者會監視 <ph id="ph1">`IsCompleted`</ph> 屬性，以得知集合何時變成空的，以及何時無法再新增項目。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The following example shows a simple <ph id="ph1">`BlockingCollection`</ph> with a bounded capacity of 100.</source>
          <target state="translated">下列範例示範界限容量為 100 的簡單 <ph id="ph1">`BlockingCollection`</ph>。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A producer task adds items to the collection as long as some external condition is true, and then calls <ph id="ph1">`CompleteAdding`</ph>.</source>
          <target state="translated">只要符合某個外部條件，生產者工作就會將項目新增至集合，然後呼叫 <ph id="ph1">`CompleteAdding`</ph>。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The consumer task takes items until the <ph id="ph1">`IsCompleted`</ph> property is true.</source>
          <target state="translated">在 <ph id="ph1">`IsCompleted`</ph> 屬性為 true 之前，消費者工作會擷取項目。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For a complete example, see <bpt id="p1">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</source>
          <target state="translated">如需完整範例，請參閱<bpt id="p1">[</bpt>如何：從 BlockingCollection 個別新增和擷取項目<ept id="p1">](how-to-add-and-take-items.md)</ept>。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Timed Blocking Operations</source>
          <target state="translated">計時封鎖作業</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In timed blocking <ph id="ph1">`TryAdd`</ph> and <ph id="ph2">`TryTake`</ph> operations on bounded collections, the method tries to add or take an item.</source>
          <target state="translated">在界限集合的計時封鎖 <ph id="ph1">`TryAdd`</ph> 和 <ph id="ph2">`TryTake`</ph> 作業上，方法會嘗試新增或擷取項目。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If an item is available it is placed into the variable that was passed in by reference, and the method returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">如果項目可用，則會將它置入依傳址所傳遞的變數，而且方法會傳回 <ph id="ph1">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If no item is retrieved after a specified time-out period the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">如果在指定的逾時期間之後未擷取任何項目，則方法會傳回 <ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The thread is then free to do some other useful work before trying again to access the collection.</source>
          <target state="translated">執行緒接著可以先執行一些其他有用工作，再重新嘗試存取集合。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For an example of timed blocking access, see the second example in <bpt id="p1">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</source>
          <target state="translated">如需計時封鎖存取的範例，請參閱<bpt id="p1">[</bpt>如何：從 BlockingCollection 個別新增和擷取項目<ept id="p1">](how-to-add-and-take-items.md)</ept>中的第二個範例。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Cancelling Add and Take Operations</source>
          <target state="translated">取消新增和擷取作業</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Add and Take operations are typically performed in a loop.</source>
          <target state="translated">新增和擷取作業一般會透過迴圈形式執行。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can cancel a loop by passing in a <ph id="ph1">`CancellationToken`</ph> to the <ph id="ph2">`TryAdd`</ph> or <ph id="ph3">`TryTake`</ph> method, and then checking the value of the token's <ph id="ph4">`IsCancellationRequested`</ph> property on each iteration.</source>
          <target state="translated">您可以將 <ph id="ph1">`CancellationToken`</ph> 傳入 <ph id="ph2">`TryAdd`</ph> 或 <ph id="ph3">`TryTake`</ph> 方法來取消迴圈，然後檢查每個反覆項目上語彙基元之 <ph id="ph4">`IsCancellationRequested`</ph> 屬性的值。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If the value is <ph id="ph1">`true`</ph>, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.</source>
          <target state="translated">如果值為 <ph id="ph1">`true`</ph>，則是由您決定透過清除任何資源並結束迴圈來回應取消要求。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following example shows an overload of <ph id="ph1">`TryAdd`</ph> that takes a cancellation token, and the code that uses it:</source>
          <target state="translated">下列範例示範採用取消語彙基元之 <ph id="ph1">`TryAdd`</ph> 的多載，以及使用它的程式碼︰</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Specifying the Collection Type</source>
          <target state="translated">指定集合類型</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When you create a <ph id="ph1">`BlockingCollection&lt;T&gt;;`</ph>, you can specify not only the bounded capacity but also the type of collection to use.</source>
          <target state="translated">在您建立 <ph id="ph1">`BlockingCollection&lt;T&gt;;`</ph> 時，不僅可以指定界限容量，還可以指定要使用的集合類型。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, you could specify a <bpt id="p1">[</bpt>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> for first in-first out (FIFO) behavior, or a <bpt id="p2">[</bpt>ConcurrentStack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> for last in-first out (LIFO) behavior.</source>
          <target state="translated">例如，您可以針對先進先出 (FIFO) 行為指定 <bpt id="p1">[</bpt>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> 物件，或針對後進先出 (LIFO) 行為指定 <bpt id="p2">[</bpt>ConcurrentStack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> 物件。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can use any collection class that implements the <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept> interface.</source>
          <target state="translated">您可以使用任何可實作 <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept> 介面的集合類別。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The default collection type for <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> is <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph>.</source>
          <target state="translated"><ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> 的預設集合類型為 <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The following code example shows how to create a <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> of strings that has a capacity of 1000 and uses a <bpt id="p1">[</bpt>ConcurrentBag<ph id="ph2">&amp;lt;</ph>T<ph id="ph3">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept>:</source>
          <target state="translated">下列程式碼範例示範如何建立容量為 1000 並使用 <bpt id="p1">[</bpt>ConcurrentBag<ph id="ph2">&amp;lt;</ph>T<ph id="ph3">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept> 之字串的 <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph>：</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>IEnumerable Support</source>
          <target state="translated">IEnumerable 支援</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> provides a <ph id="ph2">`GetConsumingEnumerable`</ph> method that enables consumers to use a <ph id="ph3">`foreach`</ph> statement to remove items until the collection is completed, which means it is empty and no more items will be added.</source>
          <target state="translated"><ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> 提供 <ph id="ph2">`GetConsumingEnumerable`</ph> 方法讓消費者可以使用 <ph id="ph3">`foreach`</ph> 陳述式移除項目，直到收集完成為止；這表示集合會是空的，而且不會再新增任何項目。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Use ForEach to Remove Items in a BlockingCollection<ept id="p1">](how-to-use-foreach-to-remove.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>如何：使用 ForEach 來移除 BlockingCollection 中的項目<ept id="p1">](how-to-use-foreach-to-remove.md)</ept>。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Using Many BlockingCollections As One</source>
          <target state="translated">將多個 BlockingCollection 當成一個使用</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> and use the static methods such as <ph id="ph2">`TakeFromAny`</ph> and <ph id="ph3">`AddToAny`</ph> that will add to or take from any of the collections in the array.</source>
          <target state="translated">如果消費者需要同時從多個集合擷取項目，您可以建立 <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> 陣列，並使用將新增至或擷取自陣列中任何集合的靜態方法 (例如 <ph id="ph2">`TakeFromAny`</ph> 和 <ph id="ph3">`AddToAny`</ph>)。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If one collection is blocking, the method immediately tries another until it finds one that can perform the operation.</source>
          <target state="translated">如果封鎖其中一個集合，則方法會立即嘗試另一個集合，直到找到可執行作業的集合為止。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Use Arrays of Blocking Collections in a Pipeline<ept id="p1">](how-to-use-arrays-of-blockingcollections.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>如何：在管線中使用封鎖回收的陣列<ept id="p1">](how-to-use-arrays-of-blockingcollections.md)</ept>。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">另請參閱</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Collections and Data Structures<ept id="p1">](../index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>集合與資料結構<ept id="p1">](../index.md)</ept></target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Thread-Safe Collections<ept id="p1">](index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>安全執行緒集合<ept id="p1">](index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>