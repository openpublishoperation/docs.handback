<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1832403174276e48dc1857be8ff11fba2b9a250c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\compilation.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56932ed1fd4d5840cde1afcc475dac369f319d67</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dcac2b7a40bcacd311e6e36d49322ee92b4f7d6b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Compilation and reuse in regular expressions</source>
          <target state="translated">規則運算式中的編譯和重複使用</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Compilation and reuse in regular expressions</source>
          <target state="translated">規則運算式中的編譯和重複使用</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Compilation and reuse in regular expressions</source>
          <target state="translated">規則運算式中的編譯和重複使用</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can optimize the performance of applications that make extensive use of regular expressions by understanding how the regular expression engine compiles expressions and by understanding how regular expressions are cached.</source>
          <target state="translated">只要了解規則運算式引擎如何編譯運算式，以及了解如何快取規則運算式，您就可以使大量使用規則運算式的應用程式達到最佳效能。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This topic discusses both compilation and caching.</source>
          <target state="translated">本主題討論編譯及快取。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Compiled Regular Expressions</source>
          <target state="translated">編譯的規則運算式</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine compiles a regular expression to a sequence of internal instructions (these are high-level codes that are different from Microsoft intermediate language, or MSIL).</source>
          <target state="translated">根據預設，規則運算式引擎會將規則運算式編譯為內部指令的序列 (這些是不同於 Microsoft Intermediate Language (MSIL) 的高階程式碼)。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>When the engine executes a regular expression, it interprets the internal codes.</source>
          <target state="translated">當引擎執行規則運算式時，它將會解譯內部程式碼。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>If a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is constructed with the <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option, it compiles the regular expression to explicit MSIL code instead of high-level regular expression internal instructions.</source>
          <target state="translated">如果 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 物件是以 <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> 選項所建構，它會將規則運算式編譯成明確的 MSIL 程式碼，而非高階的規則運算式內部指令。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This allows .NET's just-in-time (JIT) compiler to convert the expression to native machine code for higher performance.</source>
          <target state="translated">這允許 .NET 的 Just-in-Time (JIT) 編譯器將運算式轉換為原生機器碼以達到較高效能。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>However, generated MSIL cannot be unloaded.</source>
          <target state="translated">不過，產生的 MSIL 無法卸載。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The only way to unload code is to unload an entire application domain (that is, to unload all of your application's code.).</source>
          <target state="translated">卸載程式碼的唯一方式就是要卸載整個應用程式定義域 (也就是卸載您應用程式的所有程式碼)。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Effectively, once a regular expression is compiled with the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option, .NET never releases the resources used by the compiled expression, even if the regular expression was created by a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> object that is itself released to garbage collection.</source>
          <target state="translated">實際上，以 <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> 選項編譯規則運算式之後，.NET 絕不會釋放已編譯運算式所使用的資源，即使規則運算式是由 <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 物件所建立，而且物件本身被釋放以回收記憶體亦然。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You must be careful to limit the number of different regular expressions you compile with the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option to avoid consuming too many resources.</source>
          <target state="translated">您必須小心限制以 <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> 選項編譯的不同規則運算式數目，以避免消耗太多資源。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>If an application must use a large or unbounded number of regular expressions, each expression should be interpreted, not compiled.</source>
          <target state="translated">如果應用程式必須使用大量或未限制數目的規則運算式，應該要解譯而不是編譯各個運算式。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>However, if a small number of regular expressions are used repeatedly, they should be compiled with <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> for better performance.</source>
          <target state="translated">不過，如果要重複使用少數規則運算式，應該使用 <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> 編譯以獲得較高的效能。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The Regular Expressions Cache</source>
          <target state="translated">規則運算式快取</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To improve performance, the regular expression engine maintains an application-wide cache of compiled regular expressions.</source>
          <target state="translated">為了提升效能，規則運算式引擎會維護整個應用程式的已編譯規則運算式之快取。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The cache stores regular expression patterns that are used only in static method calls.</source>
          <target state="translated">這個快取會儲存只有在靜態方法呼叫中使用的規則運算式模式</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>(Regular expression patterns supplied to instance methods are not cached.) This avoids the need to reparse an expression into high-level byte code each time it is used.</source>
          <target state="translated">(不會快取提供給執行個體方法的規則運算式模式)。這可避免在每次使用運算式時，必須將其重新剖析為高階位元組程式碼。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The maximum number of cached regular expressions is determined by the value of the <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) <bpt id="p1">[</bpt>Regex.CacheSize<ept id="p1">](xref:System.Text.RegularExpressions.Regex.CacheSize)</ept> property.</source>
          <target state="translated">快取的規則運算式數目上限取決於 <ph id="ph1">`static`</ph> (在 Visual Basic 中為 <ph id="ph2">`Shared`</ph>) <bpt id="p1">[</bpt>Regex.CacheSize<ept id="p1">](xref:System.Text.RegularExpressions.Regex.CacheSize)</ept> 屬性值。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine caches up to 15 compiled regular expressions.</source>
          <target state="translated">根據預設，規則運算式引擎最多可快取 15 個已編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If the number of compiled regular expressions exceeds the cache size, the least recently used regular expression is discarded and the new regular expression is cached.</source>
          <target state="translated">如果編譯的規則運算式數目超出快取大小，就會捨棄最近最少使用的規則運算式，並快取新的規則運算式。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Your application can take advantage of precompiled regular expressions in one of the following two ways:</source>
          <target state="translated">您的應用程式可以透過下列其中一種方式，來利用預先編譯的規則運算式：</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>By using a static method of the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object to define the regular expression.</source>
          <target state="translated">使用 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 物件的靜態方法來定義規則運算式。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If you are using a regular expression pattern that has already been defined in another static method call, the regular expression engine will retrieve it from the cache.</source>
          <target state="translated">如果您使用其他靜態方法呼叫中已定義的規則運算式模式，規則運算式引擎就會從快取中擷取這個規則運算式模式。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If not, the engine will compile the regular expression and add it to the cache.</source>
          <target state="translated">如果沒有，則引擎會編譯規則運算式並新增至快取。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>By reusing an existing <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object as long as its regular expression pattern is needed.</source>
          <target state="translated">在需要現有 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 物件的規則運算式模式時重複使用物件。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Because of the overhead of object instantiation and regular expression compilation, creating and rapidly destroying numerous <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> objects is a very expensive process.</source>
          <target state="translated">由於物件具現化和規則運算式編譯會造成額外負荷，因此建立及快速終結多個 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 物件是非常耗費資源的處理序。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For applications that use a large number of different regular expressions, you can optimize performance by using calls to static <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> methods and possibly by increasing the size of the regular expression cache.</source>
          <target state="translated">對於使用大量不同規則運算式的應用程式，您可以使用靜態 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 方法的呼叫，或增加規則運算式快取的大小，以達到最佳效能。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">另請參閱</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET regular expressions<ept id="p1">](regular-expressions.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>.NET 規則運算式<ept id="p1">](regular-expressions.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>