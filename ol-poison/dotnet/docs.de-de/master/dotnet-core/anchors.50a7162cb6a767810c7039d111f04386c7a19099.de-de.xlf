<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ef2a63115f1efbe2418c348a3379fe7dd2face86</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\anchors.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d2e25c2b175059780bad8d84610bac5dd45943c9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">94ae0e65a6ef73d01b61abaca196f9a10a7fd773</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file anchors.50a7162cb6a767810c7039d111f04386c7a19099.de-de.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Anchors in regular expressions</source>
          <target state="translated">Anker in regulären Ausdrücken</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Anchors in regular expressions</source>
          <target state="translated">Anker in regulären Ausdrücken</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Anchors in regular expressions</source>
          <target state="translated">Anker in regulären Ausdrücken</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Anchors, or atomic zero-width assertions, specify a position in the string where a match must occur.</source>
          <target state="translated">Anker, auch als atomische Nullbreitenassertionen bezeichnet, geben eine Position in der Zeichenfolge an, an der eine Übereinstimmung auftreten muss.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>When you use an anchor in your search expression, the regular expression engine does not advance through the string or consume characters; it looks for a match in the specified position only.</source>
          <target state="translated">Wenn Sie im Suchausdruck einen Anker verwenden, durchsucht das Modul für reguläre Ausdrücke nicht die Zeichenfolge oder durchläuft Zeichen, sondern sucht nur an der angegebenen Position nach einer Übereinstimmung.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> specifies that the match must start at the beginning of a line or string.</source>
          <target state="translated">Beispielsweise gibt <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> an, dass die Übereinstimmung am Anfang einer Zeile oder Zeichenfolge beginnen muss.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Therefore, the regular expression <ph id="ph1">`^http:`</ph> matches "http:" only when it occurs at the beginning of a line.</source>
          <target state="translated">Daher stimmt der reguläre Ausdruck <ph id="ph1">`^http:`</ph> nur mit "http:" überein, wenn dies am Anfang einer Zeile steht.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The following table lists the anchors supported by the regular expressions in .NET.</source>
          <target state="translated">In der folgenden Tabelle werden die von den regulären .NET-Ausdrücken unterstützten Anker aufgeführt.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Anchor</source>
          <target state="translated">Anker</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The match must occur at the beginning of the string or line.</source>
          <target state="translated">Die Übereinstimmung muss am Anfang der Zeichenfolge oder Zeile vorliegen.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string or line, or before \n at the end of the string or line.</source>
          <target state="translated">Die Übereinstimmung muss am Ende der Zeichenfolge oder Zeile oder vor \n am Ende der Zeile oder Zeichenfolge vorliegen.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\A<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\A<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The match must occur at the beginning of the string only (no multiline support)</source>
          <target state="translated">Die Übereinstimmung darf nur am Anfang der Zeichenfolge vorliegen (mehrere Zeilen werden nicht unterstützt).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string, or before \n at the end of the string.</source>
          <target state="translated">Die Übereinstimmung muss am Ende der Zeichenfolge oder vor \n am Ende der Zeichenfolge vorliegen.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\z<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\z<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string only.</source>
          <target state="translated">Die Übereinstimmung darf nur am Ende der Zeichenfolge vorliegen.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\G<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\G<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The match must start at the position where the previous match ended.</source>
          <target state="translated">Die Übereinstimmung muss an dem Punkt beginnen, an dem die vorherige Übereinstimmung endete.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\b<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\b<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The match must occur on a word boundary.</source>
          <target state="translated">Die Übereinstimmung muss an einer Wortgrenze vorliegen.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\B<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\B<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The match must not occur on a word boundary.</source>
          <target state="translated">Die Übereinstimmung darf nicht an einer Wortgrenze vorliegen.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Start of String or Line: ^</source>
          <target state="translated">Anfang der Zeichenfolge oder Zeile: ^</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> anchor specifies that the following pattern must begin at the first character position of the string.</source>
          <target state="translated">Der <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept>-Anker gibt an, dass das folgende Muster an der ersten Zeichenposition der Zeichenfolge beginnen muss.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> with the <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option (see <bpt id="p3">[</bpt>Regular expression options<ept id="p3">](options.md)</ept>), the match must occur at the beginning of each line.</source>
          <target state="translated">Wenn Sie <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> mit der Option <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> (siehe <bpt id="p3">[</bpt>Optionen für reguläre Ausdrücke<ept id="p3">](options.md)</ept>) verwenden, muss die Übereinstimmung am Anfang jeder Zeile vorliegen.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">Im folgenden Beispiel wird der <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept>-Anker in einem regulären Ausdruck verwendet, der Informationen zu den Jahren extrahiert, in denen es bestimmte professionelle Baseballteams gab.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The example calls two overloads of the <ph id="ph1">`Regex.Matches`</ph> method:</source>
          <target state="translated">Im Beispiel werden zwei Überladungen der <ph id="ph1">`Regex.Matches`</ph>-Methode aufgerufen:</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The call to the <bpt id="p1">[</bpt>Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> overload finds only the first substring in the input string that matches the regular expression pattern.</source>
          <target state="translated">Der Aufruf der <bpt id="p1">[</bpt>Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept>-Überladung sucht nur die erste Teilzeichenfolge in der Eingabezeichenfolge, die mit dem Muster des regulären Ausdrucks übereinstimmt.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The call to the <bpt id="p1">[</bpt>Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> overload with the options parameter set to <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> finds all five substrings.</source>
          <target state="translated">Der Aufruf der <bpt id="p1">[</bpt>Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>-Überladung mit Festlegung des Parameters „options“ auf <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> sucht alle fünf Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+`</ph> is defined as shown in the following table.</source>
          <target state="translated">Das Muster für reguläre Ausdrücke <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+`</ph> wird entsprechend der folgenden Tabelle definiert:</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the input string (or the beginning of the line if the method is called with the <ph id="ph1">`RegexOptions.Multiline`</ph> option).</source>
          <target state="translated">Suchen Sie nach einer Übereinstimmung am Anfang der Eingabezeichenfolge (oder am Anfang der Zeile, wenn die Methode mit der <ph id="ph1">`RegexOptions.Multiline`</ph>-Option aufgerufen wird).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed either by zero or by one space exactly two times.</source>
          <target state="translated">Suchen Sie nach einer Übereinstimmung mit mindestens einem Wortzeichen, auf das genau zwei Mal eine 0 (Null) oder ein Leerzeichen folgt.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Dies ist die erste Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This expression also defines a second and third capturing group: The second consists of the captured word, and the third consists of the captured spaces.</source>
          <target state="translated">Durch diesen Ausdruck werden auch eine zweite und dritte Erfassungsgruppe definiert: Die zweite Gruppe besteht aus dem erfassten Wort, die dritte aus den erfassten Leerzeichen.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Match a comma followed by a white-space character.</source>
          <target state="translated">Suchen Sie nach einer Übereinstimmung mit einem Komma gefolgt von einem Leerzeichen.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a space, followed by one or more word characters.</source>
          <target state="translated">Suchen Sie nach einer Übereinstimmung mit einem oder mehreren Wortzeichen gefolgt von mindestens einem Wortzeichen.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This is the fourth capturing group.</source>
          <target state="translated">Dies ist die vierte Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Match a comma.</source>
          <target state="translated">Entsprechung für ein Komma finden.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Match a space followed by four decimal digits.</source>
          <target state="translated">Suchen Sie nach einer Übereinstimmung mit einem von vier Dezimalzahlen gefolgten Leerzeichen.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?`</ph></source>
          <target state="translated"><ph id="ph1">`(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?`</ph></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a hyphen followed by four decimal digits or the string "present".</source>
          <target state="translated">Suchen Sie nach einer Übereinstimmung mit 0 (Null) oder einem Bindestrich gefolgt von vier Dezimalzahlen oder der Zeichenfolge "present".</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This is the sixth capturing group.</source>
          <target state="translated">Dies ist die sechste Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>It also includes a seventh capturing group.</source>
          <target state="translated">Diese Gruppe enthält auch eine siebte Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a comma.</source>
          <target state="translated">Suchen Sie nach einer Übereinstimmung mit 0 (null) oder einem Komma.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(\s\d{4}(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?,?)+`</ph></source>
          <target state="translated"><ph id="ph1">`(\s\d{4}(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?,?)+`</ph></target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of the following: a space, four decimal digits, zero or one occurrence of a hyphen followed by four decimal digits or the string "present", and zero or one comma.</source>
          <target state="translated">Suchen Sie nach einer Übereinstimmung mit mindestens einem Vorkommen der folgenden Elemente: ein Leerzeichen, vier Dezimalzahlen, 0 (Null) oder ein Bindestrich gefolgt von vier Dezimalzahlen oder der Zeichenfolge "present" sowie 0 (Null) oder ein Komma.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This is the fifth capturing group.</source>
          <target state="translated">Dies ist die fünfte Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>End of String or Line: $</source>
          <target state="translated">Ende der Zeichenfolge oder Zeile: $</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string.</source>
          <target state="translated">Der <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept>-Anker gibt an, dass das vorangehende Muster am Ende der Eingabezeichenfolge oder vor \n am Ende der Eingabezeichenfolge vorliegen muss.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> with the <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, the match can also occur at the end of a line.</source>
          <target state="translated">Wenn Sie <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> mit der <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>-Option verwenden, kann die Übereinstimmung auch am Ende einer Zeile vorliegen.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Note that <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> matches <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> but does not match <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (the combination of carriage return and newline characters, or CR/LF).</source>
          <target state="translated">Beachten Sie, dass <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> mit <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> übereinstimmt, nicht jedoch mit <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (der Kombination aus Wagenrücklauf- und Zeilenumbruchzeichen oder CR/LF).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To match the CR/LF character combination, include <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> in the regular expression pattern.</source>
          <target state="translated">Zum Suchen einer Übereinstimmung mit der CR/LF-Zeichenkombination schließen Sie <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> in das Muster des regulären Ausdrucks ein.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following example adds the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> anchor to the regular expression pattern used in the example in the previous "Start of String or Line" section.</source>
          <target state="translated">Im folgenden Beispiel wird der <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept>-Anker dem Muster des regulären Ausdrucks hinzugefügt, der im Beispiel im vorherigen Abschnitt „Anfang der Zeichenfolge oder Zeile“ verwendet wurde.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When used with the original input string, which includes five lines of text, the <bpt id="p1">[</bpt>Regex.Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> method is unable to find a match, because the end of the first line does not match the <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept> pattern.</source>
          <target state="translated">Bei Verwendung mit der ursprünglichen Eingabezeichenfolge von fünf Textzeilen findet die <bpt id="p1">[</bpt>Regex.Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept>-Methode keine Übereinstimmung, da das Ende der ersten Zeile nicht mit dem <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>-Muster übereinstimmt.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>When the original input string is split into a string array, the <ph id="ph1">`Regex.Matches(String, String)`</ph> method succeeds in matching each of the five lines.</source>
          <target state="translated">Wenn die ursprüngliche Eingabezeichenfolge in ein Zeichenfolgenarray geteilt wird, findet die <ph id="ph1">`Regex.Matches(String, String)`</ph>-Methode eine Übereinstimmung mit jeder der fünf Zeilen.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When the <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">*</bpt>options<ept id="p2">*</ept> parameter set to <ph id="ph1">`RegexOptions.Multiline`</ph>, no matches are found because the regular expression pattern does not account for the carriage return element (\u+000D).</source>
          <target state="translated">Wenn die <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>-Methode mit dem auf <ph id="ph1">`RegexOptions.Multiline`</ph> festgelegten Parameter <bpt id="p2">*</bpt>options<ept id="p2">*</ept> aufgerufen wird, werden keine Übereinstimmungen gefunden, da das Wagenrücklaufelement (\u+000D) nicht Teil des Musters des regulären Ausdrucks ist.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>However, when the regular expression pattern is modified by replacing <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> with <bpt id="p2">**</bpt>\r?$<ept id="p2">**</ept>, calling the <ph id="ph2">`Regex.Matches(String, String, RegexOptions)`</ph> method with the <bpt id="p3">*</bpt>options<ept id="p3">*</ept> parameter set to <ph id="ph3">`RegexOptions.Multiline`</ph> again finds five matches.</source>
          <target state="translated">Wenn das Muster des regulären Ausdrucks jedoch geändert wird, indem <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> durch <bpt id="p2">**</bpt>\r?$<ept id="p2">**</ept> ersetzt wird, ergibt der Aufruf der <ph id="ph2">`Regex.Matches(String, String, RegexOptions)`</ph>-Methode wieder fünf Übereinstimmungen, sofern der Parameter <bpt id="p3">*</bpt>options<ept id="p3">*</ept> auf <ph id="ph3">`RegexOptions.Multiline`</ph> festgelegt ist.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Start of String Only: \A</source>
          <target state="translated">Nur Anfang der Zeichenfolge: \A</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> anchor specifies that a match must occur at the beginning of the input string.</source>
          <target state="translated">Der <bpt id="p1">**</bpt>\A<ept id="p1">**</ept>-Anker gibt an, dass eine Übereinstimmung am Anfang der Eingabezeichenfolge vorliegen muss.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>It is identical to the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> anchor, except that <bpt id="p2">**</bpt>\A<ept id="p2">**</ept> ignores the <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option.</source>
          <target state="translated">Dies ist mit dem <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept>-Anker identisch, jedoch ignoriert <bpt id="p2">**</bpt>\A<ept id="p2">**</ept> die <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>-Option.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Therefore, it can only match the start of the first line in a multiline input string.</source>
          <target state="translated">Daher kann hiermit in einer mehrzeiligen Eingabezeichenfolge nur eine Übereinstimmung nur am Anfang der ersten Zeile gesucht werden.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The following example is similar to the examples for the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> anchors.</source>
          <target state="translated">Das folgende Beispiel ähnelt den Beispielen für den <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept>-Anker und den <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept>-Anker.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">Der <bpt id="p1">**</bpt>\A<ept id="p1">**</ept>-Anker wird in einem regulären Ausdruck verwendet, der Informationen zu den Jahren extrahiert, in denen es bestimmte professionelle Baseballteams gab.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The input string includes five lines.</source>
          <target state="translated">Die Eingabezeichenfolge weist fünf Zeilen auf.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The call to the <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method finds only the first substring in the input string that matches the regular expression pattern.</source>
          <target state="translated">Der Aufruf der <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>-Überladung sucht nur die erste Teilzeichenfolge in der Eingabezeichenfolge, die mit dem Muster des regulären Ausdrucks übereinstimmt.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>As the example shows, the <ph id="ph1">`Multiline`</ph> option has no effect.</source>
          <target state="translated">Wie im Beispiel dargestellt, hat die <ph id="ph1">`Multiline`</ph>-Option keine Auswirkungen.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>End of String or Before Ending Newline: \Z</source>
          <target state="translated">Ende der Zeichenfolge oder vor dem abschließenden Zeilenumbruch: \Z</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> anchor specifies that a match must occur at the end of the input string, or before <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> at the end of the input string.</source>
          <target state="translated">Der <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept>-Anker gibt an, dass eine Übereinstimmung am Ende der Eingabezeichenfolge oder vor <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> am Ende der Eingabezeichenfolge vorliegen muss.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>It is identical to the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> anchor, except that <bpt id="p2">**</bpt>\Z<ept id="p2">**</ept> ignores the <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option.</source>
          <target state="translated">Dies ist mit dem <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept>-Anker identisch, jedoch ignoriert <bpt id="p2">**</bpt>\Z<ept id="p2">**</ept> die <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>-Option.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Therefore, in a multiline string, it can only match the end of the last line, or the last line before <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</source>
          <target state="translated">Daher kann hiermit in einer mehrzeiligen Zeichenfolge nur nach einer Übereinstimmung mit dem Ende der letzten Zeile oder der letzten Zeile vor <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> gesucht werden.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Note that <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> matches <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> but does not match <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (the CR/LF character combination).</source>
          <target state="translated">Beachten Sie, dass <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> mit <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>, aber nicht mit <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> übereinstimmt (der CR/LF-Zeichenkombination).</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>To match CR/LF, include <bpt id="p1">**</bpt>\r?\Z<ept id="p1">**</ept> in the regular expression pattern.</source>
          <target state="translated">Zum Suchen einer Übereinstimmung mit CR/LF schließen Sie <bpt id="p1">**</bpt>\r \Z<ept id="p1">**</ept> in das Muster des regulären Ausdrucks ein.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> anchor in a regular expression that is similar to the example in the previous "Start of String or Line" section, which extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">Im folgenden Beispiel wird der <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept>-Anker in einem regulären Ausdruck verwendet, der ähnlich wie das Beispiel aus dem vorherigen Abschnitt „Anfang der Zeichenfolge oder Zeile“ Informationen zu den Jahren extrahiert, in denen es bestimmte professionelle Baseballteams gab.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The subexpression <ph id="ph1">`\r?\Z`</ph> in the regular expression <ph id="ph2">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z`</ph> matches the end of a string, and also matches a string that ends with <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> or <bpt id="p2">**</bpt>\r\n<ept id="p2">**</ept>.</source>
          <target state="translated">Der Teilausdruck <ph id="ph1">`\r?\Z`</ph> im regulären Ausdruck <ph id="ph2">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z`</ph> stimmt sowohl mit dem Ende einer Zeichenfolge als auch mit einer Zeichenfolge überein, die mit <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> oder <bpt id="p2">**</bpt>\r\n<ept id="p2">**</ept> endet.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>As a result, each element in the array matches the regular expression pattern.</source>
          <target state="translated">Folglich stimmt jedes Element im Array mit dem Muster des regulären Ausdrucks überein.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>End of String Only: \z</source>
          <target state="translated">Nur Ende der Zeichenfolge: \z</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> anchor specifies that a match must occur at the end of the input string.</source>
          <target state="translated">Der <bpt id="p1">**</bpt>\z<ept id="p1">**</ept>-Anker gibt an, dass eine Übereinstimmung am Ende der Eingabezeichenfolge vorliegen muss.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Like the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> language element, <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> ignores the <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option.</source>
          <target state="translated">Wie das <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept>-Sprachelement ignoriert <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> die <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>-Option.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Unlike the <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> language element, <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> does not match a <bpt id="p3">**</bpt>\n<ept id="p3">**</ept> character at the end of a string.</source>
          <target state="translated">Im Gegensatz zum <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept>-Sprachelement stimmt <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> nicht mit einem <bpt id="p3">**</bpt>\n<ept id="p3">**</ept>-Zeichen am Ende einer Zeichenfolge überein.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Therefore, it can only match the last line of the input string.</source>
          <target state="translated">Daher kann hiermit nur eine Übereinstimmung mit der letzten Zeile der Eingabezeichenfolge gesucht werden.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> anchor in a regular expression that is otherwise identical to the example in the previous section, which extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">Im folgenden Beispiel wird der <bpt id="p1">**</bpt>\z<ept id="p1">**</ept>-Anker in einem regulären Ausdruck verwendet, der ansonsten mit dem Beispiel aus dem vorherigen Abschnitt übereinstimmt und Informationen zu den Jahren extrahiert, in denen es bestimmte professionelle Baseballteams gab.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The example tries to match each of five elements in a string array with the regular expression pattern <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`</ph>.</source>
          <target state="translated">Im Beispiel wird versucht, eine Übereinstimmung mit dem Muster eines regulären Ausdrucks <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`</ph> für jedes der fünf Elemente in einem Zeichenfolgenarray zu finden.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Two of the strings end with carriage return and line feed characters, one ends with a line feed character, and two end with neither a carriage return nor a line feed character.</source>
          <target state="translated">Zwei der Zeichenfolgen enden mit Wagenrücklauf- und Zeilenvorschubzeichen, eine endet mit einem Zeilenvorschubzeichen, und zwei enden weder mit einem Wagenrücklauf- noch mit einem Zeilenvorschubzeichen.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>As the output shows, only the strings without a carriage return or line feed character match the pattern.</source>
          <target state="translated">Wie die Ausgabe ergibt, stimmen nur die Zeichenfolgen ohne Wagenrücklauf oder Zeilenvorschub mit dem Muster überein.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Contiguous Matches: \G</source>
          <target state="translated">Aufeinander folgende Übereinstimmungen: \G</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\G<ept id="p1">**</ept> anchor specifies that a match must occur at the point where the previous match ended.</source>
          <target state="translated">Der <bpt id="p1">**</bpt>\G<ept id="p1">**</ept>-Anker gibt an, dass eine Übereinstimmung an dem Punkt vorliegen muss, an dem die vorherige Übereinstimmung endet.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>When you use this anchor with the <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> or <bpt id="p2">[</bpt>Match.NextMatch<ept id="p2">](xref:System.Text.RegularExpressions.Match.NextMatch)</ept> method, it ensures that all matches are contiguous.</source>
          <target state="translated">Wenn Sie diesen Anker mit der <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept>-Methode oder <bpt id="p2">[</bpt>Match.NextMatch<ept id="p2">](xref:System.Text.RegularExpressions.Match.NextMatch)</ept>-Methode verwenden, wird sichergestellt, dass alle Übereinstimmungen zusammenhängend sind.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The following example uses a regular expression to extract the names of rodent species from a comma-delimited string.</source>
          <target state="translated">Im folgenden Beispiel werden mithilfe eines regulären Ausdrucks die Namen von Nagetierspezies aus einer durch Trennzeichen getrennten Zeichenfolge extrahiert.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\G(\w+\s?\w*),?`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Der reguläre Ausdruck <ph id="ph1">`\G(\w+\s?\w*),?`</ph> wird entsprechend der Darstellung in der folgenden Tabelle interpretiert.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Begin where the last match ended.</source>
          <target state="translated">Beginnt die Übereinstimmung am Ende der vorherigen.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Übereinstimmung mit mindestens einem Wortzeichen.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Match zero or one space.</source>
          <target state="translated">Übereinstimmung mit 0 (Null) oder einem Leerzeichen.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
          <target state="translated">Übereinstimmung mit keinem oder mehreren Wortzeichen.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by zero or one space, followed by zero or more word characters.</source>
          <target state="translated">Übereinstimmung mit mindestens einem Wortzeichen gefolgt von 0 (Null) oder einem Leerzeichen, gefolgt von 0 (Null) oder weiteren Wortzeichen.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Dies ist die erste Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a literal comma character.</source>
          <target state="translated">Übereinstimmung mit 0 (Null) oder einem Literal-Kommazeichen.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Word Boundary: \b</source>
          <target state="translated">Wortgrenze: \b</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> anchor specifies that the match must occur on a boundary between a word character (the <bpt id="p2">**</bpt>\w<ept id="p2">**</ept> language element) and a non-word character (the <bpt id="p3">**</bpt>\W<ept id="p3">**</ept> language element).</source>
          <target state="translated">Der <bpt id="p1">**</bpt>\b<ept id="p1">**</ept>-Anker gibt an, dass die Übereinstimmung an einer Grenze zwischen einem Wortzeichen (dem <bpt id="p2">**</bpt>\w<ept id="p2">**</ept>-Sprachelement) und einem Nicht-Wortzeichen (dem <bpt id="p3">**</bpt>\W<ept id="p3">**</ept>-Sprachelement) vorliegen muss.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore.</source>
          <target state="translated">Wortzeichen bestehen aus alphanumerischen Zeichen und Unterstrichen. Bei Nicht-Wortzeichen handelt es sich um alle Zeichen, die weder alphanumerisch noch Unterstriche sind.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>(For more information, see <bpt id="p1">[</bpt>Character classes in regular expressions<ept id="p1">](classes.md)</ept>.) The match may also occur on a word boundary at the beginning or end of the string.</source>
          <target state="translated">(Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Zeichenklassen in regulären Ausdrücken<ept id="p1">](classes.md)</ept>.) Die Übereinstimmung kann auch an einer Wortgrenze am Anfang oder Ende der Zeichenfolge vorliegen.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
          <target state="translated">Der <bpt id="p1">**</bpt>\b<ept id="p1">**</ept>-Anker wird häufig verwendet, um sicherzustellen, dass ein Teilausdruck statt nur mit Anfang oder Ende mit einem ganzen Wort übereinstimmt.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\bare\w*\b`</ph> in the following example illustrates this usage.</source>
          <target state="translated">Im folgenden Beispiel wird die Verwendung des regulären Ausdrucks <ph id="ph1">`\bare\w*\b`</ph> veranschaulicht.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>It matches any word that begins with the substring "are".</source>
          <target state="translated">Der Ausdruck stimmt mit jedem Wort überein, das mit der Teilzeichenfolge "are" beginnt.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The output from the example also illustrates that <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> matches both the beginning and the end of the input string.</source>
          <target state="translated">Die Ausgabe des Beispiels veranschaulicht auch, dass <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> sowohl mit dem Anfang als auch dem Ende der Eingabezeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">Das Muster für reguläre Ausdrücke wird entsprechend der folgenden Tabelle interpretiert.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Der Vergleich beginnt an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match the substring "are".</source>
          <target state="translated">Übereinstimmung mit der Teilzeichenfolge "are".</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
          <target state="translated">Übereinstimmung mit keinem oder mehreren Wortzeichen.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Der Vergleich endet an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Non-Word Boundary: \B</source>
          <target state="translated">Nicht-Wortgrenze: \B</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> anchor specifies that the match must not occur on a word boundary.</source>
          <target state="translated">Der <bpt id="p1">**</bpt>\B<ept id="p1">**</ept>-Anker gibt an, dass die Übereinstimmung nicht an einer Wortgrenze vorliegen darf.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>It is the opposite of the <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> anchor.</source>
          <target state="translated">Dies ist das Gegenteil des <bpt id="p1">**</bpt>\b<ept id="p1">**</ept>-Ankers.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> anchor to locate occurrences of the substring "qu" in a word.</source>
          <target state="translated">Im folgenden Beispiel wird der <bpt id="p1">**</bpt>\B<ept id="p1">**</ept>-Anker verwendet, um nach Vorkommen der Teilzeichenfolge „qu“ in einem Wort zu suchen.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\Bqu\w+`</ph> matches a substring that begins with a "qu" that does not start a word and that continues to the end of the word.</source>
          <target state="translated">Das Muster des regulären Ausdrucks <ph id="ph1">`\Bqu\w+`</ph> stimmt mit einer Teilzeichenfolge überein, die mit "qu" beginnt, nicht der Wortbeginn ist und bis zum Ende des Worts reicht.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">Das Muster für reguläre Ausdrücke wird entsprechend der folgenden Tabelle interpretiert.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Do not begin the match at a word boundary.</source>
          <target state="translated">Übereinstimmung beginnt nicht an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Match the substring "qu".</source>
          <target state="translated">Übereinstimmung mit der Teilzeichenfolge "qu".</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Übereinstimmung mit mindestens einem Wortzeichen.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Siehe auch</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Sprachelemente für reguläre Ausdrücke – Kurzübersicht<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Optionen für reguläre Ausdrücke<ept id="p1">](options.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>