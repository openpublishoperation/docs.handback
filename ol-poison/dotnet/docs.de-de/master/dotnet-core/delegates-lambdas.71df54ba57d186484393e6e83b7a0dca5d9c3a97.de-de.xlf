<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7e9bb11db4b3586639a0447737db9cd376898325</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\delegates-lambdas.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aae9cbbba18c773bfb2aa397d05cf92d27a78319</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">49dc69e4e91139bbca55aa335f4dc86d6899dfa7</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file delegates-lambdas.71df54ba57d186484393e6e83b7a0dca5d9c3a97.de-de.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">Delegaten und Lambdas</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">Delegaten und Lambdas</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Delegates and lambdas</source>
          <target state="translated">Delegaten und Lambdas</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Delegates define a type, which specify a particular method signature.</source>
          <target state="translated">Delegaten definieren einen Typ, der eine bestimmte Methodensignatur angibt.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>A method (static or instance) that satisfies this signature can be assigned to a variable of that type, then called directly (with the appropriate arguments) or passed as an argument itself to another method and then called.</source>
          <target state="translated">Eine Methode (statische Methode oder Instanzmethode), die dieser Signatur entspricht, kann einer Variablen dieses Typs zugewiesen werden. Anschließend kann sie (mit den entsprechenden Argumenten) direkt aufgerufen oder selbst als Argument an eine andere Methode übergeben und dann aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The following example demonstrates delegate use.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von Delegaten.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>On line 4 we create a delegate type of a certain signature, in this case a method that takes a string parameter and then returns a string parameter.</source>
          <target state="translated">In Zeile 4 erstellen wir einen Delegattyp mit einer bestimmten Signatur – in diesem Fall eine Methode, die einen Zeichenfolgenparameter akzeptiert und dann einen Zeichenfolgenparameter zurückgibt.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>On line 6, we define the implementation of the delegate by providing a method that has the exact same signature.</source>
          <target state="translated">In Zeile 6 definieren wir die Implementierung des Delegaten, indem wir eine Methode bereitstellen, die exakt die gleiche Signatur aufweist.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>On line 13, the method is assigned to a type that conforms to the <ph id="ph1">`Reverse`</ph> delegate.</source>
          <target state="translated">In Zeile 13 wird die Methode einem Typ zugewiesen, der dem <ph id="ph1">`Reverse`</ph>-Delegaten entspricht.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Finally, on line 15 we invoke the delegate passing a string to be reversed.</source>
          <target state="translated">In Zeile 15 rufen wir schließlich den Delegaten auf, indem wir eine Zeichenfolge übergeben, die umgekehrt werden soll.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In order to streamline the development process, .NET includes a set of delegate types that programmers can reuse and not have to create new types.</source>
          <target state="translated">Um den Entwicklungsprozess zu optimieren, enthält .NET eine Reihe von Delegattypen, die Programmierer verwenden können, damit sie keine neuen Typen erstellen müssen.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>These are <ph id="ph1">`Func&lt;&gt;`</ph>, <ph id="ph2">`Action&lt;&gt;`</ph> and <ph id="ph3">`Predicate&lt;&gt;`</ph>, and they can be used in various places throughout the .NET APIs without the need to define new delegate types.</source>
          <target state="translated">Dies sind <ph id="ph1">`Func&lt;&gt;`</ph>, <ph id="ph2">`Action&lt;&gt;`</ph> und <ph id="ph3">`Predicate&lt;&gt;`</ph>. Sie können an verschiedenen Stellen in den .NET-APIs verwendet werden, ohne dass neue Delegattypen definiert werden müssen.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Of course, there are some differences between the three as you will see in their signatures which mostly have to do with the way they were meant to be used:</source>
          <target state="translated">Natürlich gibt es Unterschiede zwischen den drei Typen, wie Sie in ihren Signaturen erkennen können. Hierbei handelt es sich meist um Unterschiede in der Art und Weise der Verwendung dieser Typen:</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Action&lt;&gt;`</ph> is used when there is a need to perform an action using the arguments of the delegate.</source>
          <target state="translated"><ph id="ph1">`Action&lt;&gt;`</ph> wird verwendet, wenn eine Aktion mithilfe der Argumente des Delegaten ausgeführt werden muss.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Func&lt;&gt;`</ph> is used usually when you have a transformation on hand, that is, you need to transform the arguments of the delegate into a different result.</source>
          <target state="translated"><ph id="ph1">`Func&lt;&gt;`</ph> wird üblicherweise verwendet, wenn eine Transformation ausgeführt werden muss, Sie also die Argumente des Delegaten in ein anderes Ergebnis transformieren müssen.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Projections are a prime example of this.</source>
          <target state="translated">Projektionen sind ein gutes Beispiel hierfür.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Predicate&lt;&gt;`</ph> is used when you need to determine if the argument satisfies the condition of the delegate.</source>
          <target state="translated"><ph id="ph1">`Predicate&lt;&gt;`</ph> wird verwendet, wenn Sie ermitteln müssen, ob das Argument die Bedingung des Delegaten erfüllt.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>It can also be written as a <ph id="ph1">`Func&lt;T, bool&gt;`</ph>.</source>
          <target state="translated">Der Typ kann auch als <ph id="ph1">`Func&lt;T, bool&gt;`</ph> geschrieben werden.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>We can now take our example above and rewrite it using the <ph id="ph1">`Func&lt;&gt;`</ph> delegate instead of a custom type.</source>
          <target state="translated">Wir schreiben jetzt das obige Beispiel neu, indem wir den <ph id="ph1">`Func&lt;&gt;`</ph>-Delegaten anstelle eines benutzerdefinierten Typs verwenden.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The program will continue running exactly the same.</source>
          <target state="translated">Das Programm wird weiterhin genau gleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For this simple example, having a method defined outside of the Main() method seems a bit superfluous.</source>
          <target state="translated">In diesem einfachen Beispiel erscheint es überflüssig, eine Methode außerhalb der Main()-Methode zu definieren.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>It is because of this that .NET Framework 2.0 introduced the concept of <bpt id="p1">**</bpt>anonymous delegates<ept id="p1">**</ept>.</source>
          <target state="translated">Aus diesem Grund wurde in .NET Framework 2.0 das Konzept der <bpt id="p1">**</bpt>anonymen Delegaten<ept id="p1">**</ept> eingeführt.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>With their support you are able to create “inline” delegates without having to specify any additional type or method.</source>
          <target state="translated">Damit können Sie „Inlinedelegaten“ erstellen, ohne einen weiteren Typ oder eine zusätzliche Methode angeben zu müssen.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>You simply inline the definition of the delegate where you need it.</source>
          <target state="translated">Sie fügen einfach die Definition des Delegaten inline dort ein, wo Sie sie benötigen.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For an example, we are going to switch it up and use our anonymous delegate to filter out a list of only even numbers and then print them to the console.</source>
          <target state="translated">Als Beispiel verwenden wir unseren anonymen Delegaten, um eine Liste mit gerade Zahlen herauszufiltern und diese Zahlen in der Konsole auszugeben.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Notice the highlighted lines.</source>
          <target state="translated">Beachten Sie die markierten Zeilen.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>As you can see, the body of the delegate is just a set of expressions, as any other delegate.</source>
          <target state="translated">Wie Sie sehen, besteht der Haupttext des Delegaten einfach nur aus einer Reihe von Ausdrücken, wie bei jedem anderen Delegaten auch.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>But instead of it being a separate definition, we’ve introduced it <bpt id="p1">_</bpt>ad hoc<ept id="p1">_</ept> in our call to the <ph id="ph1">`FindAll()`</ph> method of the <ph id="ph2">`List&lt;T&gt;`</ph> type.</source>
          <target state="translated">Anstatt aber eine separate Definition zu erstellen, haben wir ihn <bpt id="p1">_</bpt>ad hoc<ept id="p1">_</ept> in den Aufruf der <ph id="ph1">`FindAll()`</ph>-Methode des <ph id="ph2">`List&lt;T&gt;`</ph>-Typs eingeführt.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>However, even with this approach, there is still much code that we can throw away.</source>
          <target state="translated">Selbst bei dieser Vorgehensweise bleibt immer noch zu viel Code übrig, den wir nicht benötigen.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This is where <bpt id="p1">**</bpt>lambda expressions<ept id="p1">**</ept> come into play.</source>
          <target state="translated">Hier kommen <bpt id="p1">**</bpt>Lambdaausdrücke<ept id="p1">**</ept> ins Spiel.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Lambda expressions, or just “lambdas” for short, were introduced first in C# 3.0, as one of the core building blocks of Language Integrated Query (LINQ).</source>
          <target state="translated">Lambdaausdrücke (kurz „Lambdas“) wurden zum ersten Mal in C# 3.0 eingeführt und stellen einen der wichtigsten Bausteine von LINQ (Language Integrated Query).</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>They are just a more convenient syntax for using delegates.</source>
          <target state="translated">Sie sind einfach eine praktischere Syntax für die Verwendung von Delegaten.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>They declare a signature and a method body, but don’t have an formal identity of their own, unless they are assigned to a delegate.</source>
          <target state="translated">Sie deklarieren eine Signatur und einen Methodentext, besitzen aber keine eigene formale Identität, sofern sie nicht einem Delegaten zugewiesen sind.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Unlike delegates, they can be directly assigned as the left-hand side of event registration or in various Linq clauses and methods.</source>
          <target state="translated">Im Gegensatz zu Delegaten können sie direkt als linke Seite der Ereignisregistrierung oder in verschiedenen LINQ-Klauseln und -Methoden zugewiesen werden.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Since a lambda expression is just another way of specifying a delegate, we should be able to rewrite the above sample to use a lambda expression instead of an anonymous delegate.</source>
          <target state="translated">Da ein Lambdaausdruck einfach nur eine weitere Möglichkeit ist, einen Delegaten anzugeben, können wir das obige Beispiel neu schreiben und einen Lambdaausdruck anstelle eines anonymen Delegaten verwenden.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If you take a look at the highlighted lines, you can see how a lambda expression looks like.</source>
          <target state="translated">In den markierten Zeilen sehen Sie, wie ein Lambdaausdruck aussieht.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Again, it is just a <bpt id="p1">**</bpt>very<ept id="p1">**</ept> convenient syntax for using delegates, so what happens under the covers is similar to what happens with the anonymous delegate.</source>
          <target state="translated">Das ist einfach eine <bpt id="p1">**</bpt>sehr<ept id="p1">**</ept> praktische Syntax für die Verwendung von Delegaten. Hinter den Kulissen passiert das Gleiche wie bei anonymen Delegaten.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Again, lambdas are just delegates, which means that they can be used as an event handler without any problems, as the following code snippet illustrates.</source>
          <target state="translated">Noch einmal: Lambdas sind einfach Delegaten. Das bedeutet, dass sie problemlos als Ereignishandler verwendet werden können, wie im folgenden Codeausschnitt veranschaulicht.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Further reading and resources</source>
          <target state="translated">Weitere Informationen und Ressourcen</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates<ept id="p1">](https://msdn.microsoft.com/library/ms173171.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Delegaten<ept id="p1">](https://msdn.microsoft.com/library/ms173171.aspx)</ept></target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Anonymous Functions<ept id="p1">](https://msdn.microsoft.com/library/bb882516.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Anonyme Funktionen<ept id="p1">](https://msdn.microsoft.com/library/bb882516.aspx)</ept></target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Lambda expressions<ept id="p1">](https://msdn.microsoft.com/library/bb397687.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lambda-Ausdrücke<ept id="p1">](https://msdn.microsoft.com/library/bb397687.aspx)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>