<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1458cfdb81c53b7eab384c1b7f3e65c7ad7d8098</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\language-independence.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2cd82917b5829a18453fc14cb36b156bb7d01cb4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2e998e059db8123a9b6708f3ceabde887b5cbbc3</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file language-independence.c22b026a92debade3b0e0672b2f13dac168d8abe.de-de.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Language independence and language-independent components</source>
          <target state="translated">Sprachunabhängigkeit und sprachunabhängige Komponenten</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Language independence and language-independent components</source>
          <target state="translated">Sprachunabhängigkeit und sprachunabhängige Komponenten</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Language independence and language-independent components</source>
          <target state="translated">Sprachunabhängigkeit und sprachunabhängige Komponenten</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The .NET platform is language independent.</source>
          <target state="translated">Die .NET-Plattform ist sprachunabhängig.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This means that, as a developer, you can develop in one of the many languages that target the .NET platform, such as C#, F#, and Visual Basic.</source>
          <target state="translated">Dies bedeutet, dass Sie als Entwickler in einer von vielen Sprachen für die .NET-Plattform entwickeln können, beispielweise C#, F# und Visual Basic.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can access the types and members of class libraries developed for the .NET platform without having to know the language in which they were originally written and without having to follow any of the original language's conventions.</source>
          <target state="translated">Sie können auf die Typen und Member von Klassenbibliotheken zugreifen, die für die .NET-Plattform entwickelt wurden, ohne die Sprache, in der sie ursprünglich geschrieben wurden, kennen zu müssen und ohne den Konventionen der Originalsprache folgen zu müssen.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you are a component developer, your component can be accessed by any .NET app regardless of its language.</source>
          <target state="translated">Wenn Sie ein Komponentenentwickler sind, kann von allen .NET-Apps sprachunabhängig auf die Komponente zugegriffen werden.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This first part of this article discusses creating language-independent components - that is, components that can be consumed by apps that are written in any language.</source>
          <target state="translated">In diesem Artikel wird das Erstellen sprachunabhängiger Komponenten erläutert. Diese Komponenten können von Apps verwendet werden, die in einer beliebigen Sprache geschrieben wurden.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can also create a single component or app from source code written in multiple languages; see <bpt id="p1">[</bpt>Cross-Language Interoperability<ept id="p1">](#cross-language-interoperability)</ept> in the second part of this article.</source>
          <target state="translated">Sie können auch eine einzelne Komponente oder App aus Quellcode erstellen, der in mehreren Sprachen geschrieben wurde. Weitere Informationen finden Sie im zweiten Teil dieses Artikels unter <bpt id="p1">[</bpt>Sprachübergreifende Interoperabilität<ept id="p1">](#cross-language-interoperability)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>To fully interact with other objects written in any language, objects must expose to callers only those features that are common to all languages.</source>
          <target state="translated">Um vollständig mit anderen Objekten zu interagieren, die in irgendeiner Programmiersprache geschrieben wurden, müssen die Objekte den Aufrufern nur die Funktionen verfügbar machen, die allen Sprachen gemeinsam sind.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This common set of features is defined by the Common Language Specification (CLS), which is a set of rules that apply to generated assemblies.</source>
          <target state="translated">Dieser gemeinsame Satz von Funktionen wird von der CLS (Common Language Specification) definiert. Das ist ein Satz von Regeln, die für generierte Assemblys gelten.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The Common Language Specification is defined in Partition I, Clauses 7 through 11 of the <bpt id="p1">[</bpt>ECMA-335 Standard: Common Language Infrastructure<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept>.</source>
          <target state="translated">Die Common Language Specification wird in der Partition I, in den Klauseln 7 bis 11 im <bpt id="p1">[</bpt>ECMA 335-Standard: Common Language Infrastructure<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept> definiert.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If your component conforms to the Common Language Specification, it is guaranteed to be CLS-compliant and can be accessed from code in assemblies written in any programming language that supports the CLS.</source>
          <target state="translated">Wenn die Komponente der Common Language Specification entspricht, ist sichergestellt, dass sie CLS-kompatibel ist, und dass vom Code in Assemblys, die in irgendeiner CLS unterstützenden Programmiersprache geschrieben wurden, aus auf sie zugegriffen werden kann.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You can determine whether your component conforms to the Common Language Specification at compile time by applying the <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> attribute to your source code.</source>
          <target state="translated">Sie können bestimmen, ob die Komponente zur Kompilierzeit der Common Language Specification entspricht, indem Sie das <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept>-Attribut auf den Quellcode anwenden.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For more information, see The <bpt id="p1">[</bpt>CLSCompliantAttribute attribute<ept id="p1">](#the-clscompliantattribute-attribute)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt zum <bpt id="p1">[</bpt>CLSCompliantAttribute-Attribut<ept id="p1">](#the-clscompliantattribute-attribute)</ept>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>In this article:</source>
          <target state="translated">In diesem Artikel:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CLS compliance rules<ept id="p1">](#cls-compliance-rules)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>CLS-Kompatibilitätsregeln<ept id="p1">](#cls-compliance-rules)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typen und Typmembersignaturen<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Naming conventions<ept id="p1">](#naming-conventions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Namenskonventionen<ept id="p1">](#naming-conventions)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type conversion<ept id="p1">](#type-conversion)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typkonvertierung<ept id="p1">](#type-conversion)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Arrays<ept id="p1">](#arrays)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Arrays<ept id="p1">](#arrays)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Schnittstellen<ept id="p1">](#interfaces)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enumerations<ept id="p1">](#enumerations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Enumerationen<ept id="p1">](#enumerations)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type members in general<ept id="p1">](#type-members-in-general)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typmember im Allgemeinen<ept id="p1">](#type-members-in-general)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Member accessibility<ept id="p1">](#member-accessibility)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Memberzugriff<ept id="p1">](#member-accessibility)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generische Typen und Member<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Constructors<ept id="p1">](#constructors)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Konstruktoren<ept id="p1">](#constructors)</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Eigenschaften<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Ereignisse<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Overloads<ept id="p1">](#overloads)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Überladungen<ept id="p1">](#overloads)</ept></target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Exceptions<ept id="p1">](#exceptions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Ausnahmen<ept id="p1">](#exceptions)</ept></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Attributes<ept id="p1">](#attributes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Attribute<ept id="p1">](#attributes)</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CLSCompliantAttribute attribute<ept id="p1">](#the-clscompliantattribute-attribute)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>CLSCompliantAttribute-Attribut<ept id="p1">](#the-clscompliantattribute-attribute)</ept></target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Cross-Language Interoperability<ept id="p1">](#cross-language-interoperability)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Sprachübergreifende Interoperabilität<ept id="p1">](#cross-language-interoperability)</ept></target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>CLS compliance rules</source>
          <target state="translated">CLS-Kompatibilitätsregeln</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This section discusses the rules for creating a CLS-compliant component.</source>
          <target state="translated">In diesem Abschnitt werden die Regeln zum Erstellen einer CLS-kompatiblen Komponente beschrieben.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For a complete list of rules, see Partition I, Clause 11 of the <bpt id="p1">[</bpt>ECMA-335 Standard: Common Language Infrastructure<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept>.</source>
          <target state="translated">Eine vollständige Liste der Regeln finden Sie unter Partition I, Klausel 11 im <bpt id="p1">[</bpt>ECMA 335-Standard: Common Language Infrastructure<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The Common Language Specification discusses each rule for CLS compliance as it applies to consumers (developers who are programmatically accessing a component that is CLS-compliant), frameworks (developers who are using a language compiler to create CLS-compliant libraries), and extenders (developers who are creating a tool such as a language compiler or a code parser that creates CLS-compliant components).</source>
          <target state="translated">In der Common Language Specification wird für jede Regel der CLS-Kompatibilität erläutert, wie sie auf Consumer (Entwickler, die programmgesteuert auf eine CLS-kompatible Komponente zugreifen), Frameworks (Entwickler, die einen Sprachcompiler zum Erstellen von CLS-kompatiblen Bibliotheken verwenden) und Extender (Entwickler, die zum Erstellen CLS-kompatibler Komponenten ein Tool, wie einen Sprachcompiler oder einen Codeparser, erstellen) anzuwenden ist.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This article focuses on the rules as they apply to frameworks.</source>
          <target state="translated">In diesem Artikel wird auf die Anwendbarkeit der Regeln für Frameworks eingegangen.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Note, though, that some of the rules that apply to extenders may also apply to assemblies that are created using <bpt id="p1">[</bpt>Reflection.Emit<ept id="p1">](xref:System.Reflection.Emit)</ept>.</source>
          <target state="translated">Beachten Sie allerdings, dass möglicherweise einige der Regeln für Extender auch auf Assemblys anwendbar sind, die mithilfe von <bpt id="p1">[</bpt>Reflection.Emit<ept id="p1">](xref:System.Reflection.Emit)</ept> erstellt werden.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>To design a component that is language independent, you only need to apply the rules for CLS compliance to your component's public interface.</source>
          <target state="translated">Um eine sprachenneutrale Komponente zu entwerfen, müssen Sie nur die CLS-Kompatibilitätregeln auf die öffentliche Schnittstelle der Komponente anwenden.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Your private implementation does not have to conform to the specification.</source>
          <target state="translated">Die private Implementierung muss nicht mit der Spezifikation konform sein.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The rules for CLS compliance apply only to a component's public interface, not to its private implementation.</source>
          <target state="translated">Die Regeln für CLS-Kompatibilität gelten nur für die öffentlichen Schnittstelle einer Komponente, nicht für die private Implementierung.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For example, unsigned integers other than <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept> are not CLS-compliant.</source>
          <target state="translated">Zum Beispiel sind ganze Zahlen ohne Vorzeichen, außer <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`Person`</ph> class in the following example exposes an <ph id="ph2">`Age`</ph> property of type <bpt id="p1">[</bpt>UInt16<ept id="p1">](xref:System.UInt16)</ept>, the following code displays a compiler warning.</source>
          <target state="translated">Da die <ph id="ph1">`Person`</ph>-Klasse im folgenden Beispiel eine <ph id="ph2">`Age`</ph>-Eigenschaft des Typs <bpt id="p1">[</bpt>UInt16<ept id="p1">](xref:System.UInt16)</ept> verfügbar macht, zeigt der folgende Code eine Compilerwarnung an.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You can make the Person class CLS-compliant by changing the type of <ph id="ph1">`Age`</ph> property from <ph id="ph2">`UInt16`</ph> to <bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept>, which is a CLS-compliant, 16-bit signed integer.</source>
          <target state="translated">Sie können CLS-Kompatibilität für die Person-Klasse erreichen, indem Sie den Typ der <ph id="ph1">`Age`</ph>-Eigenschaft von <ph id="ph2">`UInt16`</ph> in <bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept> ändern. Dies ist eine CLS-kompatible ganze Zahl mit Vorzeichen und einer Länge von 16 Bit.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You do not have to change the type of the private <ph id="ph1">`personAge`</ph> field.</source>
          <target state="translated">Sie müssen den Typ des privaten <ph id="ph1">`personAge`</ph>-Felds nicht ändern.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A library's public interface consists of the following:</source>
          <target state="translated">Die öffentliche Schnittstelle einer Bibliothek besteht aus folgenden Elementen:</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Definitions of public classes.</source>
          <target state="translated">Definitionen öffentlicher Klassen</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Definitions of the public members of public classes, and definitions of members accessible to derived classes (that is, protected members).</source>
          <target state="translated">Definitionen öffentlicher Member von öffentlichen Klassen sowie in Definitionen von Membern, auf die abgeleitete Klassen zugreifen können (d. h. geschützte Member).</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Parameters and return types of public methods of public classes, and parameters and return types of methods accessible to derived classes.</source>
          <target state="translated">Parameter und Rückgabetypen öffentlicher Methoden von öffentlichen Klassen sowie Parameter und Rückgabetypen von Methoden, auf die abgeleitete Klassen zugreifen können.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The rules for CLS compliance are listed in the following table.</source>
          <target state="translated">Die Regeln für CLS-Kompatibilität werden in der folgenden Tabelle aufgeführt.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The text of the rules is taken verbatim from the <bpt id="p1">[</bpt>ECMA-335 Standard: Common Language Infrastructure<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept>, which is Copyright 2012 by Ecma International.</source>
          <target state="translated">Der Text der Regeln wird in vollem Wortlaut dem <bpt id="p1">[</bpt>ECMA-335-Standard: Common Language Infrastructure<ept id="p1">](http://www.ecma-international.org/publications/standards/Ecma-335.htm)</ept> entnommen. Copyright 2012 durch Ecma-International.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>More detailed information about these rules is found in the following sections.</source>
          <target state="translated">Ausführlichere Informationen zu diesen Regeln finden Sie in den folgenden Abschnitten.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Kategorie</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>See</source>
          <target state="translated">Siehe</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Rule</source>
          <target state="translated">Regel</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Rule Number</source>
          <target state="translated">Regelzahl</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Barrierefreiheit</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Member accessibility<ept id="p1">](#member-accessibility)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Memberzugriff<ept id="p1">](#member-accessibility)</ept></target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Accessibility shall not be changed when overriding inherited methods, except when overriding a method inherited from a different assembly with accessibility <ph id="ph1">`family-or-assembly`</ph>.</source>
          <target state="translated">Beim Überschreiben von geerbten Methoden darf der Zugriff nicht geändert werden, außer wenn eine Methode überschrieben wird, die von einer anderen Assembly mit <ph id="ph1">`family-or-assembly`</ph>-Zugriff vererbt wurde.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>In this case, the override shall have accessibility <ph id="ph1">`family`</ph>.</source>
          <target state="translated">In diesem Fall muss für die Überschreibung <ph id="ph1">`family`</ph>-Zugriff festgelegt werden.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>10</source>
          <target state="translated">10</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Barrierefreiheit</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Member accessibility<ept id="p1">](#member-accessibility)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Memberzugriff<ept id="p1">](#member-accessibility)</ept></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The visibility and accessibility of types and members shall be such that types in the signature of any member shall be visible and accessible whenever the member itself is visible and accessible.</source>
          <target state="translated">Die Sichtbarkeit und der Zugriff von Typen und Membern soll so beschaffen sein, dass Typen in der Signatur eines Members sichtbar und zugreifbar sind, wann immer der Member selbst sichtbar und zugreifbar ist.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For example, a public method that is visible outside its assembly shall not have an argument whose type is visible only within the assembly.</source>
          <target state="translated">Zum Beispiel soll eine öffentliche Methode, die außerhalb der Assembly sichtbar ist, über kein Argument verfügen, dessen Typ nur innerhalb der Assembly sichtbar ist.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The visibility and accessibility of types composing an instantiated generic type used in the signature of any member shall be visible and accessible whenever the member itself is visible and accessible.</source>
          <target state="translated">Die Sichtbarkeit und der Zugriff von Typen, die einen instanziierten generischen Typ zusammensetzen, der in der Signatur eines beliebigen Members verwendet wird, soll sichtbar und zugreifbar sein, wenn der Member selbst sichtbar und zugreifbar ist.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For example, an instantiated generic type present in the signature of a member that is visible outside its assembly shall not have a generic argument whose type is visible only within the assembly.</source>
          <target state="translated">Zum Beispiel soll ein instanziierter generischer Typ, der in der Signatur eines außerhalb der Assembly sichtbaren Members vorhanden ist, über kein generisches Argument verfügen, dessen Typ nur innerhalb der Assembly sichtbar ist.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>12</source>
          <target state="translated">12</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Arrays<ept id="p1">](#arrays)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Arrays<ept id="p1">](#arrays)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Arrays shall have elements with a CLS-compliant type, and all dimensions of the array shall have lower bounds of zero.</source>
          <target state="translated">Arrays müssen über Elemente mit einem CLS-kompatiblen Typ verfügen, und die Untergrenze aller Dimensionen des Arrays muss Null sein.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Only the fact that an item is an array and the element type of the array shall be required to distinguish between overloads.</source>
          <target state="translated">Nur der Tatsache, dass es sich bei einem Element um ein Array handelt sowie der Elementtyp des Arrays muss zur Unterscheidung zwischen Überladungen ausreichen.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>When overloading is based on two or more array types the element types shall be named types.</source>
          <target state="translated">Wenn das Überladen auf Grundlage mindestens zweier Arraytypen erfolgt, muss es sich bei den Elementtypen um benannte Typen handeln.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attribute</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Attributes<ept id="p1">](#attributes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Attribute<ept id="p1">](#attributes)</ept></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Attributes shall be of type <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept>, or a type inheriting from it.</source>
          <target state="translated">Attribute müssen vom Typ <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept> sein oder von diesem erben.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>41</source>
          <target state="translated">41</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attribute</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Attributes<ept id="p1">](#attributes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Attribute<ept id="p1">](#attributes)</ept></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The CLS only allows a subset of the encodings of custom attributes.</source>
          <target state="translated">CLS gestattet nur eine Teilmenge der Codierungen benutzerdefinierter Attribute.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The only types that shall appear in these encodings are (see Partition IV): <bpt id="p1">[</bpt>System.Type<ept id="p1">](xref:System.Type)</ept>, <bpt id="p2">[</bpt>System.String<ept id="p2">](xref:System.String)</ept>, <bpt id="p3">[</bpt>System.Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>System.Boolean<ept id="p4">](xref:System.Boolean)</ept>, <bpt id="p5">[</bpt>System.Byte<ept id="p5">](xref:System.Byte)</ept>, <bpt id="p6">[</bpt>System.Int16<ept id="p6">](xref:System.Int16)</ept>, <bpt id="p7">[</bpt>System.Int32<ept id="p7">](xref:System.Int32)</ept>, <bpt id="p8">[</bpt>System.Int64<ept id="p8">](xref:System.Int64)</ept>, <bpt id="p9">[</bpt>System.Single<ept id="p9">](xref:System.Single)</ept>, <bpt id="p10">[</bpt>System.Double<ept id="p10">](xref:System.Double)</ept>, and any enumeration type based on a CLS-compliant base integer type.</source>
          <target state="translated">Die einzigen Typen, die in diesen Codierungen angezeigt werden sollen, sind (gemäß Partition IV): <bpt id="p1">[</bpt>System.Type<ept id="p1">](xref:System.Type)</ept>, <bpt id="p2">[</bpt>System.String<ept id="p2">](xref:System.String)</ept>, <bpt id="p3">[</bpt>System.Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>System.Boolean<ept id="p4">](xref:System.Boolean)</ept>, <bpt id="p5">[</bpt>System.Byte<ept id="p5">](xref:System.Byte)</ept>, <bpt id="p6">[</bpt>System.Int16<ept id="p6">](xref:System.Int16)</ept>, <bpt id="p7">[</bpt>System.Int32<ept id="p7">](xref:System.Int32)</ept>, <bpt id="p8">[</bpt>System.Int64<ept id="p8">](xref:System.Int64)</ept>, <bpt id="p9">[</bpt>System.Single<ept id="p9">](xref:System.Single)</ept>, <bpt id="p10">[</bpt>System.Double<ept id="p10">](xref:System.Double)</ept> und jeder Enumerationstyp basierend auf einem CLS-kompatiblen ganzzahligen Basistyp.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>34</source>
          <target state="translated">34</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attribute</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Attributes<ept id="p1">](#attributes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Attribute<ept id="p1">](#attributes)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The CLS does not allow publicly visible required modifiers (<ph id="ph1">`modreq`</ph>, see Partition II), but does allow optional modifiers (<ph id="ph2">`modopt`</ph>, see Partition II) it does not understand.</source>
          <target state="translated">Nach der CLS sind nicht öffentlich sichtbare erforderliche Modifizierer (<ph id="ph1">`modreq`</ph>, siehe Partition II) zulässig, allerdings sind optionale Modifizierer (<ph id="ph2">`modopt`</ph>, siehe Partition II), die sie nicht versteht, zulässig.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>35</source>
          <target state="translated">35</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Konstruktoren</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Constructors<ept id="p1">](#constructors)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Konstruktoren<ept id="p1">](#constructors)</ept></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>An object constructor shall call some instance constructor of its base class before any access occurs to inherited instance data.</source>
          <target state="translated">Ein Objektkonstruktor muss einen Instanzenkonstruktor seiner Basisklasse aufrufen, bevor ein Zugriff auf geerbte Instanzdaten erfolgt.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>(This does not apply to value types, which need not have constructors.)</source>
          <target state="translated">(Dies gilt nicht für Werttypen, die über keine Konstruktoren verfügen müssen.)</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>21</source>
          <target state="translated">21</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Konstruktoren</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Constructors<ept id="p1">](#constructors)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Konstruktoren<ept id="p1">](#constructors)</ept></target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>An object constructor shall not be called except as part of the creation of an object, and an object shall not be initialized twice.</source>
          <target state="translated">Ein Objektkonstruktor darf nicht aufgerufen werden, außer als Teil bei der Erstellung eines Objekts und ein Objekt darf nicht zweimal initialisiert werden.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>22</source>
          <target state="translated">22</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Enumerationen</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enumerations<ept id="p1">](#enumerations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Enumerationen<ept id="p1">](#enumerations)</ept></target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The underlying type of an enum shall be a built-in CLS integer type, the name of the field shall be "value__", and that field shall be marked <ph id="ph1">`RTSpecialName`</ph>.</source>
          <target state="translated">Der zugrunde liegende Typ einer Enumeration muss ein integrierter CLS-Ganzzahltyp sein, der Name des Felds muss "value__" lauten, und das Feld muss als <ph id="ph1">`RTSpecialName`</ph> gekennzeichnet sein.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>7</source>
          <target state="translated">7</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Enumerationen</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enumerations<ept id="p1">](#enumerations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Enumerationen<ept id="p1">](#enumerations)</ept></target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>There are two distinct kinds of enums, indicated by the presence or absence of the <bpt id="p1">[</bpt>System.FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> (see Partition IV Library) custom attribute.</source>
          <target state="translated">Es gibt zwei verschiedene Arten von Enumerationen, die aufgrund des Vorhandenseins oder Fehlens des benutzerdefinierten Attributs <bpt id="p1">[</bpt>System.FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> (gemäß Partition IV Library) angegeben werden.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>One represents named integer values; the other represents named bit flags that can be combined to generate an unnamed value.</source>
          <target state="translated">Eine stellt benannte ganzzahlige Werte dar, die Andere stellt benannte Bitflags dar, die zum Generieren eines unbenannten Werts kombiniert werden können.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The value of an <ph id="ph1">`enum`</ph> is not limited to the specified values.</source>
          <target state="translated">Der Wert einer <ph id="ph1">`enum`</ph> ist nicht auf die angegebenen Werte beschränkt.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>8</source>
          <target state="translated">8</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Enumerationen</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enumerations<ept id="p1">](#enumerations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Enumerationen<ept id="p1">](#enumerations)</ept></target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Literal static fields of an enum shall have the type of the enum itself.</source>
          <target state="translated">Literale statische Felder einer Enumeration müssen vom Typ der Enumeration selbst sein.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>9</source>
          <target state="translated">9</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Ereignisse</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Ereignisse<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The methods that implement an event shall be marked <ph id="ph1">`SpecialName`</ph> in the metadata.</source>
          <target state="translated">Die Methoden, die ein Ereignis implementieren, müssen in den Metadaten als <ph id="ph1">`SpecialName`</ph> gekennzeichnet sein.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>29</source>
          <target state="translated">29</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Ereignisse</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Ereignisse<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The accessibility of an event and of its accessors shall be identical.</source>
          <target state="translated">Der Zugriff eines Ereignisses und seiner Zugriffsmethoden muss identisch sein.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>30</source>
          <target state="translated">30</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Ereignisse</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Ereignisse<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`add`</ph> and <ph id="ph2">`remove`</ph> methods for an event shall both either be present or absent.</source>
          <target state="translated">Die <ph id="ph1">`add`</ph> und <ph id="ph2">`remove`</ph>-Methoden eines Ereignisses müssen entweder beide vorhanden oder beide nicht vorhanden sein.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>31</source>
          <target state="translated">31</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Ereignisse</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Ereignisse<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`add`</ph>and <ph id="ph2">`remove`</ph> methods for an event shall each take one parameter whose type defines the type of the event and that shall be derived from <bpt id="p1">[</bpt>System.Delegate<ept id="p1">](xref:System.Delegate)</ept>.</source>
          <target state="translated">Die <ph id="ph1">`add`</ph>- und <ph id="ph2">`remove`</ph>-Methoden eines Ereignisses müssen jeweils einen Parameter erhalten, dessen Typ den Ereignistyp definiert. Dieser Typ muss von <bpt id="p1">[</bpt>System.Delegate<ept id="p1">](xref:System.Delegate)</ept> abgeleitet sein.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>32</source>
          <target state="translated">32</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Ereignisse</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Ereignisse<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Events shall adhere to a specific naming pattern.</source>
          <target state="translated">Ereignisse müssen einem bestimmten Benennungsschema folgen.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The SpecialName attribute referred to in CLS rule 29 shall be ignored in appropriate name comparisons and shall adhere to identifier rules.</source>
          <target state="translated">Das SpecialName-Attribut, auf das in CLS-Regel 29 verwiesen wird, muss in den entsprechenden Namensvergleichen ignoriert werden und Bezeichnerregeln einhalten.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>33</source>
          <target state="translated">33</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Ausnahmen</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Exceptions<ept id="p1">](#exceptions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Ausnahmen<ept id="p1">](#exceptions)</ept></target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Objects that are thrown shall be of type <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept> or a type inheriting from it.</source>
          <target state="translated">Ausgelöste Objekte müssen vom Typ <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept> oder einem davon geerbten Typ sein.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Nonetheless, CLS-compliant methods are not required to block the propagation of other types of exceptions.</source>
          <target state="translated">Dennoch müssen CLS-kompatible Methoden die Weitergabe anderer Ausnahmetypen nicht blockieren.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>40</source>
          <target state="translated">40</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">Allgemein</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CLS compliance rules<ept id="p1">](#cls-compliance-rules)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>CLS-Kompatibilitätsregeln<ept id="p1">](#cls-compliance-rules)</ept></target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>CLS rules apply only to those parts of a type that are accessible or visible outsideof the defining assembly.</source>
          <target state="translated">CLS-Regeln betreffen nur die Teile eines Typs, deren Zugriff oder Sichtbarkeit außerhalb der definierenden Assembly liegen.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">Allgemein</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CLS compliance rules<ept id="p1">](#cls-compliance-rules)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>CLS-Kompatibilitätsregeln<ept id="p1">](#cls-compliance-rules)</ept></target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Members of non-CLS compliant types shall not be marked CLS-compliant.</source>
          <target state="translated">Member von Typen, die nicht CLS-kompatibel sind, dürfen nicht als CLS-kompatibel gekennzeichnet werden.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generika</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generische Typen und Member<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Nested types shall have at least as many generic parameters as the enclosing type.</source>
          <target state="translated">Geschachtelte Typen müssen mindestens so viele generische Parameter aufweisen wie der einschließende Typ.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Generic parameters in a nested type correspond by position to the generic parameters in its enclosing type.</source>
          <target state="translated">Die Position von generischen Parametern in einem geschachtelten Typ entspricht der Position der generischen Parameter im einschließenden Typ.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>42</source>
          <target state="translated">42</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generika</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generische Typen und Member<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The name of a generic type shall encode the number of type parameters declared on the non-nested type, or newly introduced to the type if nested, according to the rules defined above.</source>
          <target state="translated">Der Name eines generischen Typs muss die Anzahl von Typparametern, die auf dem nicht geschachtelten Typ deklariert oder neu in den Typ eingeführt werden, kodieren, wenn er entsprechend der oben definierten Regeln geschachtelt ist.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>43</source>
          <target state="translated">43</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generika</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generische Typen und Member<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>A generic type shall redeclare sufficient constraints to guarantee that any constraints on the base type, or interfaces would be satisfied by the generic type constraints.</source>
          <target state="translated">Ein generischer Typ muss genügend Einschränkungen neu deklarieren, um zu gewährleisten, dass alle Einschränkungen des Basistyps oder der Schnittstellen durch die Einschränkungen des generischen Typs erfüllt sein würden.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>44</source>
          <target state="translated">44</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generika</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generische Typen und Member<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Types used as constraints on generic parameters shall themselves be CLS-compliant.</source>
          <target state="translated">Als Einschränkungen für generische Parameter verwendete Typen müssen selbst CLS-kompatibel sein.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>45</source>
          <target state="translated">45</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generika</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generische Typen und Member<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The visibility and accessibility of members (including nested types) in an instantiated generic type shall be considered to be scoped to the specific instantiation rather than the generic type declaration as a whole.</source>
          <target state="translated">Es muss davon ausgegangen werden, dass die Sichtbarkeit und der Zugriff auf Member (einschließlich geschachtelter Typen) in einem instanziierten generischen Typ sich nicht auf die gesamte Deklaration des generischen Typs bezieht, sondern auf die spezifische Instanziierung.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Assuming this, the visibility and accessibility rules of CLS rule 12 still apply.</source>
          <target state="translated">Davon ausgehend gelten die Sichtbarkeits- und Zugriffsregeln der CLS-Regel 12 weiterhin.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>46</source>
          <target state="translated">46</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generika</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic types and members<ept id="p1">](#generic-types-and-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generische Typen und Member<ept id="p1">](#generic-types-and-members)</ept></target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For each abstract or virtual generic method, there shall be a default concrete (nonabstract) implementation</source>
          <target state="translated">Für jede abstrakte oder virtuell generische Methode muss es eine konkrete (nicht abstrakte) Standardimplementierung geben.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>47</source>
          <target state="translated">47</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Schnittstellen</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Schnittstellen<ept id="p1">](#interfaces)</ept></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>CLS-compliant interfaces shall not require the definition of non-CLS compliantmethods in order to implement them.</source>
          <target state="translated">Zum Implementieren von CLS-kompatiblen Schnittstellen darf keine Definition von nicht CLS-kompatiblen Methoden erforderlich sein.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Schnittstellen</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Schnittstellen<ept id="p1">](#interfaces)</ept></target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>CLS-compliant interfaces shall not define static methods, nor shall they define fields.</source>
          <target state="translated">CLS-kompatible Schnittstellen dürfen weder statische Methoden noch Felder definieren.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Mitglieder</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type members in general<ept id="p1">](#type-members-in-general)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typmember im Allgemeinen<ept id="p1">](#type-members-in-general)</ept></target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Global static fields and methods are not CLS-compliant.</source>
          <target state="translated">Globale static-Felder und Methoden sind nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>36</source>
          <target state="translated">36</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Mitglieder</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The value of a literal static is specified through the use of field initialization metadata.</source>
          <target state="translated">Der Wert eines literalen statischen Elements wird von der Verwendung von Feldinitialisierungsmetadaten angegeben.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>A CLS-compliant literal must have a value specified in field initialization metadata that is of exactly the same type as the literal (or of the underlying type, if that literal is an <ph id="ph1">`enum`</ph>).</source>
          <target state="translated">Ein CLS-kompatibles Literal muss über einen Wert verfügen, der in den Feldinitialisierungsmetadaten angegeben wird, der genau vom gleichen Typ wie das Literal ist (oder des zugrunde liegenden Typs, wenn dieses Literal <ph id="ph1">`enum`</ph> ist).</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>13</source>
          <target state="translated">13</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Mitglieder</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type members in general<ept id="p1">](#type-members-in-general)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typmember im Allgemeinen<ept id="p1">](#type-members-in-general)</ept></target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The vararg constraint is not part of the CLS, and the only calling convention supported by the CLS is the standard managed calling convention.</source>
          <target state="translated">Die vararg-Einschränkung ist nicht Teil der CLS, und die einzige Aufrufkonvention, die von der CLS unterstützt wird, ist die verwaltete Standardaufrufkonvention.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Naming conventions</source>
          <target state="translated">Namenskonventionen </target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Naming conventions<ept id="p1">](#naming-conventions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Namenskonventionen<ept id="p1">](#naming-conventions)</ept></target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Assemblies shall follow Annex 7 of Technical Report 15 of the Unicode Standard3.0 governing the set of characters permitted to start and be included in identifiers, available online at <bpt id="p1">[</bpt>Unicode Normalization Forms<ept id="p1">](http://www.unicode.org/unicode/reports/tr15/tr15-18.html)</ept>.</source>
          <target state="translated">Assemblys müssen Anhang 7 von Fachbericht 15 des Unicode Standard3.0 folgen, in dem der Satz von Zeichen geregelt wird, die am Anfang oder innerhalb von Bezeichnern enthalten sein dürfen. Er ist online unter <bpt id="p1">[</bpt>Unicode Normalization Forms<ept id="p1">](http://www.unicode.org/unicode/reports/tr15/tr15-18.html)</ept> (Unicode-Normalisierungsformen) verfügbar.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Identifiers shall be in the canonical format defined by Unicode Normalization Form C. For CLS purposes, two identifiersare the same if their lowercase mappings (as specified by the Unicode locale-insensitive, one-to-one lowercase mappings) are the same.</source>
          <target state="translated">Bezeichner müssen im kanonischen Format vorliegen, das durch die Unicode-Normalisierungsform C definiert wird. Im Sinne der CLS sind zwei Bezeichner gleich, wenn ihre kleingeschriebenen Zuordnungen (wie von den Gebietsschema-unabhängigen, klein geschriebenen 1:1-Unicodezuordnungen angegeben) gleich sind.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>That is, for two identifiers to be considered different under the CLS they shall differ in more than simply their case.</source>
          <target state="translated">Demnach müssen sich zwei Bezeichner in mehr als nur der Großschreibung unterscheiden, damit sie gemäß der CLS als unterschiedlich angesehen werden können.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>However, in order to override an inherited definition the CLI requires the precise encoding of the original declaration be used.</source>
          <target state="translated">Um jedoch eine geerbte Definition überschreiben zu können, erfordert die CLI die genaue Codierung der ursprünglichen Deklaration.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Überladen</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Naming conventions<ept id="p1">](#naming-conventions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Namenskonventionen<ept id="p1">](#naming-conventions)</ept></target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>All names introduced in a CLS-compliant scope shall be distinct independent of kind, except where the names are identical and resolved via overloading.</source>
          <target state="translated">Alle Namen, die in einem CLS-kompatiblen Bereich eingeführt werden, müssen in ihrer Art eindeutig unabhängig sein, außer bei identischen Namen, die durch Überladen aufgelöst werden.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>That is, while the CTS allows a single type to use the same name for a method and a field, the CLS does not.</source>
          <target state="translated">Während es bei CTS möglich ist, dass ein einzelner Typ denselben Namen für eine Methode und ein Feld verwendet, ist dies bei CLS demnach unmöglich.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="translated">5</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Überladen</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Naming conventions<ept id="p1">](#naming-conventions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Namenskonventionen<ept id="p1">](#naming-conventions)</ept></target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Fields and nested types shall be distinct by identifier comparison alone, eventhough the CTS allows distinct signatures to be distinguished.</source>
          <target state="translated">Felder und geschachtelte Typen müssen allein durch Vergleich des Bezeichners zu unterscheiden sein, auch wenn bei CTS verschiedene Signaturen unterschieden werden können.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events that have the same name (by identifier comparison) shall differ by more than just the return type,except as specified in CLS Rule 39</source>
          <target state="translated">Methoden, Eigenschaften und Ereignisse mit demselben Namen (nach Bezeichnervergleich) müssen sich durch mehr als nur den Rückgabetyp unterscheiden (außer wie in CLS-Regel 39 angegeben).</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>6</source>
          <target state="translated">6</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Überladen</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Overloads<ept id="p1">](#overloads)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Überladungen<ept id="p1">](#overloads)</ept></target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Only properties and methods can be overloaded.</source>
          <target state="translated">Nur Eigenschaften und Methoden können überladen werden.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>37</source>
          <target state="translated">37</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Überladen</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Overloads<ept id="p1">](#overloads)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Überladungen<ept id="p1">](#overloads)</ept></target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Properties and methods can be overloaded based only on the number and types of their parameters, except the conversion operators named <ph id="ph1">`op_Implicit`</ph> and <ph id="ph2">`op_Explicit`</ph>, which can also be overloaded based on their return type.</source>
          <target state="translated">Eigenschaften und Methoden können allein basierend auf der Anzahl und den Typen ihrer Parameter überladen werden, außer den Konvertierungsoperatoren <ph id="ph1">`op_Implicit`</ph> und <ph id="ph2">`op_Explicit`</ph>, die auch auf Grundlage des Rückgabetyps überladen werden können.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>38</source>
          <target state="translated">38</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Überladen</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>If two or more CLS-compliant methods declared in a type have the same nameand, for a specific set of type instantiations, they have the same parameter and return types, then all these methods shall be semantically equivalent at those type instantiations.</source>
          <target state="translated">Wenn mindestens zwei CLS-kompatible Methoden, die in einem Typ deklariert werden, den gleichen Namen und für einen bestimmten Satz von Typinstanziierungen die gleichen Parameter und Rückgabetypen nutzen, dann müssen alle diese Methoden bei diesen Typinstanziierungen semantisch gleichwertig sein.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>48</source>
          <target state="translated">48</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Eigenschaften</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Eigenschaften<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The methods that implement the getter and setter methods of a property shall be marked <ph id="ph1">`SpecialName`</ph> in the metadata.</source>
          <target state="translated">Die Methoden, mit denen die Getter- und die Setter-Methode einer Eigenschaft implementiert werden, müssen in den Metadaten mit <ph id="ph1">`SpecialName`</ph> markiert werden.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>24</source>
          <target state="translated">24</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Eigenschaften</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Eigenschaften<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>A property’s accessors shall all be static, all be virtual, or all be instance.</source>
          <target state="translated">Die Zugriffsmethoden einer Eigenschaft müssen alle „static“, alle „virtual“ oder alle „instance“ sein.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>26</source>
          <target state="translated">26</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Eigenschaften</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Eigenschaften<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The type of a property shall be the return type of the getter and the type of the last argument of the setter.</source>
          <target state="translated">Der Typ einer Eigenschaft muss dem Rückgabetyp der Getter-Methode und dem Typ des letzten Arguments der Setter-Methode entsprechen.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The types of the parameters of the property shall be the types of the parameters to the getter and the types of all but the final parameter of the setter.</source>
          <target state="translated">Die Parametertypen der Eigenschaft müssen den Parametertypen der Getter-Methode und, ausgenommen dem Letzten, allen Parametertypen der Setter-Methode entsprechen.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>All of these types shall be CLS-compliant, and shall not be managed pointers (i.e., shall not be passed by reference).</source>
          <target state="translated">Diese Typen müssen CLS-kompatibel sein und dürfen keine verwalteten Zeiger sein (d. h., sie dürfen nicht als Verweise übergeben werden).</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>27</source>
          <target state="translated">27</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Eigenschaften</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Eigenschaften<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Properties shall adhere to a specific naming pattern.</source>
          <target state="translated">Eigenschaften müssen einem bestimmten Benennungsschema folgen.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`SpecialName`</ph> attribute referred to in CLS rule 24 shall be ignored in appropriate name comparisons and shall adhere to identifier rules.</source>
          <target state="translated">Das <ph id="ph1">`SpecialName`</ph>-Attribut, auf das in CLS-Regel 24 verwiesen wird, muss in den entsprechenden Namensvergleichen ignoriert werden und Bezeichnerregeln einhalten.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>A property shall have a getter method, a setter method, or both.</source>
          <target state="translated">Eine Eigenschaft verfügt über eine Getter-Methode, eine Setter-Methode oder beide.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>28</source>
          <target state="translated">28</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Type conversion</source>
          <target state="translated">Typkonvertierung</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type conversion<ept id="p1">](#type-conversion)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typkonvertierung<ept id="p1">](#type-conversion)</ept></target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>If either op_Implicit or op_Explicit is provided, an alternate means of providing the coercion shall be provided.</source>
          <target state="translated">Wenn entweder op_Implicit oder op_Explicit bereitgestellt wird, muss eine alternative Möglichkeit für die Umwandlung bereitgestellt werden.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>39</source>
          <target state="translated">39</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Typen</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typen und Typmembersignaturen<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Boxed value types are not CLS-compliant.</source>
          <target state="translated">Geschachtelte Werttypen sind nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Typen</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typen und Typmembersignaturen<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>All types appearing in a signature shall be CLS-compliant.</source>
          <target state="translated">Alle Typen, die in einer Signatur erscheinen, müssen CLS-kompatibel sein.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>All types composing an instantiated generic type shall be CLS-compliant.</source>
          <target state="translated">Alle Typen, die einen instanziierten generischen Typ erstellen, müssen CLS-kompatibel sein.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>11</source>
          <target state="translated">11</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Typen</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typen und Typmembersignaturen<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Typed references are not CLS-compliant.</source>
          <target state="translated">Typisierte Verweise sind nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Typen</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typen und Typmembersignaturen<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Unmanaged pointer types are not CLS-compliant.</source>
          <target state="translated">Nicht verwaltete Zeigertypen sind nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Typen</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typen und Typmembersignaturen<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>CLS-compliant classes, value types, and interfaces shall not require the implementation of non-CLS-compliant members</source>
          <target state="translated">CLS-kompatible Klassen, Werttypen und Schnittstellen dürfen nicht die Implementierung nicht CLS-kompatibler Member erfordern.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>20</source>
          <target state="translated">20</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Typen</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types and type member signatures<ept id="p1">](#types-and-type-member-signatures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typen und Typmembersignaturen<ept id="p1">](#types-and-type-member-signatures)</ept></target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> is CLS-compliant.</source>
          <target state="translated"><bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> ist CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Any other CLS-compliant class shall inherit from a CLS-compliant class.</source>
          <target state="translated">Jede andere CLS-kompatible Klasse muss von einer CLS-kompatiblen Klasse erben.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>23</source>
          <target state="translated">23</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Types and type member signatures</source>
          <target state="translated">Typen und Typmembersignaturen</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> type is CLS-compliant and is the base type of all object types in the .NET Framework type system.</source>
          <target state="translated">Der <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>-Typ ist CLS-kompatibel, und er ist der Basistyp aller Objekttypen im .NET Framework-Typsystem.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Inheritance in the .NET Framework is either implicit (for example, the <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> class implicitly inherits from the <ph id="ph1">`Object`</ph> class) or explicit (for example, the <bpt id="p2">[</bpt>CultureNotFoundException<ept id="p2">](xref:System.Globalization.CultureNotFoundException)</ept> class explicitly inherits from the <bpt id="p3">[</bpt>ArgumentException<ept id="p3">](xref:System.ArgumentException)</ept> class, which explicitly inherits from the <bpt id="p4">[</bpt>Exception<ept id="p4">](xref:System.Exception)</ept> class.</source>
          <target state="translated">Vererbung erfolgt im .NET Framework entweder implizit (zum Beispiel erbt die <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept>-Klasse implizit von der <ph id="ph1">`Object`</ph>-Klasse) oder explizit (zum Beispiel erbt die <bpt id="p2">[</bpt>CultureNotFoundException<ept id="p2">](xref:System.Globalization.CultureNotFoundException)</ept>-Klasse explizit von der <bpt id="p3">[</bpt>ArgumentException<ept id="p3">](xref:System.ArgumentException)</ept>-Klasse, die explizit von der <bpt id="p4">[</bpt>Exception<ept id="p4">](xref:System.Exception)</ept>-Klasse erbt).</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>For a derived type to be CLS compliant, its base type must also be CLS-compliant.</source>
          <target state="translated">Damit ein abgeleiteter Typ CLS-kompatibel ist, muss auch der Basistyp CLS-kompatibel sein.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The following example shows a derived type whose base type is not CLS-compliant.</source>
          <target state="translated">Im folgenden Beispiel wird ein abgeleiteter Typ veranschaulicht, dessen Basistyp nicht CLS-kompatibel ist.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>It defines a base <ph id="ph1">`Counter`</ph> class that uses an unsigned 32-bit integer as a counter.</source>
          <target state="translated">Es wird eine <ph id="ph1">`Counter`</ph>-Basisklasse definiert, die eine ganze Zahl ohne Vorzeichen mit einer Länge von 32 Bit als Indikator verwendet.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Because the class provides counter functionality by wrapping an unsigned integer, the class is marked as non-CLS-compliant.</source>
          <target state="translated">Da die Klasse Gegenfunktionalität bereitstellt, indem eine ganze Zahl ohne Vorzeichen umgebrochen wird, wird die Klasse als nicht CLS-kompatibel gekennzeichnet.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>As a result, a derived class, <ph id="ph1">`NonZeroCounter`</ph>, is also not CLS-compliant.</source>
          <target state="translated">Daher ist eine abgeleitete Klasse, <ph id="ph1">`NonZeroCounter`</ph>, auch nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>All types that appear in member signatures, including a method's return type or a property type, must be CLS-compliant.</source>
          <target state="translated">Alle in den Membersignaturen angezeigten Typen, einschließlich des Rückgabetyps oder des Eigenschaftentyps einer Methode, müssen CLS-kompatibel sein.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>In addition, for generic types:</source>
          <target state="translated">Außerdem ist für generische Typen Folgendes erforderlich:</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>All types that compose an instantiated generic type must be CLS-compliant.</source>
          <target state="translated">Alle Typen, die einen instanziierten generischen Typ zusammensetzen, müssen CLS-kompatibel sein.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>All types used as constraints on generic parameters must be CLS-compliant.</source>
          <target state="translated">Alle als Einschränkungen für generische Parameter verwendeten Typen müssen CLS-kompatibel sein.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>The .NET <bpt id="p1">[</bpt>common type system<ept id="p1">](common-type-system.md)</ept> includes a number of built-in types that are supported directly by the common language runtime and are specially encoded in an assembly's metadata.</source>
          <target state="translated">Das <bpt id="p1">[</bpt>allgemeine Typsystem<ept id="p1">](common-type-system.md)</ept> von .NET enthält verschiedene integrierte Datentypen, die direkt von der Common Language Runtime unterstützt werden und insbesondere in den Metadaten einer Assembly codiert werden.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Of these intrinsic types, the types listed in the following table are CLS-compliant.</source>
          <target state="translated">Von diesen systeminternen Typen sind die in der folgenden Tabelle aufgeführten Typen CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>CLS-compliant type</source>
          <target state="translated">CLS-kompatibler Typ</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept></target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>8-bit unsigned integer</source>
          <target state="translated">Ganze 8-Bit-Zahl ohne Vorzeichen</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept></target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>16-bit signed integer</source>
          <target state="translated">Ganze 16-Bit-Zahl mit Vorzeichen</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept></target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>32-bit signed integer</source>
          <target state="translated">32-Bit-Ganzzahl mit Vorzeichen</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>64-bit signed integer</source>
          <target state="translated">64-Bit-Ganzzahl mit Vorzeichen</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Single<ept id="p1">](xref:System.Single)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Single<ept id="p1">](xref:System.Single)</ept></target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Single-precision floating-point value</source>
          <target state="translated">Gleitkommawert mit einfacher Genauigkeit</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept></target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Double-precision floating-point value</source>
          <target state="translated">Gleitkommawert mit doppelter Genauigkeit</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept></target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>true or false value type</source>
          <target state="translated">TRUE- oder FALSE-Werttyp</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept></target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>UTF-16 encoded code unit</source>
          <target state="translated">UTF-16-codierte Codeeinheit</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept></target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Non-floating-point decimal number</source>
          <target state="translated">Dezimalzahl ohne Gleitkomma</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IntPtr<ept id="p1">](xref:System.IntPtr)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IntPtr<ept id="p1">](xref:System.IntPtr)</ept></target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Pointer or handle of a platform-defined size</source>
          <target state="translated">Zeiger oder Handle einer Plattform-definierten Größe</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept></target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Collection of zero, one, or more Char objects</source>
          <target state="translated">Sammlung von null, einem oder mehreren Char-Objekten</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>The intrinsic types listed in the following table are not CLS-Compliant.</source>
          <target state="translated">Die in der folgenden Tabelle aufgeführten systeminternen Typen sind nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Non-compliant type</source>
          <target state="translated">Nicht kompatibler Typ</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>CLS-compliant alternative</source>
          <target state="translated">CLS-kompatible Alternative</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SByte<ept id="p1">](xref:System.SByte)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>SByte<ept id="p1">](xref:System.SByte)</ept></target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>8-bit signed integer data type</source>
          <target state="translated">Ganzzahliger 8-Bit-Datentyp mit Vorzeichen</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept></target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt16<ept id="p1">](xref:System.UInt16)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UInt16<ept id="p1">](xref:System.UInt16)</ept></target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>16-bit unsigned integer</source>
          <target state="translated">16-Bit-Ganzzahl ohne Vorzeichen</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept></target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept></target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>32-bit unsigned integer</source>
          <target state="translated">32-Bit-Ganzzahl ohne Vorzeichen</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInt64<ept id="p1">](xref:System.UInt64)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UInt64<ept id="p1">](xref:System.UInt64)</ept></target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>64-bit unsigned integer</source>
          <target state="translated">64-Bit-Ganzzahl ohne Vorzeichen</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept> (may overflow), <bpt id="p2">[</bpt>BigInteger<ept id="p2">](xref:System.Numerics.BigInteger)</ept>, or <bpt id="p3">[</bpt>Double<ept id="p3">](xref:System.Double)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept> (kann überlaufen), <bpt id="p2">[</bpt>BigInteger<ept id="p2">](xref:System.Numerics.BigInteger)</ept> oder <bpt id="p3">[</bpt>Double<ept id="p3">](xref:System.Double)</ept></target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UIntPtr<ept id="p1">](xref:System.UIntPtr)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UIntPtr<ept id="p1">](xref:System.UIntPtr)</ept></target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Unsigned pointer or handle</source>
          <target state="translated">Zeiger ohne Vorzeichen oder Handle</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IntPtr<ept id="p1">](xref:System.IntPtr)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IntPtr<ept id="p1">](xref:System.IntPtr)</ept></target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>The .NET Framework Class Library or any other class library may include other types that aren't CLS-compliant; for example:</source>
          <target state="translated">Die .NET Framework-Klassenbibliothek oder jede andere Klassenbibliothek schließen möglicherweise andere nicht CLS-kompatible Typen ein, zum Beispiel:</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Boxed value types.</source>
          <target state="translated">Geschachtelte Werttypen</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>The following C# example creates a class that has a public property of type <ph id="ph1">`int`</ph><bpt id="p1">*</bpt> named <ph id="ph2">`Value`</ph>. Because an <ph id="ph3">`int`</ph><ept id="p1">*</ept> is a boxed value type, the compiler flags it as non-CLS-compliant.</source>
          <target state="translated">Im folgenden C#-Beispiel wird eine Klasse erstellt, die über eine öffentliche Eigenschaft des Typs <ph id="ph1">`int`</ph><bpt id="p1">*</bpt> namens <ph id="ph2">`Value`</ph> verfügt. Da <ph id="ph3">`int`</ph><ept id="p1">*</ept> ein geschachtelter Werttyp ist, markiert der Compiler ihn als nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>Typed references, which are special constructs that contain a reference to an object and a reference to a type.</source>
          <target state="translated">Typisierte Verweise, die spezielle Konstrukte sind, in denen ein Verweis auf ein Objekt und ein Verweis auf einen Typ enthalten sind.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>If a type is not CLS-compliant, you should apply the <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> attribute with an <bpt id="p2">*</bpt>isCompliant<ept id="p2">*</ept> parameter with a value of <ph id="ph1">`false`</ph> to it.</source>
          <target state="translated">Wenn ein Typ nicht CLS-kompatibel ist, sollten Sie das Attribut <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> mit einem <bpt id="p2">*</bpt>isCompliant<ept id="p2">*</ept>-Parameter mit einem Wert von <ph id="ph1">`false`</ph> anwenden.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>CLSCompliantAttribute attribute<ept id="p1">](#the-clscompliantattribute-attribute)</ept> section.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt zum <bpt id="p1">[</bpt>CLSCompliantAttribute-Attribut<ept id="p1">](#the-clscompliantattribute-attribute)</ept>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>The following example illustrates the problem of CLS compliance in a method signature and in generic type instantiation.</source>
          <target state="translated">Im folgenden Beispiel wird das Problem der CLS-Kompatibilität in einer Methodensignatur und in der Instanziierung des generischen Typs veranschaulicht.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>It defines an <ph id="ph1">`InvoiceItem`</ph> class with a property of type <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept>, a property of type <bpt id="p2">[</bpt>Nullable(Of UInt32)<ept id="p2">](xref:System.Nullable%601)</ept>, and a constructor with parameters of type <ph id="ph2">`UInt32`</ph> and <ph id="ph3">`Nullable(Of UInt32)`</ph>.</source>
          <target state="translated">Dabei wird eine <ph id="ph1">`InvoiceItem`</ph>-Klasse mit einer Eigenschaft vom Typ <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept>, einer Eigenschaft vom Typ <bpt id="p2">[</bpt>Nullable(Of UInt32)<ept id="p2">](xref:System.Nullable%601)</ept> und einem Konstruktor mit Parametern vom Typ <ph id="ph2">`UInt32`</ph> und <ph id="ph3">`Nullable(Of UInt32)`</ph> definiert.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>You get four compiler warnings when you try to compile this example.</source>
          <target state="translated">Sie erhalten vier Compilerwarnungen, wenn Sie versuchen, das Beispiel zu kompilieren.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>To eliminate the compiler warnings, replace the non-CLS-compliant types in the <ph id="ph1">`InvoiceItem`</ph> public interface with compliant types:</source>
          <target state="translated">Um die Compilerwarnungen auszuschließen, ersetzen Sie die nicht CLS-kompatiblen Typen in der öffentlichen <ph id="ph1">`InvoiceItem`</ph>-Schnittstelle durch kompatible Typen:</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>In addition to the specific types listed, some categories of types are not CLS compliant.</source>
          <target state="translated">Zusätzlich zu bestimmten aufgeführten Typen sind einige Typenkategorien ebenfalls nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>These include unmanaged pointer types and function pointer types.</source>
          <target state="translated">Diese schließen nicht verwaltete Zeigertypen und Funktionszeigertypen ein.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>The following example generates a compiler warning because it uses a pointer to an integer to create an array of integers.</source>
          <target state="translated">Im folgenden Beispiel wird eine Compilerwarnung erzeugt, da ein Zeiger auf eine ganze Zahl verwendet wird, um ein Array ganzer Zahlen zu erstellen.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>For CLS-compliant abstract classes (that is, classes marked as <ph id="ph1">`abstract`</ph> in C#), all members of the class must also be CLS-compliant.</source>
          <target state="translated">Für CLS-kompatible abstrakte Klassen (also Klassen, die in C# als <ph id="ph1">`abstract`</ph> markiert sind), müssen alle Member der Klasse auch CLS-kompatibel sein.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Naming conventions</source>
          <target state="translated">Namenskonventionen </target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>Because some programming languages are case-insensitive, identifiers (such as the names of namespaces, types, and members) must differ by more than case.</source>
          <target state="translated">Da bei einigen Programmiersprachen die Groß- und Kleinschreibung nicht beachtet werden muss, müssen Bezeichner (wie die Namen von Namespaces, Typen und Membern) durch mehr als die Groß-/Kleinschreibung unterschieden werden.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>Two identifiers are considered equivalent if their lowercase mappings are the same.</source>
          <target state="translated">Zwei Bezeichner gelten als äquivalent, wenn ihre kleingeschriebenen Zuordnungen identisch sind.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The following C# example defines two public classes, <ph id="ph1">`Person`</ph> and <ph id="ph2">`person`</ph>.</source>
          <target state="translated">Im folgenden C#-Beispiel werden zwei öffentliche Klassen definiert: <ph id="ph1">`Person`</ph> und <ph id="ph2">`person`</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Because they differ only by case, the C# compiler flags them as not CLS-compliant.</source>
          <target state="translated">Da sie sich nur durch die Groß-/Kleinschreibung unterscheiden, markiert der C#-Compiler sie als nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Programming language identifiers, such as the names of namespaces, types, and members, must conform to the <bpt id="p1">[</bpt>Unicode Standard 3.0, Technical Report 15, Annex 7<ept id="p1">](http://www.unicode.org/reports/tr15/tr15-18.html)</ept>.</source>
          <target state="translated">Programmiersprachenbezeichner, wie die Namen von Namespaces, Typen und Membern, müssen dem <bpt id="p1">[</bpt>Unicode-Standard 3.0, Fachbericht 15, Anhang 7<ept id="p1">](http://www.unicode.org/reports/tr15/tr15-18.html)</ept> entsprechen.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>This means that:</source>
          <target state="translated">Dies bedeutet Folgendes:</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>The first character of an identifier can be any Unicode uppercase letter, lowercase letter, title case letter, modifier letter, other letter, or letter number.</source>
          <target state="translated">Das erste Zeichen eines Bezeichners kann jeder Unicode-Großbuchstabe, Kleinbuchstabe, großer Anfangsbuchstabe, Modifiziererbuchstabe, anderer Buchstabe oder jede Buchstabenzahl sein.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>For information on Unicode character categories, see the <bpt id="p1">[</bpt>System.Globalization.UnicodeCategory<ept id="p1">](xref:System.Globalization.UnicodeCategory)</ept> enumeration.</source>
          <target state="translated">Informationen zu Unicode-Zeichenkategorien finden Sie unter der <bpt id="p1">[</bpt>System.Globalization.UnicodeCategory<ept id="p1">](xref:System.Globalization.UnicodeCategory)</ept>-Enumeration.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>Subsequent characters can be from any of the categories as the first character, and can also include non-spacing marks, spacing combining marks, decimal numbers, connector punctuations, and formatting codes.</source>
          <target state="translated">Nachfolgende Zeichen können aus einer der Kategorien wie das erste Zeichen stammen, und sie können auch Markierungen ohne Zwischenraum, Sperrmarkierungen, Dezimalwerte, Connectorinterpunktionen und Formatierungscodes umfassen.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>Before you compare identifiers, you should filter out formatting codes and convert the identifiers to Unicode Normalization Form C, because a single character can be represented by multiple UTF-16-encoded code units.</source>
          <target state="translated">Bevor Sie Bezeichner vergleichen, sollten Sie Formatierungscodes herausfiltern und die Bezeichner in die Unicode-Normalisierungsform C konvertieren, da ein einzelnes Zeichen durch mehrere UTF-16-codierte Codeeinheiten dargestellt werden kann.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>Character sequences that produce the same code units in Unicode Normalization Form C are not CLS-compliant.</source>
          <target state="translated">Zeichensequenzen, die die gleichen Codeeinheiten in der Unicode-Normalisierungsform C erzeugen, sind nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>The following example defines a property named <ph id="ph1">`Å`</ph>, which consists of the character ANGSTROM SIGN (U+212B), and a second property named <ph id="ph2">`Å`</ph> which consists of the character LATIN CAPITAL LETTER A WITH RING ABOVE (U+00C5).</source>
          <target state="translated">Im folgenden Beispiel werden zwei Eigenschaften definiert: eine namens <ph id="ph1">`Å`</ph>, die aus dem ÅNGSTRÖM-ZEICHEN (U+212B) besteht, und eine zweite namens <ph id="ph2">`Å`</ph>, die aus dem Zeichen LATEINISCHER GROSSBUCHSTABE A MIT RING OBEN (U+00C5) besteht.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>The C# compiler flags the source code as non-CLS-compliant.</source>
          <target state="translated">Der C#-Compiler kennzeichnet den Quellcode als nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Member names within a particular scope (such as the namespaces within an assembly, the types within a namespace, or the members within a type) must be unique except for names that are resolved through overloading.</source>
          <target state="translated">Membernamen innerhalb eines bestimmten Bereichs (wie den Namespaces innerhalb einer Assembly, den Typen in einem Namespace oder den Membern innerhalb eines Typs) müssen eindeutig sein, abgesehen von Namen, die durch Überladen aufgelöst werden.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>This requirement is more stringent than that of the common type system, which allows multiple members within a scope to have identical names as long as they are different kinds of members (for example, one is a method and one is a field).</source>
          <target state="translated">Diese Anforderung ist zwingender als die des allgemeinen Typsystems, bei dem mehrere Member innerhalb eines Bereichs über identische Namen verfügen dürfen, solange es unterschiedliche Arten von Membern sind (zum Beispiel eine Methode und ein Feld).</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>In particular, for type members:</source>
          <target state="translated">Insbesondere für Typmember:</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Fields and nested types are distinguished by name alone.</source>
          <target state="translated">Felder und geschachtelte Typen werden allein nach Namen unterschieden.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events that have the same name must differ by more than just return type.</source>
          <target state="translated">Methoden, Eigenschaften und Ereignisse mit demselben Namen müssen sich durch mehr als nur den Rückgabetyp unterscheiden.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>The following example illustrates the requirement that member names must be unique within their scope.</source>
          <target state="translated">Im folgenden Beispiel wird die Anforderung veranschaulicht, dass Membernamen innerhalb des Bereichs eindeutig sein müssen.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>It defines a class named <ph id="ph1">`Converter`</ph> that includes four members named <ph id="ph2">`Conversion`</ph>.</source>
          <target state="translated">Es wird eine Klasse namens <ph id="ph1">`Converter`</ph> definiert, die vier Member namens <ph id="ph2">`Conversion`</ph> umfasst.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Three are methods, and one is a property.</source>
          <target state="translated">Drei Methoden und eine Eigenschaft.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>The method that includes an <ph id="ph1">`Int64`</ph> parameter is uniquely named, but the two methods with an <ph id="ph2">`Int32`</ph> parameter are not, because return value is not considered a part of a member's signature.</source>
          <target state="translated">Die Methode, die einen Parameter <ph id="ph1">`Int64`</ph> umfasst, hat einen eindeutigen Namen, doch die beiden Methoden mit einem <ph id="ph2">`Int32`</ph>-Parameter sind nicht eindeutig, da der Rückgabewert nicht als ein Teil der Signatur eines Members gültig ist.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Conversion`</ph> property also violates this requirement, because properties cannot have the same name as overloaded methods.</source>
          <target state="translated">Die <ph id="ph1">`Conversion`</ph>- Eigenschaft verstößt auch gegen diese Anforderung, da Eigenschaften nicht den gleichen Namen wie überladene Methoden besitzen dürfen.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Individual languages include unique keywords, so languages that target the common language runtime must also provide some mechanism for referencing identifiers (such as type names) that coincide with keywords.</source>
          <target state="translated">Einzelne Sprachen enthalten eindeutige Schlüsselwörter, sodass Sprachen für die Common Language Runtime einen Mechanismus zum Verweisen auf Bezeichner (z. B. Typnamen) bereitstellen müssen, die mit den Schlüsselwörtern übereinstimmen.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`case`</ph> is a keyword in both C# and Visual Basic.</source>
          <target state="translated">Beispielsweise ist <ph id="ph1">`case`</ph> ein Schlüsselwort in C# und Visual Basic.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>However, the following Visual Basic example is able to disambiguate a class named <ph id="ph1">`case`</ph> from the <ph id="ph2">`case`</ph> keyword by using opening and closing braces.</source>
          <target state="translated">Im folgenden Visual Basic-Beispiel wird eine Klasse namens <ph id="ph1">`case`</ph> eindeutig vom <ph id="ph2">`case`</ph>-Schlüsselwort unterschieden, indem öffnende und schließende geschweifte Klammern verwendet werden.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>Otherwise, the example would produce the error message, "Keyword is not valid as an identifier," and fail to compile.</source>
          <target state="translated">Andernfalls würde in dem Beispiel die folgende Fehlermeldung erzeugt: "Das Schlüsselwort ist kein gültiger Bezeichner", und der Code könnte nicht kompiliert werden.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>The following C# example is able to instantiate the <ph id="ph1">`case`</ph> class by using the <ph id="ph2">@</ph> symbol to disambiguate the identifier from the language keyword.</source>
          <target state="translated">Im folgenden C#-Beispiel kann die <ph id="ph1">`case`</ph>-Klasse instanziiert werden, indem das <ph id="ph2">@</ph> Symbol verwendet wird, um den Bezeichner eindeutig vom Schlüsselwort zu unterscheiden.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>Without it, the C# compiler would display two error messages, "Type expected" and "Invalid expression term 'case'."</source>
          <target state="translated">Ohne dieses Zeichen würde der C#-Compiler zwei Fehlermeldungen anzeigen:"Typ erwartet" und "Ungültiger Ausdruck 'case'".</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>Type conversion</source>
          <target state="translated">Typkonvertierung</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>The Common Language Specification defines two conversion operators:</source>
          <target state="translated">In der Common Language Specification werden zwei Konvertierungsoperatoren definiert:</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`op_Implicit`</ph>, which is used for widening conversions that do not result in loss of data or precision.</source>
          <target state="translated"><ph id="ph1">`op_Implicit`</ph>, das für Erweiterungskonvertierungen verwendet wird, die zu keinem Datenverlust oder Genauigkeitsverlust führen.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept> structure includes an overloaded <ph id="ph1">`op_Implicit`</ph> operator to convert values of integral types and <bpt id="p2">[</bpt>Char<ept id="p2">](xref:System.Char)</ept> values to <ph id="ph2">`Decimal`</ph> values.</source>
          <target state="translated">Zum Beispiel umfasst die <bpt id="p1">[</bpt>Decimal<ept id="p1">](xref:System.Decimal)</ept>-Struktur einen überladenen <ph id="ph1">`op_Implicit`</ph>-Operator, um Werte integraler Typen und <bpt id="p2">[</bpt>Char<ept id="p2">](xref:System.Char)</ept>-Werte in <ph id="ph2">`Decimal`</ph>-Werte zu konvertieren.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`op_Explicit`</ph>, which is used for narrowing conversions that can result in loss of magnitude (a value is converted to a value that has a smaller range) or precision.</source>
          <target state="translated"><ph id="ph1">`op_Explicit`</ph>, der für einschränkende Konvertierungen verwendet wird, die zu Größenverlusten (ein Wert wird in einen Wert konvertiert, der über einen kleineren Bereich verfügt) bzw. zu Verlusten der Genauigkeit führen können.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">`Decimal`</ph> structure includes an overloaded <ph id="ph2">`op_Explicit`</ph> operator to convert <bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept> and <bpt id="p2">[</bpt>Single<ept id="p2">](xref:System.Single)</ept> values to <ph id="ph3">`Decimal`</ph> and to convert <ph id="ph4">`Decimal`</ph> values to integral values, <ph id="ph5">`Double`</ph>, <ph id="ph6">`Single`</ph>, and <ph id="ph7">`Char`</ph>.</source>
          <target state="translated">Zum Beispiel umfasst die <ph id="ph1">`Decimal`</ph>-Struktur einen überladenen <ph id="ph2">`op_Explicit`</ph>-Operator, um den <bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept>-Wert und den <bpt id="p2">[</bpt>Single<ept id="p2">](xref:System.Single)</ept>-Wert in <ph id="ph3">`Decimal`</ph> zu konvertieren und die <ph id="ph4">`Decimal`</ph>-Werte in integrale Werte, <ph id="ph5">`Double`</ph>, <ph id="ph6">`Single`</ph> und <ph id="ph7">`Char`</ph> zu konvertieren.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>However, not all languages support operator overloading or the definition of custom operators.</source>
          <target state="translated">Allerdings wird Operatorüberladung oder die Definition benutzerdefinierter Operatoren nicht von allen Sprachen unterstützt.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>If you choose to implement these conversion operators, you should also provide an alternate way to perform the conversion.</source>
          <target state="translated">Wenn Sie diese Konvertierungsoperatoren implementieren, sollten Sie eine alternative Methode zum Ausführen der Konvertierung bereitstellen.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>We recommend that you provide <ph id="ph1">`From`</ph>Xxx and <ph id="ph2">`To`</ph>Xxx methods.</source>
          <target state="translated">Es wird empfohlen, <ph id="ph1">`From`</ph>Xxx- und <ph id="ph2">`To`</ph>Xxx-Methoden bereitzustellen.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>The following example defines CLS-compliant implicit and explicit conversions.</source>
          <target state="translated">Im folgenden Beispiel werden CLS-kompatible implizite und explizite Konvertierungen definiert.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>It creates a <ph id="ph1">`UDouble`</ph>class that represents an signed double-precision, floating-point number.</source>
          <target state="translated">Es wird eine <ph id="ph1">`UDouble`</ph>-Klasse erstellt, die eine Gleitkommazahl mit doppelter Genauigkeit und Vorzeichen darstellt.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>It provides for implicit conversions from <ph id="ph1">`UDouble`</ph> to <ph id="ph2">`Double`</ph> and for explicit conversions from <ph id="ph3">`UDouble`</ph> to <ph id="ph4">`Single`</ph>, <ph id="ph5">`Double`</ph> to <ph id="ph6">`UDouble`</ph>, and <ph id="ph7">`Single`</ph> to <ph id="ph8">`UDouble`</ph>.</source>
          <target state="translated">Implizite Konvertierungen aus <ph id="ph1">`UDouble`</ph> in <ph id="ph2">`Double`</ph> und explizite Konvertierungen aus <ph id="ph3">`UDouble`</ph> in <ph id="ph4">`Single`</ph>, aus <ph id="ph5">`Double`</ph> in <ph id="ph6">`UDouble`</ph> und aus <ph id="ph7">`Single`</ph> in <ph id="ph8">`UDouble`</ph> werden bereitgestellt.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>It also defines a <ph id="ph1">`ToDouble`</ph> method as an alternative to the implicit conversion operator and the <ph id="ph2">`ToSingle`</ph>, <ph id="ph3">`FromDouble`</ph>, and <ph id="ph4">`FromSingle`</ph> methods as alternatives to the explicit conversion operators.</source>
          <target state="translated">Es wird auch eine <ph id="ph1">`ToDouble`</ph>-Methode als Alternative zum Operator für implizite Konvertierung definiert, und die <ph id="ph2">`ToSingle`</ph>, <ph id="ph3">`FromDouble`</ph>-Methode sowie die <ph id="ph4">`FromSingle`</ph>-Methode werden als Alternativen zu den Operatoren der expliziten Konvertierung definiert.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>CLS-compliant arrays conform to the following rules:</source>
          <target state="translated">CLS-kompatible Arrays sind mit den folgenden Regeln kompatibel:</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>All dimensions of an array must have a lower bound of zero.</source>
          <target state="translated">Die unteren Begrenzungen aller Dimensionen eines Arrays müssen gleich 0 sein.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>The following example creates a non-CLS-compliant array with a lower bound of one.</source>
          <target state="translated">Im folgenden Beispiel wird ein Array mit einer nicht CLS-kompatiblen Untergrenze von eins erstellt.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Note that, despite the presence of the <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> attribute, the compiler does not detect that the array returned by the <ph id="ph1">`Numbers.GetTenPrimes`</ph> method is not CLS-compliant.</source>
          <target state="translated">Beachten Sie, dass der Compiler ungeachtet des Vorhandenseins des <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept>-Attributs nicht erkennt, dass das von der <ph id="ph1">`Numbers.GetTenPrimes`</ph>-Methode zurückgegebene Array nicht CLS-kompatibel ist.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>All array elements must consist of CLS-compliant types.</source>
          <target state="translated">Alle Arrayelemente müssen aus CLS-kompatiblen Typen bestehen.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>The following example defines two methods that return non-CLS-compliant arrays.</source>
          <target state="translated">Im folgenden Beispiel werden zwei Methoden, die nicht CLS-kompatible Arrays zurückgeben, definiert.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>The first returns an array of <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept> values.</source>
          <target state="translated">Die erste Methode gibt ein Array von <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept>-Werten zurück.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>The second returns an <bpt id="p1">[</bpt>Object<ept id="p1">](xref:System.Object)</ept> array that includes <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept> and <ph id="ph1">`UInt32`</ph> values.</source>
          <target state="translated">Die zweite Methode gibt ein <bpt id="p1">[</bpt>Object<ept id="p1">](xref:System.Object)</ept>-Array zurück, das <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>- und <ph id="ph1">`UInt32`</ph>-Werte umfasst.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Although the compiler identifies the first array as non-compliant because of its <ph id="ph1">`UInt32`</ph> type, it fails to recognize that the second array includes non-CLS-compliant elements.</source>
          <target state="translated">Obwohl der Compiler das erste Array aufgrund des <ph id="ph1">`UInt32`</ph>-Typs als nicht kompatibel identifiziert, wird nicht erkannt, dass das zweite Array nicht CLS-kompatible Elemente umfasst.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>Overload resolution for methods that have array parameters is based on the fact that they are arrays and on their element type.</source>
          <target state="translated">Die Überladungsauflösung für Methoden mit Arrayparametern basiert sowohl auf der Tatsache, dass es Arrays sind, als auch auf dem Elementtyp.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>For this reason, the following definition of an overloaded <ph id="ph1">`GetSquares`</ph> method is CLS-compliant.</source>
          <target state="translated">Aus diesem Grund ist die folgende Definition einer überladenen <ph id="ph1">`GetSquares`</ph>-Methode CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Schnittstellen</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>CLS-compliant interfaces can define properties, events, and virtual methods (methods with no implementation).</source>
          <target state="translated">CLS-kompatible Schnittstellen können Eigenschaften, Ereignisse und virtuelle Methoden (Methoden ohne Implementierung) definieren.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>A CLS-compliant interface cannot have any of the following:</source>
          <target state="translated">Eine CLS-kompatible Schnittstelle kann keine der folgenden Aspekte aufweisen:</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>Static methods or static fields.</source>
          <target state="translated">Statische Methoden oder statische Felder</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The C# compiler generatse compiler errors if you define a static member in an interface.</source>
          <target state="translated">Der C#-Compiler generiert Compilerfehler, wenn Sie einen statischen Member in einer Schnittstelle definieren.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Fields.</source>
          <target state="translated">Felder</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>The C# acompiler generates compiler errors if you define a field in an interface.</source>
          <target state="translated">Die C#-Compiler generiert Compilerfehler, wenn Sie ein Feld in einer Schnittstelle definieren.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>Methods that are not CLS-compliant.</source>
          <target state="translated">Methoden, die nicht CLS-kompatibel sind.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>For example, the following interface definition includes a method, <ph id="ph1">`INumber.GetUnsigned`</ph>, that is marked as non-CLS-compliant.</source>
          <target state="translated">Zum Beispiel umfasst die folgende Schnittstellendefinition eine Methode, <ph id="ph1">`INumber.GetUnsigned`</ph>, die als nicht CLS-kompatibel gekennzeichnet wird.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>This example generates a compiler warning.</source>
          <target state="translated">In diesem Beispiel wird eine Compilerwarnung generiert.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>Because of this rule, CLS-compliant types are not required to implement non-CLS-compliant members.</source>
          <target state="translated">Aufgrund dieser Regel, ist es nicht erforderlich, dass CLS-kompatible Typen nicht CLS-kompatible Member implementieren.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>If a CLS-compliant framework does expose a class that implements a non-CLS compliant interface, it should also provide concrete implementations of all non-CLS-compliant members.</source>
          <target state="translated">Wenn ein CLS-kompatibles Framework eine Klasse verfügbar macht, die eine nicht CLS- kompatible Schnittstelle implementiert, sollte sie konkrete Implementierungen aller nicht-CLS-kompatiblen Member angeben.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>CLS-compliant language compilers must also allow a class to provide separate implementations of members that have the same name and signature in multiple interfaces.</source>
          <target state="translated">CLS-kompatible Sprachcompiler müssen einer Klasse auch ermöglichen, separate Implementierungen von Membern bereitzustellen, die in mehreren Schnittstellen über den gleichen Namen und dieselbe Signatur verfügen.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>C# supports explicit interface implementations to provide different implementations of identically named methods.</source>
          <target state="translated">C# unterstützt explizite Schnittstellenimplementierungen, um unterschiedliche Implementierungen identisch benannter Methoden bereitzustellen.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The following example illustrates this scenario by defining a <ph id="ph1">`Temperature`</ph> class that implements the <ph id="ph2">`ICelsius`</ph> and <ph id="ph3">`IFahrenheit`</ph> interfaces as explicit interface implementations.</source>
          <target state="translated">Im folgenden Beispiel wird dieses Szenario veranschaulicht, indem eine <ph id="ph1">`Temperature`</ph>-Klasse definiert wird, die die <ph id="ph2">`ICelsius`</ph>-Schnittstelle und die <ph id="ph3">`IFahrenheit`</ph>-Schnittstelle als explizite Schnittstellenimplementierungen implementiert.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Enumerationen</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>CLS-compliant enumerations must follow these rules:</source>
          <target state="translated">Bei CLS-kompatiblen Enumerationen müssen die folgenden Regeln beachtet werden:</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>The underlying type of the enumeration must be an intrinsic CLS-compliant integer (<bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, <bpt id="p2">[</bpt>Int16<ept id="p2">](xref:System.Int16)</ept>, <bpt id="p3">[</bpt>Int32<ept id="p3">](xref:System.Int32)</ept>, or <bpt id="p4">[</bpt>Int64<ept id="p4">](xref:System.Int64)</ept>).</source>
          <target state="translated">Der zugrunde liegende Typ der Enumeration muss ein systeminterner CLS-kompatibler Ganzzahltyp sein (<bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, <bpt id="p2">[</bpt>Int16<ept id="p2">](xref:System.Int16)</ept>, <bpt id="p3">[</bpt>Int32<ept id="p3">](xref:System.Int32)</ept> oder <bpt id="p4">[</bpt>Int64<ept id="p4">](xref:System.Int64)</ept>).</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>For example, the following code tries to define an enumeration whose underlying type is <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept> and generates a compiler warning.</source>
          <target state="translated">Im folgenden Code wird beispielsweise versucht, eine Enumeration zu definieren, deren zugrunde liegender Typ <bpt id="p1">[</bpt>UInt32<ept id="p1">](xref:System.UInt32)</ept> ist. Eine Compilerwarnung wird generiert.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>An enumeration type must have a single instance field named <ph id="ph1">`Value__`</ph> that is marked with the <ph id="ph2">`FieldAttributes.RTSpecialName`</ph> attribute.</source>
          <target state="translated">Ein Enumerationstyp muss über ein Feld namens <ph id="ph1">`Value__`</ph> mit einer einzelnen Instanz verfügen, das mit dem <ph id="ph2">`FieldAttributes.RTSpecialName`</ph>-Attribut markiert ist.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>This enables you to reference the field value implicitly.</source>
          <target state="translated">Damit können Sie den Feldwert implizit verweisen.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>An enumeration includes literal static fields whose types match the type of the enumeration itself.</source>
          <target state="translated">Eine Enumeration umfasst literale statische Felder, deren Typen vom gleichen Typ wie die Enumeration selbst sein müssen.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>For example, if you define a <ph id="ph1">`State`</ph> enumeration with values of <ph id="ph2">`State.On`</ph> and <ph id="ph3">`State.Off`</ph>, <ph id="ph4">`State.On`</ph> and <ph id="ph5">`State.Off`</ph> are both literal static fields whose type is <ph id="ph6">`State`</ph>.</source>
          <target state="translated">Wenn Sie zum Beispiel eine <ph id="ph1">`State`</ph>-Enumeration mit den Werten aus <ph id="ph2">`State.On`</ph> und <ph id="ph3">`State.Off`</ph> definieren, sind <ph id="ph4">`State.On`</ph> und <ph id="ph5">`State.Off`</ph> literale statische Felder, deren Typ <ph id="ph6">`State`</ph> ist.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>There are two kinds of enumerations:</source>
          <target state="translated">Es gibt zwei Arten von Enumerationen.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>An enumeration that represents a set of mutually exclusive, named integer values.</source>
          <target state="translated">Eine Enumeration, die einen Satz wechselseitig exklusiver, benannter ganzzahliger Werte darstellt.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>This type of enumeration is indicated by the absence of the <bpt id="p1">[</bpt>System.FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> custom attribute.</source>
          <target state="translated">Dieser Typ der Enumeration wird durch das Fehlen des benutzerdefinierten <bpt id="p1">[</bpt>System.FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept>-Attributs angegeben.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>An enumeration that represents a set of bit flags that can combine to generate an unnamed value.</source>
          <target state="translated">Eine Enumeration, die einen Satz von Bitflags darstellt, die zum Generieren eines unbenannten Werts kombiniert werden können.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>This type of enumeration is indicated by the presence of the <bpt id="p1">[</bpt>System.FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> custom attribute.</source>
          <target state="translated">Dieser Typ der Enumeration wird durch das Vorhandensein des benutzerdefinierten <bpt id="p1">[</bpt>System.FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept>-Attributs angegeben.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>For more information, see the documentation for the <bpt id="p1">[</bpt>Enum<ept id="p1">](xref:System.Enum)</ept> structure.</source>
          <target state="translated">Weitere Informationen finden Sie in der Dokumentation zur <bpt id="p1">[</bpt>Enum<ept id="p1">](xref:System.Enum)</ept>-Struktur.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>The value of an enumeration is not limited to the range of its specified values.</source>
          <target state="translated">Der Wert einer Enumeration wird nicht auf den Bereich der angegebenen Werte beschränkt.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>In other words, the range of values in an enumeration is the range of its underlying value.</source>
          <target state="translated">Das heißt, der Wertebereich einer Enumeration ist der Bereich des zugrunde liegenden Werts.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">`Enum.IsDefined`</ph> method to determine whether a specified value is a member of an enumeration.</source>
          <target state="translated">Sie können die <ph id="ph1">`Enum.IsDefined`</ph>-Methode verwenden, um zu bestimmen, ob ein angegebener Wert ein Member einer Enumeration ist.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>Type members in general</source>
          <target state="translated">Typmember im Allgemeinen</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>The Common Language Specification requires all fields and methods to be accessed as members of a particular class.</source>
          <target state="translated">Die Common Language Specification erfordert, dass auf alle Felder und Methoden als Member einer bestimmten Klasse zugegriffen werden.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Therefore, global static fields and methods (that is, static fields or methods that are defined apart from a type) are not CLS-compliant.</source>
          <target state="translated">Daher sind globale statische Felder und Methoden (das heißt, statische Felder oder Methoden, die unabhängig von einem Typ definiert werden), nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>If you try to include a global field or method in your source code, the C# compiler generates a compiler error.</source>
          <target state="translated">Wenn Sie versuchen, ein globales Feld oder eine Methode im Quellcode einzuschließen, wird vom C#-Compiler ein Compilerfehler generiert.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>The Common Language Specification supports only the standard managed calling convention.</source>
          <target state="translated">Die Common Language Specification unterstützt nur die verwaltete Standardaufrufkonvention.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>It doesn't support unmanaged calling conventions and methods with variable argument lists marked with the <ph id="ph1">`varargs`</ph> keyword.</source>
          <target state="translated">Sie unterstützt keine nicht verwalteten Aufrufkonventionen und keine Methoden mit variablen Argumentlisten, die mit dem <ph id="ph1">`varargs`</ph>-Schlüsselwort gekennzeichnet werden.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>For variable argument lists that are compatible with the standard managed calling convention, use the <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> attribute or the individual language's implementation, such as the <ph id="ph1">`params`</ph> keyword in C# and the <ph id="ph2">`ParamArray`</ph> keyword in Visual Basic.</source>
          <target state="translated">Verwenden Sie für Variablenargumentlisten, die mit der verwalteten Standardaufrufkonvention kompatibel sind, das <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept>-Attribut oder die Implementierung der jeweiligen Sprache, wie z.B. das <ph id="ph1">`params`</ph>-Schlüsselwort in C# und das <ph id="ph2">`ParamArray`</ph>-Schlüsselwort in Visual Basic.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>Member accessibility</source>
          <target state="translated">Memberzugriff</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Overriding an inherited member cannot change the accessibility of that member.</source>
          <target state="translated">Das Überschreiben eines geerbten Members kann den Zugriff auf diesen Member nicht ändern.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>For example, a public method in a base class cannot be overridden by a private method in a derived class.</source>
          <target state="translated">Beispielsweise kann eine öffentliche Methode in einer Basisklasse nicht von einer privaten Methode in einer abgeleiteten Klasse überschrieben werden.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>There is one exception: a <ph id="ph1">`protected internal`</ph> (in C#) or <ph id="ph2">`Protected Friend`</ph> (in Visual Basic) member in one assembly that is overridden by a type in a different assembly.</source>
          <target state="translated">Es gibt allerdings eine Ausnahme: einen <ph id="ph1">`protected internal`</ph>-Member (in C#) oder einen <ph id="ph2">`Protected Friend`</ph>-Member (in Visual Basic) in einer Assembly, die von einem Typ in einer anderen Assembly überschrieben wird.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>In that case, the accessibility of the override is <ph id="ph1">`Protected`</ph>.</source>
          <target state="translated">In diesem Fall ist der Zugriff auf die Überschreibung <ph id="ph1">`Protected`</ph>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The following example illustrates the error that is generated when the <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> attribute is set to <ph id="ph1">`true`</ph>, and <ph id="ph2">`Person`</ph>, which is a class derived from <ph id="ph3">`Animal`</ph>, tries to change the accessibility of the <ph id="ph4">`Species`</ph> property from public to private.</source>
          <target state="translated">Im folgenden Beispiel wird der Fehler veranschaulicht, der generiert wird, wenn das <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept>-Attribut auf <ph id="ph1">`true`</ph> festgelegt wird und <ph id="ph2">`Person`</ph>, eine von <ph id="ph3">`Animal`</ph> abgeleitete Klasse, versucht, den Zugriff auf die <ph id="ph4">`Species`</ph>-Eigenschaft von öffentlich in privat zu ändern.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The example compiles successfully if its accessibility is changed to public.</source>
          <target state="translated">Das Beispiel wird erfolgreich kompiliert, wenn der Zugriff auf öffentlich geändert wird.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>Types in the signature of a member must be accessible whenever that member is accessible.</source>
          <target state="translated">Der Zugriff auf Typen in der Signatur eines Members muss möglich sein, wenn auf den Member zugegriffen werden kann.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>For example, this means that a public member cannot include a parameter whose type is private, protected, or internal.</source>
          <target state="translated">Das bedeutet zum Beispiel, dass ein öffentlicher Member keinen Parameter enthalten kann, dessen Typ privat, geschützt oder intern ist.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>The following example illustrates the compiler error that results when a <ph id="ph1">`StringWrapper`</ph> class constructor exposes an internal <ph id="ph2">`StringOperationType`</ph> enumeration value that determines how a string value should be wrapped.</source>
          <target state="translated">Im folgenden Beispiel wird der Compilerfehler veranschaulicht, der entsteht, wenn ein <ph id="ph1">`StringWrapper`</ph>-Klassenkonstruktor einen internen <ph id="ph2">`StringOperationType`</ph>-Enumerationswert verfügbar macht, der bestimmt, wie ein Zeichenfolgenwert umschlossen werden soll.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>Generic types and members</source>
          <target state="translated">Generische Typen und Member</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>Nested types always have at least as many generic parameters as their enclosing type.</source>
          <target state="translated">Geschachtelte Typen weisen immer mindestens so viele generische Parameter auf wie der einschließende Typ.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>These correspond by position to the generic parameters in the enclosing type.</source>
          <target state="translated">Diese entsprechen der Position nach den generischen Parametern im einschließenden Typ.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>The generic type can also include new generic parameters.</source>
          <target state="translated">Der generische Typ kann auch neue generische Parameter enthalten.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The relationship between the generic type parameters of a containing type and its nested types may be hidden by the syntax of individual languages.</source>
          <target state="translated">Die Beziehung zwischen generischen Typparametern eines enthaltenden Typs und den geschachtelten Typen wird möglicherweise von der Syntax der einzelnen Sprachen verdeckt.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>In the following example, a generic type <ph id="ph1">`Outer&lt;T&gt;`</ph> contains two nested classes, <ph id="ph2">`Inner1A`</ph> and <ph id="ph3">`Inner1B&lt;U&gt;`</ph>.</source>
          <target state="translated">Im folgenden Beispiel enthält ein generischer Typ <ph id="ph1">`Outer&lt;T&gt;`</ph> zwei geschachtelte Klassen: <ph id="ph2">`Inner1A`</ph> und <ph id="ph3">`Inner1B&lt;U&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>The calls to the <ph id="ph1">`ToString`</ph> method, which each class inherits from <ph id="ph2">`Object.ToString`</ph>, show that each nested class includes the type parameters of its containing class.</source>
          <target state="translated">Die Aufrufe der <ph id="ph1">`ToString`</ph>-Methode, die jede Klasse von <ph id="ph2">`Object.ToString`</ph> erbt, zeigen, dass jede geschachtelte Klasse die Typparameter der enthaltenden Klasse umfasst.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>Generic type names are encoded in the form <bpt id="p1">*</bpt>name<ept id="p1">*</ept>'<bpt id="p2">*</bpt>n<ept id="p2">*</ept>, where <bpt id="p3">*</bpt>name<ept id="p3">*</ept> is the type name, <bpt id="p4">*</bpt><ph id="ph1">`</ph><ept id="p4">*</ept> is a character literal, and <bpt id="p5">*</bpt>n<ept id="p5">*</ept> is the number of parameters declared on the type, or, for nested generic types, the number of newly introduced type parameters.</source>
          <target state="translated">Der Name eines generischen Typs wird in der Form <bpt id="p1">*</bpt>name<ept id="p1">*</ept>'<bpt id="p2">*</bpt>n<ept id="p2">*</ept> codiert, wobei <bpt id="p3">*</bpt>name<ept id="p3">*</ept> der Typname, <bpt id="p4">*</bpt><ph id="ph1">`</ph><ept id="p4">*</ept> ein Zeichenliteral und <bpt id="p5">*</bpt>n<ept id="p5">*</ept> die Anzahl von Parametern ist, die für den Typ deklariert sind, oder, bei geschachtelten generischen Typen, die Anzahl neu eingeführter Typparameter.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>This encoding of generic type names is primarily of interest to developers who use reflection to access CLS-complaint generic types in a library.</source>
          <target state="translated">Diese Codierung von Namen des generischen Typs ist hauptsächlich für Entwickler relevant, die Reflexion verwenden, um auf CLS-kompatible generische Typen in einer Bibliothek zuzugreifen.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>If constraints are applied to a generic type, any types used as constraints must also be CLS-compliant.</source>
          <target state="translated">Wenn Einschränkungen auf einen generischen Typ angewendet werden, müssen alle als Einschränkungen verwendeten Typen auch CLS-kompatibel sein.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>The following example defines a class named <ph id="ph1">`BaseClass`</ph> that is not CLS-compliant and a generic class named <ph id="ph2">`BaseCollection`</ph> whose type parameter must derive from <ph id="ph3">`BaseClass`</ph>.</source>
          <target state="translated">Im folgenden Beispiel wird eine Klasse namens <ph id="ph1">`BaseClass`</ph> definiert, die nicht CLS-kompatibel ist sowie eine generische Klasse namens <ph id="ph2">`BaseCollection`</ph> deren Typparameter von <ph id="ph3">`BaseClass`</ph> abgeleitet werden muss.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>But because <ph id="ph1">`BaseClass`</ph>is not CLS-compliant, the compiler emits a warning.</source>
          <target state="translated">Da <ph id="ph1">`BaseClass`</ph> jedoch nicht CLS-kompatibel ist, gibt der Compiler eine Warnung aus.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>If a generic type is derived from a generic base type, it must redeclare any constraints so that it can guarantee that constraints on the base type are also satisfied.</source>
          <target state="translated">Wenn ein generischer Typ von einem generischen Basistyp abgeleitet ist, muss er alle Einschränkungen erneut deklarieren, damit sichergestellt ist, dass auch die Einschränkungen des Basistyps erfüllt werden.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`Number&lt;T&gt;`</ph> that can represent any numeric type.</source>
          <target state="translated">Im folgenden Beispiel wird <ph id="ph1">`Number&lt;T&gt;`</ph> definiert, das einen numerischen Typ darstellen kann.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>It also defines a <ph id="ph1">`FloatingPoint&lt;T&gt;`</ph> class that represents a floating point value.</source>
          <target state="translated">Es definiert auch eine <ph id="ph1">`FloatingPoint&lt;T&gt;`</ph>-Klasse, die einen Gleitkommawert darstellt.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>However, the source code fails to compile, because it does not apply the constraint on <ph id="ph1">`Number&lt;T&gt;`</ph> (that T must be a value type) to <ph id="ph2">`FloatingPoint&lt;T&gt;`</ph>.</source>
          <target state="translated">Allerdings kann der Quellcode nicht kompiliert werden, da die Einschränkung auf <ph id="ph1">`Number&lt;T&gt;`</ph> (dieses T muss ein Werttyp sein) nicht auf <ph id="ph2">`FloatingPoint&lt;T&gt;`</ph> angewendet werden.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The example compiles successfully if the constraint is added to the <ph id="ph1">`FloatingPoint&lt;T&gt;`</ph> class.</source>
          <target state="translated">Das Beispiel wird erfolgreich kompiliert, wenn die Einschränkung der <ph id="ph1">`FloatingPoint&lt;T&gt;`</ph>-Klasse hinzugefügt wird.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The Common Language Specification imposes a conservative per-instantiation model for nested types and protected members.</source>
          <target state="translated">Die Common Language Specification erzwingt ein konservatives Pro-Instanziierungsmodell für geschachtelte Typen und geschützte Member.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Open generic types cannot expose fields or members with signatures that contain a specific instantiation of a nested, protected generic type.</source>
          <target state="translated">Offene generische Typen können Felder oder Member mit Signaturen nicht verfügbar machen, die eine bestimmte Instanziierung eines geschachtelten, geschützten generischen Typs enthalten.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>Non-generic types that extend a specific instantiation of a generic base class or interface cannot expose fields or members with signatures that contain a different instantiation of a nested, protected generic type.</source>
          <target state="translated">Nicht generische Typen, die eine bestimmte Instanziierung einer generischen Basisklasse oder Schnittstelle erweitern, können Felder oder Member mit Signaturen nicht verfügbar machen, die eine andere Instanziierung eines geschachtelten, geschützten generischen Typs enthalten.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>The following example defines a generic type, <ph id="ph1">`C1&lt;T&gt;`</ph>, and a protected class, <ph id="ph2">`C1&lt;T&gt;.N`</ph>.</source>
          <target state="translated">Das folgende Beispiel definiert einen generischen Typ „<ph id="ph1">`C1&lt;T&gt;`</ph>“ und eine geschützte Klasse „<ph id="ph2">`C1&lt;T&gt;.N`</ph>“.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`C1&lt;T&gt;`</ph> has two methods, <ph id="ph2">`M1`</ph> and <ph id="ph3">`M2`</ph>.</source>
          <target state="translated"><ph id="ph1">`C1&lt;T&gt;`</ph> verfügt über zwei Methoden, <ph id="ph2">`M1`</ph> und <ph id="ph3">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>However, <ph id="ph1">`M1`</ph> is not CLS-compliant because it tries to return a <ph id="ph2">`C1&lt;int&gt;.N`</ph> object from <ph id="ph3">`C1&lt;T&gt;`</ph>.</source>
          <target state="translated">Allerdings ist <ph id="ph1">`M1`</ph> nicht CLS-kompatibel, da versucht wird, ein <ph id="ph2">`C1&lt;int&gt;.N`</ph>-Objekt von <ph id="ph3">`C1&lt;T&gt;`</ph> zurückzugeben.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>A second class, <ph id="ph1">`C2`</ph>, is derived from <ph id="ph2">`C1&lt;long&gt;`</ph>.</source>
          <target state="translated">Eine zweite Klasse, <ph id="ph1">`C2`</ph>, wird von <ph id="ph2">`C1&lt;long&gt;`</ph> abgeleitet.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>It has two methods, <ph id="ph1">`M3`</ph> and <ph id="ph2">`M4`</ph>.</source>
          <target state="translated">Sie verfügt über zwei Methoden, <ph id="ph1">`M3`</ph> und <ph id="ph2">`M4`</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`M3`</ph> is not CLS-compliant because it tries to return a <ph id="ph2">`C1&lt;int&gt;.N`</ph> object from a subclass of <ph id="ph3">`C1&lt;long&gt;`</ph>.</source>
          <target state="translated"><ph id="ph1">`M3`</ph> ist nicht CLS-kompatibel, da versucht wird, ein <ph id="ph2">`C1&lt;int&gt;.N`</ph>-Objekt von einer Unterklasse von <ph id="ph3">`C1&lt;long&gt;`</ph> zurückzugeben.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>Note that language compilers can be even more restrictive.</source>
          <target state="translated">Beachten Sie, dass Sprachcompiler sogar noch restriktiver sein können.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>In this example, Visual Basic displays an error when it tries to compile <ph id="ph1">`M4`</ph>.</source>
          <target state="translated">In diesem Beispiel zeigt Visual Basic einen Fehler an, wenn versucht wird, <ph id="ph1">`M4`</ph> zu kompilieren.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Konstruktoren</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>Constructors in CLS-compliant classes and structures must follow these rules:</source>
          <target state="translated">Bei Konstruktoren in den CLS-kompatiblen Klassen und Strukturen müssen die folgenden Regeln beachtet werden:</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>A constructor of a derived class must call the instance constructor of its base class before it accesses inherited instance data.</source>
          <target state="translated">Der Konstruktor einer abgeleiteten Klasse muss den Instanzkonstruktor der Basisklasse aufrufen, bevor er auf geerbte Instanzdaten zugreift.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>This requirement is due to the fact that base class constructors are not inherited by their derived classes.</source>
          <target state="translated">Diese Anforderung basiert auf der Tatsache, dass Konstruktoren nicht nach ihren abgeleiteten Klassen geerbt werden.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>This rule does not apply to structures, which do not support direct inheritance.</source>
          <target state="translated">Diese Regel gilt nicht für Strukturen, die keine direkte Vererbung unterstützen.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>Typically, compilers enforce this rule independently of CLS compliance, as the following example shows.</source>
          <target state="translated">In der Regel erzwingen Compiler diese Regel unabhängig von der CLS-Kompatibilität, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>It creates a <ph id="ph1">`Doctor`</ph> class that is derived from a <ph id="ph2">`Person`</ph> class, but the <ph id="ph3">`Doctor`</ph>class fails to call the <ph id="ph4">`Person`</ph> class constructor to initialize inherited instance fields.</source>
          <target state="translated">Es wird eine <ph id="ph1">`Doctor`</ph>-Klasse erstellt, die von einer <ph id="ph2">`Person`</ph>-Klasse abgeleitet ist. Die <ph id="ph3">`Doctor`</ph>-Klasse kann den <ph id="ph4">`Person`</ph>-Klassenkonstruktor jedoch nicht zum Initialisieren geerbter Instanzfelder aufrufen.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>An object constructor cannot be called except to create an object.</source>
          <target state="translated">Ein Objektkonstruktor kann nur aufgerufen werden, um ein Objekt zu erstellen.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>In addition, an object cannot be initialized twice.</source>
          <target state="translated">Außerdem kann ein Objekt nicht zweimal initialisiert werden.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>For example, this means that <ph id="ph1">`Object.MemberwiseClone`</ph> must not call constructors.</source>
          <target state="translated">Beispielsweise bedeutet dies, dass mit <ph id="ph1">`Object.MemberwiseClone`</ph> keine Konstruktoren aufgerufen werden dürfen.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Eigenschaften</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>Properties in CLS-compliant types must follow these rules:</source>
          <target state="translated">Eigenschaften in den CLS-kompatiblen Typen müssen die folgenden Regeln beachten:</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>A property must have a setter, a getter, or both.</source>
          <target state="translated">Eine Eigenschaft muss über einen Setter, einen Getter oder beides verfügen.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>In an assembly, these are implemented as special methods, which means that they will appear as separate methods (the getter is named <ph id="ph1">`get`</ph><ph id="ph2">\_</ph><bpt id="p1">*</bpt>propertyname<ept id="p1">*</ept> and the setter is <ph id="ph3">`set*\_*propertyname*) marked as `</ph>SpecialName` in the assembly's metadata.</source>
          <target state="translated">In einer Assembly werden diese als spezielle Methoden implementiert. Das bedeutet, dass sie als separate Methoden (der Getter unter dem Namen <ph id="ph1">`get`</ph><ph id="ph2">\_</ph><bpt id="p1">*</bpt>propertyname<ept id="p1">*</ept> und der Setter unter dem Namen <ph id="ph3">`set*\_*propertyname*) marked as `</ph>SpecialName`) in den Metadaten der Assembly angezeigt werden.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>The C# compiler enforces this rule automatically without the need to apply the <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> attribute.</source>
          <target state="translated">Die C#-Compiler erzwingt diese Regel automatisch, ohne das <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept>-Attribut anzuwenden.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>A property's type is the return type of the property getter and the last argument of the setter.</source>
          <target state="translated">Ein Typ der Eigenschaft entspricht dem Rückgabetyp der Getter-Methode der Eigenschaft und dem letzten Argument der Setter-Methode.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>These types must be CLS compliant, and arguments cannot be assigned to the property by reference (that is, they cannot be managed pointers).</source>
          <target state="translated">Diese Typen müssen CLS-kompatibel sein, und Argumente können der Eigenschaft nicht mithilfe eines Verweises zugewiesen werden (das heißt, es können keine verwalteten Zeiger sein).</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>If a property has both a getter and a setter, they must both be virtual, both static, or both instance.</source>
          <target state="translated">Wenn eine Eigenschaft einen Getter und einen Setter aufweist, müssen beide "virtual", "static" oder "instance" sein.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>The C# compiler automatically enforces this rule through property definition syntax.</source>
          <target state="translated">Der C#-Compiler erzwingt diese Regel automatisch über die Eigenschaftendefinitionssyntax.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Ereignisse</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>An event is defined by its name and its type.</source>
          <target state="translated">Ein Ereignis wird vom Namen und dem Typ definiert.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>The event type is a delegate that is used to indicate the event.</source>
          <target state="translated">Der Ereignistyp ist ein Delegat, der zum Angeben des Ereignisses verwendet wird.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">`DbConnection.StateChange`</ph> event is of type <ph id="ph2">`StateChangeEventHandler`</ph>.</source>
          <target state="translated">Zum Beispiel hat das <ph id="ph1">`DbConnection.StateChange`</ph>-Ereignis den Typ <ph id="ph2">`StateChangeEventHandler`</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>In addition to the event itself, three methods with names based on the event name provide the event's implementation and are marked as <ph id="ph1">`SpecialName`</ph> in the assembly's metadata:</source>
          <target state="translated">Neben dem Ereignis selbst, stellen drei Methoden mit Namen basierend auf dem Ereignisnamen die Implementierung des Ereignisses bereit und werden in den Metadaten der Assembly als <ph id="ph1">`SpecialName`</ph> gekennzeichnet:</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>A method for adding an event handler, named <ph id="ph1">`add`</ph>_<bpt id="p1">*</bpt>EventName<ept id="p1">*</ept>.</source>
          <target state="translated">Eine Methode zum Hinzufügen eines Ereignishandlers namens <ph id="ph1">`add`</ph>_<bpt id="p1">*</bpt>Ereignisname<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>For example, the event subscription method for the <ph id="ph1">`DbConnection.StateChange`</ph> event is named <ph id="ph2">`add_StateChange`</ph>.</source>
          <target state="translated">Die Ereignisabonnementmethode für das <ph id="ph1">`DbConnection.StateChange`</ph>-Ereignis hat zum Beispiel den Namen <ph id="ph2">`add_StateChange`</ph>.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>A method for removing an event handler, named <ph id="ph1">`remove`</ph>_<bpt id="p1">*</bpt>EventName<ept id="p1">*</ept>.</source>
          <target state="translated">Eine Methode zum Enternen eines Ereignishandlers namens <ph id="ph1">`remove`</ph>_<bpt id="p1">*</bpt>Ereignisname<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>For example, the removal method for the <ph id="ph1">`DbConnection.StateChange`</ph> event is named <ph id="ph2">`remove_StateChange`</ph>.</source>
          <target state="translated">Die Entfernenmethode für das <ph id="ph1">`DbConnection.StateChange`</ph>-Ereignis hat zum Beispiel den Namen <ph id="ph2">`remove_StateChange`</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>A method for indicating that the event has occurred, named <ph id="ph1">`raise`</ph>_<bpt id="p1">*</bpt>EventName<ept id="p1">*</ept>.</source>
          <target state="translated">Eine Methode für den Hinweis, dass das Ereignis namens <ph id="ph1">`raise`</ph>_<bpt id="p1">*</bpt>Ereignisname<ept id="p1">*</ept> aufgetreten ist.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>Most of the Common Language Specification's rules regarding events are implemented by language compilers and are transparent to component developers.</source>
          <target state="translated">Die meisten Regeln der Common Language Specification zu Ereignissen werden von den Sprachcompilern implementiert und sind für Komponentenentwickler transparent.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>The methods for adding, removing, and raising the event must have the same accessibility.</source>
          <target state="translated">Die Methoden für das Hinzufügen, Entfernen und Auslösen des Ereignisses verfügen über den gleichen Zugriff.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>They must also all be static, instance, or virtual.</source>
          <target state="translated">Sie müssen zudem "static", "instance" oder "virtual" sein.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The methods for adding and removing an event have one parameter whose type is the event delegate type.</source>
          <target state="translated">Die Methoden zum Hinzufügen und Entfernen eines Ereignisses verfügen über einen Parameter, dessen Typ der Ereignisdelegattyp ist.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>The add and remove methods must both be present or both be absent.</source>
          <target state="translated">Die Methoden zum Hinzufügen und Entfernen müssen beide vorhanden sein oder beide fehlen.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>The following example defines a CLS-compliant class named <ph id="ph1">`Temperature`</ph> that raises a <ph id="ph2">`TemperatureChanged`</ph> event if the change in temperature between two readings equals or exceeds a threshold value.</source>
          <target state="translated">Im folgenden Beispiel wird eine CLS-kompatible Klasse namens <ph id="ph1">`Temperature`</ph> definiert, die ein <ph id="ph2">`TemperatureChanged`</ph>-Ereignis auslöst, wenn die Temperaturänderung zwischen zwei Messungen einem Schwellenwert entspricht oder diesen überschreitet.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Temperature`</ph> class explicitly defines a <ph id="ph2">`raise_TemperatureChanged`</ph> method so that it can selectively execute event handlers.</source>
          <target state="translated">Die <ph id="ph1">`Temperature`</ph>-Klasse definiert eine <ph id="ph2">`raise_TemperatureChanged`</ph>-Methode explizit, sodass sie selektiv Ereignishandler ausführen kann.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="translated">Overloads</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>The Common Language Specification imposes the following requirements on overloaded members:</source>
          <target state="translated">Die Common Language Specification erzwingt die folgenden Anforderungen für überladene Member:</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>Members can be overloaded based on the number of parameters and the type of any parameter.</source>
          <target state="translated">Member können auf Grundlage der Anzahl und des Typs eines Parameters überladen werden.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Calling convention, return type, custom modifiers applied to the method or its parameter, and whether parameters are passed by value or by reference are not considered when differentiating between overloads.</source>
          <target state="translated">Aufrufkonvention, Rückgabetyp, die benutzerdefinierten Modifizierer, die auf die Methode oder deren Parameter angewendet werden und, ob Parameter nach Wert oder nach Verweis übergeben werden, werden bei der Unterscheidung zwischen Überladungen nicht beachtet.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>For an example, see the code for the requirement that names must be unique within a scope in the <bpt id="p1">[</bpt>Naming conventions<ept id="p1">](#naming-conventions)</ept> section.</source>
          <target state="translated">Ein Beispiel finden Sie im Abschnitt <bpt id="p1">[</bpt>Namenskonventionen<ept id="p1">](#naming-conventions)</ept> im Code für die Anforderung, dass Namen innerhalb eines Bereichs eindeutig sein müssen.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>Only properties and methods can be overloaded.</source>
          <target state="translated">Nur Eigenschaften und Methoden können überladen werden.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>Fields and events cannot be overloaded.</source>
          <target state="translated">Felder und Ereignisse können nicht überladen werden.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>Generic methods can be overloaded based on the number of their generic parameters.</source>
          <target state="translated">Generische Methoden können auf Grundlage der Anzahl ihrer generischen Parameter überladen werden.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`op_Explicit`</ph> and <ph id="ph2">`op_Implicit`</ph> operators are exceptions to the rule that return value is not considered part of a method signature for overload resolution.</source>
          <target state="translated">Der <ph id="ph1">`op_Explicit`</ph>-Operator und der <ph id="ph2">`op_Implicit`</ph>-Operator sind Ausnahmen von der Regel, dass Rückgabewerte nicht als Teil einer Methodensignatur für Überladungsauflösung gelten.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>These two operators can be overloaded based on both their parameters and their return value.</source>
          <target state="translated">Diese beiden Operatoren können auf Grundlage ihrer Parameter und ihrer Rückgabewerte überladen werden.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Ausnahmen</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>Exception objects must derive from <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept> or from another type derived from <ph id="ph1">`System.Exception`</ph>.</source>
          <target state="translated">Ausnahmeobjekte müssen von <bpt id="p1">[</bpt>System.Exception<ept id="p1">](xref:System.Exception)</ept> oder von einem anderen Typ abgeleitet werden, der von <ph id="ph1">`System.Exception`</ph> abgeleitet wird.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>The following example illustrates the compiler error that results when a custom class named <ph id="ph1">`ErrorClass`</ph> is used for exception handling.</source>
          <target state="translated">Im folgenden Beispiel wird der Compilerfehler veranschaulicht, der entsteht, wenn eine benutzerdefinierte Klasse namens <ph id="ph1">`ErrorClass`</ph> für die Ausnahmebehandlung verwendet wird.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>To correct this error, the <ph id="ph1">`ErrorClass`</ph> class must inherit from <ph id="ph2">`System.Exception`</ph>.</source>
          <target state="translated">Um diesen Fehler zu beheben, muss die <ph id="ph1">`ErrorClass`</ph>-Klasse von <ph id="ph2">`System.Exception`</ph> erben.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>In addition, the Message property must be overridden.</source>
          <target state="translated">Außerdem muss die Message-Eigenschaft außer Kraft gesetzt werden.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>The following example corrects these errors to define an <ph id="ph1">`ErrorClass`</ph> class that is CLS-compliant.</source>
          <target state="translated">Im folgenden Beispiel werden diese Fehler korrigiert, um eine CLS-kompatible <ph id="ph1">`ErrorClass`</ph>-Klasse zu definieren.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attribute</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>In.NET Framework assemblies, custom attributes provide an extensible mechanism for storing custom attributes and retrieving metadata about programming objects, such as assemblies, types, members, and method parameters.</source>
          <target state="translated">In .NET-Frameworkassemblys stellen benutzerdefinierte Attribute einen erweiterbaren Mechanismus zum Speichern benutzerdefinierter Attribute und das Abrufen von Metadaten über Programmierobjekte, wie Assemblys, Typen, Member und Methodenparameter, bereit.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>Custom attributes must derive from <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept> or from a type derived from <ph id="ph1">`System.Attribute`</ph>.</source>
          <target state="translated">Benutzerdefinierte Attribute müssen von <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept> oder einem Typ abgeleitet werden, der von <ph id="ph1">`System.Attribute`</ph> abgeleitet wird.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>The following example violates this rule.</source>
          <target state="translated">Das folgende Beispiel verstößt gegen diese Regel.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>It defines a <ph id="ph1">`NumericAttribute`</ph> class that does not derive from <ph id="ph2">`System.Attribute`</ph>.</source>
          <target state="translated">Es wird eine <ph id="ph1">`NumericAttribute`</ph>-Klasse definiert, die nicht von <ph id="ph2">`System.Attribute`</ph> abgeleitet ist.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>Note that a compiler error results only when the non-CLS-compliant attribute is applied, not when the class is defined.</source>
          <target state="translated">Beachten Sie, dass der Compilerfehler nur entsteht, wenn das nicht CLS-kompatible Attribut angewendet wird, nicht aber, wenn die Klasse definiert ist.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>The constructor or the properties of a CLS-compliant attribute can expose only the following types:</source>
          <target state="translated">Der Konstruktor oder die Eigenschaften eines CLS-kompatiblen Attributs können nur die folgenden Typen verfügbar machen:</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept></target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept></target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept></target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Double<ept id="p1">](xref:System.Double)</ept></target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int16<ept id="p1">](xref:System.Int16)</ept></target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int32<ept id="p1">](xref:System.Int32)</ept></target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Int64<ept id="p1">](xref:System.Int64)</ept></target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Single<ept id="p1">](xref:System.Single)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Single<ept id="p1">](xref:System.Single)</ept></target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept></target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type<ept id="p1">](xref:System.Type)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Typ<ept id="p1">](xref:System.Type)</ept></target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>Any enumeration type whose underlying type is <ph id="ph1">`Byte`</ph>, <ph id="ph2">`Int16`</ph>, <ph id="ph3">`Int32`</ph>, or <ph id="ph4">`Int64`</ph>.</source>
          <target state="translated">Ein Enumerationstyp, dessen zugrunde liegender Typ <ph id="ph1">`Byte`</ph>, <ph id="ph2">`Int16`</ph>, <ph id="ph3">`Int32`</ph> oder <ph id="ph4">`Int64`</ph> ist.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`DescriptionAttribute`</ph> class that derives from <bpt id="p1">[</bpt>Attribute<ept id="p1">](xref:System.Attribute)</ept>.</source>
          <target state="translated">Im folgenden Beispiel wird eine von <bpt id="p1">[</bpt>Attribute<ept id="p1">](xref:System.Attribute)</ept> abgeleitete <ph id="ph1">`DescriptionAttribute`</ph>-Klasse definiert.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>The class constructor has a parameter of type <ph id="ph1">`Descriptor`</ph>, so the class is not CLS-compliant.</source>
          <target state="translated">Der Klassenkonstruktor verfügt über einen Parameter des Typs <ph id="ph1">`Descriptor`</ph>, sodass die Klasse nicht CLS-kompatibel ist.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>Note that the C# compiler emits a warning but compiles successfully.</source>
          <target state="translated">Beachten Sie, dass der C#-Compiler eine Warnung ausgibt, die Kompilierung aber erfolgreich durchführt.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>The CLSCompliantAttribute attribute</source>
          <target state="translated">Das CLSCompliantAttribute-Attribut</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept> attribute is used to indicate whether a program element complies with the Common Language Specification.</source>
          <target state="translated">Das <bpt id="p1">[</bpt>CLSCompliantAttribute<ept id="p1">](xref:System.CLSCompliantAttribute)</ept>-Attribut wird verwendet, um anzugeben, ob ein Programmelement mit der Common Language Specification kompatibel ist.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CLSCompliantAttribute.CLSCompliantAttribute(Boolean)`</ph> constructor includes a single required parameter, <bpt id="p1">*</bpt>isCompliant<ept id="p1">*</ept>, that indicates whether the program element is CLS-compliant.</source>
          <target state="translated">Der <ph id="ph1">`CLSCompliantAttribute.CLSCompliantAttribute(Boolean)`</ph>-Konstruktor enthält einen einzelnen erforderlichen Parameter, <bpt id="p1">*</bpt>isCompliant<ept id="p1">*</ept>, der angibt, ob das Programmelement CLS-kompatibel ist.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>At compile time, the compiler detects non-compliant elements that are presumed to be CLS-compliant and emits a warning.</source>
          <target state="translated">Zur Kompilierzeit erkennt der Compiler nicht kompatible Elemente, von denen angenommen wird, dass sie CLS-kompatibel sind, und gibt eine Warnung aus.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>The compiler does not emit warnings for types or members that are explicitly declared to be non-compliant.</source>
          <target state="translated">Der Compiler gibt keine Warnungen für die Typen oder Member aus, die explizit als nicht kompatibel deklariert werden.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>Component developers can use the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute in two ways:</source>
          <target state="translated">Komponentenentwickler können das <ph id="ph1">`CLSCompliantAttribute`</ph>-Attribut auf zwei Arten verwenden:</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>To define the parts of the public interface exposed by a component that are CLS-compliant and the parts that are not CLS-compliant.</source>
          <target state="translated">Um die Teile der öffentlichen Schnittstelle zu definieren, die von einer CLS-kompatiblen Komponente und den nicht CLS-kompatiblen Teilen verfügbar gemacht werden.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>When the attribute is used to mark particular program elements as CLS-compliant, its use guarantees that those elements are accessible from all languages and tools that target the .NET Framework.</source>
          <target state="translated">Wenn das Attribut verwendet wird, um bestimmte Programmelemente als CLS-kompatibel zu markieren, stellt seine Verwendung sicher, dass auf diese Elemente aus allen Sprachen und Tools für das .NET Framework zugegriffen werden kann.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>To ensure that the component library's public interface exposes only program elements that are CLS-compliant.</source>
          <target state="translated">Um sicherzustellen, dass die öffentliche Schnittstelle der Komponentenbibliothek nur Programmelemente verfügbar macht, die CLS-kompatibel sind.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>If elements are not CLS-compliant, compilers will generally issue a warning.</source>
          <target state="translated">Wenn Elemente nicht CLS-kompatibel sind, geben Compiler im Allgemeinen eine Warnung aus.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>In some cases, language compilers enforce CLS-compliant rules regardless of whether the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute is used.</source>
          <target state="translated">In einigen Fällen erzwingen CLS-kompatible Sprachcompiler Regeln unabhängig davon, ob das <ph id="ph1">`CLSCompliantAttribute`</ph>-Attribut verwendet wird.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>For example, defining a <ph id="ph1">`*static`</ph> member in an interface violates a CLS rule.</source>
          <target state="translated">Das Definieren eines <ph id="ph1">`*static`</ph>-Members in einer Schnittstelle verstößt zum Beispiel gegen eine CLS-Regel.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>However, if you define a <ph id="ph1">`*static`</ph> member in an interface, the C# compiler displays an error message and fails to compile the app.</source>
          <target state="translated">Wenn Sie jedoch einen <ph id="ph1">`*static`</ph>-Member in einer Schnittstelle definieren, zeigt der C#-Compiler eine Fehlermeldung an, und beim Kompilieren der App tritt ein Fehler auf.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CLSCompliantAttribute`</ph> attribute is marked with an <bpt id="p1">[</bpt>AttributeUsageAttribute<ept id="p1">](xref:System.AttributeUsageAttribute)</ept> attribute that has a value of <ph id="ph2">`AttributeTargets.All`</ph>.</source>
          <target state="translated">Das <ph id="ph1">`CLSCompliantAttribute`</ph>-Attribut wird mit einem <bpt id="p1">[</bpt>AttributeUsageAttribute<ept id="p1">](xref:System.AttributeUsageAttribute)</ept>-Attribut markiert, das einen Wert von <ph id="ph2">`AttributeTargets.All`</ph> aufweist.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>This value allows you to apply the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute to any program element, including assemblies, modules, types (classes, structures, enumerations, interfaces, and delegates), type members (constructors, methods, properties, fields, and events), parameters, generic parameters, and return values.</source>
          <target state="translated">Dieser Wert ermöglicht das Anwenden des <ph id="ph1">`CLSCompliantAttribute`</ph>-Attributs auf jedem Programmelement, einschließlich Assemblys, Modulen, Typen (Klassen, Strukturen, Enumerationen, Schnittstellen und Delegaten), Typmembern (Konstruktoren, Methoden, Eigenschaften, Feldern und Ereignissen), Parametern, generischen Parametern und Rückgabewerten.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>However, in practice, you should apply the attribute only to assemblies, types, and type members.</source>
          <target state="translated">In der Praxis sollten Sie das Attribut allerdings nur auf Assemblys, Typen und Typmember anwenden.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Otherwise, compilers ignore the attribute and continue to generate compiler warnings whenever they encounter a non-compliant parameter, generic parameter, or return value in your library's public interface.</source>
          <target state="translated">Andernfalls ignorieren Compiler das Attribut und generieren weiterhin Compilerwarnungen, wenn sie einen nicht kompatiblen Parameter, einen generischen Parameter oder einen Rückgabewert in der öffentlichen Schnittstelle der Bibliothek vorfinden.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>The value of the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute is inherited by contained program elements.</source>
          <target state="translated">Der Wert des <ph id="ph1">`CLSCompliantAttribute`</ph>-Attributs wird von enthaltenen Programmelementen geerbt.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>For example, if an assembly is marked as CLS-compliant, its types are also CLS-compliant.</source>
          <target state="translated">Wenn beispielsweise eine Assembly als CLS-kompatibel markiert ist, sind die Typen auch CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>If a type is marked as CLS-compliant, its nested types and members are also CLS-compliant.</source>
          <target state="translated">Wenn ein Typ als CLS-kompatibel gekennzeichnet ist, sind seine geschachtelten Typen und Member auch CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>You can explicitly override the inherited compliance by applying the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute to a contained program element.</source>
          <target state="translated">Sie können die geerbte Kompatibilität explizit überschreiben, indem Sie das <ph id="ph1">`CLSCompliantAttribute`</ph>- Attribut auf ein enthaltenes Programmelement anwenden.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>For example, you can use the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute with an <bpt id="p1">*</bpt>isCompliant<ept id="p1">*</ept> value of <ph id="ph2">`false`</ph> to define a non-compliant type in a compliant assembly, and you can use the attribute with an <bpt id="p2">*</bpt>isComplian<ept id="p2">*</ept> value of <ph id="ph3">`true`</ph> to define a compliant type in a non-compliant assembly.</source>
          <target state="translated">Beispielsweise können Sie das <ph id="ph1">`CLSCompliantAttribute`</ph>-Attribut mit einem <bpt id="p1">*</bpt>isCompliant<ept id="p1">*</ept>-Wert von <ph id="ph2">`false`</ph> verwenden, um einen inkompatiblen Typ in einer kompatiblen Assembly zu definieren, und Sie können das Attribut mit einem <bpt id="p2">*</bpt>isCompliant<ept id="p2">*</ept>-Wert von <ph id="ph3">`true`</ph> verwenden, um einen kompatiblen Typ in einer inkompatiblen Assembly zu definieren.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>You can also define non-compliant members in a compliant type.</source>
          <target state="translated">Sie können auch nicht kompatible Member in einem kompatiblen Typ definieren.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>However, a non-compliant type cannot have compliant members, so you cannot use the attribute with an <bpt id="p1">*</bpt>isCompliant<ept id="p1">*</ept> value of <ph id="ph1">`true`</ph> to override inheritance from a non-compliant type.</source>
          <target state="translated">Allerdings kann ein nicht kompatibler Typ keine kompatiblen Member aufweisen, sodass Sie das Attribut nicht mit einem <bpt id="p1">*</bpt>isCompliant<ept id="p1">*</ept>-Wert von <ph id="ph1">`true`</ph> verwenden können, um die Vererbung eines nicht kompatiblen Typs zu überschreiben.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>When you are developing components, you should always use the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute to indicate whether your assembly, its types, and its members are CLS-compliant.</source>
          <target state="translated">Wenn Sie Komponenten entwickeln, sollten Sie stets das <ph id="ph1">`CLSCompliantAttribute`</ph>- Attribut verwenden, um anzugeben, ob die Assembly, die Typen und die Member CLS-kompatibel sind.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>To create CLS-compliant components:</source>
          <target state="translated">So erstellen Sie CLS-kompatible Komponenten:</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`CLSCompliantAttribute`</ph> to mark you assembly as CLS-compliant.</source>
          <target state="translated">Verwenden Sie <ph id="ph1">`CLSCompliantAttribute`</ph>, um die Assembly als CLS-kompatibel zu markieren.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>Mark any publicly exposed types in the assembly that are not CLS-compliant as non-compliant.</source>
          <target state="translated">Markieren Sie jeden öffentlich verfügbar gemachten, nicht CLS-kompatiblen Typ in der Assembly als nicht kompatibel.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>Mark any publicly exposed members in CLS-compliant types as non-compliant.</source>
          <target state="translated">Markieren Sie alle öffentlich verfügbar gemachten Member in CLS-kompatiblen Typen als nicht kompatibel.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>Provide a CLS-compliant alternative for non-CLS-compliant members.</source>
          <target state="translated">Stellen Sie eine CLS-kompatible Alternative für nicht CLS-kompatible Member bereit.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>If you've successfully marked all your non-compliant types and members, your compiler should not emit any non-compliance warnings.</source>
          <target state="translated">Wenn alle inkompatiblen Typen und Member erfolgreich markiert wurden, sollte der Compiler keine Kompatibilitätswarnungen ausgeben.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>However, you should indicate which members are not CLS-compliant and list their CLS-compliant alternatives in your product documentation.</source>
          <target state="translated">Allerdings sollten Sie angeben, welche Member nicht CLS-kompatibel sind und ihre CLS-kompatiblen Alternativen in der Produktdokumentation aufführen.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CLSCompliantAttribute`</ph> attribute to define a CLS-compliant assembly and a type, <ph id="ph2">`CharacterUtilities`</ph>, that has two non-CLS-compliant members.</source>
          <target state="translated">Im folgenden Beispiel wird das <ph id="ph1">`CLSCompliantAttribute`</ph>-Attribut verwendet, um eine CLS-kompatible Assembly und einen Typ, <ph id="ph2">`CharacterUtilities`</ph>, zu definieren, der über zwei nicht CLS-kompatible Member verfügt.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>Because both members are tagged with the <ph id="ph1">`CLSCompliant(false)`</ph> attribute, the compiler produces no warnings.</source>
          <target state="translated">Da beide Member mit dem <ph id="ph1">`CLSCompliant(false)`</ph>-Attribut markiert sind, generiert der Compiler keine Warnungen.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>The class also provides a CLS-compliant alternative for both methods.</source>
          <target state="translated">Die Klasse stellt auch eine CLS-kompatible Alternative für beide Methoden bereit.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>Ordinarily, we would just add two overloads to the <ph id="ph1">`ToUTF16`</ph> method to provide CLS-compliant alternatives.</source>
          <target state="translated">Normalerweise würden der <ph id="ph1">`ToUTF16`</ph>- Methode lediglich zwei Überladungen hinzugefügt werden, um CLS-kompatible Alternativen bereitzustellen.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source>However, because methods cannot be overloaded based on return value, the names of the CLS-compliant methods are different from the names of the non-compliant methods.</source>
          <target state="translated">Da Methoden aber nicht aufgrund des Rückgabewerts überladen werden können, sind die Namen der CLS-kompatiblen Methoden von den Namen der nicht kompatiblen Methoden unterschiedlich.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>If you are developing an app rather than a library (that is, if you aren't exposing types or members that can be consumed by other app developers), the CLS compliance of the program elements that your app consumes are of interest only if your language does not support them.</source>
          <target state="translated">Wenn Sie eine App anstelle einer Bibliothek entwickeln, (das heißt, wenn Sie keine Typen oder Member verfügbar machen, die von anderen App-Entwicklern genutzt werden können), ist die CLS-Kompatibilität der Programmelemente, die von der App genutzt werden, nur relevant, wenn sie von Ihrer Sprache nicht unterstützt werden.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>In that case, your language compiler will generate an error when you try to use a non-CLS-compliant element.</source>
          <target state="translated">In diesem Fall generiert der Sprachcompiler einen Fehler, wenn Sie versuchen, ein nicht CLS-kompatibles Element zu verwenden.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>Cross-Language Interoperability</source>
          <target state="translated">Sprachübergreifende Interoperabilität</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>Language independence has a number of possible meanings.</source>
          <target state="translated">Der Begriff „Sprachunabhängigkeit“ kann mehrere Bedeutungen haben.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>One meaning involves seamlessly consuming types written in one language from an app written in another language.</source>
          <target state="translated">Eine Bedeutung umfasst die nahtlose Nutzung von Typen, die in einer Sprache geschrieben werden, in einer App, die in einer anderen Sprache geschrieben wurde.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>A second meaning, which is the focus of this article, involves combining code written in multiple languages into a single .NET Framework assembly.</source>
          <target state="translated">Eine zweite Bedeutung, die in diesem Artikels hervorgehoben wird, umfasst die Kombination von Code aus mehreren Sprachen in einer einzelnen .NET Framework-Assembly.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>The following example illustrates cross-language interoperability by creating a class library named Utilities.dll that includes two classes, <ph id="ph1">`NumericLib`</ph> and <ph id="ph2">`StringLib`</ph>.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die sprachübergreifende Interoperabilität. Es wird die Klassenbibliothek Utilities.dll erstellt, die zwei Klassen einschließt: <ph id="ph1">`NumericLib`</ph> und <ph id="ph2">`StringLib`</ph>.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`NumericLib`</ph> class is written in C#, and the <ph id="ph2">`StringLib`</ph> class is written in Visual Basic.</source>
          <target state="translated">Die <ph id="ph1">`NumericLib`</ph>-Klasse wurde in C# und die <ph id="ph2">`StringLib`</ph>-Klasse in Visual Basic geschrieben.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>Here's the source code for <ph id="ph1">`StringUtil.vb`</ph>, which includes a single member, <ph id="ph2">`ToTitleCase`</ph>, in its <ph id="ph3">`StringLib`</ph> class.</source>
          <target state="translated">Im Folgenden sehen Sie den Quellcode für <ph id="ph1">`StringUtil.vb`</ph>, der in der <ph id="ph3">`StringLib`</ph>-Klasse einen einzelnen Member <ph id="ph2">`ToTitleCase`</ph> enthält.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>Here's the source code for NumberUtil.cs, which defines a <ph id="ph1">`NumericLib`</ph> class that has two members, <ph id="ph2">`IsEven`</ph> and <ph id="ph3">`NearZero`</ph>.</source>
          <target state="translated">Im Folgenden sehen Sie den Quellcode für "NumberUtil.cs", der eine <ph id="ph1">`NumericLib`</ph>-Klasse mit zwei Membern definiert: <ph id="ph2">`IsEven`</ph> und <ph id="ph3">`NearZero`</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>To package the two classes in a single assembly, you must compile them into modules.</source>
          <target state="translated">Um die beiden Klassen in einer einzelnen Assembly zu verpacken, müssen Sie sie in Module kompilieren.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>To compile the Visual Basic source code file into a module, use this command:</source>
          <target state="translated">Verwenden Sie zum Kompilieren der Visual Basic-Quellcodedatei in einem Modul folgenden Befehl:</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>To compile the C# source code file into a module, use this command:</source>
          <target state="translated">Verwenden Sie zum Kompilieren der C#-Quellcodedatei in einem Modul folgenden Befehl:</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>You then use the Link tool (Link.exe) to compile the two modules into an assembly:</source>
          <target state="translated">Verwenden Sie dann das Linktool (Link.exe), um die beiden Module in eine Assembly zu kompilieren:</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>The following example then calls the <ph id="ph1">`NumericLib.NearZero`</ph> and <ph id="ph2">`StringLib.ToTitleCase`</ph> methods.</source>
          <target state="translated">Das folgende Beispiel ruft dann die <ph id="ph1">`NumericLib.NearZero`</ph>-Methode und die <ph id="ph2">`StringLib.ToTitleCase`</ph>-Methode auf.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>Note that both the Visual Basic code and the C# code are able to access the methods in both classes.</source>
          <target state="translated">Beachten Sie, dass sowohl der Visual Basic-Code als auch der C#-Code auf die Methoden in beiden Klassen zugreifen können.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>To compile the Visual Basic code, use this command:</source>
          <target state="translated">Verwenden Sie zum Kompilieren des Visual Basic-Codes folgenden Befehl:</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>To compile with C#, change the name of the compiler from vbc to csc, and change the file extension from .vb to .cs:</source>
          <target state="translated">Zum Kompilieren mit C# ändern Sie den Namen des Compilers von vbc in csc und die Dateierweiterung von „.vb“ in „.cs“:</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>