<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d27c8c68ea49f150fa0ae5c5c8b437c8c42c9c90</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\grouping.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2017a86039e285c3f7e84539ab1e03b25993ee39</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7b92eefc164c45f986532643547fc46ea2def520</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file grouping.33793cd2e6bf04d024a452f85e13089b2709b3dd.de-de.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">Gruppierungskonstrukte in regulären Ausdrücken</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">Gruppierungskonstrukte in regulären Ausdrücken</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">Gruppierungskonstrukte in regulären Ausdrücken</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</source>
          <target state="translated">Gruppierungskonstrukte grenzen die Teilausdrücke eines regulären Ausdrucks ab und zeichnen die Teilzeichenfolgen einer Eingabezeichenfolge auf.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can use grouping constructs to do the following:</source>
          <target state="translated">Mit Gruppierungskonstrukten können Sie folgende Schritte ausführen:</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Match a subexpression that is repeated in the input string.</source>
          <target state="translated">Finden Sie eine Entsprechung für einen Teilausdruck, der in der Eingabezeichenfolge wiederholt wird.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Apply a quantifier to a subexpression that has multiple regular expression language elements.</source>
          <target state="translated">Wenden Sie einen Quantifizierer auf einen Teilausdruck an, der über mehrere reguläre Ausdruckssprachelemente verfügt.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more information about quantifiers, see <bpt id="p1">[</bpt>Quantifiers in regular expressions<ept id="p1">](quantifiers.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu Quantifizierern finden Sie unter <bpt id="p1">[</bpt>Quantifizierer in regulären Ausdrücken<ept id="p1">](quantifiers.md)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Include a subexpression in the string that is returned by the <bpt id="p1">[</bpt>Regex.Replace<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> and <bpt id="p2">[</bpt>Match.Result<ept id="p2">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> methods.</source>
          <target state="translated">Schließen Sie einen Teilausdruck in die Zeichenfolge ein, die von den <bpt id="p1">[</bpt>Regex.Replace<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept>- und <bpt id="p2">[</bpt>Match.Result<ept id="p2">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept>-Methoden zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Retrieve individual subexpressions from the <bpt id="p1">[</bpt>Match.Groups<ept id="p1">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property and process them separately from the matched text as a whole.</source>
          <target state="translated">Rufen Sie einzelne Teilausdrücke aus der <bpt id="p1">[</bpt>Match.Groups<ept id="p1">](xref:System.Text.RegularExpressions.Match.Groups)</ept>-Eigenschaft ab, und verarbeiten Sie sie getrennt vom entsprechenden Text als Ganzes.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following table lists the grouping constructs supported by .NET regular expression engine and indicates whether they are capturing or non-capturing.</source>
          <target state="translated">Die folgende Tabelle führt die Gruppierungskonstrukte auf, die von dem .NET-Modul für reguläre Ausdrücke unterstützt werden, und gibt an, ob sie erfassend oder nicht erfassend sind.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Grouping construct</source>
          <target state="translated">Gruppierungskonstrukt</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Capturing or noncapturing</source>
          <target state="translated">Erfassend oder nicht erfassend</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Matched subexpressions<ept id="p1">](#matched-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Übereinstimmende Teilausdrücke<ept id="p1">](#matched-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">Wird erfasst</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Named matched subexpressions<ept id="p1">](#named-matched-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Benannte übereinstimmende Teilausdrücke<ept id="p1">](#named-matched-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">Wird erfasst</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Balancing group definitions<ept id="p1">](#balancing-group-definitions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Ausgleichsgruppendefinitionen<ept id="p1">](#balancing-group-definitions)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">Wird erfasst</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Noncapturing groups<ept id="p1">](#noncapturing-groups)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Nicht erfassende Gruppen<ept id="p1">](#noncapturing-groups)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Nicht erfassend</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Group options<ept id="p1">](#group-options)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Gruppenoptionen<ept id="p1">](#group-options)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Nicht erfassend</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width positive lookahead assertions<ept id="p1">](#zero-width-positive-lookahead-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Positive Lookaheadassertionen mit einer Breite von null<ept id="p1">](#zero-width-positive-lookahead-assertions)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Nicht erfassend</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width negative lookahead assertions<ept id="p1">](#zero-width-negative-lookahead-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Negative Lookaheadassertionen mit einer Breite von null<ept id="p1">](#zero-width-negative-lookahead-assertions)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Nicht erfassend</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width positive lookbehind assertions<ept id="p1">](#zero-width-positive-lookbehind-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Positive Lookbehindassertionen mit einer Breite von null<ept id="p1">](#zero-width-positive-lookbehind-assertions)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Nicht erfassend</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width negative lookbehind assertions<ept id="p1">](#zero-width-negative-lookbehind-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Negative Lookbehindassertionen mit einer Breite von null<ept id="p1">](#zero-width-negative-lookbehind-assertions)</ept></target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Nicht erfassend</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nonbacktracking subexpressions<ept id="p1">](#nonbacktracking-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Nicht zurückverfolgende Teilausdrücke<ept id="p1">](#nonbacktracking-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">Nicht erfassend</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For information on groups and the regular expression object model, see <bpt id="p1">[</bpt>Grouping Constructs and Regular Expression Objects<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>.</source>
          <target state="translated">Weitere Informationen zu Gruppen und dem Objektmodell für reguläre Ausdrücke finden Sie unter <bpt id="p1">[</bpt>Gruppierungskonstrukte und Objekte für reguläre Ausdrücke<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Matched subexpressions</source>
          <target state="translated">Übereinstimmende Teilausdrücke</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following grouping construct captures a matched subexpression:</source>
          <target state="translated">Das folgende Gruppierungskonstrukt erfasst einen übereinstimmenden Teilausdruck:</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">Hierbei ist <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> ein beliebiges gültiges Muster für reguläre Ausdrücke.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</source>
          <target state="translated">Erfassungen, die Klammern verwenden, werden automatisch von links nach rechts und mit eins beginnend auf Grundlage der Reihenfolge der öffnenden runden Klammern im regulären Ausdruck aufgezählt.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The capture that is numbered zero is the text matched by the entire regular expression pattern.</source>
          <target state="translated">Die Erfassung, die mit 0 gekennzeichnet wird, ist der Text, dem das gesamte Muster für den regulären Ausdruck entspricht.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>By default, the (subexpression) language element captures the matched subexpression.</source>
          <target state="translated">Standardmäßig erfasst das Sprachelement „(Teilausdruck)“ den übereinstimmenden Teilausdruck.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>But if the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression (see Group options later in this topic), the matched subexpression is not captured.</source>
          <target state="translated">Wenn der RegexOptions-Parameter einer Methode für den Abgleich von Mustern für reguläre Ausdrücke das RegexOptions.ExplicitCapture-Flag enthält oder wenn die n-Option auf diesen Teilausdruck angewendet wird (siehe den Abschnitt zu Gruppenoptionen weiter unten in diesem Thema), wird der übereinstimmende Teilausdruck jedoch nicht erfasst.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can access captured groups in four ways:</source>
          <target state="translated">Für den Zugriff auf erfasste Gruppen gibt es vier Möglichkeiten:</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>By using the backreference construct within the regular expression.</source>
          <target state="translated">Indem das Rückverweiskonstrukt im regulären Ausdruck verwendet wird.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept>, where <ept id="p1">*</ept>number* is the ordinal number of the captured subexpression.</source>
          <target state="translated">Auf den übereinstimmenden Teilausdruck wird im gleichen regulären Ausdruck mithilfe der Syntax <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept> verwiesen, wobei <ept id="p1">*</ept>number* die Ordinalzahl des erfassten Teilausdrucks ist.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>By using the named backreference construct within the regular expression.</source>
          <target state="translated">Indem das benannte Rückverweiskonstrukt im regulären Ausdruck verwendet wird.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, where <bpt id="p4">*</bpt>name<ept id="p4">*</ept> is the name of a capturing group, or <bpt id="p5">**</bpt>\k<ept id="p5">**</ept><bpt id="p6">_</bpt>&lt;number<ept id="p6">_</ept><bpt id="p7">**</bpt><ph id="ph2">&gt;</ph><ept id="p7">**</ept>, where <bpt id="p8">*</bpt>number<ept id="p8">*</ept> is the ordinal number of a capturing group.</source>
          <target state="translated">Auf den übereinstimmenden Teilausdruck wird im gleichen regulären Ausdruck mithilfe der Syntax <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> verwiesen, wobei <bpt id="p4">*</bpt>name<ept id="p4">*</ept> der Name einer Erfassungsgruppe ist, oder mit <bpt id="p5">**</bpt>\k<ept id="p5">**</ept><bpt id="p6">_</bpt>&lt;number<ept id="p6">_</ept><bpt id="p7">**</bpt><ph id="ph2">&gt;</ph><ept id="p7">**</ept>, wobei <bpt id="p8">*</bpt>number<ept id="p8">*</ept> die Ordinalzahl einer Erfassungsgruppe ist.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A capturing group has a default name that is identical to its ordinal number.</source>
          <target state="translated">Eine Erfassungsgruppe weist einen Standardnamen auf, der mit der zugehörigen Ordinalzahl identisch ist.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For more information, see Grouping constructs and regular expression objects later in this topic.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt „Gruppierungskonstrukte und Objekte für reguläre Ausdrücke“ weiter unten in diesem Thema.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> replacement sequence in a <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p5">*</bpt>number<ept id="p5">*</ept> is the ordinal number of the captured subexpression.</source>
          <target state="translated">Mit der Ersatzsequenz <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> in einem <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept>- oder <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept>-Methodenaufruf, wobei <bpt id="p5">*</bpt>number<ept id="p5">*</ept> die Ordinalzahl des erfassten Teilausdrucks ist.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Programmatically, by using the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">Programmgesteuert mithilfe des <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept>-Objekts, das von der <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept>-Eigenschaft zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The member at position zero in the collection represents the entire regular expression match.</source>
          <target state="translated">Der Member auf der Nullposition in der Auflistung stellt die gesamte Übereinstimmung für einen regulären Ausdruck dar.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Each subsequent member represents a matched subexpression.</source>
          <target state="translated">Jeder nachfolgende Member stellt einen übereinstimmenden Teilausdruck dar.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Grouping Constructs and Regular Expression Objects<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept> section.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt <bpt id="p1">[</bpt>Gruppierungskonstrukte und Objekte für reguläre Ausdrücke<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that identifies duplicated words in text.</source>
          <target state="translated">Im folgenden Beispiel wird ein regulärer Ausdruck veranschaulicht, der doppelte Wörter im Text identifiziert.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</source>
          <target state="translated">Die zwei Erfassungsgruppen des Musters eines regulären Ausdrucks stellen die zwei Instanzen des doppelten Worts dar.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The second instance is captured to report its starting position in the input string.</source>
          <target state="translated">Die zweite Instanz wird erfasst, um die Anfangsposition in der Eingabezeichenfolge zu melden.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is the following:</source>
          <target state="translated">Das Muster für den reguläre Ausdruck lautet folgendermaßen:</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Übereinstimmung mit mindestens einem Wortzeichen.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Dies ist die erste Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Entsprechung für ein Leerraumzeichen finden.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Match the string in the first captured group.</source>
          <target state="translated">Suchen Sie nach einer Entsprechung für die Zeichenfolge in der ersten erfassten Gruppe.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">Dies ist die zweite Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the <ph id="ph1">`Match.Index`</ph> property.</source>
          <target state="translated">Im Beispiel wird sie einer erfassten Gruppe zugewiesen, damit die Anfangsposition des doppelten Worts von der <ph id="ph1">`Match.Index`</ph>-Eigenschaft abgerufen werden kann.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Match a non-word character, including white space and punctuation.</source>
          <target state="translated">Finden Sie eine Entsprechung für ein Nichtwortzeichen, einschließlich Leerzeichen und Interpunktion.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</source>
          <target state="translated">Dies verhindert, dass für das Muster eines regulären Ausdrucks eine Entsprechung für ein Wort gefunden wird, das mit dem Wort von der zuerst erfassten Gruppe beginnt.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Named matched subexpressions</source>
          <target state="translated">Benannte übereinstimmende Teilausdrücke</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following grouping construct captures a matched subexpression and lets you access it by name or by number:</source>
          <target state="translated">Das folgende Gruppierungskonstrukt erfasst einen übereinstimmenden Teilausdruck und ermöglicht den Zugriff nach Name oder Zahl:</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">oder:</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is a valid group name, and <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">Hierbei ist <bpt id="p1">*</bpt>name<ept id="p1">*</ept> ein gültiger Gruppenname, und <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> ist ein beliebiges gültiges Muster für reguläre Ausdrücke.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>name<ept id="p1">*</ept> must not contain any punctuation characters and cannot begin with a number.</source>
          <target state="translated"><bpt id="p1">*</bpt>name<ept id="p1">*</ept> darf keine Interpunktionszeichen enthalten und nicht mit einer Zahl beginnen.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> parameter of a regular expression pattern matching method includes the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> flag, or if the <bpt id="p3">**</bpt>n<ept id="p3">**</ept> option is applied to this subexpression (see <bpt id="p4">[</bpt>Group options<ept id="p4">](#group-options)</ept> later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</source>
          <target state="translated">Wenn der <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept>-Parameter einer Methode für den Abgleich von Mustern für reguläre Ausdrücke das <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>-Flag enthält oder wenn die <bpt id="p3">**</bpt>n<ept id="p3">**</ept>-Option auf diesen Teilausdruck angewendet wird (siehe den Abschnitt <bpt id="p4">[</bpt>Gruppenoptionen<ept id="p4">](#group-options)</ept> weiter unten in diesem Thema), besteht die einzige Möglichkeit zur Erfassung eines Teilausdrucks in der expliziten Benennung von Erfassungsgruppen.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can access named captured groups in the following ways:</source>
          <target state="translated">Sie können wie folgt auf benannte erfasste Gruppen zugreifen:</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>By using the named backreference construct within the regular expression.</source>
          <target state="translated">Indem das benannte Rückverweiskonstrukt im regulären Ausdruck verwendet wird.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, where <bpt id="p4">*</bpt>name<ept id="p4">*</ept> is the name of the captured subexpression.</source>
          <target state="translated">Auf den übereinstimmenden Teilausdruck wird im gleichen regulären Ausdruck mithilfe der Syntax <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> verwiesen, wobei <bpt id="p4">*</bpt>name<ept id="p4">*</ept> der Name des erfassten Teilausdrucks ist.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>By using the backreference construct within the regular expression.</source>
          <target state="translated">Indem das Rückverweiskonstrukt im regulären Ausdruck verwendet wird.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept>, where <ept id="p1">*</ept>number* is the ordinal number of the captured subexpression.</source>
          <target state="translated">Auf den übereinstimmenden Teilausdruck wird im gleichen regulären Ausdruck mithilfe der Syntax <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept> verwiesen, wobei <ept id="p1">*</ept>number* die Ordinalzahl des erfassten Teilausdrucks ist.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</source>
          <target state="translated">Benannte übereinstimmende Teilausdrücke werden hintereinander von links nach rechts nach übereinstimmenden Teilausdrücken nummeriert.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt>${<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> replacement sequence in a <bpt id="p4">[</bpt>Regex.Replace<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p5">[</bpt>Match.Result<ept id="p5">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p6">*</bpt>name<ept id="p6">*</ept> is the name of the captured subexpression.</source>
          <target state="translated">Mit der Ersatzsequenz <bpt id="p1">**</bpt>${<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> in einem <bpt id="p4">[</bpt>Regex.Replace<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept>- oder <bpt id="p5">[</bpt>Match.Result<ept id="p5">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept>-Methodenaufruf, wobei <bpt id="p6">*</bpt>name<ept id="p6">*</ept> der Name des erfassten Teilausdrucks ist.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> replacement sequence in a <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p5">*</bpt>number<ept id="p5">*</ept> is the ordinal number of the captured subexpression.</source>
          <target state="translated">Mit der Ersatzsequenz <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> in einem <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept>- oder <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept>-Methodenaufruf, wobei <bpt id="p5">*</bpt>number<ept id="p5">*</ept> die Ordinalzahl des erfassten Teilausdrucks ist.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Programmatically, by using the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">Programmgesteuert mithilfe des <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept>-Objekts, das von der <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept>-Eigenschaft zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The member at position zero in the collection represents the entire regular expression match.</source>
          <target state="translated">Der Member auf der Nullposition in der Auflistung stellt die gesamte Übereinstimmung für einen regulären Ausdruck dar.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Each subsequent member represents a matched subexpression.</source>
          <target state="translated">Jeder nachfolgende Member stellt einen übereinstimmenden Teilausdruck dar.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Named captured groups are stored in the collection after numbered captured groups.</source>
          <target state="translated">Benannte erfasste Gruppen werden in der Auflistung nach nummerierten erfassten Gruppen gespeichert.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Programmatically, by providing the subexpression name to the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object's indexer  (in C#) or to its Item property (in Visual Basic).</source>
          <target state="translated">Programmgesteuert durch Bereitstellen des Teilausdrucknamens für den Indexer des <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept>-Objekts (in C#) oder für seine Item-Eigenschaft (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</source>
          <target state="translated">Ein einfaches Muster eines regulären Ausdrucks veranschaulicht, wie auf nummerierte (unbenannte) und benannte Gruppen entweder programmgesteuert oder mit der Sprachsyntax für reguläre Ausdrücke verwiesen werden kann.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`((?&lt;One&gt;abc)\d+)?(?&lt;Two&gt;xyz)(.*)`</ph> produces the following capturing groups by number and by name.</source>
          <target state="translated">Der reguläre Ausdruck <ph id="ph1">`((?&lt;One&gt;abc)\d+)?(?&lt;Two&gt;xyz)(.*)`</ph> generiert die folgenden Erfassungsgruppen nach Nummer und Name.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The first capturing group (number 0) always refers to the entire pattern.</source>
          <target state="translated">Die erste Erfassungsgruppe (Nummer 0) bezieht sich stets auf das gesamte Muster.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Nummer</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>0 (default name)</source>
          <target state="translated">0 (Standardname)</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>1 (default name)</source>
          <target state="translated">1 (Standardname)</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>2 (default name)</source>
          <target state="translated">2 (Standardname)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>One</source>
          <target state="translated">Eins</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Two</source>
          <target state="translated">Zwei</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</source>
          <target state="translated">Im folgenden Beispiel wird ein regulärer Ausdruck veranschaulicht, der duplizierte Wörter sowie das Wort, das jedem duplizierten Wort direkt folgt, identifiziert.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The regular expression pattern defines two named subexpressions: <ph id="ph1">`duplicateWord`</ph>, which represents the duplicated word; and <ph id="ph2">`nextWord`</ph>, which represents the word that follows the duplicated word.</source>
          <target state="translated">Das Muster eines regulären Ausdrucks definiert zwei benannte Teilausdrücke: <ph id="ph1">`duplicateWord`</ph>, der das doppelte Wort darstellt; und <ph id="ph2">`nextWord`</ph>, der das Wort darstellt, das auf das doppelte Wort folgt.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is as follows:</source>
          <target state="translated">Das Muster für den reguläre Ausdruck lautet folgendermaßen:</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression is interpreted.</source>
          <target state="translated">In der folgenden Tabelle wird gezeigt, wie der reguläre Ausdruck interpretiert wird.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Übereinstimmung mit mindestens einem Wortzeichen.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`duplicateWord`</ph>.</source>
          <target state="translated">Geben Sie für die Erfassungsgruppe <ph id="ph1">`duplicateWord`</ph> als Namen an.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Entsprechung für ein Leerraumzeichen finden.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Match the string from the captured group that is named <ph id="ph1">`duplicateWord`</ph>.</source>
          <target state="translated">Suchen Sie nach einer Entsprechung der Zeichenfolge der erfassten Gruppe mit der Bezeichnung <ph id="ph1">`duplicateWord`</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match a non-word character, including white space and punctuation.</source>
          <target state="translated">Finden Sie eine Entsprechung für ein Nichtwortzeichen, einschließlich Leerzeichen und Interpunktion.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</source>
          <target state="translated">Dies verhindert, dass für das Muster eines regulären Ausdrucks eine Entsprechung für ein Wort gefunden wird, das mit dem Wort von der zuerst erfassten Gruppe beginnt.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Übereinstimmung mit mindestens einem Wortzeichen.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`nextWord`</ph>.</source>
          <target state="translated">Geben Sie für die Erfassungsgruppe <ph id="ph1">`nextWord`</ph> als Namen an.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Note that a group name can be repeated in a regular expression.</source>
          <target state="translated">Beachten Sie, dass der Name einer Gruppe in einem regulären Ausdruck wiederholt werden kann.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>For example, it is possible for more than one group to be named <ph id="ph1">`digit`</ph>, as the following example illustrates.</source>
          <target state="translated">Beispielsweise ist es möglich, dass mehr als eine Gruppe den Namen <ph id="ph1">`digit`</ph> trägt, wie im folgenden Beispiel veranschaulicht wird.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>In the case of duplicate names, the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object is determined by the last successful capture in the input string.</source>
          <target state="translated">Im Fall von doppelten Namen wird der Wert des <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>-Objekts durch die letzte erfolgreiche Erfassung in der Eingabezeichenfolge bestimmt.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>In addition, the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> is populated with information about each capture just as it would be if the group name was not duplicated.</source>
          <target state="translated">Darüber hinaus wird <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> mit Informationen über jede Erfassung aufgefüllt, genauso, wie es der Fall wäre, wenn der Gruppenname nicht dupliziert wäre.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression <ph id="ph1">`\D+(?&lt;digit&gt;\d+)\D+(?&lt;digit&gt;\d+)?`</ph> includes two occurrences of a group named <ph id="ph2">`digit`</ph>.</source>
          <target state="translated">Im folgenden Beispiel umfasst der reguläre Ausdruck <ph id="ph1">`\D+(?&lt;digit&gt;\d+)\D+(?&lt;digit&gt;\d+)?`</ph> zwei Vorkommen einer Gruppe namens <ph id="ph2">`digit`</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The first <ph id="ph1">`digit`</ph> named group captures one or more digit characters.</source>
          <target state="translated">Die erste mit <ph id="ph1">`digit`</ph> benannte Gruppe erfasst ein oder mehrere Ziffernzeichen.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The second <ph id="ph1">`digit`</ph> named group captures either zero or one occurrence of one or more digit characters.</source>
          <target state="translated">Die zweite mit <ph id="ph1">`digit`</ph> benannte Gruppe erfasst entweder null oder ein Vorkommen von einem oder mehreren Ziffernzeichen.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object.</source>
          <target state="translated">Wie die Ausgabe des Beispiels zeigt, definiert der Wert dieses Texts, wenn die zweite Erfassungsgruppe erfolgreich mit Text übereinstimmt, den Wert des <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>-Objekts.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object.</source>
          <target state="translated">Wenn die zweite Erfassungsgruppe nicht der Eingabezeichenfolge entspricht, definiert der Wert der letzten erfolgreichen Übereinstimmung den Wert des <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>-Objekts.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression is interpreted.</source>
          <target state="translated">In der folgenden Tabelle wird gezeigt, wie der reguläre Ausdruck interpretiert wird.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Match one or more non-decimal digit characters.</source>
          <target state="translated">Übereinstimmung mit einem oder mehreren Nichtdezimal-Ziffernzeichen.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digit characters.</source>
          <target state="translated">Übereinstimmung mit einem oder mehreren Dezimalziffernzeichen.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Assign the match to the <ph id="ph1">`digit`</ph> named group.</source>
          <target state="translated">Weisen Sie die Übereinstimmung der Gruppe namens <ph id="ph1">`digit`</ph> zu.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Match one or more non-decimal digit characters.</source>
          <target state="translated">Übereinstimmung mit einem oder mehreren Nichtdezimal-Ziffernzeichen.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of one or more decimal digit characters.</source>
          <target state="translated">Übereinstimmung mit keinem oder einem Vorkommen mindestens eines Dezimalziffernzeichens.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Assign the match to the <ph id="ph1">`digit`</ph> named group.</source>
          <target state="translated">Weisen Sie die Übereinstimmung der Gruppe namens <ph id="ph1">`digit`</ph> zu.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Balancing group definitions</source>
          <target state="translated">Ausgleichen von Gruppendefinitionen</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</source>
          <target state="translated">Eine Ausgleichsgruppendefinition löscht die Definition einer zuvor definierten Gruppe und speichert in der aktuellen Gruppe das Intervall zwischen der zuvor definierten Gruppe und der aktuellen Gruppe.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>This grouping construct has the following format:</source>
          <target state="translated">Dieses Gruppierungskonstrukt besitzt das folgende Format:</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">oder:</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> is the current group (optional), <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> is a previously defined group, and <bpt id="p3">*</bpt>subexpression<ept id="p3">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">Hierbei ist <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> die aktuelle Gruppe (optional), <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> eine zuvor definierte Gruppe und <bpt id="p3">*</bpt>subexpression<ept id="p3">*</ept> ein beliebiges gültiges Muster für reguläre Ausdrücke.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The balancing group definition deletes the definition of <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> and stores the interval between <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> and <bpt id="p3">*</bpt>name1<ept id="p3">*</ept> in <bpt id="p4">*</bpt>name1<ept id="p4">*</ept>.</source>
          <target state="translated">Die Ausgleichsgruppendefinition löscht die Definition von <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> und speichert das Intervall zwischen <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> und <bpt id="p3">*</bpt>name1<ept id="p3">*</ept> in <bpt id="p4">*</bpt>name1<ept id="p4">*</ept>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>If no <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> group is defined, the match backtracks.</source>
          <target state="translated">Wenn keine <bpt id="p1">*</bpt>name2<ept id="p1">*</ept>-Gruppe definiert ist, wird die Übereinstimmung zurückverfolgt.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Because deleting the last definition of <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> reveals the previous definition of <bpt id="p2">*</bpt>name2<ept id="p2">*</ept>, this construct lets you use the stack of captures for group <bpt id="p3">*</bpt>name2<ept id="p3">*</ept> as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</source>
          <target state="translated">Da durch Löschen der letzten Definition von <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> die vorherige Definition von <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> angezeigt wird, kann mithilfe dieses Konstrukts der Erfassungsstapel für die <bpt id="p3">*</bpt>name2<ept id="p3">*</ept>-Gruppe als Zähler für die Nachverfolgung von geschachtelten Konstrukten, z.B. Anführungszeichen oder öffnende bzw. schließende Klammern, verwendet werden.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The balancing group definition uses <bpt id="p1">*</bpt>name2<ept id="p1">*</ept>as a stack.</source>
          <target state="translated">Die Ausgleichsgruppendefinition verwendet <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> als Stapel.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The beginning character of each nested construct is placed in the group and in its <bpt id="p1">[</bpt>Group.Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collection.</source>
          <target state="translated">Das Anfangszeichen jedes geschachtelten Konstrukts wird in die Gruppe sowie in die zugehörige <bpt id="p1">[</bpt>Group.Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept>-Auflistung eingefügt.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>When the closing character is matched, its corresponding opening character is removed from the group, and the <bpt id="p1">[</bpt>Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collection is decreased by one.</source>
          <target state="translated">Wenn das schließende Zeichen abgeglichen wird, wird das entsprechende öffnende Zeichen aus der Gruppe entfernt, und die <bpt id="p1">[</bpt>Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept>-Auflistung wird um eins verringert.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>After the opening and closing characters of all nested constructs have been matched, <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> is empty.</source>
          <target state="translated">Nachdem die öffnenden und schließenden Zeichen aller geschachtelten Konstrukte abgeglichen wurden, ist <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> leer.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</source>
          <target state="translated">Nachdem Sie den regulären Ausdruck im folgenden Beispiel geändert haben, sodass er die entsprechenden öffnenden und schließenden Zeichen eines geschachtelten Konstrukts enthält, können Sie diesen zur Behandlung der meisten geschachtelten Konstrukte verwenden, z. B. für mathematische Ausdrücke oder Programmcodezeilen, die mehrere geschachtelte Methodenaufrufe enthalten.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The following example uses a balancing group definition to match left and right angle brackets (&lt;&gt;) in an input string.</source>
          <target state="translated">Das folgende Codebeispiel verwendet eine Ausgleichsgruppendefinition, um in einer Eingabezeichenfolge nach öffnenden und schließenden spitzen Klammern (&lt;&gt;) zu suchen.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The example defines two named groups, <ph id="ph1">`Open`</ph> and <ph id="ph2">`Close`</ph>, that are used like a stack to track matching pairs of angle brackets.</source>
          <target state="translated">Im Beispiel werden zwei benannte Gruppen, <ph id="ph1">`Open`</ph> und <ph id="ph2">`Close`</ph>, definiert, die wie ein Stapel verwendet werden, um übereinstimmende Paare von spitzen Klammern nachzuverfolgen.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Each captured left angle bracket is pushed into the capture collection of the <ph id="ph1">`Open`</ph> group, and each captured right angle bracket is pushed into the capture collection of the <ph id="ph2">`Close`</ph> group.</source>
          <target state="translated">Jede erfasste öffnende spitze Klammer wird in die Erfassungsauflistung der <ph id="ph1">`Open`</ph>-Gruppe eingefügt, und jede erfasste schließende spitze Klammer wird in die Erfassungsauflistung der <ph id="ph2">`Close`</ph>-Gruppe eingefügt.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</source>
          <target state="translated">Die Ausgleichsgruppendefinition stellt sicher, dass es eine entsprechende schließende spitze Klammer für jede öffnende spitze Klammer gibt.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>If there is not, the final subpattern, <ph id="ph1">`(?(Open)(?!))`</ph>, is evaluated only if the <ph id="ph2">`Open`</ph> group is not empty (and, therefore, if all nested constructs have not been closed).</source>
          <target state="translated">Trifft dies nicht zu, wird das abschließende Teilmuster, <ph id="ph1">`(?(Open)(?!))`</ph>, nur ausgewertet, wenn die <ph id="ph2">`Open`</ph>-Gruppe nicht leer ist (und wenn alle geschachtelten Konstrukte nicht geschlossen wurden).</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>If the final subpattern is evaluated, the match fails, because the <ph id="ph1">`(?!)`</ph> subpattern is a zero-width negative lookahead assertion that always fails.</source>
          <target state="translated">Wenn das endgültige Teilmuster ausgewertet wird, schlägt die Übereinstimmung fehl, da das <ph id="ph1">`(?!)`</ph> Teilmuster eine negative Lookaheadassertion mit einer Breite von 0 (null) ist, die immer fehlschlägt.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is:</source>
          <target state="translated">Das Muster des regulären Ausdrucks lautet:</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The regular expression is interpreted as follows:</source>
          <target state="translated">Der reguläre Ausdruck wird wie folgt interpretiert:</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Begin at the start of the string.</source>
          <target state="translated">Starten Sie am Beginn der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Match zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">Finden Sie eine Entsprechung für null oder mehr Zeichen, die keine linken oder rechten spitzen Klammern sind.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Match a left angle bracket and assign it to a group named <ph id="ph1">`Open`</ph>.</source>
          <target state="translated">Suchen Sie eine Übereinstimmung für ein kleiner als-Zeichen, und weisen Sie es einer Gruppe mit dem Namen <ph id="ph1">`Open`</ph> zu.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Match zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">Finden Sie eine Entsprechung für null oder mehr Zeichen, die keine linken oder rechten spitzen Klammern sind.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">Finden Sie eine Entsprechung für ein oder mehr Vorkommen einer linken spitzen Klammer, gefolgt von null oder mehr Zeichen, die keine linken oder rechten spitzen Klammern sind.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">Dies ist die zweite Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Match a right angle bracket, assign the substring between the <ph id="ph1">`Open`</ph> group and the current group to the <ph id="ph2">`Close`</ph> group, and delete the definition of the <ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">Finden Sie eine Entsprechung für eine öffnende spitze Klammer, weisen Sie die Teilzeichenfolge zwischen der <ph id="ph1">`Open`</ph>-Gruppe und der aktuellen Gruppe der <ph id="ph2">`Close`</ph>-Gruppe zu, und löschen Sie die Definition der <ph id="ph3">`Open`</ph>-Gruppe.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of any character that is neither a left nor a right angle bracket.</source>
          <target state="translated">Sucht eine Übereinstimmung mit null oder mehr Vorkommen eines Zeichens, das weder eine linke noch eine rechte spitze Klammer ist.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</source>
          <target state="translated">Finden Sie eine Entsprechung für ein oder mehr Vorkommen einer rechten spitzen Klammer, gefolgt von einem die oft ausgegebene Befehlszeilen  Zeichen, das weder eine linke noch eine rechte spitze Klammern ist.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>When matching the right angle bracket, assign the substring between the <ph id="ph1">`Open`</ph> group and the current group to the <ph id="ph2">`Close`</ph> group, and delete the definition of the<ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">Wenn die rechte spitze Klammer zugeordnet wird, wird die Teilzeichenfolge zwischen der <ph id="ph1">`Open`</ph>-Gruppe und der aktuellen Gruppe der <ph id="ph2">`Close`</ph>-Gruppe zugewiesen, und die Definition der <ph id="ph3">`Open`</ph>-Gruppe wird gelöscht.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>This is the third capturing group.</source>
          <target state="translated">Dies ist die dritte Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</source>
          <target state="translated">Finden Sie eine Entsprechung für null oder mehr Vorkommen des folgenden Musters: ein oder mehr Vorkommen einer linken spitzen Klammer, gefolgt von null oder mehr Zeichen, die keine spitzen Klammern sind, gefolgt von einem oder mehr Vorkommen einer rechten spitzen Klammer, gefolgt von null oder mehr Vorkommen von nicht spitzen Klammern.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>When matching the right angle bracket, delete the definition of the <ph id="ph1">`Open`</ph> group, and assign the substring between the <ph id="ph2">`Open`</ph> group and the current group to the <ph id="ph3">`Close`</ph> group.</source>
          <target state="translated">Löschen Sie beim Abgleichen der schließenden spitzen Klammer die Definition der <ph id="ph1">`Open`</ph>-Gruppe, und weisen Sie der <ph id="ph2">`Open`</ph>-Gruppe die Teilzeichenfolge zwischen der <ph id="ph3">`Close`</ph>-Gruppe und der aktuellen Gruppe zu.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Dies ist die erste Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Open`</ph> group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</source>
          <target state="translated">Wenn die <ph id="ph1">`Open`</ph>-Gruppe vorhanden ist und eine leere Zeichenfolge abgeglichen werden kann, geben Sie die Übereinstimmung auf, erhöhen Sie dabei jedoch nicht die Position des Moduls für den regulären Ausdruch in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>This is a zero-width negative lookahead assertion.</source>
          <target state="translated">Dies ist eine negative Lookaheadassertion mit einer Breite von Null.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Because an empty string is always implicitly present in an input string, this match always fails.</source>
          <target state="translated">Da eine leere Zeichenfolge in einer Eingabezeichenfolge immer implizit vorhanden ist, schlägt diese Übereinstimmung immer fehl.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Failure of this match indicates that the angle brackets are not balanced.</source>
          <target state="translated">Das Fehlschlagen dieser Übereinstimmung weist darauf hin, dass die spitzen Klammern nicht ausgeglichen sind.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Match the end of the input string.</source>
          <target state="translated">Entsprechung für das Ende der Eingabezeichenfolge finden.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The final subexpression, <ph id="ph1">`(?(Open)(?!))`</ph>, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</source>
          <target state="translated">Der abschließende Teilausdruck, <ph id="ph1">`(?(Open)(?!))`</ph>, gibt an, ob die Schachtelungskonstrukte in der Eingabezeichenfolge ausgeglichen sind (z. B. ob jeder öffnenden spitzen Klammer eine entsprechende schließende spitze Klammer zugeordnet ist).</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>It uses conditional matching based on a valid captured group; for more information, see <bpt id="p1">[</bpt>Alternation constructs in regular expressions<ept id="p1">](alternation.md)</ept>.</source>
          <target state="translated">Dabei wird eine bedingte Übereinstimmung auf Grundlage einer gültigen erfassten Gruppe verwendet. Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Alternierungskonstrukte in regulären Ausdrücken<ept id="p1">](alternation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Open`</ph> group is defined, the regular expression engine attempts to match the subexpression <ph id="ph2">`(?!)`</ph> in the input string.</source>
          <target state="translated">Wenn die <ph id="ph1">`Open`</ph>-Gruppe definiert ist, versucht das Modul für reguläre Ausdrücke, eine Entsprechung für den <ph id="ph2">`(?!)`</ph>-Teilausdruck in der Eingabezeichenfolge zu finden.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group should be defined only if nesting constructs are unbalanced.</source>
          <target state="translated">Die <ph id="ph1">`Open`</ph>-Gruppe sollte nur definiert werden, wenn Schachtelungskonstrukte nicht ausgeglichen sind.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</source>
          <target state="translated">Daher sollte das in der Eingabezeichenfolge zu findende Muster immer dazu führen, dass die Übereinstimmung fehlschlägt.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In this case, <ph id="ph1">`(?!)`</ph> is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</source>
          <target state="translated">In diesem Fall ist <ph id="ph1">`(?!)`</ph> eine negative Lookaheadassertion mit einer Breite von Null, die immer fehlschlägt, da eine leere Zeichenfolge immer an der nächsten Position in der Eingabezeichenfolge implizit vorhanden ist.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>In the example, the regular expression engine evaluates the input string "<ph id="ph1">&lt;abc&gt;</ph>&lt;mno<ph id="ph2">&lt;xyz&gt;</ph>&gt;" as shown in the following table.</source>
          <target state="translated">Im Beispiel wertet das Modul für reguläre Ausdrücke die Eingabezeichenfolge „<ph id="ph1">&lt;abc&gt;</ph>&lt;mno<ph id="ph2">&lt;xyz&gt;</ph>&gt;“ wie in der folgenden Tabelle gezeigt aus.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Step</source>
          <target state="translated">Schritt</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Ergebnis</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Starts the match at the beginning of the input string</source>
          <target state="translated">Beginnt den Abgleich am Anfang der Eingabezeichenfolge</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters before the left angle bracket;finds no matches.</source>
          <target state="translated">Sucht vor der öffnenden spitzen Klammer nach Zeichen, die keine spitzen Klammern sind; findet keine Übereinstimmungen.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;abc&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">Findet eine Übereinstimmung mit der linken spitzen Klammer in „<ph id="ph1">&lt;abc&gt;</ph>“ und weist sie der <ph id="ph2">`Open`</ph>-Gruppe zu.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Matches "abc".</source>
          <target state="translated">Entspricht "abc".</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="translated">5</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>"&lt;abc" is the value of the second captured group.</source>
          <target state="translated">"&lt;abc" ist der Wert der zweiten erfassten Gruppe.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Das nächste Zeichen in der Eingabezeichenfolge ist keine öffnende spitze Klammer. Deshalb führt das Modul für reguläre Ausdrücke keine Schleife zurück zum <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph>-Teilmuster aus.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>6</source>
          <target state="translated">6</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Matches the right angle bracket in "<ph id="ph1">&lt;abc&gt;</ph>", assigns "abc", which is the substring between the <ph id="ph2">`Open`</ph> group and the right angle bracket, to the <ph id="ph3">`Close`</ph> group, and deletes the current value ("&lt;") of the <ph id="ph4">`Open`</ph> group, leaving it empty.</source>
          <target state="translated">Findet eine Übereinstimmung mit der rechten spitzen Klammer in „<ph id="ph1">&lt;abc&gt;</ph>“, weist „abc“ (die Teilzeichenfolge zwischen der <ph id="ph2">`Open`</ph>-Gruppe und der rechten spitzen Klammer) der <ph id="ph3">`Close`</ph>-Gruppe zu und löscht den aktuellen Wert („&lt;“) der <ph id="ph4">`Open`</ph>-Gruppe, der dann leer bleibt.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>7</source>
          <target state="translated">7</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters after the right angle bracket; finds no matches.</source>
          <target state="translated">Sucht nach der schließenden spitzen Klammer nach Zeichen, die keine spitzen Klammern sind; findet keine Übereinstimmungen.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>8</source>
          <target state="translated">8</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">Der Wert der dritten erfassten Gruppe ist "&gt;".</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Das nächste Zeichen in der Eingabezeichenfolge ist keine schließende spitze Klammer. Deshalb führt das Modul für reguläre Ausdrücke keine Schleife zurück zum <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph>-Teilmuster aus.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>9</source>
          <target state="translated">9</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The value of the first captured group is "<ph id="ph1">&lt;abc&gt;</ph>".</source>
          <target state="translated">Der Wert der ersten erfassten Gruppe ist „<ph id="ph1">&lt;abc&gt;</ph>“.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The next character in the input string is a left angle bracket, so the regular expression engine loops back to the <ph id="ph1">`(((?'Open'&lt;)`</ph> subpattern.</source>
          <target state="translated">Das nächste Zeichen in der Eingabezeichenfolge ist eine linke spitze Klammer, weshalb das Modul für reguläre Ausdrücke eine Schleife zurück zum <ph id="ph1">`(((?'Open'&lt;)`</ph>-Teilmuster ausführt.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>10</source>
          <target state="translated">10</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;mno&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">Findet eine Übereinstimmung mit der linken spitzen Klammer in „<ph id="ph1">&lt;mno&gt;</ph>“ und weist sie der <ph id="ph2">`Open`</ph>-Gruppe zu.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`Group.Captures`</ph> collection now has a single value, "&lt;".</source>
          <target state="translated">Die <ph id="ph1">`Group.Captures`</ph>-Auflistung verfügt jetzt über einen einzelnen Wert "&lt;".</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>11</source>
          <target state="translated">11</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Matches "mno".</source>
          <target state="translated">Entspricht "mno".</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>12</source>
          <target state="translated">12</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>"&lt;mno" is the value of the second captured group.</source>
          <target state="translated">"&lt;mno" ist der Wert der zweiten erfassten Gruppe.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The next character in the input string is an left angle bracket, so the regular expression engine loops back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Das nächste Zeichen in der Eingabezeichenfolge ist eine öffnende spitze Klammer, weshalb das Modul für reguläre Ausdrücke eine Schleife zurück zum <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph>-Teilmuster ausführt.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>13</source>
          <target state="translated">13</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;xyz&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">Findet eine Übereinstimmung mit der linken spitzen Klammer in „<ph id="ph1">&lt;xyz&gt;</ph>“ und weist sie der <ph id="ph2">`Open`</ph>-Gruppe zu.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Group.Captures`</ph> collection of the <ph id="ph2">`Open`</ph> group now includes two captures: the left angle bracket from "<ph id="ph3">&lt;mno&gt;</ph>", and the left angle bracket from "<ph id="ph4">&lt;xyz&gt;</ph>".</source>
          <target state="translated">Die <ph id="ph1">`Group.Captures`</ph>-Auflistung der <ph id="ph2">`Open`</ph>-Gruppe schließt jetzt zwei Erfassungen ein: die linke spitze Klammer von „<ph id="ph3">&lt;mno&gt;</ph>“ und die linke spitze Klammer von „<ph id="ph4">&lt;xyz&gt;</ph>“.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Matches "xyz".</source>
          <target state="translated">Entspricht "xyz".</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>"&lt;xyz" is the value of the second captured group.</source>
          <target state="translated">"&lt;xyz" ist der Wert der zweiten erfassten Gruppe.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Das nächste Zeichen in der Eingabezeichenfolge ist keine öffnende spitze Klammer. Deshalb führt das Modul für reguläre Ausdrücke keine Schleife zurück zum <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph>-Teilmuster aus.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Matches the right angle bracket in "<ph id="ph1">&lt;xyz&gt;</ph>".</source>
          <target state="translated">Findet eine Übereinstimmung für die rechte spitze Klammer in „<ph id="ph1">&lt;xyz&gt;</ph>“.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>"xyz", assigns the substring between the <ph id="ph1">`Open`</ph> group and the right angle bracket to the <ph id="ph2">`Close`</ph> group, and deletes the current value of the <ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">„xyz“ weist die Teilzeichenfolge zwischen der <ph id="ph1">`Open`</ph>-Gruppe und der rechten spitzen Klammer der <ph id="ph2">`Close`</ph>-Gruppe zu und löscht den aktuellen Wert der <ph id="ph3">`Open`</ph>-Gruppe.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The value of the previous capture (the left angle bracket in "<ph id="ph1">&lt;mno&gt;</ph>") becomes the current value of the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">Der Wert der vorherigen Erfassung (die linke spitze Klammer in „<ph id="ph1">&lt;mno&gt;</ph>“) wird zum aktuellen Wert der <ph id="ph2">`Open`</ph>-Gruppe.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Captures`</ph> collection of the <ph id="ph2">`Open`</ph> group now includes a single capture, the left angle bracket from "<ph id="ph3">&lt;xyz&gt;</ph>".</source>
          <target state="translated">Die <ph id="ph1">`Captures`</ph>-Auflistung der <ph id="ph2">`Open`</ph>-Gruppe schließt jetzt eine einzelne Erfassung ein, die linke spitze Klammer von „<ph id="ph3">&lt;xyz&gt;</ph>“.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters; finds no matches.</source>
          <target state="translated">Sucht nach Zeichen, die keine spitzen Klammern sind; findet keine Übereinstimmungen.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">Der Wert der dritten erfassten Gruppe ist "&gt;".</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The next character in the input string is a right angle bracket, so the regular expression engine loops back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Das nächste Zeichen in der Eingabezeichenfolge ist eine schließende spitze Klammer, weshalb das Modul für reguläre Ausdrücke eine Schleife zurück zum <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph>-Teilmuster ausführt.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Matches the final right angle bracket in "xyz&gt;&gt;", assigns "mno<ph id="ph1">&lt;xyz&gt;</ph>" (the substring between the <ph id="ph2">`Open`</ph> group and the right angle bracket) to the <ph id="ph3">`Close`</ph> group, and deletes the current value of the <ph id="ph4">`Open`</ph> group.</source>
          <target state="translated">Findet eine Entsprechung für die abschließende rechte spitze Klammer in „xyz&gt;&gt;“, weist „mno<ph id="ph1">&lt;xyz&gt;</ph>“ (die Teilzeichenfolge zwischen der <ph id="ph2">`Open`</ph>-Gruppe und der rechten spitzen Klammer) der <ph id="ph3">`Close`</ph>-Gruppe zu und löscht den aktuellen Wert der <ph id="ph4">`Open`</ph>-Gruppe.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group is now empty.</source>
          <target state="translated">Die <ph id="ph1">`Open`</ph>-Gruppe ist jetzt leer.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>20</source>
          <target state="translated">20</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters; finds no matches.</source>
          <target state="translated">Sucht nach Zeichen, die keine spitzen Klammern sind; findet keine Übereinstimmungen.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>21</source>
          <target state="translated">21</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">Der Wert der dritten erfassten Gruppe ist "&gt;".</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">Das nächste Zeichen in der Eingabezeichenfolge ist keine schließende spitze Klammer. Deshalb führt das Modul für reguläre Ausdrücke keine Schleife zurück zum <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph>-Teilmuster aus.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>22</source>
          <target state="translated">22</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The value of the first captured group is "&lt;mno<ph id="ph1">&lt;xyz&gt;</ph>&gt;".</source>
          <target state="translated">Der Wert der ersten erfassten Gruppe ist „&lt;mno<ph id="ph1">&lt;xyz&gt;</ph>&gt;“.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(((?'Open'&lt;)`</ph> subpattern.</source>
          <target state="translated">Das nächste Zeichen in der Eingabezeichenfolge ist keine öffnende spitze Klammer. Deshalb führt das Modul für reguläre Ausdrücke keine Schleife zurück zum <ph id="ph1">`(((?'Open'&lt;)`</ph>-Teilmuster aus.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>23</source>
          <target state="translated">23</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group is not defined, so no match is attempted.</source>
          <target state="translated">Die <ph id="ph1">`Open`</ph>-Gruppe ist nicht definiert, sodass keine Übereinstimmung gesucht wird.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>24</source>
          <target state="translated">24</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Matches the end of the input string.</source>
          <target state="translated">Gleicht das Ende der Eingabezeichenfolge ab.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Noncapturing groups</source>
          <target state="translated">Nicht erfassende Gruppen</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The following grouping construct does not capture the substring that is matched by a subexpression:</source>
          <target state="translated">Das folgende Gruppierungskonstrukt erfasst nicht die Teilzeichenfolge, die zu einem Teilausdruck passt:</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">Hierbei ist <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> ein beliebiges gültiges Muster für reguläre Ausdrücke.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</source>
          <target state="translated">Das nicht erfassende Gruppenkonstrukt wird in der Regel verwendet, wenn ein Quantifizierer auf eine Gruppe angewendet wird, die von der Gruppe erfassten Teilzeichenfolgen jedoch nicht von Interesse sind.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
          <target state="translated">Wenn ein regulärer Ausdruck geschachtelte Gruppierungskonstrukte einschließt, gilt ein äußeres nicht erfassendes Gruppenkonstrukt nicht für die inneren geschachtelten Gruppenkonstrukte.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that includes noncapturing groups.</source>
          <target state="translated">Im folgenden Beispiel wird ein regulärer Ausdruck veranschaulicht, der nicht erfassende Gruppen einschließt.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Note that the output does not include any captured groups.</source>
          <target state="translated">Beachten Sie, dass die Ausgabe keine erfassten Gruppen einschließt.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`(?:\b(?:\w+)\W*)+\.`</ph> matches a sentence that is terminated by a period.</source>
          <target state="translated">Der reguläre Ausdruck <ph id="ph1">`(?:\b(?:\w+)\W*)+\.`</ph> stimmt mit einem Satz überein, der durch einen Punkt beendet wird.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</source>
          <target state="translated">Da sich der reguläre Ausdruck auf Sätze konzentriert und nicht auf einzelne Wörter, werden Gruppierungskonstrukte ausschließlich als Quantifizierer verwendet.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">Das Muster für reguläre Ausdrücke wird entsprechend der folgenden Tabelle interpretiert.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Der Vergleich beginnt an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Übereinstimmung mit mindestens einem Wortzeichen.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Do not assign the matched text to a captured group.</source>
          <target state="translated">Weisen Sie einer erfassten Gruppe den entsprechenden Text nicht zu.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Match zero or more non-word characters.</source>
          <target state="translated">Suchen Sie nach einer Übereinstimmung mit null oder mehr Nicht-Wortzeichen.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</source>
          <target state="translated">Suchen Sie nach einer Übereinstimmung für das Muster aus einem oder mehreren Wortzeichen, beginnend bei einer Wortgrenze und gefolgt von null oder mehr Nicht-Wortzeichen (ein oder zwei Mal).</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Do not assign the matched text to a captured group.</source>
          <target state="translated">Weisen Sie einer erfassten Gruppe den entsprechenden Text nicht zu.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Match a period.</source>
          <target state="translated">Entsprechung für einen Punkt finden.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Group options</source>
          <target state="translated">Gruppenoptionen</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The following grouping construct applies or disables the specified options within a subexpression:</source>
          <target state="translated">Das folgende Gruppierungskonstrukt wendet die angegebenen Optionen in einem Teilausdruck an oder deaktiviert sie:</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">Hierbei ist <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> ein beliebiges gültiges Muster für reguläre Ausdrücke.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`(?i-s:)`</ph> turns on case insensitivity and disables single-line mode.</source>
          <target state="translated">Beispielsweise aktiviert <ph id="ph1">`(?i-s:)`</ph> die Einstellung, dass Groß-/Kleinschreibung nicht beachtet wird, und deaktiviert den Einzeilenmodus.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>For more information about the inline options you can specify, see <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu den Inlineoptionen, die Sie angeben können, finden Sie unter <bpt id="p1">[</bpt>Optionen für reguläre Ausdrücke<ept id="p1">](options.md)</ept>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>You can specify options that apply to an entire regular expression rather than a subexpression by using a <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or a static method.</source>
          <target state="translated">Sie können Optionen angeben, die für einen vollständigen regulären Ausdruck und nicht für einen Teilausdruck gültig sind. Verwenden Sie dazu einen <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>-Klassenkonstruktor oder eine statische Methode.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>You can also specify inline options that apply after a specific point in a regular expression by using the <ph id="ph1">`(?imnsx-imnsx)`</ph> language construct.</source>
          <target state="translated">Sie können auch Inlineoptionen angeben, die nach einem bestimmten Punkt in einem regulären Ausdruck gelten. Verwenden Sie dazu das <ph id="ph1">`(?imnsx-imnsx)`</ph>-Sprachkonstrukt.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The group options construct is not a capturing group.</source>
          <target state="translated">Das Konstrukt für die Gruppenoptionen ist keine Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>That is, although any portion of a string that is captured by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is included in the match, it is not included in a captured group nor used to populate the <bpt id="p2">[</bpt>GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object.</source>
          <target state="translated">Obwohl jeder Teil einer Zeichenfolge, der von <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> erfasst wird, in der Übereinstimmung enthalten ist, ist die Teilzeichenfolge weder in einer erfassten Gruppe enthalten noch wird sie dazu verwendet, das <bpt id="p2">[</bpt>GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept>-Objekt aufzufüllen.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b(?ix: d \w+)\s `</ph>in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern whitespace in identifying all words that begin with the letter "d".</source>
          <target state="translated">Der reguläre Ausdruck <ph id="ph1">`\b(?ix: d \w+)\s `</ph> im folgenden Beispiel verwendet Inlineoptionen in einem Gruppierungskonstrukt, um einen Abgleich ohne Berücksichtigung der Groß-/Kleinschreibung zu aktivieren und zu ermöglichen, dass beim Identifizieren aller Wörter, die mit dem Buchstaben „d“ beginnen, Leerstellen im Muster ignoriert werden.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>The regular expression is defined as shown in the following table.</source>
          <target state="translated">Der reguläre Ausdruck wird entsprechend der Darstellung in der folgenden Tabelle definiert:</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Der Vergleich beginnt an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</source>
          <target state="translated">In diesem Muster wird Übereinstimmung ohne Berücksichtigung von Groß- und Kleinschreibung verwendet, und Leerzeichen werden ignoriert (entspricht dem Buchstaben "d" gefolgt von mindestens einem Wortzeichen).</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">Entsprechung für ein Leerraumzeichen finden.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookahead assertions</source>
          <target state="translated">Positive Lookaheadassertionen mit einer Breite von Null</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width positive lookahead assertion:</source>
          <target state="translated">Das folgende Gruppierungskonstrukt definiert eine positive Lookaheadassertion mit einer Breite von Null:</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><bpt id="p3">__</bpt>)<ept id="p3">__</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><bpt id="p3">__</bpt>)<ept id="p3">__</ept></target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">Hierbei ist <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> ein beliebiges Muster für reguläre Ausdrücke.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>For a match to be successful, the input string must match the regular expression pattern in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, although the matched substring is not included in the match result.</source>
          <target state="translated">Damit eine Übereinstimmung erfolgreich ist, muss die Eingabezeichenfolge mit dem Muster für reguläre Ausdrücke in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> übereinstimmen, obwohl die übereinstimmende Teilzeichenfolge nicht im Übereinstimmungsergebnis enthalten ist.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookahead assertion does not backtrack.</source>
          <target state="translated">Eine positive Lookaheadassertion mit einer Breite von Null wird nicht zurückverfolgt.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</source>
          <target state="translated">In der Regel befindet sich eine positive Lookaheadassertion mit einer Breite von Null am Ende eines Musters eines regulären Ausdrucks.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</source>
          <target state="translated">Damit wird eine Teilzeichenfolge definiert, die am Ende einer Zeichenfolge gefunden werden muss, damit eine Übereinstimmung vorliegt, jedoch nicht in der Übereinstimmung enthalten sein soll.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>It is also useful for preventing excessive backtracking.</source>
          <target state="translated">Dies ist auch zum Verhindern einer übermäßigen Rückverfolgung nützlich.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</source>
          <target state="translated">Sie können eine Lookaheadassertion mit einer Breite von Null verwenden, um sicherzustellen, dass eine bestimmte Erfassungsgruppe mit Text beginnt, der einer Teilmenge des Musters entspricht, das für diese Erfassungsgruppe definiert ist.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</source>
          <target state="translated">Wenn z. B. eine Erfassungsgruppe aufeinander folgenden Wortzeichen entspricht, können Sie mit einer positiven Lookaheadassertion mit einer Breite von Null anfordern, dass das erste Zeichen ein alphabetischer Großbuchstabe ist.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</source>
          <target state="translated">Im folgenden Beispiel wird mithilfe einer positiven Lookaheadassertion mit einer Breite von Null eine Entsprechung für das Wort gesucht, das dem Verb "is" in der Eingabezeichenfolge vorausgeht.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>The regular expression \b\w+(?=\sis\b) is interpreted as shown in the following table.</source>
          <target state="translated">Der reguläre Ausdruck „\b\w+(?=\sis\b)“ wird entsprechend der Darstellung in der folgenden Tabelle interpretiert.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Der Vergleich beginnt an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Übereinstimmung mit mindestens einem Wortzeichen.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</source>
          <target state="translated">Bestimmen Sie, ob den Wortzeichen ein Leerstellenzeichen und die Zeichenfolge "is" folgt, die bei einer Wortgrenze endet.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>If so, the match is successful.</source>
          <target state="translated">Trifft dies zu, ist die Übereinstimmung erfolgreich.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookahead assertions</source>
          <target state="translated">Negative Lookaheadassertionen mit einer Breite von Null</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width negative lookahead assertion:</source>
          <target state="translated">Das folgende Gruppierungskonstrukt definiert eine negative Lookaheadassertion mit einer Breite von Null:</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">Hierbei ist <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> ein beliebiges Muster für reguläre Ausdrücke.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For the match to be successful, the input string must not match the regular expression pattern in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, although the matched string is not included in the match result.</source>
          <target state="translated">Damit die Übereinstimmung erfolgreich ist, darf die Eingabezeichenfolge nicht mit dem Muster für reguläre Ausdrücke in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> übereinstimmen, obwohl die übereinstimmende Zeichenfolge nicht im Übereinstimmungsergebnis enthalten ist.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</source>
          <target state="translated">Eine negative Lookaheadassertion mit einer Breite von Null wird in der Regel entweder am Anfang oder dem Ende eines regulären Ausdrucks verwendet.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</source>
          <target state="translated">Am Anfang eines regulären Ausdrucks kann ein bestimmtes Muster definiert werden, das nicht zugewiesen werden soll, wenn der Anfang des regulären Ausdrucks ein ähnliches aber allgemeineres Muster zur Übereinstimmung definiert.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>In this case, it is often used to limit backtracking.</source>
          <target state="translated">In diesem Fall wird dies häufig verwendet, um das Zurückverfolgen einzuschränken.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
          <target state="translated">Am Ende eines regulären Ausdrucks kann ein Teilausdruck definiert werden, der am Ende einer Übereinstimmung nicht auftreten darf.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</source>
          <target state="translated">Im folgenden Beispiel wird ein regulärer Ausdruck definiert, der am Anfang des regulären Ausdrucks eine Lookaheadassertion mit einer Breite von Null verwendet, um eine Entsprechung für Wörter zu finden, die nicht mit "un" beginnen.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The regular expression \b(?!un)\w+\b is interpreted as shown in the following table.</source>
          <target state="translated">Der reguläre Ausdruck „\b(?!un)\w+\b“ wird entsprechend der Darstellung in der folgenden Tabelle interpretiert.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Der Vergleich beginnt an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Determine whether the next two characters are "un".</source>
          <target state="translated">Es wird bestimmt, ob die nächsten zwei Zeichen "un" sind.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>If they are not, a match is possible.</source>
          <target state="translated">Trifft dies nicht zu, ist eine Übereinstimmung möglich.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Übereinstimmung mit mindestens einem Wortzeichen.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Der Vergleich endet an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</source>
          <target state="translated">Im folgenden Beispiel wird ein regulärer Ausdruck definiert, der am Ende eine Lookaheadassertion mit einer Breite von Null verwendet, um eine Entsprechung für Wörter zu finden, die nicht mit einem Interpunktionszeichen enden.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b\w+\b(?!\p{P})`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Der reguläre Ausdruck <ph id="ph1">`\b\w+\b(?!\p{P})`</ph> wird entsprechend der Darstellung in der folgenden Tabelle interpretiert.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Der Vergleich beginnt an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Übereinstimmung mit mindestens einem Wortzeichen.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Der Vergleich endet an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</source>
          <target state="translated">Wenn das nächste Zeichen kein Interpunktionszeichen (z. B. ein Punkt oder ein Komma) ist, ist die Übereinstimmung erfolgreich.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions</source>
          <target state="translated">Positive Lookbehindassertionen mit einer Breite von Null</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width positive lookbehind assertion:</source>
          <target state="translated">Das folgende Gruppierungskonstrukt definiert eine positive Lookbehindassertion mit einer Breite von Null:</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;=<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;=<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">Hierbei ist <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> ein beliebiges Muster für reguläre Ausdrücke.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>For a match to be successful, <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> must occur at the input string to the left of the current position, although subexpression is not included in the match result.</source>
          <target state="translated">Damit eine Übereinstimmung erfolgreich ist, muss die <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>-Zeichenfolge in der Eingabezeichenfolge links von der aktuellen Position auftreten, obwohl der Teilausdruck nicht im Übereinstimmungsergebnis enthalten ist.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookbehind assertion does not backtrack.</source>
          <target state="translated">Eine positive Lookbehindassertion mit einer Breite von Null wird nicht zurückverfolgt.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</source>
          <target state="translated">Positive Lookbehindassertionen mit einer Breite von Null werden in der Regel entweder am Anfang oder am Ende von regulären Ausdrücken verwendet.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
          <target state="translated">Das Muster, das sie definieren, ist eine Vorbedingung für eine Übereinstimmung, obwohl es kein Teil des Übereinstimmungsergebnisses ist.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</source>
          <target state="translated">Im folgenden Beispiel wird eine Entsprechung für die letzten zwei Ziffern des Jahres für das 21. Jahrhundert (das heißt, es ist erforderlich, dass die Ziffern "20" der entsprechenden Zeichenfolge vorausgehen) gefunden.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(?&lt;=\b20)\d{2}\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Das Muster für reguläre Ausdrücke <ph id="ph1">`(?&lt;=\b20)\d{2}\b`</ph> wird entsprechend der folgenden Tabelle interpretiert:</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>Match two decimal digits.</source>
          <target state="translated">Entsprechung für zwei Dezimalstellen finden.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</source>
          <target state="translated">Die Übereinstimmung wird fortgesetzt, wenn den zwei Dezimalstellen die Dezimalstellen "20" bei einer Wortgrenze vorangestellt sind.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Der Vergleich endet an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</source>
          <target state="translated">Positive Lookbehindassertions mit einer Breite von Null werden auch verwendet, um das Zurückverfolgen einzuschränken, wenn die letzten Zeichen in einer Erfassungsgruppe eine Teilmenge der Zeichen sein müssen, die dem Muster eines regulären Ausdrucks dieser Gruppe entsprechen.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</source>
          <target state="translated">Wenn beispielsweise eine Gruppe alle aufeinander folgenden Wortzeichen erfasst, können Sie mit einer positiven Lookaheadassertion mit einer Breite von Null anfordern, dass das letzte Zeichen alphabetisch ist.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind assertions</source>
          <target state="translated">Negative Lookbehindassertionen mit einer Breite von Null</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width negative lookbehind assertion:</source>
          <target state="translated">Das folgende Gruppierungskonstrukt definiert eine negative Lookbehindassertion mit einer Breite von Null:</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">Hierbei ist <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> ein beliebiges Muster für reguläre Ausdrücke.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>For a match to be successful, <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> must not occur at the input string to the left of the current position.</source>
          <target state="translated">Damit eine Übereinstimmung erfolgreich ist, darf die <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>-Zeichenfolge nicht in der Eingabezeichenfolge links von der aktuellen Position auftreten.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>However, any substring that does not match subexpression is not included in the match result.</source>
          <target state="translated">Jede Teilzeichenfolge, die nicht mit dem Teilausdruck übereinstimmt, ist nicht im Übereinstimmungsergebnis enthalten.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</source>
          <target state="translated">Negative Lookbehindassertionen mit einer Breite von Null werden in der Regel entweder am Anfang oder am Ende von regulären Ausdrücken verwendet.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>The pattern that they define precludes a match in the string that follows.</source>
          <target state="translated">Das Muster, das sie definieren, schließt eine Übereinstimmung in der darauf folgenden Zeichenfolge aus.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</source>
          <target state="translated">Sie werden auch verwendet, um die Rückverfolgung einzuschränken, wenn die letzten Zeichen in einer erfassten Gruppe keine Zeichen sein dürfen, die dem Muster eines regulären Ausdrucks dieser Gruppe entsprechen.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (_).</source>
          <target state="translated">Wenn beispielsweise eine Gruppe alle aufeinander folgenden Wortzeichen erfasst, können Sie mit einer positiven Lookaheadassertion mit einer Breite von Null anfordern, dass das letzte Zeichen kein Unterstrich (_) ist.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</source>
          <target state="translated">Im folgenden Beispiel wird eine Entsprechung für das Datum eines die oft ausgegebene Befehlszeilen  Wochentags gesucht, der nicht auf das Wochenende (das heißt weder Samstag noch Sonntag) fällt.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(?&lt;!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Das Muster für reguläre Ausdrücke <ph id="ph1">`(?&lt;!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b`</ph> wird entsprechend der folgenden Tabelle interpretiert:</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Der Vergleich beginnt an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a white-space character.</source>
          <target state="translated">Suchen Sie nach einer Übereinstimmung mit einem oder mehreren Wortzeichen gefolgt von einem Leerzeichen.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Match either one or two decimal digits followed by a white-space character and a comma.</source>
          <target state="translated">Finden Sie eine Entsprechung für entweder eine oder zwei Dezimalstellen, gefolgt von einem Leerstellenzeichen und einem Komma.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Match four decimal digits, and end the match at a word boundary.</source>
          <target state="translated">Finden Sie eine Entsprechung für vier Dezimalstellen, und beenden Sie die Übereinstimmung an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>`(?&lt;!(Saturday</source>
          <target state="translated">`(?&lt;!(Samstag</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Sunday) )`</source>
          <target state="translated">Sonntag) )`</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</source>
          <target state="translated">Wenn der Übereinstimmung etwas anderes als die Zeichenfolgen "Samstag" oder "Sonntag" (gefolgt von einem Leerzeichen) vorangestellt wird, ist die Übereinstimmung erfolgreich.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpressions</source>
          <target state="translated">Nicht zurückverfolgende Teilausdrücke</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</source>
          <target state="translated">Das folgende Gruppierungskonstrukt stellt einen nicht zurückverfolgenden Teilausdruck (auch bekannt als "gieriger" Teilausdruck) dar:</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">Hierbei ist <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> ein beliebiges Muster für reguläre Ausdrücke.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</source>
          <target state="translated">Wenn ein regulärer Ausdruck ein optionales oder alternatives übereinstimmendes Muster einschließt und eine Übereinstimmung nicht erfolgreich ist, kann sich das Modul für reguläre Ausdrücke in mehrere Richtungen branchen, um eine Entsprechung zwischen einer Eingabezeichenfolge und einem Muster zu finden.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</source>
          <target state="translated">Wenn eine Übereinstimmung nach der ersten Verzweigung nicht gefunden wird, kann das Modul für reguläre Ausdrücke den Punkt der ersten Übereinstimmung sichern bzw. den Punkt zurückverfolgen und die Übereinstimmung mithilfe der zweiten Verzweigung durchführen.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>This process can continue until all branches have been tried.</source>
          <target state="translated">Dieser Prozess kann fortgesetzt werden, bis alle Branches versucht wurden.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language construct disables backtracking.</source>
          <target state="translated">Das Sprachkonstrukt <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> deaktiviert die Rückverfolgung.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>The regular expression engine will match as many characters in the input string as it can.</source>
          <target state="translated">Das Modul für reguläre Ausdrücke stimmt mit so vielen Zeichen in der Eingabezeichenfolge überein wie möglich.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>When no further match is possible, it will not backtrack to attempt alternate pattern matches.</source>
          <target state="translated">Wenn keine weitere Übereinstimmung möglich ist, findet keine Rückverfolgung statt, um alternative Musterübereinstimmungen zu versuchen.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</source>
          <target state="translated">(Das heißt, der Teilausdruck sucht nur Entsprechungen für Zeichenfolgen, zu denen der Teilausdruck allein passen würde. Er versucht nicht, eine Entsprechung für eine Zeichenfolge auf Grundlage des Teilausdrucks und beliebige folgende Teilausdrücke zu finden.)</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>This option is recommended if you know that backtracking will not succeed.</source>
          <target state="translated">Diese Option wird empfohlen, wenn Sie wissen, dass eine Rückverfolgung nicht erfolgreich ist.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>Preventing the regular expression engine from performing unnecessary searching improves performance.</source>
          <target state="translated">Indem verhindert wird, dass vom Modul für reguläre Ausdrücke unnötige Suchläufe durchgeführt werden, wird die Leistung verbessert.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie ein nicht zurückverfolgender Teilausdruck die Ergebnisse einer Musterübereinstimmung ändert.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</source>
          <target state="translated">Der rückverfolgende reguläre Ausdruck findet erfolgreich eine Entsprechung für eine Reihe von Zeichen, die von einem weiteren Vorkommen des gleichen Zeichens bei einer Wortgrenze gefolgt wird. Beim regulären Ausdruck ohne Rückverfolgung ist dies nicht der Fall.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>The nonbacktracking regular expression <ph id="ph1">`(?&gt;(\w)\1+).\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Der nicht zurückverfolgende reguläre Ausdruck <ph id="ph1">`(?&gt;(\w)\1+).\b`</ph> wird entsprechend der folgenden Tabelle definiert.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Match a single word character and assign it to the first capturing group.</source>
          <target state="translated">Finden Sie eine Entsprechung für ein einzelnes Wortzeichen, und weisen Sie es der ersten Erfassungsgruppe zu.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Match the value of the first captured substring one or more times.</source>
          <target state="translated">Finden Sie mindestens eine Entsprechung für die erste erfasste Teilzeichenfolge.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>Match any character.</source>
          <target state="translated">Finden Sie eine Entsprechung für ein beliebiges Zeichen.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>End the match on a word boundary.</source>
          <target state="translated">Beendet den Vergleich an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</source>
          <target state="translated">Finden Sie eine Entsprechung für ein oder mehrere Vorkommen eines duplizierten Wortzeichens, führen Sie jedoch keine Rückverfolgung aus, um für das letzte Zeichen bei einer Wortgrenze eine Entsprechung zu finden.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Grouping constructs and regular expression objects</source>
          <target state="translated">Gruppieren von Konstrukten und Objekten für reguläre Ausdrücke</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Substrings that are matched by a regular expression capturing group are represented by <bpt id="p1">[</bpt>System.Text.RegularExpressions.Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects, which can be retrieved from the <bpt id="p2">[</bpt>System.Text.RegularExpressions.GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object that is returned by the <bpt id="p3">[</bpt>Match.Groups<ept id="p3">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">Teilzeichenfolgen, die von einer Gruppe zur Erfassung von regulären Ausdrücken abgeglichen werden, werden durch <bpt id="p1">[</bpt>System.Text.RegularExpressions.Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>-Objekte dargestellt, die aus dem von der <bpt id="p3">[</bpt>Match.Groups<ept id="p3">](xref:System.Text.RegularExpressions.Match.Groups)</ept>-Eigenschaft zurückgegebenen <bpt id="p2">[</bpt>System.Text.RegularExpressions.GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept>-Objekt abgerufen werden können.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object is populated as follows:</source>
          <target state="translated">Das <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept>-Objekt wird folgendermaßen aufgefüllt:</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>The first <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object in the collection (the object at index zero) represents the entire match.</source>
          <target state="translated">Das erste <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>-Objekt in der Auflistung (das Objekt bei Index 0) stellt die gesamte Übereinstimmung dar.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>The next set of <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects represent unnamed (numbered) capturing groups.</source>
          <target state="translated">Der nächste Satz von <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>-Objekten stellt unbenannte (nummerierte) Erfassungsgruppen dar.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>They appear in the order in which they are defined in the regular expression, from left to right.</source>
          <target state="translated">Sie werden in der Reihenfolge angezeigt, in der sie im regulären Ausdruck definiert sind (von links nach rechts).</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</source>
          <target state="translated">Die Indexwerte dieser Gruppen reichen von 1 bis zur Anzahl unbenannter Erfassungsgruppen in der Auflistung.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>(The index of a particular group is equivalent to its numbered backreference.</source>
          <target state="translated">(Der Index einer bestimmten Gruppe entspricht seinem nummerierten Rückverweis.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>For more information about backreferences, see <bpt id="p1">[</bpt>Backreference constructs in regular expressions<ept id="p1">](backreference.md)</ept></source>
          <target state="translated">Weitere Informationen zu Rückverweisen finden Sie unter <bpt id="p1">[</bpt>Rückverweiskonstrukte in regulären Ausdrücken<ept id="p1">](backreference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>The final set of <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects represent named capturing groups.</source>
          <target state="translated">Der letzte Satz von <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>-Objekten stellt benannte Erfassungsgruppen dar.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>They appear in the order in which they are defined in the regular expression, from left to right.</source>
          <target state="translated">Sie werden in der Reihenfolge angezeigt, in der sie im regulären Ausdruck definiert sind (von links nach rechts).</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</source>
          <target state="translated">Der Indexwert der zuerst benannten Erfassungsgruppe ist um eins größer als der Index der letzten unbenannten Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</source>
          <target state="translated">Wenn es keine unbenannten Erfassungsgruppen im regulären Ausdruck gibt, ist der Indexwert der zuerst benannten Erfassungsgruppe gleich eins.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>If you apply a quantifier to a capturing group, the corresponding <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object's <bpt id="p2">[</bpt>Capture.Value<ept id="p2">](xref:System.Text.RegularExpressions.Capture.Value)</ept>, <bpt id="p3">[</bpt>Capture.Index<ept id="p3">](xref:System.Text.RegularExpressions.Capture.Index)</ept>, and <bpt id="p4">[</bpt>Capture.Length<ept id="p4">](xref:System.Text.RegularExpressions.Capture.Length)</ept> properties reflect the last substring that is captured by a capturing group.</source>
          <target state="translated">Wenn Sie einen Quantifizierer auf eine Erfassungsgruppe anwenden, reflektieren die entsprechenden <bpt id="p2">[</bpt>Capture.Value<ept id="p2">](xref:System.Text.RegularExpressions.Capture.Value)</ept>-, <bpt id="p3">[</bpt>Capture.Index<ept id="p3">](xref:System.Text.RegularExpressions.Capture.Index)</ept>- und <bpt id="p4">[</bpt>Capture.Length<ept id="p4">](xref:System.Text.RegularExpressions.Capture.Length)</ept>-Eigenschaften des <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>-Objekts die letzte Teilzeichenfolge, die von einer Erfassungsgruppe erfasst wird.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object that is returned by the <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property.</source>
          <target state="translated">Sie können einen vollständigen Satz von Teilzeichenfolgen abrufen, die von Gruppen erfasst werden, die Quantifizierer aus dem von der <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept>-Eigenschaft zurückgegebenen <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept>-Objekt besitzen.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>The following example clarifies the relationship between the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> and <bpt id="p2">[</bpt>Capture<ept id="p2">](xref:System.Text.RegularExpressions.Capture)</ept> objects.</source>
          <target state="translated">Das folgende Beispiel verdeutlicht die Beziehung zwischen den <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>- und <bpt id="p2">[</bpt>Capture<ept id="p2">](xref:System.Text.RegularExpressions.Capture)</ept>-Objekten.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(\w+)\W+)+`</ph> extracts individual words from a string.</source>
          <target state="translated">Das Muster eines regulären Ausdrucks <ph id="ph1">`\b(\w+)\W+)+`</ph> extrahiert einzelne Wörter aus einer Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
          <target state="translated">Das Muster wird wie in der folgenden Tabelle gezeigt definiert.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Der Vergleich beginnt an einer Wortgrenze.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Übereinstimmung mit mindestens einem Wortzeichen.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Together, these characters form a word.</source>
          <target state="translated">Zusammen bilden diese Zeichen ein Wort.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">Dies ist die zweite Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>Match one or more non-word characters.</source>
          <target state="translated">Entsprechung für mindestens ein Nicht-Wortzeichen finden.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</source>
          <target state="translated">Suchen Sie nach einer Übereinstimmung für das Muster aus einem oder mehreren Wortzeichen, gefolgt von einem oder mehreren Nicht-Wortzeichen (ein oder zwei Mal).</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Dies ist die erste Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The first capturing group matches each word of the sentence.</source>
          <target state="translated">Die erste Erfassungsgruppe stimmt mit jedem Wort des Satzes überein.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>The second capturing group matches each word along with the punctuation and white space that follow the word.</source>
          <target state="translated">Die zweite Erfassungsgruppe vergleicht jedes Wort zusammen mit der Interpunktion und den Leerstellen, die auf das Wort folgen.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object whose index is 2 provides information about the text matched by the second capturing group.</source>
          <target state="translated">Das <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept>-Objekt, dessen Index 2 ist, stellt Informationen zu dem Text bereit, der durch die zweite Erfassungsgruppe abgeglichen wird.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The complete set of words captured by the capturing group are available from the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object returned by the <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property.</source>
          <target state="translated">Der vollständige Satz von Wörtern, die von der Erfassungsgruppe erfasst wurden, ist in dem <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept>-Objekt verfügbar, das von der <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept>-Eigenschaft zurückgegeben wurde.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Siehe auch</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Sprachelemente für reguläre Ausdrücke – Kurzübersicht<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking in regular expressions<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Backtracking in regulären Ausdrücken<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>