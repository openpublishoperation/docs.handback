<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">381fa0db2d92590d23ebd71a7823a8465e94a6e6</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\procedures\extension-methods.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">84bb72899e1213c1873b9817f0c4227980c03199</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56d34f039b1438766543d5745213bed0cee6296d</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_extension-methods.3376dafd6e9da1dbd7698b015510be2bb146d45b.de-de is different with handoff file name: extension-methods.3376dafd6e9da1dbd7698b015510be2bb146d45b.de-de.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Extension Methods (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Erweiterungsmethoden (Visual Basic) | Microsoft-Dokumentation</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Extension Methods (Visual Basic)</source>
          <target state="translated">Erweiterungsmethoden (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Extension methods enable developers to add custom functionality to data types that are already defined without creating a new derived type.</source>
          <target state="translated">Erweiterungsmethoden ermöglichen Entwicklern das Hinzufügen von benutzerdefinierten Funktionen, Datentypen, die bereits definiert sind, ohne einen neuen abgeleiteten Typ zu erstellen.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Extension methods make it possible to write a method that can be called as if it were an instance method of the existing type.</source>
          <target state="translated">Erweiterungsmethoden ermöglichen das Schreiben einer Methode, die aufgerufen werden können, als wäre es eine Instanzenmethode des vorhandenen Typs.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Hinweise</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>An extension method can be only a <ph id="ph1">`Sub`</ph> procedure or a <ph id="ph2">`Function`</ph> procedure.</source>
          <target state="translated">Eine Erweiterungsmethode kann ausschließlich eine <ph id="ph1">`Sub`</ph>-Prozedur oder eine <ph id="ph2">`Function`</ph>-Prozedur sein.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You cannot define an extension property, field, or event.</source>
          <target state="translated">Erweiterungseigenschaften, -felder oder -ereignisse können nicht definiert werden.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>All extension methods must be marked with the extension attribute <ph id="ph1">`&lt;Extension()&gt;`</ph> from the &lt;xref:System.Runtime.CompilerServices?displayProperty=fullName&gt; namespace.</source>
          <target state="translated">Alle Erweiterungsmethoden müssen mit dem Extension-Attribut markiert werden <ph id="ph1">`&lt;Extension()&gt;`</ph> aus der &lt;xref:System.Runtime.CompilerServices?displayProperty=fullName&gt;Namespace.&lt;/xref:System.Runtime.CompilerServices?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The first parameter in an extension method definition specifies which data type the method extends.</source>
          <target state="translated">Der erste Parameter in der Definition einer Erweiterungsmethode gibt den Datentyp an, der von der Methode erweitert wird.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When the method is run, the first parameter is bound to the instance of the data type that invokes the method.</source>
          <target state="translated">Beim Ausführen der Methode wird der erste Parameter an die Instanz des Datentyps gebunden, der die Methode aufruft.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Beispiel</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`Print`</ph> extension to the &lt;xref:System.String&gt; data type.</source>
          <target state="translated">Das folgende Beispiel definiert eine <ph id="ph1">`Print`</ph> Erweiterung der &lt;xref:System.String&gt;-Datentyp.&lt;/xref:System.String&gt;</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The method uses <ph id="ph1">`Console.WriteLine`</ph> to display a string.</source>
          <target state="translated">Die Methode verwendet <ph id="ph1">`Console.WriteLine`</ph>, um eine Zeichenfolge anzuzeigen.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The parameter of the <ph id="ph1">`Print`</ph> method, <ph id="ph2">`aString`</ph>, establishes that the method extends the &lt;xref:System.String&gt; class.</source>
          <target state="translated">Die Parameter von der <ph id="ph1">`Print`</ph> -Methode <ph id="ph2">`aString`</ph>, legt fest, dass die Methode der &lt;xref:System.String&gt;Klasse&lt;/xref:System.String&gt; erweitert</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#1<ept id="p2">](./codesnippet/VisualBasic/extension-methods_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#1;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Notice that the extension method definition is marked with the extension attribute <ph id="ph1">`&lt;Extension()&gt;`</ph>.</source>
          <target state="translated">Beachten Sie, dass die Definition der Erweiterungsmethode mit dem Erweiterungsattribut <ph id="ph1">`&lt;Extension()&gt;`</ph> markiert ist.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Marking the module in which the method is defined is optional, but each extension method must be marked.</source>
          <target state="translated">Die Markierung des Moduls, in dem die Methode definiert ist, ist optional, aber jede Erweiterungsmethode muss markiert werden.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Runtime.CompilerServices&gt; must be imported in order to access the extension attribute.</source>
          <target state="translated">&lt;xref:System.Runtime.CompilerServices&gt;muss Zugriff auf das Erweiterungsattribut importiert werden.&lt;/xref:System.Runtime.CompilerServices&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Extension methods can be declared only within modules.</source>
          <target state="translated">Erweiterungsmethoden können nur innerhalb von Modulen deklariert werden.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Typically, the module in which an extension method is defined is not the same module as the one in which it is called.</source>
          <target state="translated">Bei dem Modul, in dem eine Erweiterungsmethode definiert wird, handelt es sich normalerweise um ein anderes Modul als das, in dem sie aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Instead, the module that contains the extension method is imported, if it needs to be, to bring it into scope.</source>
          <target state="translated">Stattdessen wird das Modul, in dem die Erweiterungsmethode enthalten ist, ggf. importiert, um es in den Gültigkeitsbereich einzubinden.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>After the module that contains <ph id="ph1">`Print`</ph> is in scope, the method can be called as if it were an ordinary instance method that takes no arguments, such as <ph id="ph2">`ToUpper`</ph>:</source>
          <target state="translated">Nachdem sich das Modul, in dem <ph id="ph1">`Print`</ph> enthalten ist, im Gültigkeitsbereich befindet, kann die Methode wie jede andere gewöhnliche Instanzenmethode, die keine Argumente verwendet (z. B. <ph id="ph2">`ToUpper`</ph>) aufgerufen werden:</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#2<ept id="p2">](./codesnippet/VisualBasic/extension-methods_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#2;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The next example, <ph id="ph1">`PrintAndPunctuate`</ph>, is also an extension to &lt;xref:System.String&gt;, this time defined with two parameters.</source>
          <target state="translated">Das nächste Beispiel <ph id="ph1">`PrintAndPunctuate`</ph>, ist auch eine Erweiterung für &lt;xref:System.String&gt;, dieses Mal mit zwei Parametern definiert.&lt;/xref:System.String&gt;</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The first parameter, <ph id="ph1">`aString`</ph>, establishes that the extension method extends &lt;xref:System.String&gt;.</source>
          <target state="translated">Der erste Parameter, <ph id="ph1">`aString`</ph>, legt fest, dass die Erweiterungsmethode &lt;xref:System.String&gt;.&lt;/xref:System.String&gt; erweitert</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The second parameter, <ph id="ph1">`punc`</ph>, is intended to be a string of punctuation marks that is passed in as an argument when the method is called.</source>
          <target state="translated">Mit dem zweiten Parameter, <ph id="ph1">`punc`</ph>, wird eine aus Satzzeichen bestehende Zeichenfolge bereitgestellt, die beim Aufruf der Methode als Argument übergeben wird.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The method displays the string followed by the punctuation marks.</source>
          <target state="translated">Durch die Methode wird die Zeichenfolge gefolgt von den Satzzeichen angezeigt.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#3<ept id="p2">](./codesnippet/VisualBasic/extension-methods_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;3;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The method is called by sending in a string argument for <ph id="ph1">`punc`</ph>: <ph id="ph2">`example.PrintAndPunctuate(".")`</ph></source>
          <target state="translated">Die Methode wird aufgerufen, indem ein Zeichenfolgenargument für <ph id="ph1">`punc`</ph> gesendet wird: <ph id="ph2">`example.PrintAndPunctuate(".")`</ph></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The following example shows <ph id="ph1">`Print`</ph> and <ph id="ph2">`PrintAndPunctuate`</ph> defined and called.</source>
          <target state="translated">Im folgenden Beispiel werden <ph id="ph1">`Print`</ph> und <ph id="ph2">`PrintAndPunctuate`</ph> definiert und aufgerufen.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Runtime.CompilerServices&gt; is imported in the definition module in order to enable access to the extension attribute.</source>
          <target state="translated">&lt;xref:System.Runtime.CompilerServices&gt;wird in das Definitionsmodul importiert, um Zugriff auf das Erweiterungsattribut zu ermöglichen.&lt;/xref:System.Runtime.CompilerServices&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Next, the extension methods are brought into scope and called.</source>
          <target state="translated">Als Nächstes werden die Erweiterungsmethoden in den Gültigkeitsbereich eingebunden und aufgerufen.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Kommentare</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>All that is required to be able to run these or similar extension methods is that they be in scope.</source>
          <target state="translated">Die einzige Voraussetzung für das Ausführen dieser oder ähnlicher Erweiterungsmethoden besteht darin, dass sie sich innerhalb des Gültigkeitsbereichs befinden müssen.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If the module that contains an extension method is in scope, it is visible in IntelliSense and can be called as if it were an ordinary instance method.</source>
          <target state="translated">Wenn sich das Modul mit einer Erweiterungsmethode im Gültigkeitsbereich befindet, ist es für IntelliSense erkennbar und kann wie jede andere gewöhnliche Instanzenmethode aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Notice that when the methods are invoked, no argument is sent in for the first parameter.</source>
          <target state="translated">Beachten Sie, dass beim Aufrufen der Methoden kein Argument für den ersten Parameter gesendet wird.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Parameter <ph id="ph1">`aString`</ph> in the previous method definitions is bound to <ph id="ph2">`example`</ph>, the instance of <ph id="ph3">`String`</ph> that calls them.</source>
          <target state="translated">Der <ph id="ph1">`aString`</ph>-Parameter in den vorherigen Methodendefinitionen ist an <ph id="ph2">`example`</ph> gebunden, also die Instanz von <ph id="ph3">`String`</ph>, durch die sie aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The compiler will use <ph id="ph1">`example`</ph> as the argument sent to the first parameter.</source>
          <target state="translated">Der Compiler verwendet <ph id="ph1">`example`</ph> als das an den ersten Parameter gesendete Argument.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If an extension method is called for an object that is set to <ph id="ph1">`Nothing`</ph>, the extension method executes.</source>
          <target state="translated">Wenn eine Erweiterungsmethode für ein Objekt aufgerufen wird, das auf <ph id="ph1">`Nothing`</ph> festgelegt ist, wird die Erweiterungsmethode ausgeführt.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This does not apply to ordinary instance methods.</source>
          <target state="translated">Dies trifft nicht auf normale Instanzmethoden zu.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can explicitly check for <ph id="ph1">`Nothing`</ph> in the extension method.</source>
          <target state="translated">Sie können in der Erweiterungsmethode explizit auf <ph id="ph1">`Nothing`</ph> überprüfen.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Types That Can Be Extended</source>
          <target state="translated">Erweiterungsfähige Typen</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can define an extension method on most types that can be represented in a Visual Basic parameter list, including the following:</source>
          <target state="translated">Erweiterungsmethoden können für die meisten Typen definiert werden, die in Visual Basic-Parameterlisten wie den folgenden dargestellt werden können:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Classes (reference types)</source>
          <target state="translated">Klassen (Referenztypen)</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Structures (value types)</source>
          <target state="translated">Strukturen (Werttypen)</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Schnittstellen</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Delegates</source>
          <target state="translated">Delegaten</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>ByRef and ByVal arguments</source>
          <target state="translated">ByRef- und ByVal-Argumente</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Generic method parameters</source>
          <target state="translated">Parameter für generische Methoden</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Because the first parameter specifies the data type that the extension method extends, it is required and cannot be optional.</source>
          <target state="translated">Da der erste Parameter den Datentyp angibt, der durch die Erweiterungsmethode erweitert wird, ist er erforderlich und kann nicht ausgelassen werden.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For that reason, <ph id="ph1">`Optional`</ph> parameters and <ph id="ph2">`ParamArray`</ph> parameters cannot be the first parameter in the parameter list.</source>
          <target state="translated">Aus diesem Grund kann ein <ph id="ph1">`Optional`</ph>-Parameter oder ein <ph id="ph2">`ParamArray`</ph>-Parameter nicht der erste Parameter in der Parameterliste sein.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Extension methods are not considered in late binding.</source>
          <target state="translated">Erweiterungsmethoden werden bei der späten Bindung nicht berücksichtigt.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In the following example, the statement <ph id="ph1">`anObject.PrintMe()`</ph> raises a &lt;xref:System.MissingMemberException&gt; exception, the same exception you would see if the second <ph id="ph2">`PrintMe`</ph> extension method definition were deleted.</source>
          <target state="translated">Im folgenden Beispiel wird die Anweisung <ph id="ph1">`anObject.PrintMe()`</ph> löst eine &lt;xref:System.MissingMemberException&gt;Ausnahme, die gleiche Ausnahme angezeigt wird, wenn die zweite <ph id="ph2">`PrintMe`</ph> Definition Erweiterungsmethode wurden gelöscht.&lt;/xref:System.MissingMemberException&gt;</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#9<ept id="p2">](./codesnippet/VisualBasic/extension-methods_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#9;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Best Practices</source>
          <target state="translated">Bewährte Methoden</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Extension methods provide a convenient and powerful way to extend an existing type.</source>
          <target state="translated">Erweiterungsmethoden bieten eine einfache und leistungsstarke Möglichkeit zur Erweiterung eines vorhandenen Typs.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>However, to use them successfully, there are some points to consider.</source>
          <target state="translated">Um sie erfolgreich zu verwenden, sind jedoch einige Punkte zu beachten.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>These considerations apply mainly to authors of class libraries, but they might affect any application that uses extension methods.</source>
          <target state="translated">Obwohl sich diese Überlegungen hauptsächlich auf Autoren von Klassenbibliotheken beziehen, können sie gleichzeitig Anwendungen betreffen, die Erweiterungsmethoden verwenden.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Most generally, extension methods that you add to types that you do not own are more vulnerable than extension methods added to types that you control.</source>
          <target state="translated">Erweiterungsmethoden, die Sie Typen hinzufügen, die sich nicht in Ihrem Besitz befinden, sind im Allgemeinen angreifbarer als Erweiterungsmethoden, die Sie Typen hinzufügen, die von Ihnen gesteuert werden.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A number of things can occur in classes you do not own that can interfere with your extension methods.</source>
          <target state="translated">In Klassen, die sich nicht in Ihrem Besitz befinden, können einige Ereignisse auftreten, die Ihre Erweiterungsmethoden negativ beeinflussen könnten.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>If any accessible instance member exists that has a signature that is compatible with the arguments in the calling statement, with no narrowing conversions required from argument to parameter, the instance method will be used in preference to any extension method.</source>
          <target state="translated">Falls ein Instanzenmember vorhanden ist, auf den zugegriffen werden kann und der über eine mit den Argumenten in der aufrufenden Anweisung kompatible Signatur verfügt, ohne dass einschränkende Konvertierungen vom Argument zum Parameter festgelegt sind, wird die Instanzenmethode vor allen Erweiterungsmethoden verwendet.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Therefore, if an appropriate instance method is added to a class at some point, an existing extension member that you rely on may become inaccessible.</source>
          <target state="translated">Daher ist es möglich, dass auf einen vorhandenen Erweiterungsmember, den Sie verwenden möchten, nicht mehr zugegriffen werden kann, wenn einer Klasse zu einem bestimmten Zeitpunkt eine geeignete Instanzenmethode hinzugefügt wird.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The author of an extension method cannot prevent other programmers from writing conflicting extension methods that may have precedence over the original extension.</source>
          <target state="translated">Der Autor einer Erweiterungsmethode kann nicht verhindern, dass andere Programmierer Erweiterungsmethoden schreiben, die Vorrang vor der ursprünglichen Erweiterung haben und damit Konflikte verursachen.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can improve robustness by putting extension methods in their own namespace.</source>
          <target state="translated">Sie können die Stabilität verbessern, indem Sie Erweiterungsmethoden in einen eigenen Namespace einfügen.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Consumers of your library can then include a namespace or exclude it, or select among namespaces, separately from the rest of the library.</source>
          <target state="translated">Consumer Ihrer Bibliothek können einen Namespace dann ein- oder ausschließen bzw. vom Rest der Bibliothek getrennt unter den Namespaces auswählen.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>It may be safer to extend interfaces than it is to extend classes, especially if you do not own the interface or class.</source>
          <target state="translated">Das Erweitern von Schnittstellen bietet u. U. mehr Sicherheit als das Erweitern von Klassen, insbesondere, wenn Sie nicht der Besitzer der Schnittstelle oder Klasse sind.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A change in an interface affects every class that implements it.</source>
          <target state="translated">Eine Änderung einer Schnittstelle wirkt sich auf jede Klasse aus, die von ihr implementiert wird.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Therefore, the author may be less likely to add or change methods in an interface.</source>
          <target state="translated">Deshalb ist es eher unwahrscheinlich, dass der Autor Methoden in einer Schnittstelle hinzufügt oder ändert.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>However, if a class implements two interfaces that have extension methods with the same signature, neither extension method is visible.</source>
          <target state="translated">Wenn eine Klasse jedoch zwei Schnittstellen implementiert, die über Erweiterungsmethoden mit gleicher Signatur verfügen, wird keine der Erweiterungsmethoden angezeigt.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Extend the most specific type you can.</source>
          <target state="translated">Erweitern Sie einen möglichst spezifischen Typ.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In a hierarchy of types, if you select a type from which many other types are derived, there are layers of possibilities for the introduction of instance methods or other extension methods that might interfere with yours.</source>
          <target state="translated">Wenn Sie in einer Typhierarchie einen Typ auswählen, von dem viele andere Typen abgeleitet sind, können auf viele Weisen Instanzenmethoden oder andere Erweiterungsmethoden eingeführt werden, die Konflikte mit Ihren Instanzen- oder Erweiterungsmethoden verursachen könnten.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Extension Methods, Instance Methods, and Properties</source>
          <target state="translated">Erweiterungsmethoden, Instanzmethoden und Eigenschaften</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>When an in-scope instance method has a signature that is compatible with the arguments of a calling statement, the instance method is chosen in preference to any extension method.</source>
          <target state="translated">Wenn eine Instanzmethode im Gültigkeitsbereich über eine Signatur verfügt, die mit den Argumenten einer Aufrufanweisung kompatibel ist, wird die Instanzmethode vor den Erweiterungsmethoden bevorzugt ausgewählt.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The instance method has precedence even if the extension method is a better match.</source>
          <target state="translated">Die Instanzmethode hat auch dann Vorrang, wenn die Erweiterungsmethode eine bessere Übereinstimmung aufweist.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`ExampleClass`</ph> contains an instance method named <ph id="ph2">`ExampleMethod`</ph> that has one parameter of type <ph id="ph3">`Integer`</ph>.</source>
          <target state="translated">Im folgenden Beispiel enthält die <ph id="ph1">`ExampleClass`</ph> eine Instanzmethode mit der Bezeichnung <ph id="ph2">`ExampleMethod`</ph>, die über einen Parameter des Typs <ph id="ph3">`Integer`</ph> verfügt.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Extension method <ph id="ph1">`ExampleMethod`</ph> extends <ph id="ph2">`ExampleClass`</ph>, and has one parameter of type <ph id="ph3">`Long`</ph>.</source>
          <target state="translated">Die Erweiterungsmethode <ph id="ph1">`ExampleMethod`</ph> erweitert die <ph id="ph2">`ExampleClass`</ph> und verfügt über einen Parameter des Typs <ph id="ph3">`Long`</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#4<ept id="p2">](./codesnippet/VisualBasic/extension-methods_5.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;4;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_5.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The first call to <ph id="ph1">`ExampleMethod`</ph> in the following code calls the extension method, because <ph id="ph2">`arg1`</ph> is <ph id="ph3">`Long`</ph> and is compatible only with the <ph id="ph4">`Long`</ph> parameter in the extension method.</source>
          <target state="translated">Mit dem ersten Aufruf an <ph id="ph1">`ExampleMethod`</ph> im folgenden Code wird die Erweiterungsmethode aufgerufen, da <ph id="ph2">`arg1`</ph> den Wert <ph id="ph3">`Long`</ph> hat und nur mit dem <ph id="ph4">`Long`</ph>-Parameter in der Erweiterungsmethode kompatibel ist.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The second call to <ph id="ph1">`ExampleMethod`</ph> has an <ph id="ph2">`Integer`</ph> argument, <ph id="ph3">`arg2`</ph>, and it calls the instance method.</source>
          <target state="translated">Der zweite Aufruf von <ph id="ph1">`ExampleMethod`</ph> verfügt über ein <ph id="ph2">`Integer`</ph>-Argument, <ph id="ph3">`arg2`</ph>, und es ruft die Instanzmethode auf.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#5<ept id="p2">](./codesnippet/VisualBasic/extension-methods_6.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;5;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_6.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Now reverse the data types of the parameters in the two methods:</source>
          <target state="translated">Kehren Sie nun die Datentypen der Parameter in den zwei Methoden um:</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#6<ept id="p2">](./codesnippet/VisualBasic/extension-methods_7.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;6;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_7.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>This time the code in <ph id="ph1">`Main`</ph> calls the instance method both times.</source>
          <target state="translated">Dieses Mal ruft der Code in <ph id="ph1">`Main`</ph> beide Male die Instanzmethode auf.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This is because both <ph id="ph1">`arg1`</ph> and <ph id="ph2">`arg2`</ph> have a widening conversion to <ph id="ph3">`Long`</ph>, and the instance method takes precedence over the extension method in both cases.</source>
          <target state="translated">Das liegt daran, dass sowohl <ph id="ph1">`arg1`</ph> und <ph id="ph2">`arg2`</ph> über eine Erweiterungskonvertierung zu <ph id="ph3">`Long`</ph> verfügen, und die Instanzmethode in beiden Fällen Vorrang vor der Erweiterungsmethode hat.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#7<ept id="p2">](./codesnippet/VisualBasic/extension-methods_8.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#7;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_8.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Therefore, an extension method cannot replace an existing instance method.</source>
          <target state="translated">Dies bedeutet, dass eine Erweiterungsmethode keine vorhandene Instanzmethode ersetzen kann.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>However, when an extension method has the same name as an instance method but the signatures do not conflict, both methods can be accessed.</source>
          <target state="translated">Wenn eine Erweiterungsmethode jedoch über denselben Namen wie eine Instanzmethode verfügt, die Signaturen aber keine Konflikte verursachen, kann auf beide Methoden zugegriffen werden.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>For example, if class <ph id="ph1">`ExampleClass`</ph> contains a method named <ph id="ph2">`ExampleMethod`</ph> that takes no arguments, extension methods with the same name but different signatures are permitted, as shown in the following code.</source>
          <target state="translated">Wenn die <ph id="ph1">`ExampleClass`</ph> beispielsweise eine Methode mit dem Namen <ph id="ph2">`ExampleMethod`</ph> enthält, die keine Argumente verwendet, sind Erweiterungsmethoden mit demselben Namen aber unterschiedlichen Signaturen zulässig, wie in folgendem Code dargestellt.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#8<ept id="p2">](./codesnippet/VisualBasic/extension-methods_9.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#8;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_9.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The output from this code is as follows:</source>
          <target state="translated">Dieser Code generiert folgende Ausgabe:</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The situation is simpler with properties: if an extension method has the same name as a property of the class it extends, the extension method is not visible and cannot be accessed.</source>
          <target state="translated">Bezüglich Eigenschaften ist der Sachverhalt unkomplizierter: Wenn eine Erweiterungsmethode den gleichen Namen wie eine Eigenschaft der Klasse hat, die sie erweitert, wird die Erweiterungsmethode nicht angezeigt, und es kann nicht darauf zugegriffen werden.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Extension Method Precedence</source>
          <target state="translated">Rangfolge von Erweiterungsmethoden</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>When two extension methods that have identical signatures are in scope and accessible, the one with higher precedence will be invoked.</source>
          <target state="translated">Wenn sich zwei Erweiterungsmethoden mit identischen Signaturen im Gültigkeitsbereich befinden und zugreifbar sind, wird die Methode mit der höheren Rangfolge aufgerufen.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>An extension method's precedence is based on the mechanism used to bring the method into scope.</source>
          <target state="translated">Die Rangfolge einer Erweiterungsmethode basiert auf dem Mechanismus, der verwendet wird, um die Methode in den Gültigkeitsbereich einzubinden.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The following list shows the precedence hierarchy, from highest to lowest.</source>
          <target state="translated">Die folgende Liste gibt die hierarchische Rangfolge von oben nach unten an:</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside the current module.</source>
          <target state="translated">Im aktuellen Modul definierte Erweiterungsmethoden.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside data types in the current namespace or any one of its parents, with child namespaces having higher precedence than parent namespaces.</source>
          <target state="translated">Erweiterungsmethoden, die innerhalb von Datentypen im aktuellen Namespace oder in übergeordneten Namespaces definiert sind, wobei untergeordnete Namespaces eine höhere Rangfolge als übergeordnete Namespaces haben.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside any type imports in the current file.</source>
          <target state="translated">In Typimporten in der aktuellen Datei definierte Erweiterungsmethoden.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside any namespace imports in the current file.</source>
          <target state="translated">In Namespaceimporten in der aktuellen Datei definierte Erweiterungsmethoden.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside any project-level type imports.</source>
          <target state="translated">In Typimporten auf Projektebene definierte Erweiterungsmethoden.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside any project-level namespace imports.</source>
          <target state="translated">In Namespaceimporten auf Projektebene definierte Erweiterungsmethoden.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If precedence does not resolve the ambiguity, you can use the fully qualified name to specify the method that you are calling.</source>
          <target state="translated">Wenn sich die Mehrdeutigkeit durch die Anwendung einer Rangfolge nicht auflösen lässt, können Sie den vollqualifizierten Namen zum Festlegen der aufgerufenen Methode verwenden.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Print`</ph> method in the earlier example is defined in a module named <ph id="ph2">`StringExtensions`</ph>, the fully qualified name is <ph id="ph3">`StringExtensions.Print(example)`</ph> instead of <ph id="ph4">`example.Print()`</ph>.</source>
          <target state="translated">Wenn die <ph id="ph1">`Print`</ph>-Methode aus dem vorherigen Beispiel in einem Modul mit dem Namen <ph id="ph2">`StringExtensions`</ph> definiert wird, lautet der vollqualifizierte Name <ph id="ph3">`StringExtensions.Print(example)`</ph> und nicht <ph id="ph4">`example.Print()`</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Siehe auch</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Runtime.CompilerServices&gt;</source>
          <target state="translated">&lt;xref:System.Runtime.CompilerServices&gt;&lt;/xref:System.Runtime.CompilerServices&gt;</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Runtime.CompilerServices.ExtensionAttribute&gt;</source>
          <target state="translated">&lt;xref:System.Runtime.CompilerServices.ExtensionAttribute&gt;&lt;/xref:System.Runtime.CompilerServices.ExtensionAttribute&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Extension Methods<ept id="p1">](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Erweiterungsmethoden<ept id="p1">](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Module Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/module-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Module-Anweisung<ept id="p1">](../../../../visual-basic/language-reference/statements/module-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Procedure Parameters and Arguments<ept id="p1">](./procedure-parameters-and-arguments.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Prozedurparameter und Argumente<ept id="p1">](./procedure-parameters-and-arguments.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Optional Parameters<ept id="p1">](./optional-parameters.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Optionale Parameter<ept id="p1">](./optional-parameters.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Parameter Arrays<ept id="p1">](./parameter-arrays.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Parameterarrays<ept id="p1">](./parameter-arrays.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Attributes overview<ept id="p1">](../../../../visual-basic/programming-guide/concepts/attributes/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Übersicht über Attribute<ept id="p1">](../../../../visual-basic/programming-guide/concepts/attributes/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Scope in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Gültigkeitsbereich in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>