<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c8ff0f81054feddb4ee7042926c817de525034f9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\async-in-depth.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4a59cc5bc6b7d68b057f06623b3cc2f09799a72f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6ad464a4806ef09df47b4d06900d8102ffaf398b</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file async-in-depth.16b4c489db1495cae0a0120c706ec82c79fdaad1.es-es.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Async in depth</source>
          <target state="translated">Async en profundidad</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>In-depth explanation of how asynchronous code works in .NET</source>
          <target state="translated">Explicación detallada sobre cómo funciona el código asincrónico en .NET</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, .NET Standard</source>
          <target state="translated">.NET, .NET Core, .NET Standard</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Async in depth</source>
          <target state="translated">Async en profundidad</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</source>
          <target state="translated">La escritura de código asincrónico enlazado a E/S y CPU es sencilla al usar el modelo asincrónico basado en tareas de .NET.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The model is exposed by the <ph id="ph1">`Task`</ph> and <ph id="ph2">`Task&lt;T&gt;`</ph> types and the <ph id="ph3">`async`</ph> and <ph id="ph4">`await`</ph> language keywords.</source>
          <target state="translated">El modelo se expone mediante los tipos <ph id="ph1">`Task`</ph> y <ph id="ph2">`Task&lt;T&gt;`</ph> y las palabras claves de lenguaje <ph id="ph3">`async`</ph> y <ph id="ph4">`await`</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This article explains how to use .NET async and provides insight into the async framework used under the covers.</source>
          <target state="translated">En este artículo, se explica cómo usar Async de .NET y se proporciona información sobre el marco de trabajo de Async usado en segundo plano.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Task and Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph></source>
          <target state="translated">Task y Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Tasks are constructs used to implement what is known as the <bpt id="p1">[</bpt>Promise Model of Concurrency<ept id="p1">](https://en.wikipedia.org/wiki/Futures_and_promises)</ept>.</source>
          <target state="translated">Las tareas son construcciones que se usan para implementar lo que se conoce como el <bpt id="p1">[</bpt>modelo de promesa de simultaneidad<ept id="p1">](https://en.wikipedia.org/wiki/Futures_and_promises)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</source>
          <target state="translated">En resumen, le ofrecen una "promesa" de que el trabajo se completará en un momento posterior, lo que le permite coordinarse con la promesa con una API limpia.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task`</ph> represents a single operation which does not return a value.</source>
          <target state="translated"><ph id="ph1">`Task`</ph> representa una única operación que no devuelve un valor.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task&lt;T&gt;`</ph> represents a single operation which returns a value of type <ph id="ph2">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Task&lt;T&gt;`</ph> representa una única operación que devuelve un valor de tipo <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It’s important to reason about tasks as abstractions of work happening asynchronously, and <bpt id="p1">*</bpt>not<ept id="p1">*</ept> an abstraction over threading.</source>
          <target state="translated">Es importante razonar sobre las tareas como abstracciones de trabajo que se producen de forma asincrónica y <bpt id="p1">*</bpt>no<ept id="p1">*</ept> una abstracción sobre subprocesos.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</source>
          <target state="translated">De manera predeterminada, las tareas se ejecutan en el trabajo de subproceso y delegado actual del sistema operativo, según corresponda.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Optionally, tasks can be be explicitly requested to run on a separate thread via the <ph id="ph1">`Task.Run`</ph> API.</source>
          <target state="translated">De forma opcional, se puede solicitar de forma explícita que se ejecuten las tareas en un subproceso independiente mediante la API <ph id="ph1">`Task.Run`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of <ph id="ph1">`Task&lt;T&gt;`</ph>) of a task.</source>
          <target state="translated">Las tareas exponen un protocolo de API para supervisar, esperar y acceder al valor del resultado (en el caso de <ph id="ph1">`Task&lt;T&gt;`</ph>) de una tarea.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Language integration, with the <ph id="ph1">`await`</ph> keyword, provides a higher-level abstraction for using tasks.</source>
          <target state="translated">La integración de lenguajes, con la palabra clave <ph id="ph1">`await`</ph>, proporciona una abstracción de alto nivel para usar tareas.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Using <ph id="ph1">`await`</ph> allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</source>
          <target state="translated">Mediante <ph id="ph1">`await`</ph>, su aplicación o servicio puede realizar trabajo útil mientras se ejecuta una tarea al ceder el control a su llamador hasta que se realiza la tarea.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</source>
          <target state="translated">El código no tiene que depender de las devoluciones de llamada ni eventos para seguir ejecutándose una vez completada la tarea.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The language and task API integration does that for you.</source>
          <target state="translated">La integración de la API de tareas y lenguajes se encarga de ello.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If you’re using <ph id="ph1">`Task&lt;T&gt;`</ph>, the <ph id="ph2">`await`</ph> keyword will additionally “unwrap” the value returned when the Task is complete.</source>
          <target state="translated">Si está usando <ph id="ph1">`Task&lt;T&gt;`</ph>, la palabra clave <ph id="ph2">`await`</ph> "desencapsulará" también el valor devuelto cuando se completa la tarea.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The details of how this works are explained further below.</source>
          <target state="translated">Más adelante se explican los detalles sobre cómo funciona esto.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can learn more about tasks and the different ways to interact with them in the <bpt id="p1">[</bpt>Task-based Asynchronous Pattern (TAP) Article<ept id="p1">](https://msdn.microsoft.com/library/hh873175.aspx)</ept>.</source>
          <target state="translated">Puede obtener más información sobre las tareas y las distintas formas de interactuar con ellas en el <bpt id="p1">[</bpt>artículo Modelo asincrónico basado en tareas (TAP)<ept id="p1">](https://msdn.microsoft.com/library/hh873175.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Deeper Dive into Tasks for an I/O-Bound Operation</source>
          <target state="translated">Tareas para una operación enlazada a E/S en profundidad</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following section describes a 10,000 foot view of what happens with a typical async I/O call.</source>
          <target state="translated">En la siguiente sección, se describe una vista general de lo que sucede con una llamada de E/S asincrónica normal.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Let's start with a couple examples.</source>
          <target state="translated">Comencemos con un par de ejemplos.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The first example calls an async method and returns an active task, likely yet to complete.</source>
          <target state="translated">En el primer ejemplo, se llama a un método asincrónico y se devuelve una tarea activa que, probablemente, aún esté sin completar.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The second example adds the use of he <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords to operate on the task.</source>
          <target state="translated">En el segundo ejemplo, se agrega el uso de las palabras clave <ph id="ph1">`async`</ph> y <ph id="ph2">`await`</ph> para que funcionen en la tarea.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The call to <ph id="ph1">`GetStringAsync()`</ph> calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</source>
          <target state="translated">La llamada a <ph id="ph1">`GetStringAsync()`</ph> se realiza a través de bibliotecas de .NET de nivel inferior (es posible que se llame a otros métodos asincrónicos) hasta que se alcanza una llamada de interoperabilidad de P/Invoke en una biblioteca de red nativa.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The native library may subsequently call into a System API call (such as <ph id="ph1">`write()`</ph> to a socket on Linux).</source>
          <target state="translated">La biblioteca nativa puede realizar posteriormente una llamada API del sistema (como <ph id="ph1">`write()`</ph> a un socket en Linux).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A task object will be created at the native/managed boundary, possibly using <bpt id="p1">[</bpt>TaskCompletionSource<ept id="p1">](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))</ept>.</source>
          <target state="translated">Se creará un objeto de tarea en el límite nativo o administrado, posiblemente mediante <bpt id="p1">[</bpt>TaskCompletionSource<ept id="p1">](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))</ept>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</source>
          <target state="translated">El objeto de tarea se pasará por las capas, funcionará en ellas o se devolverá directamente y, finalmente, se devuelve al llamador inicial.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In the second example above, a <ph id="ph1">`Task&lt;T&gt;`</ph> object will be returned from <ph id="ph2">`GetStringAsync`</ph>.</source>
          <target state="translated">En este segundo ejemplo, se devolverá un objeto <ph id="ph1">`Task&lt;T&gt;`</ph> de <ph id="ph2">`GetStringAsync`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The use of the <ph id="ph1">`await`</ph> keyword causes the method to return a newly created task object.</source>
          <target state="translated">El uso de la palabra clave <ph id="ph1">`await`</ph> hace que el método devuelva un objeto de tarea recién creado.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Control returns to the caller from this location in the <ph id="ph1">`GetFirstCharactersCountAsync`</ph> method.</source>
          <target state="translated">El control vuelve al llamador de esta ubicación en el método <ph id="ph1">`GetFirstCharactersCountAsync`</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The methods and properties of the <bpt id="p1">[</bpt>Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Threading.Tasks.Task%601)</ept> object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</source>
          <target state="translated">Los métodos y propiedades del objeto <bpt id="p1">[</bpt>Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Threading.Tasks.Task%601)</ept> permiten que los llamadores supervisen el progreso de la tarea, que se completará cuando se haya ejecutado el código restante en GetFirstCharactersCountAsync.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as <ph id="ph1">`/net`</ph> in the Linux Kernel).</source>
          <target state="translated">Después de la llamada API del sistema, la solicitud ahora está en el espacio del kernel, que avanza hacia el subsistema de red del sistema operativo (como <ph id="ph1">`/net`</ph> en Linux Kernel).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Here the OS will handle the networking request <bpt id="p1">*</bpt>asynchronously<ept id="p1">*</ept>.</source>
          <target state="translated">Aquí, el sistema operativo controlará la solicitud de red <bpt id="p1">*</bpt>de forma asincrónica<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and <bpt id="p1">*</bpt>then<ept id="p1">*</ept> a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</source>
          <target state="translated">Los detalles pueden ser diferentes según el sistema operativo usado (la llamada al controlador de dispositivo puede programarse como una señal devuelta al tiempo de ejecución o una llamada al controlador de dispositivo puede realizarse y <bpt id="p1">*</bpt>después<ept id="p1">*</ept> se devuelve una señal), pero, finalmente, el tiempo de ejecución recibirá la información de que la solicitud de red está en curso.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</source>
          <target state="translated">En este momento, el trabajo del controlador de dispositivo estará programado, en curso o ya estará terminado (la solicitud ya estará "en la conexión"), pero como esto se produce de forma asincrónica, el controlador de dispositivo es capaz de controlar otra cosa de forma inmediata.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</source>
          <target state="translated">Por ejemplo, en Windows, un subproceso de sistema operativo realiza una llamada al controlador de dispositivo de red y le pide que realice la operación de red a través de un paquete de petición de interrupción (IRP) que representa la operación.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</source>
          <target state="translated">El controlador de dispositivo recibe el IRP, realiza la llamada a la red, marca el IRP como "pendiente" y vuelve al sistema operativo.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</source>
          <target state="translated">Ya que el subproceso de sistema operativo ahora sabe que el IRP está "pendiente", no tiene nada más que hacer en este trabajo y "vuelve", de modo que se puede usar para realizar otro trabajo.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</source>
          <target state="translated">Cuando se haya realizado la solicitud y regresen los datos a través del controlador de dispositivo, notifica a la CPU que se han recibido nuevos datos mediante una interrupción.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</source>
          <target state="translated">La forma en que se controla esta interrupción varía según el sistema operativo, pero, finalmente, los datos pasarán a través del sistema operativo hasta que lleguen a una llamada de interoperabilidad del sistema (por ejemplo, en Linux un controlador de interrupciones programará la mitad inferior de la IRQ para pasar los datos a través del sistema operativo de forma asincrónica).</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Note that this <bpt id="p1">*</bpt>also<ept id="p1">*</ept> happens asynchronously!</source>
          <target state="translated">Tenga en cuenta que esto <bpt id="p1">*</bpt>también<ept id="p1">*</ept> se produce de manera asincrónica.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The result is queued up until the next available thread is able execute the async method and "unwrap" the result of the completed task.</source>
          <target state="translated">El resultado se pone en cola hasta que el siguiente subproceso disponible puede ejecutar el método asincrónico y "desencapsular" el resultado de la tarea completada.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Throughout this entire process, a key takeaway is that <bpt id="p1">**</bpt>no thread is dedicated to running the task<ept id="p1">**</ept>.</source>
          <target state="translated">A lo largo de todo este proceso, un punto clave es que <bpt id="p1">**</bpt>ningún subproceso se dedica a ejecutar la tarea<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Although work is executed in some context (i.e. the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to <bpt id="p1">*</bpt>waiting<ept id="p1">*</ept> for data from the request to come back.</source>
          <target state="translated">Aunque el trabajo se ejecuta en algún contexto (es decir, el sistema operativo tiene que pasar datos a un controlador de dispositivo y responder a una interrupción), no hay ningún subproceso dedicado a <bpt id="p1">*</bpt>esperar<ept id="p1">*</ept> a que vuelvan los datos de la solicitud.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</source>
          <target state="translated">Esto permite al sistema controlar un volumen de trabajo mucho mayor en lugar de esperar a que finalicen algunas llamadas de E/S.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</source>
          <target state="translated">Aunque lo anterior puede parecer mucho trabajo que realizar, al medirlo en términos de tiempo de reloj, es ínfimo en comparación con el tiempo necesario para realizar el trabajo de E/S real.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Although not at all precise, a potential timeline for such a call would look like this:</source>
          <target state="translated">Aunque no es exacta, una escala de tiempo posible para una llamada de este estilo tendría este aspecto:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>0-1————————————————————————————————————————————————–2-3</source>
          <target state="translated">0-1————————————————————————————————————————————————–2-3</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Time spent from points <ph id="ph1">`0`</ph> to <ph id="ph2">`1`</ph> is everything up until an async method yields control to its caller.</source>
          <target state="translated">El tiempo empleado de los puntos <ph id="ph1">`0`</ph> a <ph id="ph2">`1`</ph> es todo hasta que un método asincrónico cede el control a su llamador.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Time spent from points <ph id="ph1">`1`</ph> to <ph id="ph2">`2`</ph> is the time spent on I/O, with no CPU cost.</source>
          <target state="translated">El tiempo empleado de los puntos <ph id="ph1">`1`</ph> a <ph id="ph2">`2`</ph> es el tiempo transcurrido en E/S, sin ningún costo de CPU.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Finally, time spent from points <ph id="ph1">`2`</ph> to <ph id="ph2">`3`</ph> is passing control back (and potentially a value) to the async method, at which point it is executing again.</source>
          <target state="translated">Por último, el tiempo empleado de los puntos <ph id="ph1">`2`</ph> a <ph id="ph2">`3`</ph> es durante el que se pasa el control (y posiblemente un valor) de nuevo al método asincrónico, momento en que se vuelve a ejecutar.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>What does this mean for a server scenario?</source>
          <target state="translated">¿Qué significa esto en un escenario de servidor?</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This model works well with a typical server scenario workload.</source>
          <target state="translated">Este modelo funciona bien con una carga de trabajo de escenario de servidor típica.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</source>
          <target state="translated">Ya que no hay ningún subproceso dedicado al bloqueo de tareas incompletas, el grupo de subprocesos de servidor puede atender a un mayor volumen de solicitudes web.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Consider two servers: one that runs async code, and one that does not.</source>
          <target state="translated">Considere dos servidores: uno que ejecute código asincrónico y otro que no lo haga.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For the purpose of this example, each server only has 5 threads available to service requests.</source>
          <target state="translated">Para este ejemplo, cada servidor tiene solo 5 subprocesos disponibles para las solicitudes de servicio.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Note that these numbers are imaginarily small and serve only in a demonstrative context.</source>
          <target state="translated">Tenga en cuenta que estos números son pequeños y sirven solo en un contexto demostrativo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Assume both servers receive 6 concurrent requests.</source>
          <target state="translated">Suponga que ambos servidores reciben seis solicitudes simultáneas.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Each request performs an I/O operation.</source>
          <target state="translated">Cada solicitud realiza una operación de E/S.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The server <bpt id="p1">*</bpt>without<ept id="p1">*</ept> async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</source>
          <target state="translated">El servidor <bpt id="p1">*</bpt>sin<ept id="p1">*</ept> código asincrónico tiene que poner en cola la solicitud 6 hasta que uno de los 5 subprocesos haya finalizado el trabajo enlazado a E/S y escrito una respuesta.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</source>
          <target state="translated">En el momento en que entre la solicitud 20, el servidor puede comenzar a ralentizarse, porque la cola se extiende demasiado.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The server <bpt id="p1">*</bpt>with<ept id="p1">*</ept> async code running on it still queues up the 6th request, but because it uses <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph>, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</source>
          <target state="translated">El servidor <bpt id="p1">*</bpt>con<ept id="p1">*</ept> código asincrónico en ejecución también pone en cola la solicitud 6, pero ya que usa <ph id="ph1">`async`</ph> y <ph id="ph2">`await`</ph>, cada uno de los subprocesos se libera cuando se inicia el trabajo enlazado a E/S, en lugar de cuando finaliza.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</source>
          <target state="translated">Cuando llega la solicitud 20, la cola de solicitudes entrantes será mucho más pequeña (en caso de que haya algo) y no se ralentiza el servidor.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Although this is a contrived example, it works in a very similar fashion in the real world.</source>
          <target state="translated">Aunque se trata de un ejemplo inventado, ocurre de forma muy similar en el mundo real.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In fact, you can expect a server to be able to handle an order of magnitude more requests using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> than if it were dedicating a thread for each request it receives.</source>
          <target state="translated">De hecho, puede esperar que un servidor pueda controlar más solicitudes mediante <ph id="ph1">`async`</ph> y <ph id="ph2">`await`</ph> que si se dedicaba a un subproceso para cada solicitud que recibe.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>What does this mean for client scenario?</source>
          <target state="translated">¿Qué significa esto en un escenario de cliente?</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The biggest gain for using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> for a client app is an increase in responsiveness.</source>
          <target state="translated">El mayor beneficio al usar <ph id="ph1">`async`</ph> y <ph id="ph2">`await`</ph> para una aplicación cliente es un aumento en la capacidad de respuesta.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph>.</source>
          <target state="translated">Aunque puede crear una aplicación dinámica al generar subprocesos de forma manual, el hecho de generar un subproceso es una operación costosa en comparación a usar solo <ph id="ph1">`async`</ph> y <ph id="ph2">`await`</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</source>
          <target state="translated">Especialmente en el caso de juegos para móviles, es fundamental afectar lo mínimo posible al subproceso de interfaz de usuario en lo que a E/S se refiere.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</source>
          <target state="translated">Sobre todo, ya que el trabajo enlazado a E/S no invierte prácticamente ningún tiempo en la CPU, dedicar un subproceso de CPU completo a realizar prácticamente ningún trabajo útil sería un mal uso de recursos.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with <ph id="ph1">`async`</ph> methods, and does not require extra work (such as calling a thread-safe delegate).</source>
          <target state="translated">Además, es muy sencillo enviar trabajo al subproceso de interfaz de usuario (como actualizar una interfaz de usuario) con métodos <ph id="ph1">`async`</ph> y no requiere trabajo adicional (como llamar a un delegado seguro para subprocesos).</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Deeper Dive into Task and Task<ph id="ph1">&lt;T&gt;</ph> for a CPU-Bound Operation</source>
          <target state="translated">Task y Task<ph id="ph1">&lt;T&gt;</ph> para una operación enlazada a la CPU en profundidad</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>CPU-bound <ph id="ph1">`async`</ph> code is a bit different than I/O-bound <ph id="ph2">`async`</ph> code.</source>
          <target state="translated">El código <ph id="ph1">`async`</ph> enlazado a la CPU es un poco diferente del código <ph id="ph2">`async`</ph> enlazado a E/S.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</source>
          <target state="translated">Ya que el trabajo se realiza en la CPU, no hay ninguna forma de evitar dedicar un subproceso al cálculo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The use of <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</source>
          <target state="translated">El uso de <ph id="ph1">`async`</ph> y <ph id="ph2">`await`</ph> le proporciona una manera clara de interactuar con subprocesos en segundo plano y mantener al llamador del método asincrónico dinámico.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Note that this does not provide any protection for shared data.</source>
          <target state="translated">Tenga en cuenta que esto no proporciona ninguna protección para datos compartidos.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If you are using shared data, you will still need to apply an appropriate synchronization strategy.</source>
          <target state="translated">Si usa datos compartidos, aún tendrá que aplicar una estrategia de sincronización adecuada.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Here's a 10,000 foot view of a CPU-bound async call:</source>
          <target state="translated">Esta es una vista general de una llamada asincrónica enlazada a la CPU:</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CalculateResult()`</ph> executes on the thread it was called on.</source>
          <target state="translated"><ph id="ph1">`CalculateResult()`</ph> se ejecuta en el subproceso en que se ha llamado.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When it calls <ph id="ph1">`Task.Run`</ph>, it queues the expensive CPU-bound operation, <ph id="ph2">`DoExpensiveCalculation()`</ph>, on the thread pool and receives a <ph id="ph3">`Task&lt;int&gt;`</ph> handle.</source>
          <target state="translated">Cuando llama a <ph id="ph1">`Task.Run`</ph>, pone en cola la operación costosa enlazada a la CPU, <ph id="ph2">`DoExpensiveCalculation()`</ph>, en el grupo de subprocesos y recibe un controlador <ph id="ph3">`Task&lt;int&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`DoExpensiveCalculation()`</ph> is eventually run concurrently on the next available thread, likely on another CPU core.</source>
          <target state="translated"><ph id="ph1">`DoExpensiveCalculation()`</ph> se ejecuta finalmente de forma simultánea en el siguiente subproceso disponible, probablemente en otro núcleo de CPU.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>It's possible to do concurrent work while <ph id="ph1">`DoExpensiveCalculation()`</ph> is busy on another thread, because the thread which called <ph id="ph2">`CalculateResult()`</ph> is still executing.</source>
          <target state="translated">Es posible realizar trabajo simultáneo mientras <ph id="ph1">`DoExpensiveCalculation()`</ph> está ocupado en otro subproceso, ya que el subproceso que llama a <ph id="ph2">`CalculateResult()`</ph> aún se está ejecutando.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Once <ph id="ph1">`await`</ph> is encountered, the execution of <ph id="ph2">`CalculateResult()`</ph> is yielded to its caller, allowing other work to be done with the current thread while <ph id="ph3">`DoExpensiveCalculation()`</ph> is churning out a result.</source>
          <target state="translated">Una vez se encuentra <ph id="ph1">`await`</ph>, la ejecución de <ph id="ph2">`CalculateResult()`</ph> se cede a su llamador, lo que permite que se realice otro trabajo con el subproceso actual mientras <ph id="ph3">`DoExpensiveCalculation()`</ph> genera un resultado.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Once it has finished, the result is queued up to run on the main thread.</source>
          <target state="translated">Una vez que haya finalizado, el resultado se pone en la cola para ejecutarse en el subproceso principal.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Eventually, the main thread will return to executing <ph id="ph1">`CalculateResult()`</ph>, at which point it will have the result of <ph id="ph2">`DoExpensiveCalculation()`</ph>.</source>
          <target state="translated">Finalmente, el subproceso principal volverá a ejecutar <ph id="ph1">`CalculateResult()`</ph>, momento en que tendrá el resultado de <ph id="ph2">`DoExpensiveCalculation()`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Why does async help here?</source>
          <target state="translated">¿Por qué ayuda Async en este caso?</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> are the best practice managing CPU-bound work when you need responsiveness.</source>
          <target state="translated"><ph id="ph1">`async`</ph> y <ph id="ph2">`await`</ph> son el procedimiento recomendado para administrar el trabajo enlazado a la CPU si necesita capacidad de respuesta.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>There are multiple patterns for using async with CPU-bound work.</source>
          <target state="translated">Hay varios patrones para usar Async con trabajo enlazado a la CPU.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>It's important to note that there is a small cost to using async and it's not recommended for tight loops.</source>
          <target state="translated">Es importante tener en cuenta que hay un pequeño costo al usar Async y no se recomienda para bucles de pequeñas dimensiones.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>It's up to you to determine how you write your code around this new capability.</source>
          <target state="translated">Depende de usted determinar cómo escribe el código en torno a esta nueva funcionalidad.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>