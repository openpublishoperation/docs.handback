<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">78a2d593329f0703c71df2462cfea30b02adff85</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\garbagecollection\fundamentals.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">85a4bd245b454c9539a05fdc0b6d548183dc1719</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a133fcf1682fb9d6842cc13c4d3d26b678aee967</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file fundamentals.e319dcfe892bc4f575f9356af8a79a5c663fa818.es-es.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Fundamentals of garbage collection</source>
          <target state="translated">Fundamentos de la recolección de elementos no utilizados</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Fundamentals of garbage collection</source>
          <target state="translated">Fundamentos de la recolección de elementos no utilizados</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Fundamentals of garbage collection</source>
          <target state="translated">Fundamentos de la recolección de elementos no utilizados</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In the Common Language Runtime (CLR), the garbage collector serves as an automatic memory manager.</source>
          <target state="translated">En el Common Language Runtime (CLR), el recolector de elementos no utilizados actúa como administrador de memoria automático.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It provides the following benefits:</source>
          <target state="translated">Proporciona las siguientes ventajas:</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Enables you to develop your application without having to free memory.</source>
          <target state="translated">Permite desarrollar la aplicación sin tener que liberar memoria.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Allocates objects on the managed heap efficiently.</source>
          <target state="translated">Asigna con eficacia los objetos del montón administrado.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</source>
          <target state="translated">Reclama los objetos que ya no se utilizan, borra la memoria correspondiente y mantiene la memoria disponible para asignaciones futuras.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.</source>
          <target state="translated">Los objetos administrados obtienen automáticamente contenido limpio desde el principio, de modo que sus constructores no tienen que inicializar todos los campos de datos.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Provides memory safety by making sure that an object cannot use the content of another object.</source>
          <target state="translated">Proporciona seguridad de memoria, al asegurarse de que un objeto no pueda utilizar el contenido de otro objeto.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This topic describes the core concepts of garbage collection.</source>
          <target state="translated">En este tema se describen los conceptos básicos de la recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It contains the following sections:</source>
          <target state="translated">Contiene las siguientes secciones:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Fundamentals of memory<ept id="p1">](#fundamentals-of-memory)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Fundamentos de memoria<ept id="p1">](#fundamentals-of-memory)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Conditions for a garbage collection<ept id="p1">](#conditions-for-a-garbage-collection)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Condiciones para la recolección de elementos no utilizados<ept id="p1">](#conditions-for-a-garbage-collection)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The managed heap<ept id="p1">](#the-managed-heap)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Montón administrado<ept id="p1">](#the-managed-heap)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generations<ept id="p1">](#generations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generaciones<ept id="p1">](#generations)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>What happens during a garbage collection<ept id="p1">](#what-happens-during-a-garbage-collection)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Lo que sucede durante la recolección de elementos no utilizados<ept id="p1">](#what-happens-during-a-garbage-collection)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Manipulating unmanaged resources<ept id="p1">](#manipulating-unmanaged-resources)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Manipular recursos no administrados<ept id="p1">](#manipulating-unmanaged-resources)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Fundamentals of memory</source>
          <target state="translated">Fundamentos de memoria</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The following list summarizes important CLR memory concepts.</source>
          <target state="translated">En la lista siguiente se resumen los conceptos importantes de memoria de CLR.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Each process has its own, separate virtual address space.</source>
          <target state="translated">Cada proceso tiene propio espacio de direcciones virtuales independiente.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>All processes on the same computer share the same physical memory, and share the page file if there is one.</source>
          <target state="translated">Todos los procesos del equipo comparten la misma memoria física y comparten el archivo de paginación si hay alguno.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</source>
          <target state="translated">De forma predeterminada, en los equipos de 32 bits, cada proceso tiene un espacio de direcciones virtuales en modo usuario de 2 GB.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>As an application developer, you work only with virtual address space and never manipulate physical memory directly.</source>
          <target state="translated">Como desarrollador de aplicaciones, solo trabaja con el espacio de direcciones virtuales y nunca manipula la memoria física directamente.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The garbage collector allocates and frees virtual memory for you on the managed heap.</source>
          <target state="translated">El recolector de elementos no utilizados asigna y libera memoria virtual en el montón administrado.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Virtual memory can be in three states:</source>
          <target state="translated">La memoria virtual puede estar en tres estados:</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Free.</source>
          <target state="translated">Libre.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The block of memory has no references to it and is available for allocation.</source>
          <target state="translated">El bloque de memoria no tiene ninguna referencia a ella y está disponible para su asignación.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Reserved.</source>
          <target state="translated">Reservado.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The block of memory is available for your use and cannot be used for any other allocation request.</source>
          <target state="translated">El bloque de memoria está disponible para su uso y no se puede emplear para ninguna otra solicitud de asignación.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>However, you cannot store data to this memory block until it is committed.</source>
          <target state="translated">Sin embargo, no puede almacenar datos en este bloque de memoria hasta que se confirme.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Committed.</source>
          <target state="translated">Confirmado.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The block of memory is assigned to physical storage.</source>
          <target state="translated">El bloque de memoria se asigna al almacenamiento físico.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Virtual address space can get fragmented.</source>
          <target state="translated">El espacio de direcciones virtuales puede llegar a fragmentarse.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This means that there are free blocks, also known as holes, in the address space.</source>
          <target state="translated">Esto significa que hay bloques libres, también conocidos como marcadores, en el espacio de direcciones.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</source>
          <target state="translated">Cuando se solicita una asignación de memoria virtual, el administrador de memoria virtual tiene que encontrar un único bloque libre que sea suficientemente grande para satisfacer esa solicitud de asignación.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Even if you have 2 GB of free space, the allocation that requires 2 GB will be unsuccessful unless all of that space is in a single address block.</source>
          <target state="translated">Aunque tenga 2 GB de espacio disponible, la asignación que necesita 2 GB será incorrecta a menos que todo ese espacio esté en un único bloque de direcciones.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You can run out of memory if you run out of virtual address space to reserve or physical space to commit.</source>
          <target state="translated">Puede quedarse sin memoria si no tiene espacio de direcciones virtuales para reservar o espacio físico para confirmar.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Your page file is used even if physical memory pressure (that is, demand for physical memory) is low.</source>
          <target state="translated">El archivo de paginación se usa aunque haya poca necesidad de memoria física (es decir, demanda de memoria física).</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The first time your physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</source>
          <target state="translated">La primera vez que se necesita mucha memoria física, el sistema operativo debe hacer sitio en la memoria física para almacenar los datos y hace una copia de seguridad en el archivo de paginación de algunos datos que están en la memoria física.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>That data is not paged until it is needed, so it is possible to encounter paging in situations where the physical memory pressure is very low.</source>
          <target state="translated">Esos datos no se paginan hasta que no se necesitan, por lo que es posible encontrar paginación en situaciones donde haya muy poca necesidad de memoria física.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Conditions for a garbage collection</source>
          <target state="translated">Condiciones para la recolección de elementos no utilizados</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Garbage collection occurs when one of the following conditions is true:</source>
          <target state="translated">La recolección de elementos no utilizados se produce cuando se cumple alguna de las siguientes condiciones:</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The system has low physical memory.</source>
          <target state="translated">El sistema tiene poca memoria física.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The memory that is used by allocated objects on the managed heap surpasses an acceptable threshold.</source>
          <target state="translated">La memoria que utilizan los objetos asignados del montón administrado supera un umbral aceptable.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This threshold is continuously adjusted as the process runs.</source>
          <target state="translated">Este umbral se ajusta continuamente a medida que se ejecuta el proceso.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>GC.Collect<ept id="p1">](xref:System.GC.Collect)</ept> method is called.</source>
          <target state="translated">Se llama al método <bpt id="p1">[</bpt>GC.Collect<ept id="p1">](xref:System.GC.Collect)</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>In almost all cases, you do not have to call this method, because the garbage collector runs continuously.</source>
          <target state="translated">En casi todos casos, no es necesario llamar a este método, porque el recolector de elementos no utilizados se ejecuta continuamente.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This method is primarily used for unique situations and testing.</source>
          <target state="translated">Este método se utiliza principalmente para pruebas y situaciones singulares.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The managed heap</source>
          <target state="translated">Montón administrado</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</source>
          <target state="translated">Una vez que el CLR inicializa el recolector de elementos no utilizados, asigna un segmento de memoria para almacenar y administrar objetos.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This memory is called the managed heap, as opposed to a native heap in the operating system.</source>
          <target state="translated">Esta memoria se denomina montón administrado, y se diferencia del montón nativo del sistema operativo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>There is a managed heap for each managed process.</source>
          <target state="translated">Hay un montón administrado para cada proceso administrado.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>All threads in the process allocate memory for objects on the same heap.</source>
          <target state="translated">Todos los subprocesos del proceso asignan memoria a los objetos del mismo montón.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</source>
          <target state="translated">El tamaño de los segmentos asignados por el recolector de elementos no utilizados es específico de la implementación y está sujeto a cambios en cualquier momento, incluso en las actualizaciones periódicas.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</source>
          <target state="translated">La aplicación nunca debe realizar suposiciones sobre el tamaño de un sector determinado ni depender de él, y tampoco debe intentar configurar la cantidad de memoria disponible para las asignaciones de segmentos.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The fewer objects allocated on the heap, the less work the garbage collector has to do.</source>
          <target state="translated">Cuantos menos objetos se asignen al montón, menos trabajo tendrá que hacer el recolector de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When you allocate objects, do not use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</source>
          <target state="translated">Al asignar objetos, no use valores redondeados que superen sus necesidades; por ejemplo, no asigne una matriz de 32 bytes si solo necesita 15 bytes.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>When a garbage collection is triggered, the garbage collector reclaims the memory that is occupied by dead objects.</source>
          <target state="translated">Cuando se desencadena una recolección de elementos no utilizados, el recolector de elementos no utilizados reclama la memoria ocupada por objetos muertos.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</source>
          <target state="translated">El proceso de reclamación compacta los objetos activos para moverlos juntos, y el espacio muerto se quita, para reducir el montón.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This ensures that objects that are allocated together stay together on the managed heap, to preserve their locality.</source>
          <target state="translated">De este modo, se asegura de que los objetos que se asignan juntos permanezcan juntos en el montón administrado, a fin de conservar su situación.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</source>
          <target state="translated">La tendencia a la intrusión (frecuencia y duración) de las recolecciones de elementos no utilizados es el resultado del volumen de asignaciones y la cantidad de memoria que sobrevivió en el montón administrado.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The heap can be considered as the accumulation of two heaps: the large object heap and the small object heap.</source>
          <target state="translated">El montón considerarse una acumulación de dos montones: el montón de objetos grandes y el montón de objetos pequeños.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The large object heap contains very large objects that are 85,000 bytes and larger.</source>
          <target state="translated">El montón de objetos grandes contiene objetos muy grandes de 85.000 bytes o más.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The objects on the large object heap are usually arrays.</source>
          <target state="translated">Los objetos del montón de objetos grandes suelen ser matrices.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>It is rare for an instance object to be extremely large.</source>
          <target state="translated">Es raro que un objeto de instancia sea sumamente grande.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Generations</source>
          <target state="translated">Generaciones</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The heap is organized into generations so it can handle long-lived and short-lived objects.</source>
          <target state="translated">El montón se organiza en generaciones, para poder administrar objetos de larga y corta duración.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Garbage collection primarily occurs with the reclamation of short-lived objects that typically occupy only a small part of the heap.</source>
          <target state="translated">La recolección de elementos no utilizados se produce principalmente con la reclamación de objetos de corta duración que suelen ocupar solamente una parte reducida del montón.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>There are three generations of objects on the heap:</source>
          <target state="translated">Hay tres generaciones de objetos en el montón:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Generation 0.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Generación 0.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This is the youngest generation and contains short-lived objects.</source>
          <target state="translated">Es la generación más joven y contiene los objetos de corta duración.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>An example of a short-lived object is a temporary variable.</source>
          <target state="translated">Un ejemplo de objeto de corta duración es una variable temporal.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Garbage collection occurs most frequently in this generation.</source>
          <target state="translated">La recolección de elementos no utilizados se produce con mayor frecuencia en esta generación.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Newly allocated objects form a new generation of objects and are implicitly generation 0 collections, unless they are large objects, in which case they go on the large object heap in a generation 2 collection.</source>
          <target state="translated">Los objetos recién asignados constituyen una nueva generación de objetos e implícitamente son recolecciones de generación 0, a menos que sean objetos grandes, en cuyo caso entran en el montón de objetos grandes en una recolección de la generación 2.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Most objects are reclaimed for garbage collection in generation 0 and do not survive to the next generation.</source>
          <target state="translated">La mayoría de los objetos se reclaman para la recolección de elementos no utilizados en la generación 0 y no sobreviven a la generación siguiente.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Generation 1.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Generación 1.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</source>
          <target state="translated">Esta generación contiene objetos de corta duración y sirve como búfer entre los objetos de corta y larga duración.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Generation 2.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Generación 2.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This generation contains long-lived objects.</source>
          <target state="translated">Esta generación contiene los objetos de larga duración.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>An example of a long-lived object is an object in a server application that contains static data that is live for the duration of the process.</source>
          <target state="translated">Un ejemplo de objeto de larga duración es un objeto de una aplicación de servidor que contiene datos estáticos que están activos mientras dura el proceso.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Garbage collections occur on specific generations as conditions warrant.</source>
          <target state="translated">Las recolecciones de elementos no utilizados se producen en generaciones concretas según lo permitan las condiciones.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Collecting a generation means collecting objects in that generation and all its younger generations.</source>
          <target state="translated">La recolección de una generación significa recolectar los objetos de esa generación y de todas las generaciones anteriores.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A generation 2 garbage collection is also known as a full garbage collection, because it reclaims all objects in all generations (that is, all objects in the managed heap).</source>
          <target state="translated">Una recolección de elementos no utilizados de la generación 2 se denomina también recolección de elementos no utilizados completa, porque reclama todos los objetos de todas las generaciones (es decir, todos los objetos del montón administrado).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Survival and promotions</source>
          <target state="translated">Supervivencia y promociones</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Objects that are not reclaimed in a garbage collection are known as survivors, and are promoted to the next generation.</source>
          <target state="translated">Los objetos que no se reclaman en una recolección de elementos no utilizados se denominan supervivientes y se promueven a la generación siguiente.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Objects that survive a generation 0 garbage collection are promoted to generation 1; objects that survive a generation 1 garbage collection are promoted to generation 2; and objects that survive a generation 2 garbage collection remain in generation 2.</source>
          <target state="translated">Los objetos que sobreviven a una recolección de elementos no utilizados de la generación 0 se promueven a la generación 1; los que sobreviven a una recolección de elementos no utilizados de la generación 1 se promueven a la generación 2; y los que sobreviven a una recolección de elementos no utilizados de la generación 2 permanecen en esa misma generación.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation, so the next collection gets a substantial size of reclaimed memory.</source>
          <target state="translated">Cuando el recolector de elementos no utilizados detecta que la tasa de supervivencia es alta en una generación, aumenta el umbral de asignaciones para esa generación, de modo que la recolección siguiente obtenga un tamaño sustancial de memoria reclamada.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The CLR continually balances two priorities: not letting an application's working set get too big and not letting the garbage collection take too much time.</source>
          <target state="translated">El CLR equilibra continuamente dos prioridades: no permitir que el espacio de trabajo de una aplicación adquiera un tamaño excesivo y no permitir que la recolección de elementos no utilizados tarde demasiado tiempo.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Ephemeral generations and segments</source>
          <target state="translated">Generaciones y segmentos efímeros</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Because objects in generations 0 and 1 are short-lived, these generations are known as the ephemeral generations.</source>
          <target state="translated">Dado que los objetos de las generaciones 0 y 1 son de corta duración, estas generaciones se denominan generaciones efímeras.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Ephemeral generations must be allocated in the memory segment that is known as the ephemeral segment.</source>
          <target state="translated">Las generaciones efímeras se deben asignar en el segmento de memoria denominado segmento efímero.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</source>
          <target state="translated">Cada nuevo segmento adquirido por el recolector de elementos no utilizados se convierte en el nuevo segmento efímero y contiene los objetos que sobrevivieron a una recolección de elementos no utilizados de la generación 0.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The old ephemeral segment becomes the new generation 2 segment.</source>
          <target state="translated">El segmento efímero anterior se convierte en el nuevo segmento de la generación 2.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The ephemeral segment can include generation 2 objects.</source>
          <target state="translated">El segmento efímero puede incluir objetos de la generación 2.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</source>
          <target state="translated">Los objetos de la generación 2 pueden utilizar varios segmentos (tantos como necesite el proceso y la memoria permita).</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</source>
          <target state="translated">La cantidad de memoria liberada como consecuencia de una recolección de elementos no utilizados efímera se limita al tamaño del segmento efímero.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</source>
          <target state="translated">La cantidad de memoria que se libera es proporcional al espacio que ocupaban los objetos muertos.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>What happens during a garbage collection</source>
          <target state="translated">Lo que sucede durante la recolección de elementos no utilizados</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A garbage collection has the following phases:</source>
          <target state="translated">Una recolección de elementos no utilizados tiene las siguientes fases:</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>A marking phase that finds and creates a list of all live objects.</source>
          <target state="translated">Una fase de marcado que busca y crea una lista de todos los objetos activos.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>A relocating phase that updates the references to the objects that will be compacted.</source>
          <target state="translated">Una fase de reubicación, que actualiza las referencias a los objetos que se van a compactar.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</source>
          <target state="translated">Una fase de compactación, que reclama el espacio ocupado por los objetos muertos y compacta los objetos supervivientes.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</source>
          <target state="translated">En la fase de compactación se mueven los objetos que han sobrevivido a una recolección de elementos no utilizados hacia el extremo más antiguo del segmento.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</source>
          <target state="translated">Debido a que las recolecciones de la generación 2 pueden ocupar varios segmentos, los objetos que se promueven a la generación 2 se pueden mover a un segmento anterior.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</source>
          <target state="translated">Los supervivientes de las generaciones 1 y 2 se pueden mover a un segmento diferente, porque se promueven a la generación 2.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Ordinarily, the large object heap is not compacted, because copying large objects imposes a performance penalty.</source>
          <target state="translated">Normalmente, el montón de objetos grandes no se compacta, porque al copiar objetos grandes se reduce el rendimiento.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>However,  you can use the <bpt id="p1">[</bpt>GCSettings.LargeObjectHeapCompactionMode<ept id="p1">](xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode)</ept> property to compact the large object heap on demand.</source>
          <target state="translated">Pero puede usar la propiedad <bpt id="p1">[</bpt>GCSettings.LargeObjectHeapCompactionMode<ept id="p1">](xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode)</ept> para compactar el montón de objetos grandes a petición.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The garbage collector uses the following information to determine whether objects are live:</source>
          <target state="translated">El recolector de elementos no utilizados utiliza la siguiente información para determinar si los objetos están activos:</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Stack roots.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Raíces de la pila.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Stack variables provided by the just-in-time (JIT) compiler and stack walker.</source>
          <target state="translated">Variables de pila proporcionadas por el compilador Just-In-Time (JIT) y el rastreador de pila.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Garbage collection handles.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Identificadores de recolección de elementos no utilizados.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Handles that point to managed objects and that can be allocated by user code or by the Common Language Runtime.</source>
          <target state="translated">Identificadores que señalan a objetos administrados y que se pueden asignar mediante código de usuario o mediante Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Static data.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Datos estáticos.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Static objects in application domains that could be referencing other objects.</source>
          <target state="translated">Objetos estáticos de dominios de aplicación que podrían hacer referencia a otros objetos.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Each application domain keeps track of its static objects.</source>
          <target state="translated">Cada dominio de aplicación realiza el seguimiento de sus objetos estáticos.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</source>
          <target state="translated">Antes de que iniciarse una recolección de elementos no utilizados, todos los subprocesos administrados se suspenden salvo el subproceso que activó la recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</source>
          <target state="translated">En la ilustración siguiente se muestra un subproceso que desencadena una recolección de elementos no utilizados, lo que provoca la suspensión de los demás subprocesos.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>When a thread triggers a garbage collection</source>
          <target state="translated">Cuando un subproceso activa una recolección de elementos no utilizados</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Thread that triggers a garbage collection</source>
          <target state="translated">Subproceso que desencadena una recolección de elementos no utilizados</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Manipulating unmanaged resources</source>
          <target state="translated">Manipular recursos no administrados</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If your managed objects reference unmanaged objects by using their native file handles, you have to explicitly free the unmanaged objects, because the garbage collector tracks memory only on the managed heap.</source>
          <target state="translated">Si los objetos administrados hacen referencia a objetos no administrados mediante sus identificadores de archivos nativos, es necesario liberar explícitamente los objetos no administrados, ya que el recolector de elementos no utilizados únicamente realiza el seguimiento de la memoria del montón administrado.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Users of your managed object may not dispose the native resources used by the object.</source>
          <target state="translated">Los usuarios de su objeto administrado podrían no disponer de los recursos nativos utilizados por el objeto.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>To perform the cleanup, you can make your managed object finalizable.</source>
          <target state="translated">Para realizar la limpieza, puede hacer que su objeto administrado sea susceptible de finalización.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Finalization consists of cleanup actions that you execute when the object is no longer in use.</source>
          <target state="translated">La finalización está compuesta de acciones de limpieza que el usuario ejecuta cuando el objeto ya no se utiliza.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>When your managed object dies, it performs cleanup actions that are specified in its finalizer method.</source>
          <target state="translated">Cuando el objeto administrados muere, realiza acciones de limpieza que se especifican en su método finalizador.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>When a finalizable object is discovered to be dead, its finalizer is put in a queue so that its cleanup actions are executed, but the object itself is promoted to the next generation.</source>
          <target state="translated">Cuando se detecta que un objeto susceptible de finalización está muerto, su finalizador se coloca en una cola para que se ejecuten sus acciones de limpieza, pero el objeto en sí se promueve a la generación siguiente.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Therefore, you have to wait until the next garbage collection that occurs on that generation (which is not necessarily the next garbage collection) to determine whether the object has been reclaimed.</source>
          <target state="translated">Por tanto, tendrá que esperar hasta la siguiente recolección de elementos no utilizados que se produzca en esa generación (y que no tiene por qué ser necesariamente la próxima recolección de elementos no utilizados) para determinar si se ha recuperado el objeto.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Vea también</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Garbage collection in .NET<ept id="p1">](gc.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recolección de elementos no utilizados en .NET<ept id="p1">](gc.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>