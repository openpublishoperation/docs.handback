<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0734347048742657b8e33a1fffae15448ecad4f3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\garbagecollection\gc.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">28a616416d222585b1acea71f0a6d2ed046d62ee</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1337b68771f95336d70594d78f544bfa19cfa815</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file gc.2f1aa089a6b9f1ede72e2ee49882e7b7e8b4594f.es-es.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Automatic memory management and garbage collection</source>
          <target state="translated">Administración automática de la memoria y recolección de elementos no utilizados</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Automatic memory management and garbage collection</source>
          <target state="translated">Administración automática de la memoria y recolección de elementos no utilizados</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Automatic memory management and garbage collection</source>
          <target state="translated">Administración automática de la memoria y recolección de elementos no utilizados</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Automatic memory management is one of the services that the Common Language Runtime provides during managed execution.</source>
          <target state="translated">La administración de memoria automática es uno de los servicios que proporciona Common Language Runtime durante la ejecución administrada.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The Common Language Runtime's garbage collector manages the allocation and release of memory for an application.</source>
          <target state="translated">El recolector de elementos no utilizados de Common Language Runtime administra la asignación y liberación de la memoria de una aplicación.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For developers, this means that you do not have to write code to perform memory management tasks when you develop managed applications.</source>
          <target state="translated">Esto significa que los programadores no tienen que escribir código para realizar tareas de administración de memoria al programar aplicaciones administradas.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak, or attempting to access memory for an object that has already been freed.</source>
          <target state="translated">La administración automática de la memoria puede eliminar problemas frecuentes, como olvidar liberar un objeto y causar una pérdida de memoria, o intentar tener acceso a la memoria de un objeto que ya se ha liberado.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This section describes how the garbage collector allocates and releases memory.</source>
          <target state="translated">En esta sección se describe cómo asigna y libera memoria el recolector de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Allocating Memory</source>
          <target state="translated">Asignar memoria</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</source>
          <target state="translated">Cuando se inicializa un nuevo proceso, el motor en tiempo de ejecución reserva una región contigua de espacio de direcciones para el proceso.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This reserved address space is called the managed heap.</source>
          <target state="translated">Este espacio de direcciones reservado se denomina montón administrado.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</source>
          <target state="translated">El montón administrado mantiene un puntero a la dirección a la que se asignará el siguiente objeto del montón.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Initially, this pointer is set to the managed heap's base address.</source>
          <target state="translated">Inicialmente, este puntero se establece en la dirección base del montón administrado.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>All reference types are allocated on the managed heap.</source>
          <target state="translated">Todos los tipos de referencia se asignan en el montón administrado.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</source>
          <target state="translated">Cuando una aplicación crea el primer tipo de referencia, se le asigna memoria en la dirección base del montón administrado.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</source>
          <target state="translated">Cuando la aplicación crea el siguiente objeto, el recolector de elementos no utilizados le asigna memoria en el espacio de direcciones que sigue inmediatamente al primer objeto.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</source>
          <target state="translated">Siempre que haya espacio de direcciones disponible, el recolector de elementos no utilizados continúa asignando espacio a los objetos nuevos de este modo.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Allocating memory from the managed heap is faster than unmanaged memory allocation.</source>
          <target state="translated">La asignación de memoria desde el montón administrado es más rápida que la asignación de memoria no administrada.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Because the runtime allocates memory for an object by adding a value to a pointer, it is almost as fast as allocating memory from the stack.</source>
          <target state="translated">Como el tiempo de ejecución asigna memoria a los objetos agregando un valor a un puntero, este método es casi tan rápido como la asignación de memoria desde la pila.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects very quickly.</source>
          <target state="translated">Además, puesto que los nuevos objetos que se asignan consecutivamente se almacenan uno junto a otro en el montón administrado, la aplicación puede tener un acceso muy rápido a los objetos.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Releasing Memory</source>
          <target state="translated">Liberar memoria</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</source>
          <target state="translated">El motor de optimización del recolector de elementos no utilizados determina cuál es el mejor momento para realizar una recolección basándose en las asignaciones realizadas.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</source>
          <target state="translated">Cuando el recolector de elementos no utilizados lleva a cabo una recolección, libera la memoria de los objetos que ya no usa la aplicación.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It determines which objects are no longer being used by examining the application's roots.</source>
          <target state="translated">Determina qué objetos ya no se usan examinando las raíces de la aplicación.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Every application has a set of roots.</source>
          <target state="translated">Todas las aplicaciones tienen un conjunto de raíces.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Each root either refers to an object on the managed heap or is set to null.</source>
          <target state="translated">Cada raíz hace referencia a un objeto del montón administrado, o bien se establece en null.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</source>
          <target state="translated">Las raíces de una aplicación incluyen campos estáticos, variables locales y parámetros de pila de un subproceso y registros de la CPU.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The garbage collector has access to the list of active roots that the just-in-time (JIT) compiler and the runtime maintain.</source>
          <target state="translated">El recolector de elementos no utilizados tiene acceso a la lista de raíces activas que el compilador Just-In-Time (JIT) y el runtime mantienen.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Using this list, it examines an application's roots, and in the process creates a graph that contains all the objects that are reachable from the roots.</source>
          <target state="translated">Con esta lista examina las raíces de la aplicación y, durante este proceso, crea un gráfico que contiene todos los objetos que no se pueden alcanzar desde las raíces.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Objects that are not in the graph are unreachable from the application's roots.</source>
          <target state="translated">Los objetos que no están en el gráfico no se pueden alcanzar desde las raíces de la aplicación.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The garbage collector considers unreachable objects garbage and will release the memory allocated for them.</source>
          <target state="translated">El recolector de elementos no utilizados considera elementos no utilizados a los objetos inalcanzables y libera la memoria que tienen asignada.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</source>
          <target state="translated">Durante una recolección, el recolector de elementos no utilizados examina el montón administrado y busca los bloques de espacio de direcciones que ocupan los objetos que no se pueden alcanzar.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</source>
          <target state="translated">Cuando detecta cada uno de los objetos inalcanzables, usa una función de copia de memoria para compactar los objetos alcanzables en la memoria y libera los bloques de espacios de direcciones asignados a los objetos no alcanzables.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</source>
          <target state="translated">Una vez que se ha compactado la memoria de los objetos alcanzables, el recolector de elementos no utilizados hace las correcciones de puntero necesarias para que las raíces de la aplicación señalen a los objetos en sus nuevas ubicaciones.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>It also positions the managed heap's pointer after the last reachable object.</source>
          <target state="translated">También sitúa el puntero del montón administrado después del último objeto alcanzable.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Note that memory is compacted only if a collection discovers a significant number of unreachable objects.</source>
          <target state="translated">Tenga en cuenta que la memoria sólo se compacta si, durante una recolección, se detecta un número significativo de objetos inalcanzables.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</source>
          <target state="translated">Si todos los objetos del montón administrado sobreviven a una recolección, no hay necesidad de comprimir la memoria.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>To improve performance, the runtime allocates memory for large objects in a separate heap.</source>
          <target state="translated">Para mejorar el rendimiento, el tiempo de ejecución asigna memoria a los objetos grandes en un montón aparte.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The garbage collector automatically releases the memory for large objects.</source>
          <target state="translated">El recolector de elementos no utilizados libera la memoria para los objetos grandes automáticamente.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>However, to avoid moving large objects in memory, this memory is not compacted.</source>
          <target state="translated">Sin embargo, para no mover objetos grandes en la memoria, dicha memoria no se compacta.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Generations and Performance</source>
          <target state="translated">Generaciones y rendimiento</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>To optimize the performance of the garbage collector, the managed heap is divided into three generations: 0, 1, and 2.</source>
          <target state="translated">Para optimizar el rendimiento del recolector de elementos no utilizados, el montón administrado se divide en tres generaciones: 0, 1 y 2.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The runtime's garbage collection algorithm is based on several generalizations that the computer software industry has discovered to be true by experimenting with garbage collection schemes.</source>
          <target state="translated">El algoritmo de recolección de elementos no utilizados del runtime se basa en diversas generalizaciones que la industria de software informático ha detectado como ciertas al experimentar con esquemas de recolección de elementos no utilizados.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>First, it is faster to compact the memory for a portion of the managed heap than for the entire managed heap.</source>
          <target state="translated">Primero, es más rápido compactar la memoria de una parte del montón administrado que la de todo el montón.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Secondly, newer objects will have shorter lifetimes and older objects will have longer lifetimes.</source>
          <target state="translated">En segundo lugar, los objetos más recientes tienen una duración más corta y los objetos antiguos tienen una duración más larga.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Lastly, newer objects tend to be related to each other and accessed by the application around the same time.</source>
          <target state="translated">Por último, los objetos más recientes suelen estar relacionados unos con otros y la aplicación tiene acceso a ellos más o menos al mismo tiempo.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The runtime's garbage collector stores new objects in generation 0.</source>
          <target state="translated">El recolector de elementos no utilizados del runtime almacena los nuevos objetos en la generación 0.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</source>
          <target state="translated">Los objetos creados en las primeras etapas de la duración de la aplicación y que sobreviven a las recolecciones se promueven y se almacenan en las generaciones 1 y 2.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The process of object promotion is described later in this topic.</source>
          <target state="translated">El proceso de promoción de objetos se describe más adelante en este tema.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Because it is faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</source>
          <target state="translated">Como es más rápido compactar una parte del montón administrado que todo el montón, este esquema permite que el recolector de elementos no utilizados libere la memoria en una generación específica en lugar de liberarla para todo el montón administrado cada vez que realiza una recolección.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>In reality, the garbage collector performs a collection when generation 0 is full.</source>
          <target state="translated">En realidad, el recolector de elementos no utilizados realiza una recolección cuando se llena la generación 0.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>If an application attempts to create a new object when generation 0 is full, the garbage collector discovers that there is no address space remaining in generation 0 to allocate for the object.</source>
          <target state="translated">Si una aplicación trata de crear un nuevo objeto cuando la generación 0 está llena, el recolector de elementos no utilizados detecta que no queda espacio de direcciones en la generación 0 para asignárselo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The garbage collector performs a collection in an attempt to free address space in generation 0 for the object.</source>
          <target state="translated">El recolector de elementos no utilizados realiza una recolección, en un intento de liberar espacio de direcciones para el objeto en la generación 0.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</source>
          <target state="translated">Primero examina los objetos de la generación 0 y no todos los objetos del montón administrado.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This is the most efficient approach, because new objects tend to have short lifetimes, and it is expected that many of the objects in generation 0 will no longer be in use by the application when a collection is performed.</source>
          <target state="translated">Éste es un enfoque más eficaz, ya que los objetos nuevos suelen tener una duración más corta y se espera que la aplicación no utilice muchos de los objetos de la generación 0 cuando se realice una recolección.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In addition, a collection of generation 0 alone often reclaims enough memory to allow the application to continue creating new objects.</source>
          <target state="translated">Además, una recolección de tan sólo la generación 0 a menudo recupera suficiente memoria para que la aplicación pueda continuar creando nuevos objetos.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects as explained in <bpt id="p1">[</bpt>Releasing Memory<ept id="p1">](#releasing-memory)</ept> earlier in this topic.</source>
          <target state="translated">Una vez que el recolector de elementos no utilizados realiza una recolección de la generación 0, compacta la memoria de los objetos que se pueden alcanzar como se ha explicado antes en este tema, en <bpt id="p1">[</bpt>Liberar memoria<ept id="p1">](#releasing-memory)</ept>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The garbage collector then promotes these objects and considers this portion of the managed heap generation 1.</source>
          <target state="translated">A continuación, el recolector de elementos no utilizados promueve estos objetos y considera que esta parte del montón administrado está en la generación 1.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</source>
          <target state="translated">Dado que los objetos que sobreviven a las recolecciones suelen tener una duración más larga, es lógico promoverlos a una generación superior.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>As a result, the garbage collector does not have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</source>
          <target state="translated">En consecuencia, el recolector de elementos no utilizados no tiene que volver a examinar los objetos de las generaciones 1 y 2 cada vez que realiza una recolección en la generación 0.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>After the garbage collector performs its first collection of generation 0 and promotes the reachable objects to generation 1, it considers the remainder of the managed heap generation 0.</source>
          <target state="translated">Una vez que el recolector de elementos no utilizados realiza su primera recolección de la generación 0 y promueve los objetos que se pueden alcanzar a la generación 1, considera que lo que queda del montón administrado forma parte de la generación 0.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>It continues to allocate memory for new objects in generation 0 until generation 0 is full and it is necessary to perform another collection.</source>
          <target state="translated">Continúa asignando memoria a los nuevos objetos de la generación 0 hasta que la generación 0 está completa y es necesario realizar otra recolección.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>At this point, the garbage collector's optimizing engine determines whether it is necessary to examine the objects in older generations.</source>
          <target state="translated">En este momento, el motor de optimización del recolector de elementos no utilizados determina si es necesario examinar los objetos de generaciones más antiguas.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For example, if a collection of generation 0 does not reclaim enough memory for the application to successfully complete its attempt to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</source>
          <target state="translated">Por ejemplo, si una recolección de la generación 0 no recupera memoria suficiente para que la aplicación pueda completar correctamente su intento de crear un nuevo objeto, el recolector de elementos no utilizados puede realizar una recolección de la generación 1 y, a continuación, de la generación 2.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If this does not reclaim enough memory, the garbage collector can perform a collection of generations 2, 1, and 0.</source>
          <target state="translated">Si con ello no recupera suficiente memoria, el recolector de elementos no utilizados puede realizar una recolección de las generaciones 2, 1 y 0.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>After each collection, the garbage collector compacts the reachable objects in generation 0 and promotes them to generation 1.</source>
          <target state="translated">Después de cada recolección, el recolector de elementos no utilizados compacta los objetos que puede alcanzar en la generación 0 y los promueve a la generación 1.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Objects in generation 1 that survive collections are promoted to generation 2.</source>
          <target state="translated">Los objetos de la generación 1 que sobreviven a las recolecciones se promueven a la generación 2.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Because the garbage collector supports only three generations, objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</source>
          <target state="translated">Como el recolector de elementos no utilizados solo admite tres generaciones, los objetos de la generación 2 que sobreviven a una recolección se mantienen en esta generación hasta que en una recolección posterior se determina que no se pueden alcanzar.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Releasing Memory for Unmanaged Resources</source>
          <target state="translated">Liberar memoria para recursos no administrados</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For the majority of the objects that your application creates, you can rely on the garbage collector to automatically perform the necessary memory management tasks.</source>
          <target state="translated">En el caso de la mayoría de los objetos creados por la aplicación, puede utilizar el recolector de elementos no utilizados para realizar automáticamente las tareas de administración de memoria.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>However, unmanaged resources require explicit cleanup.</source>
          <target state="translated">Sin embargo, los recursos no administrados requieren una limpieza explícita.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</source>
          <target state="translated">El tipo más habitual de recurso no administrado es un objeto que contiene un recurso del sistema operativo, como un identificador de archivo, identificador de ventana o conexión de red.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it does not have specific knowledge about how to clean up the resource.</source>
          <target state="translated">Aunque el recolector de elementos no utilizados puede realizar el seguimiento del período de duración de un objeto administrado que encapsula un recurso no administrado, no tiene un conocimiento específico de cómo limpiar el recurso.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>When you create an object that encapsulates an unmanaged resource, it is recommended that you provide the necessary code to clean up the unmanaged resource in a public <ph id="ph1">`Dispose`</ph> method.</source>
          <target state="translated">Cuando se crea un objeto que encapsula un recurso no administrado, es recomendable proporcionar el código necesario para limpiar dicho recurso en un método público <ph id="ph1">`Dispose`</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>By providing a <ph id="ph1">`Dispose`</ph> method, you enable users of your object to explicitly free its memory when they are finished with the object.</source>
          <target state="translated">Si se proporciona un método <ph id="ph1">`Dispose`</ph>, se permite que los usuarios del objeto liberen su memoria de manera explícita cuando hayan terminado de usarlo.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>When you use an object that encapsulates an unmanaged resource, you should be aware of <ph id="ph1">`Dispose`</ph> and call it as necessary.</source>
          <target state="translated">Si se usa un objeto que encapsula un recurso no administrado, se debe conocer la existencia de <ph id="ph1">`Dispose`</ph> y llamarlo cuando sea necesario.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For more information about cleaning up unmanaged resources and an example of a design pattern for implementing <ph id="ph1">`Dispose`</ph>, see <bpt id="p1">[</bpt>Garbage Collection in .NET<ept id="p1">](index.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre la limpieza de recursos no administrados y el ejemplo de un modelo de diseño para implementar <ph id="ph1">`Dispose`</ph>, consulte <bpt id="p1">[</bpt>Recolección de elementos no utilizados en .NET<ept id="p1">](index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vea también</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.GC<ept id="p1">](xref:System.GC)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.GC<ept id="p1">](xref:System.GC)</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Garbage collection in .NET<ept id="p1">](index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recolección de elementos no utilizados en .NET<ept id="p1">](index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>