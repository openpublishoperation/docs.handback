<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e0173877fa4a57da76fd774d70ce63d2beda23ad</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\language-reference\statements\for-each-next-statement.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">920e8ab760e0c35e9cebdee25d71d97faf03fa31</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a514e215bd4dd062ffed073774d33b147900c2be</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_for-each-next-statement.4cf62aa52e7b6112860031792138abf52715bfdb.es-es is different with handoff file name: for-each-next-statement.4cf62aa52e7b6112860031792138abf52715bfdb.es-es.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>For Each...Next Statement (Visual Basic) | Microsoft Docs</source>
          <target state="translated">For Each... Next Statement (Visual Basic) | Documentos de Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>For Each...Next Statement (Visual Basic)</source>
          <target state="translated">Instrucción For Each...Next (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Repeats a group of statements for each element in a collection.</source>
          <target state="translated">Repite un grupo de instrucciones para cada elemento de una colección.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Sintaxis</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Parts</source>
          <target state="translated">Elementos</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Term</source>
          <target state="translated">Término</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Definition</source>
          <target state="translated">Definición</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Required in the <ph id="ph1">`For Each`</ph> statement.</source>
          <target state="translated">Necesario en el <ph id="ph1">`For Each`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Optional in the <ph id="ph1">`Next`</ph> statement.</source>
          <target state="translated">Opcional en el <ph id="ph1">`Next`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Variable.</source>
          <target state="translated">Variable.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Used to iterate through the elements of the collection.</source>
          <target state="translated">Se utiliza para recorrer en iteración los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Required if <ph id="ph1">`element`</ph> isn't already declared.</source>
          <target state="translated">Requerido si <ph id="ph1">`element`</ph> ya no está declarado.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Data type of <ph id="ph1">`element`</ph>.</source>
          <target state="translated">Tipo de datos de <ph id="ph1">`element`</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>A variable with a type that's a collection type or Object.</source>
          <target state="translated">Una variable con un tipo que es un objeto o colección.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Refers to the collection over which the <ph id="ph1">`statements`</ph> are to be repeated.</source>
          <target state="translated">Hace referencia a la colección en la que el <ph id="ph1">`statements`</ph> deben repetirse.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>One or more statements between <ph id="ph1">`For Each`</ph> and <ph id="ph2">`Next`</ph> that run on each item in <ph id="ph3">`group`</ph>.</source>
          <target state="translated">Una o más instrucciones entre <ph id="ph1">`For Each`</ph> y <ph id="ph2">`Next`</ph> que se ejecutan en cada elemento de <ph id="ph3">`group`</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Transfers control to the start of the <ph id="ph1">`For Each`</ph> loop.</source>
          <target state="translated">Transfiere el control al principio de la <ph id="ph1">`For Each`</ph> bucle.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Transfers control out of the <ph id="ph1">`For Each`</ph> loop.</source>
          <target state="translated">Transfiere el control fuera de la <ph id="ph1">`For Each`</ph> bucle.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Terminates the definition of the <ph id="ph1">`For Each`</ph> loop.</source>
          <target state="translated">Termina la definición de la <ph id="ph1">`For Each`</ph> bucle.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">Ejemplo sencillo</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Use a <ph id="ph1">`For Each`</ph>...<ph id="ph2">`Next`</ph> loop when you want to repeat a set of statements for each element of a collection or array.</source>
          <target state="translated">Use a <ph id="ph1">`For Each`</ph>... <ph id="ph2">`Next`</ph> un bucle cuando desea repetir un conjunto de instrucciones para cada elemento de una colección o matriz.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>For...Next Statement<ept id="p1">](../../../visual-basic/language-reference/statements/for-next-statement.md)</ept> works well when you can associate each iteration of a loop with a control variable and determine that variable's initial and final values.</source>
          <target state="translated">A <bpt id="p1">[</bpt>For... Next (instrucción)<ept id="p1">](../../../visual-basic/language-reference/statements/for-next-statement.md)</ept> funciona bien cuando puede asociar cada iteración de un bucle con una variable de control y determinar los valores inicial y final de la variable.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>However, when you are dealing with a collection, the concept of initial and final values isn't meaningful, and you don't necessarily know how many elements the collection has.</source>
          <target state="translated">Sin embargo, cuando se trata de una colección, el concepto de valores iniciales y finales no es significativo y no necesariamente sabe cuántos elementos tiene la colección.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In this kind of case, a <ph id="ph1">`For Each`</ph>...<ph id="ph2">`Next`</ph> loop is often a better choice.</source>
          <target state="translated">En este tipo de caso, un <ph id="ph1">`For Each`</ph>... <ph id="ph2">`Next`</ph> bucle suele ser una mejor opción.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>In the following example, the <ph id="ph1">`For Each`</ph>…<ph id="ph2">`Next`</ph></source>
          <target state="translated">En el ejemplo siguiente, la <ph id="ph1">`For Each`</ph>...<ph id="ph2">`Next`</ph></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>statement iterates through all the elements of a List collection.</source>
          <target state="translated">instrucción recorre en iteración todos los elementos de una colección de lista.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements#121<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements&amp;#121;<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For more examples, see <bpt id="p1">[</bpt>Collections<ept id="p1">](http://msdn.microsoft.com/library/e76533a9-5033-4a0b-b003-9c2be60d185b)</ept> and <bpt id="p2">[</bpt>Arrays<ept id="p2">](../../../visual-basic/programming-guide/language-features/arrays/index.md)</ept>.</source>
          <target state="translated">Para obtener más ejemplos, vea <bpt id="p1">[</bpt>colecciones<ept id="p1">](http://msdn.microsoft.com/library/e76533a9-5033-4a0b-b003-9c2be60d185b)</ept> y <bpt id="p2">[</bpt>matrices<ept id="p2">](../../../visual-basic/programming-guide/language-features/arrays/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Nested Loops</source>
          <target state="translated">Bucles anidados</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You can nest <ph id="ph1">`For Each`</ph> loops by putting one loop within another.</source>
          <target state="translated">Puede anidar <ph id="ph1">`For Each`</ph> bucles colocando un bucle dentro de otro.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The following example demonstrates nested <ph id="ph1">`For Each`</ph>…<ph id="ph2">`Next`</ph></source>
          <target state="translated">En el ejemplo siguiente se muestra anidada <ph id="ph1">`For Each`</ph>...<ph id="ph2">`Next`</ph></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>structures.</source>
          <target state="translated">estructuras.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements#122<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements&amp;#122;<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>When you nest loops, each loop must have a unique <ph id="ph1">`element`</ph> variable.</source>
          <target state="translated">Al anidar bucles, cada bucle debe tener un único <ph id="ph1">`element`</ph> variable.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You can also nest different kinds of control structures within each other.</source>
          <target state="translated">También puede anidar diferentes tipos de estructuras de control entre sí.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Nested Control Structures<ept id="p1">](../../../visual-basic/programming-guide/language-features/control-flow/nested-control-structures.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>estructuras de Control anidadas<ept id="p1">](../../../visual-basic/programming-guide/language-features/control-flow/nested-control-structures.md)</ept>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Exit For and Continue For</source>
          <target state="translated">Exit For y continuar para</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Exit For<ept id="p1">](../../../visual-basic/language-reference/statements/exit-statement.md)</ept> statement causes execution to exit the <ph id="ph1">`For`</ph>…<ph id="ph2">`Next`</ph></source>
          <target state="translated">El <bpt id="p1">[</bpt>Exit For<ept id="p1">](../../../visual-basic/language-reference/statements/exit-statement.md)</ept> instrucción hace que la ejecución salir de la <ph id="ph1">`For`</ph>...<ph id="ph2">`Next`</ph></target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>loop and transfers control to the statement that follows the <ph id="ph1">`Next`</ph> statement.</source>
          <target state="translated">bucle y transfiere el control a la instrucción que sigue a la <ph id="ph1">`Next`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Continue For`</ph> statement transfers control immediately to the next iteration of the loop.</source>
          <target state="translated">El <ph id="ph1">`Continue For`</ph> instrucción transfiere el control inmediatamente a la siguiente iteración del bucle.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Continue Statement<ept id="p1">](../../../visual-basic/language-reference/statements/continue-statement.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>instrucción Continue<ept id="p1">](../../../visual-basic/language-reference/statements/continue-statement.md)</ept>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following example shows how to use the <ph id="ph1">`Continue For`</ph> and <ph id="ph2">`Exit For`</ph> statements.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">`Continue For`</ph> y <ph id="ph2">`Exit For`</ph> instrucciones.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements#123<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements&amp;#123;<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>You can put any number of <ph id="ph1">`Exit For`</ph> statements in a <ph id="ph2">`For Each`</ph> loop.</source>
          <target state="translated">Puede colocar cualquier número de <ph id="ph1">`Exit For`</ph> las instrucciones en un <ph id="ph2">`For Each`</ph> bucle.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>When used within nested <ph id="ph1">`For Each`</ph> loops, <ph id="ph2">`Exit For`</ph> causes execution to exit the innermost loop and transfers control to the next higher level of nesting.</source>
          <target state="translated">Cuando se utiliza dentro anidados <ph id="ph1">`For Each`</ph> bucles, <ph id="ph2">`Exit For`</ph> hace que la ejecución salir del bucle y transfiere el control más interno al siguiente nivel más alto de anidamiento.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Exit For`</ph> is often used after an evaluation of some condition, for example, in an <ph id="ph2">`If`</ph>...<ph id="ph3">`Then`</ph>...<ph id="ph4">`Else`</ph> structure.</source>
          <target state="translated"><ph id="ph1">`Exit For`</ph>a menudo se usa después de una evaluación de alguna condición, por ejemplo, en un <ph id="ph2">`If`</ph>... <ph id="ph3">`Then`</ph>... <ph id="ph4">`Else`</ph> (estructura).</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You might want to use <ph id="ph1">`Exit For`</ph> for the following conditions:</source>
          <target state="translated">Desea usar <ph id="ph1">`Exit For`</ph> para las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Continuing to iterate is unnecessary or impossible.</source>
          <target state="translated">Continuar recorrer en iteración es innecesario o imposible.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This might be caused by an erroneous value or a termination request.</source>
          <target state="translated">Esto podría deberse a un valor erróneo o una solicitud de finalización.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>An exception is caught in a <ph id="ph1">`Try`</ph>...<ph id="ph2">`Catch`</ph>...<ph id="ph3">`Finally`</ph>.</source>
          <target state="translated">Se detecta una excepción en un <ph id="ph1">`Try`</ph>... <ph id="ph2">`Catch`</ph>... <ph id="ph3">`Finally`</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You might use <ph id="ph1">`Exit For`</ph> at the end of the <ph id="ph2">`Finally`</ph> block.</source>
          <target state="translated">Puede usar <ph id="ph1">`Exit For`</ph> al final de la <ph id="ph2">`Finally`</ph> bloque.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>There an endless loop, which is a loop that could run a large or even infinite number of times.</source>
          <target state="translated">Hay un bucle interminable, que es un bucle que se puede ejecutar un número grande o incluso infinito de veces.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>If you detect such a condition, you can use <ph id="ph1">`Exit For`</ph> to escape the loop.</source>
          <target state="translated">Si detecta una condición de ese tipo, puede usar <ph id="ph1">`Exit For`</ph> para salir del bucle.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Do...Loop Statement<ept id="p1">](../../../visual-basic/language-reference/statements/do-loop-statement.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>hacer... Instrucción de bucle<ept id="p1">](../../../visual-basic/language-reference/statements/do-loop-statement.md)</ept>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iteradores</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You use an <bpt id="p1">*</bpt>iterator<ept id="p1">*</ept> to perform a custom iteration over a collection.</source>
          <target state="translated">Utiliza un <bpt id="p1">*</bpt>iterador<ept id="p1">*</ept> para realizar una iteración personalizada sobre una colección.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>An iterator can be a function or a <ph id="ph1">`Get`</ph> accessor.</source>
          <target state="translated">Un iterador puede ser una función o un <ph id="ph1">`Get`</ph> descriptor de acceso.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>It uses a <ph id="ph1">`Yield`</ph> statement to return each element of the collection one at a time.</source>
          <target state="translated">Utiliza un <ph id="ph1">`Yield`</ph> instrucción para devolver cada elemento de la colección a la vez.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>You call an iterator by using a <ph id="ph1">`For Each...Next`</ph> statement.</source>
          <target state="translated">Puede llamar a un iterador con un <ph id="ph1">`For Each...Next`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Each iteration of the <ph id="ph1">`For Each`</ph> loop calls the iterator.</source>
          <target state="translated">Cada iteración de la <ph id="ph1">`For Each`</ph> bucle llama el iterador.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>When a <ph id="ph1">`Yield`</ph> statement is reached in the iterator, the expression in the <ph id="ph2">`Yield`</ph> statement is returned, and the current location in code is retained.</source>
          <target state="translated">Cuando un <ph id="ph1">`Yield`</ph> se alcanza la instrucción en el iterador, la expresión en el <ph id="ph2">`Yield`</ph> instrucción se devuelve y se conserva la ubicación actual en el código.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Execution is restarted from that location the next time that the iterator is called.</source>
          <target state="translated">La ejecución se reinicia desde esa ubicación la próxima vez que se llama al iterador.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The following example uses an iterator function.</source>
          <target state="translated">En el ejemplo siguiente se utiliza una función de iterador.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The iterator function has a <ph id="ph1">`Yield`</ph> statement that's inside a <bpt id="p1">[</bpt>For…Next<ept id="p1">](../../../visual-basic/language-reference/statements/for-next-statement.md)</ept> loop.</source>
          <target state="translated">La función de iterador tiene un <ph id="ph1">`Yield`</ph> instrucción que se encuentra dentro de un <bpt id="p1">[</bpt>para... Siguiente<ept id="p1">](../../../visual-basic/language-reference/statements/for-next-statement.md)</ept> bucle.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`ListEvenNumbers`</ph> method, each iteration of the <ph id="ph2">`For Each`</ph> statement body creates a call to the iterator function, which proceeds to the next <ph id="ph3">`Yield`</ph> statement.</source>
          <target state="translated">En el <ph id="ph1">`ListEvenNumbers`</ph> método, cada iteración de la <ph id="ph2">`For Each`</ph> cuerpo de instrucción crea una llamada a la función del iterador, que se dirige a la siguiente <ph id="ph3">`Yield`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements#127<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>127 VbVbalrStatements<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Iterators<ept id="p1">](http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7)</ept>, <bpt id="p2">[</bpt>Yield Statement<ept id="p2">](../../../visual-basic/language-reference/statements/yield-statement.md)</ept>, and <bpt id="p3">[</bpt>Iterator<ept id="p3">](../../../visual-basic/language-reference/modifiers/iterator.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>iteradores<ept id="p1">](http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7)</ept>, <bpt id="p2">[</bpt>instrucción Yield<ept id="p2">](../../../visual-basic/language-reference/statements/yield-statement.md)</ept>, y <bpt id="p3">[</bpt>iterador<ept id="p3">](../../../visual-basic/language-reference/modifiers/iterator.md)</ept>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Technical Implementation</source>
          <target state="translated">Implementación técnica</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>When a <ph id="ph1">`For Each`</ph>…<ph id="ph2">`Next`</ph></source>
          <target state="translated">Cuando un <ph id="ph1">`For Each`</ph>...<ph id="ph2">`Next`</ph></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>statement runs, Visual Basic evaluates the collection only one time, before the loop starts.</source>
          <target state="translated">ejecuciones de instrucción, Visual Basic evalúa la colección sólo una vez, antes de que comience el bucle.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If your statement block changes <ph id="ph1">`element`</ph> or <ph id="ph2">`group`</ph>, these changes don't affect the iteration of the loop.</source>
          <target state="translated">Si cambia el bloque de instrucciones <ph id="ph1">`element`</ph> o <ph id="ph2">`group`</ph>, estos cambios no afectan a la iteración del bucle.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>When all the elements in the collection have been successively assigned to <ph id="ph1">`element`</ph>, the <ph id="ph2">`For Each`</ph> loop stops and control passes to the statement following the <ph id="ph3">`Next`</ph> statement.</source>
          <target state="translated">Cuando todos los elementos de la colección se han asignado correctamente a <ph id="ph1">`element`</ph>, <ph id="ph2">`For Each`</ph> se detiene un bucle y el control pasa a la siguiente instrucción el <ph id="ph3">`Next`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`element`</ph> hasn't been declared outside this loop, you must declare it in the <ph id="ph2">`For Each`</ph> statement.</source>
          <target state="translated">Si <ph id="ph1">`element`</ph> todavía no se ha declarado fuera de este bucle, se debe declarar en el <ph id="ph2">`For Each`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>You can declare the type of <ph id="ph1">`element`</ph> explicitly by using an <ph id="ph2">`As`</ph> statement, or you can rely on type inference to assign the type.</source>
          <target state="translated">Puede declarar el tipo de <ph id="ph1">`element`</ph> explícitamente mediante una <ph id="ph2">`As`</ph> , o bien puede confiar en la inferencia de tipos para asignar el tipo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>In either case, the scope of <ph id="ph1">`element`</ph> is the body of the loop.</source>
          <target state="translated">En cualquier caso, el ámbito de <ph id="ph1">`element`</ph> es el cuerpo del bucle.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>However, you cannot declare <ph id="ph1">`element`</ph> both outside and inside the loop.</source>
          <target state="translated">Sin embargo, no puede declarar <ph id="ph1">`element`</ph> fuera y dentro del bucle.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>You can optionally specify <ph id="ph1">`element`</ph> in the <ph id="ph2">`Next`</ph> statement.</source>
          <target state="translated">Opcionalmente, puede especificar <ph id="ph1">`element`</ph> en el <ph id="ph2">`Next`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This improves the readability of your program, especially if you have nested <ph id="ph1">`For Each`</ph> loops.</source>
          <target state="translated">Esto mejora la legibilidad del programa, especialmente si tiene anidados <ph id="ph1">`For Each`</ph> bucles.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>You must specify the same variable as the one that appears in the corresponding <ph id="ph1">`For Each`</ph> statement.</source>
          <target state="translated">Debe especificar la misma variable como el que aparece en la correspondiente <ph id="ph1">`For Each`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>You might want to avoid changing the value of <ph id="ph1">`element`</ph> inside a loop.</source>
          <target state="translated">Desea evitar cambiar el valor de <ph id="ph1">`element`</ph> dentro de un bucle.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Doing this can make it more difficult to read and debug your code.</source>
          <target state="translated">Esto puede hacer más difícil de leer y depurar el código.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Changing the value of <ph id="ph1">`group`</ph> doesn't affect the collection or its elements, which were determined when the loop was first entered.</source>
          <target state="translated">Cambiar el valor de <ph id="ph1">`group`</ph> no afecta a la colección o sus elementos, que se determinan al entra en el bucle.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>When you're nesting loops, if a <ph id="ph1">`Next`</ph> statement of an outer nesting level is encountered before the <ph id="ph2">`Next`</ph> of an inner level, the compiler signals an error.</source>
          <target state="translated">Cuando está anidar bucles, si un <ph id="ph1">`Next`</ph> instrucción de un nivel de anidamiento externo se encuentra antes de la <ph id="ph2">`Next`</ph> de un nivel interno, el compilador señala un error.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>However, the compiler can detect this overlapping error only if you specify <ph id="ph1">`element`</ph> in every <ph id="ph2">`Next`</ph> statement.</source>
          <target state="translated">Sin embargo, el compilador puede detectar este error se superponen sólo si se especifica <ph id="ph1">`element`</ph> en cada <ph id="ph2">`Next`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If your code depends on traversing a collection in a particular order, a <ph id="ph1">`For Each`</ph>...<ph id="ph2">`Next`</ph> loop isn't the best choice, unless you know the characteristics of the enumerator object the collection exposes.</source>
          <target state="translated">Si el código depende del recorrido de una colección en un orden concreto, un <ph id="ph1">`For Each`</ph>... <ph id="ph2">`Next`</ph> bucle no es la mejor elección, a menos que conozca las características del objeto enumerador que expone la colección.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The order of traversal isn't determined by Visual Basic, but by the &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; method of the enumerator object.</source>
          <target state="translated">El orden de recorrido no está determinado por Visual Basic, sino por el &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;método del objeto enumerador.&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Therefore, you might not be able to predict which element of the collection is the first to be returned in <ph id="ph1">`element`</ph>, or which is the next to be returned after a given element.</source>
          <target state="translated">Por lo tanto, no puede predecir qué elemento de la colección es el primero que se devuelve en <ph id="ph1">`element`</ph>, o que es el siguiente en ser devuelto tras un elemento dado.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>You might achieve more reliable results using a different loop structure, such as <ph id="ph1">`For`</ph>...<ph id="ph2">`Next`</ph> or <ph id="ph3">`Do`</ph>...<ph id="ph4">`Loop`</ph>.</source>
          <target state="translated">Puede conseguir resultados más confiables con una estructura de bucle diferente, como <ph id="ph1">`For`</ph>... <ph id="ph2">`Next`</ph> or <ph id="ph3">`Do`</ph>... <ph id="ph4">`Loop`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The data type of <ph id="ph1">`element`</ph> must be such that the data type of the elements of <ph id="ph2">`group`</ph> can be converted to it.</source>
          <target state="translated">Tipo de datos de <ph id="ph1">`element`</ph> deberá ser tal que el tipo de datos de los elementos de <ph id="ph2">`group`</ph> puede convertir en él.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The data type of <ph id="ph1">`group`</ph> must be a reference type that refers to a collection or an array that's enumerable.</source>
          <target state="translated">Tipo de datos de <ph id="ph1">`group`</ph> debe ser un tipo de referencia que hace referencia a una colección o una matriz que es enumerable.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Most commonly this means that <ph id="ph1">`group`</ph> refers to an object that implements the &lt;xref:System.Collections.IEnumerable&gt; interface of the <ph id="ph2">`System.Collections`</ph> namespace or the &lt;xref:System.Collections.Generic.IEnumerable%601&gt; interface of the <ph id="ph3">`System.Collections.Generic`</ph> namespace.</source>
          <target state="translated">Normalmente, esto significa que <ph id="ph1">`group`</ph> hace referencia a un objeto que implementa el &lt;xref:System.Collections.IEnumerable&gt;interfaz de la <ph id="ph2">`System.Collections`</ph> espacio de nombres o la &lt;xref:System.Collections.Generic.IEnumerable%601&gt;interfaz de la <ph id="ph3">`System.Collections.Generic`</ph> espacio de nombres.&lt;/xref:System.Collections.Generic.IEnumerable%601&gt; &lt;/xref:System.Collections.IEnumerable&gt;</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`System.Collections.IEnumerable`</ph> defines the &lt;xref:System.Collections.IEnumerable.GetEnumerator%2A&gt; method, which returns an enumerator object for the collection.</source>
          <target state="translated"><ph id="ph1">`System.Collections.IEnumerable`</ph>define la &lt;xref:System.Collections.IEnumerable.GetEnumerator%2A&gt;método, que devuelve un objeto enumerador para la colección.&lt;/xref:System.Collections.IEnumerable.GetEnumerator%2A&gt;</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The enumerator object implements the <ph id="ph1">`System.Collections.IEnumerator`</ph> interface of the <ph id="ph2">`System.Collections`</ph> namespace and exposes the &lt;xref:System.Collections.IEnumerator.Current%2A&gt; property and the &lt;xref:System.Collections.IEnumerator.Reset%2A&gt; and &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; methods.</source>
          <target state="translated">El objeto enumerador implementa la <ph id="ph1">`System.Collections.IEnumerator`</ph> interfaz de la <ph id="ph2">`System.Collections`</ph> espacio de nombres y expone el &lt;xref:System.Collections.IEnumerator.Current%2A&gt;propiedad y &lt;xref:System.Collections.IEnumerator.Reset%2A&gt;y &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;métodos.&lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt; &lt;/xref:System.Collections.IEnumerator.Reset%2A&gt; &lt;/xref:System.Collections.IEnumerator.Current%2A&gt;</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Visual Basic uses these to traverse the collection.</source>
          <target state="translated">Visual Basic utiliza éstos para recorrer la colección.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Narrowing Conversions</source>
          <target state="translated">Conversiones de restricción</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">`Option Strict`</ph> is set to <ph id="ph2">`On`</ph>, narrowing conversions ordinarily cause compiler errors.</source>
          <target state="translated">Cuando <ph id="ph1">`Option Strict`</ph> se establece en <ph id="ph2">`On`</ph>, las conversiones de restricción suelen provocan errores del compilador.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>In a <ph id="ph1">`For Each`</ph> statement, however, conversions from the elements in <ph id="ph2">`group`</ph> to <ph id="ph3">`element`</ph> are evaluated and performed at run time, and compiler errors caused by narrowing conversions are suppressed.</source>
          <target state="translated">En un <ph id="ph1">`For Each`</ph> instrucción, sin embargo, las conversiones de los elementos de <ph id="ph2">`group`</ph> a <ph id="ph3">`element`</ph> se evalúan y se realiza en tiempo de ejecución y se suprimen los errores de compilador causados por las conversiones de restricción.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In the following example, the assignment of <ph id="ph1">`m`</ph> as the initial value for <ph id="ph2">`n`</ph> doesn't compile when <ph id="ph3">`Option Strict`</ph> is on because the conversion of a <ph id="ph4">`Long`</ph> to an <ph id="ph5">`Integer`</ph> is a narrowing conversion.</source>
          <target state="translated">En el ejemplo siguiente, la asignación de <ph id="ph1">`m`</ph> como valor inicial para <ph id="ph2">`n`</ph> no se compila cuando <ph id="ph3">`Option Strict`</ph> porque se encuentra en la conversión de un <ph id="ph4">`Long`</ph> a una <ph id="ph5">`Integer`</ph> es una conversión de restricción.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`For Each`</ph> statement, however, no compiler error is reported, even though the assignment to <ph id="ph2">`number`</ph> requires the same conversion from <ph id="ph3">`Long`</ph> to <ph id="ph4">`Integer`</ph>.</source>
          <target state="translated">En el <ph id="ph1">`For Each`</ph> instrucción, sin embargo, ningún error del compilador es notificado, aunque la asignación a <ph id="ph2">`number`</ph> requiere la misma conversión de <ph id="ph3">`Long`</ph> a <ph id="ph4">`Integer`</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`For Each`</ph> statement that contains a large number, a run-time error occurs when &lt;xref:Microsoft.VisualBasic.CompilerServices.Conversions.ToInteger%2A&gt; is applied to the large number.</source>
          <target state="translated">En el <ph id="ph1">`For Each`</ph> se produce un error en tiempo de ejecución de instrucción que contiene un número elevado, cuando &lt;xref:Microsoft.VisualBasic.CompilerServices.Conversions.ToInteger%2A&gt;se aplica a la gran cantidad.&lt;/xref:Microsoft.VisualBasic.CompilerServices.Conversions.ToInteger%2A&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements#89<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_5.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements&amp;#89;<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_5.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>IEnumerator Calls</source>
          <target state="translated">Llamadas de IEnumerator</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>When execution of a <ph id="ph1">`For Each`</ph>...<ph id="ph2">`Next`</ph> loop starts, Visual Basic verifies that <ph id="ph3">`group`</ph> refers to a valid collection object.</source>
          <target state="translated">Cuando la ejecución de un <ph id="ph1">`For Each`</ph>... <ph id="ph2">`Next`</ph> inicia el bucle, Visual Basic comprueba que <ph id="ph3">`group`</ph> hace referencia a un objeto válido de la colección.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If not, it throws an exception.</source>
          <target state="translated">De lo contrario, produce una excepción.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Otherwise, it calls the &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt; method and the &lt;xref:System.Collections.IEnumerator.Current%2A&gt; property of the enumerator object to return the first element.</source>
          <target state="translated">De lo contrario, llama a la &lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;(método) y el &lt;xref:System.Collections.IEnumerator.Current%2A&gt;propiedad del objeto enumerador para devolver el primer elemento.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt; &lt;/xref:System.Collections.IEnumerator.MoveNext%2A&gt;</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`MoveNext`</ph> indicates that there is no next element, that is, if the collection is empty, the <ph id="ph2">`For Each`</ph> loop stops and control passes to the statement following the <ph id="ph3">`Next`</ph> statement.</source>
          <target state="translated">Si <ph id="ph1">`MoveNext`</ph> indica que no hay ningún elemento siguiente, es decir, si la colección está vacía, el <ph id="ph2">`For Each`</ph> se detiene un bucle y el control pasa a la siguiente instrucción el <ph id="ph3">`Next`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Otherwise, Visual Basic sets <ph id="ph1">`element`</ph> to the first element and runs the statement block.</source>
          <target state="translated">De lo contrario, Visual Basic establece <ph id="ph1">`element`</ph> para el primer elemento y se ejecuta el bloque de instrucciones.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Each time Visual Basic encounters the <ph id="ph1">`Next`</ph> statement, it returns to the <ph id="ph2">`For Each`</ph> statement.</source>
          <target state="translated">Cada vez que Visual Basic encuentra la <ph id="ph1">`Next`</ph> instrucción, devuelve a la <ph id="ph2">`For Each`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Again it calls <ph id="ph1">`MoveNext`</ph> and <ph id="ph2">`Current`</ph> to return the next element, and again it either runs the block or stops the loop depending on the result.</source>
          <target state="translated">Llama de nuevo a <ph id="ph1">`MoveNext`</ph> y <ph id="ph2">`Current`</ph> para devolver el elemento siguiente y, a uno ejecuta el bloque o se detiene el bucle según el resultado.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This process continues until <ph id="ph1">`MoveNext`</ph> indicates that there is no next element or an <ph id="ph2">`Exit For`</ph> statement is encountered.</source>
          <target state="translated">Este proceso continúa hasta que <ph id="ph1">`MoveNext`</ph> indica que no hay ningún elemento siguiente o <ph id="ph2">`Exit For`</ph> se encuentra la instrucción.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Modifying the Collection.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Modificar la colección.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The enumerator object returned by &lt;xref:System.Collections.IEnumerable.GetEnumerator%2A&gt; normally doesn't let you change the collection by adding, deleting, replacing, or reordering any elements.</source>
          <target state="translated">El objeto enumerador devuelto por &lt;xref:System.Collections.IEnumerable.GetEnumerator%2A&gt;normalmente no permite cambiar la colección agregando, eliminando, reemplazando o reordenación de elementos.&lt;/xref:System.Collections.IEnumerable.GetEnumerator%2A&gt;</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>If you change the collection after you have initiated a <ph id="ph1">`For Each`</ph>...<ph id="ph2">`Next`</ph> loop, the enumerator object becomes invalid, and the next attempt to access an element causes an &lt;xref:System.InvalidOperationException&gt; exception.</source>
          <target state="translated">Si cambia la colección después de haber iniciado un <ph id="ph1">`For Each`</ph>... <ph id="ph2">`Next`</ph> bucles, el objeto enumerador deja de ser válido y el siguiente intento de acceso a un elemento hace un &lt;xref:System.InvalidOperationException&gt;excepción.&lt;/xref:System.InvalidOperationException&gt;</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>However, this blocking of modification isn't determined by <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph>, but rather by the implementation of the &lt;xref:System.Collections.IEnumerable&gt; interface.</source>
          <target state="translated">Sin embargo, este bloqueo de modificación no viene determinado por <ph id="ph1">[!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph>, sino por la implementación de la &lt;xref:System.Collections.IEnumerable&gt;interfaz.&lt;/xref:System.Collections.IEnumerable&gt;</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It is possible to implement <ph id="ph1">`IEnumerable`</ph> in a way that allows for modification during iteration.</source>
          <target state="translated">Es posible implementar <ph id="ph1">`IEnumerable`</ph> de forma que permite la modificación durante la iteración.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If you are considering doing such dynamic modification, make sure that you understand the characteristics of the <ph id="ph1">`IEnumerable`</ph> implementation on the collection you are using.</source>
          <target state="translated">Si piensa realizar dicha modificación dinámica, asegúrese de que comprende las características de la <ph id="ph1">`IEnumerable`</ph> implementación en la colección que está utilizando.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Modifying Collection Elements.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Modificar elementos de la colección.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.IEnumerator.Current%2A&gt; property of the enumerator object is <bpt id="p1">[</bpt>ReadOnly<ept id="p1">](../../../visual-basic/language-reference/modifiers/readonly.md)</ept>, and it returns a local copy of each collection element.</source>
          <target state="translated">El &lt;xref:System.Collections.IEnumerator.Current%2A&gt;es propiedad del objeto del enumerador <bpt id="p1">[</bpt>ReadOnly<ept id="p1">](../../../visual-basic/language-reference/modifiers/readonly.md)</ept>, y devuelve una copia local de cada elemento de la colección.&lt;/xref:System.Collections.IEnumerator.Current%2A&gt;</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>This means that you cannot modify the elements themselves in a <ph id="ph1">`For Each`</ph>...<ph id="ph2">`Next`</ph> loop.</source>
          <target state="translated">Esto significa que no pueden modificar los propios elementos en un <ph id="ph1">`For Each`</ph>... <ph id="ph2">`Next`</ph> loop.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Any modification you make affects only the local copy from <ph id="ph1">`Current`</ph> and isn't reflected back into the underlying collection.</source>
          <target state="translated">Cualquier modificación realizada afecta sólo a la copia local de <ph id="ph1">`Current`</ph> y no se reflejará en la colección subyacente.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>However, if an element is a reference type, you can modify the members of the instance to which it points.</source>
          <target state="translated">Sin embargo, si un elemento es un tipo de referencia, puede modificar los miembros de la instancia a la que señala.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The following example modifies the <ph id="ph1">`BackColor`</ph> member of each <ph id="ph2">`thisControl`</ph> element.</source>
          <target state="translated">En el ejemplo siguiente se modifica el <ph id="ph1">`BackColor`</ph> miembro de cada <ph id="ph2">`thisControl`</ph> elemento.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>You cannot, however, modify <ph id="ph1">`thisControl`</ph> itself.</source>
          <target state="translated">Sin embargo, no puede modificar <ph id="ph1">`thisControl`</ph> propio.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>1<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>1<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The previous example can modify the <ph id="ph1">`BackColor`</ph> member of each <ph id="ph2">`thisControl`</ph> element, although it cannot modify <ph id="ph3">`thisControl`</ph> itself.</source>
          <target state="translated">En el ejemplo anterior se puede modificar el <ph id="ph1">`BackColor`</ph> miembro de cada <ph id="ph2">`thisControl`</ph> elemento, aunque no puede modificar <ph id="ph3">`thisControl`</ph> propio.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Traversing Arrays.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Recorrer matrices.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Because the &lt;xref:System.Array&gt; class implements the &lt;xref:System.Collections.IEnumerable&gt; interface, all arrays expose the &lt;xref:System.Array.GetEnumerator%2A&gt; method.</source>
          <target state="translated">Porque el &lt;xref:System.Array&gt;la clase implementa la &lt;xref:System.Collections.IEnumerable&gt;interfaz, todas las matrices exponen el &lt;xref:System.Array.GetEnumerator%2A&gt;método.&lt;/xref:System.Array.GetEnumerator%2A&gt; &lt;/xref:System.Collections.IEnumerable&gt; &lt;/xref:System.Array&gt;</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>This means that you can iterate through an array with a <ph id="ph1">`For Each`</ph>...<ph id="ph2">`Next`</ph> loop.</source>
          <target state="translated">Esto significa que puede iterar a través de una matriz con un <ph id="ph1">`For Each`</ph>... <ph id="ph2">`Next`</ph> loop.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>However, you can only read the array elements.</source>
          <target state="translated">Sin embargo, sólo puede leer elementos de la matriz.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>You cannot change them.</source>
          <target state="translated">No se pueden cambiar.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Ejemplo</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The following example lists all the folders in the C:\ directory by using the &lt;xref:System.IO.DirectoryInfo&gt; class.</source>
          <target state="translated">En el ejemplo siguiente se enumeran todas las carpetas en el directorio C:\ mediante el uso de la &lt;xref:System.IO.DirectoryInfo&gt;clase.&lt;/xref:System.IO.DirectoryInfo&gt;</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements#124<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_6.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements&amp;#124;<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_6.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Ejemplo</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The following example illustrates a procedure for sorting a collection.</source>
          <target state="translated">En el ejemplo siguiente se muestra un procedimiento para ordenar una colección.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The example sorts instances of a <ph id="ph1">`Car`</ph> class that are stored in a &lt;xref:System.Collections.Generic.List%601&gt;.</source>
          <target state="translated">El ejemplo ordena las instancias de un <ph id="ph1">`Car`</ph> clase que se almacenan en un &lt;xref:System.Collections.Generic.List%601&gt;.&lt;/xref:System.Collections.Generic.List%601&gt;</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Car`</ph> class implements the &lt;xref:System.IComparable%601&gt; interface, which requires that the &lt;xref:System.IComparable%601.CompareTo%2A&gt; method be implemented.</source>
          <target state="translated">El <ph id="ph1">`Car`</ph> la clase implementa la &lt;xref:System.IComparable%601&gt;interfaz, que requiere que el &lt;xref:System.IComparable%601.CompareTo%2A&gt;método implementarse.&lt;/xref:System.IComparable%601.CompareTo%2A&gt; &lt;/xref:System.IComparable%601&gt;</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Each call to the &lt;xref:System.IComparable%601.CompareTo%2A&gt; method makes a single comparison that's used for sorting.</source>
          <target state="translated">Cada llamada a la &lt;xref:System.IComparable%601.CompareTo%2A&gt;este método realiza una comparación única que se utiliza para ordenar.&lt;/xref:System.IComparable%601.CompareTo%2A&gt;</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>User-written code in the <ph id="ph1">`CompareTo`</ph> method returns a value for each comparison of the current object with another object.</source>
          <target state="translated">Código escrito por el usuario en el <ph id="ph1">`CompareTo`</ph> método devuelve un valor de comparación del objeto actual con otro objeto.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The value returned is less than zero if the current object is less than the other object, greater than zero if the current object is greater than the other object, and zero if they are equal.</source>
          <target state="translated">El valor devuelto es menor que cero si el objeto actual es menor que el otro objeto, mayor que cero si el objeto actual es mayor que el otro objeto y cero si son iguales.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>This enables you to define in code the criteria for greater than, less than, and equal.</source>
          <target state="translated">Esto permite definir en el código los criterios de mayor que, menor que e igual.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`ListCars`</ph> method, the <ph id="ph2">`cars.Sort()`</ph> statement sorts the list.</source>
          <target state="translated">En el <ph id="ph1">`ListCars`</ph> (método), el <ph id="ph2">`cars.Sort()`</ph> instrucción ordena la lista.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This call to the &lt;xref:System.Collections.Generic.List%601.Sort%2A&gt; method of the &lt;xref:System.Collections.Generic.List%601&gt; causes the <ph id="ph1">`CompareTo`</ph> method to be called automatically for the <ph id="ph2">`Car`</ph> objects in the <ph id="ph3">`List`</ph>.</source>
          <target state="translated">Esta llamada a la &lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;método de la &lt;xref:System.Collections.Generic.List%601&gt;hace que el <ph id="ph1">`CompareTo`</ph> método al que llamar automáticamente para la <ph id="ph2">`Car`</ph> objetos en la <ph id="ph3">`List`</ph>.&lt;/xref:System.Collections.Generic.List%601&gt; &lt;/xref:System.Collections.Generic.List%601.Sort%2A&gt;</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements#125<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_7.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrStatements&amp;#125;<ept id="p2">](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/for-each-next-statement_7.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vea también</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Collections<ept id="p1">](http://msdn.microsoft.com/library/e76533a9-5033-4a0b-b003-9c2be60d185b)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Colecciones<ept id="p1">](http://msdn.microsoft.com/library/e76533a9-5033-4a0b-b003-9c2be60d185b)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>For...Next Statement<ept id="p1">](../../../visual-basic/language-reference/statements/for-next-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Para... Next (instrucción)<ept id="p1">](../../../visual-basic/language-reference/statements/for-next-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Loop Structures<ept id="p1">](../../../visual-basic/programming-guide/language-features/control-flow/loop-structures.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Estructuras de bucle<ept id="p1">](../../../visual-basic/programming-guide/language-features/control-flow/loop-structures.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>While...End While Statement<ept id="p1">](../../../visual-basic/language-reference/statements/while-end-while-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>While... End While (instrucción)<ept id="p1">](../../../visual-basic/language-reference/statements/while-end-while-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Do...Loop Statement<ept id="p1">](../../../visual-basic/language-reference/statements/do-loop-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>DO... Instrucción del bucle<ept id="p1">](../../../visual-basic/language-reference/statements/do-loop-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Widening and Narrowing Conversions<ept id="p1">](../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Conversiones de restricción y ampliación<ept id="p1">](../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Object Initializers: Named and Anonymous Types<ept id="p1">](../../../visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Inicializadores de objeto: Tipos con nombre y anónimos<ept id="p1">](../../../visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Collection Initializers<ept id="p1">](../../../visual-basic/programming-guide/language-features/collection-initializers/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Inicializadores de colección<ept id="p1">](../../../visual-basic/programming-guide/language-features/collection-initializers/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Arrays<ept id="p1">](../../../visual-basic/programming-guide/language-features/arrays/index.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Matrices<ept id="p1">](../../../visual-basic/programming-guide/language-features/arrays/index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>