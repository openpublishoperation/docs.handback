<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e50593e76afecfe8807c3cb5bac479245d2feaef</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\procedures\lambda-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">895acd633a8cda2558af76ac524637fade1ae4a5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">517194bfb46ad17da82f6dda81810b1bb170a967</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_lambda-expressions.516f232819026ed497132389f62b2de45bffff48.es-es is different with handoff file name: lambda-expressions.516f232819026ed497132389f62b2de45bffff48.es-es.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Lambda Expressions (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Expresiones lambda (Visual Basic) | Documentos de Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Lambda Expressions (Visual Basic)</source>
          <target state="translated">Lambda (expresiones) (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>lambda expression<ept id="p1">*</ept> is a function or subroutine without a name that can be used wherever a delegate is valid.</source>
          <target state="translated">Un <bpt id="p1">*</bpt>expresión lambda<ept id="p1">*</ept> es una función o subrutina sin nombre que se puede utilizar donde haya un delegado válido.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be functions or subroutines and can be single-line or multi-line.</source>
          <target state="translated">Las expresiones lambda pueden ser funciones o subrutinas y pueden ser una línea o varias líneas.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can pass values from the current scope to a lambda expression.</source>
          <target state="translated">Puede pasar valores del ámbito actual a una expresión lambda.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`RemoveHandler`</ph> statement is an exception.</source>
          <target state="translated">El <ph id="ph1">`RemoveHandler`</ph> instrucción es una excepción.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You cannot pass a lambda expression in for the delegate parameter of <ph id="ph1">`RemoveHandler`</ph>.</source>
          <target state="translated">No se puede pasar una expresión lambda para el parámetro de delegado de <ph id="ph1">`RemoveHandler`</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You create lambda expressions by using the <ph id="ph1">`Function`</ph> or <ph id="ph2">`Sub`</ph> keyword, just as you create a standard function or subroutine.</source>
          <target state="translated">Crear expresiones lambda con la <ph id="ph1">`Function`</ph> o <ph id="ph2">`Sub`</ph> (palabra clave), como crear una subrutina o función estándar.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>However, lambda expressions are included in a statement.</source>
          <target state="translated">Sin embargo, las expresiones lambda se incluyen en una instrucción.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following example is a lambda expression that increments its argument and returns the value.</source>
          <target state="translated">El ejemplo siguiente es una expresión lambda que incrementa su argumento y devuelve el valor.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The example shows both the single-line and multi-line lambda expression syntax for a function.</source>
          <target state="translated">El ejemplo muestra la sintaxis de expresiones lambda de línea y de varias líneas para una función.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#14<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#14;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The following example is a lambda expression that writes a value to the console.</source>
          <target state="translated">El ejemplo siguiente es una expresión lambda que escribe un valor en la consola.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The example shows both the single-line and multi-line lambda expression syntax for a subroutine.</source>
          <target state="translated">El ejemplo muestra la sintaxis de expresiones lambda de línea y de varias líneas para una subrutina.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#15<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#15;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Notice that in the previous examples the lambda expressions are assigned to a variable name.</source>
          <target state="translated">Observe que, en los ejemplos anteriores, las expresiones lambda se asignan a un nombre de variable.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Whenever you refer to the variable, you invoke the lambda expression.</source>
          <target state="translated">Cada vez que se hace referencia a la variable, se invoca la expresión lambda.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can also declare and invoke a lambda expression at the same time, as shown in the following example.</source>
          <target state="translated">También puede declarar e invocar una expresión lambda al mismo tiempo, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#3<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;3;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A lambda expression can be returned as the value of a function call (as is shown in the example in the <bpt id="p1">[</bpt>Context<ept id="p1">](#context)</ept> section later in this topic), or passed in as an argument to a parameter that takes a delegate type, as shown in the following example.</source>
          <target state="translated">Una expresión lambda se puede devolver como el valor de una llamada de función (como se muestra en el ejemplo de la <bpt id="p1">[</bpt>contexto<ept id="p1">](#context)</ept> más adelante en este tema), o se pasa como un argumento a un parámetro que toma un tipo de delegado, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#8<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas Nº&amp;8;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Lambda Expression Syntax</source>
          <target state="translated">Sintaxis de la expresión lambda</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The syntax of a lambda expression resembles that of a standard function or subroutine.</source>
          <target state="translated">La sintaxis de una expresión lambda es similar al de una subrutina o función estándar.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The differences are as follows:</source>
          <target state="translated">Las diferencias son:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A lambda expression does not have a name.</source>
          <target state="translated">Una expresión lambda no tiene un nombre.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Lambda expressions cannot have modifiers, such as <ph id="ph1">`Overloads`</ph> or <ph id="ph2">`Overrides`</ph>.</source>
          <target state="translated">Las expresiones lambda no pueden tener modificadores, como <ph id="ph1">`Overloads`</ph> o <ph id="ph2">`Overrides`</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Single-line lambda functions do not use an <ph id="ph1">`As`</ph> clause to designate the return type.</source>
          <target state="translated">No utilizan las funciones lambda de línea un <ph id="ph1">`As`</ph> cláusula para designar el tipo de valor devuelto.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Instead, the type is inferred from the value that the body of the lambda expression evaluates to.</source>
          <target state="translated">En su lugar, el tipo se deduce del valor que se evalúa como el cuerpo de la expresión lambda.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For example, if the body of the lambda expression is <ph id="ph1">`cust.City = "London"`</ph>, its return type is <ph id="ph2">`Boolean`</ph>.</source>
          <target state="translated">Por ejemplo, si el cuerpo de la expresión lambda es <ph id="ph1">`cust.City = "London"`</ph>, su tipo de valor devuelto es <ph id="ph2">`Boolean`</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>In multi-line lambda functions, you can either specify a return type by using an <ph id="ph1">`As`</ph> clause, or omit the <ph id="ph2">`As`</ph> clause so that the return type is inferred.</source>
          <target state="translated">En las funciones lambda de varias líneas, puede especificar un tipo de valor devuelto mediante el uso de un <ph id="ph1">`As`</ph> cláusula, u omita el <ph id="ph2">`As`</ph> cláusula para que se deduce el tipo de valor devuelto.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`As`</ph> clause is omitted for a multi-line lambda function, the return type is inferred to be the dominant type from all the <ph id="ph2">`Return`</ph> statements in the multi-line lambda function.</source>
          <target state="translated">Cuando el <ph id="ph1">`As`</ph> se omite la cláusula de una función lambda de varias líneas, se deduce el tipo de valor devuelto es el tipo dominante de todas las <ph id="ph2">`Return`</ph> las instrucciones de la función lambda de varias líneas.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>dominant type<ept id="p1">*</ept> is a unique type that all other types can widen to.</source>
          <target state="translated">El <bpt id="p1">*</bpt>tipo dominante<ept id="p1">*</ept> es un tipo único que todos los demás tipos se pueden ampliar.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If this unique type cannot be determined, the dominant type is the unique type that all other types in the array can narrow to.</source>
          <target state="translated">Si no se puede determinar este tipo único, el tipo dominante es el único tipo que todos los demás tipos de la matriz se pueden restringir.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If neither of these unique types can be determined, the dominant type is <ph id="ph1">`Object`</ph>.</source>
          <target state="translated">Si no se puede determinar ninguno de estos tipos únicos, el tipo dominante es <ph id="ph1">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In this case, if <ph id="ph1">`Option Strict`</ph> is set to <ph id="ph2">`On`</ph>, a compiler error occurs.</source>
          <target state="translated">En este caso, si <ph id="ph1">`Option Strict`</ph> se establece en <ph id="ph2">`On`</ph>, se produce un error del compilador.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, if the expressions supplied to the <ph id="ph1">`Return`</ph> statement contain values of type <ph id="ph2">`Integer`</ph>, <ph id="ph3">`Long`</ph>, and <ph id="ph4">`Double`</ph>, the resulting array is of type <ph id="ph5">`Double`</ph>.</source>
          <target state="translated">Por ejemplo, si las expresiones proporcionado a la <ph id="ph1">`Return`</ph> instrucción contienen valores de tipo <ph id="ph2">`Integer`</ph>, <ph id="ph3">`Long`</ph>, y <ph id="ph4">`Double`</ph>, la matriz resultante es de tipo <ph id="ph5">`Double`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">`Integer`</ph> and <ph id="ph2">`Long`</ph> widen to <ph id="ph3">`Double`</ph> and only <ph id="ph4">`Double`</ph>.</source>
          <target state="translated">Ambos <ph id="ph1">`Integer`</ph> y <ph id="ph2">`Long`</ph> se amplían a <ph id="ph3">`Double`</ph> y sólo <ph id="ph4">`Double`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Therefore, <ph id="ph1">`Double`</ph> is the dominant type.</source>
          <target state="translated">Por lo tanto, <ph id="ph1">`Double`</ph> es el tipo dominante.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Widening and Narrowing Conversions<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>conversiones de ampliación y de restricción<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The body of a single-line function must be an expression that returns a value, not a statement.</source>
          <target state="translated">El cuerpo de una función de la línea debe ser una expresión que devuelve un valor, no una instrucción.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>There is no <ph id="ph1">`Return`</ph> statement for single-line functions.</source>
          <target state="translated">No hay ningún <ph id="ph1">`Return`</ph> instrucción para las funciones de la línea.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The value returned by the single-line function is the value of the expression in the body of the function.</source>
          <target state="translated">El valor devuelto por la función de la línea es el valor de la expresión en el cuerpo de la función.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The body of a single-line subroutine must be single-line statement.</source>
          <target state="translated">El cuerpo de una subrutina de línea debe ser una instrucción de línea.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Single-line functions and subroutines do not include an <ph id="ph1">`End Function`</ph> or <ph id="ph2">`End Sub`</ph> statement.</source>
          <target state="translated">Línea funciones y subrutinas no incluyen un <ph id="ph1">`End Function`</ph> o <ph id="ph2">`End Sub`</ph> instrucción.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can specify the data type of a lambda expression parameter by using the <ph id="ph1">`As`</ph> keyword, or the data type of the parameter can be inferred.</source>
          <target state="translated">Puede especificar el tipo de datos de un parámetro de expresión lambda utilizando la <ph id="ph1">`As`</ph> puede deducirse (palabra clave) o el tipo de datos del parámetro.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Either all parameters must have specified data types or all must be inferred.</source>
          <target state="translated">Deben haber especificado todos los parámetros deben deducir los tipos de datos o todos.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Optional`</ph> and <ph id="ph2">`Paramarray`</ph> parameters are not permitted.</source>
          <target state="translated"><ph id="ph1">`Optional`</ph>y <ph id="ph2">`Paramarray`</ph> no se permiten parámetros.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Generic parameters are not permitted.</source>
          <target state="translated">No se permiten parámetros genéricos.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Async Lambdas</source>
          <target state="translated">Lambdas asincrónicas</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can easily create lambda expressions and statements that incorporate asynchronous processing by using the <bpt id="p1">[</bpt>Async<ept id="p1">](../../../../visual-basic/language-reference/modifiers/async.md)</ept> and <bpt id="p2">[</bpt>Await Operator<ept id="p2">](../../../../visual-basic/language-reference/operators/await-operator.md)</ept> keywords.</source>
          <target state="translated">Puede crear fácilmente expresiones lambda e instrucciones que incorporen el procesamiento asincrónico mediante la <bpt id="p1">[</bpt>Async<ept id="p1">](../../../../visual-basic/language-reference/modifiers/async.md)</ept> y <bpt id="p2">[</bpt>operador Await<ept id="p2">](../../../../visual-basic/language-reference/operators/await-operator.md)</ept> palabras clave.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, the following Windows Forms example contains an event handler that calls and awaits an async method, <ph id="ph1">`ExampleMethodAsync`</ph>.</source>
          <target state="translated">Por ejemplo, en el siguiente ejemplo de formularios Windows Forms se incluye un controlador de eventos que llama y espera un método asincrónico, <ph id="ph1">`ExampleMethodAsync`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can add the same event handler by using an async lambda in an <bpt id="p1">[</bpt>AddHandler Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/addhandler-statement.md)</ept>.</source>
          <target state="translated">Puede agregar el mismo controlador de eventos mediante una lambda asincrónica en un <bpt id="p1">[</bpt>AddHandler (instrucción)<ept id="p1">](../../../../visual-basic/language-reference/statements/addhandler-statement.md)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>To add this handler, add an <ph id="ph1">`Async`</ph> modifier before the lambda parameter list, as the following example shows.</source>
          <target state="translated">Para agregar este controlador, agregue un modificador <ph id="ph1">`Async`</ph> antes de la lista de parámetros lambda, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For more information about how to create and use async methods, see <bpt id="p1">[</bpt>Asynchronous Programming with Async and Await<ept id="p1">](../../../../visual-basic/programming-guide/concepts/async/index.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de cómo crear y usar métodos asincrónicos, vea <bpt id="p1">[</bpt>la programación asincrónica con Async y Await<ept id="p1">](../../../../visual-basic/programming-guide/concepts/async/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="context"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Context</source>
          <target state="translated"><bpt id="p1">&lt;a name="context"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>Contexto</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>A lambda expression shares its context with the scope within which it is defined.</source>
          <target state="translated">Una expresión lambda comparte su contexto con el ámbito dentro del cual se define.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It has the same access rights as any code written in the containing scope.</source>
          <target state="translated">Tiene los mismos derechos de acceso que cualquier código escrito en el ámbito contenedor.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This includes access to member variables, functions and subs, <ph id="ph1">`Me`</ph>, and parameters and local variables in the containing scope.</source>
          <target state="translated">Esto incluye el acceso a las variables miembro, funciones y subrutinas, <ph id="ph1">`Me`</ph>, parámetros y variables locales del ámbito contenedor.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Access to local variables and parameters in the containing scope can extend beyond the lifetime of that scope.</source>
          <target state="translated">Acceso a las variables locales y parámetros en el ámbito contenedor se puede extender más allá de la duración de ese ámbito.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>As long as a delegate referring to a lambda expression is not available to garbage collection, access to the variables in the original environment is retained.</source>
          <target state="translated">Como un delegado que hace referencia a una expresión lambda no está disponible para la colección de elementos no utilizados, se conserva el acceso a las variables del entorno original.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>In the following example, variable <ph id="ph1">`target`</ph> is local to <ph id="ph2">`makeTheGame`</ph>, the method in which the lambda expression <ph id="ph3">`playTheGame`</ph> is defined.</source>
          <target state="translated">En el ejemplo siguiente, la variable <ph id="ph1">`target`</ph> local <ph id="ph2">`makeTheGame`</ph>, el método en el que la expresión lambda <ph id="ph3">`playTheGame`</ph> está definido.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Note that the returned lambda expression, assigned to <ph id="ph1">`takeAGuess`</ph> in <ph id="ph2">`Main`</ph>, still has access to the local variable <ph id="ph3">`target`</ph>.</source>
          <target state="translated">Tenga en cuenta que la expresión lambda devuelta, asignada a <ph id="ph1">`takeAGuess`</ph> en <ph id="ph2">`Main`</ph>, todavía tiene acceso a la variable local <ph id="ph3">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#12<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_5.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#12;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_5.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the wide range of access rights of the nested lambda expression.</source>
          <target state="translated">En el ejemplo siguiente se muestra la amplia gama de derechos de acceso de la expresión lambda anidada.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When the returned lambda expression is executed from <ph id="ph1">`Main`</ph> as <ph id="ph2">`aDel`</ph>, it accesses these elements:</source>
          <target state="translated">Cuando se ejecuta la expresión lambda devuelta desde <ph id="ph1">`Main`</ph> como <ph id="ph2">`aDel`</ph>, tiene acceso a estos elementos:</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>A field of the class in which it is defined: <ph id="ph1">`aField`</ph></source>
          <target state="translated">Un campo de la clase en la que se define:<ph id="ph1">`aField`</ph></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>A property of the class in which it is defined: <ph id="ph1">`aProp`</ph></source>
          <target state="translated">Una propiedad de la clase en la que se define:<ph id="ph1">`aProp`</ph></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A parameter of method <ph id="ph1">`functionWithNestedLambda`</ph>, in which it is defined: <ph id="ph2">`level1`</ph></source>
          <target state="translated">Un parámetro de método <ph id="ph1">`functionWithNestedLambda`</ph>, en el que se define:<ph id="ph2">`level1`</ph></target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A local variable of <ph id="ph1">`functionWithNestedLambda`</ph>: <ph id="ph2">`localVar`</ph></source>
          <target state="translated">Una variable local de <ph id="ph1">`functionWithNestedLambda`</ph>:<ph id="ph2">`localVar`</ph></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A parameter of the lambda expression in which it is nested: <ph id="ph1">`level2`</ph></source>
          <target state="translated">Un parámetro de la expresión lambda en el que está anidado:<ph id="ph1">`level2`</ph></target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#9<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_6.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#9;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_6.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Converting to a Delegate Type</source>
          <target state="translated">Convertir a un tipo de delegado</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>A lambda expression can be implicitly converted to a compatible delegate type.</source>
          <target state="translated">Una expresión lambda se puede convertir implícitamente a un tipo de delegado compatible.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For information about the general requirements for compatibility, see <bpt id="p1">[</bpt>Relaxed Delegate Conversion<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de los requisitos generales de compatibilidad, vea <bpt id="p1">[</bpt>la conversión de delegado no estricta<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For example, the following code example shows a lambda expression that implicitly converts to <ph id="ph1">`Func(Of Integer, Boolean)`</ph> or a matching delegate signature.</source>
          <target state="translated">Por ejemplo, en el ejemplo de código siguiente se muestra una expresión lambda que se convierte implícitamente a <ph id="ph1">`Func(Of Integer, Boolean)`</ph> o una firma de delegado correspondiente.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#16<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_7.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas Nº&amp;16;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_7.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The following code example shows a lambda expression that implicitly converts to <ph id="ph1">`Sub(Of Double, String, Double)`</ph> or a matching delegate signature.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra una expresión lambda que se convierte implícitamente a <ph id="ph1">`Sub(Of Double, String, Double)`</ph> o una firma de delegado correspondiente.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#23<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_8.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>23 de VbVbalrLambdas #<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_8.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>When you assign lambda expressions to delegates or pass them as arguments to procedures, you can specify the parameter names but omit their data types, letting the types be taken from the delegate.</source>
          <target state="translated">Al asignar las expresiones lambda a delegados o pasar como argumentos a los procedimientos, puede especificar los nombres de parámetro pero omite los tipos de datos, permitir que los tipos se toma del delegado.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Ejemplos</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The following example defines a lambda expression that returns <ph id="ph1">`True`</ph> if the nullable argument has an assigned value, and <ph id="ph2">`False`</ph> if its value is <ph id="ph3">`Nothing`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se define una expresión lambda que devuelve <ph id="ph1">`True`</ph> si el argumento que acepta valores NULL tiene un valor asignado, y <ph id="ph2">`False`</ph> si su valor es <ph id="ph3">`Nothing`</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#4<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_9.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas Nº&amp;4;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_9.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following example defines a lambda expression that returns the index of the last element in an array.</source>
          <target state="translated">En el ejemplo siguiente se define una expresión lambda que devuelve el índice del último elemento de una matriz.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#5<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_10.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#5;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_10.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vea también</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Procedures<ept id="p1">](./index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Procedimientos<ept id="p1">](./index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Introduction to LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Introducción a LINQ en Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Delegates<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Delegados<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Function Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/function-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Function (instrucción)<ept id="p1">](../../../../visual-basic/language-reference/statements/function-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Sub Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/sub-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Sub (instrucción)<ept id="p1">](../../../../visual-basic/language-reference/statements/sub-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Nullable Value Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/nullable-value-types.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Tipos de valor que aceptan valores null<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/nullable-value-types.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Pass Procedures to Another Procedure in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/how-to-pass-procedures-to-another-procedure.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Cómo: pasar procedimientos a otro procedimiento en Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/how-to-pass-procedures-to-another-procedure.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Create a Lambda Expression<ept id="p1">](./how-to-create-a-lambda-expression.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Cómo: crear una expresión Lambda<ept id="p1">](./how-to-create-a-lambda-expression.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Relaxed Delegate Conversion<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Conversión de delegado flexible<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>