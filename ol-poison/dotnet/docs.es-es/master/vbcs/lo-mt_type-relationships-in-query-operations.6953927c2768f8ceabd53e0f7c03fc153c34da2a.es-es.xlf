<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a966b69feca7a7021cafbccb7971913ea781c479</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\type-relationships-in-query-operations.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67448ac455263820f6bf6c4aa5dedfa148279d20</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f11474c2b7d5eb9902484fd122f08ef7743f0509</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_type-relationships-in-query-operations.6953927c2768f8ceabd53e0f7c03fc153c34da2a.es-es is different with handoff file name: type-relationships-in-query-operations.6953927c2768f8ceabd53e0f7c03fc153c34da2a.es-es.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Type Relationships in Query Operations (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Relaciones de tipos en operaciones de consulta (Visual Basic) | Documentos de Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Type Relationships in Query Operations (Visual Basic)</source>
          <target state="translated">Relaciones entre tipos en operaciones de consulta (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Variables used in <ph id="ph1">[!INCLUDE[vbteclinqext](../../../../csharp/getting-started/includes/vbteclinqext_md.md)]</ph> query operations are strongly typed and must be compatible with each other.</source>
          <target state="translated">Las variables usadas en <ph id="ph1">[!INCLUDE[vbteclinqext](../../../../csharp/getting-started/includes/vbteclinqext_md.md)]</ph> consulta operaciones están fuertemente tipadas y deben ser compatibles entre sí.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Strong typing is used in the data source, in the query itself, and in the query execution.</source>
          <target state="translated">Establecimiento inflexible de tipos se utiliza en el origen de datos, en la propia consulta y en la ejecución de consultas.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The following illustration identifies terms used to describe a <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> query.</source>
          <target state="translated">La ilustración siguiente identifica los términos utilizados para describir un <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> consulta.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For more information about the parts of a query, see <bpt id="p1">[</bpt>Basic Query Operations (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de los elementos de una consulta, vea <bpt id="p1">[</bpt>operaciones básicas de consulta (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md)</ept>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Pseudocode query with elements highlighted.<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/media/sjltyperels.png "SJLtypeRels")</ept></source>
          <target state="translated"><bpt id="p1">![</bpt>Consulta de pseudocódigo con elementos resaltados.<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/media/sjltyperels.png "SJLtypeRels")</ept></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Parts of a LINQ query</source>
          <target state="translated">Partes de una consulta LINQ</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The type of the range variable in the query must be compatible with the type of the elements in the data source.</source>
          <target state="translated">El tipo de la variable de rango en la consulta debe ser compatible con el tipo de los elementos del origen de datos.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The type of the query variable must be compatible with the sequence element defined in the <ph id="ph1">`Select`</ph> clause.</source>
          <target state="translated">El tipo de la variable de consulta debe ser compatible con el elemento de secuencia definido en el <ph id="ph1">`Select`</ph> cláusula.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Finally, the type of the sequence elements also must be compatible with the type of the loop control variable that is used in the <ph id="ph1">`For Each`</ph> statement that executes the query.</source>
          <target state="translated">Por último, el tipo de los elementos de secuencia también debe ser compatible con el tipo de la variable de control de bucle que se utiliza en el <ph id="ph1">`For Each`</ph> instrucción que ejecuta la consulta.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This strong typing facilitates identification of type errors at compile time.</source>
          <target state="translated">Establecimiento inflexible de tipos facilita la identificación de errores de tipo en tiempo de compilación.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> makes strong typing convenient by implementing local type inference, also known as <bpt id="p1">*</bpt>implicit typing<ept id="p1">*</ept>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph>hace establecimiento inflexible de tipos adecuada al implementar la inferencia de tipo local, también conocido como <bpt id="p1">*</bpt>tipos implícitos<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>That feature is used in the previous example, and you will see it used throughout the <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> samples and documentation.</source>
          <target state="translated">Que se usa la característica en el ejemplo anterior y verá que se utiliza en el <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> ejemplos y documentación.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In Visual Basic, local type inference is accomplished simply by using a <ph id="ph1">`Dim`</ph> statement without an <ph id="ph2">`As`</ph> clause.</source>
          <target state="translated">En Visual Basic, la inferencia de tipo local se logra simplemente mediante una <ph id="ph1">`Dim`</ph> instrucción sin un <ph id="ph2">`As`</ph> cláusula.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`city`</ph> is strongly typed as a string.</source>
          <target state="translated">En el ejemplo siguiente, <ph id="ph1">`city`</ph> está fuertemente tipada como una cadena.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels#1<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>1 VbLINQTypeRels<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Local type inference works only when <ph id="ph1">`Option Infer`</ph> is set to <ph id="ph2">`On`</ph>.</source>
          <target state="translated">Inferencia de tipo local sólo funciona cuando <ph id="ph1">`Option Infer`</ph> está establecido en <ph id="ph2">`On`</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Option Infer Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/option-infer-statement.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Option Infer instrucción<ept id="p1">](../../../../visual-basic/language-reference/statements/option-infer-statement.md)</ept>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>However, even if you use local type inference in a query, the same type relationships are present among the variables in the data source, the query variable, and the query execution loop.</source>
          <target state="translated">Sin embargo, incluso si utiliza la inferencia de tipo local en una consulta, las mismas relaciones de tipo están presentes entre las variables en el origen de datos, la variable de consulta y el bucle de ejecución de la consulta.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>It is useful to have a basic understanding of these type relationships when you are writing <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> queries, or working with the samples and code examples in the documentation.</source>
          <target state="translated">Resulta útil tener un conocimiento básico de estas relaciones de tipos cuando se escribe <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> consultas o trabajar con los ejemplos y ejemplos de código en la documentación.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You may need to specify an explicit type for a range variable that does not match the type returned from the data source.</source>
          <target state="translated">Debe especificar un tipo explícito para una variable de rango que no coincide con el tipo devuelto desde el origen de datos.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can specify the type of the range variable by using an <ph id="ph1">`As`</ph> clause.</source>
          <target state="translated">Puede especificar el tipo de la variable de rango mediante una <ph id="ph1">`As`</ph> cláusula.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>However, this results in an error if the conversion is a <bpt id="p1">[</bpt>narrowing conversion<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept> and <ph id="ph1">`Option Strict`</ph> is set to <ph id="ph2">`On`</ph>.</source>
          <target state="translated">Sin embargo, esto produce un error si la conversión es un <bpt id="p1">[</bpt>conversión de restricción<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept> y <ph id="ph1">`Option Strict`</ph> está establecido en <ph id="ph2">`On`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Therefore, we recommend that you perform the conversion on the values retrieved from the data source.</source>
          <target state="translated">Por lo tanto, se recomienda realizar la conversión en los valores recuperados del origen de datos.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You can convert the values from the data source to the explicit range variable type by using the &lt;xref:System.Linq.Enumerable.Cast%2A&gt; method.</source>
          <target state="translated">Puede convertir los valores del origen de datos para el tipo de variable de rango explícito mediante el &lt;xref:System.Linq.Enumerable.Cast%2A&gt;método.&lt;/xref:System.Linq.Enumerable.Cast%2A&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can also cast the values selected in the <ph id="ph1">`Select`</ph> clause to an explicit type that is different from the type of the range variable.</source>
          <target state="translated">También puede convertir los valores seleccionados en el <ph id="ph1">`Select`</ph> cláusula para un tipo explícito que sea diferente del tipo de la variable de rango.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>These points are illustrated in the following code.</source>
          <target state="translated">Estos puntos se reflejan en el código siguiente.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels#4<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels Nº&amp;4;<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Queries That Return Entire Elements of the Source Data</source>
          <target state="translated">Consultas que devuelven elementos completos de los datos de origen</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The following example shows a <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> query operation that returns a sequence of elements selected from the source data.</source>
          <target state="translated">El ejemplo siguiente muestra un <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> operación que devuelve una secuencia de elementos seleccionados del origen de datos de consulta.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The source, <ph id="ph1">`names`</ph>, contains an array of strings, and the query output is a sequence containing strings that start with the letter M.</source>
          <target state="translated">El origen, <ph id="ph1">`names`</ph>, contiene una matriz de cadenas, y el resultado de la consulta es una secuencia que contiene cadenas que empiezan por la letra M.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels#2<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels&amp;#2;<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This is equivalent to the following code, but is much shorter and easier to write.</source>
          <target state="translated">Esto es equivalente al código siguiente, pero es mucho más corto y más fácil de escribir.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Reliance on local type inference in queries is the preferred style in Visual Basic.</source>
          <target state="translated">Dependencia de la inferencia de tipo local en las consultas es el estilo preferido en Visual Basic.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels#3<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels&amp;3;<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following relationships exist in both of the previous code examples, whether the types are determined implicitly or explicitly.</source>
          <target state="translated">Existen las siguientes relaciones en ambos ejemplos de código anteriores, si se determinan los tipos de forma implícita o explícita.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The type of the elements in the data source, <ph id="ph1">`names`</ph>, is the type of the range variable, <ph id="ph2">`name`</ph>, in the query.</source>
          <target state="translated">El tipo de los elementos del origen de datos, <ph id="ph1">`names`</ph>, es el tipo de la variable de rango, <ph id="ph2">`name`</ph>, en la consulta.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The type of the object that is selected, <ph id="ph1">`name`</ph>, determines the type of the query variable, <ph id="ph2">`mNames`</ph>.</source>
          <target state="translated">El tipo del objeto seleccionado, <ph id="ph1">`name`</ph>, determina el tipo de la variable de consulta, <ph id="ph2">`mNames`</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Here <ph id="ph1">`name`</ph> is a string, so the query variable is IEnumerable(Of String) in Visual Basic.</source>
          <target state="translated">Aquí <ph id="ph1">`name`</ph> es una cadena, por lo que la variable de consulta es IEnumerable (Of String) en Visual Basic.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The query defined in <ph id="ph1">`mNames`</ph> is executed in the <ph id="ph2">`For Each`</ph> loop.</source>
          <target state="translated">La consulta definida en <ph id="ph1">`mNames`</ph> se ejecuta en el <ph id="ph2">`For Each`</ph> bucle.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The loop iterates over the result of executing the query.</source>
          <target state="translated">El bucle recorre en iteración el resultado de ejecutar la consulta.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`mNames`</ph>, when it is executed, will return a sequence of strings, the loop iteration variable, <ph id="ph2">`nm`</ph>, also is a string.</source>
          <target state="translated">Porque <ph id="ph1">`mNames`</ph>, cuando se ejecuta, devuelve una secuencia de cadenas, la variable de iteración del bucle, <ph id="ph2">`nm`</ph>, también es una cadena.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Queries That Return One Field from Selected Elements</source>
          <target state="translated">Consultas que devuelven un campo de los elementos seleccionados</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The following example shows a <ph id="ph1">[!INCLUDE[vbtecdlinq](../../../../csharp/includes/vbtecdlinq_md.md)]</ph> query operation that returns a sequence containing only one part of each element selected from the data source.</source>
          <target state="translated">El ejemplo siguiente muestra un <ph id="ph1">[!INCLUDE[vbtecdlinq](../../../../csharp/includes/vbtecdlinq_md.md)]</ph> operación que devuelve una secuencia que contiene sólo una parte de cada elemento seleccionado del origen de datos de consulta.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The query takes a collection of <ph id="ph1">`Customer`</ph> objects as its data source and projects only the <ph id="ph2">`Name`</ph> property in the result.</source>
          <target state="translated">La consulta toma una colección de <ph id="ph1">`Customer`</ph> objetos como origen de datos y proyectos de sólo el <ph id="ph2">`Name`</ph> propiedad en el resultado.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Because the customer name is a string, the query produces a sequence of strings as output.</source>
          <target state="translated">Dado que el nombre del cliente es una cadena, la consulta genera una secuencia de cadenas como resultado.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>0<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>0<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The relationships between variables are like those in the simpler example.</source>
          <target state="translated">Las relaciones entre las variables son como las del ejemplo más sencillo.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The type of the elements in the data source, <ph id="ph1">`customers`</ph>, is the type of the range variable, <ph id="ph2">`cust`</ph>, in the query.</source>
          <target state="translated">El tipo de los elementos del origen de datos, <ph id="ph1">`customers`</ph>, es el tipo de la variable de rango, <ph id="ph2">`cust`</ph>, en la consulta.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In this example, that type is <ph id="ph1">`Customer`</ph>.</source>
          <target state="translated">En este ejemplo, que es de tipo <ph id="ph1">`Customer`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Select`</ph> statement returns the <ph id="ph2">`Name`</ph> property of each <ph id="ph3">`Customer`</ph> object instead of the whole object.</source>
          <target state="translated">El <ph id="ph1">`Select`</ph> instrucción devuelve el <ph id="ph2">`Name`</ph> propiedad de cada <ph id="ph3">`Customer`</ph> objeto en lugar de todo el objeto.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`Name`</ph> is a string, the query variable, <ph id="ph2">`custNames`</ph>, will again be IEnumerable(Of String), not of <ph id="ph3">`Customer`</ph>.</source>
          <target state="translated">Porque <ph id="ph1">`Name`</ph> es una cadena, la variable de consulta, <ph id="ph2">`custNames`</ph>, volverán a ser IEnumerable (Of String), no de <ph id="ph3">`Customer`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`custNames`</ph> represents a sequence of strings, the <ph id="ph2">`For Each`</ph> loop's iteration variable, <ph id="ph3">`custName`</ph>, must be a string.</source>
          <target state="translated">Porque <ph id="ph1">`custNames`</ph> representa una secuencia de cadenas, la <ph id="ph2">`For Each`</ph> variable de iteración del bucle, <ph id="ph3">`custName`</ph>, debe ser una cadena.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Without local type inference, the previous example would be more cumbersome to write and to understand, as the following example shows.</source>
          <target state="translated">Sin la inferencia de tipo local, el ejemplo anterior sería más difícil de escribir y comprender, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>1<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>1<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Queries That Require Anonymous Types</source>
          <target state="translated">Consultas que requieren tipos anónimos</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following example shows a more complex situation.</source>
          <target state="translated">En el ejemplo siguiente se muestra una situación más compleja.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In the previous example, it was inconvenient to specify types for all the variables explicitly.</source>
          <target state="translated">En el ejemplo anterior, no era apropiado especificar explícitamente los tipos de todas las variables.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In this example, it is impossible.</source>
          <target state="translated">En este ejemplo, es imposible.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Instead of selecting entire <ph id="ph1">`Customer`</ph> elements from the data source, or a single field from each element, the <ph id="ph2">`Select`</ph> clause in this query returns two properties of the original <ph id="ph3">`Customer`</ph> object: <ph id="ph4">`Name`</ph> and <ph id="ph5">`City`</ph>.</source>
          <target state="translated">En lugar de seleccionar todo <ph id="ph1">`Customer`</ph> elementos desde el origen de datos o un campo único de cada elemento, la <ph id="ph2">`Select`</ph> cláusula en esta consulta devuelve dos propiedades del original <ph id="ph3">`Customer`</ph> objeto: <ph id="ph4">`Name`</ph> y <ph id="ph5">`City`</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In response to the <ph id="ph1">`Select`</ph> clause, the compiler defines an anonymous type that contains those two properties.</source>
          <target state="translated">En respuesta a la <ph id="ph1">`Select`</ph> cláusula, el compilador define un tipo anónimo que contiene esas dos propiedades.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The result of executing <ph id="ph1">`nameCityQuery`</ph> in the <ph id="ph2">`For Each`</ph> loop is a collection of instances of the new anonymous type.</source>
          <target state="translated">El resultado de ejecutar <ph id="ph1">`nameCityQuery`</ph> en el <ph id="ph2">`For Each`</ph> bucle es una colección de instancias del nuevo tipo anónimo.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Because the anonymous type has no usable name, you cannot specify the type of <ph id="ph1">`nameCityQuery`</ph> or <ph id="ph2">`custInfo`</ph> explicitly.</source>
          <target state="translated">Dado que el tipo anónimo no tiene ningún nombre utilizable, no puede especificar el tipo de <ph id="ph1">`nameCityQuery`</ph> o <ph id="ph2">`custInfo`</ph> explícitamente.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>That is, with an anonymous type, you have no type name to use in place of <ph id="ph1">`String`</ph> in <ph id="ph2">`IEnumerable(Of String)`</ph>.</source>
          <target state="translated">Es decir, con un tipo anónimo, no tiene ningún nombre de tipo para usar en lugar de <ph id="ph1">`String`</ph> en <ph id="ph2">`IEnumerable(Of String)`</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Anonymous Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>tipos anónimos<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>2<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>2<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Although it is not possible to specify types for all the variables in the previous example, the relationships remain the same.</source>
          <target state="translated">Aunque no es posible especificar los tipos de todas las variables en el ejemplo anterior, las relaciones siguen siendo los mismos.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The type of the elements in the data source is again the type of the range variable in the query.</source>
          <target state="translated">El tipo de los elementos del origen de datos nuevo es el tipo de la variable de rango en la consulta.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In this example, <ph id="ph1">`cust`</ph> is an instance of <ph id="ph2">`Customer`</ph>.</source>
          <target state="translated">En este ejemplo, <ph id="ph1">`cust`</ph> es una instancia de <ph id="ph2">`Customer`</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`Select`</ph> statement produces an anonymous type, the query variable, <ph id="ph2">`nameCityQuery`</ph>, must be implicitly typed as an anonymous type.</source>
          <target state="translated">Dado que la <ph id="ph1">`Select`</ph> instrucción genera un tipo anónimo, la variable de consulta, <ph id="ph2">`nameCityQuery`</ph>, debe declararse implícitamente como un tipo anónimo.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>An anonymous type has no usable name, and therefore cannot be specified explicitly.</source>
          <target state="translated">Un tipo anónimo no tiene ningún nombre utilizable y, por tanto, no se puede especificar explícitamente.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The type of the iteration variable in the <ph id="ph1">`For Each`</ph> loop is the anonymous type created in step 2.</source>
          <target state="translated">El tipo de la variable de iteración en la <ph id="ph1">`For Each`</ph> bucle es el tipo anónimo creado en el paso 2.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Because the type has no usable name, the type of the loop iteration variable must be determined implicitly.</source>
          <target state="translated">Dado que el tipo no tiene ningún nombre utilizable, implícitamente se determinará el tipo de la variable de iteración del bucle.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Vea también</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Getting Started with LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/getting-started-with-linq.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Introducción a LINQ en Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/getting-started-with-linq.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Anonymous Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Tipos anónimos<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Local Type Inference<ept id="p1">](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Inferencia de tipo local<ept id="p1">](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Introduction to LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Introducción a LINQ en Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>LINQ<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>LINQ<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Queries<ept id="p1">](../../../../visual-basic/language-reference/queries/queries.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Consultas<ept id="p1">](../../../../visual-basic/language-reference/queries/queries.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>