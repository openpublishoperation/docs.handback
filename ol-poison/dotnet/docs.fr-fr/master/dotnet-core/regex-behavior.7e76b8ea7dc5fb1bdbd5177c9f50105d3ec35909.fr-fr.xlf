<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fa0513a5b450742995bd86fca495ba9904e7361b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\regex-behavior.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4487a8a5971b0098f55c989ab3c345500350eaad</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c84206223270960d50dfe758841e4cb5765524b6</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file regex-behavior.7e76b8ea7dc5fb1bdbd5177c9f50105d3ec35909.fr-fr.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Details of regular expression behavior</source>
          <target state="translated">Comportement détaillé des expressions régulières</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Details of regular expression behavior</source>
          <target state="translated">Comportement détaillé des expressions régulières</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Details of regular expression behavior</source>
          <target state="translated">Comportement détaillé des expressions régulières</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The .NET regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</source>
          <target state="translated">Le moteur d’expression régulière .NET est un analyseur d’expression régulière rétroactive qui incorpore un moteur NFA (Nondeterministic Finite Automaton) tel que celui utilisé par Perl, Python, Emacs et Tcl.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</source>
          <target state="translated">Cette particularité le distingue des moteurs d’expression régulière pure DFA (Deterministic Finite Automaton) plus rapides, mais plus limités, comme ceux d’awk, egrep ou lex.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This also distinguishes it from standardized, but slower, POSIX NFAs.</source>
          <target state="translated">Elle le distingue également des moteurs NFA POSIX standardisés, mais plus lents.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The following section describes the three types of regular expression engines, and explains why regular expressions in .NET are implemented by using a traditional NFA engine.</source>
          <target state="translated">La section suivante décrit les trois types de moteurs d’expression régulière et explique pourquoi les expressions régulières dans .NET sont implémentées à l’aide d’un moteur NFA classique.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Benefits of the NFA Engine</source>
          <target state="translated">Avantages du moteur NFA</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When DFA engines perform pattern matching, their processing order is driven by the input string.</source>
          <target state="translated">Quand les moteurs DFA exécutent des critères spéciaux, leur ordre de traitement est piloté par la chaîne d’entrée.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</source>
          <target state="translated">Les moteurs commencent au début de la chaîne d’entrée et continuent de manière séquentielle pour déterminer si le caractère suivant correspond au modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>They can guarantee to match the longest string possible.</source>
          <target state="translated">Ils peuvent garantir une correspondance avec la chaîne la plus longue possible.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Because they never test the same character twice, DFA engines do not support backtracking.</source>
          <target state="translated">Étant donné qu’ils ne testent jamais le même caractère deux fois, les moteurs DFA ne prennent pas en charge la rétroaction.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</source>
          <target state="translated">Toutefois, étant donné qu’un moteur DFA contient uniquement un état fini, il ne peut pas rechercher un modèle avec des références arrière, et comme il ne construit pas d’expansion explicite, il ne peut pas capturer de sous-expressions.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</source>
          <target state="translated">Contrairement aux moteurs DFA, quand les moteurs NFA classiques exécutent des critères spéciaux, leur ordre de traitement est piloté par le modèle d’expression régulière.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</source>
          <target state="translated">Lorsqu’il traite un élément de langage particulier, le moteur utilise une correspondance gourmande ; autrement dit, il cherche la chaîne d’entrée la plus longue possible.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>But it also saves its state after successfully matching a subexpression.</source>
          <target state="translated">Mais il enregistre également son état après avoir trouvé la correspondance correcte d’une sous-expression.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If a match eventually fails, the engine can return to a saved state so it can try additional matches.</source>
          <target state="translated">Si une correspondance finit par échouer, le moteur peut revenir à un état enregistré pour tenter d’autres correspondances.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as backtracking.</source>
          <target state="translated">Ce processus consistant à abandonner une correspondance réussie de sous-expression pour que les éléments de langage ultérieurs dans l’expression régulière puissent également correspondre est appelé rétroaction.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</source>
          <target state="translated">Les moteurs NFA utilisent la rétroaction pour tester toutes les expansions possibles d’une expression régulière dans un ordre spécifique et accepter la première correspondance.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</source>
          <target state="translated">Comme un moteur NFA classique construit une expansion spécifique de l’expression régulière pour obtenir une correspondance correcte, il peut capturer des correspondances de sous-expressions et des références arrière correspondantes.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</source>
          <target state="translated">Toutefois, comme un moteur NFA classique utilise la rétroaction, il peut visiter le même état plusieurs fois s’il y parvient par différents chemins.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>As a result, it can run exponentially slowly in the worst case.</source>
          <target state="translated">Par conséquent, il peut s’exécuter lentement de façon exponentielle dans le pire des cas.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</source>
          <target state="translated">Comme un moteur NFA classique accepte la première correspondance trouvée, il peut également en négliger d’autres (éventuellement plus longues).</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</source>
          <target state="translated">Les moteurs NFA POSIX sont comme les moteurs NFA classiques, sauf qu’ils poursuivent la rétroaction jusqu’à garantir qu’ils ont trouvé la correspondance la plus longue possible.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</source>
          <target state="translated">Ainsi, un moteur NFA POSIX est plus lent qu’un moteur NFA classique. Quand vous utilisez un moteur NFA POSIX, vous ne pouvez pas favoriser une correspondance plus courte au détriment d’une plus longue en modifiant l’ordre de la recherche rétroactive.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</source>
          <target state="translated">Les moteurs NFA classiques ont la préférence des programmeurs, car ils offrent un meilleur contrôle sur la mise en correspondance de chaînes que les moteurs DFA ou NFA POSIX.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</source>
          <target state="translated">Même si, dans le pire des cas, ils peuvent s’exécuter lentement, vous pouvez les amener à trouver des correspondances sur des durées linéaires ou polynomiales à l’aide de modèles qui réduisent les ambiguïtés et limitent la rétroaction.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well-written and avoids cases in which backtracking degrades performance exponentially.</source>
          <target state="translated">En d’autres termes, même si les moteurs NFA privilégient la puissance et la flexibilité au détriment des performances, ils offrent souvent des performances bonnes à acceptables si une expression régulière est bien écrite et évite les cas dans lesquels la rétroaction dégrade exponentiellement les performances.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see <bpt id="p1">[</bpt>Backtracking in Regular Expressions<ept id="p1">](backtracking.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la baisse des performances due à la rétroaction excessive et sur les moyens de créer une expression régulière pour y remédier, consultez <bpt id="p1">[</bpt>Rétroaction dans les expressions régulières<ept id="p1">](backtracking.md)</ept>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>.NET Framework Engine Capabilities</source>
          <target state="translated">Fonctionnalités du moteur .NET Framework</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>To take advantage of the benefits of a traditional NFA engine, the .NET regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</source>
          <target state="translated">Pour tirer parti des avantages d’un moteur NFA classique, le moteur d’expression régulière .NET inclut un ensemble complet de constructions pour permettre aux programmeurs de diriger le moteur de rétroaction.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>These constructs can be used to find matches faster or to favor specific expansions over others.</source>
          <target state="translated">Ces constructions peuvent être utilisées pour rechercher des correspondances plus rapidement ou pour favoriser des expansions spécifiques par rapport à d’autres.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Other features of the .NET regular expression engine include the following:</source>
          <target state="translated">Les autres fonctionnalités du moteur d’expression régulière .NET sont les suivantes :</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Lazy quantifiers</source>
          <target state="translated">Quantificateurs paresseux</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Lazy quantifiers: <bpt id="p1">**</bpt>??<ept id="p1">**</ept>, <bpt id="p2">__</bpt>*?<ept id="p2">__</ept>, <bpt id="p3">**</bpt>+?<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,<ept id="p6">**</ept><bpt id="p7">_</bpt>m<ept id="p7">_</ept><bpt id="p8">**</bpt>}?<ept id="p8">**</ept>.</source>
          <target state="translated">Quantificateurs paresseux : <bpt id="p1">**</bpt>??<ept id="p1">**</ept>, <bpt id="p2">__</bpt>*?<ept id="p2">__</ept>, <bpt id="p3">**</bpt>+?<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,<ept id="p6">**</ept><bpt id="p7">_</bpt>m<ept id="p7">_</ept><bpt id="p8">**</bpt>}?<ept id="p8">**</ept>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>These constructs tell the backtracking engine to search the minimum number of repetitions first.</source>
          <target state="translated">Ces constructions indiquent au moteur de rétroaction de rechercher d’abord le nombre minimal de répétitions.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</source>
          <target state="translated">Par opposition, les quantificateurs gourmands ordinaires essaient de trouver d’abord le nombre maximal de répétitions.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between the two.</source>
          <target state="translated">L’exemple suivant illustre la différence entre les deux.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</source>
          <target state="translated">Une expression régulière correspond à une phrase se terminant par un nombre qu’un groupe de capture est destiné à extraire.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`.+(\d+)\.`</ph> includes the greedy quantifier <ph id="ph2">`.+`</ph>, which causes the regular expression engine to capture only the last digit of the number.</source>
          <target state="translated">L’expression régulière <ph id="ph1">`.+(\d+)\.`</ph> inclut le quantificateur gourmand <ph id="ph2">`.+`</ph>, qui amène le moteur d’expression régulière à capturer uniquement le dernier chiffre du nombre.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In contrast, the regular expression <ph id="ph1">`.+?(\d+)\.`</ph> includes the lazy quantifier <ph id="ph2">`.+?`</ph>, which causes the regular expression engine to capture the entire number.</source>
          <target state="translated">Par opposition, l’expression régulière <ph id="ph1">`.+?(\d+)\.`</ph> inclut le quantificateur paresseux <ph id="ph2">`.+?`</ph>, qui amène le moteur d’expression régulière à capturer le nombre entier.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The greedy and lazy versions of this regular expression are defined as shown in the following table.</source>
          <target state="translated">Les versions gourmande et paresseuse de cette expression régulière sont définies comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`.+`</ph> (greedy quantifier)</source>
          <target state="translated"><ph id="ph1">`.+`</ph> (quantificateur gourmand)</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Match at least one occurrence of any character.</source>
          <target state="translated">Mettre en correspondance au moins une occurrence de n’importe quel caractère.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</source>
          <target state="translated">Le moteur d’expression régulière recherche alors la chaîne entière, puis effectue une rétroaction si nécessaire pour trouver le reste du modèle.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`.+?`</ph> (lazy quantifier)</source>
          <target state="translated"><ph id="ph1">`.+?`</ph> (quantificateur paresseux)</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Match at least one occurrence of any character, but match as few as possible.</source>
          <target state="translated">Mettre en correspondance au moins une occurrence de n’importe quel caractère, mais une quantité la plus petite possible.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Match at least one numeric character, and assign it to the first capturing group.</source>
          <target state="translated">Mettre en correspondance au moins un caractère numérique et l’assigner au premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Match a period.</source>
          <target state="translated">Mettre en correspondance un point.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For more information about lazy quantifiers, see <bpt id="p1">[</bpt>Quantifiers in regular expressions<ept id="p1">](quantifiers.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les quantificateurs paresseux, consultez <bpt id="p1">[</bpt>Quantificateurs dans les expressions régulières<ept id="p1">](quantifiers.md)</ept>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Positive lookahead</source>
          <target state="translated">Préanalyse positive</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Positive lookahead: <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">Préanalyse positive : <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</source>
          <target state="translated">Cette fonctionnalité permet au moteur de rétroaction de revenir au même endroit dans le texte après avoir mis en correspondance une sous-expression.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</source>
          <target state="translated">Elle s’avère utile pour effectuer une recherche dans le texte en vérifiant plusieurs modèles qui démarrent à la même position.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</source>
          <target state="translated">Elle permet également au moteur de vérifier qu’une sous-chaîne existe à la fin de la correspondance sans inclure cette sous-chaîne dans le texte correspondant.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</source>
          <target state="translated">L’exemple suivant utilise la préanalyse positive pour extraire les mots d’une phrase qui ne sont pas suivis de symboles de ponctuation.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b[A-Z]+\b(?=\P{P})`</ph> is defined as shown in the following table.</source>
          <target state="translated">L'expression régulière <ph id="ph1">`\b[A-Z]+\b(?=\P{P})`</ph> est définie comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Motif</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Match any alphabetic character one or more times.</source>
          <target state="translated">Mettre en correspondance un caractère alphabétique une ou plusieurs fois.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option, the comparison is case-insensitive.</source>
          <target state="translated">Étant donné que la méthode <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> est appelée avec l’option <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>, la comparaison ne respecte pas la casse.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Look ahead to determine whether the next character is a punctuation symbol.</source>
          <target state="translated">Préanalyser pour déterminer si le caractère suivant est un symbole de ponctuation.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If it is not, the match succeeds.</source>
          <target state="translated">Dans la négative, la correspondance réussit.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For more information about positive lookahead assertions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les assertions de préanalyse positive, consultez <bpt id="p1">[</bpt>Constructions de regroupement dans les expressions régulières<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Negative lookahead</source>
          <target state="translated">Préanalyse négative</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Negative lookahead: <bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">Préanalyse négative : <bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This feature adds the ability to match an expression only if a subexpression fails to match.</source>
          <target state="translated">Cette fonctionnalité ajoute la possibilité de mettre en correspondance une expression uniquement si une sous-expression ne correspond pas.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</source>
          <target state="translated">Elle s’avère particulièrement efficace pour affiner une recherche, car il est souvent plus simple de fournir une expression pour un cas à éliminer qu’une expression pour les cas à inclure.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For example, it is difficult to write an expression for words that do not begin with "non".</source>
          <target state="translated">Par exemple, il est difficile d’écrire une expression pour les mots qui ne commencent pas par « non ».</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The following example uses negative lookahead to exclude them.</source>
          <target state="translated">L’exemple suivant utilise la préanalyse négative pour les exclure.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(?!non)\w+\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Le modèle d'expression régulière <ph id="ph1">`\b(?!non)\w+\b`</ph> est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Commencer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Look ahead to ensure that the current string does not begin with "non".</source>
          <target state="translated">Préanalyser pour garantir que la chaîne actuelle ne commence pas par « non ».</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>If it does, the match fails.</source>
          <target state="translated">Si c’est le cas, la correspondance échoue.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Mettre en correspondance un ou plusieurs caractères alphabétiques.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Terminer la correspondance à la limite d'un mot.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For more information about negative lookahead assertions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les assertions de préanalyse négative, consultez <bpt id="p1">[</bpt>Constructions de regroupement dans les expressions régulières<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Conditional evaluation</source>
          <target state="translated">Évaluation conditionnelle</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Conditional evaluation: <bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept>&amp;#124;<bpt id="p5">_</bpt>no<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> and<bpt id="p7">**</bpt>(?(<ept id="p7">**</ept><bpt id="p8">_</bpt>name<ept id="p8">_</ept><bpt id="p9">**</bpt>)<ept id="p9">**</ept><bpt id="p10">_</bpt>yes<ept id="p10">_</ept>&amp;#124;<bpt id="p11">_</bpt>no<ept id="p11">_</ept><bpt id="p12">**</bpt>)<ept id="p12">**</ept>, where <bpt id="p13">*</bpt>expression<ept id="p13">*</ept> is a subexpression to match, <bpt id="p14">*</bpt>name<ept id="p14">*</ept> is the name of a capturing group, <bpt id="p15">*</bpt>yes<ept id="p15">*</ept> is the string to match if <bpt id="p16">*</bpt>expression<ept id="p16">*</ept> is matched or <bpt id="p17">*</bpt>name<ept id="p17">*</ept> is a valid, non-empty captured group, and <bpt id="p18">*</bpt>no<ept id="p18">*</ept> is the subexpression to match if <bpt id="p19">*</bpt>expression<ept id="p19">*</ept> is not matched or <bpt id="p20">*</bpt>name<ept id="p20">*</ept> is not a valid, non-empty captured group.</source>
          <target state="translated">Évaluation conditionnelle : <bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>oui<ept id="p4">_</ept>&amp;#124;<bpt id="p5">_</bpt>non<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> et<bpt id="p7">**</bpt>(?(<ept id="p7">**</ept><bpt id="p8">_</bpt>nom<ept id="p8">_</ept><bpt id="p9">**</bpt>)<ept id="p9">**</ept><bpt id="p10">_</bpt>oui<ept id="p10">_</ept>&amp;#124;<bpt id="p11">_</bpt>non<ept id="p11">_</ept><bpt id="p12">**</bpt>)<ept id="p12">**</ept>, où <bpt id="p13">*</bpt>expression<ept id="p13">*</ept> est une sous-expression à trouver, <bpt id="p14">*</bpt>nom<ept id="p14">*</ept> est le nom d’un groupe de capture, <bpt id="p15">*</bpt>oui<ept id="p15">*</ept> est la chaîne à trouver si <bpt id="p16">*</bpt>expression<ept id="p16">*</ept> est trouvée ou <bpt id="p17">*</bpt>nom<ept id="p17">*</ept> est un groupe capturé valide et non vide, et <bpt id="p18">*</bpt>non<ept id="p18">*</ept> est la sous-expression à trouver si <bpt id="p19">*</bpt>expression<ept id="p19">*</ept> est introuvable ou <bpt id="p20">*</bpt>nom<ept id="p20">*</ept> n’est pas un groupe capturé valide et non vide.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</source>
          <target state="translated">Grâce à cette fonctionnalité, le moteur peut rechercher à l’aide de plusieurs autres modèles, selon le résultat d’une correspondance de sous-expression précédente ou le résultat d’une assertion de largeur nulle.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</source>
          <target state="translated">Cette fonctionnalité permet une forme plus puissante de référence arrière qui permet, par exemple, de rechercher une sous-expression en fonction d’une sous-expression précédente trouvée.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The regular expression in the following example matches paragraphs that are intended for both public and internal use.</source>
          <target state="translated">L’expression régulière utilisée dans l’exemple suivant trouve les paragraphes destinés à une utilisation à la fois interne et publique.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Paragraphs intended only for internal use begin with a <ph id="ph1">`&lt;PRIVATE&gt;`</ph> tag.</source>
          <target state="translated">Les paragraphes destinés à un usage interne uniquement commencent par une balise <ph id="ph1">`&lt;PRIVATE&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^(?&lt;Pvt&gt;\&lt;PRIVATE\&gt;\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$`</ph> uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</source>
          <target state="translated">Le modèle d’expression régulière <ph id="ph1">`^(?&lt;Pvt&gt;\&lt;PRIVATE\&gt;\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$`</ph> utilise une évaluation conditionnelle pour assigner le contenu des paragraphes destinés à une utilisation publique et interne à des groupes de capture distincts.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>These paragraphs can then be handled differently.</source>
          <target state="translated">Ces paragraphes peuvent ensuite être gérés différemment.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">Le modèle d’expression régulière est défini comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of a line.</source>
          <target state="translated">Commencer la correspondance au début d’une ligne.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of the string <ph id="ph1">`&lt;PRIVATE&gt;`</ph> followed by a white-space character.</source>
          <target state="translated">Mettre en correspondance zéro ou une occurrence de la chaîne <ph id="ph1">`&lt;PRIVATE&gt;`</ph> suivie d’un espace blanc.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Assign the match to a capturing group named Pvt.</source>
          <target state="translated">Assigner la correspondance à un groupe de capture nommé Pvt.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Pvt`</ph> capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</source>
          <target state="translated">Si le groupe de capture <ph id="ph1">`Pvt`</ph> existe, mettre en correspondance une ou plusieurs occurrences d’un ou plusieurs caractères de mot suivis de zéro ou un séparateur de ponctuation suivi d’un espace blanc.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Assign the substring to the first capturing group.</source>
          <target state="translated">Assigner la sous-chaîne au premier groupe de capture.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Pvt`</ph> capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</source>
          <target state="translated">Si le groupe de capture <ph id="ph1">`Pvt`</ph> n’existe pas, mettre en correspondance une ou plusieurs occurrences d’un ou plusieurs caractères de mot suivis de zéro ou un séparateur de ponctuation suivi d’un espace blanc.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Assign the substring to the third capturing group.</source>
          <target state="translated">Assigner la sous-chaîne au troisième groupe de capture.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Match the end of a line or the end of the string.</source>
          <target state="translated">Mettre en correspondance la fin d’une ligne ou la fin de la chaîne.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>For more information about conditional evaluation, see <bpt id="p1">[</bpt>Alternation constructs in regular expressions<ept id="p1">](alternation.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’évaluation conditionnelle, consultez <bpt id="p1">[</bpt>Constructions d’alternative dans les expressions régulières<ept id="p1">](alternation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Balancing group definitions</source>
          <target state="translated">Définitions de groupe d'équilibrage</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Balancing group definitions: <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name1-name2<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</source>
          <target state="translated">Définitions de groupe d’équilibrage : <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>nom1-nom2<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>sous-expression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</source>
          <target state="translated">Cette fonctionnalité permet au moteur d’expression régulière d’effectuer un suivi des constructions imbriquées telles que les parenthèses ou les crochets ouvrants et fermants.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>For an example, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Pour obtenir un exemple, consultez <bpt id="p1">[</bpt>Constructions de regroupement dans les expressions régulières<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpressions</source>
          <target state="translated">Sous-expressions non rétroactives</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpressions (also known as greedy subexpressions): <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">Sous-expressions non rétroactives (également appelées sous-expressions gourmandes) : <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</source>
          <target state="translated">Cette fonctionnalité permet au moteur de rétroaction de garantir qu’une sous-expression correspond uniquement à la première correspondance trouvée pour cette sous-expression, comme si l’expression s’exécutait indépendamment de l’expression qui la contient.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</source>
          <target state="translated">Si vous n’utilisez pas cette construction, les recherches rétroactives à partir de la plus grande expression peuvent modifier le comportement d’une sous-expression.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`(a+)\w`</ph> matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the <ph id="ph2">`\w`</ph> language element and is not included in the captured group.</source>
          <target state="translated">Par exemple, l’expression régulière <ph id="ph1">`(a+)\w`</ph> trouve un ou plusieurs caractères « a », ainsi qu’un caractère de mot qui suit la séquence de caractères « a », puis assigne la séquence de caractères « a » au premier groupe de capture. Toutefois, si le dernier caractère de la chaîne d’entrée est également un « a », il est mis en correspondance par l’élément de langage <ph id="ph2">`\w`</ph> et n’est pas inclus dans le groupe capturé.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`((?&gt;a+))\w`</ph> prevents this behavior.</source>
          <target state="translated">L’expression régulière <ph id="ph1">`((?&gt;a+))\w`</ph> empêche ce comportement.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</source>
          <target state="translated">Étant donné que tous les caractères « a » consécutifs sont trouvés sans rétroaction, le premier groupe de capture inclut tous les caractères « a » consécutifs.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>If the "a" characters are not followed by at least one more character other than "a", the match fails.</source>
          <target state="translated">Si les caractères « a » ne sont pas suivis d’au moins un caractère autre que « a », la correspondance échoue.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For more information about nonbacktracking subexpressions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les sous-expressions non rétroactives, consultez <bpt id="p1">[</bpt>Constructions de regroupement dans les expressions régulières<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Right-to-left matching</source>
          <target state="translated">Mise en correspondance de droite à gauche</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Right-to-left matching, which is specified by supplying the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option to a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static instance matching method.</source>
          <target state="translated">La mise en correspondance de droite à gauche est spécifiée en fournissant l’option <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> à une méthode de mise en correspondance de constructeur de classe ou d’instance statique <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</source>
          <target state="translated">Cette fonctionnalité s’avère utile lors de la recherche de droite à gauche au lieu de gauche à droite, ou dans les cas où il est plus efficace de commencer une correspondance dans la partie droite du modèle plutôt que la partie gauche.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</source>
          <target state="translated">Comme l’illustre l’exemple suivant, l’utilisation de la mise en correspondance de droite à gauche peut modifier le comportement des quantificateurs gourmands.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The example conducts two searches for a sentence that ends in a number.</source>
          <target state="translated">L’exemple effectue deux recherches d’une phrase qui se termine par un nombre.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The left-to-right search that uses the greedy quantifier <ph id="ph1">`+`</ph> matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</source>
          <target state="translated">La recherche de gauche à droite qui utilise le quantificateur gourmand <ph id="ph1">`+`</ph> trouve l’un des six chiffres dans la phrase, tandis que la recherche de droite à gauche trouve les six chiffres.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>For an description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</source>
          <target state="translated">Pour obtenir la description du modèle d’expression régulière, consultez l’exemple qui illustre les quantificateurs paresseux plus haut dans cette section.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>For more information about right-to-left matching, see <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la mise en correspondance de droite à gauche, consultez <bpt id="p1">[</bpt>Options des expressions régulières<ept id="p1">](options.md)</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Positive and negative lookbehind</source>
          <target state="translated">Postanalyse positive et négative</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Positive and negative lookbehind: <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> for positive lookbehind, and <bpt id="p4">**</bpt>(?&lt;!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> for negative lookbehind.</source>
          <target state="translated">Postanalyse positive et négative : <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>sous-expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> pour une postanalyse positive et <bpt id="p4">**</bpt>(?&lt;!<ept id="p4">**</ept><bpt id="p5">_</bpt>sous-expression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> pour une postanalyse négative.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>This feature is similar to lookahead, which is discussed earlier in this topic.</source>
          <target state="translated">Cette fonctionnalité est semblable à la préanalyse décrite précédemment dans cette rubrique.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</source>
          <target state="translated">Comme le moteur d’expression régulière autorise une mise en correspondance complète de droite à gauche, les expressions régulières autorisent les postanalyses illimitées.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</source>
          <target state="translated">La postanalyse positive et négative peut également servir à éviter d’imbriquer des quantificateurs lorsque la sous-expression imbriquée est un sur-ensemble d’une expression externe.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Regular expressions with such nested quantifiers often offer poor performance.</source>
          <target state="translated">Les expressions régulières comportant ces quantificateurs imbriqués offrent souvent des performances médiocres.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</source>
          <target state="translated">L’exemple suivant vérifie qu’une chaîne commence et se termine par un caractère alphanumérique et que tout autre caractère contenu dans la chaîne fait partie d’un sur-ensemble plus grand.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>It forms a portion of the regular expression used to validate e-mail addresses; for more information, see <bpt id="p1">[</bpt>How to: Verify that Strings Are in Valid Email Format<ept id="p1">](verify-format.md)</ept>.</source>
          <target state="translated">Il forme une partie de l’expression régulière utilisée pour valider des adresses e-mail. Pour plus d’informations, consultez <bpt id="p1">[</bpt>Guide pratique : vérifier que des chaînes sont dans un format d’adresse e-mail valide<ept id="p1">](verify-format.md)</ept>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^[A-Z0-9]([-!#$%&amp;'.*+/=?^`</ph>{}|~\w])*(?&lt;=[A-Z0-9])$` is defined as shown in the following table.</source>
          <target state="translated">L'expression régulière <ph id="ph1">`^[A-Z0-9]([-!#$%&amp;'.*+/=?^`</ph>{}|~\w])*(?&lt;=[A-Z0-9])$` est définie comme indiqué dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Modèle</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">Commencer la correspondance au début de la chaîne.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Match any numeric or alphanumeric character.</source>
          <target state="translated">Mettre en correspondance n’importe quel caractère numérique ou alphanumérique.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>(The comparison is case-insensitive.)</source>
          <target state="translated">(La comparaison respecte la casse.)</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`([-!#$%&amp;'.*+/=?^`</ph>{}&amp;#124;~\w])*`</source>
          <target state="translated"><ph id="ph1">`([-!#$%&amp;'.*+/=?^`</ph>{}&amp;#124;~\w])*`</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of any word character, or any of the following characters: -, !, #, $, %, &amp;, ', ., *, +, /, =, ?, ^, `, {, }, &amp;#124;, or ~.</source>
          <target state="translated">Mettre en correspondance zéro, une ou plusieurs occurrences de n’importe quel caractère de mot ou de l’un des caractères suivants : -, !, #, $, %, &amp;, ', ., *, +, /, =, ?, ^, `, {, }, &amp;#124;, ou ~.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Look behind to the previous character, which must be numeric or alphanumeric.</source>
          <target state="translated">Postanalyser jusqu’au caractère précédent, qui doit être numérique ou alphanumérique.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>(The comparison is case-insensitive.)</source>
          <target state="translated">(La comparaison respecte la casse.)</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>End the match at the end of the string.</source>
          <target state="translated">Termine la correspondance à la fin de la chaîne.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>For more information about positive and negative lookbehind, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la postanalyse positive et négative, consultez <bpt id="p1">[</bpt>Constructions de regroupement dans les expressions régulières<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Related Topics</source>
          <target state="translated">Rubriques connexes</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Titre</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Rétroaction<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Provides information about how regular expression backtracking branches to find alternative matches.</source>
          <target state="translated">Fournit des informations sur la manière dont la rétroaction d’expression régulière se ramifie pour trouver d’autres correspondances.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Compilation and reuse<ept id="p1">](compilation.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Compilation et réutilisation<ept id="p1">](compilation.md)</ept></target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Provides information about compiling and reusing regular expressions to increase performance.</source>
          <target state="translated">Fournit des informations sur la compilation et la réutilisation des expressions régulières pour augmenter les performances.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Thread safety<ept id="p1">](thread-safety.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Cohérence de thread<ept id="p1">](thread-safety.md)</ept></target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</source>
          <target state="translated">Fournit des informations sur la sécurité des threads d’expression régulière et explique quand vous devez synchroniser l’accès aux objets d’expression régulière.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET regular expressions<ept id="p1">](regular-expressions.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Expressions régulières .NET<ept id="p1">](regular-expressions.md)</ept></target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Provides an overview of the programming language aspect of regular expressions.</source>
          <target state="translated">Fournit une vue d’ensemble de l’aspect du langage de programmation des expressions régulières.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The regular expression Object Model<ept id="p1">](object-model.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Modèle objet d’expression régulière<ept id="p1">](object-model.md)</ept></target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Provides information and code examples illustrating how to use the regular expression classes.</source>
          <target state="translated">Fournit des informations et des exemples de code illustrant l’utilisation des classes d’expression régulière.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression examples<ept id="p1">](regex-examples.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Exemples d’expressions régulières<ept id="p1">](regex-examples.md)</ept></target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Contains code examples that illustrate the use of regular expressions in common applications.</source>
          <target state="translated">Contient des exemples de code qui illustrent l’utilisation des expressions régulières dans des applications courantes.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Langage des expressions régulières - Aide-mémoire<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</source>
          <target state="translated">Fournit des informations sur le jeu de caractères, d’opérateurs et de constructions permettant de définir des expressions régulières.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Référence</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.RegularExpressions<ept id="p1">](xref:System.Text.RegularExpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.RegularExpressions<ept id="p1">](xref:System.Text.RegularExpressions)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>