<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c724bf8b6794e71d49b32c7d3ce9e010f541f68f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\operators-and-expressions\arithmetic-operators.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">168c9f9933b2e34f593a9fafbf545bcaf77a67a3</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">22434cdfba0b468075a3151b855b9c76e3fb27c9</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_arithmetic-operators.d40b7d716eace7bfd9ca27742d78467e761c6a3e.fr-fr is different with handoff file name: arithmetic-operators.d40b7d716eace7bfd9ca27742d78467e761c6a3e.fr-fr.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators in Visual Basic | Microsoft Docs</source>
          <target state="translated">Opérateurs arithmétiques en Visual Basic | Documents Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators in Visual Basic</source>
          <target state="translated">Opérateurs arithmétiques en Visual Basic</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Arithmetic operators are used to perform many of the familiar arithmetic operations that involve the calculation of numeric values represented by literals, variables, other expressions, function and property calls, and constants.</source>
          <target state="translated">Opérateurs arithmétiques sont utilisés pour effectuer de nombreuses opérations arithmétiques familières qui impliquent le calcul de valeurs numériques représentées par des littéraux, variables, autres expressions, fonction appels de propriété et des constantes.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Also classified with arithmetic operators are the bit-shift operators, which act at the level of the individual bits of the operands and shift their bit patterns to the left or right.</source>
          <target state="translated">Également classés avec les opérateurs arithmétiques sont les opérateurs de décalage de bits, qui agissent au niveau des bits des opérandes individuels et leurs modèles de bits de décalage vers la gauche ou la droite.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Arithmetic Operations</source>
          <target state="translated">Opérations arithmétiques</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can add two values in an expression together with the <bpt id="p1">[</bpt>+ Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/addition-operator.md)</ept>, or subtract one from another with the <bpt id="p2">[</bpt>- Operator (Visual Basic)<ept id="p2">](../../../../visual-basic/language-reference/operators/subtraction-operator.md)</ept>, as the following example demonstrates.</source>
          <target state="translated">Vous pouvez ajouter deux valeurs dans une expression avec la <bpt id="p1">[</bpt>opérateur +<ept id="p1">](../../../../visual-basic/language-reference/operators/addition-operator.md)</ept>, ou soustraire une valeur d’une autre avec les <bpt id="p2">[</bpt>-, opérateur (Visual Basic)<ept id="p2">](../../../../visual-basic/language-reference/operators/subtraction-operator.md)</ept>, comme le montre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#57<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators&amp;#57;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Negation also uses the <bpt id="p1">[</bpt>- Operator (Visual Basic)<ept id="p1">](../../../../visual-basic/language-reference/operators/subtraction-operator.md)</ept>, but with only one operand, as the following example demonstrates.</source>
          <target state="translated">Négation utilise également le <bpt id="p1">[</bpt>-, opérateur (Visual Basic)<ept id="p1">](../../../../visual-basic/language-reference/operators/subtraction-operator.md)</ept>, mais avec un seul opérande, comme l’exemple suivant montre comment.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#58<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators&amp;#58;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Multiplication and division use the <bpt id="p1">[</bpt>* Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/multiplication-operator.md)</ept> and <bpt id="p2">[</bpt>/ Operator (Visual Basic)<ept id="p2">](../../../../visual-basic/language-reference/operators/floating-point-division-operator.md)</ept>, respectively, as the following example demonstrates.</source>
          <target state="translated">Multiplication et division utilisent le <bpt id="p1">[</bpt>* opérateur<ept id="p1">](../../../../visual-basic/language-reference/operators/multiplication-operator.md)</ept> et <bpt id="p2">[</bpt>/, opérateur (Visual Basic)<ept id="p2">](../../../../visual-basic/language-reference/operators/floating-point-division-operator.md)</ept>, respectivement, comme le montre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#59<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators&amp;#59;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Exponentiation uses the <bpt id="p1">[</bpt>^ Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/exponentiation-operator.md)</ept>, as the following example demonstrates.</source>
          <target state="translated">Élévation à la puissance utilise le <bpt id="p1">[</bpt>^ opérateur<ept id="p1">](../../../../visual-basic/language-reference/operators/exponentiation-operator.md)</ept>, comme le montre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#60<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators&amp;#60;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Integer division is carried out using the <bpt id="p1">[</bpt>\ Operator (Visual Basic)<ept id="p1">](../../../../visual-basic/language-reference/operators/integer-division-operator.md)</ept>.</source>
          <target state="translated">Division d’entier s’effectue à l’aide de la <bpt id="p1">[</bpt>\, opérateur (Visual Basic)<ept id="p1">](../../../../visual-basic/language-reference/operators/integer-division-operator.md)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Integer division returns the quotient, that is, the integer that represents the number of times the divisor can divide into the dividend without consideration of any remainder.</source>
          <target state="translated">Division d’entier retourne le quotient, autrement dit, l’entier qui représente le nombre de fois où le diviseur peut être divisé par le dividende sans tenir compte du reste.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Both the divisor and the dividend must be integral types (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, and <ph id="ph8">`ULong`</ph>) for this operator.</source>
          <target state="translated">Le diviseur et le dividende doivent être des types intégrés (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, et <ph id="ph8">`ULong`</ph>) pour cet opérateur.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>All other types must be converted to an integral type first.</source>
          <target state="translated">Tous les autres types doivent tout d’abord être convertis en un type intégral.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following example demonstrates integer division.</source>
          <target state="translated">L’exemple suivant illustre la division d’entier.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#61<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_5.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators&amp;#61;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_5.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Modulus arithmetic is performed using the <bpt id="p1">[</bpt>Mod Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/mod-operator.md)</ept>.</source>
          <target state="translated">Modulo arithmétique est effectué à l’aide de la <bpt id="p1">[</bpt>Mod, opérateur<ept id="p1">](../../../../visual-basic/language-reference/operators/mod-operator.md)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This operator returns the remainder after dividing the divisor into the dividend an integral number of times.</source>
          <target state="translated">Cet opérateur retourne le reste après que le diviseur par le dividende un nombre intégral de fois.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>If both divisor and dividend are integral types, the returned value is integral.</source>
          <target state="translated">Si le diviseur et le dividende sont des types intégraux, la valeur retournée est intégrale.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>If divisor and dividend are floating-point types, the returned value is also floating-point.</source>
          <target state="translated">Si le diviseur et le dividende sont des types à virgule flottante, la valeur retournée est également à virgule flottante.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this behavior.</source>
          <target state="translated">L’exemple suivant illustre ce comportement.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#62<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_6.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators&amp;#62;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_6.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#63<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_7.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators&amp;#63;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_7.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Attempted Division by Zero</source>
          <target state="translated">Tentative de Division par zéro</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Division by zero has different results depending on the data types involved.</source>
          <target state="translated">Division par zéro produit des résultats différents selon les types de données impliqués.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In integral divisions (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, <ph id="ph8">`ULong`</ph>), the <ph id="ph9">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> throws a &lt;xref:System.DivideByZeroException&gt; exception.</source>
          <target state="translated">In integral divisions (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, <ph id="ph8">`ULong`</ph>), the <ph id="ph9">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> throws a &lt;xref:System.DivideByZeroException&gt; exception.&lt;/xref:System.DivideByZeroException&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>In division operations on the <ph id="ph1">`Decimal`</ph> or <ph id="ph2">`Single`</ph> data type, the <ph id="ph3">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> also throws a &lt;xref:System.DivideByZeroException&gt; exception.</source>
          <target state="translated">Dans les opérations de division sur la <ph id="ph1">`Decimal`</ph> ou <ph id="ph2">`Single`</ph> type de données, le <ph id="ph3">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> lève également une &lt;xref:System.DivideByZeroException&gt;exception.&lt;/xref:System.DivideByZeroException&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In floating-point divisions involving the <ph id="ph1">`Double`</ph> data type, no exception is thrown, and the result is the class member representing &lt;xref:System.Double.NaN&gt;, &lt;xref:System.Double.PositiveInfinity&gt;, or &lt;xref:System.Double.NegativeInfinity&gt;, depending on the dividend.</source>
          <target state="translated">Dans les divisions à virgule flottante qui implique le <ph id="ph1">`Double`</ph> type de données, aucune exception n’est levée et le résultat est le membre de classe représentant &lt;xref:System.Double.NaN&gt;, &lt;xref:System.Double.PositiveInfinity&gt;, ou &lt;xref:System.Double.NegativeInfinity&gt;, selon le dividende.&lt;/xref:System.Double.NegativeInfinity&gt; &lt;/xref:System.Double.PositiveInfinity&gt; &lt;/xref:System.Double.NaN&gt;</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following table summarizes the various results of attempting to divide a <ph id="ph1">`Double`</ph> value by zero.</source>
          <target state="translated">Le tableau suivant résume les différents résultats de la tentative de diviser un <ph id="ph1">`Double`</ph> valeur par zéro.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Dividend data type</source>
          <target state="translated">Type de données dividende</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Divisor data type</source>
          <target state="translated">Type de données diviseur</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Dividend value</source>
          <target state="translated">Valeur du dividende</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Résultat</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Double.NaN&gt; (not a mathematically defined number)</source>
          <target state="translated">&lt;xref:System.Double.NaN&gt;(pas un nombre défini mathématiquement)&lt;/xref:System.Double.NaN&gt;</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>&gt; 0</source>
          <target state="translated">&gt; 0</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Double.PositiveInfinity&gt;</source>
          <target state="translated">&lt;xref:System.Double.PositiveInfinity&gt;&lt;/xref:System.Double.PositiveInfinity&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\&lt;</ph> 0</source>
          <target state="translated"><ph id="ph1">\&lt;</ph> 0</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Double.NegativeInfinity&gt;</source>
          <target state="translated">&lt;xref:System.Double.NegativeInfinity&gt;&lt;/xref:System.Double.NegativeInfinity&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When you catch a &lt;xref:System.DivideByZeroException&gt; exception, you can use its members to help you handle it.</source>
          <target state="translated">Lorsque vous interceptez une &lt;xref:System.DivideByZeroException&gt;qu'exception, vous pouvez utiliser ses membres pour vous aider à gérer celui-ci.&lt;/xref:System.DivideByZeroException&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For example, the &lt;xref:System.Exception.Message%2A&gt; property holds the message text for the exception.</source>
          <target state="translated">Par exemple, le &lt;xref:System.Exception.Message%2A&gt;propriété contient le texte du message pour l’exception.&lt;/xref:System.Exception.Message%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Try...Catch...Finally Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>essayez... Catch... Instruction finally<ept id="p1">](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Bit-Shift Operations</source>
          <target state="translated">Opérations de décalage de bits</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A bit-shift operation performs an arithmetic shift on a bit pattern.</source>
          <target state="translated">Une opération de décalage de bits effectue un décalage arithmétique sur un modèle binaire.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The pattern is contained in the operand on the left, while the operand on the right specifies the number of positions to shift the pattern.</source>
          <target state="translated">Le modèle est contenu dans l’opérande de gauche, tandis que l’opérande de droite indique le nombre de positions pour décaler le modèle.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>You can shift the pattern to the right with the <bpt id="p1">[</bpt>&gt;&gt; Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/right-shift-operator.md)</ept> or to the left with the <bpt id="p2">[</bpt>&lt;&lt; Operator<ept id="p2">](../../../../visual-basic/language-reference/operators/left-shift-operator.md)</ept>.</source>
          <target state="translated">Vous pouvez décaler le modèle vers la droite avec le <bpt id="p1">[</bpt>&gt;&gt; opérateur<ept id="p1">](../../../../visual-basic/language-reference/operators/right-shift-operator.md)</ept> ou vers la gauche avec la <bpt id="p2">[</bpt> &lt;&gt; &lt;/&gt; <ept id="p2">](../../../../visual-basic/language-reference/operators/left-shift-operator.md)</ept>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The data type of the pattern operand must be <ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, or <ph id="ph8">`ULong`</ph>.</source>
          <target state="translated">Le type de données de l’opérande de modèle doit être <ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, ou <ph id="ph8">`ULong`</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The data type of the shift amount operand must be <ph id="ph1">`Integer`</ph> or must widen to <ph id="ph2">`Integer`</ph>.</source>
          <target state="translated">Le type de données de l’opérande de décalage doit être <ph id="ph1">`Integer`</ph> ou doit s’étendre à <ph id="ph2">`Integer`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Arithmetic shifts are not circular, which means the bits shifted off one end of the result are not reintroduced at the other end.</source>
          <target state="translated">Les décalages arithmétiques ne sont pas circulaires, ce qui signifie que les bits décalés à une extrémité du résultat ne sont pas réintroduits à l’autre extrémité.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The bit positions vacated by a shift are set as follows:</source>
          <target state="translated">Les positions de bit libérées par un décalage sont définies comme suit :</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>0 for an arithmetic left shift</source>
          <target state="translated">0 pour un décalage arithmétique vers la gauche</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>0 for an arithmetic right shift of a positive number</source>
          <target state="translated">0 pour un décalage arithmétique vers la droite d’un nombre positif</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>0 for an arithmetic right shift of an unsigned data type (<ph id="ph1">`Byte`</ph>, <ph id="ph2">`UShort`</ph>, <ph id="ph3">`UInteger`</ph>, <ph id="ph4">`ULong`</ph>)</source>
          <target state="translated">0 pour un décalage arithmétique vers la droite d’un type de données non signé (<ph id="ph1">`Byte`</ph>, <ph id="ph2">`UShort`</ph>, <ph id="ph3">`UInteger`</ph>, <ph id="ph4">`ULong`</ph>)</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>1 for an arithmetic right shift of a negative number (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Short`</ph>, <ph id="ph3">`Integer`</ph>, or <ph id="ph4">`Long`</ph>)</source>
          <target state="translated">1 pour un décalage arithmétique vers la droite d’un nombre négatif (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Short`</ph>, <ph id="ph3">`Integer`</ph>, ou <ph id="ph4">`Long`</ph>)</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following example shifts an <ph id="ph1">`Integer`</ph> value both left and right.</source>
          <target state="translated">L’exemple suivant Décale une <ph id="ph1">`Integer`</ph> valeur gauche et droite.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#64<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_8.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators&amp;#64;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_8.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Arithmetic shifts never generate overflow exceptions.</source>
          <target state="translated">Les décalages arithmétiques ne génèrent jamais des exceptions de dépassement de capacité.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Bitwise Operations</source>
          <target state="translated">Opérations de bits</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In addition to being logical operators, <ph id="ph1">`Not`</ph>, <ph id="ph2">`Or`</ph>, <ph id="ph3">`And`</ph>, and <ph id="ph4">`Xor`</ph> also perform bitwise arithmetic when used on numeric values.</source>
          <target state="translated">Opérateurs logiques, <ph id="ph1">`Not`</ph>, <ph id="ph2">`Or`</ph>, <ph id="ph3">`And`</ph>, et <ph id="ph4">`Xor`</ph> également effectuer les opérations de bits arithmétiques lorsqu’ils sont utilisés sur des valeurs numériques.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For more information, see "Bitwise Operations" in <bpt id="p1">[</bpt>Logical and Bitwise Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez « Opérations de bits » dans <bpt id="p1">[</bpt>opérateurs logiques et au niveau du bit en Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Type Safety</source>
          <target state="translated">Sécurité de type</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Operands should normally be of the same type.</source>
          <target state="translated">Opérandes doivent généralement être du même type.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For example, if you are doing addition with an <ph id="ph1">`Integer`</ph> variable, you should add it to another <ph id="ph2">`Integer`</ph> variable, and you should assign the result to a variable of type <ph id="ph3">`Integer`</ph> as well.</source>
          <target state="translated">Par exemple, si vous ajoutez avec une <ph id="ph1">`Integer`</ph> variable, vous devez l’ajouter à un autre <ph id="ph2">`Integer`</ph> variable et vous devez attribuer le résultat à une variable de type <ph id="ph3">`Integer`</ph> également.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>One way to ensure good type-safe coding practice is to use the <bpt id="p1">[</bpt>Option Strict Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept>.</source>
          <target state="translated">Pour assurer le bon type-safe pratique de programmation consiste à utiliser le <bpt id="p1">[</bpt>Option Strict, instruction<ept id="p1">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If you set <ph id="ph1">`Option Strict On`</ph>, <ph id="ph2">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> automatically performs <bpt id="p1">*</bpt>type-safe<ept id="p1">*</ept> conversions.</source>
          <target state="translated">Si vous définissez <ph id="ph1">`Option Strict On`</ph>, <ph id="ph2">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> effectue automatiquement <bpt id="p1">*</bpt>type-safe<ept id="p1">*</ept> conversions.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, if you try to add an <ph id="ph1">`Integer`</ph> variable to a <ph id="ph2">`Double`</ph> variable and assign the value to a <ph id="ph3">`Double`</ph> variable, the operation proceeds normally, because an <ph id="ph4">`Integer`</ph> value can be converted to <ph id="ph5">`Double`</ph> without loss of data.</source>
          <target state="translated">Par exemple, si vous essayez d’ajouter un <ph id="ph1">`Integer`</ph> à la variable un <ph id="ph2">`Double`</ph> variable et attribuez la valeur à un <ph id="ph3">`Double`</ph> variable, l’opération continue normalement, parce qu’un <ph id="ph4">`Integer`</ph> valeur peut être convertie en <ph id="ph5">`Double`</ph> sans perte de données.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Type-unsafe conversions, on the other hand, cause a compiler error with <ph id="ph1">`Option Strict On`</ph>.</source>
          <target state="translated">Conversions de type sécurisé en revanche, le compilateur génère une erreur avec <ph id="ph1">`Option Strict On`</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example, if you try to add an <ph id="ph1">`Integer`</ph> variable to a <ph id="ph2">`Double`</ph> variable and assign the value to an <ph id="ph3">`Integer`</ph> variable, a compiler error results, because a <ph id="ph4">`Double`</ph> variable cannot be implicitly converted to type <ph id="ph5">`Integer`</ph>.</source>
          <target state="translated">Par exemple, si vous essayez d’ajouter un <ph id="ph1">`Integer`</ph> à la variable un <ph id="ph2">`Double`</ph> variable et attribuez la valeur à une <ph id="ph3">`Integer`</ph> variable, une erreur de compilation se produit, car un <ph id="ph4">`Double`</ph> variable ne peut pas être convertie implicitement en type <ph id="ph5">`Integer`</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If you set <ph id="ph1">`Option Strict Off`</ph>, however, <ph id="ph2">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> allows implicit narrowing conversions to take place, although they can result in the unexpected loss of data or precision.</source>
          <target state="translated">Si vous définissez <ph id="ph1">`Option Strict Off`</ph>, toutefois, <ph id="ph2">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> permet les conversions restrictives implicites, même si elles peuvent entraîner une perte inattendue de données ou de précision.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For this reason, we recommend that you use <ph id="ph1">`Option Strict On`</ph> when writing production code.</source>
          <target state="translated">Pour cette raison, nous vous recommandons d’utiliser <ph id="ph1">`Option Strict On`</ph> lors de l’écriture de code de production.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Widening and Narrowing Conversions<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Conversions étendues et restrictives<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Arithmetic Operators<ept id="p1">](../../../../visual-basic/language-reference/operators/arithmetic-operators.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Opérateurs arithmétiques<ept id="p1">](../../../../visual-basic/language-reference/operators/arithmetic-operators.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Bit Shift Operators<ept id="p1">](../../../../visual-basic/language-reference/operators/bit-shift-operators.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Opérateurs de décalage de bits<ept id="p1">](../../../../visual-basic/language-reference/operators/bit-shift-operators.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Comparison Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/comparison-operators.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Opérateurs de comparaison en Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/comparison-operators.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Concatenation Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Opérateurs de concaténation dans Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Logical and Bitwise Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Opérateurs logiques et au niveau du bit en Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Efficient Combination of Operators<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/efficient-combination-of-operators.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Association efficace d’opérateurs<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/efficient-combination-of-operators.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>