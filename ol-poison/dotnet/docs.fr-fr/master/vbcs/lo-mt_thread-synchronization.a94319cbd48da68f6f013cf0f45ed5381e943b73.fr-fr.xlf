<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ec8fa89c8921eadee428a90971d9ae4ce305a109</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\threading\thread-synchronization.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">507fd3da6f780fafc0c90fc0aad1da71b8d75111</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c9f1ce06f6aa83729f732b6a23672aef4a568997</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_thread-synchronization.a94319cbd48da68f6f013cf0f45ed5381e943b73.fr-fr is different with handoff file name: thread-synchronization.a94319cbd48da68f6f013cf0f45ed5381e943b73.fr-fr.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Thread Synchronization (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Thread de synchronisation (Visual Basic) | Documents Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Thread Synchronization (Visual Basic)</source>
          <target state="translated">Synchronisation de threads (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.</source>
          <target state="translated">Les sections suivantes décrivent les fonctionnalités et les classes qui peuvent être utilisés pour synchroniser l’accès aux ressources dans les applications multithread.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>One of the benefits of using multiple threads in an application is that each thread executes asynchronously.</source>
          <target state="translated">Un des avantages de l’utilisation de plusieurs threads dans une application est que chaque thread s’exécute de façon asynchrone.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.</source>
          <target state="translated">Pour les applications Windows, ainsi, les tâches longues à exécuter en arrière-plan pendant que la fenêtre d’application et les contrôles restent réactives.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For server applications, multithreading provides the ability to handle each incoming request with a different thread.</source>
          <target state="translated">Pour serveur d’applications, le multithreading fournit la capacité de gérer chaque requête entrante avec un thread différent.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Otherwise, each new request would not get serviced until the previous request had been fully satisfied.</source>
          <target state="translated">Sinon, chaque nouvelle demande ne serait pas prise en charge jusqu'à ce que la demande précédente avait été entièrement satisfaite.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.</source>
          <target state="translated">Toutefois, la nature asynchrone des threads a pour conséquence que l’accès aux ressources telles que les handles de fichiers, les connexions réseau et la mémoire doit être coordonnée.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.</source>
          <target state="translated">Sinon, deux ou plusieurs threads peuvent accéder à la même ressource en même temps, chacun ignorant les actions des autres.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The result is unpredictable data corruption.</source>
          <target state="translated">Le résultat est une altération des données imprévisibles.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the &lt;xref:System.Threading.Interlocked&gt; class.</source>
          <target state="translated">Pour les opérations simples sur les types de données numériques intégraux, synchronisation des threads peut se faire avec les membres de la &lt;xref:System.Threading.Interlocked&gt;classe.&lt;/xref:System.Threading.Interlocked&gt;</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.</source>
          <target state="translated">Pour toutes les autres données types et les ressources non thread-safe, le multithreading ne peuvent être en toute sécurité effectuées à l’aide de constructions dans cette rubrique.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For background information on multithreaded programming, see:</source>
          <target state="translated">Pour des informations générales sur la programmation multithread, consultez :</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Managed Threading Basics<ept id="p1">](http://msdn.microsoft.com/library/b2944911-0e8f-427d-a8bb-077550618935)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Principes fondamentaux du Threading managé<ept id="p1">](http://msdn.microsoft.com/library/b2944911-0e8f-427d-a8bb-077550618935)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using Threads and Threading<ept id="p1">](http://msdn.microsoft.com/library/9b5ec2cd-121b-4d49-b075-222cf26f2344)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Utilisation des Threads et du Threading<ept id="p1">](http://msdn.microsoft.com/library/9b5ec2cd-121b-4d49-b075-222cf26f2344)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Managed Threading Best Practices<ept id="p1">](http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Meilleures pratiques pour le Threading managé<ept id="p1">](http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The lock and SyncLock Keywords</source>
          <target state="translated">Les mots-clés lock et SyncLock</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The Visual Basic <ph id="ph1">`SyncLock`</ph> statement can be used to ensure that a block of code runs to completion without interruption by other threads.</source>
          <target state="translated">Visual Basic <ph id="ph1">`SyncLock`</ph> instruction peut être utilisée pour garantir qu’un bloc de code s’exécute jusqu'à son achèvement sans interruption par d’autres threads.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.</source>
          <target state="translated">Cela s’effectue en obtenant un verrou à exclusion mutuelle pour un objet donné pour la durée du bloc de code.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`SyncLock`</ph> statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.</source>
          <target state="translated">Un <ph id="ph1">`SyncLock`</ph> instruction Obtient un objet comme argument et est suivie d’un bloc de code qui doit être exécutée par un seul thread à la fois.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Exemple :</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The argument provided to the <ph id="ph1">`SyncLock`</ph> keyword must be an object based on a reference type, and is used to define the scope of the lock.</source>
          <target state="translated">L’argument fourni pour le <ph id="ph1">`SyncLock`</ph> mot clé doit être un objet basé sur un type référence et est utilisé pour définir l’étendue du verrou.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In the example above, the lock scope is limited to this function because no references to the object <ph id="ph1">`lockThis`</ph> exist outside the function.</source>
          <target state="translated">Dans l’exemple ci-dessus, la portée de verrouillage est limitée à cette fonction car aucune référence à l’objet <ph id="ph1">`lockThis`</ph> existe en dehors de la fonction.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If such a reference did exist, lock scope would extend to that object.</source>
          <target state="translated">Si une telle référence existait, portée de verrouillage s’étendrait à cet objet.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.</source>
          <target state="translated">En principe, l’objet fourni est utilisé uniquement pour identifier de manière unique la ressource qui est partagée par plusieurs threads, afin d’être une instance de la classe arbitraire.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In practice, however, this object usually represents the resource for which thread synchronization is necessary.</source>
          <target state="translated">Dans la pratique, toutefois, cet objet représente généralement la ressource pour le thread qui la synchronisation est nécessaire.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.</source>
          <target state="translated">Par exemple, si un objet conteneur doit être utilisé par plusieurs threads, puis le conteneur peut être passé pour verrouiller, et le bloc de code synchronisé suivant le verrouillage accéderait au conteneur.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.</source>
          <target state="translated">Tant que les autres threads sont verrouillés sur le même contenir avant d’y accéder, en toute sécurité l’accès à l’objet est synchronisé.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Generally, it is best to avoid locking on a <ph id="ph1">`public`</ph> type, or on object instances beyond the control of your application.</source>
          <target state="translated">En général, il est préférable d’éviter le verrouillage sur un <ph id="ph1">`public`</ph> type, ou sur des instances d’objet du contrôle de votre application.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`lockThis`</ph> can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.</source>
          <target state="translated">Par exemple, <ph id="ph1">`lockThis`</ph> peut être problématique si l’instance est accessible au public, car le code en dehors de votre contrôle risque de verrouiller l’objet.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This could create deadlock situations where two or more threads wait for the release of the same object.</source>
          <target state="translated">Cela pourrait créer une situation de blocage où deux ou plusieurs threads attendent la libération du même objet.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Locking on a public data type, as opposed to an object, can cause problems for the same reason.</source>
          <target state="translated">Le verrouillage sur un type de données public, par opposition à un objet, peut entraîner des problèmes pour la même raison.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Locking on literal strings is especially risky because literal strings are <bpt id="p1">*</bpt>interned<ept id="p1">*</ept> by the common language runtime (CLR).</source>
          <target state="translated">Verrouillage sur des chaînes littérales est particulièrement risqué, car les chaînes littérales sont <bpt id="p1">*</bpt>stagiaire<ept id="p1">*</ept> par le common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.</source>
          <target state="translated">Cela signifie qu’il existe une seule instance d’une chaîne donnée littéral pour l’ensemble du programme, le même objet exact représente le littéral dans tous les domaines d’application, en cours d’exécution sur tous les threads.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.</source>
          <target state="translated">Par conséquent, un verrou placé sur une chaîne avec le même contenu n’importe où dans les verrous de processus d’application toutes les instances de cette chaîne dans l’application.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>As a result, it is best to lock a private or protected member that is not interned.</source>
          <target state="translated">Par conséquent, il est préférable de verrouiller un membre privé ou protégé qui n’est pas stagiaire.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Some classes provide members specifically for locking.</source>
          <target state="translated">Certaines classes fournissent des membres spécifiquement pour le verrouillage.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Array&gt; type, for example, provides &lt;xref:System.Array.SyncRoot%2A&gt;.</source>
          <target state="translated">Le &lt;xref:System.Array&gt;type, par exemple, fournit &lt;xref:System.Array.SyncRoot%2A&gt;.&lt;/xref:System.Array.SyncRoot%2A&gt; &lt;/xref:System.Array&gt;</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Many collection types provide a <ph id="ph1">`SyncRoot`</ph> member as well.</source>
          <target state="translated">De nombreux types de collection fournissent un <ph id="ph1">`SyncRoot`</ph> membre.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For more information about the <ph id="ph1">`SyncLock`</ph> statement, see the following topics:</source>
          <target state="translated">Pour plus d’informations sur la <ph id="ph1">`SyncLock`</ph> instruction, consultez les rubriques suivantes :</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SyncLock Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/synclock-statement.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>SyncLock (instruction)<ept id="p1">](../../../../visual-basic/language-reference/statements/synclock-statement.md)</ept></target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Monitors</source>
          <target state="translated">Analyses</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Like the <ph id="ph1">`SyncLock`</ph> keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.</source>
          <target state="translated">Comme le <ph id="ph1">`SyncLock`</ph> (mot clé), les moniteurs empêchent des blocs de code d’être exécutés simultanément par plusieurs threads.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Threading.Monitor.Enter%2A&gt; method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls &lt;xref:System.Threading.Monitor.Exit%2A&gt;.</source>
          <target state="translated">La &lt;xref:System.Threading.Monitor.Enter%2A&gt;méthode ne permet qu’un seul thread de continuer dans les instructions suivantes ; tous les autres threads sont bloqués jusqu'à ce que le thread d’exécution appelle &lt;xref:System.Threading.Monitor.Exit%2A&gt;.&lt;/xref:System.Threading.Monitor.Exit%2A&gt; &lt;/xref:System.Threading.Monitor.Enter%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This is just like using the <ph id="ph1">`SyncLock`</ph> keyword.</source>
          <target state="translated">Cela équivaut à l’aide de la <ph id="ph1">`SyncLock`</ph> (mot clé).</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Exemple :</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">Cela équivaut à :</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Using the <ph id="ph1">`SyncLock`</ph> keyword is generally preferred over using the &lt;xref:System.Threading.Monitor&gt; class directly, both because <ph id="ph2">`SyncLock`</ph> is more concise, and because <ph id="ph3">`SyncLock`</ph> insures that the underlying monitor is released, even if the protected code throws an exception.</source>
          <target state="translated">À l’aide de la <ph id="ph1">`SyncLock`</ph> mot clé est généralement préférée à l’aide de la &lt;xref:System.Threading.Monitor&gt;classe directement, les deux, car <ph id="ph2">`SyncLock`</ph> est plus concis et parce que <ph id="ph3">`SyncLock`</ph> assure que le moniteur sous-jacent est libéré, même si le code protégé lève une exception.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This is accomplished with the <ph id="ph1">`Finally`</ph> keyword, which executes its associated code block regardless of whether an exception is thrown.</source>
          <target state="translated">Cela est effectué avec le <ph id="ph1">`Finally`</ph> (mot clé), qui exécute son bloc de code associé, qu’une exception est levée.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Synchronization Events and Wait Handles</source>
          <target state="translated">Événements de synchronisation et Handles d’attente</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.</source>
          <target state="translated">À l’aide d’un verrou ou une analyse est utile pour empêcher l’exécution simultanée des blocs de code sensibles aux threads, mais ces constructions ne permettent pas d’un thread de communiquer un événement à un autre.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This requires <bpt id="p1">*</bpt>synchronization events<ept id="p1">*</ept>, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.</source>
          <target state="translated">Cela nécessite <bpt id="p1">*</bpt>les événements de synchronisation<ept id="p1">*</ept>, qui sont des objets qui ont une des deux États, signalé et non signalé, qui peut être utilisé pour activer et d’interrompre des threads.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.</source>
          <target state="translated">Threads peuvent être interrompus en étant obligés d’attendre un événement de synchronisation qui n’est pas signalé et peuvent être activés en modifiant l’état de l’événement signalé.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.</source>
          <target state="translated">Si un thread tente d’attendre un événement qui est déjà signalé, le thread continue de s’exécuter sans délai.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>There are two kinds of synchronization events: &lt;xref:System.Threading.AutoResetEvent&gt;, and &lt;xref:System.Threading.ManualResetEvent&gt;.</source>
          <target state="translated">Il existe deux types d’événements de synchronisation : &lt;xref:System.Threading.AutoResetEvent&gt;et &lt;xref:System.Threading.ManualResetEvent&gt;.&lt;/xref:System.Threading.ManualResetEvent&gt; &lt;/xref:System.Threading.AutoResetEvent&gt;</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>They differ only in that &lt;xref:System.Threading.AutoResetEvent&gt; changes from signaled to unsignaled automatically any time it activates a thread.</source>
          <target state="translated">Ils diffèrent uniquement dans cette &lt;xref:System.Threading.AutoResetEvent&gt;modifications d’état signalé à non signalé automatiquement à chaque fois qu’il active un thread.&lt;/xref:System.Threading.AutoResetEvent&gt;</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Conversely, a &lt;xref:System.Threading.ManualResetEvent&gt; allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its &lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt; method is called.</source>
          <target state="translated">À l’inverse, un &lt;xref:System.Threading.ManualResetEvent&gt;permet à n’importe quel nombre de threads pour être activé que par leur état signalé et revient à un non signalé état lorsque son &lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;méthode est appelée.&lt;/xref:System.Threading.EventWaitHandle.Reset%2A&gt; &lt;/xref:System.Threading.ManualResetEvent&gt;</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Threads can be made to wait on events by calling one of the wait methods, such as &lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;, &lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;, or &lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;.</source>
          <target state="translated">Peuvent obliger les threads à attendre les événements en appelant une de ces méthodes d’attente, tel que &lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;, &lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;, ou &lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;.&lt;/xref:System.Threading.WaitHandle.WaitAll%2A&gt; &lt;/xref:System.Threading.WaitHandle.WaitAny%2A&gt; &lt;/xref:System.Threading.WaitHandle.WaitOne%2A&gt;</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt; causes the thread to wait until a single event becomes signaled, &lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName&gt; blocks a thread until one or more indicated events become signaled, and &lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName&gt; blocks the thread until all of the indicated events become signaled.</source>
          <target state="translated">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;oblige le thread d’attente jusqu'à ce qu’un événement unique soit signalé, &lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName&gt;bloque un thread jusqu'à ce qu’un ou plusieurs événements indiqués soient signalés, et &lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName&gt;bloque le thread jusqu'à ce que tous les événements indiqués soient signalés.&lt;/xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName&gt; &lt;/xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName&gt;&lt;/xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>An event becomes signaled when its &lt;xref:System.Threading.EventWaitHandle.Set%2A&gt; method is called.</source>
          <target state="translated">Un événement est signalé lors de sa &lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;méthode est appelée.&lt;/xref:System.Threading.EventWaitHandle.Set%2A&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>In the following example, a thread is created and started by the <ph id="ph1">`Main`</ph> function.</source>
          <target state="translated">Dans l’exemple suivant, un thread est créé et démarré par le <ph id="ph1">`Main`</ph> (fonction).</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The new thread waits on an event using the &lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt; method.</source>
          <target state="translated">Le nouveau thread attend un événement à l’aide de la &lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;méthode.&lt;/xref:System.Threading.WaitHandle.WaitOne%2A&gt;</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The thread is suspended until the event becomes signaled by the primary thread that is executing the <ph id="ph1">`Main`</ph> function.</source>
          <target state="translated">Le thread est suspendu jusqu'à ce que l’événement soit signalé par le thread principal qui exécute la <ph id="ph1">`Main`</ph> (fonction).</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Once the event becomes signaled, the auxiliary thread returns.</source>
          <target state="translated">Une fois que l’événement soit signalé, le thread auxiliaire est retourné.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In this case, because the event is only used for one thread activation, either the &lt;xref:System.Threading.AutoResetEvent&gt; or &lt;xref:System.Threading.ManualResetEvent&gt; classes could be used.</source>
          <target state="translated">Dans ce cas, étant donné que l’événement est uniquement utilisé pour l’activation d’un thread, soit le &lt;xref:System.Threading.AutoResetEvent&gt;ou &lt;xref:System.Threading.ManualResetEvent&gt;classes peuvent être utilisés.&lt;/xref:System.Threading.ManualResetEvent&gt; &lt;/xref:System.Threading.AutoResetEvent&gt;</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Mutex Object</source>
          <target state="translated">Objet mutex</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>mutex<ept id="p1">*</ept> is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.</source>
          <target state="translated">A <bpt id="p1">*</bpt>mutex<ept id="p1">*</ept> est similaire à un moniteur ; elle empêche l’exécution simultanée d’un bloc de code par plusieurs threads simultanément.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In fact, the name "mutex" is a shortened form of the term "mutually exclusive."</source>
          <target state="translated">En fait, le nom « mutex » est une forme raccourcie du terme « mutuellement exclusif ».</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Unlike monitors, however, a mutex can be used to synchronize threads across processes.</source>
          <target state="translated">Toutefois, contrairement aux analyses, un mutex peut être utilisé pour synchroniser des threads de processus.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A mutex is represented by the &lt;xref:System.Threading.Mutex&gt; class.</source>
          <target state="translated">Un mutex est représenté par la &lt;xref:System.Threading.Mutex&gt;classe.&lt;/xref:System.Threading.Mutex&gt;</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>When used for inter-process synchronization, a mutex is called a <bpt id="p1">*</bpt>named mutex<ept id="p1">*</ept> because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.</source>
          <target state="translated">Synchronisation inter-processus, un mutex est appelé un <bpt id="p1">*</bpt>mutex nommé<ept id="p1">*</ept> , car il doit être utilisé dans une autre application, et par conséquent, il ne peut pas être partagé au moyen d’une variable globale ou statique.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>It must be given a name so that both applications can access the same mutex object.</source>
          <target state="translated">Il doit disposer d’un nom pour que les deux applications puissent accéder au même objet mutex.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Although a mutex can be used for intra-process thread synchronization, using &lt;xref:System.Threading.Monitor&gt; is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.</source>
          <target state="translated">Bien qu’un mutex peut être utilisé pour la synchronisation de threads intra-processus, à l’aide &lt;xref:System.Threading.Monitor&gt;est généralement recommandée, car les moniteurs ont été conçus spécifiquement pour le .NET Framework et par conséquent utilisent les ressources plus efficacement.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In contrast, the &lt;xref:System.Threading.Mutex&gt; class is a wrapper to a Win32 construct.</source>
          <target state="translated">En revanche, la &lt;xref:System.Threading.Mutex&gt;classe est un wrapper d’une construction Win32.&lt;/xref:System.Threading.Mutex&gt;</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the &lt;xref:System.Threading.Monitor&gt; class.</source>
          <target state="translated">Il est plus puissant qu’un moniteur, un mutex nécessite des transitions d’interopérabilité qui sont plus gourmandes que celles requises par la &lt;xref:System.Threading.Monitor&gt;classe.&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For an example of using a mutex, see <bpt id="p1">[</bpt>Mutexes<ept id="p1">](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2)</ept>.</source>
          <target state="translated">Pour obtenir un exemple de l’utilisation d’un mutex, consultez <bpt id="p1">[</bpt>les mutex<ept id="p1">](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Interlocked Class</source>
          <target state="translated">Interlocked (classe)</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You can use the methods of the &lt;xref:System.Threading.Interlocked&gt; class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.</source>
          <target state="translated">Vous pouvez utiliser les méthodes de la &lt;xref:System.Threading.Interlocked&gt;classe pour éviter les problèmes qui peuvent se produire lorsque plusieurs threads tentent simultanément de mettre à jour ou de comparer une même valeur.&lt;/xref:System.Threading.Interlocked&gt;</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.</source>
          <target state="translated">Les méthodes de cette classe vous permettent d’en toute sécurité incrément décrémentent, exchange et comparer des valeurs à partir de n’importe quel thread.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>ReaderWriter Locks</source>
          <target state="translated">Verrous ReaderWriter</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.</source>
          <target state="translated">Dans certains cas, vous souhaiterez verrouiller une ressource uniquement lorsque les données sont écrites et autoriser plusieurs clients à lire simultanément des données ne sont pas actualisées.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Threading.ReaderWriterLock&gt; class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.</source>
          <target state="translated">La &lt;xref:System.Threading.ReaderWriterLock&gt;classe applique un accès exclusif à une ressource lors de la modification par un thread, mais elle permet un accès non exclusif lors de la lecture de la ressource.&lt;/xref:System.Threading.ReaderWriterLock&gt;</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.</source>
          <target state="translated">Les verrous ReaderWriter constituent une alternative utile aux verrous exclusifs qui provoquent des autres threads à attendre, même lorsque ces threads n’avez pas besoin de mettre à jour les données.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Deadlocks</source>
          <target state="translated">Blocages</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a <ph id="ph1">`deadlock`</ph>, where multiple threads are waiting for each other and the application comes to a halt.</source>
          <target state="translated">Synchronisation de threads est très utile dans les applications multithread, mais le risque de création d’un <ph id="ph1">`deadlock`</ph>, où plusieurs threads s’attendent mutuellement et l’application s’arrête.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.</source>
          <target state="translated">Un blocage est analogue à une situation dans laquelle automobiles bloquées à un arrêt de quatre processeurs, et chaque personne est en attente pour l’autre passe.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Avoiding deadlocks is important; the key is careful planning.</source>
          <target state="translated">Éviter les verrous mortels est important. la clé est une planification soigneuse.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>You can often predict deadlock situations by diagramming multithreaded applications before you start coding.</source>
          <target state="translated">Vous pouvez souvent prévoir les situations de blocage par la représentation graphique des applications multithread, avant de commencer le codage.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Thread&gt;&lt;/xref:System.Threading.Thread&gt;</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;&lt;/xref:System.Threading.WaitHandle.WaitOne%2A&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;&lt;/xref:System.Threading.WaitHandle.WaitAny%2A&gt;</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;&lt;/xref:System.Threading.WaitHandle.WaitAll%2A&gt;</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.Join%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Join%2A&gt;&lt;/xref:System.Threading.Thread.Join%2A&gt;</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.Start%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Start%2A&gt;&lt;/xref:System.Threading.Thread.Start%2A&gt;</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Thread.Sleep%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Thread.Sleep%2A&gt;&lt;/xref:System.Threading.Thread.Sleep%2A&gt;</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Monitor&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Monitor&gt;&lt;/xref:System.Threading.Monitor&gt;</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Mutex&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Mutex&gt;&lt;/xref:System.Threading.Mutex&gt;</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.AutoResetEvent&gt;</source>
          <target state="translated">&lt;xref:System.Threading.AutoResetEvent&gt;&lt;/xref:System.Threading.AutoResetEvent&gt;</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.ManualResetEvent&gt;</source>
          <target state="translated">&lt;xref:System.Threading.ManualResetEvent&gt;&lt;/xref:System.Threading.ManualResetEvent&gt;</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.Interlocked&gt;</source>
          <target state="translated">&lt;xref:System.Threading.Interlocked&gt;&lt;/xref:System.Threading.Interlocked&gt;</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.WaitHandle&gt;</source>
          <target state="translated">&lt;xref:System.Threading.WaitHandle&gt;&lt;/xref:System.Threading.WaitHandle&gt;</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.EventWaitHandle&gt;</source>
          <target state="translated">&lt;xref:System.Threading.EventWaitHandle&gt;&lt;/xref:System.Threading.EventWaitHandle&gt;</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading&gt;</source>
          <target state="translated">&lt;xref:System.Threading&gt;&lt;/xref:System.Threading&gt;</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</source>
          <target state="translated">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;&lt;/xref:System.Threading.EventWaitHandle.Set%2A&gt;</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Multithreaded Applications (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Applications multithread (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>SyncLock Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/synclock-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>SyncLock, instruction<ept id="p1">](../../../../visual-basic/language-reference/statements/synclock-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Mutexes<ept id="p1">](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Mutex<ept id="p1">](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Interlocked Operations<ept id="p1">](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Opérations verrouillées<ept id="p1">](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>AutoResetEvent<ept id="p1">](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>AutoResetEvent<ept id="p1">](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Synchronizing Data for Multithreading<ept id="p1">](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Synchronisation des données pour le Multithreading<ept id="p1">](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>