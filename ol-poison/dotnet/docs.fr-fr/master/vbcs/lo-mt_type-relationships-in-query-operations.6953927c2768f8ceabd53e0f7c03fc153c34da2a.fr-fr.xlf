<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a966b69feca7a7021cafbccb7971913ea781c479</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\type-relationships-in-query-operations.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67448ac455263820f6bf6c4aa5dedfa148279d20</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f11474c2b7d5eb9902484fd122f08ef7743f0509</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_type-relationships-in-query-operations.6953927c2768f8ceabd53e0f7c03fc153c34da2a.fr-fr is different with handoff file name: type-relationships-in-query-operations.6953927c2768f8ceabd53e0f7c03fc153c34da2a.fr-fr.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Type Relationships in Query Operations (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Relations des types dans des opérations de requête (Visual Basic) | Documents Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Type Relationships in Query Operations (Visual Basic)</source>
          <target state="translated">Relations des types dans des opérations de requête (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Variables used in <ph id="ph1">[!INCLUDE[vbteclinqext](../../../../csharp/getting-started/includes/vbteclinqext_md.md)]</ph> query operations are strongly typed and must be compatible with each other.</source>
          <target state="translated">Variables utilisées dans <ph id="ph1">[!INCLUDE[vbteclinqext](../../../../csharp/getting-started/includes/vbteclinqext_md.md)]</ph> requête opérations sont fortement typées et doivent être compatibles entre eux.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Strong typing is used in the data source, in the query itself, and in the query execution.</source>
          <target state="translated">Un typage fort est utilisé dans la source de données, dans la requête elle-même et dans l’exécution des requêtes.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The following illustration identifies terms used to describe a <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> query.</source>
          <target state="translated">L’illustration suivante identifie les termes utilisés pour décrire un <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> requête.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For more information about the parts of a query, see <bpt id="p1">[</bpt>Basic Query Operations (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les parties d’une requête, consultez <bpt id="p1">[</bpt>base des opérations de requête (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md)</ept>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Pseudocode query with elements highlighted.<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/media/sjltyperels.png "SJLtypeRels")</ept></source>
          <target state="translated"><bpt id="p1">![</bpt>Requête en pseudocode avec éléments en surbrillance.<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/media/sjltyperels.png "SJLtypeRels")</ept></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Parts of a LINQ query</source>
          <target state="translated">Parties d’une requête LINQ</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The type of the range variable in the query must be compatible with the type of the elements in the data source.</source>
          <target state="translated">Le type de la variable de portée dans la requête doit être compatible avec le type des éléments dans la source de données.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The type of the query variable must be compatible with the sequence element defined in the <ph id="ph1">`Select`</ph> clause.</source>
          <target state="translated">Le type de la variable de requête doit être compatible avec l’élément de séquence défini dans la <ph id="ph1">`Select`</ph> clause.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Finally, the type of the sequence elements also must be compatible with the type of the loop control variable that is used in the <ph id="ph1">`For Each`</ph> statement that executes the query.</source>
          <target state="translated">Enfin, le type d’éléments de la séquence également doit être compatible avec le type de la variable de contrôle de boucle est utilisée dans la <ph id="ph1">`For Each`</ph> instruction qui exécute la requête.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This strong typing facilitates identification of type errors at compile time.</source>
          <target state="translated">Ce typage fort facilite l’identification des erreurs de type au moment de la compilation.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> makes strong typing convenient by implementing local type inference, also known as <bpt id="p1">*</bpt>implicit typing<ept id="p1">*</ept>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph>rend le typage plus pratique en implémentant l’inférence de type local, également appelé <bpt id="p1">*</bpt>typage implicite<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>That feature is used in the previous example, and you will see it used throughout the <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> samples and documentation.</source>
          <target state="translated">Fonctionnalité est utilisée dans l’exemple précédent et vous verrez qu’elle est utilisée dans toute la <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> documentation et exemples.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In Visual Basic, local type inference is accomplished simply by using a <ph id="ph1">`Dim`</ph> statement without an <ph id="ph2">`As`</ph> clause.</source>
          <target state="translated">Dans Visual Basic, l’inférence de type local s’effectue en utilisant simplement un <ph id="ph1">`Dim`</ph> instruction sans un <ph id="ph2">`As`</ph> clause.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`city`</ph> is strongly typed as a string.</source>
          <target state="translated">Dans l’exemple suivant, <ph id="ph1">`city`</ph> est fortement typée en tant que chaîne.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels#1<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels n °&amp;1;<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Local type inference works only when <ph id="ph1">`Option Infer`</ph> is set to <ph id="ph2">`On`</ph>.</source>
          <target state="translated">Inférence de type local fonctionne uniquement lorsque <ph id="ph1">`Option Infer`</ph> est défini sur <ph id="ph2">`On`</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Option Infer Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/option-infer-statement.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Option Infer, instruction<ept id="p1">](../../../../visual-basic/language-reference/statements/option-infer-statement.md)</ept>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>However, even if you use local type inference in a query, the same type relationships are present among the variables in the data source, the query variable, and the query execution loop.</source>
          <target state="translated">Toutefois, même si vous utilisez l’inférence de type local dans une requête, les mêmes relations de type sont présentes parmi les variables dans la source de données, la variable de requête et la boucle d’exécution de requête.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>It is useful to have a basic understanding of these type relationships when you are writing <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> queries, or working with the samples and code examples in the documentation.</source>
          <target state="translated">Il est utile d’avoir une connaissance élémentaire de ces relations de type lorsque vous écrivez <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> requêtes ou pour travailler avec les exemples et exemples de code dans la documentation.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You may need to specify an explicit type for a range variable that does not match the type returned from the data source.</source>
          <target state="translated">Vous devrez peut-être spécifier un type explicite pour une variable de portée qui ne correspond pas au type retourné de la source de données.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can specify the type of the range variable by using an <ph id="ph1">`As`</ph> clause.</source>
          <target state="translated">Vous pouvez spécifier le type de la variable de plage en utilisant une <ph id="ph1">`As`</ph> clause.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>However, this results in an error if the conversion is a <bpt id="p1">[</bpt>narrowing conversion<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept> and <ph id="ph1">`Option Strict`</ph> is set to <ph id="ph2">`On`</ph>.</source>
          <target state="translated">Toutefois, cela entraîne une erreur si la conversion est un <bpt id="p1">[</bpt>conversion restrictive<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept> et <ph id="ph1">`Option Strict`</ph> est défini sur <ph id="ph2">`On`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Therefore, we recommend that you perform the conversion on the values retrieved from the data source.</source>
          <target state="translated">Par conséquent, nous vous recommandons d’effectuer la conversion sur les valeurs récupérées de la source de données.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You can convert the values from the data source to the explicit range variable type by using the &lt;xref:System.Linq.Enumerable.Cast%2A&gt; method.</source>
          <target state="translated">Vous pouvez convertir les valeurs de la source de données pour le type de variable de portée explicite à l’aide de la &lt;xref:System.Linq.Enumerable.Cast%2A&gt;méthode.&lt;/xref:System.Linq.Enumerable.Cast%2A&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can also cast the values selected in the <ph id="ph1">`Select`</ph> clause to an explicit type that is different from the type of the range variable.</source>
          <target state="translated">Vous pouvez également convertir les valeurs sélectionnées dans la <ph id="ph1">`Select`</ph> clause à un type explicite qui est différent du type de la variable de portée.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>These points are illustrated in the following code.</source>
          <target state="translated">Ces points sont illustrés dans le code suivant.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels#4<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels n °&amp;4;<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Queries That Return Entire Elements of the Source Data</source>
          <target state="translated">Requêtes qui retournent des éléments entiers de la Source de données</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The following example shows a <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> query operation that returns a sequence of elements selected from the source data.</source>
          <target state="translated">L’exemple suivant illustre une <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> opération qui retourne une séquence d’éléments sélectionnés à partir de la source de données de requête.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The source, <ph id="ph1">`names`</ph>, contains an array of strings, and the query output is a sequence containing strings that start with the letter M.</source>
          <target state="translated">La source, <ph id="ph1">`names`</ph>, contient un tableau de chaînes, et le résultat de la requête est une séquence contenant des chaînes qui commencent par la lettre M.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels#2<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels n °&amp;2;<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This is equivalent to the following code, but is much shorter and easier to write.</source>
          <target state="translated">Cela équivaut au code suivant, mais il est beaucoup plus court et plus facile à écrire.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Reliance on local type inference in queries is the preferred style in Visual Basic.</source>
          <target state="translated">Dépendance par rapport à l’inférence de type local dans les requêtes est le style par défaut dans Visual Basic.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels#3<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbLINQTypeRels n °&amp;3;<ept id="p2">](../../../../visual-basic/programming-guide/concepts/linq/codesnippet/VisualBasic/type-relationships-in-query-operations_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following relationships exist in both of the previous code examples, whether the types are determined implicitly or explicitly.</source>
          <target state="translated">Les relations suivantes existent dans les deux exemples de code précédents, si les types sont déterminés implicitement ou explicitement.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The type of the elements in the data source, <ph id="ph1">`names`</ph>, is the type of the range variable, <ph id="ph2">`name`</ph>, in the query.</source>
          <target state="translated">Le type des éléments dans la source de données <ph id="ph1">`names`</ph>, est le type de la variable de plage, <ph id="ph2">`name`</ph>, dans la requête.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The type of the object that is selected, <ph id="ph1">`name`</ph>, determines the type of the query variable, <ph id="ph2">`mNames`</ph>.</source>
          <target state="translated">Le type de l’objet sélectionné, <ph id="ph1">`name`</ph>, détermine le type de la variable de requête, <ph id="ph2">`mNames`</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Here <ph id="ph1">`name`</ph> is a string, so the query variable is IEnumerable(Of String) in Visual Basic.</source>
          <target state="translated">Ici <ph id="ph1">`name`</ph> est une chaîne, donc la variable de requête est IEnumerable (Of String) en Visual Basic.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The query defined in <ph id="ph1">`mNames`</ph> is executed in the <ph id="ph2">`For Each`</ph> loop.</source>
          <target state="translated">La requête définie dans <ph id="ph1">`mNames`</ph> est exécutée dans le <ph id="ph2">`For Each`</ph> boucle.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The loop iterates over the result of executing the query.</source>
          <target state="translated">La boucle parcourt le résultat de l’exécution de la requête.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`mNames`</ph>, when it is executed, will return a sequence of strings, the loop iteration variable, <ph id="ph2">`nm`</ph>, also is a string.</source>
          <target state="translated">Étant donné que <ph id="ph1">`mNames`</ph>, lorsqu’elle est exécutée, retourne une séquence de chaînes, la variable d’itération de boucle, <ph id="ph2">`nm`</ph>, est une chaîne.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Queries That Return One Field from Selected Elements</source>
          <target state="translated">Requêtes qui retournent un champ d’éléments sélectionnés</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The following example shows a <ph id="ph1">[!INCLUDE[vbtecdlinq](../../../../csharp/includes/vbtecdlinq_md.md)]</ph> query operation that returns a sequence containing only one part of each element selected from the data source.</source>
          <target state="translated">L’exemple suivant illustre une <ph id="ph1">[!INCLUDE[vbtecdlinq](../../../../csharp/includes/vbtecdlinq_md.md)]</ph> opération qui retourne une séquence qui contient uniquement une partie de chaque élément sélectionné à partir de la source de données de requête.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The query takes a collection of <ph id="ph1">`Customer`</ph> objects as its data source and projects only the <ph id="ph2">`Name`</ph> property in the result.</source>
          <target state="translated">La requête prend une collection de <ph id="ph1">`Customer`</ph> objets comme source de données et projette uniquement la <ph id="ph2">`Name`</ph> propriété dans le résultat.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Because the customer name is a string, the query produces a sequence of strings as output.</source>
          <target state="translated">Étant donné que le nom du client est une chaîne, la requête produit une séquence de chaînes comme sortie.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>0<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>0<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The relationships between variables are like those in the simpler example.</source>
          <target state="translated">Les relations entre les variables sont semblables à celles de l’exemple simple.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The type of the elements in the data source, <ph id="ph1">`customers`</ph>, is the type of the range variable, <ph id="ph2">`cust`</ph>, in the query.</source>
          <target state="translated">Le type des éléments dans la source de données <ph id="ph1">`customers`</ph>, est le type de la variable de plage, <ph id="ph2">`cust`</ph>, dans la requête.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In this example, that type is <ph id="ph1">`Customer`</ph>.</source>
          <target state="translated">Dans cet exemple, qui est de type <ph id="ph1">`Customer`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Select`</ph> statement returns the <ph id="ph2">`Name`</ph> property of each <ph id="ph3">`Customer`</ph> object instead of the whole object.</source>
          <target state="translated">Le <ph id="ph1">`Select`</ph> instruction retourne le <ph id="ph2">`Name`</ph> propriété de chaque <ph id="ph3">`Customer`</ph> objet au lieu de l’objet entier.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`Name`</ph> is a string, the query variable, <ph id="ph2">`custNames`</ph>, will again be IEnumerable(Of String), not of <ph id="ph3">`Customer`</ph>.</source>
          <target state="translated">Étant donné que <ph id="ph1">`Name`</ph> est une chaîne, la variable de requête, <ph id="ph2">`custNames`</ph>, seront encore IEnumerable (Of String), pas de <ph id="ph3">`Customer`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`custNames`</ph> represents a sequence of strings, the <ph id="ph2">`For Each`</ph> loop's iteration variable, <ph id="ph3">`custName`</ph>, must be a string.</source>
          <target state="translated">Étant donné que <ph id="ph1">`custNames`</ph> représente une séquence de chaînes, la <ph id="ph2">`For Each`</ph> variable d’itération de la boucle, <ph id="ph3">`custName`</ph>, doit être une chaîne.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Without local type inference, the previous example would be more cumbersome to write and to understand, as the following example shows.</source>
          <target state="translated">Sans inférence de type local, l’exemple précédent serait plus fastidieux à écrire et à comprendre, comme le montre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>1<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>1<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Queries That Require Anonymous Types</source>
          <target state="translated">Requêtes qui requièrent des Types anonymes</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following example shows a more complex situation.</source>
          <target state="translated">L’exemple suivant illustre une situation plus complexe.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In the previous example, it was inconvenient to specify types for all the variables explicitly.</source>
          <target state="translated">Dans l’exemple précédent, il était fastidieux de spécifier explicitement des types pour toutes les variables.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In this example, it is impossible.</source>
          <target state="translated">Dans cet exemple, il est impossible.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Instead of selecting entire <ph id="ph1">`Customer`</ph> elements from the data source, or a single field from each element, the <ph id="ph2">`Select`</ph> clause in this query returns two properties of the original <ph id="ph3">`Customer`</ph> object: <ph id="ph4">`Name`</ph> and <ph id="ph5">`City`</ph>.</source>
          <target state="translated">Au lieu de sélectionner toute <ph id="ph1">`Customer`</ph> éléments à partir de la source de données ou un champ unique de chaque élément, le <ph id="ph2">`Select`</ph> clause dans cette requête retourne deux propriétés de l’original <ph id="ph3">`Customer`</ph> objet : <ph id="ph4">`Name`</ph> et <ph id="ph5">`City`</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In response to the <ph id="ph1">`Select`</ph> clause, the compiler defines an anonymous type that contains those two properties.</source>
          <target state="translated">En réponse à la <ph id="ph1">`Select`</ph> clause, le compilateur définit un type anonyme qui contient ces deux propriétés.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The result of executing <ph id="ph1">`nameCityQuery`</ph> in the <ph id="ph2">`For Each`</ph> loop is a collection of instances of the new anonymous type.</source>
          <target state="translated">Le résultat de l’exécution <ph id="ph1">`nameCityQuery`</ph> dans les <ph id="ph2">`For Each`</ph> boucle est une collection d’instances du nouveau type anonyme.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Because the anonymous type has no usable name, you cannot specify the type of <ph id="ph1">`nameCityQuery`</ph> or <ph id="ph2">`custInfo`</ph> explicitly.</source>
          <target state="translated">Étant donné que le type anonyme n’a pas de nom utilisable, vous ne pouvez pas spécifier le type de <ph id="ph1">`nameCityQuery`</ph> ou <ph id="ph2">`custInfo`</ph> explicitement.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>That is, with an anonymous type, you have no type name to use in place of <ph id="ph1">`String`</ph> in <ph id="ph2">`IEnumerable(Of String)`</ph>.</source>
          <target state="translated">Autrement dit, avec un type anonyme, vous n’avez aucun nom de type à utiliser à la place de <ph id="ph1">`String`</ph> dans <ph id="ph2">`IEnumerable(Of String)`</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Anonymous Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>les Types anonymes<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>2<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>2<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Although it is not possible to specify types for all the variables in the previous example, the relationships remain the same.</source>
          <target state="translated">Bien qu’il n’est pas possible de spécifier des types pour toutes les variables dans l’exemple précédent, les relations restent les mêmes.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The type of the elements in the data source is again the type of the range variable in the query.</source>
          <target state="translated">Le type des éléments dans la source de données est à nouveau le type de la variable de portée dans la requête.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In this example, <ph id="ph1">`cust`</ph> is an instance of <ph id="ph2">`Customer`</ph>.</source>
          <target state="translated">Dans cet exemple, <ph id="ph1">`cust`</ph> est une instance de <ph id="ph2">`Customer`</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`Select`</ph> statement produces an anonymous type, the query variable, <ph id="ph2">`nameCityQuery`</ph>, must be implicitly typed as an anonymous type.</source>
          <target state="translated">Étant donné que la <ph id="ph1">`Select`</ph> instruction produit un type anonyme, la variable de requête, <ph id="ph2">`nameCityQuery`</ph>, doit être implicitement typée comme type anonyme.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>An anonymous type has no usable name, and therefore cannot be specified explicitly.</source>
          <target state="translated">Un type anonyme n’a aucun nom utilisable et ne peut donc pas être spécifié explicitement.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The type of the iteration variable in the <ph id="ph1">`For Each`</ph> loop is the anonymous type created in step 2.</source>
          <target state="translated">Le type de la variable d’itération dans le <ph id="ph1">`For Each`</ph> boucle est le type anonyme créé à l’étape 2.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Because the type has no usable name, the type of the loop iteration variable must be determined implicitly.</source>
          <target state="translated">Étant donné que le type ne possède aucun nom utilisable, le type de la variable d’itération de boucle doit être déterminé implicitement.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Voir aussi</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Getting Started with LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/getting-started-with-linq.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Mise en route de LINQ en Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/getting-started-with-linq.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Anonymous Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Types anonymes<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Local Type Inference<ept id="p1">](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Inférence de Type local<ept id="p1">](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Introduction to LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Introduction à LINQ en Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>LINQ<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>LINQ<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Queries<ept id="p1">](../../../../visual-basic/language-reference/queries/queries.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Requêtes<ept id="p1">](../../../../visual-basic/language-reference/queries/queries.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>