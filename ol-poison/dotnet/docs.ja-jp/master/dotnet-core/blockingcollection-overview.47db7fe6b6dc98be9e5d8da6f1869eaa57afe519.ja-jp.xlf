<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">64a01b5e21e012dfaae07a02f5fb27932be9cf98</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\collections\threadsafe\blockingcollection-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ee211c059c42480350d31c938f52419524b3332b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">251ba741ba26217dd42939dd73f9e65137e27a21</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file blockingcollection-overview.47db7fe6b6dc98be9e5d8da6f1869eaa57afe519.ja-jp.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="translated">BlockingCollection の概要</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="translated">BlockingCollection の概要</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>BlockingCollection Overview</source>
          <target state="translated">BlockingCollection の概要</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> is a thread-safe collection class that provides the following features:</source>
          <target state="translated"><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> は、次の機能を提供するスレッド セーフなコレクション クラスです。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>An implementation of the Producer-Consumer pattern.</source>
          <target state="translated">Producer-Consumer パターンの実装。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Thread-safe addition and removal of items from a collection.</source>
          <target state="translated">コレクションの項目のスレッド セーフな追加と削除。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Optional maximum capacity.</source>
          <target state="translated">最大容量 (オプション)。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Insertion and removal operations that block when collection is empty or full.</source>
          <target state="translated">コレクションが空またはいっぱいになったときにブロックする挿入操作と削除操作。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Insertion and removal "try" operations that do not block or that block up to a specified period of time.</source>
          <target state="translated">ブロックせずに実行されるか、指定された時間が経過するまでブロックする、挿入および削除の "試行" 操作。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Encapsulates any collection type that implements <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept> を実装する任意のコレクション型のカプセル化。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Cancellation with cancellation tokens.</source>
          <target state="translated">キャンセル トークンを使用したキャンセル。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Two kinds of enumeration with <ph id="ph1">`foreach`</ph>:</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> を使用した 2 種類の列挙。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Read-only enumeration.</source>
          <target state="translated">読み取り専用の列挙。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Enumeration that removes items as they are enumerated.</source>
          <target state="translated">列挙された項目を削除する列挙。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Bounding and Blocking Support</source>
          <target state="translated">境界とブロッキングのサポート</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> supports bounding and blocking.</source>
          <target state="translated"><bpt id="p1">[</bpt>BlockingCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> は境界とブロッキングをサポートします。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Bounding means you can set the maximum capacity of the collection.</source>
          <target state="translated">境界は、コレクションの最大容量を設定できることを意味します。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.</source>
          <target state="translated">境界を使用すると、メモリ内のコレクションの最大サイズを制御し、producer スレッドが consumer スレッドよりも先に進行しすぎるのを防ぐことができます。これは、特定のシナリオで重要になります。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.</source>
          <target state="translated">コレクションには、複数のスレッドやタスクが同時に項目を追加できます。コレクションが指定された最大容量に達すると、producer スレッドは項目が削除されるまでブロックします。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.</source>
          <target state="translated">複数の cosumer が同時に項目を削除できます。コレクションが空になった場合、consumer スレッドは、producer が項目を追加するまでブロックします。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>A producing thread can call <ph id="ph1">`CompleteAdding`</ph> to indicate that no more items will be added.</source>
          <target state="translated">producer スレッドでは、それ以上項目が追加されないことを示すために、<ph id="ph1">`CompleteAdding`</ph> を呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Consumers monitor the <ph id="ph1">`IsCompleted`</ph> property to know when the collection is empty and no more items will be added.</source>
          <target state="translated">consumer では、<ph id="ph1">`IsCompleted`</ph> プロパティを監視して、コレクションが空になったときや、それ以上の項目は追加されないことになったときを把握できます。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The following example shows a simple <ph id="ph1">`BlockingCollection`</ph> with a bounded capacity of 100.</source>
          <target state="translated">次の例は、容量の上限が 100 に設定された単純な <ph id="ph1">`BlockingCollection`</ph> を示しています。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A producer task adds items to the collection as long as some external condition is true, and then calls <ph id="ph1">`CompleteAdding`</ph>.</source>
          <target state="translated">いくつかの外部条件が true である間、producer タスクはコレクションに項目を追加し、<ph id="ph1">`CompleteAdding`</ph> を呼び出します。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The consumer task takes items until the <ph id="ph1">`IsCompleted`</ph> property is true.</source>
          <target state="translated">consumer タスクは、<ph id="ph1">`IsCompleted`</ph> プロパティが true になるまで項目を取得します。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For a complete example, see <bpt id="p1">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</source>
          <target state="translated">コード例全体については、「<bpt id="p1">[</bpt>方法: BlockingCollection の項目を個別に追加および取得する<ept id="p1">](how-to-add-and-take-items.md)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Timed Blocking Operations</source>
          <target state="translated">時間制限付きのブロッキング操作</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In timed blocking <ph id="ph1">`TryAdd`</ph> and <ph id="ph2">`TryTake`</ph> operations on bounded collections, the method tries to add or take an item.</source>
          <target state="translated">境界のあるコレクションにおける時間制限付きの <ph id="ph1">`TryAdd`</ph> 操作および <ph id="ph2">`TryTake`</ph> 操作では、メソッドは項目を追加または取得しようと試みます。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If an item is available it is placed into the variable that was passed in by reference, and the method returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">項目を使用できる場合、その項目は参照渡しで渡された変数に格納され、メソッドは <ph id="ph1">`true`</ph> を返します。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If no item is retrieved after a specified time-out period the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">指定されたタイムアウト期間を経過しても項目が取得されない場合、メソッドは <ph id="ph1">`false`</ph> を返します。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The thread is then free to do some other useful work before trying again to access the collection.</source>
          <target state="translated">その後、再びコレクションへのアクセスを試みる前に、他の必要な処理をスレッドで自由に実行できます。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For an example of timed blocking access, see the second example in <bpt id="p1">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id="p1">](how-to-add-and-take-items.md)</ept>.</source>
          <target state="translated">時間制限付きのブロッキング アクセスの例については、「<bpt id="p1">[</bpt>方法: BlockingCollection の項目を個別に追加および取得する<ept id="p1">](how-to-add-and-take-items.md)</ept>」の 2 番目の例を参照してください。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Cancelling Add and Take Operations</source>
          <target state="translated">追加操作と取得操作の取り消し</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Add and Take operations are typically performed in a loop.</source>
          <target state="translated">追加操作と取得操作は、通常、ループ内で実行されます。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can cancel a loop by passing in a <ph id="ph1">`CancellationToken`</ph> to the <ph id="ph2">`TryAdd`</ph> or <ph id="ph3">`TryTake`</ph> method, and then checking the value of the token's <ph id="ph4">`IsCancellationRequested`</ph> property on each iteration.</source>
          <target state="translated"><ph id="ph2">`TryAdd`</ph> メソッドまたは <ph id="ph3">`TryTake`</ph> メソッドに <ph id="ph1">`CancellationToken`</ph> を渡し、各イテレーションでトークンの <ph id="ph4">`IsCancellationRequested`</ph> プロパティの値を確認するようにすると、ループを取り消すことができます。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If the value is <ph id="ph1">`true`</ph>, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.</source>
          <target state="translated">値が <ph id="ph1">`true`</ph> である場合は、キャンセル要求に応答するかどうかを決定できます。応答するには、リソースをクリーンアップし、ループを終了します。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following example shows an overload of <ph id="ph1">`TryAdd`</ph> that takes a cancellation token, and the code that uses it:</source>
          <target state="translated">次の例は、キャンセル トークンを受け取る <ph id="ph1">`TryAdd`</ph> のオーバーロードと、それを使用するコードを示しています。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Specifying the Collection Type</source>
          <target state="translated">コレクションの型の指定</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When you create a <ph id="ph1">`BlockingCollection&lt;T&gt;;`</ph>, you can specify not only the bounded capacity but also the type of collection to use.</source>
          <target state="translated"><ph id="ph1">`BlockingCollection&lt;T&gt;;`</ph> の作成時には、容量の上限だけでなく、使用するコレクションの型も指定できます。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, you could specify a <bpt id="p1">[</bpt>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> for first in-first out (FIFO) behavior, or a <bpt id="p2">[</bpt>ConcurrentStack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> for last in-first out (LIFO) behavior.</source>
          <target state="translated">たとえば、先入れ先出し法 (FIFO) の動作には <bpt id="p1">[</bpt>ConcurrentQueue<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> を指定し、後入れ先出し法 (LIFO) の動作には <bpt id="p2">[</bpt>ConcurrentStack<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p2">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> を指定できます。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can use any collection class that implements the <bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept> interface.</source>
          <target state="translated"><bpt id="p1">[</bpt>IProducerConsumerCollection<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept> インターフェイスを実装する任意のコレクション クラスを使用できます。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The default collection type for <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> is <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph>.</source>
          <target state="translated"><ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> の既定のコレクション型は <ph id="ph2">`ConcurrentQueue&lt;T&gt;`</ph> です。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The following code example shows how to create a <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> of strings that has a capacity of 1000 and uses a <bpt id="p1">[</bpt>ConcurrentBag<ph id="ph2">&amp;lt;</ph>T<ph id="ph3">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept>:</source>
          <target state="translated">次のコード例は、容量が 1000 で、<bpt id="p1">[</bpt>ConcurrentBag<ph id="ph2">&amp;lt;</ph>T<ph id="ph3">&amp;gt;</ph><ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept> を使用する文字列の <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> を作成する方法を示しています。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>IEnumerable Support</source>
          <target state="translated">IEnumerable のサポート</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> provides a <ph id="ph2">`GetConsumingEnumerable`</ph> method that enables consumers to use a <ph id="ph3">`foreach`</ph> statement to remove items until the collection is completed, which means it is empty and no more items will be added.</source>
          <target state="translated"><ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> は <ph id="ph2">`GetConsumingEnumerable`</ph> メソッドを提供します。これにより、コンシューマーは <ph id="ph3">`foreach`</ph> ステートメントを使用して、コレクションが完成するまで (コレクションが空になり、それ以上項目が追加されなくなるまで) 項目を削除できます。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Use ForEach to Remove Items in a BlockingCollection<ept id="p1">](how-to-use-foreach-to-remove.md)</ept>.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>方法: ForEach を使用して BlockingCollection 内の項目を削除する<ept id="p1">](how-to-use-foreach-to-remove.md)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Using Many BlockingCollections As One</source>
          <target state="translated">多数の BlockingCollection を 1 つとして使用する</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> and use the static methods such as <ph id="ph2">`TakeFromAny`</ph> and <ph id="ph3">`AddToAny`</ph> that will add to or take from any of the collections in the array.</source>
          <target state="translated">consumer が複数のコレクションから同時に項目を取得する必要のあるシナリオでは、<ph id="ph1">`BlockingCollection&lt;T&gt;`</ph> の配列を作成し、<ph id="ph2">`TakeFromAny`</ph> や <ph id="ph3">`AddToAny`</ph> などの静的メソッドを使用できます。これらのメソッドでは、配列内の任意のコレクションを対象に追加または取得の操作を実行できます。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If one collection is blocking, the method immediately tries another until it finds one that can perform the operation.</source>
          <target state="translated">いずれかのコレクションがブロックしている場合、メソッドはすぐに別のコレクションを試します。これは、操作を実行できるコレクションが見つかるまで続行されます。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Use Arrays of Blocking Collections in a Pipeline<ept id="p1">](how-to-use-arrays-of-blockingcollections.md)</ept>.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>方法: パイプラインでブロッキング コレクションの配列を使用する<ept id="p1">](how-to-use-arrays-of-blockingcollections.md)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">関連項目</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Collections.Concurrent<ept id="p1">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Collections and Data Structures<ept id="p1">](../index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>コレクションとデータ構造体<ept id="p1">](../index.md)</ept></target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Thread-Safe Collections<ept id="p1">](index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>スレッドセーフなコレクション<ept id="p1">](index.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>