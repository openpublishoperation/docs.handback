<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">381fa0db2d92590d23ebd71a7823a8465e94a6e6</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\procedures\extension-methods.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">84bb72899e1213c1873b9817f0c4227980c03199</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56d34f039b1438766543d5745213bed0cee6296d</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_extension-methods.3376dafd6e9da1dbd7698b015510be2bb146d45b.ja-jp is different with handoff file name: extension-methods.3376dafd6e9da1dbd7698b015510be2bb146d45b.ja-jp.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Extension Methods (Visual Basic) | Microsoft Docs</source>
          <target state="translated">拡張メソッド (Visual Basic) |Microsoft ドキュメント</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Extension Methods (Visual Basic)</source>
          <target state="translated">拡張メソッド (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Extension methods enable developers to add custom functionality to data types that are already defined without creating a new derived type.</source>
          <target state="translated">拡張メソッドでは、新しい派生型を作成しなくても既に定義されているデータ型にカスタム機能を追加することが有効にします。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Extension methods make it possible to write a method that can be called as if it were an instance method of the existing type.</source>
          <target state="translated">拡張メソッドを使用すれば、既存の型のインスタンス メソッドの場合と同様に呼び出すことができるメソッドを記述できます。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">コメント</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>An extension method can be only a <ph id="ph1">`Sub`</ph> procedure or a <ph id="ph2">`Function`</ph> procedure.</source>
          <target state="translated">拡張メソッドになるのは、<ph id="ph1">`Sub`</ph> プロシージャと <ph id="ph2">`Function`</ph> プロシージャだけです。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You cannot define an extension property, field, or event.</source>
          <target state="translated">拡張プロパティ、拡張フィールド、拡張イベントを定義することはできません。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>All extension methods must be marked with the extension attribute <ph id="ph1">`&lt;Extension()&gt;`</ph> from the &lt;xref:System.Runtime.CompilerServices?displayProperty=fullName&gt; namespace.</source>
          <target state="translated">すべての拡張メソッドは、拡張属性でマークする必要があります<ph id="ph1">`&lt;Extension()&gt;`</ph>から、&lt;xref:System.Runtime.CompilerServices?displayProperty=fullName&gt;名前空間&lt;/xref:System.Runtime.CompilerServices?displayProperty=fullName&gt;。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The first parameter in an extension method definition specifies which data type the method extends.</source>
          <target state="translated">拡張メソッド定義の最初のパラメーターでは、そのメソッドが拡張するデータ型を指定します。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When the method is run, the first parameter is bound to the instance of the data type that invokes the method.</source>
          <target state="translated">メソッドが実行されると、最初のパラメーターは、そのメソッドを呼び出すデータ型のインスタンスにバインディングされます。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">例</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`Print`</ph> extension to the &lt;xref:System.String&gt; data type.</source>
          <target state="translated">次の例、<ph id="ph1">`Print`</ph>の拡張機能、&lt;xref:System.String&gt;データ型&lt;/xref:System.String&gt;。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The method uses <ph id="ph1">`Console.WriteLine`</ph> to display a string.</source>
          <target state="translated">このメソッドでは、<ph id="ph1">`Console.WriteLine`</ph> を使用して文字列を表示します。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The parameter of the <ph id="ph1">`Print`</ph> method, <ph id="ph2">`aString`</ph>, establishes that the method extends the &lt;xref:System.String&gt; class.</source>
          <target state="translated">パラメーター、<ph id="ph1">`Print`</ph>メソッド、 <ph id="ph2">`aString`</ph>、メソッドが&lt;xref:System.String&gt;クラス&lt;/xref:System.String&gt;を拡張することを指定</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#1<ept id="p2">](./codesnippet/VisualBasic/extension-methods_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#1;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Notice that the extension method definition is marked with the extension attribute <ph id="ph1">`&lt;Extension()&gt;`</ph>.</source>
          <target state="translated">拡張メソッド定義に拡張属性 <ph id="ph1">`&lt;Extension()&gt;`</ph> を設定している点に注目してください。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Marking the module in which the method is defined is optional, but each extension method must be marked.</source>
          <target state="translated">メソッドが定義されているモジュールに拡張属性を設定するかどうかは任意ですが、それぞれの拡張メソッドにはこの設定が必要です。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Runtime.CompilerServices&gt; must be imported in order to access the extension attribute.</source>
          <target state="translated">&lt;xref:System.Runtime.CompilerServices&gt;拡張属性にアクセスするためにインポートする必要があります。&lt;/xref:System.Runtime.CompilerServices&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Extension methods can be declared only within modules.</source>
          <target state="translated">拡張メソッドはモジュール内でのみ宣言できます。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Typically, the module in which an extension method is defined is not the same module as the one in which it is called.</source>
          <target state="translated">通常、拡張メソッドを定義するモジュールと拡張メソッドを呼び出すモジュールは、別々になります。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Instead, the module that contains the extension method is imported, if it needs to be, to bring it into scope.</source>
          <target state="translated">必要に応じて、拡張メソッドが含まれているモジュールをインポートすることによって、そのモジュールをスコープの中に入れます。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>After the module that contains <ph id="ph1">`Print`</ph> is in scope, the method can be called as if it were an ordinary instance method that takes no arguments, such as <ph id="ph2">`ToUpper`</ph>:</source>
          <target state="translated"><ph id="ph1">`Print`</ph> が含まれているモジュールをスコープの中に入れたら、引数を使用しない通常のインスタンス メソッド (<ph id="ph2">`ToUpper`</ph> など) の場合と同じ要領でそのメソッドを呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#2<ept id="p2">](./codesnippet/VisualBasic/extension-methods_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#2;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The next example, <ph id="ph1">`PrintAndPunctuate`</ph>, is also an extension to &lt;xref:System.String&gt;, this time defined with two parameters.</source>
          <target state="translated">次の例では、<ph id="ph1">`PrintAndPunctuate`</ph>も拡張である&lt;xref:System.String&gt;、今回は&amp;2; つのパラメーターを定義します&lt;/xref:System.String&gt;。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The first parameter, <ph id="ph1">`aString`</ph>, establishes that the extension method extends &lt;xref:System.String&gt;.</source>
          <target state="translated">最初のパラメーター <ph id="ph1">`aString`</ph>、 &lt;xref:System.String&gt;.&lt;/xref:System.String&gt;を拡張する拡張メソッドを指定</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The second parameter, <ph id="ph1">`punc`</ph>, is intended to be a string of punctuation marks that is passed in as an argument when the method is called.</source>
          <target state="translated">2 番目のパラメーター <ph id="ph1">`punc`</ph> では、メソッドの呼び出し時に引数として渡す区切り記号の文字列を指定します。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The method displays the string followed by the punctuation marks.</source>
          <target state="translated">このメソッドでは、文字列の後にその区切り記号を表示します。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#3<ept id="p2">](./codesnippet/VisualBasic/extension-methods_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#3;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The method is called by sending in a string argument for <ph id="ph1">`punc`</ph>: <ph id="ph2">`example.PrintAndPunctuate(".")`</ph></source>
          <target state="translated">このメソッドを呼び出すときには、<ph id="ph1">`punc`</ph> の引数として <ph id="ph2">`example.PrintAndPunctuate(".")`</ph> を渡します。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The following example shows <ph id="ph1">`Print`</ph> and <ph id="ph2">`PrintAndPunctuate`</ph> defined and called.</source>
          <target state="translated"><ph id="ph1">`Print`</ph> と <ph id="ph2">`PrintAndPunctuate`</ph> を定義して呼び出す例を次に示します。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Runtime.CompilerServices&gt; is imported in the definition module in order to enable access to the extension attribute.</source>
          <target state="translated">&lt;xref:System.Runtime.CompilerServices&gt;拡張属性にアクセスできるようにするために定義モジュールにインポートされます。&lt;/xref:System.Runtime.CompilerServices&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">コード</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Next, the extension methods are brought into scope and called.</source>
          <target state="translated">次に、拡張メソッドをスコープの中に取り込んで呼び出します。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">コメント</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>All that is required to be able to run these or similar extension methods is that they be in scope.</source>
          <target state="translated">このような拡張メソッドを実行するための唯一の要件は、その拡張メソッドをスコープの中に組み入れておくことです。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If the module that contains an extension method is in scope, it is visible in IntelliSense and can be called as if it were an ordinary instance method.</source>
          <target state="translated">拡張メソッドが含まれているモジュールがスコープの中に入っていれば、その拡張メソッドは IntelliSense からアクセスできるということであり、通常のインスタンス メソッドの場合と同じ要領で呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Notice that when the methods are invoked, no argument is sent in for the first parameter.</source>
          <target state="translated">メソッドを呼び出すときに、最初のパラメーターの引数を渡していない点に注目してください。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Parameter <ph id="ph1">`aString`</ph> in the previous method definitions is bound to <ph id="ph2">`example`</ph>, the instance of <ph id="ph3">`String`</ph> that calls them.</source>
          <target state="translated">前のメソッド定義のパラメーター <ph id="ph1">`aString`</ph> が、メソッドを呼び出す <ph id="ph2">`example`</ph> のインスタンスである <ph id="ph3">`String`</ph> にバインディングされています。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The compiler will use <ph id="ph1">`example`</ph> as the argument sent to the first parameter.</source>
          <target state="translated">コンパイラは、最初のパラメーターに渡す引数としてその <ph id="ph1">`example`</ph> を使用します。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If an extension method is called for an object that is set to <ph id="ph1">`Nothing`</ph>, the extension method executes.</source>
          <target state="translated"><ph id="ph1">`Nothing`</ph> に設定されたオブジェクトに対して拡張メソッドが呼び出された場合、その拡張メソッドが実行されます。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This does not apply to ordinary instance methods.</source>
          <target state="translated">これは、通常のインスタンス メソッドには適用されません。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can explicitly check for <ph id="ph1">`Nothing`</ph> in the extension method.</source>
          <target state="translated">拡張メソッドの <ph id="ph1">`Nothing`</ph> は明示的にチェックできます。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Types That Can Be Extended</source>
          <target state="translated">拡張可能な型</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can define an extension method on most types that can be represented in a Visual Basic parameter list, including the following:</source>
          <target state="translated">拡張メソッドは、Visual Basic のパラメーター リストで記述できるほとんどの型で定義できます。以下に例を示します。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Classes (reference types)</source>
          <target state="translated">クラス (参照型)</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Structures (value types)</source>
          <target state="translated">構造体 (値型)</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">インターフェイス</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Delegates</source>
          <target state="translated">デリゲート</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>ByRef and ByVal arguments</source>
          <target state="translated">ByRef 引数と ByVal 引数</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Generic method parameters</source>
          <target state="translated">ジェネリック メソッド パラメーター</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">配列</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Because the first parameter specifies the data type that the extension method extends, it is required and cannot be optional.</source>
          <target state="translated">最初のパラメーターでは、メソッドによって拡張するデータ型を指定するので、最初のパラメーターは必須であり、任意指定にすることはできません。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For that reason, <ph id="ph1">`Optional`</ph> parameters and <ph id="ph2">`ParamArray`</ph> parameters cannot be the first parameter in the parameter list.</source>
          <target state="translated">したがって、パラメーター リストの最初のパラメーターとして、<ph id="ph1">`Optional`</ph> パラメーターと <ph id="ph2">`ParamArray`</ph> パラメーターを記述することはできません。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Extension methods are not considered in late binding.</source>
          <target state="translated">拡張メソッドは遅延バインディングでは考慮されません。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In the following example, the statement <ph id="ph1">`anObject.PrintMe()`</ph> raises a &lt;xref:System.MissingMemberException&gt; exception, the same exception you would see if the second <ph id="ph2">`PrintMe`</ph> extension method definition were deleted.</source>
          <target state="translated">次の例では、ステートメントで<ph id="ph1">`anObject.PrintMe()`</ph>を発生させます、&lt;xref:System.MissingMemberException&gt;例外を同じ例外の場合に発生する、2 つ目<ph id="ph2">`PrintMe`</ph>拡張メソッド定義が削除された&lt;/xref:System.MissingMemberException&gt;。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#9<ept id="p2">](./codesnippet/VisualBasic/extension-methods_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#9;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Best Practices</source>
          <target state="translated">ベスト プラクティス</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Extension methods provide a convenient and powerful way to extend an existing type.</source>
          <target state="translated">拡張メソッドは、既存の型を拡張するための便利で強力な手段になります。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>However, to use them successfully, there are some points to consider.</source>
          <target state="translated">それでも、適切に使用するにはいくつかの注意点があります。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>These considerations apply mainly to authors of class libraries, but they might affect any application that uses extension methods.</source>
          <target state="translated">ここで取り上げる注意点は、主にクラス ライブラリを作成するときに当てはまりますが、拡張メソッドを使用するアプリケーションであればどんなアプリケーションにも影響する可能性があります。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Most generally, extension methods that you add to types that you do not own are more vulnerable than extension methods added to types that you control.</source>
          <target state="translated">一般的に、自分で所有していない型に追加した拡張メソッドは、自分で制御できる型に追加した拡張メソッドよりも脆弱になります。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A number of things can occur in classes you do not own that can interfere with your extension methods.</source>
          <target state="translated">自分で所有していないクラスでは、拡張メソッドの動作に影響を及ぼしかねない事柄がいくつか発生する可能性があります。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>If any accessible instance member exists that has a signature that is compatible with the arguments in the calling statement, with no narrowing conversions required from argument to parameter, the instance method will be used in preference to any extension method.</source>
          <target state="translated">呼び出し元ステートメントの引数との互換性があるシグネチャを持ったアクセス可能なインスタンス メンバーが存在し、引数からパラメーターへの縮小変換が不要な場合は、拡張メソッドよりもそのインスタンス メソッドの方が優先的に使用されます。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Therefore, if an appropriate instance method is added to a class at some point, an existing extension member that you rely on may become inaccessible.</source>
          <target state="translated">したがって、該当するインスタンス メソッドがいずれかの時点でクラスに追加されると、使用しなければならない既存の拡張メソッドにアクセスできなくなる可能性があります。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The author of an extension method cannot prevent other programmers from writing conflicting extension methods that may have precedence over the original extension.</source>
          <target state="translated">拡張メソッドの作成者の側では、その拡張メソッドよりも優先的に使用される可能性がある別の拡張メソッドを他のプログラマが作成する、という事態を防止できません。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can improve robustness by putting extension methods in their own namespace.</source>
          <target state="translated">拡張メソッドをそれ自身の名前空間に入れておけば、拡張メソッドの信頼性が向上します。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Consumers of your library can then include a namespace or exclude it, or select among namespaces, separately from the rest of the library.</source>
          <target state="translated">ライブラリを利用する側では、ライブラリの名前空間とそれ以外の部分を分けて、名前空間を組み込んだり除外したり取捨選択したりすることができます。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>It may be safer to extend interfaces than it is to extend classes, especially if you do not own the interface or class.</source>
          <target state="translated">クラスを拡張するよりもインターフェイスを拡張する方が安全です。インターフェイスまたはクラスを自分で所有していない場合は特にそういえます。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A change in an interface affects every class that implements it.</source>
          <target state="translated">インターフェイスが変更されると、そのインターフェイスを実装するすべてのクラスが影響を受けます。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Therefore, the author may be less likely to add or change methods in an interface.</source>
          <target state="translated">したがって、インターフェイスでメソッドが追加されたり変更されたりする可能性の方が低いといえます。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>However, if a class implements two interfaces that have extension methods with the same signature, neither extension method is visible.</source>
          <target state="translated">ただし、クラスが同じシグニチャの拡張メソッドを持つ&amp;2; つのインターフェイスを実装する場合、どちらの拡張メソッドにもアクセスできません。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Extend the most specific type you can.</source>
          <target state="translated">できるだけ具体性の高い型を拡張するようにします。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In a hierarchy of types, if you select a type from which many other types are derived, there are layers of possibilities for the introduction of instance methods or other extension methods that might interfere with yours.</source>
          <target state="translated">型の階層の中で他の多くの型の派生元になっている型で拡張メソッドを選択すると、その拡張メソッドの動作に影響を及ぼしかねないインスタンス メソッドや他の拡張メソッドが組み込まれる可能性が高くなります。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Extension Methods, Instance Methods, and Properties</source>
          <target state="translated">拡張メソッド、インスタンス メソッド、およびプロパティ</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>When an in-scope instance method has a signature that is compatible with the arguments of a calling statement, the instance method is chosen in preference to any extension method.</source>
          <target state="translated">スコープ内のインスタンス メソッドが、呼び出し元ステートメントの引数と互換性があるシグネチャを持っている場合、拡張メソッドよりもそのインスタンス メソッドの方が優先的に使用されます。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The instance method has precedence even if the extension method is a better match.</source>
          <target state="translated">この場合、より適合する拡張メソッドがあっても、インスタンス メソッドの方が優先されます。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`ExampleClass`</ph> contains an instance method named <ph id="ph2">`ExampleMethod`</ph> that has one parameter of type <ph id="ph3">`Integer`</ph>.</source>
          <target state="translated">次の例では、<ph id="ph1">`ExampleClass`</ph> に、<ph id="ph2">`ExampleMethod`</ph> 型のパラメーターを&amp;1; つ持つ <ph id="ph3">`Integer`</ph> という名前のインスタンス メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Extension method <ph id="ph1">`ExampleMethod`</ph> extends <ph id="ph2">`ExampleClass`</ph>, and has one parameter of type <ph id="ph3">`Long`</ph>.</source>
          <target state="translated">拡張メソッド <ph id="ph1">`ExampleMethod`</ph> は <ph id="ph2">`ExampleClass`</ph> を拡張し、<ph id="ph3">`Long`</ph> 型のパラメーターを&amp;1; つ持ちます。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#4<ept id="p2">](./codesnippet/VisualBasic/extension-methods_5.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;4;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_5.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The first call to <ph id="ph1">`ExampleMethod`</ph> in the following code calls the extension method, because <ph id="ph2">`arg1`</ph> is <ph id="ph3">`Long`</ph> and is compatible only with the <ph id="ph4">`Long`</ph> parameter in the extension method.</source>
          <target state="translated">次のコードでは、<ph id="ph1">`ExampleMethod`</ph> の最初の呼び出しで、拡張メソッドが呼び出されます。これは、<ph id="ph2">`arg1`</ph> が <ph id="ph3">`Long`</ph> であり、拡張メソッドの <ph id="ph4">`Long`</ph> パラメーターとのみ互換性があるためです。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The second call to <ph id="ph1">`ExampleMethod`</ph> has an <ph id="ph2">`Integer`</ph> argument, <ph id="ph3">`arg2`</ph>, and it calls the instance method.</source>
          <target state="translated"><ph id="ph1">`ExampleMethod`</ph> の&amp;2; 回目の呼び出しでは、<ph id="ph2">`Integer`</ph> 引数 <ph id="ph3">`arg2`</ph> があるため、インスタンス メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#5<ept id="p2">](./codesnippet/VisualBasic/extension-methods_6.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#5;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_6.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Now reverse the data types of the parameters in the two methods:</source>
          <target state="translated">次は、2 つのメソッド間でパラメーターのデータ型が逆になっています。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#6<ept id="p2">](./codesnippet/VisualBasic/extension-methods_7.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;6;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_7.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>This time the code in <ph id="ph1">`Main`</ph> calls the instance method both times.</source>
          <target state="translated">今回は、<ph id="ph1">`Main`</ph> 内のコードはどちらの場合でもインスタンス メソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This is because both <ph id="ph1">`arg1`</ph> and <ph id="ph2">`arg2`</ph> have a widening conversion to <ph id="ph3">`Long`</ph>, and the instance method takes precedence over the extension method in both cases.</source>
          <target state="translated">これは、<ph id="ph1">`arg1`</ph> と <ph id="ph2">`arg2`</ph> は <ph id="ph3">`Long`</ph> へ拡大変換され、どちらの場合でも拡張メソッドよりインスタンス メソッドの方が優先されるためです。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#7<ept id="p2">](./codesnippet/VisualBasic/extension-methods_8.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#7;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_8.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Therefore, an extension method cannot replace an existing instance method.</source>
          <target state="translated">つまり、既存のインスタンス メソッドの代わりに拡張メソッドを使用することはできません。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>However, when an extension method has the same name as an instance method but the signatures do not conflict, both methods can be accessed.</source>
          <target state="translated">ただし、拡張メソッドとインスタンス メソッドの名前が同じでもシグネチャが競合しない場合は、両方のメソッドを使用できます。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>For example, if class <ph id="ph1">`ExampleClass`</ph> contains a method named <ph id="ph2">`ExampleMethod`</ph> that takes no arguments, extension methods with the same name but different signatures are permitted, as shown in the following code.</source>
          <target state="translated">たとえば、クラス <ph id="ph1">`ExampleClass`</ph> に引数を使用しない <ph id="ph2">`ExampleMethod`</ph> という名前のメソッドがあるとします。拡張メソッドの名前がそのメソッドと同じでもシグネチャが違えば、その拡張メソッドを使用することは可能です。次に例を示します。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods#8<ept id="p2">](./codesnippet/VisualBasic/extension-methods_9.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrExtensionMethods&amp;#8;<ept id="p2">](./codesnippet/VisualBasic/extension-methods_9.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The output from this code is as follows:</source>
          <target state="translated">このコードの出力は次のようになります。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The situation is simpler with properties: if an extension method has the same name as a property of the class it extends, the extension method is not visible and cannot be accessed.</source>
          <target state="translated">プロパティの場合、状況はより単純です。拡張メソッドの名前がそのクラスのプロパティと同じである場合、その拡張メソッドは非表示になり、アクセスできません。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Extension Method Precedence</source>
          <target state="translated">拡張メソッドの優先順位</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>When two extension methods that have identical signatures are in scope and accessible, the one with higher precedence will be invoked.</source>
          <target state="translated">2 つの拡張メソッドのシグネチャが同じで、そのいずれもスコープに入っていてアクセスが可能な場合は、優先順位の高い方が呼び出されます。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>An extension method's precedence is based on the mechanism used to bring the method into scope.</source>
          <target state="translated">拡張メソッドの優先順位は、メソッドをスコープに組み入れる方法に基づいています。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The following list shows the precedence hierarchy, from highest to lowest.</source>
          <target state="translated">優先順位の高い方から低い方へと並べると、次のようになります。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside the current module.</source>
          <target state="translated">現在のモジュールの中で定義されている拡張メソッド。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside data types in the current namespace or any one of its parents, with child namespaces having higher precedence than parent namespaces.</source>
          <target state="translated">現在の名前空間の方がその親に相当する名前空間よりも優先順位が高ければ、現在の名前空間またはそのいずれかの親に相当する名前空間にあるデータ型の中で定義されている拡張メソッド。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside any type imports in the current file.</source>
          <target state="translated">現在のファイルの型インポートの中で定義されている拡張メソッド。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside any namespace imports in the current file.</source>
          <target state="translated">現在のファイルの名前空間インポートの中で定義されている拡張メソッド。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside any project-level type imports.</source>
          <target state="translated">プロジェクト レベルの型インポートの中で定義されている拡張メソッド。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Extension methods defined inside any project-level namespace imports.</source>
          <target state="translated">プロジェクト レベルの名前空間インポートの中で定義されている拡張メソッド。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If precedence does not resolve the ambiguity, you can use the fully qualified name to specify the method that you are calling.</source>
          <target state="translated">優先順位を適用してもあいまいさが残る場合は、完全修飾名を使用して、呼び出すメソッドを指定できます。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Print`</ph> method in the earlier example is defined in a module named <ph id="ph2">`StringExtensions`</ph>, the fully qualified name is <ph id="ph3">`StringExtensions.Print(example)`</ph> instead of <ph id="ph4">`example.Print()`</ph>.</source>
          <target state="translated">先ほどの例の <ph id="ph1">`Print`</ph> メソッドが <ph id="ph2">`StringExtensions`</ph> という名前のモジュールで定義されていれば、完全修飾名は <ph id="ph3">`StringExtensions.Print(example)`</ph> ではなく <ph id="ph4">`example.Print()`</ph> になります。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">関連項目</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Runtime.CompilerServices&gt;</source>
          <target state="translated">&lt;xref:System.Runtime.CompilerServices&gt;&lt;/xref:System.Runtime.CompilerServices&gt;</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Runtime.CompilerServices.ExtensionAttribute&gt;</source>
          <target state="translated">&lt;xref:System.Runtime.CompilerServices.ExtensionAttribute&gt;&lt;/xref:System.Runtime.CompilerServices.ExtensionAttribute&gt;</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Extension Methods<ept id="p1">](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>拡張メソッド<ept id="p1">](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Module Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/module-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Module ステートメント<ept id="p1">](../../../../visual-basic/language-reference/statements/module-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Procedure Parameters and Arguments<ept id="p1">](./procedure-parameters-and-arguments.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>プロシージャのパラメーターと引数<ept id="p1">](./procedure-parameters-and-arguments.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Optional Parameters<ept id="p1">](./optional-parameters.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>省略可能なパラメーター<ept id="p1">](./optional-parameters.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Parameter Arrays<ept id="p1">](./parameter-arrays.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>パラメーター配列<ept id="p1">](./parameter-arrays.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Attributes overview<ept id="p1">](../../../../visual-basic/programming-guide/concepts/attributes/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>属性の概要<ept id="p1">](../../../../visual-basic/programming-guide/concepts/attributes/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Scope in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Visual Basic におけるスコープ<ept id="p1">](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>