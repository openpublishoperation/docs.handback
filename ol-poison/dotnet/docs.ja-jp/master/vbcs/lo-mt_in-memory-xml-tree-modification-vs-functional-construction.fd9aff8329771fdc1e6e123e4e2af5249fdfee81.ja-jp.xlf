<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0456d221f01573e6ef1c67a3e0d1db585e6f3b0c</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\in-memory-xml-tree-modification-vs-functional-construction.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">eb369222c9661adba4ad778e847f74f691eee325</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">852c142cd6422c641afeb712615442a38383fcdd</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_in-memory-xml-tree-modification-vs-functional-construction.fd9aff8329771fdc1e6e123e4e2af5249fdfee81.ja-jp is different with handoff file name: in-memory-xml-tree-modification-vs-functional-construction.fd9aff8329771fdc1e6e123e4e2af5249fdfee81.ja-jp.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>In-Memory XML Tree Modification vs. Functional Construction (LINQ to XML) (Visual Basic) | Microsoft Docs</source>
          <target state="translated">メモリ内の XML ツリーの変更と関数型構築 (LINQ to XML) (Visual Basic) |Microsoft ドキュメント</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>In-Memory XML Tree Modification vs. Functional Construction (LINQ to XML) (Visual Basic)</source>
          <target state="translated">メモリ内の XML ツリーの変更と関数型構築 (LINQ to XML) (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Modifying an XML tree in place is a traditional approach to changing the shape of an XML document.</source>
          <target state="translated">XML ドキュメントの構造を変更する場合は、XML ツリーを直接変更するのが従来の方法です。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>A typical application loads a document into a data store such as DOM or <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>; uses a programming interface to insert nodes, delete nodes, or change the content of nodes; and then saves the XML to a file or transmits it over a network.</source>
          <target state="translated">一般的なアプリケーションでは、ドキュメントを DOM や <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> などのデータ ストアに読み込み、プログラミング インターフェイスを使用してノードの挿入、削除、または内容変更を行い、その後に XML をファイルに保存するか、またはネットワーク上に送信します。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> enables another approach that is useful in many scenarios<bpt id="p1">*</bpt>: functional construction<ept id="p1">*</ept>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>では、別の方法として多くのシナリオで役に立つ<bpt id="p1">*</bpt>: 関数型構築<ept id="p1">*</ept>します。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Functional construction treats modifying data as a problem of transformation, rather than as detailed manipulation of a data store.</source>
          <target state="translated">関数型構築では、データの変更が、データ ストアの詳細な操作としてではなく変換の問題として扱われます。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>If you can take a representation of data and transform it efficiently from one form to another, the result is the same as if you took one data store and manipulated it in some way to take another shape.</source>
          <target state="translated">データの表現をある形式から別の形式に効率よく変換できれば、データ ストアを何らかの方法で操作して別の構造にする場合と同じ結果を得られます。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A key to the functional construction approach is to pass the results of queries to &lt;xref:System.Xml.Linq.XDocument&gt; and &lt;xref:System.Xml.Linq.XElement&gt; constructors.</source>
          <target state="translated">クエリの結果を渡す関数型構築の方法で重要です&lt;xref:System.Xml.Linq.XDocument&gt;と&lt;xref:System.Xml.Linq.XElement&gt;コンス トラクター&lt;/xref:System.Xml.Linq.XElement&gt; &lt;/xref:System.Xml.Linq.XDocument&gt; 。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In many cases you can write the transformational code in a fraction of the time that it would take to manipulate the data store, and that code is more robust and easier to maintain.</source>
          <target state="translated">多くの場合、変換コードは、データ ストアを操作する場合に比べてはるかに短時間で作成でき、堅牢性と保守性にも優れています。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In these cases, even though the transformational approach can take more processing power, it is a more effective way to modify data.</source>
          <target state="translated">この場合、変換コードによる方法では、より大きな処理能力を必要とする可能性はありますが、効果的にデータを変更できます。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If a developer is familiar with the functional approach, the resulting code in many cases is easier to understand.</source>
          <target state="translated">開発者が関数型の方法に精通していれば、ほとんどの場合、作成されるコードもよりわかりやすくなります。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>It is easy to find the code that modifies each part of the tree.</source>
          <target state="translated">ツリーの各部分を変更するコードが簡単に見つかります。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The approach where you modify an XML tree in-place is more familiar to many DOM programmers, whereas code written using the functional approach might look unfamiliar to a developer who doesn't yet understand that approach.</source>
          <target state="translated">DOM プログラマの多くは、XML ツリーを直接変更する方法に慣れています。関数型の方法をまだ理解していない開発者は、この方法で記述されたコードに慣れていない場合があります。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If you have to only make a small modification to a large XML tree, the approach where you modify a tree in place in many cases will take less CPU time.</source>
          <target state="translated">大きな XML ツリーに小さな変更を加えるだけであれば、ツリーを直接変更する方法の方が使用する CPU 時間が少ない場合がほとんどです。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This topic provides an example that is implemented with both approaches.</source>
          <target state="translated">このトピックでは、両方の方法での実装例を紹介します。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Transforming Attributes into Elements</source>
          <target state="translated">属性から要素への変換</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For this example, suppose you want to modify the following simple XML document so that the attributes become elements.</source>
          <target state="translated">この例では、属性が要素となるように、次の単純な XML ドキュメントを変更するケースを想定します。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This topic first presents the traditional in-place modification approach.</source>
          <target state="translated">まず、直接変更する従来の方法を示します。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>It then shows the functional construction approach.</source>
          <target state="translated">その後に関数型構築の方法を示します。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Modifying the XML Tree</source>
          <target state="translated">XML ツリーの変更</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You can write some procedural code to create elements from the attributes, and then delete the attributes, as follows:</source>
          <target state="translated">属性から要素を作成した後に属性を削除する、次のようなプロシージャ コードを記述します。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This code produces the following output:</source>
          <target state="translated">このコードを実行すると、次の出力が生成されます。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Functional Construction Approach</source>
          <target state="translated">関数型構築の方法</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>By contrast, a functional approach consists of code to form a new tree, picking and choosing elements and attributes from the source tree, and transforming them as appropriate as they are added to the new tree.</source>
          <target state="translated">上のコードとは対照的に、関数型の方法を構成するコードでは、新しいツリーを作成し、ソース ツリーから要素と属性を選択し、その要素と属性を新しいツリーに追加するときに適宜変換します。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The functional approach looks like the following:</source>
          <target state="translated">関数型の方法は次のようになります。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This example outputs the same XML as the first example.</source>
          <target state="translated">この例では、最初の例と同じ XML が出力されます。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>However, notice that you can actually see the resulting structure of the new XML in the functional approach.</source>
          <target state="translated">ただし、関数型の方法では、新しい XML の構造が実際に作成されます。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You can see the creation of the <ph id="ph1">`Root`</ph> element, the code that pulls the <ph id="ph2">`Child1`</ph> element from the source tree, and the code that transforms the attributes from the source tree to elements in the new tree.</source>
          <target state="translated"><ph id="ph1">`Root`</ph> 要素、ソース ツリーから <ph id="ph2">`Child1`</ph> 要素を取り出すコード、およびソース ツリーから取得した属性を新しいツリーの要素に変換するコードが作成されることがわかります。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The functional example in this case is not any shorter than the first example, and it is not really any simpler.</source>
          <target state="translated">ここで示した関数型の例は、最初の例と比べて短くはなく、単純でもありません。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>However, if you have many changes to make to an XML tree, the non functional approach will become quite complex and somewhat obtuse.</source>
          <target state="translated">しかし XML ツリーに多数の変更を加える場合、関数型でない方法では、処理がかなり複雑になり、効率的とはいえません。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In contrast, when using the functional approach, you still just form the desired XML, embedding queries and expressions as appropriate, to pull in the desired content.</source>
          <target state="translated">一方、関数型の方法では、クエリと式を適宜組み込んだ必要な XML を作成するだけで、必要な内容を取り出せます。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The functional approach yields code that is easier to maintain.</source>
          <target state="translated">関数型の方法で生成されたコードの方が、保守も簡単です。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Notice that in this case the functional approach probably would not perform quite as well as the tree manipulation approach.</source>
          <target state="translated">この例では、ツリーを操作する方法に比べて関数型の方法のパフォーマンスが低くなる可能性があるので注意してください。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The main issue is that the functional approach creates more short lived objects.</source>
          <target state="translated">主な問題は、関数型の方法では存続期間の短いオブジェクトが多数作成されることです。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>However, the tradeoff is an effective one if using the functional approach allows for greater programmer productivity.</source>
          <target state="translated">その代わりに、関数型の方法の方がプログラマの生産性が高いという効果があります。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This is a very simple example, but it serves to show the difference in philosophy between the two approaches.</source>
          <target state="translated">ここで示したのはごく単純な例ですが、2 つの方法に関する考え方の違いをよく表しています。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The functional approach yields greater productivity gains for transforming larger XML documents.</source>
          <target state="translated">大きな XML ドキュメントを変換する場合は、関数型の方法を使用した方が生産性が高くなります。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">関連項目</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Modifying XML Trees (LINQ to XML) (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/modifying-xml-trees-linq-to-xml.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>XML ツリー (LINQ to XML) の変更 (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/modifying-xml-trees-linq-to-xml.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>