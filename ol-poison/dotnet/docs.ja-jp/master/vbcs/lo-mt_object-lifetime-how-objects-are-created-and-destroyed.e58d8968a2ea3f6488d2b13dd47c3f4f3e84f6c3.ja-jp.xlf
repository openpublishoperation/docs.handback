<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">404c21c39a24d54c008fddf6dc386cc2895fe3a0</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\objects-and-classes\object-lifetime-how-objects-are-created-and-destroyed.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e014e125cb65134f8526308bfab4d2bfdc4a687b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">91fb8a8d836c42b16145676f0bfc78c39448fe21</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_object-lifetime-how-objects-are-created-and-destroyed.e58d8968a2ea3f6488d2b13dd47c3f4f3e84f6c3.ja-jp is different with handoff file name: object-lifetime-how-objects-are-created-and-destroyed.e58d8968a2ea3f6488d2b13dd47c3f4f3e84f6c3.ja-jp.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Object Lifetime: How Objects Are Created and Destroyed (Visual Basic) | Microsoft Docs</source>
          <target state="translated">オブジェクトの有効期間: オブジェクトの作成と破棄 (Visual Basic) |Microsoft ドキュメント</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Object Lifetime: How Objects Are Created and Destroyed (Visual Basic)</source>
          <target state="translated">オブジェクトの有効期間: オブジェクトの作成と破棄 (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>An instance of a class, an object, is created by using the <ph id="ph1">`New`</ph> keyword.</source>
          <target state="translated">クラスのインスタンス (オブジェクト) を作成するには、<ph id="ph1">`New`</ph> キーワードを使用します。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Initialization tasks often must be performed on new objects before they are used.</source>
          <target state="translated">新しいオブジェクトを使用する前に、多くの場合、そのオブジェクトに対して初期化タスクを実行する必要があります。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Common initialization tasks include opening files, connecting to databases, and reading values of registry keys.</source>
          <target state="translated">一般的な初期化タスクとして、ファイルを開く、データベースに接続する、レジストリ キーの値を読み取る、などがあります。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Visual Basic controls the initialization of new objects using procedures called <bpt id="p1">*</bpt>constructors<ept id="p1">*</ept> (special methods that allow control over initialization).</source>
          <target state="translated">Visual Basic と呼ばれるプロシージャを使用して新しいオブジェクトの初期化を制御する<bpt id="p1">*</bpt>コンス トラクター<ept id="p1">*</ept> (初期化を制御できる特殊なメソッド)。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>After an object leaves scope, it is released by the common language runtime (CLR).</source>
          <target state="translated">スコープを離れたオブジェクトは、共通言語ランタイム (CLR) によって解放されます。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Visual Basic controls the release of system resources using procedures called <bpt id="p1">*</bpt>destructors<ept id="p1">*</ept>.</source>
          <target state="translated">Visual Basic と呼ばれるプロシージャを使用しているシステム リソースの解放を制御する<bpt id="p1">*</bpt>デストラクター<ept id="p1">*</ept>します。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Together, constructors and destructors support the creation of robust and predictable class libraries.</source>
          <target state="translated">コンストラクターとデストラクターは共に、堅牢で予測可能なクラス ライブラリの作成をサポートしています。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Using Constructors and Destructors</source>
          <target state="translated">コンストラクターとデストラクターの使用</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Constructors and destructors control the creation and destruction of objects.</source>
          <target state="translated">コンストラクターとデストラクターは、オブジェクトの作成および破棄を制御します。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Sub New`</ph> and <ph id="ph2">`Sub Finalize`</ph> procedures in Visual Basic initialize and destroy objects; they replace the <ph id="ph3">`Class_Initialize`</ph> and <ph id="ph4">`Class_Terminate`</ph> methods used in <ph id="ph5">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> 6.0 and earlier versions.</source>
          <target state="translated">Visual Basic の <ph id="ph1">`Sub New`</ph> と <ph id="ph2">`Sub Finalize`</ph> の各プロシージャが、オブジェクトを初期化および破棄します。これらは、<ph id="ph3">`Class_Initialize`</ph> 6.0 とそれ以前のバージョンで使用される <ph id="ph4">`Class_Terminate`</ph> と <ph id="ph5">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> の各メソッドに置き換わるものです。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Sub New</source>
          <target state="translated">Sub New</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Sub New`</ph> constructor can run only once when a class is created.</source>
          <target state="translated"><ph id="ph1">`Sub New`</ph> コンストラクターは、クラスの作成時に&amp;1; 回だけ実行できます。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>It cannot be called explicitly anywhere other than in the first line of code of another constructor from either the same class or from a derived class.</source>
          <target state="translated">同じクラスまたは派生クラスから別のコンストラクターの最初のコード行以外の任意の場所で、明示的に呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Furthermore, the code in the <ph id="ph1">`Sub New`</ph> method always runs before any other code in a class.</source>
          <target state="translated">また、<ph id="ph1">`Sub New`</ph> メソッド内のコードは常に、クラス内の他のすべてのコードより先に実行されます。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](../../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)]</ph> and later versions implicitly create a <ph id="ph2">`Sub New`</ph> constructor at run time if you do not explicitly define a <ph id="ph3">`Sub New`</ph> procedure for a class.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](../../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)]</ph>以降のバージョンが暗黙的に作成し、<ph id="ph2">`Sub New`</ph>コンス トラクターに明示的に定義していない場合、実行時に、<ph id="ph3">`Sub New`</ph>クラスのプロシージャです。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>To create a constructor for a class, create a procedure named <ph id="ph1">`Sub New`</ph> anywhere in the class definition.</source>
          <target state="translated">クラスのコンストラクターを作成するには、クラス定義の任意の場所に <ph id="ph1">`Sub New`</ph> という名前のプロシージャを作成します。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To create a parameterized constructor, specify the names and data types of arguments to <ph id="ph1">`Sub New`</ph> just as you would specify arguments for any other procedure, as in the following code:</source>
          <target state="translated">パラメーター化されたコンストラクターを作成するには、次のコードに示すように、他のプロシージャの引数を指定する場合と同じく、<ph id="ph1">`Sub New`</ph> に引数の名前とデータ型を指定します。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOOP#42<ept id="p2">](../../../../visual-basic/misc/codesnippet/VisualBasic/object-lifetime-how-objects-are-created-and-destroyed_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOOP #&amp;42;<ept id="p2">](../../../../visual-basic/misc/codesnippet/VisualBasic/object-lifetime-how-objects-are-created-and-destroyed_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Constructors are frequently overloaded, as in the following code:</source>
          <target state="translated">コンストラクターは、次のコードに示すように、頻繁にオーバーロードされます。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOOP#116<ept id="p2">](../../../../visual-basic/misc/codesnippet/VisualBasic/object-lifetime-how-objects-are-created-and-destroyed_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOOP&amp;116; 位<ept id="p2">](../../../../visual-basic/misc/codesnippet/VisualBasic/object-lifetime-how-objects-are-created-and-destroyed_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>When you define a class derived from another class, the first line of a constructor must be a call to the constructor of the base class, unless the base class has an accessible constructor that takes no parameters.</source>
          <target state="translated">別のクラスから派生したクラスを定義するときは、基本クラスにパラメーターを受け取らないアクセス可能なコンストラクターがある場合を除き、コンストラクターの&amp;1; 行目で基本クラスのコンストラクターを呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A call to the base class that contains the above constructor, for example, would be <ph id="ph1">`MyBase.New(s)`</ph>.</source>
          <target state="translated">たとえば、上記のコンストラクターを含む基本クラスの呼び出しは、<ph id="ph1">`MyBase.New(s)`</ph> になります。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Otherwise, <ph id="ph1">`MyBase.New`</ph> is optional, and the <ph id="ph2">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> runtime calls it implicitly.</source>
          <target state="translated">それ以外の場合、<ph id="ph1">`MyBase.New`</ph> はオプションであり、<ph id="ph2">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> ランタイムによって暗黙的に呼び出されます。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>After you write the code to call the parent object's constructor, you can add any additional initialization code to the <ph id="ph1">`Sub New`</ph> procedure.</source>
          <target state="translated">親オブジェクトのコンストラクターを呼び出すコードを記述した後、追加の初期化コードを <ph id="ph1">`Sub New`</ph> プロシージャに追加できます。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Sub New`</ph> can accept arguments when called as a parameterized constructor.</source>
          <target state="translated"><ph id="ph1">`Sub New`</ph>は、パラメーター化されたコンストラクターとして呼び出されたときには、引数を受け取ることができます。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>These parameters are passed from the procedure calling the constructor, for example, <ph id="ph1">`Dim AnObject As New ThisClass(X)`</ph>.</source>
          <target state="translated">このようなパラメーターは、コンストラクターを呼び出すプロシージャ (たとえば、<ph id="ph1">`Dim AnObject As New ThisClass(X)`</ph>) から渡されます。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Sub Finalize</source>
          <target state="translated">Sub Finalize</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Before releasing objects, the CLR automatically calls the <ph id="ph1">`Finalize`</ph> method for objects that define a <ph id="ph2">`Sub Finalize`</ph> procedure.</source>
          <target state="translated">オブジェクトを解放する前に、CLR は <ph id="ph1">`Finalize`</ph> プロシージャを定義するオブジェクトの <ph id="ph2">`Sub Finalize`</ph> メソッドを自動的に呼び出します。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Finalize`</ph> method can contain code that needs to execute just before an object is destroyed, such as code for closing files and saving state information.</source>
          <target state="translated"><ph id="ph1">`Finalize`</ph> メソッドには、ファイルを閉じて状態情報を保存するコードなど、オブジェクトを破棄する直前に実行する必要があるコードを含めることができます。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>There is a slight performance penalty for executing <ph id="ph1">`Sub Finalize`</ph>, so you should define a <ph id="ph2">`Sub Finalize`</ph> method only when you need to release objects explicitly.</source>
          <target state="translated"><ph id="ph1">`Sub Finalize`</ph> の実行には若干のパフォーマンス低下が伴うため、オブジェクトを明示的に解放する必要がある場合にのみ、<ph id="ph2">`Sub Finalize`</ph> メソッドを定義してください。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The garbage collector in the CLR does not (and cannot) dispose of <bpt id="p1">*</bpt>unmanaged objects<ept id="p1">*</ept>, objects that the operating system executes directly, outside the CLR environment.</source>
          <target state="translated">CLR のガベージ コレクターは、(ことはできません) 破棄しませんの<bpt id="p1">*</bpt>オブジェクトのアンマネージ<ept id="p1">*</ept>、オペレーティング システムが CLR 環境の外部で直接実行するオブジェクト。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This is because different unmanaged objects must be disposed of in different ways.</source>
          <target state="translated">これは、管理されていないオブジェクトごとに異なる方法で破棄する必要があるためです。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>That information is not directly associated with the unmanaged object; it must be found in the documentation for the object.</source>
          <target state="translated">その情報は、管理されていないオブジェクトに直接には関連付けられません。オブジェクトのドキュメントに記載する必要があります。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A class that uses unmanaged objects must dispose of them in its <ph id="ph1">`Finalize`</ph> method.</source>
          <target state="translated">管理されていないオブジェクトを使用するクラスでは、<ph id="ph1">`Finalize`</ph> メソッド内でそのオブジェクトを破棄する必要があります。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Finalize`</ph> destructor is a protected method that can be called only from the class it belongs to, or from derived classes.</source>
          <target state="translated"><ph id="ph1">`Finalize`</ph> デストラクターは、所属先のクラスまたは派生クラスからのみ呼び出し可能な保護されたメソッドです。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The system calls <ph id="ph1">`Finalize`</ph> automatically when an object is destroyed, so you should not explicitly call <ph id="ph2">`Finalize`</ph> from outside of a derived class's <ph id="ph3">`Finalize`</ph> implementation.</source>
          <target state="translated"><ph id="ph1">`Finalize`</ph> はオブジェクトが破棄されるときに自動的に呼び出されるため、派生クラスの <ph id="ph2">`Finalize`</ph> 実装の外部から <ph id="ph3">`Finalize`</ph> を明示的に呼び出す必要はありません。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Unlike <ph id="ph1">`Class_Terminate`</ph>, which executes as soon as an object is set to nothing, there is usually a delay between when an object loses scope and when Visual Basic calls the <ph id="ph2">`Finalize`</ph> destructor.</source>
          <target state="translated">オブジェクトが nothing に設定されるとすぐに実行される <ph id="ph1">`Class_Terminate`</ph> と異なり、通常、オブジェクトがスコープを失ってから Visual Basic が <ph id="ph2">`Finalize`</ph> デストラクターを呼び出すまでに遅延が発生します。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](../../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)]</ph> and later versions allow for a second kind of destructor, &lt;xref:System.IDisposable.Dispose%2A&gt;, which can be explicitly called at any time to immediately release resources.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](../../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)]</ph>以降のバージョンでは、2 つ目の一種のデストラクター、および&lt;xref:System.IDisposable.Dispose%2A&gt;、すぐにリソースを解放するには、いつでも明示的に呼び出すを&lt;/xref:System.IDisposable.Dispose%2A&gt;。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Finalize`</ph> destructor should not throw exceptions, because they cannot be handled by the application and can cause the application to terminate.</source>
          <target state="translated"><ph id="ph1">`Finalize`</ph> デストラクターからは例外をスローしません。これは、その例外をアプリケーションで処理できないために、アプリケーションが異常終了する可能性があるためです。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>How New and Finalize Methods Work in a Class Hierarchy</source>
          <target state="translated">クラス階層での New メソッドおよび Finalize メソッドの動作</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Whenever an instance of a class is created, the common language runtime (CLR) attempts to execute a procedure named <ph id="ph1">`New`</ph>, if it exists in that object.</source>
          <target state="translated">クラスのインスタンスが作成されると、そのオブジェクト内に <ph id="ph1">`New`</ph> という名前のプロシージャが存在する場合、共通言語ランタイム (CLR) はそのプロシージャを実行しようとします。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`New`</ph> is a type of procedure called a <ph id="ph2">`constructor`</ph> that is used to initialize new objects before any other code in an object executes.</source>
          <target state="translated"><ph id="ph1">`New`</ph> は、オブジェクトの他のコードを実行する前に新しいオブジェクトを初期化するために使用される、<ph id="ph2">`constructor`</ph>と呼ばれる種類のプロシージャです。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`New`</ph> constructor can be used to open files, connect to databases, initialize variables, and take care of any other tasks that need to be done before an object can be used.</source>
          <target state="translated"><ph id="ph1">`New`</ph> コンストラクターを使用すると、ファイルを開く、データベースに接続する、変数を初期化するなど、オブジェクトを使用する前に実行する必要があるタスクを管理できます。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>When an instance of a derived class is created, the <ph id="ph1">`Sub New`</ph> constructor of the base class executes first, followed by constructors in derived classes.</source>
          <target state="translated">派生クラスのインスタンスが作成されると、まず基本クラスの <ph id="ph1">`Sub New`</ph> コンストラクターが実行され、続いて派生クラスのコンストラクターが実行されます。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This happens because the first line of code in a <ph id="ph1">`Sub New`</ph> constructor uses the syntax <ph id="ph2">`MyBase.New()`</ph>to call the constructor of the class immediately above itself in the class hierarchy.</source>
          <target state="translated">このように動作するのは、<ph id="ph1">`Sub New`</ph> コンストラクターの最初のコード行では、<ph id="ph2">`MyBase.New()`</ph> 構文を使用して、クラス階層の自身のすぐ上位にあるクラスのコンストラクターを呼び出すためです。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Sub New`</ph> constructor is then called for each class in the class hierarchy until the constructor for the base class is reached.</source>
          <target state="translated"><ph id="ph1">`Sub New`</ph> コンストラクターはその後、基本クラスのコンストラクターに到達するまで、クラス階層のクラスごとに呼び出されます。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>At that point, the code in the constructor for the base class executes, followed by the code in each constructor in all derived classes and the code in the most derived classes is executed last.</source>
          <target state="translated">その時点で、基本クラスのコンストラクター内のコードが実行され、続いてすべての派生クラスの各コンストラクター内のコードが実行され、最後にほとんどの派生クラス内のコードが実行されます。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Constructors and Inheritance<ept id="p1">]</ept><bpt id="p2">(../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance.gif "</bpt>vaConstructorsInheritance<ept id="p2">")</ept></source>
          <target state="translated"><bpt id="p1">![</bpt>コンス トラクターと継承<ept id="p1">]</ept><bpt id="p2">(../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance.gif "</bpt>vaConstructorsInheritance<ept id="p2">")</ept></target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>When an object is no longer needed, the CLR calls the &lt;xref:System.Object.Finalize%2A&gt; method for that object before freeing its memory.</source>
          <target state="translated">CLR が呼び出すオブジェクトを不要になったとき、&lt;xref:System.Object.Finalize%2A&gt;のメモリを解放する前にそのオブジェクトのメソッドです&lt;/xref:System.Object.Finalize%2A&gt;。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Object.Finalize%2A&gt; method is called a <ph id="ph1">`destructor`</ph> because it performs cleanup tasks, such as saving state information, closing files and connections to databases, and other tasks that must be done before releasing the object.</source>
          <target state="translated">&lt;xref:System.Object.Finalize%2A&gt;メソッドが呼び出される、<ph id="ph1">`destructor`</ph>ファイルおよびデータベース、およびその他のオブジェクトを解放する前に行う必要があるタスクへの接続を閉じて状態情報の保存などのクリーンアップ タスクが実行されるためです&lt;/xref:System.Object.Finalize%2A&gt;。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Constructors Inheritance2<ept id="p1">]</ept><bpt id="p2">(../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance_2.gif "</bpt>vaConstructorsInheritance_2<ept id="p2">")</ept></source>
          <target state="translated"><bpt id="p1">![</bpt>コンス トラクター Inheritance2<ept id="p1">]</ept><bpt id="p2">(../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance_2.gif "</bpt>vaConstructorsInheritance_2<ept id="p2">")</ept></target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>IDisposable Interface</source>
          <target state="translated">IDisposable インターフェイス</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Class instances often control resources not managed by the CLR, such as Windows handles and database connections.</source>
          <target state="translated">クラスのインスタンスは、多くの場合、Windows ハンドルやデータベース接続など、CLR では管理されないリソースを制御します。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>These resources must be disposed of in the <ph id="ph1">`Finalize`</ph> method of the class, so that they will be released when the object is destroyed by the garbage collector.</source>
          <target state="translated">これらのリソースは、オブジェクトがガベージ コレクターによって破棄されるときに解放されるように、クラスの <ph id="ph1">`Finalize`</ph> メソッドで破棄する必要があります。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>However, the garbage collector destroys objects only when the CLR requires more free memory.</source>
          <target state="translated">ただし、ガベージ コレクターは、CLR でより多くの空きメモリが必要な場合にのみ、オブジェクトを破棄します。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This means that the resources may not be released until long after the object goes out of scope.</source>
          <target state="translated">つまり、オブジェクトがスコープ外になるまで、リソースが解放されない可能性があります。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>To supplement garbage collection, your classes can provide a mechanism to actively manage system resources if they implement the &lt;xref:System.IDisposable&gt; interface.</source>
          <target state="translated">ガベージ コレクションを補足するために、クラスが実装している場合、システム リソースを積極的に管理するためのメカニズムを提供できます、&lt;xref:System.IDisposable&gt;インターフェイス&lt;/xref:System.IDisposable&gt;。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.IDisposable&gt; has one method, &lt;xref:System.IDisposable.Dispose%2A&gt;, which clients should call when they finish using an object.</source>
          <target state="translated">&lt;xref:System.IDisposable&gt;1 つのメソッドを持つ&lt;xref:System.IDisposable.Dispose%2A&gt;、どのクライアントがオブジェクトを使用して終了するときに呼び出す必要があります&lt;/xref:System.IDisposable.Dispose%2A&gt;。&lt;/xref:System.IDisposable&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can use the &lt;xref:System.IDisposable.Dispose%2A&gt; method to immediately release resources and perform tasks such as closing files and database connections.</source>
          <target state="translated">使用することができます、&lt;xref:System.IDisposable.Dispose%2A&gt;をすぐにリソースを解放し、ファイルを閉じるなどのタスクを実行してデータベース接続&lt;/xref:System.IDisposable.Dispose%2A&gt;。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Unlike the <ph id="ph1">`Finalize`</ph> destructor, the &lt;xref:System.IDisposable.Dispose%2A&gt; method is not called automatically.</source>
          <target state="translated">異なり、<ph id="ph1">`Finalize`</ph>デストラクター、&lt;xref:System.IDisposable.Dispose%2A&gt;メソッドは自動的に呼び出されません&lt;/xref:System.IDisposable.Dispose%2A&gt;。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Clients of a class must explicitly call &lt;xref:System.IDisposable.Dispose%2A&gt; when you want to immediately release resources.</source>
          <target state="translated">クラスのクライアントを明示的に呼び出す必要があります&lt;xref:System.IDisposable.Dispose%2A&gt;をすぐにリソースを解放する場合します&lt;/xref:System.IDisposable.Dispose%2A&gt;。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Implementing IDisposable</source>
          <target state="translated">IDisposable の実装</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A class that implements the &lt;xref:System.IDisposable&gt; interface should include these sections of code:</source>
          <target state="translated">実装するクラス、&lt;xref:System.IDisposable&gt;インターフェイスは、次のコード セクションを含める必要があります:&lt;/xref:System.IDisposable&gt;</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>A field for keeping track of whether the object has been disposed:</source>
          <target state="translated">オブジェクトが破棄されているかどうかを追跡するためのフィールド。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>An overload of the &lt;xref:System.IDisposable.Dispose%2A&gt; that frees the class's resources.</source>
          <target state="translated">オーバー ロード、&lt;xref:System.IDisposable.Dispose%2A&gt;クラスのリソースを解放する&lt;/xref:System.IDisposable.Dispose%2A&gt;。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>This method should be called by the &lt;xref:System.IDisposable.Dispose%2A&gt; and <ph id="ph1">`Finalize`</ph> methods of the base class:</source>
          <target state="translated">このメソッドによって呼び出される、&lt;xref:System.IDisposable.Dispose%2A&gt;と<ph id="ph1">`Finalize`</ph>基本クラスのメソッド:&lt;/xref:System.IDisposable.Dispose%2A&gt;</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;xref:System.IDisposable.Dispose%2A&gt; that contains only the following code:</source>
          <target state="translated">実装&lt;xref:System.IDisposable.Dispose%2A&gt;次のコードのみを含む:&lt;/xref:System.IDisposable.Dispose%2A&gt;</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>An override of the <ph id="ph1">`Finalize`</ph> method that contains only the following code:</source>
          <target state="translated">次のコードのみを含む <ph id="ph1">`Finalize`</ph> メソッドのオーバーライド。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Deriving from a Class that Implements IDisposable</source>
          <target state="translated">IDisposable を実装するクラスからの派生</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>A class that derives from a base class that implements the &lt;xref:System.IDisposable&gt; interface does not need to override any of the base methods unless it uses additional resources that need to be disposed.</source>
          <target state="translated">実装する基本クラスから派生したクラス、&lt;xref:System.IDisposable&gt;インターフェイスは破棄する必要があるその他のリソースを使用しない限り、基本メソッドをオーバーライドする必要はありません&lt;/xref:System.IDisposable&gt;。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In that situation, the derived class should override the base class's <ph id="ph1">`Dispose(disposing)`</ph> method to dispose of the derived class's resources.</source>
          <target state="translated">その場合、派生クラスでは、派生クラスのリソースを破棄するように基本クラスの <ph id="ph1">`Dispose(disposing)`</ph> メソッドをオーバーライドする必要があります。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>This override must call the base class's <ph id="ph1">`Dispose(disposing)`</ph> method.</source>
          <target state="translated">このオーバーライドでは、基本クラスの <ph id="ph1">`Dispose(disposing)`</ph> メソッドを呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>A derived class should not override the base class's &lt;xref:System.IDisposable.Dispose%2A&gt; and <ph id="ph1">`Finalize`</ph> methods.</source>
          <target state="translated">派生クラスには、基本クラスのオーバーライドできません&lt;xref:System.IDisposable.Dispose%2A&gt;と<ph id="ph1">`Finalize`</ph>メソッド&lt;/xref:System.IDisposable.Dispose%2A&gt;。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>When those methods are called from an instance of the derived class, the base class's implementation of those methods call the derived class's override of the <ph id="ph1">`Dispose(disposing)`</ph> method.</source>
          <target state="translated">これらのメソッドが派生クラスのインスタンスから呼び出されると、基本クラスでのこれらのメソッドの実装によって、派生クラスでの <ph id="ph1">`Dispose(disposing)`</ph> メソッドのオーバーライドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Garbage Collection and the Finalize Destructor</source>
          <target state="translated">ガベージ コレクションと Finalize デストラクター</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> uses the <bpt id="p1">*</bpt>reference-tracing garbage collection<ept id="p1">*</ept> system to periodically release unused resources.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph>を使用して、<bpt id="p1">*</bpt>参照トレース ガベージ コレクション<ept id="p1">*</ept>システムを定期的に未使用のリソースを解放します。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Visual Basic 6.0 and earlier versions used a different system called <bpt id="p1">*</bpt>reference counting<ept id="p1">*</ept> to manage resources.</source>
          <target state="translated">Visual Basic 6.0 とそれ以前のバージョンの使用と呼ばれるさまざまなシステム<bpt id="p1">*</bpt>参照カウント<ept id="p1">*</ept>リソースを管理します。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Although both systems perform the same function automatically, there are a few important differences.</source>
          <target state="translated">どちらのシステムも同じ機能を自動的に実行しますが、いくつかの重要な違いがあります。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The CLR periodically destroys objects when the system determines that such objects are no longer needed.</source>
          <target state="translated">CLR は、不要と判断したオブジェクトを定期的に破棄します。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Objects are released more quickly when system resources are in short supply, and less frequently otherwise.</source>
          <target state="translated">オブジェクトは、システム リソースが不足したときには迅速に解放され、それ以外の場合には解放の頻度が低くなります。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The delay between when an object loses scope and when the CLR releases it means that, unlike with objects in Visual Basic 6.0 and earlier versions, you cannot determine exactly when the object will be destroyed.</source>
          <target state="translated">オブジェクトがスコープを失ってから CLR が解放するまでに遅延が発生します。つまり、Visual Basic 6.0 とそれ以前のバージョンのオブジェクトとは異なり、オブジェクトがいつ破棄されるかを正確に特定することはできません。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In such a situation, objects are said to have <bpt id="p1">*</bpt>non-deterministic lifetime<ept id="p1">*</ept>.</source>
          <target state="translated">このような場合、オブジェクトがあると言わ<bpt id="p1">*</bpt>不明確な有効期間<ept id="p1">*</ept>します。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>In most cases, non-deterministic lifetime does not change how you write applications, as long as you remember that the <ph id="ph1">`Finalize`</ph> destructor may not immediately execute when an object loses scope.</source>
          <target state="translated">ほとんどの場合、有効期間が不明確でもアプリケーションの作成方法は変わりません。ただし、オブジェクトがスコープを失ってもすぐには <ph id="ph1">`Finalize`</ph> デストラクターが実行されない可能性があることに留意する必要があります。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Another difference between the garbage-collection systems involves the use of <ph id="ph1">`Nothing`</ph>.</source>
          <target state="translated">ガベージ コレクション システム間の相違点にはこの他、<ph id="ph1">`Nothing`</ph> を使用することがあります。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>To take advantage of reference counting in Visual Basic 6.0 and earlier versions, programmers sometimes assigned <ph id="ph1">`Nothing`</ph> to object variables to release the references those variables held.</source>
          <target state="translated">Visual Basic 6.0 とそれ以前のバージョンの参照カウントを利用するために、プログラマはオブジェクト変数に <ph id="ph1">`Nothing`</ph> を割り当てて、オブジェクト変数が保持する参照を解放することがありました。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>If the variable held the last reference to the object, the object's resources were released immediately.</source>
          <target state="translated">変数がオブジェクトへの最後の参照を保持していた場合、オブジェクトのリソースは直ちに解放されました。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In later versions of Visual Basic, while there may be cases in which this procedure is still valuable, performing it never causes the referenced object to release its resources immediately.</source>
          <target state="translated">Visual Basic のそれ以降のバージョンでも、このプロシージャが有益な場合がありますが、実行しても、参照したオブジェクトによってリソースが直ちに解放されることはありません。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>To release resources immediately, use the object's &lt;xref:System.IDisposable.Dispose%2A&gt; method, if available.</source>
          <target state="translated">リソースを直ちに解放するには、オブジェクトの&lt;xref:System.IDisposable.Dispose%2A&gt;メソッドを使用可能な場合です&lt;/xref:System.IDisposable.Dispose%2A&gt;。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The only time you should set a variable to <ph id="ph1">`Nothing`</ph> is when its lifetime is long relative to the time the garbage collector takes to detect orphaned objects.</source>
          <target state="translated">変数を <ph id="ph1">`Nothing`</ph> に設定する必要があるのは、ガベージ コレクターが孤立したオブジェクトを検出するのに要する時間よりも、変数の有効期間が長い場合のみです。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">関連項目</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.IDisposable.Dispose%2A&gt;</source>
          <target state="translated">&lt;xref:System.IDisposable.Dispose%2A&gt;&lt;/xref:System.IDisposable.Dispose%2A&gt;</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Initialization and Termination of Components<ept id="p1">](http://msdn.microsoft.com/library/58444076-a9d2-4c91-b3f6-0e180dc0695d)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>コンポーネントの初期化と終了<ept id="p1">](http://msdn.microsoft.com/library/58444076-a9d2-4c91-b3f6-0e180dc0695d)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>New Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/new-operator.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>New 演算子<ept id="p1">](../../../../visual-basic/language-reference/operators/new-operator.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](http://msdn.microsoft.com/library/a17b0066-71c2-4ba4-9822-8e19332fc213)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>アンマネージ リソースをクリーンアップします。<ept id="p1">](http://msdn.microsoft.com/library/a17b0066-71c2-4ba4-9822-8e19332fc213)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Nothing<ept id="p1">](../../../../visual-basic/language-reference/nothing.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Nothing<ept id="p1">](../../../../visual-basic/language-reference/nothing.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>