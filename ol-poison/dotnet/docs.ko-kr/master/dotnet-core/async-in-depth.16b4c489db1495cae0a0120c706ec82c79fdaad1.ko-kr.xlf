<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c8ff0f81054feddb4ee7042926c817de525034f9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\async-in-depth.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4a59cc5bc6b7d68b057f06623b3cc2f09799a72f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6ad464a4806ef09df47b4d06900d8102ffaf398b</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file async-in-depth.16b4c489db1495cae0a0120c706ec82c79fdaad1.ko-kr.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Async in depth</source>
          <target state="translated">비동기에 대한 자세한 설명</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>In-depth explanation of how asynchronous code works in .NET</source>
          <target state="translated">.NET에서 비동기 코드가 작동하는 방식에 대한 자세한 설명</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, .NET Standard</source>
          <target state="translated">.NET, .NET Core, .NET 표준</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Async in depth</source>
          <target state="translated">비동기에 대한 자세한 설명</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</source>
          <target state="translated">.NET 태스크 기반 비동기 모델을 사용하면 I/O 및 CPU 바인딩된 비동기 코드를 간단하게 작성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The model is exposed by the <ph id="ph1">`Task`</ph> and <ph id="ph2">`Task&lt;T&gt;`</ph> types and the <ph id="ph3">`async`</ph> and <ph id="ph4">`await`</ph> language keywords.</source>
          <target state="translated">모델은 <ph id="ph1">`Task`</ph> 및 <ph id="ph2">`Task&lt;T&gt;`</ph> 형식과 <ph id="ph3">`async`</ph> 및 <ph id="ph4">`await`</ph> 언어 키워드로 표시됩니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This article explains how to use .NET async and provides insight into the async framework used under the covers.</source>
          <target state="translated">이 문서에서는 .NET 비동기를 사용하는 방법을 설명하고 백그라운드에서 사용되는 비동기 프레임워크에 대한 통찰을 제공합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Task and Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph></source>
          <target state="translated">Task 및 Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Tasks are constructs used to implement what is known as the <bpt id="p1">[</bpt>Promise Model of Concurrency<ept id="p1">](https://en.wikipedia.org/wiki/Futures_and_promises)</ept>.</source>
          <target state="translated">태스크는 <bpt id="p1">[</bpt>동시성 약속 모델<ept id="p1">](https://en.wikipedia.org/wiki/Futures_and_promises)</ept>을 구현하는 데 사용되는 구문입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</source>
          <target state="translated">간단히 말해서, 나중에 작업이 완료될 것이라는 "약속"을 제공하여 클린 API로 약속을 조정할 수 있게 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task`</ph> represents a single operation which does not return a value.</source>
          <target state="translated"><ph id="ph1">`Task`</ph> - 값을 반환하지 않는 작업 하나를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task&lt;T&gt;`</ph> represents a single operation which returns a value of type <ph id="ph2">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Task&lt;T&gt;`</ph> - <ph id="ph2">`T`</ph> 형식의 값을 반환하는 작업 하나를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It’s important to reason about tasks as abstractions of work happening asynchronously, and <bpt id="p1">*</bpt>not<ept id="p1">*</ept> an abstraction over threading.</source>
          <target state="translated">스레딩에 대한 추상화가 <bpt id="p1">*</bpt>아니라<ept id="p1">*</ept> 비동기적으로 수행되는 작업의 추상화로 태스크에 대해 추론하는 것이 중요합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</source>
          <target state="translated">기본적으로 태스크는 현재 스레드에 대해 실행되며 해당하는 경우 운영 체제에 작업을 위임합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Optionally, tasks can be be explicitly requested to run on a separate thread via the <ph id="ph1">`Task.Run`</ph> API.</source>
          <target state="translated">필요에 따라 <ph id="ph1">`Task.Run`</ph> API를 통해 별도 스레드에서 실행되도록 태스크를 명시적으로 요청할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of <ph id="ph1">`Task&lt;T&gt;`</ph>) of a task.</source>
          <target state="translated">태스크는 태스크의 결과 값(<ph id="ph1">`Task&lt;T&gt;`</ph>의 경우)을 모니터링, 대기 및 액세스하기 위한 API 프로토콜을 표시합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Language integration, with the <ph id="ph1">`await`</ph> keyword, provides a higher-level abstraction for using tasks.</source>
          <target state="translated"><ph id="ph1">`await`</ph> 키워드가 있는 언어 통합에서는 태스크 사용을 위한 상위 수준 추상화를 제공합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Using <ph id="ph1">`await`</ph> allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</source>
          <target state="translated"><ph id="ph1">`await`</ph>를 사용하면 태스크가 완료될 때까지 해당 호출자에게 제어가 양도되므로 태스크가 실행되는 동안 응용 프로그램 또는 서비스에서 유용한 작업을 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</source>
          <target state="translated">태스크가 완료된 후에는 코드에서 콜백 또는 이벤트를 사용하여 실행을 계속할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The language and task API integration does that for you.</source>
          <target state="translated">언어 및 태스크 API 통합에서 해당 작업을 자동으로 수행합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If you’re using <ph id="ph1">`Task&lt;T&gt;`</ph>, the <ph id="ph2">`await`</ph> keyword will additionally “unwrap” the value returned when the Task is complete.</source>
          <target state="translated"><ph id="ph1">`Task&lt;T&gt;`</ph>를 사용하는 경우 <ph id="ph2">`await`</ph> 키워드는 태스크가 완료될 때 반환되는 값을 추가로 "래핑 해제"합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The details of how this works are explained further below.</source>
          <target state="translated">작동 방식에 대한 자세한 내용은 아래에서 자세히 설명합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can learn more about tasks and the different ways to interact with them in the <bpt id="p1">[</bpt>Task-based Asynchronous Pattern (TAP) Article<ept id="p1">](https://msdn.microsoft.com/library/hh873175.aspx)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>TAP(태스크 기반 비동기 패턴) 문서<ept id="p1">](https://msdn.microsoft.com/library/hh873175.aspx)</ept>에서 태스크 및 태스크를 조작하는 다양한 방법에 대해 자세히 알아볼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Deeper Dive into Tasks for an I/O-Bound Operation</source>
          <target state="translated">I/O 바인딩된 작업에 대한 태스크 심층 분석</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following section describes a 10,000 foot view of what happens with a typical async I/O call.</source>
          <target state="translated">다음 섹션에서는 일반적인 비동기 I/O 호출에서 발생하는 결과에 대해 대략적으로 설명합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Let's start with a couple examples.</source>
          <target state="translated">몇 가지 예부터 살펴보겠습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The first example calls an async method and returns an active task, likely yet to complete.</source>
          <target state="translated">첫 번째 예제에서는 비동기 메서드를 호출하고 아직 완료되지 않았을 가능성이 큰 활성 태스크를 반환합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The second example adds the use of he <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords to operate on the task.</source>
          <target state="translated">두 번째 예제에서는 태스크에 적용할 <ph id="ph1">`async`</ph> 및 <ph id="ph2">`await`</ph> 키워드 사용을 추가합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The call to <ph id="ph1">`GetStringAsync()`</ph> calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</source>
          <target state="translated"><ph id="ph1">`GetStringAsync()`</ph> 호출은 네이티브 네트워킹 라이브러리에 대한 P/Invoke interop 호출에 도달할 때까지 하위 수준 .NET 라이브러리를 호출(다른 비동기 메서드 호출)합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The native library may subsequently call into a System API call (such as <ph id="ph1">`write()`</ph> to a socket on Linux).</source>
          <target state="translated">이후에 네이티브 라이브러리는 시스템 API 호출(예: Linux의 소켓에 대한 <ph id="ph1">`write()`</ph>)을 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A task object will be created at the native/managed boundary, possibly using <bpt id="p1">[</bpt>TaskCompletionSource<ept id="p1">](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>TaskCompletionSource<ept id="p1">](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))</ept>를 사용하여 네이티브/관리 경계에 태스크 개체가 생성됩니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</source>
          <target state="translated">태스크 개체가 계층을 통해 위로 전달되며, 초기 호출자에게 반환될 때까지 작업되거나 바로 반환될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In the second example above, a <ph id="ph1">`Task&lt;T&gt;`</ph> object will be returned from <ph id="ph2">`GetStringAsync`</ph>.</source>
          <target state="translated">위의 두 번째 예제에서는 <ph id="ph1">`Task&lt;T&gt;`</ph> 개체가 <ph id="ph2">`GetStringAsync`</ph>에서 반환됩니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The use of the <ph id="ph1">`await`</ph> keyword causes the method to return a newly created task object.</source>
          <target state="translated"><ph id="ph1">`await`</ph> 키워드를 사용하면 메서드가 새로 만든 태스크 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Control returns to the caller from this location in the <ph id="ph1">`GetFirstCharactersCountAsync`</ph> method.</source>
          <target state="translated"><ph id="ph1">`GetFirstCharactersCountAsync`</ph> 메서드의 이 위치에서 호출자에게 제어가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The methods and properties of the <bpt id="p1">[</bpt>Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Threading.Tasks.Task%601)</ept> object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</source>
          <target state="translated"><bpt id="p1">[</bpt>Task<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Threading.Tasks.Task%601)</ept> 개체의 메서드 및 속성을 사용하면 GetFirstCharactersCountAsync의 나머지 코드가 실행될 때 완료되는 태스크의 진행률을 호출자가 모니터링할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as <ph id="ph1">`/net`</ph> in the Linux Kernel).</source>
          <target state="translated">시스템 API 호출 후에 요청은 이제 커널 공간에 있으며, OS의 네트워킹 하위 시스템(예: Linux 커널의 <ph id="ph1">`/net`</ph>)로 진행합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Here the OS will handle the networking request <bpt id="p1">*</bpt>asynchronously<ept id="p1">*</ept>.</source>
          <target state="translated">여기서 OS는 네트워킹 요청을 <bpt id="p1">*</bpt>비동기적으로<ept id="p1">*</ept> 처리합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and <bpt id="p1">*</bpt>then<ept id="p1">*</ept> a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</source>
          <target state="translated">세부 정보는 사용하는 OS에 따라 다를 수 있지만(장치 드라이버 호출을 런타임으로 다시 전송되는 신호로 예약하거나 장치 드라이버를 호출한 <bpt id="p1">*</bpt>다음<ept id="p1">*</ept> 신호가 다시 전송될 수 있음) 결국 런타임에서 네트워킹 요청이 진행 중이라는 알림을 받습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</source>
          <target state="translated">이번에는 장치 드라이버에 대한 작업이 예약되거나, 진행 중이거나, 이미 완료(요청이 이미 "네트워크"를 통해 전송됨)되었지만 이 모든 작업이 비동기적으로 수행되므로 장치 드라이버에서 다른 작업을 즉시 처리할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</source>
          <target state="translated">예를 들어 Windows에서 OS 스레드는 네트워크 장치 드라이버를 호출하고 작업을 나타내는 IRP(인터럽트 요청 패킷)를 통해 네트워킹 작업을 수행하도록 요청합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</source>
          <target state="translated">장치 드라이버는 IRP를 수신하고 네트워크를 호출한 다음 IRP를 "보류 중"으로 표시하고 OS에 다시 반환합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</source>
          <target state="translated">이제 OS 스레드에서 IRP가 "보류 중"임을 알고 있으므로 이 작업에 대해 수행할 작업이 없으며 다른 작업을 수행하는 데 사용될 수 있도록 다시 "반환"됩니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</source>
          <target state="translated">요청이 수행되고 장치 드라이버를 통해 데이터가 반환되면 인터럽트를 통해 수신된 새 데이터를 CPU에 알려줍니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</source>
          <target state="translated">이 인터럽트의 처리 방법은 OS에 따라 다르지만 결국 데이터가 시스템 interop 호출에 도달할 때까지 OS를 통해 전달됩니다. 예를 들어 Linux에서는 인터럽트 처리기가 OS를 통해 비동기적으로 데이터를 위로 전달하기 위해 IRQ의 아래쪽 절반을 예약합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Note that this <bpt id="p1">*</bpt>also<ept id="p1">*</ept> happens asynchronously!</source>
          <target state="translated">이 작업도 <bpt id="p1">*</bpt>역시<ept id="p1">*</ept> 비동기적으로 수행됩니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The result is queued up until the next available thread is able execute the async method and "unwrap" the result of the completed task.</source>
          <target state="translated">다음 사용 가능한 스레드가 비동기 메서드를 실행하고 완료된 태스크의 결과를 "래핑 해제"할 수 있을 때까지 결과가 큐에 유지됩니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Throughout this entire process, a key takeaway is that <bpt id="p1">**</bpt>no thread is dedicated to running the task<ept id="p1">**</ept>.</source>
          <target state="translated">이 전체 프로세스의 요점은 <bpt id="p1">**</bpt>태스크 실행 전용 스레드가 없다<ept id="p1">**</ept>는 것입니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Although work is executed in some context (i.e. the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to <bpt id="p1">*</bpt>waiting<ept id="p1">*</ept> for data from the request to come back.</source>
          <target state="translated">일부 컨텍스트에서 작업이 실행되기는 하지만(즉, OS에서 데이터를 장치 드라이버로 전달하고 인터럽트에 응답해야 함) 요청에서 데이터가 반환될 때까지 <bpt id="p1">*</bpt>대기<ept id="p1">*</ept>하는 전용 스레드는 없습니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</source>
          <target state="translated">이렇게 하면 시스템에서 일부 I/O 호출이 완료될 때까지 대기하는 것보다 훨씬 더 많은 작업량을 처리할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</source>
          <target state="translated">위의 프로세스를 위해 수행할 작업이 많아 보일 수도 있지만 벽시계 시간으로 측정할 때 실제 I/O 작업을 수행하는 데 걸리는 시간보다 훨씬 짧습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Although not at all precise, a potential timeline for such a call would look like this:</source>
          <target state="translated">정확하지는 않지만 이러한 호출의 잠재적인 타임라인은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>0-1————————————————————————————————————————————————–2-3</source>
          <target state="translated">0-1————————————————————————————————————————————————–2-3</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Time spent from points <ph id="ph1">`0`</ph> to <ph id="ph2">`1`</ph> is everything up until an async method yields control to its caller.</source>
          <target state="translated"><ph id="ph1">`0`</ph> 지점에서 <ph id="ph2">`1`</ph> 지점 사이의 소요 시간은 비동기 메서드가 호출자에 제어를 양도할 때까지 걸리는 시간입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Time spent from points <ph id="ph1">`1`</ph> to <ph id="ph2">`2`</ph> is the time spent on I/O, with no CPU cost.</source>
          <target state="translated"><ph id="ph1">`1`</ph> 지점에서 <ph id="ph2">`2`</ph> 지점 사이의 소요 시간은 CPU 비용 없이 I/O에 걸리는 시간입니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Finally, time spent from points <ph id="ph1">`2`</ph> to <ph id="ph2">`3`</ph> is passing control back (and potentially a value) to the async method, at which point it is executing again.</source>
          <target state="translated">마지막으로, <ph id="ph1">`2`</ph> 지점에서 <ph id="ph2">`3`</ph> 지점 사이의 소요 시간은 제어(및 잠재적으로 값)가 비동기 메서드로 다시 전달되는 시간으로, 이때 메서드가 다시 실행됩니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>What does this mean for a server scenario?</source>
          <target state="translated">서버 시나리오에서는 어떤 의미가 있을까요?</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This model works well with a typical server scenario workload.</source>
          <target state="translated">이 모델은 일반적인 서버 시나리오 작업에도 잘 맞습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</source>
          <target state="translated">완료되지 않은 태스크를 차단하는 전용 스레드가 없기 때문에 서버 스레드 풀이 훨씬 더 많은 웹 요청을 처리할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Consider two servers: one that runs async code, and one that does not.</source>
          <target state="translated">비동기 코드를 실행하는 서버와 비동기 코드를 실행하지 않는 서버가 있다고 가정해 보세요.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For the purpose of this example, each server only has 5 threads available to service requests.</source>
          <target state="translated">이 예제를 위해 각 서버에서 서비스 요청에 사용할 수 있는 스레드가 5개뿐이라고 가정해봅시다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Note that these numbers are imaginarily small and serve only in a demonstrative context.</source>
          <target state="translated">이러한 개수는 비현실적으로 적은 개수이며 데모 컨텍스트에서만 사용됩니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Assume both servers receive 6 concurrent requests.</source>
          <target state="translated">두 서버가 모두 6개의 동시 요청을 받는다고 가정해봅시다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Each request performs an I/O operation.</source>
          <target state="translated">각 요청에서 I/O 작업을 수행합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The server <bpt id="p1">*</bpt>without<ept id="p1">*</ept> async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</source>
          <target state="translated">비동기 코드가 <bpt id="p1">*</bpt>없는<ept id="p1">*</ept> 서버는 5개의 스레드 중 하나가 I/O 바인딩된 작업을 완료하고 응답을 쓸 때까지 6번째 요청을 큐에 유지해야 합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</source>
          <target state="translated">20번째 요청이 도달할 때쯤에는 큐가 너무 길어져서 서버 속도가 저하되기 시작할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The server <bpt id="p1">*</bpt>with<ept id="p1">*</ept> async code running on it still queues up the 6th request, but because it uses <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph>, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</source>
          <target state="translated">비동기 코드가 실행되고 <bpt id="p1">*</bpt>있는<ept id="p1">*</ept> 서버도 여섯 번째 요청을 큐에 유지하지만 <ph id="ph1">`async`</ph> 및 <ph id="ph2">`await`</ph>를 사용하기 때문에 I/O 바인딩된 작업이 완료될 때가 아니라 시작될 때 해당 스레드가 각각 해제됩니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</source>
          <target state="translated">20번째 요청이 도달할 때쯤에는 들어오는 요청의 큐가 훨씬 더 적으며(큐에 요청이 있는 경우에도) 서버 속도가 저하되지 않습니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Although this is a contrived example, it works in a very similar fashion in the real world.</source>
          <target state="translated">가상의 예제이지만 실제 환경에서도 매우 유사한 방식으로 작동합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In fact, you can expect a server to be able to handle an order of magnitude more requests using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> than if it were dedicating a thread for each request it receives.</source>
          <target state="translated">실제로 서버가 <ph id="ph1">`async`</ph> 및 <ph id="ph2">`await`</ph>를 사용할 경우 받는 각 요청에 전용 스레드를 사용하는 경우에 비해 훨씬 더 많은 요청을 처리할 것을 예상할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>What does this mean for client scenario?</source>
          <target state="translated">클라이언트 시나리오에서는 어떤 의미가 있을까요?</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The biggest gain for using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> for a client app is an increase in responsiveness.</source>
          <target state="translated">클라이언트 앱에 <ph id="ph1">`async`</ph> 및 <ph id="ph2">`await`</ph>를 사용할 경우의 가장 큰 이점은 응답성 증가입니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph>.</source>
          <target state="translated">스레드를 수동으로 생성하여 앱의 응답성을 개선할 수도 있지만 스레드 생성 작업은 <ph id="ph1">`async`</ph> 및 <ph id="ph2">`await`</ph>를 사용하는 것보다 비용이 많이 듭니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</source>
          <target state="translated">특히 모바일 게임 등의 경우 I/O와 관련된 UI 스레드에 대한 영향을 최소화하는 것이 중요합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</source>
          <target state="translated">무엇보다도, I/O 바인딩된 작업은 CPU 시간이 거의 필요하지 않으므로 유용하지 않은 작업에 전체 CPU 스레드를 전용으로 지정할 경우 리소스를 잘못 사용하는 것입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with <ph id="ph1">`async`</ph> methods, and does not require extra work (such as calling a thread-safe delegate).</source>
          <target state="translated">또한 UI 스레드에 작업을 디스패치하는 경우(예: UI 업데이트) <ph id="ph1">`async`</ph> 메서드를 사용하면 간단하며 추가 작업(예: 스레드로부터 안전한 대리자 호출)이 필요하지 않습니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Deeper Dive into Task and Task<ph id="ph1">&lt;T&gt;</ph> for a CPU-Bound Operation</source>
          <target state="translated">CPU 바인딩된 작업에 대한 Task 및 Task<ph id="ph1">&lt;T&gt;</ph> 심층 분석</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>CPU-bound <ph id="ph1">`async`</ph> code is a bit different than I/O-bound <ph id="ph2">`async`</ph> code.</source>
          <target state="translated">CPU 바인딩된 <ph id="ph1">`async`</ph> 코드는 I/O 바인딩된 <ph id="ph2">`async`</ph> 코드와 약간 다릅니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</source>
          <target state="translated">CPU에서 작업이 수행되기 때문에 스레드를 계산 전용으로 지정할 방법이 없습니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The use of <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</source>
          <target state="translated"><ph id="ph1">`async`</ph> 및 <ph id="ph2">`await`</ph>를 사용하면 깔끔하게 백그라운드 스레드를 조작하고 비동기 메서드 호출자를 응답 가능한 상태로 유지할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Note that this does not provide any protection for shared data.</source>
          <target state="translated">이 경우 공유 데이터는 보호되지 않습니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If you are using shared data, you will still need to apply an appropriate synchronization strategy.</source>
          <target state="translated">공유 데이터를 사용하는 경우 적절한 동기화 전략을 적용해야 합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Here's a 10,000 foot view of a CPU-bound async call:</source>
          <target state="translated">CPU 바인딩된 비동기 호출에 대한 개략적인 보기입니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CalculateResult()`</ph> executes on the thread it was called on.</source>
          <target state="translated"><ph id="ph1">`CalculateResult()`</ph>가 호출된 스레드에서 실행됩니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When it calls <ph id="ph1">`Task.Run`</ph>, it queues the expensive CPU-bound operation, <ph id="ph2">`DoExpensiveCalculation()`</ph>, on the thread pool and receives a <ph id="ph3">`Task&lt;int&gt;`</ph> handle.</source>
          <target state="translated"><ph id="ph1">`Task.Run`</ph>을 호출할 때 비용이 많이 드는 CPU 바인딩된 작업 <ph id="ph2">`DoExpensiveCalculation()`</ph>을 스레드 풀의 큐에 넣고 <ph id="ph3">`Task&lt;int&gt;`</ph> 핸들을 받습니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`DoExpensiveCalculation()`</ph> is eventually run concurrently on the next available thread, likely on another CPU core.</source>
          <target state="translated"><ph id="ph1">`DoExpensiveCalculation()`</ph>이 결국 다른 CPU 코어에 있을 가능성이 큰 다음 사용 가능한 스레드에서 동시에 실행됩니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>It's possible to do concurrent work while <ph id="ph1">`DoExpensiveCalculation()`</ph> is busy on another thread, because the thread which called <ph id="ph2">`CalculateResult()`</ph> is still executing.</source>
          <target state="translated"><ph id="ph2">`CalculateResult()`</ph>를 호출한 스레드가 여전히 실행되고 있으므로 <ph id="ph1">`DoExpensiveCalculation()`</ph>이 다른 스레드에서 진행 중인 동안 동시 작업을 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Once <ph id="ph1">`await`</ph> is encountered, the execution of <ph id="ph2">`CalculateResult()`</ph> is yielded to its caller, allowing other work to be done with the current thread while <ph id="ph3">`DoExpensiveCalculation()`</ph> is churning out a result.</source>
          <target state="translated"><ph id="ph1">`await`</ph>가 발생하면 <ph id="ph2">`CalculateResult()`</ph> 실행이 해당 호출자에게 양도되어 <ph id="ph3">`DoExpensiveCalculation()`</ph>이 결과를 생성하는 동안 현재 스레드에서 다른 작업을 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Once it has finished, the result is queued up to run on the main thread.</source>
          <target state="translated">완료되면 결과가 주 스레드에서 실행하기 위해 큐에 배치됩니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Eventually, the main thread will return to executing <ph id="ph1">`CalculateResult()`</ph>, at which point it will have the result of <ph id="ph2">`DoExpensiveCalculation()`</ph>.</source>
          <target state="translated">결국 주 스레드가 <ph id="ph1">`CalculateResult()`</ph> 실행으로 돌아가고, 이때 <ph id="ph2">`DoExpensiveCalculation()`</ph> 결과를 갖게 됩니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Why does async help here?</source>
          <target state="translated">이때 비동기가 왜 도움이 될까요?</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> are the best practice managing CPU-bound work when you need responsiveness.</source>
          <target state="translated"><ph id="ph1">`async`</ph> 및 <ph id="ph2">`await`</ph>는 응답성이 필요할 때 CPU 바인딩된 작업을 관리하는 모범 사례입니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>There are multiple patterns for using async with CPU-bound work.</source>
          <target state="translated">CPU 바인딩된 작업에 비동기를 사용하는 여러 가지 패턴이 있습니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>It's important to note that there is a small cost to using async and it's not recommended for tight loops.</source>
          <target state="translated">비동기 사용 시 작은 비용이 발생하며 타이트 루프에는 권장되지 않습니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>It's up to you to determine how you write your code around this new capability.</source>
          <target state="translated">이 새로운 기능과 관련된 코드 작성 방법은 사용자가 결정할 사항입니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>