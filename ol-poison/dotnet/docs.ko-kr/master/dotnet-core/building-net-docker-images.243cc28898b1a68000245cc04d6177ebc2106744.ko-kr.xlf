<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8cc784c267e9ca85ae110f8c92e0191f6fee6596</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\docker\building-net-docker-images.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4ed453aeba7aa4e4a4396090ec77d1f55f235a9b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">197e21704e8d6d8187a514bd5bd70904aedf06c9</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file building-net-docker-images.243cc28898b1a68000245cc04d6177ebc2106744.ko-kr.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Building .NET Core Docker Images</source>
          <target state="translated">.NET Core Docker 이미지 작성</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Understanding Docker images and .NET Core</source>
          <target state="translated">Docker 이미지 및 .NET Core 이해</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, Docker</source>
          <target state="translated">.NET, .NET Core, Docker</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Building Docker Images for .NET Core Applications</source>
          <target state="translated">.NET Core 응용 프로그램에 대한 Docker 이미지 작성</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In order to get an understanding of how to use .NET Core and Docker together, we must first get to know the different Docker images that are offered and when is the right use case for them.</source>
          <target state="translated">.NET Core와 Docker를 함께 사용하는 방법을 이해하려면 먼저 제공되는 다양한 Docker 이미지와 올바른 사용 시기에 대해 알고 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Here we will walk through the variations offered, build an ASP.NET Core Web API, use the Yeoman Docker tools to create a debuggable container as well as peek at how Visual Studio Code can assist in the process.</source>
          <target state="translated">여기서는 제공되는 변형 이미지를 살펴보고, ASP.NET Core Web API를 빌드하며, Yeoman Docker 도구를 사용하여 디버깅 가능한 컨테이너를 만들 뿐만 아니라 Visual Studio Code가 이 프로세스에 어떻게 도움이 되는지를 살펴봅니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Docker Image Optimizations</source>
          <target state="translated">Docker 이미지 최적화</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When building Docker images for developers, we focused on three main scenarios:</source>
          <target state="translated">개발자를 위한 Docker 이미지를 작성할 때 다음 세 가지 주요 시나리오를 중점적으로 고려했습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Images used to develop .NET Core apps</source>
          <target state="translated">.NET Core 앱을 개발하는 데 사용되는 이미지</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Images used to build .NET Core apps</source>
          <target state="translated">.NET Core 앱을 빌드하는 데 사용되는 이미지</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Images used to run .NET Core apps</source>
          <target state="translated">.NET Core 앱을 실행하는 데 사용되는 이미지</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Why three images?</source>
          <target state="translated">왜 이 세 가지 이미지가 중요할까요?</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>When developing, building and running containerized applications, we have different priorities.</source>
          <target state="translated">컨테이너화된 응용 프로그램을 개발, 빌드 및 실행할 때 서로 다른 우선 순위가 있습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Development:<ept id="p1">**</ept>  How fast can you iterate changes, and the ability to debug the changes.</source>
          <target state="translated"><bpt id="p1">**</bpt>개발:<ept id="p1">**</ept>  얼마나 빨리 변경을 반복할 수 있는지 그리고 변경 내용을 디버그하는 기능이 중요합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The size of the image isn't as important, rather can you make changes to your code and see them quickly.</source>
          <target state="translated">이미지의 크기는 중요하지 않으며 코드를 변경하고 변경 내용을 신속하게 확인할 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Some of our tools, like <bpt id="p1">[</bpt>yo docker<ept id="p1">](https://aka.ms/yodocker)</ept> for use in VS Code use this image during development time.</source>
          <target state="translated"><bpt id="p1">[</bpt>yo docker<ept id="p1">](https://aka.ms/yodocker)</ept>와 같이 VS Code에서 사용하는 일부 도구에서 개발하는 동안 이 이미지를 사용합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Build:<ept id="p1">**</ept> What's needed to compile your app.</source>
          <target state="translated"><bpt id="p1">**</bpt>빌드:<ept id="p1">**</ept> 앱을 컴파일하는 데 무엇이 필요한지가 중요합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This includes the compiler and any other dependencies to optimize the binaries.</source>
          <target state="translated">여기에는 컴파일러와 이진 파일을 최적화하기 위한 다른 모든 종속성이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This image isn't the image you deploy, rather it's an image you use to build the content you place into a production image.</source>
          <target state="translated">이 이미지는 배포하는 이미지가 아니며, 프로덕션 이미지에 배치하는 콘텐츠를 빌드하는 데 사용되는 이미지입니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This image would be used in your continuous integration, or build environment.</source>
          <target state="translated">이 이미지는 연속 통합 또는 빌드 환경에서 사용됩니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For instance, rather than installing all the dependencies directly on a build agent, the build agent would instance a build image to compile the application with all the dependencies required to build the app contained within the image.</source>
          <target state="translated">예를 들어 모든 종속성을 빌드 에이전트에 직접 설치하는 대신 빌드 에이전트는 빌드 이미지를 인스턴스화하여 이미지 내에 포함된 앱을 빌드하는 데 필요한 모든 종속성을 사용하여 응용 프로그램을 컴파일합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Your build agent only needs to know how to run this Docker image.</source>
          <target state="translated">빌드 에이전트는 이 Docker 이미지를 실행하는 방법만 알고 있으면 됩니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Production:<ept id="p1">**</ept> How fast you can deploy and start your image.</source>
          <target state="translated"><bpt id="p1">**</bpt>프로덕션:<ept id="p1">**</ept> 이미지를 배포하고 시작할 수 있는 속도가 중요합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This image is small so it can quickly travel across the network from your Docker Registry to your Docker hosts.</source>
          <target state="translated">이 이미지는 작기 때문에 Docker 레지스트리에서 Docker 호스트 사이의 네트워크를 신속하게 이동할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The contents are ready to run enabling the fastest time from Docker run to processing results.</source>
          <target state="translated">콘텐츠를 실행할 준비가 되면 Docker 실행부터 결과 처리까지 가장 빠른 시간에 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In the immutable Docker model, there's no need for dynamic compilation of code.</source>
          <target state="translated">변경이 불가능한 Docker 모델에서는 코드를 동적으로 컴파일할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The content you place in this image would be limited to the binaries and content needed to run the application.</source>
          <target state="translated">이 이미지에 배치되는 콘텐츠는 이진 파일과 응용 프로그램을 실행하는 데 필요한 콘텐츠로 제한됩니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For example, the published output using <ph id="ph1">`dotnet publish`</ph> which contains the compiled binaries, images, .js and .css files.</source>
          <target state="translated">컴파일된 이진 파일, 이미지, .js 및 .css 파일을 포함하는 <ph id="ph1">`dotnet publish`</ph>를 사용하는 게시된 출력을 예로 들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Over time, you'll see images that contain pre-jitted packages.</source>
          <target state="translated">시간이 지남에 따라 미리 JIT 컴파일된 패키지를 포함하는 이미지가 표시됩니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Though there are multiple versions of the .NET Core image, they all share one or more layers.</source>
          <target state="translated">여러 버전의 .NET Core 이미지가 있지만 모두 하나 이상의 레이어를 공유합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The amount of disk space needed to store or the delta to pull from your registry is much smaller than the whole because all of the images share the same base layer and potentially others.</source>
          <target state="translated">모든 이미지가 동일한 기본 레이어와 잠재적으로 다른 레이어를 공유하기 때문에 저장하는 데 필요한 디스크 공간의 크기나 레지스트리에서 끌어오는 델타가 전체보다 훨씬 더 작습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Docker image variations</source>
          <target state="translated">Docker 이미지 변형</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>To achieve the goals above, we provide image variants under <bpt id="p1">[</bpt>microsoft/dotnet<ept id="p1">](https://hub.docker.com/r/microsoft/dotnet/)</ept>.</source>
          <target state="translated">위의 목표를 달성하기 위해 <bpt id="p1">[</bpt>microsoft/dotnet<ept id="p1">](https://hub.docker.com/r/microsoft/dotnet/)</ept>에서 이미지 변형을 제공합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`microsoft/dotnet:&lt;version&gt;-sdk`</ph> : that is <bpt id="p1">**</bpt>microsoft/dotnet:1.0.0-preview2-sdk<ept id="p1">**</ept>, this image contains the .NET Core SDK which includes the .NET Core and Command Line Tools (CLI).</source>
          <target state="translated"><ph id="ph1">`microsoft/dotnet:&lt;version&gt;-sdk`</ph>: 즉, <bpt id="p1">**</bpt>microsoft/dotnet:1.0.0-preview2-sdk<ept id="p1">**</ept>로, 이 이미지는 .NET Core 및 CLI(명령줄 도구)가 포함된 .NET Core SDK를 포함합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This image maps to the <bpt id="p1">**</bpt>development scenario<ept id="p1">**</ept>.</source>
          <target state="translated">이 이미지는 <bpt id="p1">**</bpt>개발 시나리오<ept id="p1">**</ept>에 매핑됩니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You would use this image for local development, debugging and unit testing.</source>
          <target state="translated">로컬 개발, 디버깅 및 단위 테스트에 이 이미지를 사용합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For example, all the development you do, before you check in your code.</source>
          <target state="translated">예를 들어 코드 체크 인 전의 모든 개발 작업에 사용합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This image can also be used for your <bpt id="p1">**</bpt>build<ept id="p1">**</ept> scenarios.</source>
          <target state="translated">이 이미지는 <bpt id="p1">**</bpt>빌드<ept id="p1">**</ept> 시나리오에도 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`microsoft/dotnet:&lt;version&gt;-core`</ph> : that is <bpt id="p1">**</bpt>microsoft/dotnet:1.0.0-core<ept id="p1">**</ept>, image which runs <bpt id="p2">[</bpt>portable .NET Core applications<ept id="p2">](../deploying/index.md)</ept> and it is optimized for running your application in <bpt id="p3">**</bpt>production<ept id="p3">**</ept>.</source>
          <target state="translated"><ph id="ph1">`microsoft/dotnet:&lt;version&gt;-core`</ph>: 즉, <bpt id="p1">**</bpt>microsoft/dotnet:1.0.0-core<ept id="p1">**</ept>로, <bpt id="p2">[</bpt>이식 가능한 .NET Core 응용 프로그램<ept id="p2">](../deploying/index.md)</ept>을 실행하는 이미지이며 <bpt id="p3">**</bpt>프로덕션<ept id="p3">**</ept>에서 응용 프로그램을 실행하는 데 맞게 최적화되어 있습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It does not contain the SDK, and is meant to take the optimized output of <ph id="ph1">`dotnet publish`</ph>.</source>
          <target state="translated">SDK를 포함하지 않으며 <ph id="ph1">`dotnet publish`</ph>의 최적화된 출력을 수행하기 위한 것입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The portable runtime is well suited for Docker container scenarios as running multiple containers benefit from shared image layers.</source>
          <target state="translated">이식 가능한 런타임은 실행 중인 여러 컨테이너에서 공유 이미지 레이어를 활용하는 경우 Docker 컨테이너 시나리오에 적합합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Alternative images</source>
          <target state="translated">대체 이미지</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In addition to the optimized scenarios of development, build and production, we provide additional images:</source>
          <target state="translated">개발, 빌드 및 프로덕션에 최적화된 시나리오 외에도 추가 이미지를 제공합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`microsoft/dotnet:&lt;version&gt;-onbuild`</ph> : that is <bpt id="p1">**</bpt>microsoft/dotnet:1.0.0-preview2-onbuild<ept id="p1">**</ept>, contains <bpt id="p2">[</bpt>ONBUILD<ept id="p2">](https://docs.docker.com/engine/reference/builder/#/onbuild)</ept> triggers.</source>
          <target state="translated"><ph id="ph1">`microsoft/dotnet:&lt;version&gt;-onbuild`</ph>: 즉, <bpt id="p1">**</bpt>microsoft/dotnet:1.0.0-preview2-onbuild<ept id="p1">**</ept>로, <bpt id="p2">[</bpt>ONBUILD<ept id="p2">](https://docs.docker.com/engine/reference/builder/#/onbuild)</ept> 트리거를 포함합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The build will <bpt id="p1">[</bpt>COPY<ept id="p1">](https://docs.docker.com/engine/reference/builder/#/copy)</ept> your application, run <ph id="ph1">`dotnet restore`</ph> and create an <bpt id="p2">[</bpt>ENTRYPOINT<ept id="p2">](https://docs.docker.com/engine/reference/builder/#/entrypoint)</ept> <ph id="ph2">`dotnet run`</ph> instruction to run the application when the Docker image is run.</source>
          <target state="translated">빌드는 응용 프로그램을 <bpt id="p1">[</bpt>COPY<ept id="p1">](https://docs.docker.com/engine/reference/builder/#/copy)</ept>하고, <ph id="ph1">`dotnet restore`</ph>를 실행하며, Docker 이미지가 실행될 때 응용 프로그램을 실행하는 <bpt id="p2">[</bpt>ENTRYPOINT<ept id="p2">](https://docs.docker.com/engine/reference/builder/#/entrypoint)</ept> <ph id="ph2">`dotnet run`</ph> 명령을 만듭니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>While not an optimized image for production, some may find it useful to simply copy their source code into an image and run it.</source>
          <target state="translated">프로덕션에 최적화된 이미지는 아니지만 단순히 소스 코드를 이미지에 복사하여 실행할 때 유용한 경우는 있습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`microsoft/dotnet:&lt;version&gt;-core-deps`</ph> : that is <bpt id="p1">**</bpt>microsoft/dotnet:1.0.0-core-deps<ept id="p1">**</ept>, if you wish to run self-contained applications use this image.</source>
          <target state="translated"><ph id="ph1">`microsoft/dotnet:&lt;version&gt;-core-deps`</ph>: 즉, <bpt id="p1">**</bpt>microsoft/dotnet:1.0.0-core-deps<ept id="p1">**</ept>로, 자체 포함 응용 프로그램을 실행하려는 경우 이 이미지를 사용합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>It contains the operating system with all of the native dependencies needed by .NET Core.</source>
          <target state="translated">.NET Core에 필요한 모든 기본 종속성과 함께 운영 체제를 포함합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This image can also be used as a base image for your own custom CoreFX or CoreCLR builds.</source>
          <target state="translated">이 이미지는 고유한 사용자 지정 CoreFX 또는 CoreCLR 빌드에 대한 기본 이미지로 사용할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>While the <bpt id="p1">**</bpt>onbuild<ept id="p1">**</ept> variant is optimized to simply place your code in an image and run it, this image is optimized to have only the operating system dependencies required to run .NET Core apps that have the .NET Runtime packaged with the application.</source>
          <target state="translated"><bpt id="p1">**</bpt>onbuild<ept id="p1">**</ept> 변형이 단순히 코드를 이미지에 배치하고 실행하도록 최적화된 반면 이 이미지는 .NET 런타임이 응용 프로그램과 함께 패키지로 제공되는 .NET Core 앱을 실행하는 데 필요한 운영 체제 종속성만 갖도록 최적화되어 있습니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This image isn't generally optimized for running multiple .NET Core containers on the same host, as each image carries the .NET Core runtime within the application, and you will not benefit from image layering.</source>
          <target state="translated">각 이미지가 응용 프로그램 내에서 .NET Core 런타임을 전달하기 때문에 이 이미지는 일반적으로 동일한 호스트에서 여러 .NET Core 컨테이너를 실행하는 데 최적화되어 있지 않으며 이미지 레이어를 활용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Latest versions of each variant:</source>
          <target state="translated">각 변형의 최신 버전:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`microsoft/dotnet`</ph> or <ph id="ph2">`microsoft/dotnet:latest`</ph> (includes SDK)</source>
          <target state="translated"><ph id="ph1">`microsoft/dotnet`</ph> 또는 <ph id="ph2">`microsoft/dotnet:latest`</ph>(SDK 포함)</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Here is a list of the images after a <ph id="ph1">`docker pull &lt;imagename&gt;`</ph> on a development machine to show the various sizes.</source>
          <target state="translated">다음은 개발 컴퓨터에서 다양한 크기를 보여 주는 <ph id="ph1">`docker pull &lt;imagename&gt;`</ph> 다음의 이미지 목록입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Notice, the development/build variant, <ph id="ph1">`microsoft/dotnet:1.0.0-preview2-sdk`</ph> is larger as it contains the SDK to develop and build your application.</source>
          <target state="translated">개발/빌드 변형인 <ph id="ph1">`microsoft/dotnet:1.0.0-preview2-sdk`</ph>는 응용 프로그램을 개발하고 빌드하는 SDK를 포함하기 때문에 더 큽니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The production variant, <ph id="ph1">`microsoft/dotnet:core`</ph> is smaller, as it only contains the .NET Core runtime.</source>
          <target state="translated">프로덕션 변형인 <ph id="ph1">`microsoft/dotnet:core`</ph>는 .NET Core 런타임만 포함하기 때문에 더 작습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The minimal image capable of being used on Linux, <ph id="ph1">`core-deps`</ph>, is quite smaller, however your application will need to copy a private copy of the .NET Runtime with it.</source>
          <target state="translated">Linux에서 사용할 수 있는 최소 이미지인 <ph id="ph1">`core-deps`</ph>는 훨씬 더 작지만 응용 프로그램에서 이 이미지를 사용하여 .NET 런타임의 개인 복사본을 복사해야 합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Since containers are already private isolation barriers, you will lose that optimization when running multiple dotnet based containers.</source>
          <target state="translated">컨테이너가 이미 개인 격리 장벽이기 때문에 여러 dotnet 기반 컨테이너를 실행할 경우 최적화가 손실됩니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">필수 조건</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To build and run, you'll need a few things installed:</source>
          <target state="translated">빌드하고 실행하려면 다음과 같은 몇 가지 항목을 설치해야 합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET Core<ept id="p1">](http://dot.net)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>.NET Core<ept id="p1">](http://dot.net)</ept></target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Docker<ept id="p1">](https://www.docker.com/products/docker)</ept> to run your Docker containers locally</source>
          <target state="translated">Docker 컨테이너를 로컬로 실행하기 위한 <bpt id="p1">[</bpt>Docker<ept id="p1">](https://www.docker.com/products/docker)</ept></target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Yeoman generator for ASP.NET<ept id="p1">](https://github.com/omnisharp/generator-aspnet)</ept> for creating the Web API application</source>
          <target state="translated">Web API 응용 프로그램을 만들기 위한 <bpt id="p1">[</bpt>ASP.NET용 Yeoman 생성기<ept id="p1">](https://github.com/omnisharp/generator-aspnet)</ept></target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Yeoman generator for Docker<ept id="p1">](http://aka.ms/yodocker)</ept> from Microsoft</source>
          <target state="translated">Microsoft의 <bpt id="p1">[</bpt>Docker용 Yeoman 생성기<ept id="p1">](http://aka.ms/yodocker)</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Install the Yeoman generators for ASP.NET Core and Docker using npm</source>
          <target state="translated">npm을 사용하여 ASP.NET Core 및 Docker용 Yeoman 생성기 설치</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This sample will be using <bpt id="p1">[</bpt>Visual Studio Code<ept id="p1">](http://code.visualstudio.com)</ept> for the editor.</source>
          <target state="translated">이 샘플에서는 <bpt id="p1">[</bpt>Visual Studio Code<ept id="p1">](http://code.visualstudio.com)</ept>를 편집기에 사용합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Creating the Web API application</source>
          <target state="translated">Web API 응용 프로그램 만들기</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For a reference point, before we containerize the application, first run the application locally.</source>
          <target state="translated">참조 지점으로 응용 프로그램을 컨테이너화하기 전에 먼저 로컬로 응용 프로그램을 실행합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The finished application is located in the <bpt id="p1">[</bpt>dotnet/core-docs repository on GitHub<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/docker/building-net-docker-images)</ept>.</source>
          <target state="translated">완성된 응용 프로그램은 <bpt id="p1">[</bpt>GitHub의 dotnet/core-docs 리포지토리<ept id="p1">](https://github.com/dotnet/docs/tree/master/samples/core/docker/building-net-docker-images)</ept>에 있습니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Create a directory for your application.</source>
          <target state="translated">응용 프로그램에 대한 디렉터리를 만듭니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Open a command or terminal session in that directory and use the ASP.NET Yeoman generator by typing the following:</source>
          <target state="translated">해당 디렉터리에서 명령 또는 터미널 세션을 열고 다음을 입력하여 ASP.NET Yeoman 생성기를 사용합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Select <bpt id="p1">**</bpt>Web API Application<ept id="p1">**</ept> and type <bpt id="p2">**</bpt>api<ept id="p2">**</ept> for the name of the app and tap enter.</source>
          <target state="translated"><bpt id="p1">**</bpt>Web API 응용 프로그램<ept id="p1">**</ept>을 선택하고 앱의 이름으로 <bpt id="p2">**</bpt>api<ept id="p2">**</ept>를 입력한 다음 &lt;Enter&gt; 키를 탭합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Once the application is scaffolded, change to the <ph id="ph1">`/api`</ph> directory and restore the NuGet dependencies using <ph id="ph2">`dotnet restore`</ph>.</source>
          <target state="translated">응용 프로그램이 스캐폴드되면 <ph id="ph1">`/api`</ph> 디렉터리로 변경하고 <ph id="ph2">`dotnet restore`</ph>를 사용하여 NuGet 종속성을 복원합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Test the application using <ph id="ph1">`dotnet run`</ph> and browsing to <bpt id="p1">**</bpt>http://localhost:5000/api/values<ept id="p1">**</ept></source>
          <target state="translated"><ph id="ph1">`dotnet run`</ph>을 사용하고 <bpt id="p1">**</bpt>http://localhost:5000/api/values<ept id="p1">**</ept> 로 이동하여 응용 프로그램을 테스트합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`Ctrl+C`</ph> to stop the application.</source>
          <target state="translated"><ph id="ph1">`Ctrl+C`</ph>를 사용하여 응용 프로그램을 중지합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Adding Docker support</source>
          <target state="translated">Docker 지원 추가</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Adding Docker support to the project is achieved using the Yeoman generator from Microsoft.</source>
          <target state="translated">Microsoft용 Yeoman 생성기를 사용하여 프로젝트에 Docker 지원을 추가할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>It currently supports .NET Core, Node.js and Go projects by creating a Dockerfile and scripts that help build and run projects inside containers.</source>
          <target state="translated">현재 컨테이너 내에서 프로젝트를 빌드하고 실행하는 데 도움이 되는 Dockerfile 및 스크립트를 만들어 .NET Core, Node.js 및 Go 프로젝트를 지원합니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Visual Studio Code specific files are also added (launch.json, tasks.json) for editor debugging and command palette support.</source>
          <target state="translated">편집기 디버깅 및 명령 팔레트를 지원하기 위해 Visual Studio Code 관련 파일(launch.json, tasks.json)도 추가됩니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Select <ph id="ph1">`.NET Core`</ph> as the project type</source>
          <target state="translated"><ph id="ph1">`.NET Core`</ph>를 프로젝트 형식으로 선택</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`rtm`</ph> for the version of .NET Core</source>
          <target state="translated"><ph id="ph1">`rtm`</ph>: .NET Core의 버전</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Y`</ph> the project uses a web server</source>
          <target state="translated"><ph id="ph1">`Y`</ph>: 프로젝트에서 웹 서버 사용</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`5000`</ph> is the port the Web API application is listening on (http://localhost:5000)</source>
          <target state="translated"><ph id="ph1">`5000`</ph>: Web API 응용 프로그램에서 수신 대기하는 포트(http://localhost:5000)</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`api`</ph> for the image name</source>
          <target state="translated"><ph id="ph1">`api`</ph>: 이미지 이름</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`api`</ph> for the service name</source>
          <target state="translated"><ph id="ph1">`api`</ph>: 서비스 이름</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`api`</ph> for the compose project</source>
          <target state="translated"><ph id="ph1">`api`</ph>: 작성 프로젝트</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Y`</ph> to overwrite the current Dockerfile</source>
          <target state="translated"><ph id="ph1">`Y`</ph>: 현재 Dockerfile 덮어쓰기</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>When the generator is complete, the following files are added to the project</source>
          <target state="translated">생성기가 완료되면 다음 파일이 프로젝트에 추가됩니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>.vscode/launch.json</source>
          <target state="translated">.vscode/launch.json</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Dockerfile.debug</source>
          <target state="translated">Dockerfile.debug</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Dockerfile</source>
          <target state="translated">Dockerfile</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>docker-compose.debug.yml</source>
          <target state="translated">docker-compose.debug.yml</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>docker-compose.yml</source>
          <target state="translated">docker-compose.yml</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>dockerTask.ps1</source>
          <target state="translated">dockerTask.ps1</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>dockerTask.sh</source>
          <target state="translated">dockerTask.sh</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>.vscode/tasks.json</source>
          <target state="translated">.vscode/tasks.json</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The generator creates two Dockerfiles.</source>
          <target state="translated">생성자는 두 개의 Dockerfile을 만듭니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Dockerfile.debug<ept id="p1">**</ept> - this file is based on the <bpt id="p2">**</bpt>microsoft/dotnet:1.0.0-preview2-sdk<ept id="p2">**</ept> image which if you note from the list of image variants, includes the SDK, CLI and .NET Core and will be the image used for development and debugging (F5).</source>
          <target state="translated"><bpt id="p1">**</bpt>Dockerfile.debug<ept id="p1">**</ept> - 이 파일은 이미지 변형 목록에서 확인할 경우 SDK, CLI 및 .NET Core를 포함하고 개발 및 디버깅(F5)에 사용되는 이미지인 <bpt id="p2">**</bpt>microsoft/dotnet:1.0.0-preview2-sdk<ept id="p2">**</ept> 이미지를 기반으로 합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Including all of these components produces a larger image with a size roughly of 540MB.</source>
          <target state="translated">이러한 모든 구성 요소를 포함하면 약 540MB의 더 큰 이미지가 생성됩니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Dockerfile<ept id="p1">**</ept> - this image is the release image based on <bpt id="p2">**</bpt>microsoft/dotnet:1.0.0-core<ept id="p2">**</ept> and should be used for production.</source>
          <target state="translated"><bpt id="p1">**</bpt>Dockerfile<ept id="p1">**</ept> - 이 이미지는 <bpt id="p2">**</bpt>microsoft/dotnet:1.0.0-core<ept id="p2">**</ept>를 기반으로 하는 릴리스 이미지이며 프로덕션에 사용됩니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This image when built is approximately 253 MB.</source>
          <target state="translated">빌드할 때 이 이미지는 약 253MB입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Creating the Docker images</source>
          <target state="translated">Docker 이미지 만들기</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Using the <ph id="ph1">`dockerTask.sh`</ph> or <ph id="ph2">`dockerTask.ps1`</ph> script, we can build or compose the image and container for the <bpt id="p1">**</bpt>api<ept id="p1">**</ept> application for a specific environment.</source>
          <target state="translated"><ph id="ph1">`dockerTask.sh`</ph> 또는 <ph id="ph2">`dockerTask.ps1`</ph> 스크립트를 사용하여 특정 환경에서 <bpt id="p1">**</bpt>api<ept id="p1">**</ept> 응용 프로그램에 대한 이미지 및 컨테이너를 빌드하거나 작성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Build the <bpt id="p1">**</bpt>debug<ept id="p1">**</ept> image by running the following command.</source>
          <target state="translated">다음 명령을 실행하여 <bpt id="p1">**</bpt>debug<ept id="p1">**</ept> 이미지를 빌드합니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The image will build the ASP.NET application, run <ph id="ph1">`dotnet restore`</ph>, add the debugger to the image, set an <ph id="ph2">`ENTRYPOINT`</ph> and finally copy the app to the image.</source>
          <target state="translated">이 이미지는 ASP.NET 응용 프로그램을 빌드하고 <ph id="ph1">`dotnet restore`</ph>를 실행하며 디버거를 이미지에 추가하고 <ph id="ph2">`ENTRYPOINT`</ph>를 설정한 다음 마지막으로 이미지에 앱을 복사합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The result is a Docker image named <bpt id="p1">*</bpt>api<ept id="p1">*</ept> with a <ph id="ph1">`TAG`</ph> of <bpt id="p2">*</bpt>debug<ept id="p2">*</ept>.</source>
          <target state="translated">결과는 <ph id="ph1">`TAG`</ph>가 <bpt id="p2">*</bpt>debug<ept id="p2">*</ept>인 <bpt id="p1">*</bpt>api<ept id="p1">*</ept>라는 Docker 이미지입니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>See the images on the machine using <ph id="ph1">`docker images`</ph>.</source>
          <target state="translated"><ph id="ph1">`docker images`</ph>를 사용하여 컴퓨터의 이미지를 확인하세요.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Another way to generate the image and run the application within the Docker container is to open the application in Visual Studio Code and use the debugging tools.</source>
          <target state="translated">이미지를 생성하고 Docker 컨테이너 내에서 응용 프로그램을 실행하는 또 다른 방법은 Visual Studio Code에서 응용 프로그램을 열고 디버깅 도구를 사용하는 것입니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Select the debugging icon in the View Bar on the left side of VS Code.</source>
          <target state="translated">VS Code의 왼쪽에 있는 보기 표시줄에서 디버깅 아이콘을 선택합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>vscode debugging icon</source>
          <target state="translated">vscode 디버깅 아이콘</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Then tap the play icon or F5 to generate the image and start the application within the container.</source>
          <target state="translated">그런 다음 재생 아이콘이나 &lt;F5&gt; 키를 탭하여 이미지를 생성하고 컨테이너 내에서 응용 프로그램을 시작합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The Web API will be launched using your default web browser at http://localhost:5000.</source>
          <target state="translated">Web API가 http://localhost:5000에서 기본 웹 브라우저를 사용하여 시작됩니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>VSCode Docker Tools Debug</source>
          <target state="translated">VSCode Docker 도구 디버그</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>You may set break points in your application, step through, etc. just as if the application was running locally on your development machine as opposed to inside the container.</source>
          <target state="translated">마치 응용 프로그램이 컨테이너 내부가 아닌 개발 컴퓨터에서 로컬로 실행되는 것처럼 응용 프로그램에서 중단점을 설정하고 단계별로 실행하는 등의 작업을 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The benefit to debugging within the container is this is the same image that would be deployed to a production environment.</source>
          <target state="translated">컨테이너 내에서 디버깅하는 장점은 프로덕션 환경에 배포되는 것과 동일한 이미지가 사용된다는 점입니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Creating the release or production image requires simply running the command from the terminal passing the <ph id="ph1">`release`</ph> environment name.</source>
          <target state="translated">릴리스 또는 프로덕션 이미지를 만들려면 <ph id="ph1">`release`</ph> 환경 이름을 전달하여 터미널에서 명령을 실행하기만 하면 됩니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The command creates the image based on the smaller <bpt id="p1">**</bpt>microsoft/dotnet:core<ept id="p1">**</ept> base image, <bpt id="p2">[</bpt>EXPOSE<ept id="p2">](https://docs.docker.com/engine/reference/builder/#/expose)</ept> port 5000, sets the <bpt id="p3">[</bpt>ENTRYPOINT<ept id="p3">](https://docs.docker.com/engine/reference/builder/#/entrypoint)</ept> for <ph id="ph1">`dotnet api.dll`</ph> and copies it to the <ph id="ph2">`/app`</ph> directory.</source>
          <target state="translated">이 명령은 더 작은 <bpt id="p1">**</bpt>microsoft/dotnet:core<ept id="p1">**</ept> 기본 이미지를 기반으로 이미지를 만들고, 포트 5000을 <bpt id="p2">[</bpt>EXPOSE<ept id="p2">](https://docs.docker.com/engine/reference/builder/#/expose)</ept> <ph id="ph1">`dotnet api.dll`</ph>에 대한 <bpt id="p3">[</bpt>ENTRYPOINT<ept id="p3">](https://docs.docker.com/engine/reference/builder/#/entrypoint)</ept> 설정하며, <ph id="ph2">`/app`</ph> 디렉터리에 이 이미지를 복사합니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>There is no debugger, SDK or <ph id="ph1">`dotnet restore`</ph> resulting in a much smaller image.</source>
          <target state="translated">훨씬 더 작은 이미지를 생성하는 디버거, SDK 또는 <ph id="ph1">`dotnet restore`</ph>가 없습니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The image is named <bpt id="p1">**</bpt>api<ept id="p1">**</ept> with a <ph id="ph1">`TAG`</ph> of <bpt id="p2">**</bpt>latest<ept id="p2">**</ept>.</source>
          <target state="translated">이미지 이름은 <ph id="ph1">`TAG`</ph>가 <bpt id="p2">**</bpt>latest<ept id="p2">**</ept>인 <bpt id="p1">**</bpt>api<ept id="p1">**</ept>입니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">요약</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Using the Docker generator to add the necessary files to our Web API application made the process simple to create the development and production versions of the images.</source>
          <target state="translated">Docker 생성기를 사용하여 Web API 응용 프로그램에 필요한 파일을 추가하면 이미지의 개발 및 프로덕션 버전을 만드는 프로세스가 간단해집니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The tooling is cross platform by also providing a PowerShell script to accomplish the same results on Windows and Visual Studio Code integration providing step through debugging of the application within the container.</source>
          <target state="translated">도구는 컨테이너 내에서 응용 프로그램의 단계별 실행 디버깅을 제공하는 Windows 및 Visual Studio Code 통합에서 동일한 결과를 얻도록 하는 PowerShell 스크립트도 제공하여 플랫폼 간 도구입니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>By understanding the image variants and the target scenarios, you can optimize your inner-loop development process, while achieving optimized images for production deployments.</source>
          <target state="translated">이미지 변형 및 대상 시나리오를 이해하면 프로덕션 배포에 최적화된 이미지를 얻는 동시에 내부 루프 개발 프로세스를 최적화할 수 있습니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>