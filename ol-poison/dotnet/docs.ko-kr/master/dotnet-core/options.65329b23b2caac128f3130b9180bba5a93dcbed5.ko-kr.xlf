<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a2a9fe356a0b2e9cf9415714bc01b77ea86229fc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\options.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e7ed328ee4fc3ad1c060537e6e61b2ccbfdca11</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9843036ea6c346b0a75b08c6d3e1e5a955c63372</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file options.65329b23b2caac128f3130b9180bba5a93dcbed5.ko-kr.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">정규식 옵션</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">정규식 옵션</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">정규식 옵션</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</source>
          <target state="translated">기본적으로 입력 문자열을 정규식 패턴의 리터럴 문자와 비교할 때는 대/소문자를 구분하고, 정규식 패턴의 공백은 리터럴 공백 문자로 해석되며, 정규식의 캡처링 그룹은 명시적 및 암시적으로 명명됩니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</source>
          <target state="translated">정규식 옵션을 지정하여 기본 정규식 동작의 이러한 측면과 몇 가지 다른 측면을 수정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern matching method as a <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> enumeration value.</source>
          <target state="translated">다음 테이블에 나열되어 있는 이러한 옵션은 정규식 패턴의 일부로 인라인으로 포함되거나, <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 클래스 생성자 또는 고정 패턴 일치 메서드에 <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 열거형 값으로 제공될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>RegexOptions member</source>
          <target state="translated">RegexOptions 멤버</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Inline character</source>
          <target state="translated">인라인 문자</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Effect</source>
          <target state="translated">효과</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>없음<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">사용할 수 없음</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Use default behavior.</source>
          <target state="translated">기본 동작을 사용합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Default options<ept id="p1">](#default-options)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>기본 옵션<ept id="p1">](#default-options)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>i<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>i<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Use case-insensitive matching.</source>
          <target state="translated">대/소문자를 구분하지 않는 일치를 사용합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Case-insensitive matching<ept id="p1">](#case-insensitive-matching)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>대/소문자를 구분하지 않는 일치<ept id="p1">](#case-insensitive-matching)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>m<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Use multiline mode, where <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> match the beginning and end of each line (instead of the beginning and end of the input string).</source>
          <target state="translated">여러 줄 모드를 사용합니다. 여기서 <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> 및 <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept>는 각 줄의 시작 부분 및 끝 부분과 일치합니다(입력 문자열의 시작 부분 및 끝 부분 대신).</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Multiline mode<ept id="p1">](#multiline-mode)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>여러 줄 모드<ept id="p1">](#multiline-mode)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>s<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>s<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Use single-line mode, where the period (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) matches every character (instead of every character except <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>).</source>
          <target state="translated">한 줄 모드를 사용합니다. 여기서 마침표(<bpt id="p1">**</bpt>.<ept id="p1">**</ept>)는 모든 문자와 일치합니다(<bpt id="p2">**</bpt>\n<ept id="p2">**</ept>을 제외한 모든 문자 대신).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Single-line mode<ept id="p1">](#single-line-mode)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>한 줄 모드<ept id="p1">](#single-line-mode)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>n<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>n<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Do not capture unnamed groups.</source>
          <target state="translated">명명되지 않은 그룹을 캡처하지 않습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The only valid captures are explicitly named or numbered groups of the form <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</source>
          <target state="translated">유효한 캡처만이 <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> 형식의 명시적으로 명명되거나 번호가 매겨진 그룹입니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Explicit captures only<ept id="p1">](#explicit-captures-only)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>명시적 캡처만 해당<ept id="p1">](#explicit-captures-only)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">사용할 수 없음</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Compile the regular expression to an assembly.</source>
          <target state="translated">정규식을 어셈블리로 컴파일합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Compiled regular expressions<ept id="p1">](#compiled-regular-expressions)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>컴파일된 정규식<ept id="p1">](#compiled-regular-expressions)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>x<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>x<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Exclude unescaped white space from the pattern, and enable comments after a number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>).</source>
          <target state="translated">이스케이프되지 않은 공백을 패턴에서 제외하고 숫자 기호(<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) 뒤에 주석을 사용하도록 설정합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Ignore white space<ept id="p1">](#ignore-white-space)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>공백 무시<ept id="p1">](#ignore-white-space)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">사용할 수 없음</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Change the search direction.</source>
          <target state="translated">검색 방향을 변경합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Search moves from right to left instead of from left to right.</source>
          <target state="translated">검색이 왼쪽에서 오른쪽으로 대신 오른쪽에서 왼쪽으로 이동합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Right-to-left mode<ept id="p1">](#right-to-left-mode)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>오른쪽에서 왼쪽 모드<ept id="p1">](#right-to-left-mode)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">사용할 수 없음</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Enable ECMAScript-compliant behavior for the expression.</source>
          <target state="translated">식에 대해 ECMAScript와 호환되는 동작을 사용하도록 설정합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>ECMAScript matching behavior<ept id="p1">](#ecmascript-matching-behavior)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>ECMAScript 일치 동작<ept id="p1">](#ecmascript-matching-behavior)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">사용할 수 없음</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Ignore cultural differences in language.</source>
          <target state="translated">언어의 문화권 차이를 무시합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Comparison using the invariant culture<ept id="p1">](#comparison-using-the-invariant-culture)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>고정 문화권을 사용한 비교<ept id="p1">](#comparison-using-the-invariant-culture)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Specifying the options</source>
          <target state="translated">옵션 지정</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You can specify options for regular expressions in one of three ways:</source>
          <target state="translated">정규식에 대한 옵션은 다음과 같은 세 가지 방법 중 하나로 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter of a <bpt id="p2">[</bpt>System.Text.RegularExpressions.Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor such as <bpt id="p3">[</bpt>Regex.Regex(String, RegexOptions)<ept id="p3">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions))</ept> or static (Shared in Visual Basic) pattern-matching method, such as  <bpt id="p4">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</source>
          <target state="translated"><bpt id="p3">[</bpt>Regex.Regex (String, RegexOptions)<ept id="p3">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions))</ept>와 같은 <bpt id="p2">[</bpt>System.Text.RegularExpressions.Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 클래스 생성자의 <bpt id="p1">*</bpt>options<ept id="p1">*</ept> 매개 변수에서 또는 <bpt id="p4">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>과 같은 고정(Visual Basic의 경우 공유) 패턴 일치 메서드에서 가능합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter is a bitwise OR combination of <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> enumerated values.</source>
          <target state="translated"><bpt id="p1">*</bpt>옵션<ept id="p1">*</ept> 매개 변수는 <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 열거된 값의 비트 OR 조합입니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>When options are supplied to a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> instance by using the <bpt id="p2">*</bpt>options<ept id="p2">*</ept> parameter of a class constructor, the options are are assigned to the <bpt id="p3">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property.</source>
          <target state="translated">클래스 생성자의 <bpt id="p2">*</bpt>options<ept id="p2">*</ept> 매개 변수를 사용하여 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 인스턴스에 옵션을 제공하면 해당 옵션이 <bpt id="p3">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 속성에 할당됩니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>However, the <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property does not reflect inline options in the regular expression pattern itself.</source>
          <target state="translated">그러나 <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 속성은 정규식 패턴 자체에 인라인 옵션을 반영하지는 않습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">다음 예제에서 이에 대해 설명합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter of the <bpt id="p2">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">이 예제에서는 <bpt id="p2">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> 메서드의 <bpt id="p1">*</bpt>options<ept id="p1">*</ept> 매개 변수를 사용하여 대/소문자를 구분하지 않는 일치를 사용하도록 설정하고 문자 "d"로 시작하는 단어를 식별할 때 패턴 공백을 무시합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>By applying inline options in a regular expression pattern with the syntax <bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept> 구문을 사용하여 정규식 패턴에 인라인 옵션을 적용합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</source>
          <target state="translated">이 옵션은 옵션이 정의된 지점에서 패턴의 끝 부분까지 또는 다른 인라인 옵션에 의해 옵션이 정의되지 않은 지점까지 패턴에 적용됩니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Note that the <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> instance does not reflect these inline options.</source>
          <target state="translated"><bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 인스턴스의 <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 속성은 이러한 인라인 옵션을 반영하지 않습니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Miscellaneous constructs in regular expressions<ept id="p1">](miscellaneous.md)</ept> topic.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>정규식의 기타 구문<ept id="p1">](miscellaneous.md)</ept> 항목을 참조하세요.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">다음 예제에서 이에 대해 설명합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">이 예제에서는 인라인 옵션을 사용하여 대/소문자를 구분하지 않는 일치를 사용하도록 설정하고 문자 "d"로 시작하는 단어를 식별할 때 패턴 공백을 무시합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>By applying inline options in a particular grouping construct in a regular expression pattern with the syntax <bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> 구문을 사용하여 정규식 패턴의 특정 그룹화 구문에 인라인 옵션을 적용합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</source>
          <target state="translated">옵션 집합 앞에 기호가 없으면 집합이 설정되고, 옵션 집합 앞에 빼기 기호가 있으면 집합이 해제됩니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>(<bpt id="p1">**</bpt>?<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</source>
          <target state="translated">는 옵션의 사용 여부에 따라 필요한 언어 구문의 고정 부분입니다. 이 옵션은 해당 그룹에만 적용됩니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>정규식의 그룹화 구문<ept id="p1">](grouping.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">다음 예제에서 이에 대해 설명합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">이 예제에서는 그룹화 구문에 인라인 옵션을 사용하여 대/소문자를 구분하지 않는 일치를 사용하도록 설정하고 문자 "d"로 시작하는 단어를 식별할 때 패턴 공백을 무시합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>If options are specified inline, a minus sign (-) before an option or set of options turns off those options.</source>
          <target state="translated">옵션이 인라인으로 지정된 경우 옵션 또는 옵션 집합 앞에 빼기 기호(-)가 있으면 해당 옵션이 해제됩니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For example, the inline construct <bpt id="p1">**</bpt>(?ix-ms)<ept id="p1">**</ept> turns on the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> and <bpt id="p3">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> options and turns off the <bpt id="p4">[</bpt>RegexOptions.Multiline<ept id="p4">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> and <bpt id="p5">[</bpt>RegexOptions.Singleline<ept id="p5">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> options.</source>
          <target state="translated">예를 들어, 인라인 구문 <bpt id="p1">**</bpt>(?ix-ms)<ept id="p1">**</ept>이 <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> 및 <bpt id="p3">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> 옵션을 켜고 <bpt id="p4">[</bpt>RegexOptions.Multiline<ept id="p4">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 및 <bpt id="p5">[</bpt>는 RegexOptions.Singleline<ept id="p5">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> 옵션을 끕니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>All regular expression options are turned off by default.</source>
          <target state="translated">모든 정규식 옵션은 기본적으로 해제되어 있습니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If the regular expression options specified in the options parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</source>
          <target state="translated">생성자 또는 메서드 호출의 options 매개 변수에 지정된 정규식 옵션이 정규식 패턴에 인라인으로 지정된 옵션과 충돌하는 경우 인라인 옵션이 사용됩니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The following five regular expression options can be set both with the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter and inline:</source>
          <target state="translated">다음 5개의 정규식 옵션은 <bpt id="p1">*</bpt>options<ept id="p1">*</ept> 매개 변수와 인라인으로 모두 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The following five regular expression options can be set using the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter but cannot be set inline:</source>
          <target state="translated">다음 5개의 정규식 옵션은 <bpt id="p1">*</bpt>options<ept id="p1">*</ept> 매개 변수를 사용하여 설정할 수 있지만 인라인으로는 설정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Determining the options</source>
          <target state="translated">옵션 확인</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can determine which options were provided to a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object when it was instantiated by retrieving the value of the read-only <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> property.</source>
          <target state="translated">읽기 전용 <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> 속성 값을 검색하여 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 개체를 인스턴스화했을 때 해당 개체에 제공된 옵션을 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To test for the presence of any option except <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, perform an AND operation with the value of the <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> property and the <bpt id="p3">[</bpt>RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> value in which you are interested.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>을 제외한 모든 옵션의 존재 유무를 테스트하려면 <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> 속성 값 및 관심 있는 <bpt id="p3">[</bpt>RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 값으로 AND 작업을 수행합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Then test whether the result equals that <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> value.</source>
          <target state="translated">그런 다음 결과가 해당 <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 값과 같은지 테스트합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The following example tests whether the <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option has been set.</source>
          <target state="translated">다음 예제에서는 <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> 옵션이 설정되었는지 테스트합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>To test for <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, determine whether the value of the <bpt id="p2">[</bpt>RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property is equal to <bpt id="p3">[</bpt>RegexOptions.None<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, as the following example illustrates.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>을 테스트하려면 다음 예제와 같이 <bpt id="p2">[</bpt>RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 속성 값이 <bpt id="p3">[</bpt>RegexOptions.None<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>과 같은지를 결정합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following sections list the options supported by regular expression in  .NET.</source>
          <target state="translated">다음 섹션에는 .NET의 정규식에서 지원하는 옵션이 나열되어 있습니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Default options</source>
          <target state="translated">기본 옵션</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> 옵션은 지정된 옵션이 없고 정규식 엔진에서 해당 기본 동작을 사용함을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This includes the following:</source>
          <target state="translated">여기에는 다음과 같은 사항이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</source>
          <target state="translated">패턴이 ECMAScript 정규식이 아니라 정식으로 해석됩니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is matched in the input string from left to right.</source>
          <target state="translated">정규식 패턴이 입력 문자열에서 왼쪽에서 오른쪽으로 일치됩니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Comparisons are case-sensitive.</source>
          <target state="translated">비교는 대/소문자를 구분합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> language elements match the beginning and end of the input string.</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> 및 <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> 언어 요소는 입력 문자열의 시작 부분 및 끝 부분과 일치합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>language element matches every character except <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</source>
          <target state="translated">언어 요소는 <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>을 제외한 모든 문자와 일치합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Any white space in a regular expression pattern is interpreted as a literal space character.</source>
          <target state="translated">정규식 패턴의 모든 공백은 리터럴 공백 문자로 해석됩니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The conventions of the current culture are used when comparing the pattern to the input string.</source>
          <target state="translated">패턴을 입력 문자열과 비교할 때 현재 문화권의 규칙이 사용됩니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Capturing groups in the regular expression pattern are implicit as well as explicit.</source>
          <target state="translated">정규식 패턴의 캡처링 그룹은 명시적 및 암시적입니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option has no inline equivalent.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> 옵션과 동일한 인라인 옵션은 없습니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</source>
          <target state="translated">정규식 옵션이 인라인으로 적용된 경우 기본 동작은 특정 옵션을 해제하여 옵션별로 복원됩니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`(?i)`</ph> turns on case-insensitive comparison, and <ph id="ph2">`(?-i)`</ph> restores the default case-sensitive comparison.</source>
          <target state="translated">예를 들어, <ph id="ph1">`(?i)`</ph>는 대/소문자를 구분하지 않는 비교를 설정하고 <ph id="ph2">`(?-i)`</ph>는 기본 대/소문자를 구분하는 비교를 복원합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> 옵션은 정규식 엔진의 기본 동작을 나타내므로 메서드 호출에 명시적으로 지정되는 경우가 드뭅니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>A constructor or static pattern-matching method without an options parameter is called instead.</source>
          <target state="translated">대신 생성자 또는 정적 패턴 일치 메서드가 options 매개 변수 없이 호출됩니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Case-insensitive matching</source>
          <target state="translated">대/소문자를 구분하지 않는 일치</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option, or the <bpt id="p2">**</bpt>i<ept id="p2">**</ept> inline option, provides case-insensitive matching.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> 옵션 또는 <bpt id="p2">**</bpt>i<ept id="p2">**</ept> 인라인 옵션은 대/소문자를 구분하지 않는 일치를 제공합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>By default, the casing conventions of the current culture are used.</source>
          <target state="translated">기본적으로 현재 문화권의 대/소문자 사용 규칙이 사용됩니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression pattern, <ph id="ph1">`\bthe\w*\b`</ph>, that matches all words starting with "the".</source>
          <target state="translated">다음 예제에서는 "the"로 시작하는 모든 단어와 일치하는 정규식 패턴 <ph id="ph1">`\bthe\w*\b`</ph>를 정의합니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Because the first call to the Match method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</source>
          <target state="translated">Match 메서드에 대한 첫 번째 호출에서 기본 대/소문자를 구분하는 비교를 사용하므로 출력은 문장을 시작하는 문자열 "The"가 일치하지 않음을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It is matched when the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with options set to <bpt id="p2">[</bpt>IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> 메서드가 옵션이 <bpt id="p2">[</bpt>IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>로 설정된 상태로 호출되면 이 문자열이 일치합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The following example modifies the regular expression pattern from the previous example to use inline options instead of the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter to provide case-insensitive comparison.</source>
          <target state="translated">다음 예제에서는 대/소문자를 구분하지 않는 비교를 제공하기 위해 <bpt id="p1">*</bpt>options<ept id="p1">*</ept> 매개 변수 대신 인라인 옵션을 사용하도록 이전 예제의 정규식 패턴을 수정합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</source>
          <target state="translated">첫 번째 패턴은 문자열 "the"에서 문자 "t"에만 적용되는 그룹화 구문에 대/소문자를 구분하지 않는 옵션을 정의합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</source>
          <target state="translated">옵션 구문이 패턴의 시작 부분에서 발생하므로 두 번째 패턴은 대/소문자를 구분하지 않는 옵션을 전체 정규식에 적용합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Multiline mode</source>
          <target state="translated">여러 줄 모드</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, or the <bpt id="p2">**</bpt>m<ept id="p2">**</ept> inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 옵션 또는 <bpt id="p2">**</bpt>m<ept id="p2">**</ept> 인라인 옵션은 정규식 엔진이 여러 줄로 구성된 입력 문자열을 처리할 수 있게 해줍니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It changes the interpretation of the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</source>
          <target state="translated">이 옵션은 <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> 및 <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> 언어 요소가 입력 문자열의 시작 부분 및 끝 부분 대신 줄의 시작 부분 및 끝 부분과 일치하도록 해당 언어 요소의 해석을 변경합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>By default, <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> matches only the end of the input string.</source>
          <target state="translated">기본적으로 <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept>는 입력 문자열의 끝 부분과만 일치합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>If you specify the <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, it matches either the newline character <bpt id="p2">**</bpt>(\n)<ept id="p2">**</ept> or the end of the input string.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 옵션을 지정하면 줄 바꿈 문자<bpt id="p2">**</bpt>(\n)<ept id="p2">**</ept> 또는 입력 문자열의 끝 부분과 일치합니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>It does not, however, match the carriage return/line feed character combination.</source>
          <target state="translated">그러나 캐리지 리턴/줄 바꿈 문자 조합과는 일치하지 않습니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>To successfully match them, use the subexpression <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> instead of just <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>.</source>
          <target state="translated">성공적으로 일치시키려면 단순히 <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>만 사용할 것이 아니라 하위 식 <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept>를 사용합니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The following example extracts bowlers names and scores and adds them to a <bpt id="p1">[</bpt>SortedList<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.SortedList%602)</ept> collection that sorts them in descending order.</source>
          <target state="translated">다음 예제에서는 볼링하는 사람의 이름과 점수를 추출하여 이를 내림차순으로 정렬하는 <bpt id="p1">[</bpt>SortedList<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.SortedList%602)</ept> 컬렉션에 추가합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> method is called twice.</source>
          <target state="translated"><bpt id="p1">[</bpt>Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> 메서드가 두 번 호출됩니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>In the first method call, the regular expression is <ph id="ph1">`^(\w+)\s(\d+)$`</ph> and no options are set.</source>
          <target state="translated">첫 번째 메서드 호출에서 정규식은 <ph id="ph1">`^(\w+)\s(\d+)$`</ph>이며 옵션이 설정되지 않았습니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</source>
          <target state="translated">출력에 표시된 것처럼, 정규식 엔진이 입력 패턴을 입력 문자열의 시작 부분 및 끝 부분과 함께 일치시킬 수 없어 찾은 일치 항목이 없습니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>In the second method call, the regular expression is changed to <ph id="ph1">`^(\w+)\s(\d+)\r?$`</ph> and the options are set to <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</source>
          <target state="translated">두 번째 메서드 호출에서 정규식은 <ph id="ph1">`^(\w+)\s(\d+)\r?$`</ph>로 변경되었으며 옵션이 <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>으로 설정되었습니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</source>
          <target state="translated">출력에 표시된 것처럼, 이름 및 점수가 성공적으로 일치되었으며 점수가 내림차순으로 표시되었습니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^(\w+)\s(\d+)\r*$`</ph> is defined as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`^(\w+)\s(\d+)\r*$`</ph>는 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Begin at the start of the line.</source>
          <target state="translated">줄의 시작 부분에서 시작합니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">이 그룹은 첫 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">공백 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
          <target state="translated">하나 이상의 10진수 숫자가 일치하는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">이 그룹은 두 번째 캡처링 그룹입니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Match zero or one carriage return character.</source>
          <target state="translated">0개 또는 1개의 캐리지 리턴 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>End at the end of the line.</source>
          <target state="translated">줄의 끝 부분에서 끝납니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous one, except that it uses the inline option <bpt id="p1">**</bpt>(?m)<ept id="p1">**</ept> to set the multiline option.</source>
          <target state="translated">다음 예제는 인라인 옵션<bpt id="p1">**</bpt>(?m)<ept id="p1">**</ept>을 사용하여 여러 줄 옵션을 설정한다는 점을 제외하고는 이전 예제와 동일합니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Single-line mode</source>
          <target state="translated">한 줄 모드</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option, or the s inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> 옵션 또는 s 인라인 옵션은 정규식 엔진이 입력 문자열이 한 줄로 구성된 것처럼 입력 문자열을 처리하도록 합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>It does this by changing the behavior of the period (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) language element so that it matches every character, instead of matching every character except for the newline character <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> or \u000A.</source>
          <target state="translated">이 옵션은 마침표(<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) 언어 요소가 줄 바꿈 문자 <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> 또는 \u000A를 제외한 모든 문자와 일치하는 대신 모든 문자와 일치하도록 해당 언어 요소의 동작을 변경하여 그렇게 합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The following example illustrates how the behavior of the .</source>
          <target state="translated">다음 예제에서는</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>language element changes when you use the <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> 옵션을 사용할 때 . 언어 요소의 동작이 변경되는 방법을 설명합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^.+`</ph> starts at the beginning of the string and matches every character.</source>
          <target state="translated">정규식 <ph id="ph1">`^.+`</ph>는 문자열의 시작 부분에서 시작하여 모든 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, <bpt id="p1">**</bpt>\r<ept id="p1">**</ept> or \u000D, but it does not match <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</source>
          <target state="translated">기본적으로 일치는 첫째 줄 끝에서 끝납니다. 정규식 패턴은 캐리지 리턴 문자, <bpt id="p1">**</bpt>\r<ept id="p1">**</ept> 또는 \u000D와 일치하지만 <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>과는 일치하지 않습니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option interprets the entire input string as a single line, it matches every character in the input string, including <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> 옵션은 한 줄로 전체 입력 문자열을 해석하기 때문에 <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>을 포함하여 입력 문자열의 모든 문자를 일치시킵니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous one, except that it uses the inline option <bpt id="p1">**</bpt>(?s)<ept id="p1">**</ept> to enable single-line mode.</source>
          <target state="translated">다음 예제는 인라인 옵션 <bpt id="p1">**</bpt>(?s)<ept id="p1">**</ept>를 사용하여 한 줄 모드를 사용하도록 설정한다는 점을 제외하고는 이전 예제와 동일합니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Explicit captures only</source>
          <target state="translated">명시적 캡처만 해당</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</source>
          <target state="translated">기본적으로 캡처링 그룹은 정규식 패턴에 괄호를 사용하여 정의됩니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Named groups are assigned a name or number by the <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> language option, whereas unnamed groups are accessible by index.</source>
          <target state="translated">명명된 그룹은 <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> 언어 옵션에 의해 이름 또는 번호가 할당되는 반면, 명명되지 않은 그룹은 인덱스로 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object, unnamed groups precede named groups.</source>
          <target state="translated"><bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 개체에서 명명되지 않은 그룹은 명명된 그룹 앞에 있습니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</source>
          <target state="translated">그룹화 구문은 일반적으로 여러 언어 요소에 수량자를 적용하는 데만 사용되고, 캡처된 부분 문자열은 관심을 두는 부분이 아닙니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>For example, if the following regular expression:</source>
          <target state="translated">예를 들어, 다음 정규식</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> object) is of interest.</source>
          <target state="translated">가 문서에서 마침표, 느낌표 또는 물음표로 끝나는 문장만 추출하려는 의도로 사용된 경우 결과 문장(<bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> 개체로 표현됨)만 관심을 두는 부분입니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The individual words in the collection are not.</source>
          <target state="translated">컬렉션의 개별 단어는 관심을 두는 부분이 아닙니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collection objects.</source>
          <target state="translated">정규식 엔진이 <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 및 <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> 컬렉션 개체를 둘 다 채워야 하므로 이후에 사용되지 않는 캡처링 그룹에는 비용이 많이 들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>As an alternative, you can use either the <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option or the <bpt id="p2">**</bpt>n<ept id="p2">**</ept> inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the <bpt id="p3">**</bpt>(?&lt;<ept id="p3">**</ept><bpt id="p4">_</bpt>name<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">&gt;</ph><ept id="p5">**</ept> <bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept> construct.</source>
          <target state="translated">대안으로 <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> 옵션 또는 <bpt id="p2">**</bpt>n<ept id="p2">**</ept> 인라인 옵션을 사용하여 유효한 캡처가 <bpt id="p3">**</bpt>(?&lt;<ept id="p3">**</ept><bpt id="p4">_</bpt>name<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">&gt;</ph><ept id="p5">**</ept> <bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept> 구문에 의해 지정된, 명시적으로 명명되거나 번호가 매겨진 그룹임을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The following example displays information about the matches returned by the <ph id="ph1">`\b\(?((\w+),?\s?)+[\.!?]\)?`</ph> regular expression pattern when the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept> method is called with and without the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">다음 예제에서는 <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept> 메서드가 <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> 옵션을 사용하여 호출된 경우와 이 옵션을 사용하지 않고 호출된 경우에 <ph id="ph1">`\b\(?((\w+),?\s?)+[\.!?]\)?`</ph> 정규식 패턴에서 반환하는 일치 항목에 대한 정보를 표시합니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>As the output from the first method call shows, the regular expression engine fully populates the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collection objects with information about captured substrings.</source>
          <target state="translated">첫 번째 메서드 호출의 출력이 보여 주는 것처럼, 정규식 엔진은 캡처된 부분 문자열에 대한 정보로 <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 및 <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> 컬렉션 개체를 완전히 채웁니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Because the second method is called with options set to <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>, it does not capture information on groups.</source>
          <target state="translated">두 번째 메서드는 options을 <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>로 설정한 상태로 호출되었기 때문에 그룹에 대한 정보를 캡처하지 않습니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b\(?((?&gt;\w+),?\s?)+[\.!?]\)?`</ph> is defined as shown in the following table.</source>
          <target state="translated">정규식 패턴 <ph id="ph1">`\b\(?((?&gt;\w+),?\s?)+[\.!?]\)?`</ph>는 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Begin at a word boundary.</source>
          <target state="translated">단어 경계에서 시작합니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrences of the opening parenthesis ("(").</source>
          <target state="translated">0개 또는 1개의 여는 괄호("(")를 찾습니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Match one or more word characters, followed by zero or one commas.</source>
          <target state="translated">하나 이상의 단어 문자 다음에 0개 또는 1개의 쉼표가 있는 일치 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Do not backtrack when matching word characters.</source>
          <target state="translated">단어 문자를 찾을 때 역추적하지 않습니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space characters.</source>
          <target state="translated">0회 이상 나오는 공백 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</source>
          <target state="translated">하나 이상의 단어 문자 다음에 0개 또는 1개의 쉼표 및 0개 또는 1개의 공백 문자가 한 번 이상 나타나는 조합을 찾습니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</source>
          <target state="translated">세 가지 문장 부호 기호 다음에 0개 또는 1개의 닫는 괄호(")")가 있는 모든 일치 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>You can also use the <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> inline element to suppress automatic captures.</source>
          <target state="translated">또한 <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> 인라인 요소를 사용하여 자동 캡처를 억제할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous regular expression pattern to use the <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> inline element instead of the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">다음 예제에서는 <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> 옵션 대신 <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> 인라인 요소를 사용하도록 이전 정규식 패턴을 수정합니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Finally, you can use the inline group element <bpt id="p1">**</bpt>(?n:)<ept id="p1">**</ept> to suppress automatic captures on a group-by-group basis.</source>
          <target state="translated">마지막으로, 인라인 그룹 요소 <bpt id="p1">**</bpt>(?n:)<ept id="p1">**</ept>를 사용하여 그룹별로 자동 캡처를 억제할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous pattern to suppress unnamed captures in the outer group, <ph id="ph1">`((?&gt;\w+),?\s?)`</ph>.</source>
          <target state="translated">다음 예제에서는 바깥쪽 그룹 <ph id="ph1">`((?&gt;\w+),?\s?)`</ph>에서 명명되지 않은 캡처를 억제하도록 이전 패턴을 수정합니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Note that this suppresses unnamed captures in the inner group as well.</source>
          <target state="translated">여기서는 안쪽 그룹에서도 명명되지 않은 캡처가 억제됩니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Compiled regular expressions</source>
          <target state="translated">컴파일된 정규식</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>By default, regular expressions in .NET are interpreted.</source>
          <target state="translated">기본적으로 .NET의 정규식은 해석됩니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>When a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated or a static <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</source>
          <target state="translated"><bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 개체가 인스턴스화되거나 고정 <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 메서드가 호출되면 정규식 패턴이 일련의 사용자 지정 opcode로 구문 분석되고 해석기는 이러한 opcode를 사용하여 정규식을 실행합니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</source>
          <target state="translated">여기에는 절충 사항이 수반됩니다. 즉, 정규식 엔진의 초기화 비용은 런타임 성능을 희생하여 최소화됩니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You can use compiled instead of interpreted regular expressions by using the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> 옵션을 사용하여, 해석된 정규식 대신 컴파일된 정규식을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</source>
          <target state="translated">이 경우 패턴이 정규식 엔진에 전달되면 일련의 opcode로 구문 분석된 다음, 공용 언어 런타임으로 직접 전달될 수 있는 MSIL(Microsoft Intermediate Language)로 변환됩니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Compiled regular expressions maximize run-time performance at the expense of initialization time.</source>
          <target state="translated">컴파일된 정규식은 초기화 시간을 희생하여 런타임 성능을 최대화합니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>A regular expression can be compiled only by supplying the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or a static pattern-matching method.</source>
          <target state="translated">정규식은 <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> 값을 <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 클래스 생성자 또는 정적 패턴 일치 메서드의 options 매개 변수에 제공해서만 컴파일할 수 있으며,</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">인라인 옵션으로는 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>You can use compiled regular expressions in calls to both static and instance regular expressions.</source>
          <target state="translated">컴파일된 정규식은 정적 정규식과 인스턴스 정규식 둘 다에 대한 호출에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>In static regular expressions, the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option is passed to the options parameter of the regular expression pattern-matching method.</source>
          <target state="translated">정적 정규식에서 <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> 옵션은 정규식 패턴 일치 메서드의 options 매개 변수에 전달됩니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>In instance regular expressions, it is passed to the options parameter of the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor.</source>
          <target state="translated">인스턴스 정규식에서 이 옵션은 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 클래스 생성자의 options 매개 변수에 전달됩니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>In both cases, it results in enhanced performance.</source>
          <target state="translated">따라서 두 가지 경우 모두에서 성능이 향상됩니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>However, this improvement in performance occurs only under the following conditions:</source>
          <target state="translated">그러나 이 성능 향상은 다음 조건에서만 발생합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</source>
          <target state="translated">특정 정규식을 나타내는 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 개체가 정규식 패턴 일치 메서드에 대한 여러 번의 호출에 사용됩니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is not allowed to go out of scope, so it can be reused.</source>
          <target state="translated"><bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 개체가 범위를 벗어날 수 없어 재사용될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>A static regular expression is used in multiple calls to regular expression pattern-matching methods.</source>
          <target state="translated">정적 정규식이 정규식 패턴 일치 메서드에 대한 여러 번의 호출에 사용됩니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</source>
          <target state="translated">(정적 메서드 호출에 사용된 정규식이 정규식 엔진에 의해 캐시되므로 성능 향상이 가능합니다.)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Ignore white space</source>
          <target state="translated">공백 무시</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</source>
          <target state="translated">기본적으로 정규식 패턴에서 공백은 중요합니다. 공백은 정규식 엔진이 입력 문자열에서 공백 문자를 강제로 일치시키도록 합니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Because of this, the regular expression <ph id="ph1">`"\b\w+\s"`</ph> and <ph id="ph2">`"\b\w+ "`</ph> are roughly equivalent regular expressions.</source>
          <target state="translated">따라서 정규식 <ph id="ph1">`"\b\w+\s"`</ph>와 <ph id="ph2">`"\b\w+ "`</ph>는 거의 동일한 정규식입니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>In addition, when the number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</source>
          <target state="translated">또한 정규식 패턴에 숫자 기호(<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>)가 있으면 이는 일치시킬 리터럴 문자로 해석됩니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option, or the <bpt id="p2">**</bpt>x<ept id="p2">**</ept> inline option, changes this default behavior as follows:</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> 옵션 또는 <bpt id="p2">**</bpt>x<ept id="p2">**</ept> 인라인 옵션은 다음과 같이 이 기본 동작을 변경합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Unescaped white space in the regular expression pattern is ignored.</source>
          <target state="translated">정규식 패턴에서 이스케이프되지 않은 공백은 무시됩니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>To be part of a regular expression pattern, white-space characters must be escaped (for example, as <bpt id="p1">**</bpt>\s<ept id="p1">**</ept> or "*<bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept> ").</source>
          <target state="translated">정규식 패턴의 일부가 되려면 공백 문자가 이스케이프되어야 합니다(예: <bpt id="p1">**</bpt>\s<ept id="p1">**</ept> 또는 "*<bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept> "로).</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) is interpreted as the beginning of a comment, rather than as a literal character.</source>
          <target state="translated">숫자 기호(<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>)는 리터럴 문자가 아니라 주석의 시작 부분으로 해석됩니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>All text in the regular expression pattern from the <bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept> character to the end of the string is interpreted as a comment.</source>
          <target state="translated">정규식 패턴에서 모든 텍스트는 <bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept> 문자부터 문자열의 끝 부분까지 주석으로 해석됩니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>However, in the following cases, white space characters in a regular expression aren't ignored, even if you use the <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option:</source>
          <target state="translated">그러나 다음 경우에 정규식의 공백 문자는 <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> 옵션을 사용하더라도 무시되지 않습니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>White space within a character class is always interpreted literally.</source>
          <target state="translated">문자 클래스 내의 공백은 항상 리터럴로 해석됩니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`[ .,;:]`</ph> matches any single white-space character, period, comma, semicolon, or colon.</source>
          <target state="translated">예를 들어, 정규식 패턴 <ph id="ph1">`[ .,;:]`</ph>는 모든 단일 공백 문자, 마침표, 쉼표, 세미콜론 또는 콜론과 일치합니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>White space isn't allowed within a bracketed quantifier, such as <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,}<ept id="p6">**</ept>, and <bpt id="p7">**</bpt>{<ept id="p7">**</ept><bpt id="p8">_</bpt>n<ept id="p8">_</ept><bpt id="p9">**</bpt>,<ept id="p9">**</ept><bpt id="p10">_</bpt>m<ept id="p10">_</ept><bpt id="p11">**</bpt>}<ept id="p11">**</ept>.</source>
          <target state="translated">중괄호로 묶은 수량자 내에는 공백이 허용되지 않습니다(예: <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,}<ept id="p6">**</ept> 및 <bpt id="p7">**</bpt>{<ept id="p7">**</ept><bpt id="p8">_</bpt>n<ept id="p8">_</ept><bpt id="p9">**</bpt>,<ept id="p9">**</ept><bpt id="p10">_</bpt>m<ept id="p10">_</ept><bpt id="p11">**</bpt>}<ept id="p11">**</ept>).</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <bpt id="p1">**</bpt>\d{1. 3}<ept id="p1">**</ept> fails to match any sequences of digits from one to three digits because it contains a white-space character.</source>
          <target state="translated">예를 들어, 정규식 패턴 <bpt id="p1">**</bpt>\d{1. 3}<ept id="p1">**</ept>은 공백 문자를 포함하고 있기 때문에 1자리에서 3자리까지의 숫자로 이루어진 어떠한 숫자 시퀀스와도 일치하지 않습니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>White space isn't allowed within a character sequence that introduces a language element.</source>
          <target state="translated">언어 요소를 도입하는 문자 시퀀스 내에는 공백이 허용되지 않습니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예:</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The language element <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> represents a noncapturing group, and the <bpt id="p4">**</bpt>(?:<ept id="p4">**</ept> portion of the element can't have embedded spaces.</source>
          <target state="translated">언어 요소 <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>는 비 캡처링 그룹을 나타내고, 요소의 <bpt id="p4">**</bpt>(?:<ept id="p4">**</ept> 부분은 공백을 포함할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The pattern <bpt id="p1">**</bpt>(? :<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> throws an <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept> at run time because the regular expression engine can't parse the pattern, and the pattern <bpt id="p5">**</bpt>(? :<ept id="p5">**</ept><bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept>  fails to match <bpt id="p8">*</bpt>subexpression<ept id="p8">*</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>(? :<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> 패턴은 정규식 엔진이 패턴을 구문 분석할 수 없고 <bpt id="p5">**</bpt>(? :<ept id="p5">**</ept><bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept> 패턴이 <bpt id="p8">*</bpt>subexpression<ept id="p8">*</ept>과 일치하지 않으므로 런타임에 <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept>을 throw합니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The language element <bpt id="p1">**</bpt>\p{<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, which represents a Unicode category or named block, can't include embedded spaces in the <bpt id="p4">**</bpt>\p{<ept id="p4">**</ept> portion of the element.</source>
          <target state="translated">유니코드 범주 또는 명명된 블록을 나타내는 언어 요소 <bpt id="p1">**</bpt>\p{<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>는 요소의 <bpt id="p4">**</bpt>\p{<ept id="p4">**</ept> 부분에 공백을 포함할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>If you do include a white space, the element throws an <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept> at run time.</source>
          <target state="translated">공백을 포함하는 경우 이 요소가 런타임에 <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept>을 throw합니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</source>
          <target state="translated">이 옵션을 사용하면 일반적으로 구문 분석 및 이해가 어려운 정규식을 단순화하는 데 도움이 됩니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>It improves readability, and makes it possible to document a regular expression.</source>
          <target state="translated">이 옵션은 가독성을 향상시키고 정규식을 문서화할 수 있게 해줍니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The following example defines the following regular expression pattern:</source>
          <target state="translated">다음 예제에서는 다음과 같은 정규식 패턴을 정의합니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\b \(? ( (?&gt;\w+) ,?\s? )+ [\.!?] \)? # Matches an entire sentence`</ph>.</source>
          <target state="translated"><ph id="ph1">`\b \(? ( (?&gt;\w+) ,?\s? )+ [\.!?] \)? # Matches an entire sentence`</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>This pattern is similar to the pattern defined in the <bpt id="p1">[</bpt>Explicit captures only<ept id="p1">](#explicit-captures-only)</ept> section, except that it uses the <bpt id="p2">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option to ignore pattern white space.</source>
          <target state="translated">이 패턴은 <bpt id="p2">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> 옵션을 사용하여 패턴 공백을 무시하는 점을 제외하고는 <bpt id="p1">[</bpt>명시적 캡처만 해당<ept id="p1">](#explicit-captures-only)</ept> 섹션에 정의된 패턴과 유사합니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following example uses the inline option <bpt id="p1">**</bpt>(?x)<ept id="p1">**</ept> to ignore pattern white space.</source>
          <target state="translated">다음 예제에서는 인라인 옵션 <bpt id="p1">**</bpt>(?x)<ept id="p1">**</ept>를 사용하여 패턴 공백을 무시합니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Right-to-left mode</source>
          <target state="translated">오른쪽에서 왼쪽 모드</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine searches from left to right.</source>
          <target state="translated">기본적으로 정규식 엔진은 왼쪽에서 오른쪽으로 검색합니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>You can reverse the search direction by using the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> 옵션을 사용하여 검색 방향을 반대로 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The search automatically begins at the last character position of the string.</source>
          <target state="translated">검색은 자동으로 문자열의 마지막 문자 위치에서 시작됩니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>For pattern-matching methods that include a starting position parameter, such as <bpt id="p1">[</bpt>Regex.Match(String, Int32)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept>, the starting position is the index of the rightmost character position at which the search is to begin.</source>
          <target state="translated">시작 위치 매개 변수를 포함한 패턴 일치 메서드의 경우(예: <bpt id="p1">[</bpt>Regex.Match(String, Int32)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept>) 시작 위치는 검색이 시작될 가장 오른쪽 문자 위치의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Right-to-left pattern mode is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">오른쪽에서 왼쪽 패턴 모드는 <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> 값을 <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 클래스 생성자 또는 정적 패턴 일치 메서드의 options 매개 변수에 제공해서만 사용할 수 있으며,</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">인라인 옵션으로는 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> 옵션은 검색 방향만 변경하며 오른쪽에서 왼쪽으로 정규식 패턴을 해석하지는 않습니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\bb\w+\s`</ph> matches words that begin with the letter "b" and are followed by a white-space character.</source>
          <target state="translated">예를 들어, 정규식 <ph id="ph1">`\bb\w+\s`</ph>는 문자 "b"로 시작하고 뒤에 공백 문자가 있는 단어와 일치합니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>In the following example, the input string consists of three words that include one or more "b" characters.</source>
          <target state="translated">다음 예제에서 입력 문자열은 하나 이상의 "b" 문자를 포함하는 세 단어로 구성됩니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</source>
          <target state="translated">첫 번째 단어는 "b"로 시작하고, 두 번째 단어는 "b"로 끝나며, 세 번째 단어는 단어 중간에 두 개의 "b" 문자를 포함합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, only the first word matches the regular expression pattern.</source>
          <target state="translated">예제의 출력이 보여 주는 것처럼, 첫 번째 단어만 정규식 패턴과 일치합니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Also note that the lookahead assertion (the <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element) and the lookbehind assertion (the <bpt id="p4">**</bpt>(?&lt;<ept id="p4">**</ept><ph id="ph2">=</ph><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> language element) do not change direction.</source>
          <target state="translated">lookahead 어설션(<bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> 언어 요소) 및 lookbehind 어설션(<bpt id="p4">**</bpt>(?&lt;<ept id="p4">**</ept><ph id="ph2">=</ph><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> 언어 요소)은 방향을 변경하지 않습니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The lookahead assertions look to the right; the lookbehind assertions look to the left.</source>
          <target state="translated">lookahead 어설션은 오른쪽을 확인하고, lookbehind 어설션은 왼쪽을 확인합니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`(?&lt;=\d{1,2}\s)\w+,?\s\d{4}`</ph> uses the lookbehind assertion to test for a date that precedes a month name.</source>
          <target state="translated">예를 들어, 정규식 <ph id="ph1">`(?&lt;=\d{1,2}\s)\w+,?\s\d{4}`</ph>에서는 lookbehind 어설션을 사용하여 월 이름 앞에 있는 날짜에 대해 테스트합니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The regular expression then matches the month and the year.</source>
          <target state="translated">그런 다음 정규식은 월 및 연도를 일치시킵니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>For information on lookahead and lookbehind assertsions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">lookahead 및 lookbehind 어설션에 대한 자세한 내용은 <bpt id="p1">[</bpt>정규식의 그룹화 구문<ept id="p1">](grouping.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">패턴</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The beginning of the match must be preceded by one or two decimal digits followed by a space.</source>
          <target state="translated">일치 항목의 시작 부분 앞에는 한 개 또는 두 개의 10진수와 그 뒤에 공백이 하나 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">하나 이상의 단어 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Match zero or one comma characters.</source>
          <target state="translated">0개 또는 1개의 쉼표 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">공백 문자를 찾습니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Match four decimal digits.</source>
          <target state="translated">네 개의 10진수를 찾습니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>ECMAScript matching behavior</source>
          <target state="translated">ECMAScript 일치 동작</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</source>
          <target state="translated">기본적으로 정규식 엔진은 정규식 패턴을 입력 텍스트에 일치시킬 때 정식 동작을 사용합니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> option.</source>
          <target state="translated">그러나 <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> 옵션을 지정하여 ECMAScript 일치 동작을 사용하도록 정규식 엔진에 지시할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>ECMAScript-compliant behavior is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">ECMAScript와 호환되는 동작은 <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> 값을 <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 클래스 생성자 또는 정적 패턴 일치 메서드의 options 매개 변수에 제공해서만 사용할 수 있으며,</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">인라인 옵션으로는 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> option can be combined only with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> and <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> options.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> 옵션은 <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> 및 <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 옵션과 결합해야만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>The use of any other option in a regular expression results in an <bpt id="p1">[</bpt>ArgumentOutOfRangeException<ept id="p1">](xref:System.ArgumentOutOfRangeException)</ept>.</source>
          <target state="translated">정규식에 다른 옵션을 사용하면 <bpt id="p1">[</bpt>ArgumentOutOfRangeException<ept id="p1">](xref:System.ArgumentOutOfRangeException)</ept>이 발생합니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</source>
          <target state="translated">ECMAScript의 동작과 정식 정규식의 동작은 문자 클래스 구문, 자신을 참조하는 캡처링 그룹 및 8진수 대 역참조 해석의 세 가지 영역에서 다릅니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Character class syntax.</source>
          <target state="translated">문자 클래스 구문.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</source>
          <target state="translated">정식 정규식은 유니코드를 지원하는 반면 ECMAScript는 지원하지 않으므로, ECMAScript의 문자 클래스의 구문이 더 제한되어 있으며 일부 문자 클래스 언어 요소는 다른 의미를 지닙니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>For example, ECMAScript does not support language elements such as the Unicode category or block elements <bpt id="p1">*</bpt>\p<ept id="p1">*</ept> and <bpt id="p2">**</bpt>\P<ept id="p2">**</ept>.</source>
          <target state="translated">예를 들어, ECMAScript는 유니코드 범주 또는 블록 요소 <bpt id="p1">*</bpt>\p<ept id="p1">*</ept> 및 <bpt id="p2">**</bpt>\P<ept id="p2">**</ept>와 같은 언어 요소를 지원하지 않습니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Similarly, the <bpt id="p1">**</bpt>\w<ept id="p1">**</ept> element, which matches a word character, is equivalent to the <bpt id="p2">**</bpt>[a-zA-Z_0-9]<ept id="p2">**</ept> character class when using ECMAScript and <bpt id="p3">**</bpt>[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]<ept id="p3">**</ept> when using canonical behavior.</source>
          <target state="translated">마찬가지로, 단어 문자와 일치하는 <bpt id="p1">**</bpt>\w<ept id="p1">**</ept> 요소는 ECMAScript를 사용할 경우 <bpt id="p2">**</bpt>[a-zA-Z_0-9]<ept id="p2">**</ept> 문자 클래스와 동일하고 정식 동작을 사용할 경우 <bpt id="p3">**</bpt>[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]<ept id="p3">**</ept>과 동일합니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Character classes in regular expressions<ept id="p1">](classes.md)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>정규식의 문자 클래스<ept id="p1">](classes.md)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between canonical and ECMAScript pattern matching.</source>
          <target state="translated">다음 예제에서는 정식 패턴 일치와 ECMAScript 패턴 일치 간의 차이점을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>It defines a regular expression, <ph id="ph1">`\b(\w+\s*)+`</ph>, that matches words followed by white-space characters.</source>
          <target state="translated">이 예제에서는 뒤에 공백 문자가 있는 단어와 일치하는 정규식 <ph id="ph1">`\b(\w+\s*)+`</ph>를 정의합니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</source>
          <target state="translated">입력은 두 개의 문자열로 구성되어 있는데, 한 문자열은 라틴 문자 집합을 사용하고 다른 문자열은 키릴 자모 문자 집합을 사용합니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>As the output shows, the call to the <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</source>
          <target state="translated">출력에 표시된 것처럼, ECMAScript 일치를 사용하는 <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> 메서드에 대한 호출은 키릴 자모 단어와 일치하지 않는 반면 정식 일치를 사용하는 메서드 호출은 이러한 단어와 일치합니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Self-referencing capturing groups.</source>
          <target state="translated">자신을 참조하는 캡처링 그룹.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>A regular expression capture class with a backreference to itself must be updated with each capture iteration.</source>
          <target state="translated">자신에 대한 역참조가 있는 정규식 캡처 클래스는 각 캡처 반복으로 업데이트되어야 합니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>As the following example shows, this feature enables the regular expression <ph id="ph1">`((a+)(\1) ?)+`</ph> to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</source>
          <target state="translated">다음 예제에서 보여 주는 것처럼, 이 기능은 정규식 <ph id="ph1">`((a+)(\1) ?)+`</ph>가 ECMAScript를 사용할 경우에는 입력 문자열 " aa aaaa aaaaaa "과 일치하고 정식 일치를 사용할 경우에는 일치하지 않도록 합니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>For more information about string comparisons that are case-sensitive and that use the invariant culture, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](best-practices.md)</ept>.</source>
          <target state="translated">대/소문자를 구분하고 고정 문화권을 사용하는 문자열 비교에 대한 자세한 내용은 <bpt id="p1">[</bpt>문자열 사용에 대한 유용한 정보<ept id="p1">](best-practices.md)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Instead of using the case-insensitive comparisons of the current culture, you can specify the <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> option to ignore cultural differences in language and to use the conventions of the invariant culture.</source>
          <target state="translated">현재 문화권의 대/소문자를 구분하지 않는 비교를 사용하는 대신 <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> 옵션을 지정하여 언어의 문화적 차이를 무시하고 고정 문화권의 규칙을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Comparison using the invariant culture is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">고정 문화권을 사용하는 비교는 <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> 값을 <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 클래스 생성자 또는 정적 패턴 일치 메서드의 options 매개 변수에 제공해서만 사용할 수 있으며,</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">인라인 옵션으로는 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The following example is identical to the previous example, except that the static <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with options that include <bpt id="p2">[</bpt>RegexOptions.CultureInvariant<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept>.</source>
          <target state="translated">다음 예제는 <bpt id="p2">[</bpt>RegexOptions.CultureInvariant<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept>를 포함하는 옵션을 사용하여 고정 <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> 메서드를 호출한다는 점을 제외하고 이전 예제와 동일합니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</source>
          <target state="translated">현재 문화권이 터키어(터키)로 설정된 경우에도 정규식 엔진은 성공적으로 "FILE"과 "file"을 일치시키고 파일 리소스에 대한 액세스를 차단할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>정규식 언어 - 빠른 참조<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>