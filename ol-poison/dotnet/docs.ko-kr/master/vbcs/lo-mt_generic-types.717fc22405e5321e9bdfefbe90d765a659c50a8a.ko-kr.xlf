<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1f6c48ff7f72eb86526ed4d71e6259b7886aab25</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\data-types\generic-types.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0e8396d263a5936b81fca9a308fdf9f5c31f5d75</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">325a9e8983910fff4b3e9524a6ebd94baade2c9f</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_generic-types.717fc22405e5321e9bdfefbe90d765a659c50a8a.ko-kr is different with handoff file name: generic-types.717fc22405e5321e9bdfefbe90d765a659c50a8a.ko-kr.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Generic Types in Visual Basic (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Visual Basic (Visual Basic)의 제네릭 형식 | Microsoft 문서</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Generic Types in Visual Basic (Visual Basic)</source>
          <target state="translated">Visual Basic의 제네릭 형식(Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>generic type<ept id="p1">*</ept> is a single programming element that adapts to perform the same functionality for a variety of data types.</source>
          <target state="translated"><bpt id="p1">*</bpt>제네릭 형식<ept id="p1">*</ept> 은 다양한 데이터 형식에 대해 동일한 기능을 수행하도록 조정되는 단일 프로그래밍 요소입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>When you define a generic class or procedure, you do not have to define a separate version for each data type for which you might want to perform that functionality.</source>
          <target state="translated">제네릭 클래스 또는 프로시저를 정의할 때는 해당 기능을 수행하고자 하는 각 데이터 형식마다 별도의 버전을 정의할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>An analogy is a screwdriver set with removable heads.</source>
          <target state="translated">비유하자면 헤드를 교체할 수 있는 스크루드라이버와 비슷합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You inspect the screw you need to turn and select the correct head for that screw (slotted, crossed, starred).</source>
          <target state="translated">즉, 돌려야 하는 나사에 맞는 헤드(일자, 십자, 별 모양)를 선택합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Once you insert the correct head in the screwdriver handle, you perform the exact same function with the screwdriver, namely turning the screw.</source>
          <target state="translated">그리고 올바른 헤드를 스크루드라이버 핸들에 삽입하면 스크루드라이버와 정확하게 동일한 기능, 즉 나사를 돌리는 기능을 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Diagram of a screwdriver set as a generic tool<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/media/genericscrewdriver.gif "GenericScrewDriver")</ept></source>
          <target state="translated"><bpt id="p1">![</bpt>제네릭 도구로 설정 된 스크루 드라이버의 다이어그램<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/media/genericscrewdriver.gif "GenericScrewDriver")</ept></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Screwdriver set as a generic tool</source>
          <target state="translated">제네릭 도구 역할을 하는 스크루드라이버 세트</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When you define a generic type, you parameterize it with one or more data types.</source>
          <target state="translated">제네릭 형식을 정의할 때는 하나 이상의 데이터 형식을 사용하여 매개 변수를 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This allows the using code to tailor the data types to its requirements.</source>
          <target state="translated">이렇게 하면 코드를 사용하여 데이터 형식을 요구 사항에 맞출 수 있습니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Your code can declare several different programming elements from the generic element, each one acting on a different set of data types.</source>
          <target state="translated">각각 서로 다른 데이터 형식 집합에 대해 작동하는 여러 프로그래밍 요소를 제네릭 요소에서 선언할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>But the declared elements all perform the identical logic, no matter what data types they are using.</source>
          <target state="translated">하지만 선언된 요소는 사용하는 데이터 형식에 관계없이 모두 동일한 논리를 수행합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For example, you might want to create and use a queue class that operates on a specific data type such as <ph id="ph1">`String`</ph>.</source>
          <target state="translated">예를 들어 <ph id="ph1">`String`</ph>과 같은 특정 데이터 형식에서 작동하는 큐 클래스를 만들어 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You can declare such a class from &lt;xref:System.Collections.Generic.Queue%601?displayProperty=fullName&gt;, as the following example shows.</source>
          <target state="translated">이러한 클래스를 선언할 수 &lt;xref:System.Collections.Generic.Queue%601?displayProperty=fullName&gt;다음 예제와 같이.&lt;/xref:System.Collections.Generic.Queue%601?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrDataTypes#1<ept id="p2">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrDataTypes #&amp;1;<ept id="p2">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You can now use <ph id="ph1">`stringQ`</ph> to work exclusively with <ph id="ph2">`String`</ph> values.</source>
          <target state="translated">이제 <ph id="ph1">`stringQ`</ph> 를 사용하여 <ph id="ph2">`String`</ph> 값으로만 작업할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`stringQ`</ph> is specific for <ph id="ph2">`String`</ph> instead of being generalized for <ph id="ph3">`Object`</ph> values, you do not have late binding or type conversion.</source>
          <target state="translated"><ph id="ph1">`stringQ`</ph> 는 <ph id="ph2">`String`</ph> 값에 일반화되는 것이 아니라 <ph id="ph3">`Object`</ph> 에 한정되므로 런타임에 바인딩 또는 형식 변환이 없습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This saves execution time and reduces run-time errors.</source>
          <target state="translated">이를 통해 실행 시간을 절약하고 런타임 오류를 줄일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For more information on using a generic type, see <bpt id="p1">[</bpt>How to: Use a Generic Class<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md)</ept>.</source>
          <target state="translated">제네릭 형식 사용에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>하는 방법: 제네릭 클래스를 사용 하 여<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Example of a Generic Class</source>
          <target state="translated">제네릭 클래스의 예</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The following example shows a skeleton definition of a generic class.</source>
          <target state="translated">다음 예에서는 제네릭 클래스의 기본 정의를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrDataTypes#2<ept id="p2">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrDataTypes #&amp;2;<ept id="p2">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In the preceding skeleton, <ph id="ph1">`t`</ph> is a <bpt id="p1">*</bpt>type parameter<ept id="p1">*</ept>, that is, a placeholder for a data type that you supply when you declare the class.</source>
          <target state="translated">앞의 기본 정의에서 <ph id="ph1">`t`</ph> 은 <bpt id="p1">*</bpt>형식 매개 변수<ept id="p1">*</ept>, 즉 클래스를 선언할 때 제공하는 데이터 형식에 대한 자리 표시자입니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Elsewhere in your code, you can declare various versions of <ph id="ph1">`classHolder`</ph> by supplying various data types for <ph id="ph2">`t`</ph>.</source>
          <target state="translated">코드의 다른 곳에서 <ph id="ph1">`classHolder`</ph> 에 대한 다양한 데이터 형식을 제공하여 여러 버전의 <ph id="ph2">`t`</ph>를 선언할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The following example shows two such declarations.</source>
          <target state="translated">다음 예제에서는 이러한 선언 두 가지를  보여 줍니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrDataTypes#3<ept id="p2">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrDataTypes #&amp;3;<ept id="p2">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The preceding statements declare <bpt id="p1">*</bpt>constructed classes<ept id="p1">*</ept>, in which a specific type replaces the type parameter.</source>
          <target state="translated">위의 문에서는 특정 형식이 형식 매개 변수를 대체하는 <bpt id="p1">*</bpt>생성된 클래스<ept id="p1">*</ept>를 선언합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This replacement is propagated throughout the code within the constructed class.</source>
          <target state="translated">이 대체는 생성된 클래스 내에서 코드 전체로 전파됩니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following example shows what the <ph id="ph1">`processNewItem`</ph> procedure looks like in <ph id="ph2">`integerClass`</ph>.</source>
          <target state="translated">다음 예에서는 <ph id="ph1">`processNewItem`</ph> 의 <ph id="ph2">`integerClass`</ph>프로시저 모습을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrDataTypes#4<ept id="p2">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrDataTypes #&amp;4;<ept id="p2">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For a more complete example, see <bpt id="p1">[</bpt>How to: Define a Class That Can Provide Identical Functionality on Different Data Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md)</ept>.</source>
          <target state="translated">자세한 예제를 참조 하십시오. <bpt id="p1">[</bpt>하는 방법: 기능을 정의 된 클래스는 수 제공 동일한 서로 다른 데이터 형식에<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Eligible Programming Elements</source>
          <target state="translated">적용 가능한 프로그래밍 요소</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You can define and use generic classes, structures, interfaces, procedures, and delegates.</source>
          <target state="translated">제네릭 클래스, 구조체, 인터페이스, 프로시저 및 대리자를 정의하고 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> defines several generic classes, structures, and interfaces that represent commonly used generic elements.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> 여러 제네릭 클래스, 구조체 및 자주 사용 되는 제네릭 요소를 나타내는 인터페이스를 정의 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Collections.Generic?displayProperty=fullName&gt; namespace provides dictionaries, lists, queues, and stacks.</source>
          <target state="translated">&lt;xref:System.Collections.Generic?displayProperty=fullName&gt;사전, 목록, 큐 및 스택 네임 스페이스를 제공 합니다.&lt;/xref:System.Collections.Generic?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Before defining your own generic element, see if it is already available in &lt;xref:System.Collections.Generic?displayProperty=fullName&gt;.</source>
          <target state="translated">일반 사용자가 직접 요소를 정의 하기 전에 &lt;xref:System.Collections.Generic?displayProperty=fullName&gt;.&lt;/xref:System.Collections.Generic?displayProperty=fullName&gt; 에서 사용할 수 있는 이미 있는지 확인 하십시오</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Procedures are not types, but you can define and use generic procedures.</source>
          <target state="translated">프로시저는 형식이 아니지만 제네릭 프로시저를 정의하고 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Generic Procedures in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/generic-procedures.md)</ept>.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>Visual Basic의 제네릭 프로시저<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/generic-procedures.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Advantages of Generic Types</source>
          <target state="translated">제네릭 형식의 장점</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A generic type serves as a basis for declaring several different programming elements, each of which operates on a specific data type.</source>
          <target state="translated">제네릭 형식은 각각 특정 데이터 형식에서 작동하는 서로 다른 프로그래밍 요소 여러 개를 선언하는 기초의 역할을 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The alternatives to a generic type are:</source>
          <target state="translated">제네릭 형식의 대안은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>A single type operating on the <ph id="ph1">`Object`</ph> data type.</source>
          <target state="translated"><ph id="ph1">`Object`</ph> 데이터 형식에서 작동하는 단일 형식.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>A set of <bpt id="p1">*</bpt>type-specific<ept id="p1">*</ept> versions of the type, each version individually coded and operating on one specific data type such as <ph id="ph1">`String`</ph>, <ph id="ph2">`Integer`</ph>, or a user-defined type such as <ph id="ph3">`customer`</ph>.</source>
          <target state="translated">형식의 <bpt id="p1">*</bpt>형식 특정<ept id="p1">*</ept> 버전 집합. 각 버전은 <ph id="ph1">`String`</ph>, <ph id="ph2">`Integer`</ph>또는 사용자 정의 형식(예: <ph id="ph3">`customer`</ph>)과 같은 하나의 특정 데이터 형식에 대해 개별적으로 코딩되고 작동합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A generic type has the following advantages over these alternatives:</source>
          <target state="translated">이러한 대안에 비교했을 때 제네릭 형식에는 다음과 같은 장점이 있습니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Type Safety.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>형식 안전성입니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Generic types enforce compile-time type checking.</source>
          <target state="translated">제네릭 형식은 컴파일 시간 형식 검사를 적용합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Types based on <ph id="ph1">`Object`</ph> accept any data type, and you must write code to check whether an input data type is acceptable.</source>
          <target state="translated"><ph id="ph1">`Object`</ph> 에 기반한 형식은 모든 데이터 형식을 수락하며 입력 데이터 형식이 수락 가능한지 확인하기 위한 코드를 작성해야 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>With generic types, the compiler can catch type mismatches before run time.</source>
          <target state="translated">제네릭 형식을 사용하면 컴파일러가 런타임 전에 불일치를 찾아낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Performance.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>성능을 제공 합니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Generic types do not have to <bpt id="p1">*</bpt>box<ept id="p1">*</ept> and <bpt id="p2">*</bpt>unbox<ept id="p2">*</ept> data, because each one is specialized for one data type.</source>
          <target state="translated">제네릭 형식은 데이터 <bpt id="p1">*</bpt>box<ept id="p1">*</ept> 및 <bpt id="p2">*</bpt>unbox<ept id="p2">*</ept> 작업을 수행할 필요가 없습니다. 각각 하나의 데이터 형식에 특수화되기 때문입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Operations based on <ph id="ph1">`Object`</ph> must box input data types to convert them to <ph id="ph2">`Object`</ph> and unbox data destined for output.</source>
          <target state="translated"><ph id="ph1">`Object`</ph> 에 기반한 작업에서는 입력 데이터 형식에 box 작업을 수행하여 <ph id="ph2">`Object`</ph> 로 변환한 다음 출력을 위한 데이터를 unbox해야 합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Boxing and unboxing reduce performance.</source>
          <target state="translated">이러한 box 및 unbox 작업으로 성능이 저하됩니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Types based on <ph id="ph1">`Object`</ph> are also late-bound, which means that accessing their members requires extra code at run time.</source>
          <target state="translated">또한 <ph id="ph1">`Object`</ph> 에 기반한 형식은 런타임에 바인딩되므로 해당 멤버에 액세스하려면 런타임에 추가 코드가 필요합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This also reduces performance.</source>
          <target state="translated">이 경우에도 성능이 저하됩니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Code Consolidation.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>코드 통합입니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The code in a generic type has to be defined only once.</source>
          <target state="translated">제네릭 형식의 코드는 한 번만 정의하면 됩니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A set of type-specific versions of a type must replicate the same code in each version, with the only difference being the specific data type for that version.</source>
          <target state="translated">형식의 형식 특정 버전 집합은 각 버전에서 동일한 코드를 복제해야 하며 유일한 차이는 해당 버전의 특정 데이터 형식입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>With generic types, the type-specific versions are all generated from the original generic type.</source>
          <target state="translated">제네릭 형식을 사용하면 형식 특정 버전이 모두 원본 제네릭 형식에서 생성됩니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Code Reuse.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>코드 다시 사용 합니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Code that does not depend on a particular data type can be reused with various data types if it is generic.</source>
          <target state="translated">특정 데이터 형식에 종속되지 않는 코드는 제네릭일 경우 여러 데이터 형식에 재사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>You can often reuse it even with a data type that you did not originally predict.</source>
          <target state="translated">원래 예상하지 않았던 데이터 형식에도 재사용할 수 있는 경우도 많습니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>IDE Support.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>IDE 지원 합니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>When you use a constructed type declared from a generic type, the integrated development environment (IDE) can give you more support while you are developing your code.</source>
          <target state="translated">제네릭 형식에서 선언된 생성된 형식을 사용하면 코드 개발 시 IDE(통합 개발 환경)에서 더 많은 지원 기능이 제공됩니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For example, IntelliSense can show you the type-specific options for an argument to a constructor or method.</source>
          <target state="translated">예를 들어 IntelliSense가 생성자 또는 메서드의 인수에 대한 형식 특정 옵션을 표시할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Generic Algorithms.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>제네릭 알고리즘입니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Abstract algorithms that are type-independent are good candidates for generic types.</source>
          <target state="translated">형식에 독립적인 추상 알고리즘이 제네릭 형식의 좋은 후보입니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For example, a generic procedure that sorts items using the &lt;xref:System.IComparable&gt; interface can be used with any data type that implements &lt;xref:System.IComparable&gt;.</source>
          <target state="translated">예를 들어, 제네릭 프로시저 임을 확인 하는 &lt;xref:System.IComparable&gt;인터페이스 &lt;xref:System.IComparable&gt;.&lt;/xref:System.IComparable&gt; 를 구현 하는 모든 데이터 형식을 사용 하 여&lt;/xref:System.IComparable&gt; 사용 하 여 항목을 정렬</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Constraints</source>
          <target state="translated">제약 조건</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Although the code in a generic type definition should be as type-independent as possible, you might need to require a certain capability of any data type supplied to your generic type.</source>
          <target state="translated">제네릭 형식 정의의 코드는 가능한 형식에 독립적이어야 하지만 제네릭 형식에 제공되는 모든 데이터 형식의 특정 기능을 요구해야 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example, if you want to compare two items for the purpose of sorting or collating, their data type must implement the &lt;xref:System.IComparable&gt; interface.</source>
          <target state="translated">예를 들어, 정렬 또는 데이터 정렬을 위해 두 항목을 비교 하려는 경우 데이터 형식을 구현 해야는 &lt;xref:System.IComparable&gt;인터페이스.&lt;/xref:System.IComparable&gt;</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>You can enforce this requirement by adding a <bpt id="p1">*</bpt>constraint<ept id="p1">*</ept> to the type parameter.</source>
          <target state="translated">형식 매개 변수에 <bpt id="p1">*</bpt>제약 조건<ept id="p1">*</ept> 을 추가하여 이 요구 사항을 적용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Example of a Constraint</source>
          <target state="translated">제약 조건의 예</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The following example shows a skeleton definition of a class with a constraint that requires the type argument to implement &lt;xref:System.IComparable&gt;.</source>
          <target state="translated">다음 예제에서 형식 인수 &lt;xref:System.IComparable&gt;.&lt;/xref:System.IComparable&gt; 를 구현 하는 제약 조건 사용 하는 클래스의 기본 정의 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrDataTypes#5<ept id="p2">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_5.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrDataTypes #&amp;5;<ept id="p2">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_5.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If subsequent code attempts to construct a class from <ph id="ph1">`itemManager`</ph> supplying a type that does not implement &lt;xref:System.IComparable&gt;, the compiler signals an error.</source>
          <target state="translated">이후 코드에서 클래스를 생성 하려고 할 경우 <ph id="ph1">`itemManager`</ph> 구현 하지 않는 한 형식을 제공 &lt;xref:System.IComparable&gt;, 컴파일러에서 오류를 알립니다.&lt;/xref:System.IComparable&gt;</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Types of Constraints</source>
          <target state="translated">제약 조건의 형식</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Your constraint can specify the following requirements in any combination:</source>
          <target state="translated">제약 조건은 다음 요구 사항을 원하는 대로 조합하여 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The type argument must implement one or more interfaces</source>
          <target state="translated">형식 인수는 하나 이상의 인터페이스를 구현해야 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The type argument must be of the type of, or inherit from, at most one class</source>
          <target state="translated">형식 인수는 최대 하나의 클래스에서 형식을 상속하거나 해당 클래스의 형식이어야 함</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The type argument must expose a parameterless constructor accessible to the code that creates objects from it</source>
          <target state="translated">형식 인수는 매개 변수 없는 생성자로부터 개체를 만드는 코드에 액세스할 수 있는 매개 변수 없는 생성자를 노출해야 함</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The type argument must be a <bpt id="p1">*</bpt>reference type<ept id="p1">*</ept>, or it must be a <bpt id="p2">*</bpt>value type<ept id="p2">*</ept></source>
          <target state="translated">형식 인수는 <bpt id="p1">*</bpt>참조 형식<ept id="p1">*</ept>이거나 <bpt id="p2">*</bpt>값 형식<ept id="p2">*</ept>이어야 함</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If you need to impose more than one requirement, you use a comma-separated <bpt id="p1">*</bpt>constraint list<ept id="p1">*</ept> inside braces (<ph id="ph1">`{ }`</ph>).</source>
          <target state="translated">둘 이상의 요구 사항을 적용해야 하는 경우 쉼표로 구분된 <bpt id="p1">*</bpt>제약 조건 목록<ept id="p1">*</ept> 을 중괄호(<ph id="ph1">`{ }`</ph>) 안에 넣으세요.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>To require an accessible constructor, you include the <bpt id="p1">[</bpt>New Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/new-operator.md)</ept> keyword in the list.</source>
          <target state="translated">포함 하는 액세스 가능 생성자를 필요로 하는 <bpt id="p1">[</bpt>New 연산자<ept id="p1">](../../../../visual-basic/language-reference/operators/new-operator.md)</ept> 키워드 목록에 있습니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>To require a reference type, you include the <ph id="ph1">`Class`</ph> keyword; to require a value type, you include the <ph id="ph2">`Structure`</ph> keyword.</source>
          <target state="translated">참조 형식을 요구하려면 <ph id="ph1">`Class`</ph> 키워드를 넣고, 값 형식을 요구하려면 <ph id="ph2">`Structure`</ph> 키워드를 넣으세요.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>For more information on constraints, see <bpt id="p1">[</bpt>Type List<ept id="p1">](../../../../visual-basic/language-reference/statements/type-list.md)</ept>.</source>
          <target state="translated">참조 제약 조건에 대 한 자세한 내용은 <bpt id="p1">[</bpt>유형 목록<ept id="p1">](../../../../visual-basic/language-reference/statements/type-list.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Example of Multiple Constraints</source>
          <target state="translated">다중 제약 조건의 예</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The following example shows a skeleton definition of a generic class with a constraint list on the type parameter.</source>
          <target state="translated">다음 예제에서는 형식 매개 변수에 제약 조건 목록이 있는 제네릭 클래스의 기본 정의를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In the code that creates an instance of this class, the type argument must implement both the &lt;xref:System.IComparable&gt; and &lt;xref:System.IDisposable&gt; interfaces, be a reference type, and expose an accessible parameterless constructor.</source>
          <target state="translated">이 클래스의 인스턴스를 만드는 코드에서 형식 인수 모두 구현 해야는 &lt;xref:System.IComparable&gt;및 &lt;xref:System.IDisposable&gt;인터페이스를 참조 형식 이어야 하 고 액세스 가능한 매개 변수가 없는 생성자를 노출 합니다.&lt;/xref:System.IDisposable&gt; &lt;/xref:System.IComparable&gt;</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrDataTypes#6<ept id="p2">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_6.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrDataTypes #&amp;6;<ept id="p2">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_6.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Important Terms</source>
          <target state="translated">중요 용어</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Generic types introduce and use the following terms:</source>
          <target state="translated">제네릭 형식에서는 다음의 용어를 사용합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Generic Type<ept id="p1">*</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>제네릭 형식<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>A definition of a class, structure, interface, procedure, or delegate for which you supply at least one data type when you declare it.</source>
          <target state="translated">선언할 때 최소 하나의 데이터 형식을 제공하는 클래스, 구조체, 인터페이스, 프로시저 또는 대리자의 정의입니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Type Parameter<ept id="p1">*</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>형식 매개 변수<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>In a generic type definition, a placeholder for a data type you supply when you declare the type.</source>
          <target state="translated">제네릭 형식 정의에서 형식을 선언할 때 제공하는 데이터 형식에 대한 자리 표시자입니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Type Argument<ept id="p1">*</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>형식 인수<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>A specific data type that replaces a type parameter when you declare a constructed type from a generic type.</source>
          <target state="translated">제네릭 형식에서 생성된 형식을 선언할 때 형식 매개 변수를 대체하는 특정 데이터 형식입니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Constraint<ept id="p1">*</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>제약 조건<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>A condition on a type parameter that restricts the type argument you can supply for it.</source>
          <target state="translated">제공할 수 있는 형식 인수를 제한하는 형식 매개 변수에 대한 조건입니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A constraint can require that the type argument must implement a particular interface, be or inherit from a particular class, have an accessible parameterless constructor, or be a reference type or a value type.</source>
          <target state="translated">제약 조건은 형식 인수가 특정 인터페이스를 구현하도록 요구하거나, 특정 클래스이거나 특정 클래스에서 상속되도록 요구하거나, 액세스 가능한 매개 변수 없는 생성자를 가지도록 요구하거나, 참조 형식 또는 값 형식이도록 요구할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>You can combine these constraints, but you can specify at most one class.</source>
          <target state="translated">이러한 제약 조건을 결합할 수 있지만 최대 하나의 클래스를 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Constructed Type<ept id="p1">*</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>생성된 형식<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>A class, structure, interface, procedure, or delegate declared from a generic type by supplying type arguments for its type parameters.</source>
          <target state="translated">형식 매개 변수에 대한 형식 인수를 제공하여 제네릭 형식에서 선언된 클래스, 구조체, 인터페이스, 프로시저 또는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Data Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>데이터 형식<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Type Characters<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>형식 문자<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Value Types and Reference Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>값 형식과 참조 형식<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Type Conversions in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Visual Basic의 형식 변환<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Troubleshooting Data Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>데이터 형식 문제 해결<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Data Types<ept id="p1">](../../../../visual-basic/language-reference/data-types/data-type-summary.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>데이터 형식<ept id="p1">](../../../../visual-basic/language-reference/data-types/data-type-summary.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Of<ept id="p1">](../../../../visual-basic/language-reference/statements/of-clause.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Of<ept id="p1">](../../../../visual-basic/language-reference/statements/of-clause.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>As<ept id="p1">](../../../../visual-basic/language-reference/statements/as-clause.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>마찬가지로<ept id="p1">](../../../../visual-basic/language-reference/statements/as-clause.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Object Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/object-data-type.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Object 데이터 형식<ept id="p1">](../../../../visual-basic/language-reference/data-types/object-data-type.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Covariance and Contravariance<ept id="p1">](http://msdn.microsoft.com/library/a58cc086-276f-4f91-a366-85b7f95f38b8)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>공 분산과 반공 분산<ept id="p1">](http://msdn.microsoft.com/library/a58cc086-276f-4f91-a366-85b7f95f38b8)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Iterators<ept id="p1">](http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>반복기<ept id="p1">](http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>