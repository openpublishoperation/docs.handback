<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ef2a63115f1efbe2418c348a3379fe7dd2face86</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\anchors.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d2e25c2b175059780bad8d84610bac5dd45943c9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">94ae0e65a6ef73d01b61abaca196f9a10a7fd773</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file anchors.50a7162cb6a767810c7039d111f04386c7a19099.pt-br.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Anchors in regular expressions</source>
          <target state="translated">Âncoras em expressões regulares</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Anchors in regular expressions</source>
          <target state="translated">Âncoras em expressões regulares</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Anchors in regular expressions</source>
          <target state="translated">Âncoras em expressões regulares</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Anchors, or atomic zero-width assertions, specify a position in the string where a match must occur.</source>
          <target state="translated">Âncoras ou asserções atômicas de largura zero, especificam uma posição na cadeia de caracteres em que uma correspondência deve ocorrer.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>When you use an anchor in your search expression, the regular expression engine does not advance through the string or consume characters; it looks for a match in the specified position only.</source>
          <target state="translated">Quando você usa uma âncora na sua expressão de pesquisa, o mecanismo de expressões regulares não avança pela cadeia de caracteres ou consome caracteres, ele procura uma correspondência apenas na posição especificada.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> specifies that the match must start at the beginning of a line or string.</source>
          <target state="translated">Por exemplo, <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> Especifica que a correspondência deve começar no início de uma linha ou cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Therefore, the regular expression <ph id="ph1">`^http:`</ph> matches "http:" only when it occurs at the beginning of a line.</source>
          <target state="translated">Portanto, a expressão regular <ph id="ph1">`^http:`</ph> corresponde a "http:" apenas quando ele ocorre no início de uma linha.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The following table lists the anchors supported by the regular expressions in .NET.</source>
          <target state="translated">A tabela a seguir lista as âncoras com suporte pelas expressões regulares no .NET.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Anchor</source>
          <target state="translated">Âncora</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The match must occur at the beginning of the string or line.</source>
          <target state="translated">A correspondência deve ocorrer no início da cadeia de caracteres ou da linha.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string or line, or before \n at the end of the string or line.</source>
          <target state="translated">A correspondência deve ocorrer no final da cadeia de caracteres ou linha ou antes de \n no final da linha ou da cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\A<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\A<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The match must occur at the beginning of the string only (no multiline support)</source>
          <target state="translated">A correspondência deve ocorrer no início da cadeia de caracteres apenas (sem suporte a multilinha)</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\Z<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string, or before \n at the end of the string.</source>
          <target state="translated">A correspondência deve ocorrer no final da cadeia de caracteres ou antes de \n no final da cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\z<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\z<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string only.</source>
          <target state="translated">A correspondência deve ocorrer apenas no final da cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\G<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\G<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The match must start at the position where the previous match ended.</source>
          <target state="translated">A correspondência deve começar na posição em que a correspondência anterior foi encerrada.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\b<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\b<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The match must occur on a word boundary.</source>
          <target state="translated">A correspondência deve ocorrer em um limite de palavra.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>\B<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>\B<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The match must not occur on a word boundary.</source>
          <target state="translated">A correspondência não deve ocorrer em um limite de palavra.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Start of String or Line: ^</source>
          <target state="translated">Início da Cadeia de Caracteres ou Linha: ^</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> anchor specifies that the following pattern must begin at the first character position of the string.</source>
          <target state="translated">A âncora <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> especifica que o seguinte padrão deve começar na posição do primeiro caractere da cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> with the <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option (see <bpt id="p3">[</bpt>Regular expression options<ept id="p3">](options.md)</ept>), the match must occur at the beginning of each line.</source>
          <target state="translated">Se você usar <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> com a opção <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> (consulte <bpt id="p3">[</bpt>Opções de expressões regulares<ept id="p3">](options.md)</ept>), a correspondência deverá ocorrer no início de cada linha.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">O exemplo a seguir usa a âncora <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> em uma expressão regular que extrai informações sobre os anos durante os quais algumas equipes de profissionais de beisebol existiram.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The example calls two overloads of the <ph id="ph1">`Regex.Matches`</ph> method:</source>
          <target state="translated">O exemplo chama duas sobrecargas do método <ph id="ph1">`Regex.Matches`</ph>:</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The call to the <bpt id="p1">[</bpt>Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> overload finds only the first substring in the input string that matches the regular expression pattern.</source>
          <target state="translated">A chamada para a sobrecarga <bpt id="p1">[</bpt>Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> localiza apenas a primeira subcadeia de caracteres na cadeia de caracteres de entrada que corresponde ao padrão de expressão regular.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The call to the <bpt id="p1">[</bpt>Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> overload with the options parameter set to <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> finds all five substrings.</source>
          <target state="translated">A chamada para a sobrecarga <bpt id="p1">[</bpt>Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> com o parâmetro de opções definido como <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> localiza todas as cinco subcadeias de caracteres.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+`</ph> is defined as shown in the following table.</source>
          <target state="translated">O padrão de expressão regular <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+`</ph> é definido conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the input string (or the beginning of the line if the method is called with the <ph id="ph1">`RegexOptions.Multiline`</ph> option).</source>
          <target state="translated">Começa a correspondência no início da cadeia de caracteres de entrada (ou o início da linha se o método for chamado com a opção <ph id="ph1">`RegexOptions.Multiline`</ph>).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed either by zero or by one space exactly two times.</source>
          <target state="translated">Corresponde a um ou mais caracteres de palavra seguidos por zero ou um espaço exatamente duas vezes.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Este é o primeiro grupo de captura.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This expression also defines a second and third capturing group: The second consists of the captured word, and the third consists of the captured spaces.</source>
          <target state="translated">Essa expressão também define um segundo e um terceiro grupos de captura: o segundo consiste na palavra capturada e o terceiro consiste nos espaços capturados.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Match a comma followed by a white-space character.</source>
          <target state="translated">Corresponde a uma vírgula seguida por um caractere de espaço em branco.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a space, followed by one or more word characters.</source>
          <target state="translated">Corresponde a um ou mais caracteres de palavra seguidos por um espaço, seguido por um ou mais caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This is the fourth capturing group.</source>
          <target state="translated">Este é o quarto grupo de captura.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Match a comma.</source>
          <target state="translated">Corresponde a uma vírgula.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Match a space followed by four decimal digits.</source>
          <target state="translated">Corresponde a um espaço seguido por quatro dígitos decimais.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?`</ph></source>
          <target state="translated"><ph id="ph1">`(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?`</ph></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a hyphen followed by four decimal digits or the string "present".</source>
          <target state="translated">Corresponde a zero ou uma ocorrência de um hífen seguido por quatro dígitos decimais ou a cadeia de caracteres "present".</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This is the sixth capturing group.</source>
          <target state="translated">Este é o sexto grupo de captura.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>It also includes a seventh capturing group.</source>
          <target state="translated">Ele também inclui um sétimo grupo de captura.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a comma.</source>
          <target state="translated">Corresponde a zero ou uma ocorrência de uma vírgula.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(\s\d{4}(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?,?)+`</ph></source>
          <target state="translated"><ph id="ph1">`(\s\d{4}(-(\d{4}`</ph>&amp;#124;<ph id="ph2">`present))?,?)+`</ph></target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of the following: a space, four decimal digits, zero or one occurrence of a hyphen followed by four decimal digits or the string "present", and zero or one comma.</source>
          <target state="translated">Corresponde a uma ou mais ocorrências do seguinte: um espaço, quatro dígitos decimais, zero ou uma ocorrência de um hífen seguido por quatro dígitos decimais ou a cadeia de caracteres "present" e zero ou uma vírgula.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This is the fifth capturing group.</source>
          <target state="translated">Este é o quinto grupo de captura.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>End of String or Line: $</source>
          <target state="translated">Final da Cadeia de Caracteres ou da Linha: $</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string.</source>
          <target state="translated">A âncora <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> especifica que o padrão anterior deve ocorrer no final da cadeia de caracteres de entrada ou antes de \n no final da cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> with the <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, the match can also occur at the end of a line.</source>
          <target state="translated">Se você usar <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> com a opção <bpt id="p2">[</bpt>RegexOptions.Multiline<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>, a correspondência também pode ocorrer no final de uma linha.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Note that <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> matches <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> but does not match <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (the combination of carriage return and newline characters, or CR/LF).</source>
          <target state="translated">Observe que <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> corresponde a <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>, mas não corresponde a <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (a combinação de caracteres de nova linha e de retorno de carro ou CR/LF).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To match the CR/LF character combination, include <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> in the regular expression pattern.</source>
          <target state="translated">De acordo com a combinação de caracteres CR/LF, inclua <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> no padrão de expressão regular.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following example adds the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> anchor to the regular expression pattern used in the example in the previous "Start of String or Line" section.</source>
          <target state="translated">O exemplo a seguir adiciona a âncora <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> ao padrão de expressão regular usada no exemplo na seção anterior "Início da cadeia de caracteres ou linha".</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When used with the original input string, which includes five lines of text, the <bpt id="p1">[</bpt>Regex.Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> method is unable to find a match, because the end of the first line does not match the <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept> pattern.</source>
          <target state="translated">Quando usado com a cadeia de caracteres de entrada original, que inclui cinco linhas de texto, o método <bpt id="p1">[</bpt>Regex.Matches(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String))</ept> não pode localizar uma correspondência, pois o final da primeira linha não corresponde ao padrão <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>When the original input string is split into a string array, the <ph id="ph1">`Regex.Matches(String, String)`</ph> method succeeds in matching each of the five lines.</source>
          <target state="translated">Quando a cadeia de caracteres de entrada original é dividida em uma matriz de cadeia de caracteres, o método <ph id="ph1">`Regex.Matches(String, String)`</ph> obtém sucesso na correspondência de cada uma das cinco linhas.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When the <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with the <bpt id="p2">*</bpt>options<ept id="p2">*</ept> parameter set to <ph id="ph1">`RegexOptions.Multiline`</ph>, no matches are found because the regular expression pattern does not account for the carriage return element (\u+000D).</source>
          <target state="translated">Quando o método <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> for chamado com o parâmetro <bpt id="p2">*</bpt>options<ept id="p2">*</ept> definido como <ph id="ph1">`RegexOptions.Multiline`</ph>, nenhuma correspondência será encontrada porque o padrão de expressão regular não considera o elemento de retorno de carro (\u+000D).</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>However, when the regular expression pattern is modified by replacing <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> with <bpt id="p2">**</bpt>\r?$<ept id="p2">**</ept>, calling the <ph id="ph2">`Regex.Matches(String, String, RegexOptions)`</ph> method with the <bpt id="p3">*</bpt>options<ept id="p3">*</ept> parameter set to <ph id="ph3">`RegexOptions.Multiline`</ph> again finds five matches.</source>
          <target state="translated">No entanto, quando o padrão de expressão regular é modificado substituindo <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> por <bpt id="p2">**</bpt>\r?$<ept id="p2">**</ept>, chamar o método <ph id="ph2">`Regex.Matches(String, String, RegexOptions)`</ph> com o parâmetro <bpt id="p3">*</bpt>options<ept id="p3">*</ept> definido como <ph id="ph3">`RegexOptions.Multiline`</ph> novamente encontra cinco correspondências.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Start of String Only: \A</source>
          <target state="translated">Apenas Início da Cadeia de Caracteres: \A</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> anchor specifies that a match must occur at the beginning of the input string.</source>
          <target state="translated">A âncora <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> especifica que uma correspondência deve ocorrer no início da cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>It is identical to the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> anchor, except that <bpt id="p2">**</bpt>\A<ept id="p2">**</ept> ignores the <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option.</source>
          <target state="translated">Ela é idêntica à âncora <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept>, exceto que <bpt id="p2">**</bpt>\A<ept id="p2">**</ept> ignora a opção <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Therefore, it can only match the start of the first line in a multiline input string.</source>
          <target state="translated">Portanto, ela pode corresponder apenas ao início da primeira linha em uma cadeia de caracteres de entrada multilinhas.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The following example is similar to the examples for the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> anchors.</source>
          <target state="translated">O exemplo a seguir é semelhante aos exemplos das âncoras <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> e <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">Ele usa a âncora <bpt id="p1">**</bpt>\A<ept id="p1">**</ept> em uma expressão regular que extrai informações sobre os anos durante os quais algumas equipes de profissionais de beisebol existiram.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The input string includes five lines.</source>
          <target state="translated">A cadeia de caracteres de entrada inclui cinco linhas.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The call to the <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method finds only the first substring in the input string that matches the regular expression pattern.</source>
          <target state="translated">A chamada para o método <bpt id="p1">[</bpt>Regex.Matches(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> localiza apenas a primeira subcadeia de caracteres na cadeia de caracteres de entrada que corresponde ao padrão de expressão regular.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>As the example shows, the <ph id="ph1">`Multiline`</ph> option has no effect.</source>
          <target state="translated">Como o exemplo mostra, a opção <ph id="ph1">`Multiline`</ph> não tem efeito.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>End of String or Before Ending Newline: \Z</source>
          <target state="translated">Final da Cadeia de Caracteres ou Antes de Terminar Nova Linha: \ Z</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> anchor specifies that a match must occur at the end of the input string, or before <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> at the end of the input string.</source>
          <target state="translated">A âncora <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> especifica que a correspondência deve ocorrer no final da cadeia de caracteres de entrada ou antes de <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> no final da cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>It is identical to the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> anchor, except that <bpt id="p2">**</bpt>\Z<ept id="p2">**</ept> ignores the <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option.</source>
          <target state="translated">Ela é idêntica à âncora <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept>, exceto que <bpt id="p2">**</bpt>\Z<ept id="p2">**</ept> ignora a opção <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Therefore, in a multiline string, it can only match the end of the last line, or the last line before <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</source>
          <target state="translated">Portanto, em uma cadeia de caracteres multilinhas, ela pode corresponder apenas ao final da última linha ou à última linha antes de <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Note that <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> matches <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> but does not match <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (the CR/LF character combination).</source>
          <target state="translated">Observe que <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> corresponde a <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> mas não corresponde a <bpt id="p3">**</bpt>\r\n<ept id="p3">**</ept> (a combinação de caracteres CR/LF).</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>To match CR/LF, include <bpt id="p1">**</bpt>\r?\Z<ept id="p1">**</ept> in the regular expression pattern.</source>
          <target state="translated">Para corresponder a CR/LF, inclua <bpt id="p1">**</bpt>\r?\Z<ept id="p1">**</ept> no padrão da expressão regular.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> anchor in a regular expression that is similar to the example in the previous "Start of String or Line" section, which extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">O exemplo a seguir usa a âncora <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> em uma expressão regular semelhante ao exemplo na seção “Início da Cadeia de Caracteres ou Linha” anterior, que extrai informações sobre os anos durante os quais algumas equipes de profissionais de beisebol existiram.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The subexpression <ph id="ph1">`\r?\Z`</ph> in the regular expression <ph id="ph2">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z`</ph> matches the end of a string, and also matches a string that ends with <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> or <bpt id="p2">**</bpt>\r\n<ept id="p2">**</ept>.</source>
          <target state="translated">A subexpressão <ph id="ph1">`\r?\Z`</ph> na expressão regular <ph id="ph2">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z`</ph> corresponde ao final de uma cadeia de caracteres e também corresponde a uma cadeia de caracteres que termina com <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> ou <bpt id="p2">**</bpt>\r\n<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>As a result, each element in the array matches the regular expression pattern.</source>
          <target state="translated">Como resultado, cada elemento da matriz corresponde ao padrão da expressão regular.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>End of String Only: \z</source>
          <target state="translated">Apenas Final da Cadeia de Caracteres: \ z</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> anchor specifies that a match must occur at the end of the input string.</source>
          <target state="translated">A âncora <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> especifica que uma correspondência deve ocorrer no final da cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Like the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> language element, <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> ignores the <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option.</source>
          <target state="translated">Como o elemento de linguagem <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept>, <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> ignora a opção <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Unlike the <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept> language element, <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> does not match a <bpt id="p3">**</bpt>\n<ept id="p3">**</ept> character at the end of a string.</source>
          <target state="translated">Diferentemente do elemento de linguagem <bpt id="p1">**</bpt>\Z<ept id="p1">**</ept>, <bpt id="p2">**</bpt>\z<ept id="p2">**</ept> não corresponde ao caractere <bpt id="p3">**</bpt>\n<ept id="p3">**</ept> no final de uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Therefore, it can only match the last line of the input string.</source>
          <target state="translated">Portanto, ele pode corresponder somente à última linha da cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> anchor in a regular expression that is otherwise identical to the example in the previous section, which extracts information about the years during which some professional baseball teams existed.</source>
          <target state="translated">O exemplo a seguir usa a âncora <bpt id="p1">**</bpt>\z<ept id="p1">**</ept> em uma expressão regular que é de outro modo idêntica ao exemplo na seção anterior, que extrai informações sobre os anos durante os quais algumas equipes de profissionais de beisebol existiram.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The example tries to match each of five elements in a string array with the regular expression pattern <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`</ph>.</source>
          <target state="translated">O exemplo tenta corresponder cada um dos cinco elementos em uma matriz de cadeia de caracteres com um padrão de expressão regular <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Two of the strings end with carriage return and line feed characters, one ends with a line feed character, and two end with neither a carriage return nor a line feed character.</source>
          <target state="translated">Duas das cadeias de caracteres terminam com os caracteres de alimentação de linha e retorno de carro, uma termina com um caractere de alimentação de linha e duas terminam sem um caractere de retorno de carro nem um caractere de alimentação de linha.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>As the output shows, only the strings without a carriage return or line feed character match the pattern.</source>
          <target state="translated">Como a saída mostra, apenas as cadeias de caracteres sem um caractere de retorno de carro ou de alimentação de linha correspondem ao padrão.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Contiguous Matches: \G</source>
          <target state="translated">Correspondências Contíguas: \ G</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\G<ept id="p1">**</ept> anchor specifies that a match must occur at the point where the previous match ended.</source>
          <target state="translated">A âncora <bpt id="p1">**</bpt>\G<ept id="p1">**</ept> especifica que uma correspondência deve ocorrer no ponto em que a correspondência anterior foi encerrada.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>When you use this anchor with the <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> or <bpt id="p2">[</bpt>Match.NextMatch<ept id="p2">](xref:System.Text.RegularExpressions.Match.NextMatch)</ept> method, it ensures that all matches are contiguous.</source>
          <target state="translated">Quando você usa essa âncora com o método <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> ou <bpt id="p2">[</bpt>Match.NextMatch<ept id="p2">](xref:System.Text.RegularExpressions.Match.NextMatch)</ept>, ela garante que todas as correspondências são contíguas.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The following example uses a regular expression to extract the names of rodent species from a comma-delimited string.</source>
          <target state="translated">O exemplo a seguir usa uma expressão regular para extrair os nomes de espécies de roedores de uma cadeia de caracteres delimitada por vírgulas.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\G(\w+\s?\w*),?`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">A expressão regular <ph id="ph1">`\G(\w+\s?\w*),?`</ph> é interpretada conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Begin where the last match ended.</source>
          <target state="translated">Começa onde a última correspondência terminou.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Fazer a correspondência a um ou mais caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Match zero or one space.</source>
          <target state="translated">Corresponde a zero ou um espaço.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
          <target state="translated">Corresponder a zero ou mais caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by zero or one space, followed by zero or more word characters.</source>
          <target state="translated">Corresponde a um ou mais caracteres de palavra seguidos por zero ou um espaço, seguido por zero ou mais caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">Este é o primeiro grupo de captura.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a literal comma character.</source>
          <target state="translated">Corresponde a zero ou uma ocorrência de um caractere de vírgula literal.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Word Boundary: \b</source>
          <target state="translated">Limite de Palavra: \b</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> anchor specifies that the match must occur on a boundary between a word character (the <bpt id="p2">**</bpt>\w<ept id="p2">**</ept> language element) and a non-word character (the <bpt id="p3">**</bpt>\W<ept id="p3">**</ept> language element).</source>
          <target state="translated">A âncora <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> especifica que a correspondência deve ocorrer em um limite entre um caractere de palavra (o elemento de linguagem <bpt id="p2">**</bpt>\w<ept id="p2">**</ept>) e um caractere não pertencente a palavras (o elemento de linguagem <bpt id="p3">**</bpt>\W<ept id="p3">**</ept>).</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore.</source>
          <target state="translated">Os caracteres de palavra consistem em caracteres alfanuméricos e sublinhados. Um caractere não pertencente a palavras é qualquer caractere que não seja alfanumérico ou um sublinhado.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>(For more information, see <bpt id="p1">[</bpt>Character classes in regular expressions<ept id="p1">](classes.md)</ept>.) The match may also occur on a word boundary at the beginning or end of the string.</source>
          <target state="translated">(Para obter mais informações, confira <bpt id="p1">[</bpt>Classes de caracteres em expressões regulares<ept id="p1">](classes.md)</ept>.) A correspondência também pode ocorrer em um limite de palavra no início ou no final da cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
          <target state="translated">A âncora <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> frequentemente é usada para garantir que uma subexpressão corresponda a uma palavra inteira, em vez de apenas ao início ou final de uma palavra.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\bare\w*\b`</ph> in the following example illustrates this usage.</source>
          <target state="translated">A expressão regular <ph id="ph1">`\bare\w*\b`</ph> no exemplo a seguir ilustra esse uso.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>It matches any word that begins with the substring "are".</source>
          <target state="translated">Ela corresponde a qualquer palavra que comece com a subcadeia de caracteres "are".</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The output from the example also illustrates that <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> matches both the beginning and the end of the input string.</source>
          <target state="translated">A saída do exemplo também ilustra que <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> corresponde ao início e ao final da cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">O padrão da expressão regular é interpretado conforme a tabela a seguir.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Começar a correspondência em um limite de palavra.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match the substring "are".</source>
          <target state="translated">Corresponde à subcadeia de caracteres “are”.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
          <target state="translated">Corresponder a zero ou mais caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Termina a correspondência em um limite de palavra.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Non-Word Boundary: \B</source>
          <target state="translated">Limite de Não Palavra: \B</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> anchor specifies that the match must not occur on a word boundary.</source>
          <target state="translated">A âncora <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> especifica que a correspondência não deve ocorrer em um limite de palavra.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>It is the opposite of the <bpt id="p1">**</bpt>\b<ept id="p1">**</ept> anchor.</source>
          <target state="translated">É o oposto da âncora <bpt id="p1">**</bpt>\b<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> anchor to locate occurrences of the substring "qu" in a word.</source>
          <target state="translated">O exemplo a seguir usa a âncora <bpt id="p1">**</bpt>\B<ept id="p1">**</ept> para localizar ocorrências da subcadeia de caracteres "qu" em uma palavra.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\Bqu\w+`</ph> matches a substring that begins with a "qu" that does not start a word and that continues to the end of the word.</source>
          <target state="translated">O padrão de expressão regular <ph id="ph1">`\Bqu\w+`</ph> corresponde a uma subcadeia de caracteres que começa com um "qu" que não inicia uma palavra e que continua até o final da palavra.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">O padrão da expressão regular é interpretado conforme a tabela a seguir.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Do not begin the match at a word boundary.</source>
          <target state="translated">Não começa a correspondência em um limite de palavra.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Match the substring "qu".</source>
          <target state="translated">Corresponde à subcadeia de caracteres “qu”.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Fazer a correspondência a um ou mais caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Consulte também</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Linguagem de expressão regular – referência rápida<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Opções de expressões regulares<ept id="p1">](options.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>