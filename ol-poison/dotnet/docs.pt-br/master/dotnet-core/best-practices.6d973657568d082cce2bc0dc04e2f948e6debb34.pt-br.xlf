<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d92549bf46f1c7a728bc6e2ac7cb183251115084</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\best-practices.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">29a81bfee1bf49fb6b417139448a333398f8a0b0</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f5f2f83420d224fc7138a8161f172550635ffde7</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file best-practices.6d973657568d082cce2bc0dc04e2f948e6debb34.pt-br.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Best practices for regular expressions</source>
          <target state="translated">Práticas recomendadas para expressões regulares</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Best practices for regular expressions</source>
          <target state="translated">Práticas recomendadas para expressões regulares</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Best practices for regular expressions</source>
          <target state="translated">Práticas recomendadas para expressões regulares</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</source>
          <target state="translated">O mecanismo de expressões regulares no .NET é uma ferramenta poderosa e repleta de recursos que processa o texto com base em correspondências de padrões em vez de em comparar e corresponder o texto literal.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In most cases, it performs pattern matching rapidly and efficiently.</source>
          <target state="translated">Na maioria dos casos, ele realiza a correspondência de padrões de forma rápida e eficiente.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>However, in some cases, the regular expression engine can appear to be very slow.</source>
          <target state="translated">No entanto, em alguns casos, o mecanismo de expressões regulares pode parecer ser muito lento.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</source>
          <target state="translated">Em casos extremos, pode até mesmo parecer parar de responder enquanto processa uma entrada relativamente pequena em um período de horas ou até mesmo dias.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</source>
          <target state="translated">Este tópico descreve algumas das práticas recomendadas que os desenvolvedores podem adotar para garantir que as expressões regulares obtenham o máximo de desempenho.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It contains the following sections:</source>
          <target state="translated">Ele contém as seguintes seções:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Consider the input source<ept id="p1">](#consider-the-input-source)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Considere a fonte de entrada<ept id="p1">](#consider-the-input-source)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Handle object instantiation appropriately<ept id="p1">](#handle-object-instantiation-appropriately)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Trate a instanciação de objetos adequadamente<ept id="p1">](#handle-object-instantiation-appropriately)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Take charge of backtracking<ept id="p1">](#take-charge-of-backtracking)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tome conta do retrocesso<ept id="p1">](#take-charge-of-backtracking)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Use time-out values<ept id="p1">](#use-time-out-values)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Use valores de tempo limite<ept id="p1">](#use-time-out-values)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Capture only when necessary<ept id="p1">](#capture-only-when-necessary)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Capture somente quando necessário<ept id="p1">](#capture-only-when-necessary)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Related topics<ept id="p1">](#related-topics)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tópicos relacionados<ept id="p1">](#related-topics)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Consider the input source</source>
          <target state="translated">Considere a fonte de entrada</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In general, regular expressions can accept two types of input: constrained or unconstrained.</source>
          <target state="translated">Em geral, as expressões regulares podem aceitar dois tipos de entrada: restrita e não restrita.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Constrained input is text that originates from a known or reliable source and follows a predefined format.</source>
          <target state="translated">Uma entrada restrita é o texto proveniente de uma fonte conhecida ou confiável e segue um formato predefinido.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</source>
          <target state="translated">Uma entrada irrestrita é um texto que se origina de uma origem não confiável como um usuário não confiável e não pode seguir um formato predefinido ou esperado.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Regular expression patterns are typically written to match valid input.</source>
          <target state="translated">Os padrões de expressões regulares geralmente são escritos para corresponder a entradas válidas.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</source>
          <target state="translated">Ou seja, os desenvolvedores examinam o texto que desejam corresponder e escrevem um padrão de expressão regular que corresponde a ele.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</source>
          <target state="translated">Os desenvolvedores então determinam se esse padrão requer correção ou uma elaboração adicional testando-o com vários itens de entrada válidos.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</source>
          <target state="translated">Quando o padrão corresponde a todas as entradas válidas presumidas, é declarado como pronto para produção e pode ser incluído em um aplicativo final.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This makes a regular expression pattern suitable for matching constrained input.</source>
          <target state="translated">Isso torna um padrão de expressão regular apropriado para corresponder uma entrada restrita.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>However, it does not make it suitable for matching unconstrained input.</source>
          <target state="translated">No entanto, ele não o torna adequado para corresponder à entrada sem restrição.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</source>
          <target state="translated">Para corresponder a uma entrada sem restrição, uma expressão regular deve ser capaz de manipular três tipos de texto:</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>• Text that matches the regular expression pattern.</source>
          <target state="translated">• Texto que corresponda ao padrão da expressão regular.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>• Text that does not match the regular expression pattern.</source>
          <target state="translated">• Texto que não corresponda ao padrão da expressão regular.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>• Text that nearly matches the regular expression pattern.</source>
          <target state="translated">• Texto que quase corresponda ao padrão da expressão regular.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The last text type is especially problematic for a regular expression that has been written to handle constrained input.</source>
          <target state="translated">O último tipo de texto é particularmente problemático para uma expressão regular que foi escrita para lidar com entradas restritas.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If that regular expression also relies on extensive <bpt id="p1">[</bpt>backtracking<ept id="p1">](backtracking.md)</ept>, the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</source>
          <target state="translated">Se essa expressão regular também depender de <bpt id="p1">[</bpt>retrocesso<ept id="p1">](backtracking.md)</ept> abrangente, o mecanismo de expressões regulares poderá gastar um período fora do normal (em alguns casos, muitas horas ou dias) processando texto aparentemente inócuo.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</source>
          <target state="translated">O exemplo a seguir usa uma expressão regular que é propensa a retrocesso excessivo e que pode rejeitar endereços de email válidos.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You should not use it in an email validation routine.</source>
          <target state="translated">Você não deve usá-lo em uma rotina de validação de email.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you would like a regular expression that validates email addresses, see <bpt id="p1">[</bpt>How to: Verify that strings are in valid email format<ept id="p1">](verify-format.md)</ept>.</source>
          <target state="translated">Se você desejar uma expressão regular que valida endereços de email, confira <bpt id="p1">[</bpt>Como verificar se cadeias de caracteres estão em um formato de email válido<ept id="p1">](verify-format.md)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</source>
          <target state="translated">Por exemplo, considere uma expressão regular muito usada, mas extremamente problemática, para validar o alias de um endereço de email.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*$`</ph> is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</source>
          <target state="translated">A expressão regular <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*$`</ph> é escrita para processar o que é considerado um endereço de email válido, o que consiste em um caractere alfanumérico seguido por zero ou mais caracteres que podem ser alfanuméricos, pontos ou hifens.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The regular expression must end with an alphanumeric character.</source>
          <target state="translated">A expressão regular deve terminar com um caractere alfanumérico.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</source>
          <target state="translated">No entanto, como mostra o exemplo a seguir, embora esta expressão regular manipule entradas válidas facilmente, seu desempenho é muito ineficiente ao processar uma entrada quase válida.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</source>
          <target state="translated">Conforme mostrado pela saída do exemplo, o mecanismo de expressões regulares processa o alias de email válido quase no mesmo tempo, independentemente do seu comprimento.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</source>
          <target state="translated">Por outro lado, quando o endereço de email quase válido tem mais de cinco caracteres, o tempo de processamento chega a dobrar para cada caractere adicional na cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</source>
          <target state="translated">Isso significa que uma cadeia de 28 caracteres quase válidos levaria mais de uma hora para ser processada e uma cadeia de 33 caracteres quase válidos demoraria quase um dia.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</source>
          <target state="translated">Como essa expressão regular foi desenvolvida considerando apenas a correspondência com o formato da entrada, ela não leva em consideração entradas que não correspondem ao padrão.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</source>
          <target state="translated">Isso, por sua vez, pode permitir que entradas não restritas quase correspondentes ao padrão da expressão regular prejudiquem significativamente o desempenho.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>To solve this problem, you can do the following:</source>
          <target state="translated">Para resolver este problema, você pode fazer o seguinte:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</source>
          <target state="translated">Ao desenvolver um padrão, você deve considerar como o retrocesso pode afetar o desempenho do mecanismo de expressões regulares, especialmente se a expressão regular for criada para processar entradas sem restrição.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Take charge of backtracking<ept id="p1">](#take-charge-of-backtracking)</ept> section.</source>
          <target state="translated">Para obter mais informações, consulte a seção <bpt id="p1">[</bpt>Tome conta do retrocesso<ept id="p1">](#take-charge-of-backtracking)</ept>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</source>
          <target state="translated">Teste rigorosamente sua expressão regular usando entradas inválidas e quase válidas, bem como entradas válidas.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>To generate input for a particular regular expression randomly, you can use <bpt id="p1">[</bpt>Rex<ept id="p1">](http://research.microsoft.com/en-us/projects/rex/)</ept>, which is a regular expression exploration tool from Microsoft Research.</source>
          <target state="translated">Para gerar entradas para uma expressão regular específica aleatoriamente, você pode usar <bpt id="p1">[</bpt>Rex<ept id="p1">](http://research.microsoft.com/en-us/projects/rex/)</ept>, que é uma ferramenta de exploração de expressões regulares da Microsoft Research.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Handle object instantiation appropriately</source>
          <target state="translated">Trate a instanciação de objetos adequadamente</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>At the heart of .NET’s regular expression object model is the <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class, which represents the regular expression engine.</source>
          <target state="translated">No centro do modelo de objeto de expressões regulares do .NET está a classe <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept>, que representa o mecanismo de expressões regulares.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Often, the single greatest factor that affects regular expression performance is the way in which the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> engine is used.</source>
          <target state="translated">Muitas vezes, o maior fator individual que afeta o desempenho das expressões regulares é a forma como o mecanismo <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> é usado.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</source>
          <target state="translated">Definir uma expressão regular envolve o acoplamento vigoroso do mecanismo de expressões regulares com um padrão de expressão regular.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>That coupling process, whether it involves instantiating a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</source>
          <target state="translated">Esse processo de acoplamento, seja envolvendo a instanciação de um objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> ao passar para seu construtor um padrão de expressão regular ou seja chamando um método estático ao passar o padrão de expressão regular com a cadeia de caracteres a ser analisada, é necessariamente caro.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</source>
          <target state="translated">É possível acoplar o mecanismo de expressões regulares com um padrão específico de expressão regular e usar o mecanismo para fazer a correspondência com texto de várias maneiras:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can call a static pattern-matching method, such as <bpt id="p1">[</bpt>Regex.Match(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String))</ept>.</source>
          <target state="translated">Você pode chamar um método estático de correspondência de padrões, como <bpt id="p1">[</bpt>Regex.Match(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String))</ept>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This does not require instantiation of a regular expression object.</source>
          <target state="translated">Isso não requer a instanciação de um objeto de expressão regular.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You can instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object and call an instance pattern-matching method of an interpreted regular expression.</source>
          <target state="translated">É possível criar uma instância de um objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> e chamar um método de instância de correspondência de padrões de uma expressão regular interpretada.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This is the default method for binding the regular expression engine to a regular expression pattern.</source>
          <target state="translated">Esse é o método padrão para associar o mecanismo de expressões regulares a uma expressão regular padrão.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It results when a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated without an options argument that includes the <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> flag.</source>
          <target state="translated">Isso ocorre quando um objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> é instanciado sem um argumento de opções que inclui o sinalizador <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object and call an instance pattern-matching method of a compiled regular expression.</source>
          <target state="translated">Você pode criar uma instância de um objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> e chamar um método de instância de correspondência de padrões de uma expressão regular compilada.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Regular expression objects represent compiled patterns when a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated with an options argument that includes the <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> flag.</source>
          <target state="translated">Os objetos de expressão regular representam padrões compilados quando um objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> é instanciado com um argumento de opções que inclui o sinalizador <bpt id="p2">[</bpt>RegexOptions.Compiled<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</source>
          <target state="translated">A forma da chamada de método (estático, interpretada, compilada) afeta o desempenho se a mesma expressão regular é usada repetidamente em chamadas de método ou se um aplicativo faz uso extensivo de objetos de expressão regular.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Static regular expressions</source>
          <target state="translated">Expressões regulares estáticas</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</source>
          <target state="translated">Os métodos de expressões regulares estáticas são recomendados como uma alternativa a criar repetidamente instâncias de um objeto de expressão regular com a mesma expressão regular.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in instance method calls is cached internally by the regular expression engine.</source>
          <target state="translated">Ao contrário de padrões de expressões regulares usados por objetos de expressões regulares, os códigos de operação ou a linguagem intermediária compilada da Microsoft (MSIL) de padrões usados em chamadas de métodos são armazenados em cache internamente pelo mecanismo de expressões regulares.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>For example, you might call a method to validate user input.</source>
          <target state="translated">Por exemplo, você pode chamar um método para validar a entrada do usuário.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In this example, a method named <ph id="ph1">`IsValidCurrency`</ph> checks whether the user has entered a currency symbol followed by at least one decimal digit.</source>
          <target state="translated">Neste exemplo, um método chamado <ph id="ph1">`IsValidCurrency`</ph> verifica se o usuário inseriu um símbolo de moeda seguido por pelo menos um dígito decimal.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A very inefficient implementation of the <ph id="ph1">`IsValidCurrency`</ph> method is shown in the following example.</source>
          <target state="translated">Uma implementação bem ineficiente do método <ph id="ph1">`IsValidCurrency`</ph> é mostrada no exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Note that each method call reinstantiates a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object with the same pattern.</source>
          <target state="translated">Observe que cada chamada de método reinstancia um objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> com o mesmo padrão.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</source>
          <target state="translated">Isso, por sua vez, significa que o padrão de expressão regular deve ser recompilado toda vez que o método é chamado.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>You should replace this inefficient code with a call to the static <bpt id="p1">[</bpt>Regex.IsMatch(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String))</ept> method.</source>
          <target state="translated">Você deve substituir esse código ineficiente por uma chamada ao método estático <bpt id="p1">[</bpt>Regex.IsMatch(String, String)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String))</ept>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This eliminates the need to instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</source>
          <target state="translated">Isso elimina a necessidade de criar uma instância de um objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> toda vez que você desejar chamar um método de correspondência de padrões e permite que o mecanismo de expressões regulares recupere uma versão compilada da expressão regular do cache.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>By default, the last 15 most recently used static regular expression patterns are cached.</source>
          <target state="translated">Por padrão, os 15 padrões de expressões regulares estáticas usados mais recentemente são armazenados no cache.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <bpt id="p1">[</bpt>Regex.CacheSize<ept id="p1">](xref:System.Text.RegularExpressions.Regex.CacheSize)</ept> property.</source>
          <target state="translated">Para aplicativos que requerem um número maior de expressões regulares estáticas armazenadas no cache, o tamanho do cache pode ser ajustado com a definição da propriedade <bpt id="p1">[</bpt>Regex.CacheSize<ept id="p1">](xref:System.Text.RegularExpressions.Regex.CacheSize)</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\p{Sc}+\s*\d+`</ph> that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</source>
          <target state="translated">A expressão regular <ph id="ph1">`\p{Sc}+\s*\d+`</ph> que é usada neste exemplo verifica que a cadeia de caracteres de entrada consiste em um símbolo de moeda e pelo menos um dígito decimal.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The pattern is defined as shown in the following table.</source>
          <target state="translated">O padrão é definido conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Match one or more characters in the Unicode Symbol, Currency category.</source>
          <target state="translated">Corresponde a um ou mais caracteres no símbolo Unicode, categoria de moeda.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">Corresponder a zero ou mais caracteres de espaço em branco.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Corresponde a um ou mais dígitos decimais.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Interpreted vs. compiled regular expressions</source>
          <target state="translated">Expressões regulares compiladas vs. interpretadas</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Regular expression patterns that are not bound to the regular expression engine through the specification of the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option are interpreted.</source>
          <target state="translated">Os padrões de expressões regulares que não são associados ao mecanismo de expressões regulares com a especificação da opção <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> são interpretados.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</source>
          <target state="translated">Quando um objeto de expressão regular é instanciado, o mecanismo de expressões regulares converte a expressão regular em um conjunto de códigos de operação.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</source>
          <target state="translated">Quando um método de instância é chamado, os códigos de operação são convertidos para MSIL e executados pelo compilador JIT.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</source>
          <target state="translated">Da mesma forma, quando um método estático de expressão regular é chamado e a expressão regular não pode ser encontrada no cache, o mecanismo de expressão regular converte a expressão regular em um conjunto de códigos operacionais e os armazena no cache.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>It then converts these operation codes to MSIL so that the JIT compiler can execute them.</source>
          <target state="translated">Em seguida, converte esses códigos de operação para MSIL de modo que o compilador JIT possa executá-los.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Interpreted regular expressions reduce startup time at the cost of slower execution time.</source>
          <target state="translated">As expressões regulares interpretadas reduzem o tempo de inicialização ao custo de um tempo de execução mais lento.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</source>
          <target state="translated">Devido a isso, eles são melhores utilizados quando a expressão regular é usada em um pequeno número de chamadas de método ou se o número exato de chamadas para métodos de expressão regular é desconhecido, mas com a expectativa de ser pequeno.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</source>
          <target state="translated">À medida que número de chamadas de método aumenta, o ganho de desempenho do tempo de inicialização reduzido é superado pela velocidade de execução mais lenta.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Regular expression patterns that are bound to the regular expression engine through the specification of the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option are compiled.</source>
          <target state="translated">Os padrões de expressões regulares que são associados ao mecanismo de expressões regulares com a especificação da opção <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> são compilados.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</source>
          <target state="translated">Isso significa que, quando um objeto de expressão regular é instanciado ou quando um método de expressão regular estática é chamado e a expressão regular não pode ser encontrada no cache, o mecanismo de expressões regulares converte a expressão regular para um conjunto intermediário de códigos de operação, que em seguida é convertido para MSIL.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>When a method is called, the JIT compiler executes the MSIL.</source>
          <target state="translated">Quando um método é chamado, o compilador JIT executa o MSIL.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</source>
          <target state="translated">Em contraste com as expressões regulares interpretadas, as expressões regulares compiladas aumentam o tempo de inicialização, mas executam os métodos individuais de correspondência padrão de forma mais rápida.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</source>
          <target state="translated">Como resultado, o benefício de desempenho que resulta da compilação da expressão regular aumenta em proporção ao número de métodos de expressões regulares chamados.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</source>
          <target state="translated">Para resumir, recomendamos que você use expressões regulares interpretadas ao chamar métodos de expressões regulares com uma expressão regular específica com relativa pouca frequência.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</source>
          <target state="translated">Você deve usar expressões regulares compiladas ao chamar os métodos de expressões regulares com uma expressão regular específica com uma relativa frequência.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</source>
          <target state="translated">É difícil determinar o limite exato em que as velocidades de execução mais lentas das expressões regulares interpretadas suplantam os ganhos proporcionados pelo tempo de inicialização reduzido ou o limite em que os tempos de inicialização mais lentos das expressões regulares compiladas suplantam os ganhos gerados por suas velocidades de execução mais rápida.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</source>
          <target state="translated">O limite depende de vários fatores, incluindo a complexidade da expressão regular e dos dados específicos que são processados.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <bpt id="p1">[</bpt>Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> class to compare their execution times.</source>
          <target state="translated">Para determinar se as expressões regulares interpretadas ou compiladas oferecem o melhor desempenho para seu cenário de aplicativo específico, você pode usar a classe <bpt id="p1">[</bpt>Stopwatch<ept id="p1">](xref:System.Diagnostics.Stopwatch)</ept> para comparar seus tempos de execução.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's The Financier.</source>
          <target state="translated">O exemplo a seguir compara o desempenho de expressões regulares compiladas e interpretadas ao ler as dez primeiras frases e ao ler todas as frases no texto The Financier de Theodore Dreiser.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</source>
          <target state="translated">Conforme mostrado pela saída do exemplo, quando apenas dez chamadas são feitas para os métodos correspondentes de expressão regular, uma expressão regular interpretada oferece um desempenho melhor do que uma expressão regular compilada.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</source>
          <target state="translated">No entanto, uma expressão regular compilada oferece melhor desempenho quando um grande número de chamadas (neste caso, mais 13.000) é feito.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The regular expression pattern used in the example, <ph id="ph1">`\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`</ph>, is defined as shown in the following table.</source>
          <target state="translated">O padrão de expressão regular usado neste exemplo, <ph id="ph1">`\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`</ph>, é definido como mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Começa a correspondência em um limite de palavra.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Fazer a correspondência a um ou mais caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>`(\r?\n)</source>
          <target state="translated">`(\r?\n)</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>,?\s)`</source>
          <target state="translated">,?\s)`</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</source>
          <target state="translated">Corresponde a um zero ou um retorno de carro seguido por um caractere de nova linha, ou zero ou uma vírgula seguida por um caractere de espaço em branco.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>`(\w+((\r?\n)</source>
          <target state="translated">`(\w+((\r?\n)</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>,?\s))*`</source>
          <target state="translated">,?\s))*`</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</source>
          <target state="translated">Corresponde a zero ou mais ocorrências de um ou mais caracteres de palavra que são seguidos por zero ou por retornos de carro e por um caractere de nova linha ou por zero ou uma vírgula seguida por um caractere de espaço em branco.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Fazer a correspondência a um ou mais caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Match a period, question mark, colon, semicolon, or exclamation point.</source>
          <target state="translated">Corresponde a um ponto, um ponto de interrogação, dois-pontos, ponto-e-vírgula ou ponto de exclamação.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Take charge of backtracking</source>
          <target state="translated">Tome conta do retrocesso</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</source>
          <target state="translated">Normalmente, o mecanismo de expressões regulares usa progressão linear para percorrer uma cadeia de caracteres de entrada e compará-la a uma expressão regular padrão.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>However, when indeterminate quantifiers such as <bpt id="p1">__</bpt><ph id="ph1">*</ph><ept id="p1">__</ept>, <bpt id="p2">**</bpt><ph id="ph2">+</ph><ept id="p2">**</ept>, and <bpt id="p3">**</bpt>?<ept id="p3">**</ept></source>
          <target state="translated">No entanto, quando quantificadores indefinidos, como <bpt id="p1">__</bpt><ph id="ph1">*</ph><ept id="p1">__</ept>, <bpt id="p2">**</bpt><ph id="ph2">+</ph><ept id="p2">**</ept>, e <bpt id="p3">**</bpt>?<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</source>
          <target state="translated">são usados em uma expressão regular padrão, o mecanismo de expressões regulares pode desistir de uma parte das correspondências parciais com êxito e retornar a um estado salvo anteriormente para pesquisar uma correspondência com êxito para o padrão inteiro.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>This process is known as backtracking.</source>
          <target state="translated">Esse processo é conhecido como retrocesso.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For more information on backtracking, see <bpt id="p1">[</bpt>Details of regular expression behavior<ept id="p1">](regex-behavior.md)</ept> and <bpt id="p2">[</bpt>Backtracking in regular expressions<ept id="p2">](backtracking.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre o retrocesso, confira <bpt id="p1">[</bpt>Detalhes do comportamento de expressões regulares<ept id="p1">](regex-behavior.md)</ept> e <bpt id="p2">[</bpt>Retrocesso em expressões regulares<ept id="p2">](backtracking.md)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Support for backtracking gives regular expressions power and flexibility.</source>
          <target state="translated">O suporte ao retrocesso proporciona poder e flexibilidade às expressões regulares.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</source>
          <target state="translated">Ele também coloca a responsabilidade por controlar o funcionamento do mecanismo de expressões regulares nas mãos dos desenvolvedores de expressões regulares.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</source>
          <target state="translated">Como os desenvolvedores geralmente não estão cientes dessa responsabilidade, o uso indevido do retrocesso ou a confiança no retrocesso excessivo geralmente exerce o papel mais significativo na degradação do desempenho da expressão regular.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>In a worst-case scenario, execution time can double for each additional character in the input string.</source>
          <target state="translated">Em um cenário de pior caso, o tempo de execução pode dobrar para cada caractere adicional na cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</source>
          <target state="translated">Na verdade, quando o retrocesso é usado excessivamente, é fácil criar o equivalente programático de um loop infinito se a entrada quase corresponder ao padrão da expressão regular; o mecanismo de expressões regulares pode levar horas ou mesmo dias para processar uma cadeia de caracteres de entrada relativamente curta.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</source>
          <target state="translated">Frequentemente, os aplicativos pagam uma penalidade de desempenho por usar o retrocesso, mesmo ele não sendo essencial para uma correspondência.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b\p{Lu}\w*\b`</ph> matches all words that begin with an uppercase character, as the following table shows.</source>
          <target state="translated">Por exemplo, a expressão regular <ph id="ph1">`\b\p{Lu}\w*\b`</ph> corresponde a todas as palavras que começam com um caractere maiúsculo, como mostra a tabela a seguir.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Começar a correspondência em um limite de palavra.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Match an uppercase character.</source>
          <target state="translated">Corresponder a um caractere maiúsculo.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
          <target state="translated">Corresponder a zero ou mais caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Termina a correspondência em um limite de palavra.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</source>
          <target state="translated">Como um limite de palavra não é o mesmo que ou um subconjunto de, um caractere de palavra, não há nenhuma possibilidade de o mecanismo de expressões regulares cruzar um limite de palavra ao corresponder caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</source>
          <target state="translated">Isso significa que, para esta expressão regular, o retrocesso nunca pode contribuir para o êxito total de qualquer correspondência – ele só pode prejudicar o desempenho, pois o mecanismo de expressões regulares é forçado a salvar o estado para cada correspondência preliminar bem-sucedida de um caractere de palavra.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>If you determine that backtracking is not necessary, you can disable it by using the <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element.</source>
          <target state="translated">Se você determinar que o retrocesso não é necessário, poderá desabilitá-lo usando o elemento de linguagem <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The following example parses an input string by using two regular expressions.</source>
          <target state="translated">O exemplo a seguir analisa uma cadeia de caracteres de entrada usando duas expressões regulares.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The first, <ph id="ph1">`\b\p{Lu}\w*\b`</ph>, relies on backtracking.</source>
          <target state="translated">A primeira, <ph id="ph1">`\b\p{Lu}\w*\b`</ph>, depende do retrocesso.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The second, <ph id="ph1">`\b\p{Lu}(?&gt;\w*)\b`</ph>, disables backtracking.</source>
          <target state="translated">A segunda, <ph id="ph1">`\b\p{Lu}(?&gt;\w*)\b`</ph>, desabilita o retrocesso.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, they both produce the same result.</source>
          <target state="translated">Conforme mostrado pela saída do exemplo, ambas produzem o mesmo resultado.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>In many cases, backtracking is essential for matching a regular expression pattern to input text.</source>
          <target state="translated">Em muitos casos, o retrocesso é essencial para corresponder um padrão de expressão regular ao texto de entrada.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</source>
          <target state="translated">No entanto, o retrocesso excessivo pode prejudicar severamente o desempenho e criar a impressão de que um aplicativo parou de responder.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</source>
          <target state="translated">Em particular, isso acontece quando quantificadores são aninhados e o texto que corresponde à subexpressão externa é um subconjunto do texto que corresponde à subexpressão interna.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</source>
          <target state="translated">Além de evitar retrocessos excessivos, você deve usar o recurso de tempo limite para garantir que retrocessos excessivos não degradem severamente o desempenho da expressão regular.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Use time-out values<ept id="p1">](#use-time-out-values)</ept> section.</source>
          <target state="translated">Para obter mais informações, confira a seção <bpt id="p1">[</bpt>Use valores de tempo limite<ept id="p1">](#use-time-out-values)</ept>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$`</ph> is intended to match a part number that consists of at least one alphanumeric character.</source>
          <target state="translated">Por exemplo, o padrão de expressão regular <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$`</ph> destina-se a corresponder a um número de peça que consiste em pelo menos um caractere alfanumérico.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</source>
          <target state="translated">Todos os demais caracteres podem consistir em um caractere alfanumérico, um hífen, um sublinhado ou um ponto, embora o último caractere deva ser alfanumérico.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>A dollar sign terminates the part number.</source>
          <target state="translated">Um cifrão termina o número da peça.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression <ph id="ph1">`[0-9A-Z]`</ph> is a subset of the subexpression <ph id="ph2">`[-.\w]*`</ph>.</source>
          <target state="translated">Em alguns casos, esse padrão de expressão regular pode exibir um desempenho muito ruim porque os quantificadores estão aninhados e porque a subexpressão <ph id="ph1">`[0-9A-Z]`</ph> é um subconjunto da subexpressão <ph id="ph2">`[-.\w]*`</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</source>
          <target state="translated">Nesses casos, você pode otimizar o desempenho da expressão regular ao remover os quantificadores aninhados e substituir a subexpressão externa por uma declaração de lookahead ou lookbehind de largura zero.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</source>
          <target state="translated">As asserções lookahead e lookbehind são âncoras; elas não movem o ponteiro na cadeia de caracteres de entrada, mas fazem uma verificação para verificar se uma condição especificada foi atendida.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>For example, the part number regular expression can be rewritten as <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])\$$`</ph>.</source>
          <target state="translated">Por exemplo, a expressão regular do número de peça pode ser reescrita como <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])\$$`</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>This regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">Esse padrão de expressão regular é definido conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the input string.</source>
          <target state="translated">Começar a correspondência no início da cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
          <target state="translated">Corresponde a um caractere alfanumérico.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The part number must consist of at least this character.</source>
          <target state="translated">O número de peça deve consistir em pelo menos este caractere.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of any word character, hyphen, or period.</source>
          <target state="translated">Corresponde a zero ou mais ocorrências de qualquer caractere de palavra, hífen ou ponto.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`</ph><ph id="ph2">\$</ph>]</source>
          <target state="translated"><ph id="ph1">`</ph><ph id="ph2">\$</ph>]</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Match a dollar sign.</source>
          <target state="translated">Corresponde a um cifrão.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</source>
          <target state="translated">Examine além do cifrão final para garantir que o caractere anterior seja alfanumérico.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`$`</ph> End the match at the end of the input string.</source>
          <target state="translated"><ph id="ph1">`$`</ph> Finalizar a correspondência no final da cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The following example illustrates the use of this regular expression to match an array containing possible part numbers.</source>
          <target state="translated">O exemplo a seguir ilustra o uso dessa expressão regular para corresponder a uma que contém possíveis números de peças.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</source>
          <target state="translated">A linguagem de expressões regulares no .NET inclui os seguintes elementos de linguagem que você pode usar para eliminar quantificadores aninhados.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Constructos de agrupamento em expressões regulares<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Language element</source>
          <target state="translated">Elemento de linguagem</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookahead.</source>
          <target state="translated">Lookahead positivo de largura zero.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Look ahead of the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> matches the input string.</source>
          <target state="translated">Examina além da posição atual para determinar se a <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> corresponde à cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookahead.</source>
          <target state="translated">Lookahead negativo de largura zero.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Look ahead of the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> does not match the input string.</source>
          <target state="translated">Examina além da posição atual para determinar se a <bpt id="p1">*</bpt>subexpressão<ept id="p1">*</ept> não corresponde à cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind.</source>
          <target state="translated">Lookbehind positivo de largura zero.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Look behind the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> matches the input string.</source>
          <target state="translated">Examina o conteúdo que antecede a posição atual para determinar se a <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> corresponde à cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind.</source>
          <target state="translated">Lookbehind negativo de largura zero.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Look behind the current position to determine whether <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> does not match the input string.</source>
          <target state="translated">Examina o conteúdo que antecede a posição atual para determinar se a <bpt id="p1">*</bpt>subexpressão<ept id="p1">*</ept> não corresponde à cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Use time-out values</source>
          <target state="translated">Use valores de tempo limite</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</source>
          <target state="translated">Se suas expressões regulares processarem entradas quase correspondentes ao padrão da expressão regular, elas poderão frequentemente confiar no retrocesso excessivo, o que afeta significativamente o desempenho.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</source>
          <target state="translated">Além de considerar cuidadosamente o uso do retrocesso e testar a expressão regular contra entradas quase correspondentes, você deve sempre definir um valor de tempo limite para garantir que o impacto do retrocesso excessivo, caso ocorra, seja minimizado.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out.</source>
          <target state="translated">O intervalo de tempo limite da expressão regular define o período durante o qual o mecanismo de expressões regulares procurará uma única correspondência antes que o tempo limite seja atingido.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The default time-out interval is <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept>, which means that the regular expression will not time out.</source>
          <target state="translated">O intervalo de tempo limite padrão é <bpt id="p1">[</bpt>Regex.InfiniteMatchTimeout<ept id="p1">](xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout)</ept>, o que significa que a expressão regular não atingirá o tempo limite.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You can override this value and define a time-out interval as follows:</source>
          <target state="translated">É possível substituir esse valor e definir um intervalo de tempo limite da seguinte forma:</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>By providing a time-out value when you instantiate a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object by calling the <bpt id="p2">[</bpt>Regex(String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> constructor.</source>
          <target state="translated">Fornecendo um valor de tempo limite ao criar uma instância de um objeto <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> chamando o construtor <bpt id="p2">[</bpt>Regex(String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>By calling a static pattern matching method, such as <bpt id="p1">[</bpt>Regex.Match(String, String, RegexOptions, TimeSpan)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> or <bpt id="p2">[</bpt>Regex.Replace(String, String, String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept>, that includes a <bpt id="p3">*</bpt>matchTimeout<ept id="p3">*</ept> parameter.</source>
          <target state="translated">Chamando um padrão estático que corresponde ao método, como <bpt id="p1">[</bpt>Regex.Match(String, String, RegexOptions, TimeSpan)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept> ou <bpt id="p2">[</bpt>Regex.Replace(String, String, String, RegexOptions, TimeSpan)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan))</ept>, que inclui um parâmetro <bpt id="p3">*</bpt>matchTimeout<ept id="p3">*</ept>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept> exception.</source>
          <target state="translated">Se você tiver definido um intervalo de tempo limite e uma correspondência não for localizada no final do intervalo, o método de expressão regular gerará uma exceção <bpt id="p1">[</bpt>RegexMatchTimeoutException<ept id="p1">](xref:System.Text.RegularExpressions.RegexMatchTimeoutException)</ept>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</source>
          <target state="translated">No manipulador de exceção, você pode optar por tentar fazer novamente a correspondência com um intervalo de tempo limite mais longo, abandonar a tentativa de correspondência e assumir que não há nenhuma correspondência ou abandonar a tentativa de correspondência e registrar as informações de exceção para análise futura.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`GetWordData`</ph> method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</source>
          <target state="translated">O exemplo a seguir define um método <ph id="ph1">`GetWordData`</ph> que instancia uma expressão regular com um intervalo de tempo limite de 350 milissegundos para calcular o número de palavras e o número médio de caracteres em uma palavra em um documento de texto.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is re-instantiated.</source>
          <target state="translated">Se a operação de correspondência exceder o tempo limite, o intervalo de tempo limite será aumentado em 350 milissegundos e o objeto de <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> será reinstanciado.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</source>
          <target state="translated">Se o novo intervalo de tempo limite exceder 1 segundo, o método gerará novamente a exceção no chamador.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Capture only when necessary</source>
          <target state="translated">Capture somente quando necessário</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</source>
          <target state="translated">As expressões regulares no .NET dão suporte a vários constructos de agrupamento, que permitem a você agrupar um padrão de expressão regular em uma ou mais subexpressões.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The most commonly used grouping constructs in .NET regular expression language are <bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>, which defines a numbered capturing group, and <bpt id="p4">*</bpt><bpt id="p5">*</bpt>(?&lt;<ept id="p5">*</ept><bpt id="p6">_</bpt>name<ept id="p6">_</ept><ept id="p4">*</ept><bpt id="p7">*</bpt><ph id="ph1">&gt;</ph><ept id="p7">*</ept><bpt id="p8">*</bpt><bpt id="p9">_</bpt>subexpression<ept id="p9">_</ept><ept id="p8">*</ept><bpt id="p10">*</bpt>)<ept id="p10">*</ept>*, which defines a named capturing group.</source>
          <target state="translated">Os constructos de agrupamentos mais usados na linguagem de expressões regulares no .NET <bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>, que define um grupo de captura numerado e <bpt id="p4">*</bpt><bpt id="p5">*</bpt>(?&lt;<ept id="p5">*</ept><bpt id="p6">_</bpt>name<ept id="p6">_</ept><ept id="p4">*</ept><bpt id="p7">*</bpt><ph id="ph1">&gt;</ph><ept id="p7">*</ept><bpt id="p8">*</bpt><bpt id="p9">_</bpt>subexpression<ept id="p9">_</ept><ept id="p8">*</ept><bpt id="p10">*</bpt>)<ept id="p10">*</ept>*, que define um grupo de captura nomeado.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</source>
          <target state="translated">Os construtores de agrupamento são essenciais para criar referências reversas e definir uma subexpressão à qual um quantificador é aplicado.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>However, the use of these language elements has a cost.</source>
          <target state="translated">No entanto, o uso desses elementos de linguagem tem um custo.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>They cause the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <bpt id="p3">[</bpt>CaptureCollection<ept id="p3">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object returned by the <bpt id="p4">[</bpt>Group.Captures<ept id="p4">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property of a particular capturing group with multiple <bpt id="p5">[</bpt>Capture<ept id="p5">](xref:System.Text.RegularExpressions.Capture)</ept> objects.</source>
          <target state="translated">Eles fazem com que o objeto <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> retornado pela propriedade <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> seja populado com as capturas sem nome ou nomeadas mais recentes. Além disso, se um único constructo de agrupamento tiver capturado várias subcadeias de caracteres na cadeia de caracteres de entrada, também populam o objeto <bpt id="p3">[</bpt>CaptureCollection<ept id="p3">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> retornado pela propriedade <bpt id="p4">[</bpt>Group.Captures<ept id="p4">](xref:System.Text.RegularExpressions.Group.Captures)</ept> de um grupo de captura específico com vários objetos <bpt id="p5">[</bpt>Capture<ept id="p5">](xref:System.Text.RegularExpressions.Capture)</ept>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</source>
          <target state="translated">Muitas vezes, os construtores de agrupamento são usados somente em uma expressão regular de modo que quantificadores possam ser aplicados a eles e os grupos capturados por essas subexpressão não são usados posteriormente.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b(\w+[;,]?\s?)+[.?!]`</ph> is designed to capture an entire sentence.</source>
          <target state="translated">Por exemplo, a expressão regular <ph id="ph1">`\b(\w+[;,]?\s?)+[.?!]`</ph> é criada para capturar uma frase inteira.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The following table describes the language elements in this regular expression pattern and their effect on the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> object's <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> and <bpt id="p3">[</bpt>Group.Captures<ept id="p3">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collections.</source>
          <target state="translated">A tabela a seguir descreve os elementos de linguagem nesse padrão de expressão regular e seu efeito nas coleções <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> e <bpt id="p3">[</bpt>Group.Captures<ept id="p3">](xref:System.Text.RegularExpressions.Group.Captures)</ept> do objeto <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Começa a correspondência em um limite de palavra.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Fazer a correspondência a um ou mais caracteres de palavra.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Match zero or one comma or semicolon.</source>
          <target state="translated">Corresponde a zero ou uma vírgula ou ponto e vírgula.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space character.</source>
          <target state="translated">Corresponder a zero ou a um caractere de espaço em branco.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</source>
          <target state="translated">Corresponde a uma ou mais ocorrências de um ou mais caracteres de palavra seguidos por uma vírgula opcional ou por ponto-e-vírgula seguido por um caractere de espaço em branco opcional.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</source>
          <target state="translated">Isso define o primeiro grupo de captura, que é necessário para que a combinação de vários caracteres de palavra (ou seja, uma palavra) seguido por um símbolo de pontuação opcional seja repetida até que o mecanismo de expressões regulares atinja o final de uma sentença.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Match a period, question mark, or exclamation point.</source>
          <target state="translated">Corresponde a um ponto, um ponto de interrogação ou um ponto de exclamação.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>As the following example shows, when a match is found, both the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> objects are populated with captures from the match.</source>
          <target state="translated">Como o exemplo a seguir mostra, quando uma correspondência é encontrada, os objetos <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> e <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> são populados com as capturas da correspondência.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>In this case, the capturing group <ph id="ph1">`(\w+[;,]?\s?)`</ph> exists so that the <bpt id="p1">**</bpt><ph id="ph2">+</ph><ept id="p1">**</ept> quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</source>
          <target state="translated">Nesse caso, o grupo de captura <ph id="ph1">`(\w+[;,]?\s?)`</ph> existe para que o quantificador <bpt id="p1">**</bpt><ph id="ph2">+</ph><ept id="p1">**</ept> possa ser aplicado a ele, o que permite que o padrão de expressão regular corresponda a cada palavra em uma sentença.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Otherwise, it would match the last word in a sentence.</source>
          <target state="translated">Caso contrário, ele corresponderia à última palavra em uma sentença.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</source>
          <target state="translated">Quando você usa subexpressões apenas para aplicar quantificadores a elas e não está interessado em texto capturado, desabilite as capturas de grupo.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element prevents the group to which it applies from capturing matched substrings.</source>
          <target state="translated">Por exemplo, o elemento de linguagem <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> evita que o grupo ao qual ele se aplica capture subcadeias de caracteres correspondidas.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression pattern from the previous example is changed to <ph id="ph1">`\b(?:\w+[;,]?\s?)+[.?!]`</ph>.</source>
          <target state="translated">No exemplo a seguir, o padrão de expressão regular do exemplo anterior é alterado para <ph id="ph1">`\b(?:\w+[;,]?\s?)+[.?!]`</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>As the output shows, it prevents the regular expression engine from populating the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collections.</source>
          <target state="translated">Conforme mostrado pela saída, ele impede que o mecanismo de expressões regulares popule as coleções <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> e <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>You can disable captures in one of the following ways:</source>
          <target state="translated">É possível desabilitar as capturas de uma das seguintes formas:</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element.</source>
          <target state="translated">Use o elemento de linguagem <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>This element prevents the capture of matched substrings in the group to which it applies.</source>
          <target state="translated">Esse elemento impede a captura de subcadeias de caracteres correspondidas no grupo ao qual se ele aplica.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>It does not disable substring captures in any nested groups.</source>
          <target state="translated">Ele não desabilita capturas de subcadeias de caracteres em grupos aninhados.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">Use a opção <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>It disables all unnamed or implicit captures in the regular expression pattern.</source>
          <target state="translated">Ela desabilita todas as capturas sem nome ou implícitas no padrão de expressão regular.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>When you use this option, only substrings that match named groups defined with the <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept><bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> language element can be captured.</source>
          <target state="translated">Quando você usa essa opção, somente as subcadeias de caracteres que correspondem aos grupos nomeados definidos com o elemento de linguagem <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept><bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> podem ser capturadas.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> flag can be passed to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or to the options parameter of a <bpt id="p3">[</bpt>Regex<ept id="p3">](xref:System.Text.RegularExpressions.Regex)</ept> static matching method.</source>
          <target state="translated">O sinalizador <bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> pode ser passado para o parâmetro de opções de um construtor de classe <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> ou para o parâmetro de opções de um método de correspondência estático <bpt id="p3">[</bpt>Regex<ept id="p3">](xref:System.Text.RegularExpressions.Regex)</ept>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>n<ept id="p1">**</ept> option in the <bpt id="p2">**</bpt>(?imnsx)<ept id="p2">**</ept> language element.</source>
          <target state="translated">Use a opção <bpt id="p1">**</bpt>n<ept id="p1">**</ept> no elemento de linguagem <bpt id="p2">**</bpt>(?imnsx)<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</source>
          <target state="translated">Esta opção desabilita todas as capturas sem nome ou implícitas a partir do ponto no padrão de expressão regular em que o elemento aparece.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Captures are disabled either until the end of the pattern or until the <bpt id="p1">**</bpt>(-n)<ept id="p1">**</ept> option enables unnamed or implicit captures.</source>
          <target state="translated">As capturas são desabilitadas até o final do padrão ou até a opção <bpt id="p1">**</bpt>(-n)<ept id="p1">**</ept> habilitar capturas sem nome ou implícitas.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Miscellaneous constructs in regular expressions<ept id="p1">](miscellaneous.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Constructos diversos em expressões regulares<ept id="p1">](miscellaneous.md)</ept>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>n<ept id="p1">**</ept> option in the <bpt id="p2">**</bpt>(?imnsx:<ept id="p2">**</ept><bpt id="p3">_</bpt>subexpression<ept id="p3">_</ept><bpt id="p4">**</bpt>)<ept id="p4">**</ept> language element.</source>
          <target state="translated">Use a opção <bpt id="p1">**</bpt>n<ept id="p1">**</ept> no elemento de linguagem <bpt id="p2">**</bpt>(?imnsx:<ept id="p2">**</ept><bpt id="p3">_</bpt>subexpression<ept id="p3">_</ept><bpt id="p4">**</bpt>)<ept id="p4">**</ept>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>This option disables all unnamed or implicit captures in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>.</source>
          <target state="translated">Esta opção desabilita todas as capturas sem nome ou implícitas na <bpt id="p1">*</bpt>subexpressão<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Captures by any unnamed or implicit nested capturing groups are disabled as well.</source>
          <target state="translated">As capturas por grupos de capturas aninhadas sem nome ou implícitas também são desabilitadas.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="translated">Tópicos relacionados</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Título</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Details of regular expression behavior<ept id="p1">](regex-behavior.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Detalhes do comportamento de expressões regulares<ept id="p1">](regex-behavior.md)</ept></target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Examines the implementation of the regular expression engine in .NET.</source>
          <target state="translated">Examina a implementação do mecanismo de expressões regulares no .NET.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</source>
          <target state="translated">O tópico concentra-se na flexibilidade de expressões regulares e explica a responsabilidade do desenvolvedor para garantir o funcionamento eficiente e robusto do mecanismo de expressões regulares.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking in regular expressions<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Retrocesso em expressões regulares<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</source>
          <target state="translated">Explica o que é o retrocesso é como ele afeta o desempenho da expressão regular e examina os elementos de linguagem que fornecem alternativas ao retrocesso.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Linguagem de expressão regular – referência rápida<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</source>
          <target state="translated">Descreve os elementos de linguagem de expressões regulares do .NET e fornece links para a documentação detalhada de cada elemento da linguagem.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>