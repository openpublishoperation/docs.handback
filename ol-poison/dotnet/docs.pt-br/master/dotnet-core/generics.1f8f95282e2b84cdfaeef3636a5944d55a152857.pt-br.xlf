<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">09f52c2b4b821b21279f602e7bbf45e91fe98dec</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\generics.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6add02984958edc8aa861bdfb8f07b4b4937a581</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1d28dd0577194dcbfe32efffe44899f9c319f2c5</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file generics.1f8f95282e2b84cdfaeef3636a5944d55a152857.pt-br.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Generic Types (Generics) Overview</source>
          <target state="translated">Visão Geral dos Tipos Genéricos (Genéricos)</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Generic Types (Generics) Overview</source>
          <target state="translated">Visão Geral dos Tipos Genéricos (Genéricos)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Generic Types (Generics) Overview</source>
          <target state="translated">Visão Geral dos Tipos Genéricos (Genéricos)</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>We use generics all the time in C#, whether implicitly or explicitly.</source>
          <target state="translated">Usamos genéricos sempre em C#, de forma implícita ou explícita.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>When you use LINQ in C#, did you ever notice that you are working with IEnumerable<ph id="ph1">&lt;T&gt;</ph>?</source>
          <target state="translated">Ao usar LINQ em C#, você já percebeu alguma vez estar trabalhando com IEnumerable<ph id="ph1">&lt;T&gt;</ph>?</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Or if you ever saw an online sample of a “generic repository” for talking to databases using Entity Framework, did you see that most methods return IQueryable<ph id="ph1">&lt;T&gt;</ph>?</source>
          <target state="translated">Ou, no caso de você já ter visto um exemplo de um "repositório genérico" online para conversar com bancos de dados usando o Entity Framework, você já viu que a maioria dos métodos retornam IQueryable<ph id="ph1">&lt;T&gt;</ph>?</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You may have wondered what the <bpt id="p1">**</bpt>T<ept id="p1">**</ept> is in these examples and why is it in there?</source>
          <target state="translated">Talvez você tenha se perguntdo o que é o <bpt id="p1">**</bpt>T<ept id="p1">**</ept> nesses exemplos e por que ele está lá?</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>First introduced to the .NET Framework 2.0, generics involved changes to both the C# language and the Common Language Runtime (CLR).</source>
          <target state="translated">Introduzida pela primeira vez no .NET Framework 2.0, os genéricos envolviam alterações tanto à linguagem C# quanto CLR (Common Language Runtime).</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Generics<ept id="p1">**</ept> are essentially a “code template” that allows developers to define <bpt id="p2">[</bpt>type-safe<ept id="p2">](https://msdn.microsoft.com/library/hbzz1a9a.aspx)</ept> data structures without committing to an actual data type.</source>
          <target state="translated"><bpt id="p1">**</bpt>Genéricos<ept id="p1">**</ept> são essencialmente um "modelo de código" que permite que os desenvolvedores definam estruturas de dados <bpt id="p2">[</bpt>fortemente tipadas<ept id="p2">](https://msdn.microsoft.com/library/hbzz1a9a.aspx)</ept> sem se comprometer com um tipo de dados real.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`List&lt;T&gt;`</ph> is a <bpt id="p1">[</bpt>Generic Collection<ept id="p1">](https://msdn.microsoft.com/library/System.Collections.Generic.aspx)</ept> that can be declared and used with any type: <ph id="ph2">`List&lt;int&gt;`</ph>, <ph id="ph3">`List&lt;string&gt;`</ph>, <ph id="ph4">`List&lt;Person&gt;`</ph>, etc.</source>
          <target state="translated">Por exemplo, <ph id="ph1">`List&lt;T&gt;`</ph> é uma <bpt id="p1">[</bpt>coleção de genéricos<ept id="p1">](https://msdn.microsoft.com/library/System.Collections.Generic.aspx)</ept> que pode ser declarada e usada com qualquer tipo: <ph id="ph2">`List&lt;int&gt;`</ph>, <ph id="ph3">`List&lt;string&gt;`</ph>, <ph id="ph4">`List&lt;Person&gt;`</ph>, etc.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>So, what’s the point?</source>
          <target state="translated">Então, do que isso realmente se trata?</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Why are generics useful?</source>
          <target state="translated">Por que os genéricos são úteis?</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>In order to understand this, we need to take a look at a specific class before and after adding generics.</source>
          <target state="translated">Para compreender isso, precisamos dar uma olhada em uma classe específica antes e depois de adicionar os genéricos.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Let’s look at the <ph id="ph1">`ArrayList`</ph>.</source>
          <target state="translated">Vamos examinar o <ph id="ph1">`ArrayList`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In C# 1.0, the <ph id="ph1">`ArrayList`</ph> elements were of type <ph id="ph2">`object`</ph>.</source>
          <target state="translated">No C# 1.0, os elementos <ph id="ph1">`ArrayList`</ph> eram do tipo <ph id="ph2">`object`</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This meant that any element that was added was silently converted into an <ph id="ph1">`object`</ph>; same thing happens on reading the elements from the list (this process is known as <bpt id="p1">[</bpt>boxing<ept id="p1">](https://msdn.microsoft.com/library/yz2be5wk.aspx)</ept> and unboxing respectively).</source>
          <target state="translated">Isso significava que qualquer elemento que fosse adicionado silenciosamente era convertido em um <ph id="ph1">`object`</ph>; a mesma coisa acontece ao ler os elementos da lista (esse processo é conhecido como <bpt id="p1">[</bpt>conversão boxing<ept id="p1">](https://msdn.microsoft.com/library/yz2be5wk.aspx)</ept> e conversão unboxing, respectivamente).</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Boxing and unboxing have an impact of performance.</source>
          <target state="translated">Conversões boxing e unboxing têm um impacto sobre o desempenho.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>More than that, however, there is no way to tell at compile time what is the actual type of the data in the list.</source>
          <target state="translated">Mais importante do que isso, no entanto, não há uma maneira de saber, durante o tempo de compilação, qual é o tipo real dos dados na lista.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This makes for some fragile code.</source>
          <target state="translated">Isso resulta em um código frágil.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Generics solve this problem by providing additional information the type of data each instance of list will contain.</source>
          <target state="translated">Genéricos resolvem esse problema, fornecendo informações adicionais sobre o tipo de dados que cada instância da lista conterá.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Put simply, you can only add integers to <ph id="ph1">`List&lt;int&gt;`</ph> and only add Persons to <ph id="ph2">`List&lt;Person&gt;`</ph>, etc.</source>
          <target state="translated">Resumindo, você só pode adicionar inteiros a <ph id="ph1">`List&lt;int&gt;`</ph> e só pode adicionar pessoas a <ph id="ph2">`List&lt;Person&gt;`</ph>, etc.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Generics are also available at runtime, or <bpt id="p1">**</bpt>reified<ept id="p1">**</ept>.</source>
          <target state="translated">Genéricos também estão disponíveis em tempo de execução ou <bpt id="p1">**</bpt>reificados<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This means the runtime knows what type of data structure you are using and can store it in memory more efficiently.</source>
          <target state="translated">Isso significa que o tempo de execução sabe que tipo de estrutura de dados você está usando e pode armazená-la na memória com mais eficiência.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Here is a small program that illustrates the efficiency of knowing the data structure type at runtime:</source>
          <target state="translated">Aqui está um pequeno programa que ilustra a eficiência de saber o tipo da estrutura de dados em tempo de execução:</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This program yields the following output:</source>
          <target state="translated">Este programa produz a seguinte saída:</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The first thing you notice here is that sorting the generic list is significantly faster than for the non-generic list.</source>
          <target state="translated">A primeira coisa que você observa aqui é que classificar a lista genérica é significativamente mais rápido do que classificar a lista não genérica.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You might also notice that the type for the generic list is distinct ([System.Int32]) whereas the type for the non-generic list is generalized.</source>
          <target state="translated">Você também observará que o tipo de lista genérico é distinto ([System.Int32]) enquanto o tipo da lista não genérico é generalizado.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Because the runtime knows the generic <ph id="ph1">`List&lt;int&gt;`</ph> is of type int, it can store the list elements in an underlying integer array in memory while the non-generic <ph id="ph2">`ArrayList`</ph> has to cast each list element as an object as stored in an object array in memory.</source>
          <target state="translated">Como o tempo de execução sabe que o genérico <ph id="ph1">`List&lt;int&gt;`</ph> é do tipo int, ele pode armazenar elementos de lista em uma matriz de inteiros subjacente na memória, enquanto o <ph id="ph2">`ArrayList`</ph> não genérico tem que converter cada elemento da lista como um objeto armazenado em uma matriz de objetos na memória.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>As shown through this example, the extra castings take up time and slow down the list sort.</source>
          <target state="translated">Conforme mostrado neste exemplo, as conversões extras levam tempo e atrasam a classificação da lista.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The last useful thing about the runtime knowing the type of your generic is a better debugging experience.</source>
          <target state="translated">A última coisa útil sobre o tempo de execução saber o tipo de seu genérico é uma melhor experiência de depuração.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>When you are debugging a generic in C#, you know what type each element is in your data structure.</source>
          <target state="translated">Quando você está depurando um genérico em C#, você sabe que tipo de cada elemento está na sua estrutura de dados.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Without generics, you would have no idea what type each element was.</source>
          <target state="translated">Sem os genéricos, você não faria ideia de qual o tipo de cada elemento.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Further reading and resources</source>
          <target state="translated">Recursos e leituras adicionais</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>An Introduction to C# Generics<ept id="p1">](https://msdn.microsoft.com/library/ms379564.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Introdução aos genéricos C#<ept id="p1">](https://msdn.microsoft.com/library/ms379564.aspx)</ept></target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide - Generics<ept id="p1">](https://msdn.microsoft.com/library/512aeb7t.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Guia de Programação em C# – Genéricos<ept id="p1">](https://msdn.microsoft.com/library/512aeb7t.aspx)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>