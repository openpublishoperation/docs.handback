<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">36041eda54290484741c375ae776b7bf1a74d7a1</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\native-interop.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0350b8bceb01c1f5eed3e52a53eadd29fd462567</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">902ac0a2fae11665b6f094b1f80beeda47159590</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">The handback priority in file path dotnet-core\native-interop.8f6566123608155a52a2ab93eca340fe3087fb34.pt-br.xlf is not match with handoff type ht-p2</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">Interoperabilidade nativa</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Native interoperability</source>
          <target state="translated">Interoperabilidade nativa</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Native Interoperability</source>
          <target state="translated">Interoperabilidade nativa</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In this document, we will dive a little bit deeper into all three ways of doing “native interoperability” that are available on the .NET platform.</source>
          <target state="translated">Neste documento, encontraremos mais detalhes sobre as três maneiras de fazer “interoperabilidade nativa” que estão disponíveis na plataforma .NET.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>There are a few of reasons why you would want to call into native code:</source>
          <target state="translated">Existem alguns motivos para chamar em código nativo:</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Operating Systems come with a large volume of APIs that are not present in the managed class libraries.</source>
          <target state="translated">Os sistemas operacionais vêm com um grande volume de APIs que não estão presentes nas bibliotecas de classes gerenciadas.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A prime example for this would be access to hardware or operating system management functions.</source>
          <target state="translated">Um exemplo perfeito para isso seria o acesso a funções de gerenciamento de hardware ou do sistema operacional.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Communicating with other components that have or can produce C-style ABIs (native ABIs).</source>
          <target state="translated">Comunicação com outros componentes que têm ou podem produzir ABIs de estilo C (ABIs nativas).</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This covers, for example, Java code that is exposed via <bpt id="p1">[</bpt>Java Native Interface (JNI)<ept id="p1">](http://docs.oracle.com/javase/8/docs/technotes/guides/jni/)</ept> or any other managed language that could produce a native component.</source>
          <target state="translated">Isso abrange, por exemplo, código Java que é exposto por meio da <bpt id="p1">[</bpt>JNI (Interface Nativa do Java)<ept id="p1">](http://docs.oracle.com/javase/8/docs/technotes/guides/jni/)</ept> ou qualquer outra linguagem gerenciada que possa produzir um componente nativo.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>On Windows, most of the software that gets installed, such as Microsoft Office suite, registers COM components that represent their programs and allow developers to automate them or use them.</source>
          <target state="translated">No Windows, a maioria dos softwares que são instalados, como o pacote Microsoft Office, registra os componentes que representam seus programas e permitem que sejam automatizados ou usados pelos desenvolvedores.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This also requires native interoperability.</source>
          <target state="translated">Isso também requer interoperabilidade nativa.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Of course, the list above does not cover all of the potential situations and scenarios in which the developer would want/like/need to interface with native components.</source>
          <target state="translated">Evidentemente, a lista acima não abrange todas as possíveis situações e cenários em que o desenvolvedor desejaria/gostaria de/precisaria fazer interface com componentes nativos.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>.NET class library, for instance, uses the native interoperability support to implement a fair number of its APIs, like console support and manipulation, file system access and others.</source>
          <target state="translated">A biblioteca de classes do .NET, por exemplo, usa o suporte para interoperabilidade nativa para implementar um número razoável de APIs, como suporte ao console e manipulação, acesso ao sistema de arquivos e outras.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>However, it is important to note that there is an option, should one need it.</source>
          <target state="translated">No entanto, é importante observar que há uma opção, se necessário.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Most of the examples in this document will be presented for all three supported platforms for .NET Core (Windows, Linux and macOS).</source>
          <target state="translated">A maioria dos exemplos deste documento será apresentada para todas as três plataformas com suporte para .NET Core (Windows, Linux e macOS).</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>However, for some short and illustrative examples, just one sample is shown that uses Windows filenames and extensions (that is, “dll” for libraries).</source>
          <target state="translated">No entanto, para alguns exemplos ilustrativos e curtos, é exibida apenas uma amostra que usa nomes de arquivo e extensões do Windows (ou seja, “dll” para bibliotecas).</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This does not mean that those features are not available on Linux or macOS, it was done merely for convenience sake.</source>
          <target state="translated">Isso não significa que tais recursos não estão disponíveis em Linux ou macOS; foi feito simplesmente para maior conveniência.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Platform Invoke (P/Invoke)</source>
          <target state="translated">Invocação de plataforma (P/Invoke)</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>P/Invoke is a technology that allows you to access structs, callbacks and functions in unmanaged libraries from your managed code.</source>
          <target state="translated">P/Invoke é uma tecnologia que permite acessar structs, retornos de chamada e funções em bibliotecas não gerenciadas do seu código gerenciado.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Most of the P/Invoke API is contained in two namespaces: <ph id="ph1">`System`</ph> and <ph id="ph2">`System.Runtime.InteropServices`</ph>.</source>
          <target state="translated">A maior parte da API do P/Invoke está contida em dois namespaces: <ph id="ph1">`System`</ph> e <ph id="ph2">`System.Runtime.InteropServices`</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Using these two namespaces will allow you access to the attributes that describe how you want to communicate with the native component.</source>
          <target state="translated">A utilização desses dois namespaces permitirá acessar os atributos que descrevem como você deseja se comunicar com o componente nativo.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Let’s start from the most common example, and that is calling unmanaged functions in your managed code.</source>
          <target state="translated">Vamos começar com exemplo mais comum, que é chamar funções não gerenciadas no seu código gerenciado.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Let’s show a message box from a command-line application:</source>
          <target state="translated">Vamos mostrar uma caixa de mensagem de um aplicativo de linha de comando:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The example above is pretty simple, but it does show off what is needed to invoke unmanaged functions from managed code.</source>
          <target state="translated">O exemplo acima é muito simples, mas mostra o que é necessário para invocar funções não gerenciadas do código gerenciado.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Let’s step through the example:</source>
          <target state="translated">Vamos analisar o exemplo:</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Line #1 shows the using statement for the <ph id="ph1">`System.Runtime.InteropServices`</ph> which is the namespace that holds all of the items we need.</source>
          <target state="translated">A linha #1 mostra a instrução de uso para o <ph id="ph1">`System.Runtime.InteropServices`</ph>, que é o namespace que contém todos os itens de que precisamos.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Line #5 introduces the <ph id="ph1">`DllImport`</ph> attribute.</source>
          <target state="translated">A linha #5 apresenta o atributo <ph id="ph1">`DllImport`</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL.</source>
          <target state="translated">Esse atributo é crucial, pois informa ao tempo de execução que deve carregar a DLL não gerenciada.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This is the DLL into which we wish to invoke.</source>
          <target state="translated">É a DLL para a qual desejamos invocar.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Line #6 is the crux of the P/Invoke work.</source>
          <target state="translated">A linha #6 é o ponto crucial do trabalho do P/Invoke.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>It defines a managed method that has the <bpt id="p1">**</bpt>exact same signature<ept id="p1">**</ept> as the unmanaged one.</source>
          <target state="translated">Define um método gerenciado que tem <bpt id="p1">**</bpt>exatamente a mesma assinatura<ept id="p1">**</ept> que o não gerenciado.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The declaration has a new keyword that you can notice, <ph id="ph1">`extern`</ph>, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in <ph id="ph2">`DllImport`</ph> attribute.</source>
          <target state="translated">A declaração tem uma nova palavra-chave que você pode observar, <ph id="ph1">`extern`</ph>, que informa ao tempo de execução que é um método externo; quando invocado, o tempo de execução deve encontrá-la na DLL especificada no atributo <ph id="ph2">`DllImport`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The rest of the example is just invoking the method as you would any other managed method.</source>
          <target state="translated">O restante do exemplo é simplesmente chamar o método como você faria com qualquer outro método gerenciado.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The sample is similar for macOS.</source>
          <target state="translated">A amostra é semelhante para macOS.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>One thing that needs to change is, of course, the name of the library in the <ph id="ph1">`DllImport`</ph> attribute, as macOS has a different scheme of naming dynamic libraries.</source>
          <target state="translated">Uma coisa que precisa ser alterada é, obviamente, o nome da biblioteca no atributo <ph id="ph1">`DllImport`</ph>, pois o macOS tem um esquema diferente de nomenclatura de bibliotecas dinâmicas.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The sample below uses the <ph id="ph1">`getpid(2)`</ph> function to get the process ID of the application and print it out to the console.</source>
          <target state="translated">O exemplo abaixo usa a função <ph id="ph1">`getpid(2)`</ph> para obter a identificação do processo do aplicativo e imprimi-la para o console.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>It is similar on Linux, of course.</source>
          <target state="translated">É semelhante no Linux, evidentemente.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The function name is same, since <ph id="ph1">`getpid(2)`</ph> is <bpt id="p1">[</bpt>POSIX<ept id="p1">](https://en.wikipedia.org/wiki/POSIX)</ept> system call.</source>
          <target state="translated">O nome da função é o mesmo, já que <ph id="ph1">`getpid(2)`</ph> é uma chamada do sistema <bpt id="p1">[</bpt>POSIX<ept id="p1">](https://en.wikipedia.org/wiki/POSIX)</ept>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Invoking managed code from unmanaged code</source>
          <target state="translated">Chamando código gerenciado do código não gerenciado</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Of course, the runtime allows communication to flow both ways which enables you to call into managed artifacts from native functions, using function pointers.</source>
          <target state="translated">Naturalmente, o tempo de execução possibilita que a comunicação aconteça em ambas as direções, o que permite chamar artefato gerenciados de funções nativas usando ponteiros de função.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The closest thing to a function pointer in managed code is a <bpt id="p1">**</bpt>delegate<ept id="p1">**</ept>, so this is what is used to allow callbacks from native code into managed code.</source>
          <target state="translated">A coisa mais próxima a um ponteiro de função no código gerenciado é um <bpt id="p1">**</bpt>delegado<ept id="p1">**</ept>; portanto, isso é usado para permitir retornos de chamada do código nativo para o código gerenciado.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The way to use this feature is similar to managed to native process described above.</source>
          <target state="translated">A maneira de usar esse recurso é semelhante ao processo gerenciado para nativo, descrito acima.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For a given callback, you define a delegate that matches the signature, and pass that into the external method.</source>
          <target state="translated">Para um retorno de chamada específico, você define um delegado que corresponda à assinatura e o passa para o método externo.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The runtime will take care of everything else.</source>
          <target state="translated">O tempo de execução cuidará do resto.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Before we walk through our example, it is good to go over the signatures of the unmanaged functions we need to work with.</source>
          <target state="translated">Antes de analisarmos nosso exemplo, é bom examinar as assinaturas das funções não gerenciadas com as quais precisamos trabalhar.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The function we want to call to enumerate all of the windows has the following signature: <ph id="ph1">`BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</ph></source>
          <target state="translated">A função que desejamos chamar para enumerar todas as janelas tem esta assinatura: <ph id="ph1">`BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</ph></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The first parameter is a callback.</source>
          <target state="translated">O primeiro parâmetro é um retorno de chamada.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The said callback has the following signature: <ph id="ph1">`BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</ph></source>
          <target state="translated">Esse retorno de chamada tem a seguinte assinatura: <ph id="ph1">`BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</ph></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>With this in mind, let’s walk through the example:</source>
          <target state="translated">Com isso em mente, vamos analisar o exemplo:</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Line #8 in the example defines a delegate that matches the signature of the callback from unmanaged code.</source>
          <target state="translated">A linha #8 no exemplo define um delegado que corresponde à assinatura do retorno de chamada do código não gerenciado.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Notice how the LPARAM and HWND types are represented using <ph id="ph1">`IntPtr`</ph> in the managed code.</source>
          <target state="translated">Observe como os tipos LPARAM e HWND são representados usando <ph id="ph1">`IntPtr`</ph> no código gerenciado.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Lines #10 and #11 introduce the <ph id="ph1">`EnumWindows`</ph> function from the user32.dll library.</source>
          <target state="translated">As linhas #10 e #11 introduzem a função <ph id="ph1">`EnumWindows`</ph> da biblioteca user32.dll.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Lines #13 - 16 implement the delegate.</source>
          <target state="translated">As linhas #13-16 implementam o delegado.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For this simple example, we just want to output the handle to the console.</source>
          <target state="translated">Neste exemplo simples, queremos apenas produzir o identificador para o console.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Finally, in line #19 we invoke the external method and pass in the delegate.</source>
          <target state="translated">Por fim, na linha #19, invocamos o método externo e passamos o delegado.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The Linux and macOS examples are shown below.</source>
          <target state="translated">Os exemplos de Linux e macOS são mostrados abaixo.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For them, we use the <ph id="ph1">`ftw`</ph> function that can be found in <ph id="ph2">`libc`</ph>, the C library.</source>
          <target state="translated">Para eles, usamos a função <ph id="ph1">`ftw`</ph> que pode ser encontrada em <ph id="ph2">`libc`</ph>, a biblioteca C.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters.</source>
          <target state="translated">Essa função é usada para percorrer as hierarquias de diretório e leva um ponteiro para uma função como um dos seus parâmetros.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The said function has the following signature: <ph id="ph1">`int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`</ph>.</source>
          <target state="translated">Essa função tem a seguinte assinatura: <ph id="ph1">`int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>macOS example uses the same function, and the only difference is the argument to the <ph id="ph1">`DllImport`</ph> attribute, as macOS keeps <ph id="ph2">`libc`</ph> in a different place.</source>
          <target state="translated">O exemplo do macOS usa a mesma função; a única diferença é o argumento para o atributo <ph id="ph1">`DllImport`</ph>, pois o macOS mantém <ph id="ph2">`libc`</ph> em um local diferente.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Both of the above examples depend on parameters, and in both cases, the parameters are given as managed types.</source>
          <target state="translated">Os exemplos acima dependem de parâmetros e, em ambos os casos, os parâmetros são fornecidos como tipos gerenciados.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Runtime does the “right thing” and processes these into its equivalents on the other side.</source>
          <target state="translated">O tempo de execução faz a “coisa certa” e processa em equivalentes no outro lado.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Since this process is really important to writing quality native interop code, let’s take a look at what happens when the runtime <bpt id="p1">_</bpt>marshals<ept id="p1">_</ept> the types.</source>
          <target state="translated">Como esse processo é realmente importante para escrever código de interoperabilidade nativa de qualidade, vamos ver o que acontece quando o tempo de execução <bpt id="p1">_</bpt>realiza marshalling<ept id="p1">_</ept> dos tipos.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Type marshalling</source>
          <target state="translated">Marshalling dos tipos</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Marshalling<ept id="p1">**</ept> is the process of transforming types when they need to cross the managed boundary into native and vice versa.</source>
          <target state="translated"><bpt id="p1">**</bpt>Marshalling<ept id="p1">**</ept> é o processo de transformar tipos quando precisam atravessar o limite gerenciado para nativo e vice-versa.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The reason marshalling is needed is because the types in the managed and unmanaged code are different.</source>
          <target state="translated">O marshalling é necessário porque os tipos são diferentes, no código gerenciado e não gerenciado.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In managed code, for instance, you have a <ph id="ph1">`String`</ph>, while in the unmanaged world strings can be Unicode (“wide”), non-Unicode, null-terminated, ASCII, etc. By default, the P/Invoke subsystem will try to do the Right Thing based on the default behavior which you can see on <bpt id="p1">[</bpt>MSDN<ept id="p1">](https://msdn.microsoft.com/library/zah6xy75.aspx)</ept>.</source>
          <target state="translated">No código gerenciado, por exemplo, você tem um <ph id="ph1">`String`</ph>; no mundo não gerenciado, as cadeias de caracteres podem ser Unicode (“horizontais”), não Unicode, finalizadas com null, ASCII, etc. Por padrão, o subsistema do P/Invoke tentará fazer a coisa certa com base no comportamento padrão que você pode ver no <bpt id="p1">[</bpt>MSDN<ept id="p1">](https://msdn.microsoft.com/library/zah6xy75.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>However, for those situations where you need extra control, you can employ the <ph id="ph1">`MarshalAs`</ph> attribute to specify what is the expected type on the unmanaged side.</source>
          <target state="translated">Contudo, nas situações em que você precisa de controle extra, pode utilizar o atributo <ph id="ph1">`MarshalAs`</ph> para especificar qual é o tipo esperado no lado não gerenciado.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For instance, if we want the string to be sent as a null-terminated ANSI string, we could do it like this:</source>
          <target state="translated">Por exemplo, se quisermos que a cadeia de caracteres seja enviada como uma cadeia de caracteres ANSI finalizada com null, poderemos fazer o seguinte:</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Marshalling classes and structs</source>
          <target state="translated">Marshalling de classes e structs</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Another aspect of type marshalling is how to pass in a struct to an unmanaged method.</source>
          <target state="translated">Outro aspecto do marshalling de tipos é como passar um struct para um método não gerenciado.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For instance, some of the unmanaged methods require a struct as a parameter.</source>
          <target state="translated">Por exemplo, alguns dos métodos não gerenciados requerem um struct como parâmetro.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In these cases, we need to create a corresponding struct or a class in managed part of the world to use it as a parameter.</source>
          <target state="translated">Nesses casos, precisamos criar um struct correspondente ou uma classe na parte gerenciada do mundo para usar como parâmetro.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>However, just defining the class is not enough, we also need to instruct the marshaler how to map fields in the class to the unmanaged struct.</source>
          <target state="translated">No entanto, definir a classe não é suficiente; também precisamos ensinar o marshaler como mapear campos na classe para o struct não gerenciado.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>This is where the <ph id="ph1">`StructLayout`</ph> attribute comes into play.</source>
          <target state="translated">É aí que o atributo <ph id="ph1">`StructLayout`</ph> entra em cena.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The example above shows off a simple example of calling into <ph id="ph1">`GetSystemTime()`</ph> function.</source>
          <target state="translated">O exemplo acima mostra um exemplo simples de chamar para a função <ph id="ph1">`GetSystemTime()`</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The interesting bit is on line 4<ph id="ph1">\.</ph> The attribute specifies that the fields of the class should be mapped sequentially to the struct on the other (unmanaged) side.</source>
          <target state="translated">A parte interessante está na linha 4<ph id="ph1">\.</ph> O atributo especifica que os campos da classe devem apontar em sequência para o struct no outro lado (não gerenciado).</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This means that the naming of the fields is not important, only their order is important, as it needs to correspond to the unmanaged struct, shown below:</source>
          <target state="translated">Isso significa que os nomes dos campos não são importantes, apenas sua ordem é importante, já que precisa corresponder ao struct não gerenciado, mostrado abaixo:</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>We already saw the Linux and macOS example for this in the previous example.</source>
          <target state="translated">Já vimos o exemplo de Linux e macOS no exemplo anterior.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>It is shown again below.</source>
          <target state="translated">Ele é mostrado novamente abaixo.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`StatClass`</ph> class represents a structure that is returned by the <ph id="ph2">`stat`</ph> system call on UNIX systems.</source>
          <target state="translated">A classe <ph id="ph1">`StatClass`</ph> representa uma estrutura que é retornada pela chamada do sistema <ph id="ph2">`stat`</ph> em sistemas UNIX.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>It represents information about a given file.</source>
          <target state="translated">Representa informações sobre um arquivo específico.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The class above is the stat struct representation in managed code.</source>
          <target state="translated">A classe acima é a representação de struct stat no código gerenciado.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Again, the fields in the class have to be in the same order as the native struct (you can find these by perusing man pages on your favorite UNIX implementation) and they have to be of the same underlying type.</source>
          <target state="translated">Novamente, os campos na classe precisam estar na mesma ordem que o struct nativo (você pode encontrá-los analisando páginas do manual na sua implementação de UNIX favorita) e precisam ser do mesmo tipo subjacente.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>More resources</source>
          <target state="translated">Mais recursos</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>PInvoke.net wiki<ept id="p1">](http://www.pinvoke.net)</ept> an excellent Wiki with information on common Win32 APIs and how to call them.</source>
          <target state="translated"><bpt id="p1">[</bpt>PInvoke.net wiki<ept id="p1">](http://www.pinvoke.net)</ept> uma wiki excelente com informações sobre as APIs comuns do Win32 e como chamá-las.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>P/Invoke on MSDN<ept id="p1">](https://msdn.microsoft.com/library/zbz07712.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>P/Invoke no MSDN<ept id="p1">](https://msdn.microsoft.com/library/zbz07712.aspx)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Mono documentation on P/Invoke<ept id="p1">](http://www.mono-project.com/docs/advanced/pinvoke/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Documentação do Mono no P/Invoke<ept id="p1">](http://www.mono-project.com/docs/advanced/pinvoke/)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>