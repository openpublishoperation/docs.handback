<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ac0f1f0f538d629041b4baff47e0eaa425f9aedd</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\fsharp\language-reference\generics\index.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a10050ab7b40047888a631bd3f333d329365349e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f31269830be0c890189ec889f80e36489639a00a</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file index.1c0502d20d8c37c8bfb1064de057170fb40e3a73.pt-br.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Generics (F#)</source>
          <target state="translated">Genéricos (F#)</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Generics (F#)</source>
          <target state="translated">Genéricos (F#)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>visual f#, f#, functional programming</source>
          <target state="translated">visual f#, f#, programação funcional</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Genéricos</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be <bpt id="p1">*</bpt>generic<ept id="p1">*</ept>.</source>
          <target state="translated">Os valores, os métodos, as propriedades e os tipos de agregação, como classes, registros e uniões discriminadas, da função em F# podem ser <bpt id="p1">*</bpt>genéricos<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</source>
          <target state="translated">As construções genéricas contêm pelo menos um parâmetro de tipo, que é geralmente fornecido pelo usuário da construção genérica.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</source>
          <target state="translated">Os tipos e as funções genéricas permitem que você escreva códigos que funcionam com diversos tipos sem repetir o código de cada tipo.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</source>
          <target state="translated">Tornar seu código genérico pode ser algo simples em F#, pois normalmente seu código é implicitamente inferido como genérico pelos mecanismos de generalização automática e de inferência de tipos do compilador.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Sintaxe</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Comentários</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</source>
          <target state="translated">A declaração de um tipo ou de uma função explicitamente genérica é muito semelhante a de um tipo ou função não genérica, exceto com relação à especificação (e uso) dos parâmetros de tipo, entre colchetes após o nome da função ou do tipo.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Declarations are often implicitly generic.</source>
          <target state="translated">Geralmente, as declarações são implicitamente genéricas.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</source>
          <target state="translated">Se você não especificar completamente o tipo de cada parâmetro usado para compor uma função ou tipo, o compilador tentará inferir o tipo de cada parâmetro, o valor e a variável de código que você escreve.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Type Inference<ept id="p1">](../type-inference.md)</ept>.</source>
          <target state="translated">Para saber mais, veja <bpt id="p1">[</bpt>Inferência de tipo<ept id="p1">](../type-inference.md)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</source>
          <target state="translated">Se o código do tipo ou função não restringir de outro modo os tipos de parâmetros, a função ou o tipo será implicitamente genérico.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This process is named <bpt id="p1">*</bpt>automatic generalization<ept id="p1">*</ept>.</source>
          <target state="translated">Esse processo é chamado de <bpt id="p1">*</bpt>generalização automática<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>There are some limits on automatic generalization.</source>
          <target state="translated">Há alguns limites para a generalização automática.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the <bpt id="p1">*</bpt>value restriction<ept id="p1">*</ept>.</source>
          <target state="translated">Por exemplo, se o compilador em F# não puder inferir os tipos de uma construção genérica, o compilador relatará um erro que faz referência a uma restrição chamada de <bpt id="p1">*</bpt>restrição de valor<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In that case, you may have to add some type annotations.</source>
          <target state="translated">Nesse caso, talvez seja necessário adicionar algumas anotações de tipo.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see <bpt id="p1">[</bpt>Automatic Generalization<ept id="p1">](automatic-generalization.md)</ept>.</source>
          <target state="translated">Para saber mais sobre generalização automática e restrição de valor e como alterar seu código para resolver esse problema, veja <bpt id="p1">[</bpt>Generalização automática<ept id="p1">](automatic-generalization.md)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In the previous syntax, <bpt id="p1">*</bpt>type-parameters<ept id="p1">*</ept> is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</source>
          <target state="translated">Na sintaxe anterior, <bpt id="p1">*</bpt>type-parameters<ept id="p1">*</ept> é uma lista separada por vírgulas de parâmetros que representam tipos desconhecidos, cada um deles começa com uma aspa simples e, opcionalmente, com uma cláusula de restrição que limita ainda mais os tipos que podem ser usados para esse parâmetro de tipo.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For the syntax for constraint clauses of various kinds and other information about constraints, see <bpt id="p1">[</bpt>Constraints<ept id="p1">](constraints.md)</ept>.</source>
          <target state="translated">Para obter a sintaxe das cláusulas de restrição de vários tipos e outras informações sobre restrições, veja <bpt id="p1">[</bpt>Restrições<ept id="p1">](constraints.md)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>type-definition<ept id="p1">*</ept> in the syntax is the same as the type definition for a non-generic type.</source>
          <target state="translated">Na sintaxe, <bpt id="p1">*</bpt>type-definition<ept id="p1">*</ept> é igual à definição de tipo para um tipo não genérico.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>It includes the constructor parameters for a class type, an optional <ph id="ph1">`as`</ph> clause, the equal symbol, the record fields, the <ph id="ph2">`inherit`</ph> clause, the choices for a discriminated union, <ph id="ph3">`let`</ph> and <ph id="ph4">`do`</ph> bindings, member definitions, and anything else permitted in a non-generic type definition.</source>
          <target state="translated">Ele inclui os parâmetros do construtor para um tipo de classe, uma cláusula <ph id="ph1">`as`</ph> opcional, o símbolo de igual, os campos de registro, a cláusula <ph id="ph2">`inherit`</ph>, as opções de uma união discriminada, associações <ph id="ph3">`let`</ph> e <ph id="ph4">`do`</ph>, definições de membro e qualquer outra coisa permitida em uma definição de tipo não genérico.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The other syntax elements are the same as those for non-generic functions and types.</source>
          <target state="translated">Os outros elementos de sintaxe são os mesmos para tipos e funções não genéricos.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">*</bpt>object-identifier<ept id="p1">*</ept> is an identifier that represents the containing object itself.</source>
          <target state="translated">Por exemplo, <bpt id="p1">*</bpt>object-identifier<ept id="p1">*</ept> é um identificador que representa o objeto contido em si.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Properties, fields, and constructors cannot be more generic than the enclosing type.</source>
          <target state="translated">Os construtores, os campos e as propriedades não podem ser mais genéricos do que o tipo delimitador.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Also, values in a module cannot be generic.</source>
          <target state="translated">Além disso, os valores em um módulo não podem ser genéricos.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Implicitly Generic Constructs</source>
          <target state="translated">Construções implicitamente genéricas</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</source>
          <target state="translated">Quando o compilador de F# infere os tipos em seu código, ele trata automaticamente qualquer função que possa ser genérica como genérica.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</source>
          <target state="translated">Se você especificar um tipo explicitamente, como um tipo de parâmetro, você evita a generalização automática.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In the following code example, <ph id="ph1">`makeList`</ph> is generic, even though neither it nor its parameters are explicitly declared as generic.</source>
          <target state="translated">No exemplo de código a seguir, <ph id="ph1">`makeList`</ph> é genérico, mesmo que ele ou seus parâmetros não sejam explicitamente declarados como genéricos.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet1700.fs)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet1700.fs)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The signature of the function is inferred to be <ph id="ph1">`'a -&gt; 'a -&gt; 'a list`</ph>.</source>
          <target state="translated">A assinatura da função é inferida como <ph id="ph1">`'a -&gt; 'a -&gt; 'a list`</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Note that <ph id="ph1">`a`</ph> and <ph id="ph2">`b`</ph> in this example are inferred to have the same type.</source>
          <target state="translated">Observe que, neste exemplo, <ph id="ph1">`a`</ph> e <ph id="ph2">`b`</ph> são inferidos com tendo o mesmo tipo.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This is because they are included in a list together, and all elements of a list must be of the same type.</source>
          <target state="translated">Isso ocorre porque eles são incluídos em uma lista juntos, e todos os elementos de uma lista devem ser do mesmo tipo.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</source>
          <target state="translated">Você também pode tornar uma função genérica usando a sintaxe de aspas simples em uma anotação de tipo para indicar que um tipo de parâmetro é um parâmetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>In the following code, <ph id="ph1">`function1`</ph> is generic because its parameters are declared in this manner, as type parameters.</source>
          <target state="translated">No código a seguir, <ph id="ph1">`function1`</ph> é genérico porque os parâmetros são declarados dessa maneira, como parâmetros de tipo.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet1701.fs)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet1701.fs)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Explicitly Generic Constructs</source>
          <target state="translated">Construções explicitamente genéricas</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>You can also make a function generic by explicitly declaring its type parameters in angle brackets (<ph id="ph1">`&lt;type-parameter&gt;`</ph>).</source>
          <target state="translated">Você também pode tornar uma função genérica declarando explicitamente seus parâmetros de tipo entre colchetes angulares (<ph id="ph1">`&lt;type-parameter&gt;`</ph>).</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following code illustrates this.</source>
          <target state="translated">O código a seguir ilustra isso.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet1703.fs)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet1703.fs)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Using Generic Constructs</source>
          <target state="translated">Como usar construções genéricas</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>When you use generic functions or methods, you might not have to specify the type arguments.</source>
          <target state="translated">Quando você usa métodos ou funções genéricas, talvez não seja necessário especificar os argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The compiler uses type inference to infer the appropriate type arguments.</source>
          <target state="translated">O compilador usa a inferência de tipo para inferir os argumentos de tipo apropriados.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</source>
          <target state="translated">Se ainda houver ambiguidade, forneça argumentos de tipo entre colchetes angulares, separando vários argumentos de tipo por vírgulas.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The following code shows the use of the functions that are defined in the previous sections.</source>
          <target state="translated">O código a seguir mostra o uso das funções definidas nas seções anteriores.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet1702.fs)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet1702.fs)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>There are two ways to refer to a generic type by name.</source>
          <target state="translated">Há duas maneiras de se referir a um tipo genérico por nome.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`list&lt;int&gt;`</ph> and <ph id="ph2">`int list`</ph> are two ways to refer to a generic type <ph id="ph3">`list`</ph> that has a single type argument <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Por exemplo, <ph id="ph1">`list&lt;int&gt;`</ph> e <ph id="ph2">`int list`</ph> são duas maneiras de se referir a um tipo genérico <ph id="ph3">`list`</ph> que tem um único argumento de tipo <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The latter form is conventionally used only with built-in F# types such as <ph id="ph1">`list`</ph> and <ph id="ph2">`option`</ph>.</source>
          <target state="translated">A segunda forma é usada apenas com tipos internos de F#, como <ph id="ph1">`list`</ph> e <ph id="ph2">`option`</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>If there are multiple type arguments, you normally use the syntax <ph id="ph1">`Dictionary&lt;int, string&gt;`</ph> but you can also use the syntax <ph id="ph2">`(int, string) Dictionary`</ph>.</source>
          <target state="translated">Se houver vários argumentos de tipo, você normalmente usará a sintaxe <ph id="ph1">`Dictionary&lt;int, string&gt;`</ph>, mas também é possível usar a sintaxe <ph id="ph2">`(int, string) Dictionary`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Wildcards as Type Arguments</source>
          <target state="translated">Caracteres curinga como argumentos de tipo</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (<ph id="ph1">`_`</ph>), instead of a named type argument.</source>
          <target state="translated">Para especificar se um argumento de tipo deve ser deduzido pelo compilador, você pode usar o sublinhado, ou um símbolo de caractere curinga (<ph id="ph1">`_`</ph>), em vez de um argumento de tipo nomeado.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This is shown in the following code.</source>
          <target state="translated">Isso será mostrado no código a seguir.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet1704.fs)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet1704.fs)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Constraints in Generic Types and Functions</source>
          <target state="translated">Restrições em funções e tipos genéricos</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</source>
          <target state="translated">Em uma definição de função ou tipo genérico, você pode usar somente as construções sabidamente disponíveis no parâmetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This is required to enable the verification of function and method calls at compile time.</source>
          <target state="translated">Isso é necessário para habilitar a verificação de chamadas de função e de método no tempo de compilação.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</source>
          <target state="translated">Se você declarar explicitamente os parâmetros de tipo, aplique uma restrição explícita a um parâmetro de tipo genérico a fim de notificar o compilador de que certos métodos e funções estão disponíveis.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</source>
          <target state="translated">No entanto, se você permitir que o compilador de F# deduza seus tipos de parâmetros genéricos, ele determinará as restrições apropriadas a você.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Constraints<ept id="p1">](constraints.md)</ept>.</source>
          <target state="translated">Para saber mais, veja <bpt id="p1">[</bpt>Restrições<ept id="p1">](constraints.md)</ept>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Statically Resolved Type Parameters</source>
          <target state="translated">Parâmetros de tipo resolvidos estaticamente</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>There are two kinds of type parameters that can be used in F# programs.</source>
          <target state="translated">Há dois tipos de parâmetros de tipo que podem ser usados em programas em F#.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The first are generic type parameters of the kind described in the previous sections.</source>
          <target state="translated">O primeiro são os parâmetros de tipo genérico do tipo descrito nas seções anteriores.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</source>
          <target state="translated">Esse primeiro tipo de parâmetro de tipo é equivalente a parâmetros de tipo genérico usados em linguagens como Visual Basic e C#.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Another kind of type parameter is specific to F# and is referred to as a <bpt id="p1">*</bpt>statically resolved type parameter<ept id="p1">*</ept>.</source>
          <target state="translated">Outro tipo de parâmetro de tipo é específico do F# e é conhecido como um <bpt id="p1">*</bpt>parâmetro de tipo resolvido estaticamente<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For information about these constructs, see <bpt id="p1">[</bpt>Statically Resolved Type Parameters<ept id="p1">](statically-resolved-type-parameters.md)</ept>.</source>
          <target state="translated">Para saber mais sobre essas construções, veja <bpt id="p1">[</bpt>Parâmetros de tipo resolvidos estaticamente<ept id="p1">](statically-resolved-type-parameters.md)</ept>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Exemplos</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet1705.fs)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-fsharp</bpt><bpt id="p2">[</bpt>Main<ept id="p2">](../../../../samples/snippets/fsharp/lang-ref-1/snippet1705.fs)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Consulte também</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Language Reference<ept id="p1">](../index.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Referência de linguagem<ept id="p1">](../index.md)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types<ept id="p1">](../fsharp-types.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tipos<ept id="p1">](../fsharp-types.md)</ept></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Statically Resolved Type Parameters<ept id="p1">](statically-resolved-type-parameters.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Parâmetros de tipo resolvidos estaticamente<ept id="p1">](statically-resolved-type-parameters.md)</ept></target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generics in the .NET Framework<ept id="p1">](https://msdn.microsoft.com/library/ms172192.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Genéricos no .NET Framework<ept id="p1">](https://msdn.microsoft.com/library/ms172192.aspx)</ept></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Automatic Generalization<ept id="p1">](automatic-generalization.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generalização automática<ept id="p1">](automatic-generalization.md)</ept></target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Constraints<ept id="p1">](constraints.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Restrições<ept id="p1">](constraints.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>