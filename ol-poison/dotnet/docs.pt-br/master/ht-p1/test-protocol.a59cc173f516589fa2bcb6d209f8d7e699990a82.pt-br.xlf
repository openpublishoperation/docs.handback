<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a35385cbb08614493fdcfc74504b00178dc532ea</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\tools\test-protocol.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p1</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">571f9ba49be9fc4a0d1dd23f2457b2087630460a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc71dad02f1e86873b9019185f14ff3375d92ce9</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Targeting source file commit 81e7604f0a646e5de9c2ed35ff3b6ef6d7fb2e71 is lower than latest handed back source file commit 81e7604f0a646e5de9c2ed35ff3b6ef6d7fb2e71</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">Protocolo de comunicação de teste da CLI do .NET Core</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">Protocolo de comunicação de teste da CLI do .NET Core</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core CLI test communication protocol</source>
          <target state="translated">Protocolo de comunicação de teste da CLI do .NET Core</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introdução</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Anytime you pass a port to dotnet test, the command will run in design time.</source>
          <target state="translated">Sempre que você passar uma porta para o teste dotnet, o comando será executado no tempo de design.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>That means that dotnet test will connect to that port using TCP and will then exchange an established set of messages with whatever else is connected to that port.</source>
          <target state="translated">Isso significa que esse teste dotnet conectará a essa porta usando TCP e trocará um conjunto de mensagens estabelecida com qualquer outra coisa que estiver conectada a essa porta.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When this happens, the runner also receives a new port that dotnet test will use to communicate with it.</source>
          <target state="translated">Quando isso acontece, o executor também recebe uma nova porta que o teste dotnet usará para se comunicar com ele.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The reason why the runner also uses TCP to communicate with dotnet test is because in design mode, it is not sufficient to just output results to the console.</source>
          <target state="translated">O motivo pelo qual o executor também usa TCP para se comunicar com o teste dotnet é porque no modo design não é suficiente apenas gerar os resultados para o console.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The command needs to send the adapter structure messages containing the results of the test execution.</source>
          <target state="translated">O comando precisa enviar as mensagens de estrutura do adaptador que contém os resultados da execução do teste.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Communication protocol at design time.</source>
          <target state="translated">Protocolo de comunicação no tempo de design.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Because during design time, dotnet test connects to a port when it starts up, the adapter needs to be listening on that port otherwise dotnet test will fail.</source>
          <target state="translated">Como no tempo de design o teste dotnet se conecta a uma porta quando é iniciado, o adaptador precisa estar escutando essa porta, caso contrário o teste dotnet falhará.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>We did it like this so that the adapter could reserve all the ports it needs by binding and listening to them before dotnet test ran and tried to get ports for the runner.</source>
          <target state="translated">Deixamos isso desta forma para que o adaptador possa reservar todas as portas necessárias associando e escutando-as antes que o teste dotnet fosse executado e tentasse obter portas para o executor.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Once dotnet test starts, it sends a TestSession.Connected message to the adapter indicating that it is ready to receive messages.</source>
          <target state="translated">Uma vez iniciado o teste dotnet, ele envia uma mensagem TestSession.Connected ao adaptador indicando que ele está pronto para receber mensagens.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>It is possible to send an optional <bpt id="p1">[</bpt>version check<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept> message with the adapter version of the protocol in it.</source>
          <target state="translated">É possível enviar uma mensagem de <bpt id="p1">[</bpt>verificação de versão<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept> opcional com a versão do adaptador do protocolo nela.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Dotnet test will send back the version of the protocol that it supports.</source>
          <target state="translated">O teste dotnet enviará de volta a versão do protocolo à qual ele dá suporte.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>All messages have the format described here: <bpt id="p1">[</bpt>Message.cs<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>.</source>
          <target state="translated">Todas as mensagens têm o formato descrito aqui: <bpt id="p1">[</bpt>Message.cs<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The payload formats for each message is described in links to the classes used to serialize/deserialize the information in the description of the protocol.</source>
          <target state="translated">Os formatos de carga para cada mensagem são descritos em links para as classes usadas para serializar/desserializar as informações na descrição do protocolo.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Test Execution</source>
          <target state="translated">Execução de Teste</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Test Execution</source>
          <target state="translated">Execução de Teste</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>After the optional version check, the adapter sends a TestExecution.GetTestRunnerProcessStartInfo, with the <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> it wants to execute inside of it.</source>
          <target state="translated">Após a verificação de versão opcional, o adaptador enviará um TestExecution.GetTestRunnerProcessStartInfo com os <bpt id="p1">[</bpt>testes<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> que deseja executar dentro dele.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Dotnet test sends back a FileName and Arguments inside a <bpt id="p1">[</bpt>TestStartInfo<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.DotNet.Tools.Test/TestStartInfo.cs)</ept> payload that the adapter can use to start the runner.</source>
          <target state="translated">O teste dotnet envia de volta um FileName e Arguments dentro de uma carga <bpt id="p1">[</bpt>TestStartInfo<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.DotNet.Tools.Test/TestStartInfo.cs)</ept> que o adaptador pode usar para iniciar o executor.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In the past, we would send the list of tests to run as part of that argument, but we were actually going over the command line size limit for some test projects.</source>
          <target state="translated">No passado, podíamos enviar a lista de testes a serem executados como parte do argumento, mas a verdade é que com isso ultrapassávamos o limite de tamanho da linha de comando para alguns projetos de teste.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>As part of the arguments, we send a port that the runner should connect to and for executing tests, a --wait-command flag, that indicates that the runner should connect to the port and wait for commands, instead of going ahead and executing the tests.</source>
          <target state="translated">Como parte dos argumentos, enviaremos uma porta à qual o executor deve se conectar e para executar testes,um sinalizador --wait-command, que indica que o executor deve se conectar à porta e aguardar os comandos em vez de prosseguir e executar os testes.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>At this point, the adapter can launch the runner (and attach to it for debugging if it chooses to).</source>
          <target state="translated">Neste ponto, o adaptador pode iniciar o executor (e anexar a ele para depuração se optar por fazer isso).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Once the runner starts, it sends dotnet test a TestRunner.WaitCommand message that indicates it is ready to receive commands, at which point dotnet test sends a TestRunner.Execute with the list of <bpt id="p1">[</bpt>tests<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> to run.</source>
          <target state="translated">Uma vez iniciado o executor, ele envia uma mensagem TestRunner.WaitCommand para o teste dotnet que indica que ele está pronto para receber comandos, quando então o teste dotnet envia um TestRunner.Execute com a lista de <bpt id="p1">[</bpt>testes<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> a ser executados.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This bypasses the command line size limit described above.</source>
          <target state="translated">Isso ignora o limite de tamanho da linha de comando descrito acima.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The runner then sends dotnet test (and it passes forward to the adapter) a TestExecution.TestStarted for each tests as they start with the <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> information inside of it.</source>
          <target state="translated">O executor de teste dotnet envia (e transmite para o adaptador) um TestExecution.TestStarted para cada teste, pois eles começam com as informações de <bpt id="p1">[</bpt>teste<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> dentro dele.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The runner also sends dotnet test (and it forwards to the adapter) a TestExecution.TestResult for each test with the <bpt id="p1">[</bpt>individual result<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept> of the test.</source>
          <target state="translated">O executor também envia para o teste dotnet (e encaminha para o adaptador) um TestExecution.TestResult para cada teste com o <bpt id="p1">[</bpt>resultado individual<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept> do teste.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>After all tests finish, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestExecution.Completed to the adapter.</source>
          <target state="translated">Depois de concluir todos os testes, o executor envia uma mensagem TestRunner.Completed para o teste dotnet, a qual o teste dotnet envia como TestExecution.Completed para o adaptador.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.</source>
          <target state="translated">Quando o adaptador tiver concluído, ele envia para o teste dotnet um TestSession.Terminate que fará com que o teste dotnet seja desligado.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Test discovery</source>
          <target state="translated">Descoberta de teste</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Test discovery</source>
          <target state="translated">Descoberta de teste</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>After the optional version check, the adapter sends a TestDiscovery.Start message.</source>
          <target state="translated">Após a verificação de versão opcional, o adaptador envia uma mensagem TestDiscovery.Start.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Because in this case, the adapter does not need to attach to the process, dotnet test will start the runner itself.</source>
          <target state="translated">Como nesse caso o adaptador não precisa anexar ao processo, o teste dotnet iniciará o próprio executor.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Also, since there is no long list of arguments to be passed to the runner, no --wait-command flag is needed to be passed to the runner.</source>
          <target state="translated">Além disso, visto que não há nenhuma lista longa de argumentos a serem passados para o executor, nenhum sinalizador --wait-command é necessário para ser passado para o executor.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>dotnet test only passes a --list argument to the runner, which means the runner should not run the tests, just list them.</source>
          <target state="translated">O teste dotnet apenas passa um argumento --list para o executor, o que significa que o executor não deve executar os testes, apenas listá-los.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The runner then sends dotnet test (and it passes forward to the adapter) a TestDiscovery.TestFound for each <bpt id="p1">[</bpt>test<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> found.</source>
          <target state="translated">O executor envia para o teste dotnet (e transmite para o adaptador) um TestDiscovery.TestFound para cada <bpt id="p1">[</bpt>teste<ept id="p1">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> encontrado.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>After all tests are discovered, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestDiscovery.Completed to the adapter.</source>
          <target state="translated">Depois que todos os testes foram descobertos, o executor envia uma mensagem TestRunner.Completed para o teste dotnet, a qual o teste dotnet envia como TestDiscovery.Completed para o adaptador.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.</source>
          <target state="translated">Quando o adaptador tiver concluído, ele envia para o teste dotnet um TestSession.Terminate que fará com que o teste dotnet seja desligado.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>