<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">88b6bddcdeec2859844f5d5f94777146d488b5fb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\linq-to-xml-vs-dom.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f2c2cdc40489a532d8f326c6c5e4f0549bafc0a9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a240e3e78b46cbd0414aa63daed0a4271195b57c</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_linq-to-xml-vs-dom.b885cedf8f5437b1934557d12d343eddc2407aa2.pt-br is different with handoff file name: linq-to-xml-vs-dom.b885cedf8f5437b1934557d12d343eddc2407aa2.pt-br.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>LINQ to XML vs. DOM (Visual Basic) | Microsoft Docs</source>
          <target state="translated">LINQ to XML e DOM (Visual Basic) | Documentos do Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>LINQ to XML vs. DOM (Visual Basic)</source>
          <target state="translated">LINQ to XML e DOM (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This section describes some key differences between <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> and the current predominant XML programming API, the W3C Document Object Model (DOM).</source>
          <target state="translated">Esta seção descreve algumas das principais diferenças entre <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> e API, o modelo de objeto de documento (DOM) W3C de programação XML predominante atual.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>New Ways to Construct XML Trees</source>
          <target state="translated">Novas maneiras de criar árvores XML</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In the W3C DOM, you build an XML tree from the bottom up; that is, you create a document, you create elements, and then you add the elements to the document.</source>
          <target state="translated">No W3C DOM, você cria uma árvore XML de baixo para cima; ou seja, você cria um documento, cria elementos e, em seguida, adiciona elementos ao documento.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, the following would be a typical way to create an XML tree using the Microsoft implementation of DOM, &lt;xref:System.Xml.XmlDocument&gt;:</source>
          <target state="translated">Por exemplo, o seguinte seria uma maneira comum de criar uma árvore XML usando a implementação da Microsoft do DOM, &lt;xref:System.Xml.XmlDocument&gt;:&lt;/xref:System.Xml.XmlDocument&gt;</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This style of coding does not visually provide much information about the structure of the XML tree.</source>
          <target state="translated">Este estilo de codificação não fornece visualmente muitas informações sobre a estrutura da árvore XML.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> supports this approach to constructing an XML tree, but also supports an alternative approach, <bpt id="p1">*</bpt>functional construction<ept id="p1">*</ept>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>oferece suporte a essa abordagem para construir uma árvore XML, mas também oferece suporte a uma abordagem alternativa, <bpt id="p1">*</bpt>construção funcional<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In Visual Basic, functional construction uses XML literals to build an XML tree.</source>
          <target state="translated">No Visual Basic, a construção funcional usa literais XML para criar uma árvore XML.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Here is how you would construct the same XML tree by using <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> functional construction:</source>
          <target state="translated">Aqui está como você poderia construir a mesma árvore XML usando <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> construção funcional:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Notice that indenting the code to construct the XML tree shows the structure of the underlying XML.</source>
          <target state="translated">Observe que o recuo do código para construir a árvore XML mostra a estrutura do XML subjacente.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Creating XML Trees (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/creating-xml-trees.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>criar árvores XML (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/creating-xml-trees.md)</ept>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Working Directly with XML Elements</source>
          <target state="translated">Trabalhando diretamente com Elementos XML</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>When you program with XML, your primary focus is usually on XML elements and perhaps on attributes.</source>
          <target state="translated">Quando você programa com XML, o foco principal é geralmente em elementos XML e talvez em atributos.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, you can work directly with XML elements and attributes.</source>
          <target state="translated">No <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, você pode trabalhar diretamente com elementos e atributos XML.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For example, you can do the following:</source>
          <target state="translated">Por exemplo, você pode fazer o seguinte:</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Create XML elements without using a document object at all.</source>
          <target state="translated">Criar elementos XML sem usar nenhum objeto de documento.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This simplifies programming when you have to work with fragments of XML trees.</source>
          <target state="translated">Isso simplifica a programação quando você tem que trabalhar com partes de árvores XML.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Load <ph id="ph1">`T:System.Xml.Linq.XElement`</ph> objects directly from an XML file.</source>
          <target state="translated">Carregue objetos <ph id="ph1">`T:System.Xml.Linq.XElement`</ph> diretamente de um arquivo XML.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Serialize <ph id="ph1">`T:System.Xml.Linq.XElement`</ph> objects to a file or a stream.</source>
          <target state="translated">Serialize objetos <ph id="ph1">`T:System.Xml.Linq.XElement`</ph> para um arquivo ou fluxo.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Compare this to the W3C DOM, in which the XML document is used as a logical container for the XML tree.</source>
          <target state="translated">Compare isso para o W3C DOM, no qual o documento XML é usado como um contêiner lógico para a árvore XML.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In DOM, XML nodes, including elements and attributes, must be created in the context of an XML document.</source>
          <target state="translated">No DOM, os nós XML, incluindo elementos e atributos, devem ser criados no contexto de um documento XML.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Here is a fragment of the code to create a name element in DOM:</source>
          <target state="translated">Aqui está um fragmento de código para criar um elemento de nome DOM:</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If you want to use an element across multiple documents, you must import the nodes across documents.</source>
          <target state="translated">Se você quiser usar um elemento em vários documentos, deverá importar os nós nos documentos.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> avoids this layer of complexity.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>evita essa camada de complexidade.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>When using LINQ to XML, you use the &lt;xref:System.Xml.Linq.XDocument&gt; class only if you want to add a comment or processing instruction at the root level of the document.</source>
          <target state="translated">Ao usar LINQ to XML, você usa o &lt;xref:System.Xml.Linq.XDocument&gt;classe somente se você quiser adicionar uma instrução de processamento ou comentário no nível da raiz do documento.&lt;/xref:System.Xml.Linq.XDocument&gt;</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Simplified Handling of Names and Namespaces</source>
          <target state="translated">Tratamento simplificado de nomes e namespaces</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Handling names, namespaces, and namespace prefixes is generally a complex part of XML programming.</source>
          <target state="translated">Tratar nomes, namespaces e prefixos de namespace é geralmente uma parte complexa da programação de XML.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> simplifies names and namespaces by eliminating the requirement to deal with namespace prefixes.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>simplifica os nomes e namespaces eliminando a necessidade de lidar com prefixos de namespace.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If you want to control namespace prefixes, you can.</source>
          <target state="translated">Se quiser, você pode controlar prefixos de namespace.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>But if you decide to not explicitly control namespace prefixes, <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> will assign namespace prefixes during serialization if they are required, or will serialize using default namespaces if they are not.</source>
          <target state="translated">Mas se você decidir não controlar explicitamente os prefixos de namespace <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> atribuirá prefixos de namespace durante a serialização se forem necessários, ou serializará usando namespaces padrão se não forem.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If default namespaces are used, there will be no namespace prefixes in the resulting document.</source>
          <target state="translated">Se namespaces padrão forem usados, haverá sem prefixos de namespace no documento resultante.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/working-with-xml-namespaces.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>trabalhar com Namespaces XML (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/working-with-xml-namespaces.md)</ept>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Another problem with the DOM is that it does not let you change the name of a node.</source>
          <target state="translated">Outro problema com os DOM é que ele não permite que você altere o nome de um nó.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Instead, you have to create a new node and copy all the child nodes to it, losing the original node identity.</source>
          <target state="translated">Em vez disso, você precisa criar um novo nó e copiar todos os nós filhos para ele, perdendo a identidade do nó original.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> avoids this problem by enabling you to set the &lt;xref:System.Xml.Linq.XName&gt; property on a node.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>evita esse problema, permitindo que você defina o &lt;xref:System.Xml.Linq.XName&gt;propriedade em um nó.&lt;/xref:System.Xml.Linq.XName&gt;</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Static Method Support for Loading XML</source>
          <target state="translated">Suporte de método estático para carregar XML</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> lets you load XML by using static methods, instead of instance methods.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>permite que você carregue XML usando métodos estáticos, em vez de métodos de instância.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This simplifies loading and parsing.</source>
          <target state="translated">Isso simplifica o carregamento e a análise.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Load XML from a File (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/how-to-load-xml-from-a-file.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>como: carregar XML de um arquivo (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/how-to-load-xml-from-a-file.md)</ept>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Removal of Support for DTD Constructs</source>
          <target state="translated">Remoção de suporte para construções de DTD</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> further simplifies XML programming by removing support for entities and entity references.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>simplifica ainda mais a programação removendo o suporte para entidades e referências a entidades XML.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The management of entities is complex, and is rarely used.</source>
          <target state="translated">O gerenciamento de entidades é complexo e raramente é utilizado.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Removing their support increases performance and simplifies the programming interface.</source>
          <target state="translated">Remover o suporte aumenta o desempenho e simplifica a interface de programação.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>When a <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> tree is populated, all DTD entities are expanded.</source>
          <target state="translated">Quando um <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> árvore é preenchida, todas as entidades DTD são expandidas.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Support for Fragments</source>
          <target state="translated">Suporte para fragmentos</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> does not provide an equivalent for the <ph id="ph2">`XmlDocumentFragment`</ph> class.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>não fornece um equivalente para o <ph id="ph2">`XmlDocumentFragment`</ph> classe.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In many cases, however, the <ph id="ph1">`XmlDocumentFragment`</ph> concept can be handled by the result of a query that is typed as &lt;xref:System.Collections.Generic.IEnumerable%601&gt; of &lt;xref:System.Xml.Linq.XNode&gt;, or &lt;xref:System.Collections.Generic.IEnumerable%601&gt; of &lt;xref:System.Xml.Linq.XElement&gt;.</source>
          <target state="translated">Em muitos casos, no entanto, o <ph id="ph1">`XmlDocumentFragment`</ph> conceito pode ser tratado pelo resultado de uma consulta que é digitado como &lt;xref:System.Collections.Generic.IEnumerable%601&gt;de &lt;xref:System.Xml.Linq.XNode&gt;, ou &lt;xref:System.Collections.Generic.IEnumerable%601&gt;de &lt;xref:System.Xml.Linq.XElement&gt;.&lt;/xref:System.Xml.Linq.XElement&gt; &lt;/xref:System.Collections.Generic.IEnumerable%601&gt; &lt;/xref:System.Xml.Linq.XNode&gt; &lt;/xref:System.Collections.Generic.IEnumerable%601&gt;</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Support for XPathNavigator</source>
          <target state="translated">Suporte para XPathNavigator</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> provides support for &lt;xref:System.Xml.XPath.XPathNavigator&gt; through extension methods in the &lt;xref:System.Xml.XPath?displayProperty=fullName&gt; namespace.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>fornece suporte para &lt;xref:System.Xml.XPath.XPathNavigator&gt;por meio de métodos de extensão no &lt;xref:System.Xml.XPath?displayProperty=fullName&gt;namespace.&lt;/xref:System.Xml.XPath?displayProperty=fullName&gt; &lt;/xref:System.Xml.XPath.XPathNavigator&gt;</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;xref:System.Xml.XPath.Extensions?displayProperty=fullName&gt;.</source>
          <target state="translated">Para obter mais informações, consulte &lt;xref:System.Xml.XPath.Extensions?displayProperty=fullName&gt;.&lt;/xref:System.Xml.XPath.Extensions?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Support for White Space and Indentation</source>
          <target state="translated">Suporte para espaço em branco e recuo</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> handles white space more simply than the DOM.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>manipula o espaço em branco mais simples que o DOM.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>A common scenario is to read indented XML, create an in-memory XML tree without any white space text nodes (that is, not preserving white space), perform some operations on the XML, and then save the XML with indentation.</source>
          <target state="translated">Um cenário comum é ler o XML recuado, criar uma árvore XML na memória sem nenhum nó de texto de espaço em branco (isto é, não preservar espaço em branco), executar algumas operações no XML e, em seguida, salvar o XML com recuo.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>When you serialize the XML with formatting, only significant white space in the XML tree is preserved.</source>
          <target state="translated">Quando você serializa o XML com formatação, somente os espaços em branco significativos na árvore XML são preservados.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This is the default behavior for <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>.</source>
          <target state="translated">Este é o comportamento padrão para <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Another common scenario is to read and modify XML that has already been intentionally indented.</source>
          <target state="translated">Outro cenário comum é ler e modificar XML que já foi recuado intencionalmente.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You might not want to change this indentation in any way.</source>
          <target state="translated">Você pode não querer modificar este recuo de nenhuma forma.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, you can do this by preserving white space when you load or parse the XML and disabling formatting when you serialize the XML.</source>
          <target state="translated">No <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, você pode fazer isso preservando o espaço em branco ao carregar ou analisar o XML e desabilitando a formatação ao serializar o XML.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> stores white space as an &lt;xref:System.Xml.Linq.XText&gt; node, instead of having a specialized &lt;xref:System.Xml.XmlNodeType&gt; node type, as the DOM does.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>armazena o espaço em branco como um &lt;xref:System.Xml.Linq.XText&gt;nó, em vez de ter especializado &lt;xref:System.Xml.XmlNodeType&gt;tipo de nó, como o DOM faz.&lt;/xref:System.Xml.XmlNodeType&gt; &lt;/xref:System.Xml.Linq.XText&gt;</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Support for Annotations</source>
          <target state="translated">Suporte para anotações</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> elements support an extensible set of annotations.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>elementos oferecem suporte a um conjunto extensível de anotações.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This is useful for tracking miscellaneous information about an element, such as schema information, information about whether the element is bound to a UI, or any other kind of application-specific information.</source>
          <target state="translated">Isso é útil para controlar informações variadas sobre um elemento, como informações de esquema, informações sobre se o elemento é associado a uma interface do usuário ou qualquer outra informação de tipo de aplicativo específico.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>LINQ to XML Annotations<ept id="p1">](http://msdn.microsoft.com/library/e2f0052d-61e2-48d4-9ea4-356c9cab35d5)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>anotações LINQ to XML<ept id="p1">](http://msdn.microsoft.com/library/e2f0052d-61e2-48d4-9ea4-356c9cab35d5)</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Support for Schema Information</source>
          <target state="translated">Suporte para informações do esquema</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> provides support for XSD validation through extension methods in the &lt;xref:System.Xml.Schema?displayProperty=fullName&gt; namespace.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>fornece suporte para validação de XSD por meio de métodos de extensão no &lt;xref:System.Xml.Schema?displayProperty=fullName&gt;namespace.&lt;/xref:System.Xml.Schema?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can validate that an XML tree complies with an XSD.</source>
          <target state="translated">Você pode validar que uma árvore XML está em conformidade com XSD.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>You can populate the XML tree with the post-schema-validation infoset (PSVI).</source>
          <target state="translated">Você pode preencher a árvore XML com o PSVI (post-schema-validation infoset).</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Validate Using XSD<ept id="p1">](http://msdn.microsoft.com/library/481a97fa-6e96-46f2-8c9a-415555fac33b)</ept> and &lt;xref:System.Xml.Schema.Extensions&gt;.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>como: validar usando XSD<ept id="p1">](http://msdn.microsoft.com/library/481a97fa-6e96-46f2-8c9a-415555fac33b)</ept> e &lt;xref:System.Xml.Schema.Extensions&gt;.&lt;/xref:System.Xml.Schema.Extensions&gt;</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Consulte também</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Getting Started (LINQ to XML)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/getting-started-linq-to-xml.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Introdução (LINQ to XML)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/getting-started-linq-to-xml.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>