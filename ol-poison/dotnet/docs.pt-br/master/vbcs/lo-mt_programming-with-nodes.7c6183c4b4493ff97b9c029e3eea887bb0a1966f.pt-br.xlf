<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">52fb60b95b869a79900f84c2a1a7a6151bb5b58f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\programming-with-nodes.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8130e1cf9590c7980123209f85b300f267b7e59b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">25f662c4ac837ff60c67e236762eba69a9dc8aa1</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_programming-with-nodes.7c6183c4b4493ff97b9c029e3eea887bb0a1966f.pt-br is different with handoff file name: programming-with-nodes.7c6183c4b4493ff97b9c029e3eea887bb0a1966f.pt-br.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Programming with Nodes (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Programando conosco (Visual Basic) | Documentos do Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Programming with Nodes (Visual Basic)</source>
          <target state="translated">Programação conosco (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> developers who need to write programs such as an XML editor, a transform system, or a report writer often need to write programs that work at a finer level of granularity than elements and attributes.</source>
          <target state="translated">desenvolvedores de<ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> que precisam geralmente escrever programas como um editor XML, um sistema uma transformação, ou uma necessidade o gravador de relatório escrever programas que funcionam no nível mais fino de granularidade dos elementos e atributos.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>They often need to work at the node level, manipulating text nodes, processing instructions, and comments.</source>
          <target state="translated">Freqüentemente necessitam de trabalhar no nível de nó, em nós de manipulação de texto, as instruções de processamento, e os comentários.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic provides some details about programming at the node level.</source>
          <target state="translated">Este tópico fornece alguns detalhes sobre programação no nível do nó.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Node Details</source>
          <target state="translated">Detalhes do nó</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>There are a number of details of programming that a programmer working at the node level should know.</source>
          <target state="translated">Há um número de detalhes de programação que um programador que funciona a nível do nó deve conhecer.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Parent Property of Children Nodes of XDocument is Set to Null</source>
          <target state="translated">A propriedade pai de nós de filhos de XDocument é definida como nula</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.Linq.XObject.Parent%2A&gt; property contains the parent &lt;xref:System.Xml.Linq.XElement&gt;, not the parent node.</source>
          <target state="translated">O &lt;xref:System.Xml.Linq.XObject.Parent%2A&gt;propriedade contém o pai &lt;xref:System.Xml.Linq.XElement&gt;, não o nó pai.&lt;/xref:System.Xml.Linq.XElement&gt; &lt;/xref:System.Xml.Linq.XObject.Parent%2A&gt;</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Child nodes of &lt;xref:System.Xml.Linq.XDocument&gt; have no parent &lt;xref:System.Xml.Linq.XElement&gt;.</source>
          <target state="translated">Nós filhos de &lt;xref:System.Xml.Linq.XDocument&gt;não ter nenhum pai &lt;xref:System.Xml.Linq.XElement&gt;.&lt;/xref:System.Xml.Linq.XElement&gt; &lt;/xref:System.Xml.Linq.XDocument&gt;</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Their parent is the document, so the &lt;xref:System.Xml.Linq.XObject.Parent%2A&gt; property for those nodes is set to null.</source>
          <target state="translated">Seu pai é o documento, para que o &lt;xref:System.Xml.Linq.XObject.Parent%2A&gt;propriedade para esses nós é definida como null.&lt;/xref:System.Xml.Linq.XObject.Parent%2A&gt;</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this:</source>
          <target state="translated">O exemplo a seguir demonstra este:</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este exemplo gera a seguinte saída:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Adjacent Text Nodes are Possible</source>
          <target state="translated">Nós adjacentes de texto são possíveis</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In a number of XML programming models, adjacent text nodes are always merged.</source>
          <target state="translated">Em um número XML que programa modelos, nós adjacentes de texto sempre são mesclados.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This is sometimes called normalization of text nodes.</source>
          <target state="translated">Isso é às vezes chamado normalização de nós de texto.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> does not normalize text nodes.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> não normalizará nós de texto.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you add two text nodes to the same element, it will result in adjacent text nodes.</source>
          <target state="translated">Se você adicionar dois nós de texto ao mesmo elemento, resultará a nós adjacentes de texto.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>However, if you add content specified as a string rather than as an &lt;xref:System.Xml.Linq.XText&gt; node, <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> might merge the string with an adjacent text node.</source>
          <target state="translated">No entanto, se você adicionar conteúdo especificado como uma cadeia de caracteres em vez de um &lt;xref:System.Xml.Linq.XText&gt;nó <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> pode mesclar a cadeia de caracteres com um nó de texto adjacente.&lt;/xref:System.Xml.Linq.XText&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this:</source>
          <target state="translated">O exemplo a seguir demonstra este:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este exemplo gera a seguinte saída:</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Empty Text Nodes are Possible</source>
          <target state="translated">Os nós vazios de texto são possíveis</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In some XML programming models, text nodes are guaranteed to not contain the empty string.</source>
          <target state="translated">Em algum XML que programa modelos, os nós de texto são garantidos para não conter a cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The reasoning is that such a text node has no impact on serialization of the XML.</source>
          <target state="translated">O raciocínio é que um nó de texto não tem impacto na serialização XML.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>However, for the same reason that adjacent text nodes are possible, if you remove the text from a text node by setting its value to the empty string, the text node itself will not be deleted.</source>
          <target state="translated">No entanto, pela mesma razão nós adjacentes do texto são possíveis, se você remover o texto de um nó de texto definindo seu valor para a cadeia de caracteres vazia, o nó de texto em si não serão excluídos.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este exemplo gera a seguinte saída:</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>An Empty Text Node Impacts Serialization</source>
          <target state="translated">Um nó de texto vazio afeta a serialização</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If an element contains only a child text node that is empty, it is serialized with the long tag syntax: <ph id="ph1">`&lt;Child&gt;&lt;/Child&gt;`</ph>.</source>
          <target state="translated">Se um elemento contém apenas um nó filho do texto que está vazio, é serializado com longa sintaxe de marca: <ph id="ph1">`&lt;Child&gt;&lt;/Child&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If an element contains no child nodes whatsoever, it is serialized with the short tag syntax: <ph id="ph1">`&lt;Child /&gt;`</ph>.</source>
          <target state="translated">Se um elemento não contém nenhum nó filho, qualquer é serializado pela sintaxe abreviada de marca: <ph id="ph1">`&lt;Child /&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este exemplo gera a seguinte saída:</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Namespaces are Attributes in the LINQ to XML Tree</source>
          <target state="translated">Namespaces são atributos na árvore LINQ to XML</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Even though namespace declarations have identical syntax to attributes, in some programming interfaces, such as XSLT and XPath, namespace declarations are not considered to be attributes.</source>
          <target state="translated">Mesmo que as declarações namespace tenham a sintaxe idêntica a atributos, em algumas interfaces de programação, como XSLT e o XPath, as declarações namespace não são consideradas como atributos.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>However, in <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, namespaces are stored as &lt;xref:System.Xml.Linq.XAttribute&gt; objects in the XML tree.</source>
          <target state="translated">No entanto, em <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, namespaces são armazenadas como &lt;xref:System.Xml.Linq.XAttribute&gt;objetos na árvore XML.&lt;/xref:System.Xml.Linq.XAttribute&gt;</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you iterate through the attributes for an element that contains a namespace declaration, you will see the namespace declaration as one of the items in the returned collection.</source>
          <target state="translated">Se você itera através de atributos para um elemento que contém uma declaração de namespace, você verá a declaração de namespace como um dos itens na coleção retornada.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Xml.Linq.XAttribute.IsNamespaceDeclaration%2A&gt; property indicates whether an attribute is a namespace declaration.</source>
          <target state="translated">O &lt;xref:System.Xml.Linq.XAttribute.IsNamespaceDeclaration%2A&gt;propriedade indica se um atributo é uma declaração de namespace.&lt;/xref:System.Xml.Linq.XAttribute.IsNamespaceDeclaration%2A&gt;</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este exemplo gera a seguinte saída:</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>XPath Axis Methods Do Not Return Child White Space of XDocument</source>
          <target state="translated">Os métodos do eixo XPath retornam espaço em branco filho de XDocument</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> allows for child text nodes of an &lt;xref:System.Xml.Linq.XDocument&gt;, as long as the text nodes contain only white space.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>permite que nós de texto filho de um &lt;xref:System.Xml.Linq.XDocument&gt;, contanto que os nós de texto contém somente espaço em branco.&lt;/xref:System.Xml.Linq.XDocument&gt;</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>However, the XPath object model does not include white space as child nodes of a document, so when you iterate through the children of an &lt;xref:System.Xml.Linq.XDocument&gt; using the &lt;xref:System.Xml.Linq.XContainer.Nodes%2A&gt; axis, white space text nodes will be returned.</source>
          <target state="translated">No entanto, o modelo de objeto XPath não inclui o espaço em branco como nós filho de um documento, então quando você itera através de filhos de um &lt;xref:System.Xml.Linq.XDocument&gt;usando o &lt;xref:System.Xml.Linq.XContainer.Nodes%2A&gt;eixo, nós de texto de espaço em branco serão retornados.&lt;/xref:System.Xml.Linq.XContainer.Nodes%2A&gt; &lt;/xref:System.Xml.Linq.XDocument&gt;</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>However, when you iterate through the children of an &lt;xref:System.Xml.Linq.XDocument&gt; using the XPath axis methods, white space text nodes will not be returned.</source>
          <target state="translated">No entanto, quando você itera através de filhos de um &lt;xref:System.Xml.Linq.XDocument&gt;usando os métodos de eixo XPath, nós de texto de espaço em branco não serão retornados.&lt;/xref:System.Xml.Linq.XDocument&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este exemplo gera a seguinte saída:</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>XDeclaration Objects are not Nodes</source>
          <target state="translated">Os objetos de XDeclaration não são nós</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When you iterate through the children nodes of an &lt;xref:System.Xml.Linq.XDocument&gt;, you will not see the XML declaration object.</source>
          <target state="translated">Quando você itera através de nós filhos de um &lt;xref:System.Xml.Linq.XDocument&gt;, você não verá o objeto de declaração XML.&lt;/xref:System.Xml.Linq.XDocument&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>It is a property of the document, not a child node of it.</source>
          <target state="translated">É uma propriedade do documento, não um nó filho deles.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
          <target state="translated">Este exemplo gera a seguinte saída:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Consulte também</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Advanced LINQ to XML Programming (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Avançada LINQ to XML programação (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>