<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e72540726bdd1b3624064c7388e58d80320c5831</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\character-encoding.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b73b5b21b030d4950c1041bdd0f07aeb8388b963</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b3b23336c2f6d3d51c94110149950c68c41b93a0</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file character-encoding.9f7c193d37ac8a4e5d5dc58d51e833684394535f.ru-ru.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Character encoding in .NET</source>
          <target state="translated">Кодировка символов в .NET</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Character encoding in .NET</source>
          <target state="translated">Кодировка символов в .NET</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Character encoding in .NET</source>
          <target state="translated">Кодировка символов в .NET</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Characters are abstract entities that can be represented in many different ways.</source>
          <target state="translated">Символы — это абстрактные сущности, которые могут быть представлены различными способами.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>A character encoding is a system that pairs each character in a supported character set with some value that represents that character.</source>
          <target state="translated">Кодировка — это система, где с каждым символом поддерживаемого набора символов сопоставляется значение, представляющее этот символ.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, Morse code is a character encoding that pairs each character in the Roman alphabet with a pattern of dots and dashes that are suitable for transmission over telegraph lines.</source>
          <target state="translated">Например, азбука Морзе — это кодировка, в которой каждому символу латинского алфавита соответствует набор точек и тире, которые можно передавать с помощью телеграфа.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A character encoding for computers pairs each character in a supported character set with a numeric value that represents that character.</source>
          <target state="translated">Компьютерная кодировка — это система, где с каждым символом поддерживаемого набора символов сопоставлено числовое значение, представляющее этот символ.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A character encoding has two distinct components:</source>
          <target state="translated">Кодировка состоит из двух компонентов:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>An encoder, which translates a sequence of characters into a sequence of numeric values (bytes).</source>
          <target state="translated">кодировщик, преобразующий последовательность символов в последовательность числовых значений (байтов);</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>A decoder, which translates a sequence of bytes into a sequence of characters.</source>
          <target state="translated">декодер, преобразующий последовательность байтов в последовательность символов.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Character encoding describes the rules by which an encoder and a decoder operate.</source>
          <target state="translated">Кодировка описывает правила, по которым работают кодировщик и декодер.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> class describes the rules for encoding to, and decoding from, 8-bit Unicode Transformation Format (UTF-8), which uses one to four bytes to represent a single Unicode character.</source>
          <target state="translated">Например, класс <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> описывает правила кодирования и декодирования для формата UTF-8, в котором используется от одного до четырех байтов для представления одного символа Юникода.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Encoding and decoding can also include validation.</source>
          <target state="translated">В процессе кодирования и декодирования также может выполняться проверка.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> class checks all surrogates to make sure they constitute valid surrogate pairs.</source>
          <target state="translated">Например, класс <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> предназначен для проверки допустимости пар, составляемых всеми символами-заместителями.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>(A surrogate pair consists of a character with a code point that ranges from U+D800 to U+DBFF followed by a character with a code point that ranges from U+DC00 to U+DFFF.) A fallback strategy determines how an encoder handles invalid characters or how a decoder handles invalid bytes.</source>
          <target state="translated">(Пара символов-заместителей состоит из символа с кодовой точкой в диапазоне от U+D800 до U+DBFF и символа с кодовой точкой в диапазоне от U+DC00 до U+DFFF.) Резервная стратегия определяет, как кодировщик обрабатывает недопустимые символы или как декодер обрабатывает недопустимые байты.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The .NET encoding classes provide a way to store and convert character data.</source>
          <target state="translated">Классы кодировок .NET позволяют хранить и преобразовывать символьные данные.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>They should not be used to store binary data in string form.</source>
          <target state="translated">Их не следует использовать для хранения двоичных данных в строковом виде.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Depending on the encoding used, converting binary data to string format with the encoding classes can introduce unexpected behavior and produce inaccurate or corrupted data.</source>
          <target state="translated">В зависимости от используемой кодировки преобразование двоичных данных в строковый формат с использованием классов кодировок может привести к неожиданному результату и неточным или поврежденным данным.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To convert binary data to a string form, use the <bpt id="p1">[</bpt>Convert.ToBase64String<ept id="p1">](xref:System.Convert.ToBase64String(System.Byte[]))</ept> method.</source>
          <target state="translated">Для преобразования двоичных данных в строковый формат используйте метод <bpt id="p1">[</bpt>Convert.ToBase64String<ept id="p1">](xref:System.Convert.ToBase64String(System.Byte[]))</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>.NET uses the UTF-16 encoding (represented by the <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept> class) to represent characters and strings.</source>
          <target state="translated">Платформа .NET использует кодировку UTF-16 (представленную классом <bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept>) для представления символов и строк.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Applications that target the common language runtime use encoders to map Unicode character representations supported by the common language runtime to other encoding schemes.</source>
          <target state="translated">В приложениях, предназначенных для среды CLR, кодировщики используются для сопоставления представлений символов Юникода, поддерживаемых средой CLR, с другими схемами кодирования.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>They use decoders to map characters from non-Unicode encodings to Unicode.</source>
          <target state="translated">Декодеры служат для сопоставления символов различных кодировок с Юникодом.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This topic consists of the following sections:</source>
          <target state="translated">В этом разделе:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Encodings in .NET<ept id="p1">](#encodings-in-net)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Кодировки в .NET<ept id="p1">](#encodings-in-net)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Selecting an encoding class<ept id="p1">](#selecting-an-encoding-class)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Выбор класса кодировки<ept id="p1">](#selecting-an-encoding-class)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using an encoding object<ept id="p1">](#using-an-encoding-object)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Использование объекта кодировки<ept id="p1">](#using-an-encoding-object)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Choosing a fallback strategy<ept id="p1">](#choosing-a-fallback-strategy)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Выбор резервной стратегии<ept id="p1">](#choosing-a-fallback-strategy)</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Реализация пользовательской резервной стратегии<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Encodings in .NET</source>
          <target state="translated">Кодировки в .NET</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>All character encoding classes in .NET inherit from the <bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> class, which is an abstract class that defines the functionality common to all character encodings.</source>
          <target state="translated">Все классы кодировок в .NET наследуют от класса <bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> — абстрактного класса, определяющего общую для всех кодировок функциональность.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>To access the individual encoding objects implemented in .NET, do the following:</source>
          <target state="translated">Для доступа к отдельным объектам кодировок, реализованным в .NET, можно сделать следующее:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Use the static properties of the <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> class, which return objects that represent the standard character encodings available in .NET (ASCII, UTF-7, UTF-8, UTF-16, and UTF-32).</source>
          <target state="translated">Использовать статические свойства класса <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept>, возвращающие объекты, которые представляют стандартные кодировки, доступные в .NET (ASCII, UTF-7, UTF-8, UTF-16 и UTF-32).</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt>Encoding.Unicode<ept id="p1">](xref:System.Text.Encoding.Unicode)</ept> property returns a <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept> object.</source>
          <target state="translated">Например, свойство <bpt id="p1">[</bpt>Encoding.Unicode<ept id="p1">](xref:System.Text.Encoding.Unicode)</ept> возвращает объект <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Each object uses replacement fallback to handle strings that it cannot encode and bytes that it cannot decode.</source>
          <target state="translated">Каждый объект использует резервную стратегию замены для обработки строк, которые он не может закодировать, и байтов, которые не может декодировать.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Replacement fallback<ept id="p1">](#replacement-fallback)</ept> section.)</source>
          <target state="translated">(Подробнее см. в разделе <bpt id="p1">[</bpt>Стратегия замены<ept id="p1">](#replacement-fallback)</ept>.)</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Call the encoding's class constructor.</source>
          <target state="translated">Вызвать конструктор класса кодировки.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Objects for the ASCII, UTF-7, UTF-8, UTF-16, and UTF-32 encodings can be instantiated in this way.</source>
          <target state="translated">Таким образом могут быть созданы объекты для кодировок ASCII, UTF-7, UTF-8, UTF-16 и UTF-32.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>By default, each object uses replacement fallback to handle strings that it cannot encode and bytes that it cannot decode, but you can specify that an exception should be thrown instead.</source>
          <target state="translated">По умолчанию каждый объект использует резервную стратегию замены для обработки строк, которые он не может закодировать, и байтов, которые он не может декодировать, но вы можете указать, чтобы вместо этого создавалось исключение.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Replacement fallback<ept id="p1">](#replacement-fallback)</ept> and <bpt id="p2">[</bpt>Exception fallback<ept id="p2">](#exception-fallback)</ept> sections.)</source>
          <target state="translated">(Подробнее см. в разделах <bpt id="p1">[</bpt>Стратегия замены<ept id="p1">](#replacement-fallback)</ept> и <bpt id="p2">[</bpt>Стратегия исключения<ept id="p2">](#exception-fallback)</ept>.)</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">[</bpt>Encoding.Encoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> constructor and pass it an integer that represents the encoding.</source>
          <target state="translated">Вызвать конструктор <bpt id="p1">[</bpt>Encoding.Encoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> и передать ему целое число, представляющее кодировку.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Standard encoding objects use replacement fallback, and code page and double-byte character set (DBCS) encoding objects use best-fit fallback to handle strings that they cannot encode and bytes that they cannot decode.</source>
          <target state="translated">Объекты стандартных кодировок используют резервные стратегии замены, а объекты кодовых страниц и двухбайтовых кодировок (DBCS) используют резервную стратегию наилучшего соответствия для обработки строк, которые не удается закодировать, или байтов, которые не удается декодировать.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Best-Fit fallback<ept id="p1">](#best-fit-fallback)</ept> section.)</source>
          <target state="translated">(Подробнее см. в разделе <bpt id="p1">[</bpt>Стратегия наилучшего соответствия<ept id="p1">](#best-fit-fallback)</ept>.)</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">[</bpt>Encoding.GetEncoding<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> method, which returns any standard, code page, or DBCS encoding available in .NET.</source>
          <target state="translated">Вызвать метод <bpt id="p1">[</bpt>Encoding.GetEncoding<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept>, возвращающий любую стандартную кодировку, кодовую страницу или кодировку DBCS, доступную в .NET.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Overloads let you specify a fallback object for both the encoder and the decoder.</source>
          <target state="translated">Перегрузки позволяют задать резервный объект как для кодировщика, так и для декодера.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The Unicode Standard assigns a code point (a number) and a name to each character in every supported script.</source>
          <target state="translated">В стандарте Юникода каждому символу в каждом поддерживаемом символьном наборе присваивается кодовая точка (номер) и имя.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For example, the character "A" is represented by the code point U+0041 and the name "LATIN CAPITAL LETTER A".</source>
          <target state="translated">Например, символ "A" представляется кодовой точкой U+0041 и именем LATIN CAPITAL LETTER A.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The Unicode Transformation Format (UTF) encodings define ways to encode that code point into a sequence of one or more bytes.</source>
          <target state="translated">Кодировки UTF определяют способы кодирования кодовой точки в виде последовательности из одного или нескольких байтов.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A Unicode encoding scheme simplifies world-ready application development because it allows characters from any character set to be represented in a single encoding.</source>
          <target state="translated">Схема кодировки Юникод упрощает разработку международных приложений, так как позволяет представлять символы любых наборов символов в единой кодировке.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Application developers no longer have to keep track of the encoding scheme that was used to produce characters for a specific language or writing system, and data can be shared among systems internationally without being corrupted.</source>
          <target state="translated">Разработчикам приложений больше не нужно сохранять данные о схеме кодировки, которая использовалась для представления символов конкретного языка или системы письма. Передача данных между системами, использующими различные языки, может происходить без искажений.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>.NET supports three encodings defined by the Unicode standard: UTF-8, UTF-16, and UTF-32.</source>
          <target state="translated">Платформа .NET поддерживает три кодировки, определенные стандартом Юникод: UTF-8, UTF-16 и UTF-32.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For more information, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode<ept id="p1">](http://www.unicode.org/)</ept> home page.</source>
          <target state="translated">Дополнительные сведения см. в описании стандарта Юникод на домашней странице <bpt id="p1">[</bpt>Юникода<ept id="p1">](http://www.unicode.org/)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>.NET supports the character encoding systems listed in the following table.</source>
          <target state="translated">Платформа .NET поддерживает системы кодирования символов, перечисленные в таблице ниже.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Кодировка</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">Класс</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Advantages/disadvantages</source>
          <target state="translated">Преимущества и недостатки</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept></target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Encodes a limited range of characters by using the lower seven bits of a byte.</source>
          <target state="translated">Кодирует ограниченный диапазон символов, используя семь младших битов байта.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Because this encoding only supports character values from U+0000 through U+007F, in most cases it is inadequate for internationalized applications.</source>
          <target state="translated">Так как эта кодировка поддерживает только значения символов от U+0000 до U+007F, то в большинстве случаев она не отвечает требованиям международных приложений.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UTF7Encoding<ept id="p1">](xref:System.Text.UTF7Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UTF7Encoding<ept id="p1">](xref:System.Text.UTF7Encoding)</ept></target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Represents characters as sequences of 7-bit ASCII characters.</source>
          <target state="translated">Представляет символы в виде последовательностей 7-разрядных символов ASCII.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Non-ASCII Unicode characters are represented by an escape sequence of ASCII characters.</source>
          <target state="translated">Символы Юникода, не относящиеся к ASCII, представляются в виде escape-последовательности символов ASCII.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>UTF-7 supports protocols such as e-mail and newsgroup protocols.</source>
          <target state="translated">UTF-7 поддерживает протоколы, например протоколы электронной почты и групп новостей.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>However, UTF-7 is not particularly secure or robust.</source>
          <target state="translated">Однако формат UTF-7 недостаточно безопасен и надежен.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In some cases, changing one bit can radically alter the interpretation of an entire UTF-7 string.</source>
          <target state="translated">В некоторых случаях изменение одного бита может привести к существенному изменению интерпретации всей строки UTF-7.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In other cases, different UTF-7 strings can encode the same text.</source>
          <target state="translated">В других случаях для кодировки одного и того же текста могут использоваться разные строки UTF-7.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For sequences that include non-ASCII characters, UTF-7 requires more space than UTF-8, and encoding/decoding is slower.</source>
          <target state="translated">В последовательностях, содержащих отличные от ASCII символы, формат UTF-7 требует больше места, чем UTF-8, а кодирование и декодирование выполняются медленнее.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Consequently, you should use UTF-8 instead of UTF-7 if possible.</source>
          <target state="translated">Поэтому по возможности лучше использовать UTF-8 вместо UTF-7.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a sequence of one to four bytes.</source>
          <target state="translated">Представляет каждую кодовую точку Юникода в виде последовательности от одного до четырех байтов.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>UTF-8 supports 8-bit data sizes and works well with many existing operating systems.</source>
          <target state="translated">UTF-8 поддерживает 8-разрядный размер данных и хорошо работает со многими операционными системами.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For the ASCII range of characters, UTF-8 is identical to ASCII encoding and allows a broader set of characters.</source>
          <target state="translated">Для диапазона символов ASCII кодировка UTF-8 идентична кодировке ASCII и предоставляет более широкий набор символов.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, for Chinese-Japanese-Korean (CJK) scripts, UTF-8 can require three bytes for each character, and can potentially cause larger data sizes than UTF-16.</source>
          <target state="translated">Однако для китайской, японской и корейской письменности UTF-8 может потребовать три байта для каждого символа, что может привести к большему объему данных по сравнению с UTF-16.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Note that sometimes the amount of ASCII data, such as HTML tags, justifies the increased size for the CJK range.</source>
          <target state="translated">Обратите внимание, что иногда увеличение размера данных для китайской, японской и корейской письменности объясняется объемом данных ASCII, например тегами HTML.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UnicodeEncoding<ept id="p1">](xref:System.Text.UnicodeEncoding)</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a sequence of one or two 16-bit integers.</source>
          <target state="translated">Представляет каждую кодовую точку Юникода в виде последовательности одного или двух 16-разрядных целых чисел.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Most common Unicode characters require only one UTF-16 code point, although Unicode supplementary characters (U+10000 and greater) require two UTF-16 surrogate code points.</source>
          <target state="translated">Наиболее распространенные символы Юникода требуют только одной кодовой точки UTF-16, хотя дополнительные символы Юникода (U+10000 и далее) требуют двух замещающих кодовых точек UTF-16.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Both little-endian and big-endian byte orders are supported.</source>
          <target state="translated">Поддерживаются оба порядка байтов: прямой и обратный.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>UTF-16 encoding is used by the common language runtime to represent Char and String values, and it is used by the Windows operating system to represent WCHAR values.</source>
          <target state="translated">Кодировка UTF-16 используется средой CLR для представления значений Char и String, а операционной системой Windows — для представления значений WCHAR.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a 32-bit integer.</source>
          <target state="translated">Представляет каждую кодовую точку Юникода в виде 32-разрядного целого числа.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Both little-endian and big-endian byte orders are supported.</source>
          <target state="translated">Поддерживаются оба порядка байтов: прямой и обратный.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>UTF-32 encoding is used when applications want to avoid the surrogate code point behavior of UTF-16 encoding on operating systems for which encoded space is too important.</source>
          <target state="translated">Кодировка UTF-32 используется в случае, когда приложению требуется избежать поведения замещающей кодовой точки кодировки UTF-16 в операционных системах, в которых закодированное пространство имеет большое значение.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Single glyphs rendered on a display can still be encoded with more than one UTF-32 character.</source>
          <target state="translated">Для кодирования отдельных отображаемых глифов может использоваться несколько символов UTF-32.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>These encodings enable you to work with Unicode characters as well as with encodings that are most commonly used in legacy applications.</source>
          <target state="translated">Эти кодировки позволяют работать с символами Юникода, а также с кодировками, которые часто используются в приложениях прежних версий.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>In addition, you can create a custom encoding by defining a class that derives from <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> and overriding its members.</source>
          <target state="translated">Кроме того, можно создать настраиваемую кодировку, определив класс, производный от <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept>, и переопределив его члены.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>By default, .NET Core does not make available any code page encodings other than code page 28591 and the Unicode encodings, such as UTF-8 and UTF-16.</source>
          <target state="translated">По умолчанию .NET Core не предоставляет доступ к кодировкам кодовых страниц, кроме кодовой страницы 28591 и кодировок Юникода, например UTF-8 и UTF-16.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>However, you can add the code page encodings found in standard Windows apps that target the .NET Framework to your app.</source>
          <target state="translated">Однако вы можете добавить в свое приложение кодировки кодовых страниц из стандартных приложений Windows, ориентированных на .NET Framework.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For complete information, see the <bpt id="p1">[</bpt>EncodingProvider<ept id="p1">](xref:System.Text.EncodingProvider)</ept> topic.</source>
          <target state="translated">Подробнее см. в разделе <bpt id="p1">[</bpt>EncodingProvider<ept id="p1">](xref:System.Text.EncodingProvider)</ept>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Selecting an Encoding class</source>
          <target state="translated">Выбор класса кодировки</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If you have the opportunity to choose the encoding to be used by your application, you should use a Unicode encoding, preferably either <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> or <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>.</source>
          <target state="translated">Если у вас есть возможность выбрать кодировку для использования в приложении, следует использовать Юникод, предпочтительно <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> или <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>(.NET also supports a third Unicode encoding, <bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept>.)</source>
          <target state="translated">(Платформа .NET также поддерживает третью кодировку — Юникод <bpt id="p1">[</bpt>UTF32Encoding<ept id="p1">](xref:System.Text.UTF32Encoding)</ept>.)</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If you are planning to use an ASCII encoding (<bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>), choose <bpt id="p2">[</bpt>UTF8Encoding<ept id="p2">](xref:System.Text.UTF8Encoding)</ept> instead.</source>
          <target state="translated">Если вы планируете использовать кодировку ASCII (<bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>), выберите вместо нее <bpt id="p2">[</bpt>UTF8Encoding<ept id="p2">](xref:System.Text.UTF8Encoding)</ept>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The two encodings are identical for the ASCII character set, but <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> has the following advantages:</source>
          <target state="translated">Эти две кодировки идентичны для набора символов ASCII, но <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> имеет указанные ниже преимущества.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>It can represent every Unicode character, whereas <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> supports only the Unicode character values between U+0000 and U+007F.</source>
          <target state="translated">Она может представлять любой символ Юникода, тогда как <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> поддерживает только символы Юникода в диапазоне от U+0000 до U+007F.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>It provides error detection and better security.</source>
          <target state="translated">Она обеспечивает обнаружение ошибок и более высокий уровень безопасности.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>It has been tuned to be as fast as possible and should be faster than any other encoding.</source>
          <target state="translated">Она настроена для максимально быстрой работы и должна быть быстрее любых других кодировок.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Even for content that is entirely ASCII, operations performed with <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> are faster than operations performed with <bpt id="p2">[</bpt>ASCIIEncoding<ept id="p2">](xref:System.Text.ASCIIEncoding)</ept>.</source>
          <target state="translated">Даже для содержимого, имеющего только формат ASCII, выполнение операций с помощью <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> происходит быстрее, чем с помощью <bpt id="p2">[</bpt>ASCIIEncoding<ept id="p2">](xref:System.Text.ASCIIEncoding)</ept>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>You should consider using <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> only for legacy applications.</source>
          <target state="translated">Кодировку <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> рекомендуется использовать только для приложений прежних версий.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>However, even for legacy applications, <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> might be a better choice for the following reasons (assuming default settings):</source>
          <target state="translated">Однако даже для приложений прежних версий <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> может быть предпочтительнее по указанным ниже причинам (при параметрах по умолчанию).</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If your application has content that is not strictly ASCII and encodes it with <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>, each non-ASCII character encodes as a question mark (?).</source>
          <target state="translated">Если содержимое приложения включает символы не только в формате ASCII, при кодировании с помощью <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> каждый символ, не относящийся к ASCII, кодируется как знак вопроса (?).</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If the application then decodes this data, the information is lost.</source>
          <target state="translated">При последующем декодировании эти данные утрачиваются.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If your application has content that is not strictly ASCII and encodes it with <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>, the result seems unintelligible if interpreted as ASCII.</source>
          <target state="translated">Если содержимое приложения включает символы не только в формате ASCII, при кодировании с помощью <bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept> представление символов в формате ASCII дает непригодный для чтения результат.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>However, if the application then uses a UTF-8 decoder to decode this data, the data performs a round trip successfully.</source>
          <target state="translated">Однако при последующем декодировании данных с помощью декодера UTF-8 обработка данных выполняется успешно.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In a web application, characters sent to the client in response to a web request should reflect the encoding used on the client.</source>
          <target state="translated">В веб-приложении символы, отправленные клиенту в ответ на веб-запрос, должны отражать кодировку, используемую в клиенте.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In most cases, you should set the <bpt id="p1">[</bpt>HttpResponse.ContentEncoding<ept id="p1">](xref:System.Net.HttpResponseHeader.ContentEncoding)</ept> property to the value returned by the <bpt id="p2">[</bpt>HttpRequestHeader.ContentEncoding<ept id="p2">](xref:System.Net.HttpRequestHeader.ContentEncoding)</ept> property to display text in the encoding that the user expects.</source>
          <target state="translated">Как правило, требуется задать для свойства <bpt id="p1">[</bpt>HttpResponse.ContentEncoding<ept id="p1">](xref:System.Net.HttpResponseHeader.ContentEncoding)</ept> значение, возвращаемое свойством <bpt id="p2">[</bpt>HttpRequestHeader.ContentEncoding<ept id="p2">](xref:System.Net.HttpRequestHeader.ContentEncoding)</ept>, для отображения текста в той кодировке, которую ожидает пользователь.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Using an encoding object</source>
          <target state="translated">Использование объекта кодировки</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>An encoder converts a string of characters (most commonly, Unicode characters) to its numeric (byte) equivalent.</source>
          <target state="translated">Кодировщик преобразует строку символов (чаще всего символов Юникода) в их числовой (байтовый) эквивалент.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For example, you might use an ASCII encoder to convert Unicode characters to ASCII so that they can be displayed at the console.</source>
          <target state="translated">Например, кодировщик ASCII можно использовать для преобразования символов Юникода в ASCII, чтобы они могли отображаться на консоли.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>To perform the conversion, you call the <bpt id="p1">[</bpt>Encoding.GetBytes<ept id="p1">](xref:System.Text.Encoding.GetBytes(System.Char[]))</ept> method.</source>
          <target state="translated">Чтобы выполнить преобразование, вызовите метод <bpt id="p1">[</bpt>Encoding.GetBytes<ept id="p1">](xref:System.Text.Encoding.GetBytes(System.Char[]))</ept>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>If you want to determine how many bytes are needed to store the encoded characters before performing the encoding, you can call the <bpt id="p1">[</bpt>GetByteCount<ept id="p1">](xref:System.Text.Encoding.GetByteCount(System.Char[]))</ept> method.</source>
          <target state="translated">Если перед выполнением кодирования нужно определить, сколько байтов потребуется для хранения закодированных символов, можно вызвать метод <bpt id="p1">[</bpt>GetByteCount<ept id="p1">](xref:System.Text.Encoding.GetByteCount(System.Char[]))</ept>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following example uses a single byte array to encode strings in two separate operations.</source>
          <target state="translated">В примере ниже один массив байтов используется для кодирования строк в двух отдельных операциях.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It maintains an index that indicates the starting position in the byte array for the next set of ASCII-encoded bytes.</source>
          <target state="translated">Имеется индекс, указывающий начальную позицию в массиве байтов для следующего набора байтов, закодированных с использованием ASCII.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It calls the <bpt id="p1">[</bpt>ASCIIEncoding.GetByteCount(String)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetByteCount(System.String))</ept> method to ensure that the byte array is large enough to accommodate the encoded string.</source>
          <target state="translated">Вызывается метод <bpt id="p1">[</bpt>ASCIIEncoding.GetByteCount(String)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetByteCount(System.String))</ept> для проверки того, что массив байтов достаточно велик для хранения закодированной строки.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>It then calls the <bpt id="p1">[</bpt>ASCIIEncoding.GetBytes(String, Int32, Int32, Byte[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32))</ept> method to encode the characters in the string.</source>
          <target state="translated">Затем вызывается метод <bpt id="p1">[</bpt>ASCIIEncoding.GetBytes(String, Int32, Int32, Byte[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32))</ept> для кодирования символов в строке.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>A decoder converts a byte array that reflects a particular character encoding into a set of characters, either in a character array or in a string.</source>
          <target state="translated">Декодер преобразует массив байтов, отражающий конкретную кодировку символов, в набор символов в массиве символов или в строке.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>To decode a byte array into a character array, you call the <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> method.</source>
          <target state="translated">Чтобы декодировать массив байтов в массив символов, вызовите метод <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>To decode a byte array into a string, you call the <bpt id="p1">[</bpt>GetString<ept id="p1">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept> method.</source>
          <target state="translated">Чтобы декодировать массив байтов в строку, вызовите метод <bpt id="p1">[</bpt>GetString<ept id="p1">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If you want to determine how many characters are needed to store the decoded bytes before performing the decoding, you can call the <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> method.</source>
          <target state="translated">Если перед декодированием нужно определить, сколько символов требуется для хранения раскодированных байтов, можно вызвать метод <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The following example encodes three strings and then decodes them into a single array of characters.</source>
          <target state="translated">В примере ниже три строки кодируются, а затем декодируются в один массив символов.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>It maintains an index that indicates the starting position in the character array for the next set of decoded characters.</source>
          <target state="translated">Имеется индекс, указывающий начальную позицию в массиве символов для следующего набора декодированных символов.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>It calls the <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> method to ensure that the character array is large enough to accommodate all the decoded characters.</source>
          <target state="translated">Вызывается метод <bpt id="p1">[</bpt>GetCharCount<ept id="p1">](xref:System.Text.Encoding.GetCharCount(System.Byte[]))</ept> для проверки того, что массив символов достаточно велик для хранения всех декодированных символов.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>It then calls the <bpt id="p1">[</bpt>ASCIIEncoding.GetChars(Byte[], Int32, Int32, Char[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> method to decode the byte array.</source>
          <target state="translated">Затем вызывается метод <bpt id="p1">[</bpt>ASCIIEncoding.GetChars(Byte[], Int32, Int32, Char[], Int32)<ept id="p1">](xref:System.Text.ASCIIEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> для декодирования массива байтов.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The encoding and decoding methods of a class derived from <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> are designed to work on a complete set of data; that is, all the data to be encoded or decoded is supplied in a single method call.</source>
          <target state="translated">Методы кодирования и декодирования класса, производного от класса <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept>, предназначены для работы с полным набором данных. Это значит, что все данные, подлежащие кодированию или декодированию, предоставляются в одном вызове метода.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>However, in some cases, data is available in a stream, and the data to be encoded or decoded may be available only from separate read operations.</source>
          <target state="translated">Однако в некоторых случаях данные предоставляются в потоке, тогда данные для кодирования и декодирования можно получить только с помощью нескольких операций чтения.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>This requires the encoding or decoding operation to remember any saved state from its previous invocation.</source>
          <target state="translated">В таком случае необходимо, чтобы операция кодирования или декодирования "помнила" сохраненное после предыдущего вызова состояние.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Methods of classes derived from <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> and <bpt id="p2">[</bpt>Decoder<ept id="p2">](xref:System.Text.Decoder)</ept> are able to handle encoding and decoding operations that span multiple method calls.</source>
          <target state="translated">Методы классов, производных от <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> и <bpt id="p2">[</bpt>Decoder<ept id="p2">](xref:System.Text.Decoder)</ept>, могут обрабатывать операции кодирования и декодирования, охватывающие несколько вызовов методов.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> object for a particular encoding is available from that encoding's <bpt id="p2">[</bpt>Encoding.GetEncoder<ept id="p2">](xref:System.Text.Encoding.GetEncoder)</ept> property.</source>
          <target state="translated">Объект <bpt id="p1">[</bpt>Encoder<ept id="p1">](xref:System.Text.Encoder)</ept> для конкретной кодировки доступен в ее свойстве <bpt id="p2">[</bpt>Encoding.GetEncoder<ept id="p2">](xref:System.Text.Encoding.GetEncoder)</ept>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> object for a particular encoding is available from that encoding's <bpt id="p2">[</bpt>Encoding.GetDecoder<ept id="p2">](xref:System.Text.Encoding.GetDecoder)</ept> property.</source>
          <target state="translated">Объект <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> для конкретной кодировки доступен в ее свойстве <bpt id="p2">[</bpt>Encoding.GetDecoder<ept id="p2">](xref:System.Text.Encoding.GetDecoder)</ept>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For decoding operations, note that classes derived from <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept> include a <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> method, but they do not have a method that corresponds to <bpt id="p3">[</bpt>Encoding.GetString<ept id="p3">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept>.</source>
          <target state="translated">Что касается операций декодирования, обратите внимание, что классы, производные от <bpt id="p1">[</bpt>Decoder<ept id="p1">](xref:System.Text.Decoder)</ept>, включают метод <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept>, но не имеют метода, соответствующего <bpt id="p3">[</bpt>Encoding.GetString<ept id="p3">](xref:System.Text.Encoding.GetString(System.Byte[]))</ept>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between using the <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> and <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> methods for decoding a Unicode byte array.</source>
          <target state="translated">В примере ниже показано различие между использованием методов <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> и <bpt id="p2">[</bpt>Decoder.GetChars<ept id="p2">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> для декодирования массива байтов Юникода.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The example encodes a string that contains some Unicode characters to a file, and then uses the two decoding methods to decode them ten bytes at a time.</source>
          <target state="translated">В этом примере строка, содержащая несколько символов Юникода, кодируется в файл, а затем два метода декодирования используются для декодирования по десять байтов за раз.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Because a surrogate pair occurs in the tenth and eleventh bytes, it is decoded in separate method calls.</source>
          <target state="translated">Так как замещающая пара оказывается в десятом и одиннадцатом байтах, она декодируется в отдельных вызовах метода.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>As the output shows, the <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> method is not able to correctly decode the bytes and instead replaces them with U+FFFD (REPLACEMENT CHARACTER).</source>
          <target state="translated">Как видно из выходных данных, метод <bpt id="p1">[</bpt>Encoding.GetChars<ept id="p1">](xref:System.Text.Encoding.GetChars(System.Byte[]))</ept> не может правильно декодировать байты и заменяет их символом U+FFFD (замещающим символом).</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>On the other hand, the <bpt id="p1">[</bpt>Decoder.GetChars<ept id="p1">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> method is able to successfully decode the byte array to get the original string.</source>
          <target state="translated">С другой стороны, метод <bpt id="p1">[</bpt>Decoder.GetChars<ept id="p1">](xref:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32))</ept> может успешно декодировать массив байтов для получения исходной строки.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Choosing a fallback strategy</source>
          <target state="translated">Выбор резервной стратегии</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>When a method tries to encode or decode a character but no mapping exists, it must implement a fallback strategy that determines how the failed mapping should be handled.</source>
          <target state="translated">Когда метод пытается закодировать или декодировать символ, но не находит сопоставления, он должен использовать резервную стратегию, определяющую, как должно обрабатываться отсутствие сопоставления.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>There are three types of fallback strategies:</source>
          <target state="translated">Существует три типа резервных стратегий:</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Best-fit fallback</source>
          <target state="translated">стратегия наилучшего соответствия;</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Replacement fallback</source>
          <target state="translated">стратегия замены;</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Exception fallback</source>
          <target state="translated">стратегия исключения.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The most common problems in encoding operations occur when a Unicode character cannot be mapped to a particular code page encoding.</source>
          <target state="translated">При операциях кодирования наиболее часто проблемы возникают, когда символ Юникода не удается сопоставить с определенной кодировкой кодовой страницы.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The most common problems in decoding operations occur when invalid byte sequences cannot be translated into valid Unicode characters.</source>
          <target state="translated">При операциях декодирования наиболее часто проблемы возникают, когда недопустимую последовательность байтов не удается преобразовать в допустимые символы Юникода.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>For these reasons, you should know which fallback strategy a particular encoding object uses.</source>
          <target state="translated">Поэтому необходимо знать, какую резервную стратегию использует определенный объект кодировки.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should specify the fallback strategy used by an encoding object when you instantiate the object.</source>
          <target state="translated">По возможности при создании экземпляра объекта следует указывать резервную стратегию, используемую объектом кодировки.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Best-fit fallback</source>
          <target state="translated">стратегия наилучшего соответствия;</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>When a character does not have an exact match in the target encoding, the encoder can try to map it to a similar character.</source>
          <target state="translated">Если символ не имеет точного соответствия в целевой кодировке, кодировщик может попытаться сопоставить его с похожим символом.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>(Best-fit fallback is mostly an encoding rather than a decoding issue.</source>
          <target state="translated">(Стратегия наилучшего соответствия связана с проблемами, возникающими скорее при кодировании, чем при декодировании.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>There are very few code pages that contain characters that cannot be successfully mapped to Unicode.) Best-fit fallback is the default for code page and double-byte character set encodings that are retrieved by the <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> and <bpt id="p2">[</bpt>Encoding.GetEncoding(String)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.String))</ept> overloads.</source>
          <target state="translated">Существует лишь небольшое число кодовых страниц, символы которых нельзя сопоставить с Юникодом.) Стратегия наилучшего соответствия является стратегией по умолчанию для кодовых страниц и двухбайтовых кодировок, извлекаемых перегрузками <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> и <bpt id="p2">[</bpt>Encoding.GetEncoding(String)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.String))</ept>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>In theory, the Unicode encoding classes provided in .NET (<bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>, <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept>, and <bpt id="p3">[</bpt>UTF32Encoding<ept id="p3">](xref:System.Text.UTF32Encoding)</ept>) support every character in every character set, so they can be used to eliminate best-fit fallback issues.</source>
          <target state="translated">Теоретически классы кодировок Юникода, доступные в .NET (<bpt id="p1">[</bpt>UTF8Encoding<ept id="p1">](xref:System.Text.UTF8Encoding)</ept>, <bpt id="p2">[</bpt>UnicodeEncoding<ept id="p2">](xref:System.Text.UnicodeEncoding)</ept> и <bpt id="p3">[</bpt>UTF32Encoding<ept id="p3">](xref:System.Text.UTF32Encoding)</ept>), поддерживают все символы всех наборов символов, поэтому их можно использовать, чтобы избежать проблем со стратегией наилучшего соответствия.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Best-fit strategies vary for different code pages, and they are not documented in detail.</source>
          <target state="translated">Стратегии наилучшего соответствия для разных кодовых страниц различаются. Не все стратегии подробно задокументированы.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>For example, for some code pages, full-width Latin characters map to the more common half-width Latin characters.</source>
          <target state="translated">Например, для некоторых кодовых страниц полноширинные латинские символы сопоставляются с более распространенными полуширинными символами.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>For other code pages, this mapping is not made.</source>
          <target state="translated">Для других кодовых страниц такое сопоставление не выполняется.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Even under an aggressive best-fit strategy, there is no imaginable fit for some characters in some encodings.</source>
          <target state="translated">Даже в случае применения активной стратегии наилучшего соответствия для некоторых символов некоторых кодировок отсутствует возможное сопоставление.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example, a Chinese ideograph has no reasonable mapping to code page 1252.</source>
          <target state="translated">Например, для идеографических символов китайского алфавита отсутствуют корректные сопоставления с символами кодовой страницы 1252.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>In this case, a replacement string is used.</source>
          <target state="translated">В этом случае используются замещающие строки.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>By default, this string is just a single QUESTION MARK (U+003F).</source>
          <target state="translated">По умолчанию в качестве замещающей строки используется знак вопроса (U+003F).</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The following example uses code page 1252 (the Windows code page for Western European languages) to illustrate best-fit mapping and its drawbacks.</source>
          <target state="translated">В примере ниже используется кодовая страница 1252 (кодовая страница Windows для западноевропейских языков) для иллюстрации стратегии наилучшего соответствия и ее недостатков.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> method is used to retrieve an encoding object for code page 1252.</source>
          <target state="translated">Метод <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.Int32))</ept> используется для получения объекта кодировки для кодовой страницы 1252.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>By default, it uses a best-fit mapping for Unicode characters that it does not support.</source>
          <target state="translated">По умолчанию для неподдерживаемых символов Юникода используется стратегия наилучшего соответствия.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The example instantiates a string that contains three non-ASCII characters - CIRCLED LATIN CAPITAL LETTER S (U+24C8), SUPERSCRIPT FIVE (U+2075), and INFINITY (U+221E) - separated by spaces.</source>
          <target state="translated">В примере создается экземпляр строки, содержащий три символа, не относящихся к ASCII (прописная латинская буква S в кружке (U+24C8), надстрочный индекс 5 (U+2075) и знак бесконечности (U+221E)), разделенные пробелами.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, when the string is encoded, the three original non-space characters are replaced by QUESTION MARK (U+003F), DIGIT FIVE (U+0035), and DIGIT EIGHT (U+0038).</source>
          <target state="translated">Как видно из выходных данных примера, при кодировке строки три исходных отличных от пробела символа заменяются вопросительным знаком (U+003F), цифрой пять (U+0035) и цифрой восемь (U+0038).</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>DIGIT EIGHT is a particularly poor replacement for the unsupported INFINITY character, and QUESTION MARK indicates that no mapping was available for the original character.</source>
          <target state="translated">Цифра восемь — особенно неудачная замена неподдерживаемого знака бесконечности, а вопросительный знак показывает, что для исходного символа сопоставление не найдено.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Best-fit mapping is the default behavior for an <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> object that encodes Unicode data into code page data, and there are legacy applications that rely on this behavior.</source>
          <target state="translated">По умолчанию для объекта <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> применяется стратегия наилучшего соответствия, при которой данные в формате Юникод кодируются в формат кодовой страницы. Ряд приложений предыдущих версий построен с учетом этой стратегии.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>However, most new applications should avoid best-fit behavior for security reasons.</source>
          <target state="translated">Однако в целях безопасности в большинстве новых приложений не рекомендуется применять эту стратегию.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For example, applications should not put a domain name through a best-fit encoding.</source>
          <target state="translated">Например, приложениям не следует выполнять кодировку доменного имени в режиме наилучшего соответствия.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>You can also implement a custom best-fit fallback mapping for an encoding.</source>
          <target state="translated">Вы также можете реализовать пользовательскую стратегию наилучшего соответствия для кодировки.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> section.</source>
          <target state="translated">Подробнее см. в разделе <bpt id="p1">[</bpt>Реализация пользовательской резервной стратегии<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>If best-fit fallback is the default for an encoding object, you can choose another fallback strategy when you retrieve an <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> object by calling the <bpt id="p2">[</bpt>Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> or <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> overload.</source>
          <target state="translated">Если стратегия наилучшего соответствия задана по умолчанию для объекта кодировки, вы можете выбрать другую резервную стратегию при извлечении объекта <bpt id="p1">[</bpt>Encoding<ept id="p1">](xref:System.Text.Encoding)</ept> путем вызова перегрузки <bpt id="p2">[</bpt>Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> или <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The following section includes an example that replaces each character that cannot be mapped to code page 1252 with an asterisk (<ph id="ph1">\*</ph>).</source>
          <target state="translated">В следующем разделе приводится пример, где каждый символ, который не удается сопоставить с кодовой страницей 1252, заменяется звездочкой (<ph id="ph1">\*</ph>).</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Replacement fallback</source>
          <target state="translated">стратегия замены;</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>When a character does not have an exact match in the target scheme, but there is no appropriate character that it can be mapped to, the application can specify a replacement character or string.</source>
          <target state="translated">Когда символ не имеет точного соответствия в целевой схеме и нет подходящего символа, с которым его можно сопоставить, приложение может использовать замещающий символ или строку.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>This is the default behavior for the Unicode decoder, which replaces any two-byte sequence that it cannot decode with REPLACEMENT_CHARACTER (U+FFFD).</source>
          <target state="translated">Так по умолчанию поступает декодер Юникода, заменяющий любую двухбайтовую последовательность, которую он не может декодировать, замещающим символом (U+FFFD).</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>It is also the default behavior of the <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept> class, which replaces each character that it cannot encode or decode with a question mark.</source>
          <target state="translated">Кроме того, это поведение по умолчанию класса <bpt id="p1">[</bpt>ASCIIEncoding<ept id="p1">](xref:System.Text.ASCIIEncoding)</ept>, заменяющего каждый символ, который не удается кодировать или декодировать, вопросительным знаком.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The following example illustrates character replacement for the Unicode string from the previous example.</source>
          <target state="translated">В примере ниже показана замена символов для строки Юникода из предыдущего примера.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>As the output shows, each character that cannot be decoded into an ASCII byte value is replaced by 0x3F, which is the ASCII code for a question mark.</source>
          <target state="translated">Как видно из выходных данных, каждый символ, который не удается декодировать в байтовое значение ASCII, заменяется 0x3F, то есть кодом ASCII для вопросительного знака.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>.NET includes the <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> and <bpt id="p2">[</bpt>DecoderReplacementFallback<ept id="p2">](xref:System.Text.DecoderReplacementFallback)</ept> classes, which substitute a replacement string if a character does not map exactly in an encoding or decoding operation.</source>
          <target state="translated">В .NET есть классы <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> и <bpt id="p2">[</bpt>DecoderReplacementFallback<ept id="p2">](xref:System.Text.DecoderReplacementFallback)</ept>, подставляющие замещающую строку, если не удается точно сопоставить символ при кодировании или декодировании.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>By default, this replacement string is a question mark, but you can call a class constructor overload to choose a different string.</source>
          <target state="translated">По умолчанию эта замещающая строка — вопросительный знак, но вы можете вызвать перегрузку конструктора класса, чтобы выбрать другую строку.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Typically, the replacement string is a single character, although this is not a requirement.</source>
          <target state="translated">Как правило, замещающая строка — это отдельный символ, хотя это необязательно.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The following example changes the behavior of the code page 1252 encoder by instantiating an <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> object that uses an asterisk (<ph id="ph1">\*</ph>) as a replacement string.</source>
          <target state="translated">В примере ниже поведение кодировщика кодовой страницы 1252 изменяется путем создания экземпляра объекта <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept>, который использует символ звездочки (<ph id="ph1">\*</ph>) в качестве замещающей строки.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>You can also implement a replacement class for an encoding.</source>
          <target state="translated">Также можно реализовать класс замены для кодировки.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> section.</source>
          <target state="translated">Подробнее см. в разделе <bpt id="p1">[</bpt>Реализация пользовательской резервной стратегии<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>In addition to QUESTION MARK (U+003F), the Unicode REPLACEMENT CHARACTER (U+FFFD) is commonly used as a replacement string, particularly when decoding byte sequences that cannot be successfully translated into Unicode characters.</source>
          <target state="translated">Помимо вопросительного знака (U+003F) в качестве замещающей строки часто используется замещающий символ Юникода (U+FFFD), особенно при декодировании последовательностей байтов, которые не удается преобразовать в символы Юникода.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>However, you are free to choose any replacement string, and it can contain multiple characters.</source>
          <target state="translated">Однако вы можете выбрать любую замещающую строку, в том числе из нескольких символов.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Exception fallback</source>
          <target state="translated">стратегия исключения.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Instead of providing a best-fit fallback or a replacement string, an encoder can throw an <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> if it is unable to encode a set of characters, and a decoder can throw a <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> if it is unable to decode a byte array.</source>
          <target state="translated">Вместо подстановки наиболее подходящей или замещающей строки кодировщик может создавать исключение <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept>, если не удается закодировать набор символов, а декодер — создавать исключение <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept>, если не удается декодировать массив байтов.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>To throw an exception in encoding and decoding operations, you supply an <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> object and a <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> object, respectively, to the <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> method.</source>
          <target state="translated">Для создания исключения в операциях кодирования и декодирования методу <bpt id="p3">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p3">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> необходимо предоставить объект <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> или <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept>, соответственно.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The following example illustrates exception fallback with the ASCIIEncoding class.</source>
          <target state="translated">В примере ниже иллюстрируется резервная стратегия исключения с классом ASCIIEncoding.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>You can also implement a custom exception handler for an encoding operation.</source>
          <target state="translated">Вы также можете реализовать пользовательский обработчик исключений для операции кодирования.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a custom fallback strategy<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept> section.</source>
          <target state="translated">Подробнее см. в разделе <bpt id="p1">[</bpt>Реализация пользовательской резервной стратегии<ept id="p1">](#implementing-a-custom-fallback-strategy)</ept>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> and <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> objects provide the following information about the condition that caused the exception:</source>
          <target state="translated">Объекты <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> и <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> предоставляют следующую информацию о состоянии, вызвавшем исключение.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> object includes an <bpt id="p2">[</bpt>IsUnknownSurrogate<ept id="p2">](xref:System.Text.EncoderFallbackException.IsUnknownSurrogate)</ept> method, which indicates whether the character or characters that cannot be encoded represent an unknown surrogate pair (in which case, the method returns <ph id="ph1">`true`</ph>) or an unknown single character (in which case, the method returns <ph id="ph2">`false`</ph>).</source>
          <target state="translated">Объект <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> включает метод <bpt id="p2">[</bpt>IsUnknownSurrogate<ept id="p2">](xref:System.Text.EncoderFallbackException.IsUnknownSurrogate)</ept>, указывающий, представляют ли символы (или символ), которые не удается закодировать, неизвестную замещающую пару (тогда метод возвращает значение <ph id="ph1">`true`</ph>) или неизвестный отдельный символ (тогда метод возвращает значение <ph id="ph2">`false`</ph>).</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The characters in the surrogate pair are available from the <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknownHigh<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknownHigh)</ept> and <bpt id="p2">[</bpt>EncoderFallbackException.CharUnknownLow<ept id="p2">](xref:System.Text.EncoderFallbackException.CharUnknownLow)</ept> properties.</source>
          <target state="translated">Символы замещающей пары доступны в свойствах <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknownHigh<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknownHigh)</ept> и <bpt id="p2">[</bpt>EncoderFallbackException.CharUnknownLow<ept id="p2">](xref:System.Text.EncoderFallbackException.CharUnknownLow)</ept>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The unknown single character is available from the <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknown<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknown)</ept> property.</source>
          <target state="translated">Неизвестный отдельный символ доступен в свойстве <bpt id="p1">[</bpt>EncoderFallbackException.CharUnknown<ept id="p1">](xref:System.Text.EncoderFallbackException.CharUnknown)</ept>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackException.Index<ept id="p1">](xref:System.Text.EncoderFallbackException.Index)</ept> property indicates the position in the string at which the first character that could not be encoded was found.</source>
          <target state="translated">Свойство <bpt id="p1">[</bpt>EncoderFallbackException.Index<ept id="p1">](xref:System.Text.EncoderFallbackException.Index)</ept> указывает позицию первого символа, который не удалось закодировать, в строке.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>DecoderFallbackException<ept id="p1">](xref:System.Text.DecoderFallbackException)</ept> object includes a <bpt id="p2">[</bpt>BytesUnknown<ept id="p2">](xref:System.Text.DecoderFallbackException.BytesUnknown)</ept> property that returns an array of bytes that cannot be decoded.</source>
          <target state="translated">Объект <bpt id="p1">[</bpt>DecoderFallbackException<ept id="p1">](xref:System.Text.DecoderFallbackException)</ept> включает свойство <bpt id="p2">[</bpt>BytesUnknown<ept id="p2">](xref:System.Text.DecoderFallbackException.BytesUnknown)</ept>, возвращающее массив байтов, которые не удается декодировать.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>DecoderFallbackException.Index<ept id="p1">](xref:System.Text.DecoderFallbackException.Index)</ept> property indicates the starting position of the unknown bytes.</source>
          <target state="translated">Свойство <bpt id="p1">[</bpt>DecoderFallbackException.Index<ept id="p1">](xref:System.Text.DecoderFallbackException.Index)</ept> указывает начальную позицию неизвестных байтов.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Although the <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> and <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> objects provide adequate diagnostic information about the exception, they do not provide access to the encoding or decoding buffer.</source>
          <target state="translated">Несмотря на то, что объекты <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> и <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> предоставляют достаточно подробную диагностическую информацию об исключении, они не предоставляют доступ к буферу кодирования или декодирования.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Therefore, they do not allow invalid data to be replaced or corrected within the encoding or decoding method.</source>
          <target state="translated">Поэтому они не позволяют заменять или исправлять недопустимые данные в методе кодирования или декодирования.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Implementing a custom fallback strategy</source>
          <target state="translated">Реализация пользовательской резервной стратегии</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>In addition to the best-fit mapping that is implemented internally by code pages, .NET includes the following classes for implementing a fallback strategy:</source>
          <target state="translated">Помимо встроенной стратегии наилучшего соответствия, реализованной кодовыми страницами, платформа .NET содержит следующие классы для реализации резервной стратегии:</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> and <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> to replace characters in encoding operations.</source>
          <target state="translated">классы <bpt id="p1">[</bpt>EncoderReplacementFallback<ept id="p1">](xref:System.Text.EncoderReplacementFallback)</ept> и <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> можно использовать для замены символов в операциях кодирования;</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>DecoderReplacementFallback<ept id="p1">](xref:System.Text.DecoderReplacementFallback)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> to replace characters in decoding operations.</source>
          <target state="translated">классы <bpt id="p1">[</bpt>DecoderReplacementFallback<ept id="p1">](xref:System.Text.DecoderReplacementFallback)</ept> и <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> можно использовать для замены символов в операциях декодирования;</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>EncoderExceptionFallback<ept id="p1">](xref:System.Text.EncoderExceptionFallback)</ept> and <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> to throw an <bpt id="p3">[</bpt>EncoderFallbackException<ept id="p3">](xref:System.Text.EncoderFallbackException)</ept> when a character cannot be encoded.</source>
          <target state="translated">классы <bpt id="p1">[</bpt>EncoderExceptionFallback<ept id="p1">](xref:System.Text.EncoderExceptionFallback)</ept> и <bpt id="p2">[</bpt>EncoderFallbackBuffer<ept id="p2">](xref:System.Text.EncoderFallbackBuffer)</ept> можно использовать для создания исключения <bpt id="p3">[</bpt>EncoderFallbackException<ept id="p3">](xref:System.Text.EncoderFallbackException)</ept>, когда символ не удается закодировать;</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>DecoderExceptionFallback<ept id="p1">](xref:System.Text.DecoderExceptionFallback)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> to throw a <bpt id="p3">[</bpt>DecoderFallbackException<ept id="p3">](xref:System.Text.DecoderFallbackException)</ept> when a character cannot be decoded.</source>
          <target state="translated">классы <bpt id="p1">[</bpt>DecoderExceptionFallback<ept id="p1">](xref:System.Text.DecoderExceptionFallback)</ept> и <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> можно использовать для создания исключения <bpt id="p3">[</bpt>DecoderFallbackException<ept id="p3">](xref:System.Text.DecoderFallbackException)</ept>, когда символ не удается декодировать.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>In addition, you can implement a custom solution that uses best-fit fallback, replacement fallback, or exception fallback, by following these steps:</source>
          <target state="translated">Кроме того, можно реализовать пользовательское решение, использующее резервную стратегию наилучшего соответствия или стратегию исключения, выполнив указанные ниже действия.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Derive a class from <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> for decoding operations.</source>
          <target state="translated">Создайте класс, производный от <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept>, для операций кодирования и класс, производный от <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept>, для операций декодирования.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Derive a class from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> for decoding operations.</source>
          <target state="translated">Создайте класс, производный от <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>, для операций кодирования и класс, производный от <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept>, для операций декодирования.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>For exception fallback, if the predefined <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> and <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> classes do not meet your needs, derive a class from an exception object such as <bpt id="p3">[</bpt>Exception<ept id="p3">](xref:System.Exception)</ept> or <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept>.</source>
          <target state="translated">Для задания резервной стратегии исключения, если классы <bpt id="p1">[</bpt>EncoderFallbackException<ept id="p1">](xref:System.Text.EncoderFallbackException)</ept> и <bpt id="p2">[</bpt>DecoderFallbackException<ept id="p2">](xref:System.Text.DecoderFallbackException)</ept> не отвечают вашим требованиям, следует наследовать класс от объекта исключения, например <bpt id="p3">[</bpt>Exception<ept id="p3">](xref:System.Exception)</ept> или <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Deriving from EncoderFallback or DecoderFallback</source>
          <target state="translated">Наследование от класса EncoderFallback или класса DecoderFallback</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>To implement a custom fallback solution, you must create a class that inherits from <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> for decoding operations.</source>
          <target state="translated">Для реализации пользовательской резервной стратегии необходимо создать класс, наследующий от <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> для операций кодирования и от класса <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> для операций декодирования.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Instances of these classes are passed to the <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> method and serve as the intermediary between the encoding class and the fallback implementation.</source>
          <target state="translated">Экземпляры этих классов передаются в метод <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> и служат посредниками между классом кодировки и реализацией резервной стратегии.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>When you create a custom fallback solution for an encoder or decoder, you must implement the following members:</source>
          <target state="translated">При создании пользовательской резервной стратегии для кодировщика или декодера необходимо реализовать следующие члены:</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallback.MaxCharCount<ept id="p1">](xref:System.Text.EncoderFallback.MaxCharCount)</ept> or <bpt id="p2">[</bpt>DecoderFallback.MaxCharCount<ept id="p2">](xref:System.Text.DecoderFallback.MaxCharCount)</ept> property, which returns the maximum possible number of characters that the best-fit, replacement, or exception fallback can return to replace a single character.</source>
          <target state="translated">Свойство <bpt id="p1">[</bpt>EncoderFallback.MaxCharCount<ept id="p1">](xref:System.Text.EncoderFallback.MaxCharCount)</ept> или <bpt id="p2">[</bpt>DecoderFallback.MaxCharCount<ept id="p2">](xref:System.Text.DecoderFallback.MaxCharCount)</ept>, возвращающее максимально возможное число символов, которое может использоваться для замены одного символа в стратегиях наилучшего соответствия, замены или исключения.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>For a custom exception fallback, its value is zero.</source>
          <target state="translated">Для пользовательской резервной стратегии исключения его значение равно нулю.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> or <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> method, which returns your custom <bpt id="p3">[</bpt>EncoderFallbackBuffer<ept id="p3">](xref:System.Text.EncoderFallbackBuffer)</ept> or <bpt id="p4">[</bpt>DecoderFallbackBuffer<ept id="p4">](xref:System.Text.DecoderFallbackBuffer)</ept> implementation.</source>
          <target state="translated">Метод <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> или <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept>, возвращающий пользовательскую реализацию <bpt id="p3">[</bpt>EncoderFallbackBuffer<ept id="p3">](xref:System.Text.EncoderFallbackBuffer)</ept> или <bpt id="p4">[</bpt>DecoderFallbackBuffer<ept id="p4">](xref:System.Text.DecoderFallbackBuffer)</ept>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The method is called by the encoder when it encounters the first character that it is unable to successfully encode, or by the decoder when it encounters the first byte that it is unable to successfully decode.</source>
          <target state="translated">Метод вызывается кодировщиком, когда он встречает первый символ, который не удается закодировать, или декодером, когда он встречает первый байт, который не удается декодировать.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Deriving from EncoderFallbackBuffer or DecoderFallbackBuffer</source>
          <target state="translated">Наследование от класса EncoderFallbackBuffer или класса DecoderFallbackBuffer</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>To implement a custom fallback solution, you must also create a class that inherits from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> for encoding operations, and from <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> for decoding operations.</source>
          <target state="translated">Для реализации пользовательской резервной стратегии необходимо также создать класс, наследующий от <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> для операций кодирования и от класса <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> для операций декодирования.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Instances of these classes are returned by the <ph id="ph1">`CreateFallbackBuffer`</ph> method of the <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> and <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept> classes.</source>
          <target state="translated">Экземпляры этих классов возвращаются методом <ph id="ph1">`CreateFallbackBuffer`</ph> классов <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> и <bpt id="p2">[</bpt>DecoderFallback<ept id="p2">](xref:System.Text.DecoderFallback)</ept>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> method is called by the encoder when it encounters the first character that it is not able to encode, and the <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> method is called by the decoder when it encounters one or more bytes that it is not able to decode.</source>
          <target state="translated">Метод <bpt id="p1">[</bpt>EncoderFallback.CreateFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallback.CreateFallbackBuffer)</ept> вызывается кодировщиком, когда он встречает первый символ, который не удается закодировать, а метод <bpt id="p2">[</bpt>DecoderFallback.CreateFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallback.CreateFallbackBuffer)</ept> вызывается декодером, когда он встречает один или несколько байтов, которые не удается декодировать.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> classes provide the fallback implementation.</source>
          <target state="translated">Классы <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> и <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> предоставляют реализацию резервной стратегии.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Each instance represents a buffer that contains the fallback characters that will replace the character that cannot be encoded or the byte sequence that cannot be decoded.</source>
          <target state="translated">Каждый экземпляр представляет буфер, содержащий символы резервной стратегии, которые заменят символ, который не удалось закодировать, или последовательность байтов, которую не удалось декодировать.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>When you create a custom fallback solution for an encoder or decoder, you must implement the following members:</source>
          <target state="translated">При создании пользовательской резервной стратегии для кодировщика или декодера необходимо реализовать следующие члены:</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.%23ctor)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> method.</source>
          <target state="translated">Метод <bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.%23ctor)</ept> или <bpt id="p2">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Char,System.Int32))</ept> is called by the encoder to provide the fallback buffer with information about the character that it cannot encode.</source>
          <target state="translated">Метод <bpt id="p1">[</bpt>EncoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Char,System.Int32))</ept> вызывается кодировщиком, чтобы предоставить резервный буфер со сведениями о символе, который не удается кодировать.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Because the character to be encoded may be a surrogate pair, this method is overloaded.</source>
          <target state="translated">Так как символ, который требуется закодировать, может быть замещающей парой, этот метод перегружается.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>One overload is passed the character to be encoded and its index in the string.</source>
          <target state="translated">Одной перегрузке передается символ, который нужно закодировать, и его индекс в строке.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The second overload is passed the high and low surrogate along with its index in the string.</source>
          <target state="translated">Второй перегрузке передаются верхний и нижний замещающий знаки и их индекс в строке.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> method is called by the decoder to provide the fallback buffer with information about the bytes that it cannot decode.</source>
          <target state="translated">Метод <bpt id="p1">[</bpt>DecoderFallbackBuffer.Fallback<ept id="p1">](xref:System.Text.DecoderFallbackBuffer.Fallback(System.Byte[],System.Int32))</ept> вызывается декодером, чтобы предоставить резервный буфер со сведениями о байтах, которые не удается декодировать.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>This method is passed an array of bytes that it cannot decode, along with the index of the first byte.</source>
          <target state="translated">Этому методу передается массив байтов, которые не удалось декодировать, а также индекс первого байта.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The fallback method should return <ph id="ph1">`true`</ph> if the fallback buffer can supply a best-fit or replacement character or characters; otherwise, it should return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Метод резервной стратегии должен возвращать значение <ph id="ph1">`true`</ph>, если резервный буфер может предоставить наилучшим образом соответствующий или замещающий символ (или символы); в противном случае он должен возвращать значение <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>For an exception fallback, the fallback method should throw an exception.</source>
          <target state="translated">При использовании стратегии исключения метод резервной стратегии должен создавать исключение.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.GetNextChar<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.GetNextChar)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.GetNextChar<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.GetNextChar)</ept> method, which is called repeatedly by the encoder or decoder to get the next character from the fallback buffer.</source>
          <target state="translated">Метод <bpt id="p1">[</bpt>EncoderFallbackBuffer.GetNextChar<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.GetNextChar)</ept> или <bpt id="p2">[</bpt>DecoderFallbackBuffer.GetNextChar<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.GetNextChar)</ept>, который вызывается кодировщиком или декодером многократно для получения следующего символа из резервного буфера.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>When all fallback characters have been returned, the method should return U+0000.</source>
          <target state="translated">После возврата всех резервных символов метод должен вернуть символ U+0000.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.Remaining<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Remaining)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.Remaining<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Remaining)</ept> property, which returns the number of characters remaining in the fallback buffer.</source>
          <target state="translated">Свойство <bpt id="p1">[</bpt>EncoderFallbackBuffer.Remaining<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Remaining)</ept> или <bpt id="p2">[</bpt>DecoderFallbackBuffer.Remaining<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Remaining)</ept>, которое возвращает количество символов, оставшихся в резервном буфере.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.MovePrevious<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.MovePrevious)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.MovePrevious<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.MovePrevious)</ept> method, which moves the current position in the fallback buffer to the previous character.</source>
          <target state="translated">Метод <bpt id="p1">[</bpt>EncoderFallbackBuffer.MovePrevious<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.MovePrevious)</ept> или <bpt id="p2">[</bpt>DecoderFallbackBuffer.MovePrevious<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.MovePrevious)</ept>, который перемещает текущую позицию в резервном буфере к предыдущему символу.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EncoderFallbackBuffer.Reset<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Reset)</ept> or <bpt id="p2">[</bpt>DecoderFallbackBuffer.Reset<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Reset)</ept> method, which reinitializes the fallback buffer.</source>
          <target state="translated">Метод <bpt id="p1">[</bpt>EncoderFallbackBuffer.Reset<ept id="p1">](xref:System.Text.EncoderFallbackBuffer.Reset)</ept> или <bpt id="p2">[</bpt>DecoderFallbackBuffer.Reset<ept id="p2">](xref:System.Text.DecoderFallbackBuffer.Reset)</ept>, повторно инициализирующий резервный буфер.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>If the fallback implementation is a best-fit fallback or a replacement fallback, the classes derived from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> and <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept> also maintain two private instance fields: the exact number of characters in the buffer; and the index of the next character in the buffer to return.</source>
          <target state="translated">Если реализована резервная стратегия наилучшего соответствия или замены, классы, унаследованные от <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> и <bpt id="p2">[</bpt>DecoderFallbackBuffer<ept id="p2">](xref:System.Text.DecoderFallbackBuffer)</ept>, также имеют два закрытых поля экземпляра: точное число символов в буфере и индекс в буфере следующего символа, который нужно вернуть.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>An EncoderFallback example</source>
          <target state="translated">Пример EncoderFallback</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>An earlier example used replacement fallback to replace Unicode characters that did not correspond to ASCII characters with an asterisk (<ph id="ph1">\*</ph>).</source>
          <target state="translated">В примере выше использовалась стратегия замены символов Юникода, не соответствующих символам ASCII, звездочкой (<ph id="ph1">\*</ph>).</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The following example uses a custom best-fit fallback implementation instead to provide a better mapping of non-ASCII characters.</source>
          <target state="translated">В примере ниже используется пользовательская резервная стратегия наилучшего соответствия для получения более удачного сопоставления символов, отсутствующих в ASCII.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The following code defines a class named <ph id="ph1">`CustomMapper`</ph> that is derived from <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept> to handle the best-fit mapping of non-ASCII characters.</source>
          <target state="translated">В приведенном коде определяется класс с именем <ph id="ph1">`CustomMapper`</ph>, производный от <bpt id="p1">[</bpt>EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept>, для обработки наилучшего сопоставления символов, отсутствующих в ASCII.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`CreateFallbackBuffer`</ph> method returns a <ph id="ph2">`CustomMapperFallbackBuffer`</ph> object, which provides the <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept> implementation.</source>
          <target state="translated">Его метод <ph id="ph1">`CreateFallbackBuffer`</ph> возвращает объект <ph id="ph2">`CustomMapperFallbackBuffer`</ph>, предоставляющий реализацию <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CustomMapper`</ph> class uses a <bpt id="p1">[</bpt>Dictionary<ph id="ph2">&amp;lt;</ph>TKey, TValue<ph id="ph3">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.Dictionary%602)</ept> object to store the mappings of unsupported Unicode characters (the key value) and their corresponding 8-bit characters (which are stored in two consecutive bytes in a 64-bit integer).</source>
          <target state="translated">Класс <ph id="ph1">`CustomMapper`</ph> использует объект <bpt id="p1">[</bpt>Dictionary<ph id="ph2">&amp;lt;</ph>TKey, TValue<ph id="ph3">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.Dictionary%602)</ept> для хранения сопоставлений неподдерживаемых символов Юникода (значение ключа) и соответствующих им 8-битных символов (которые хранятся в двух последовательных байтах в виде 64-разрядного целого числа).</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>To make this mapping available to the fallback buffer, the <ph id="ph1">`CustomMapper`</ph> instance is passed as a parameter to the <ph id="ph2">`CustomMapperFallbackBuffer`</ph> class constructor.</source>
          <target state="translated">Чтобы это сопоставление было доступно резервному буферу, экземпляр <ph id="ph1">`CustomMapper`</ph> передается в качестве параметра конструктору класса <ph id="ph2">`CustomMapperFallbackBuffer`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Because the longest mapping is the string "INF" for the Unicode character U+221E, the <ph id="ph1">`MaxCharCount`</ph> property returns 3.</source>
          <target state="translated">Так как самое длинное сопоставление — это строка INF для символа Юникода с кодом U+221E, свойство <ph id="ph1">`MaxCharCount`</ph> возвращает значение 3.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The following code defines the <ph id="ph1">`CustomMapperFallbackBuffer`</ph> class, which is derived from <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>.</source>
          <target state="translated">В примере кода ниже определяется класс <ph id="ph1">`CustomMapperFallbackBuffer`</ph>, производный от <bpt id="p1">[</bpt>EncoderFallbackBuffer<ept id="p1">](xref:System.Text.EncoderFallbackBuffer)</ept>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The dictionary that contains best-fit mappings and that is defined in the <ph id="ph1">`CustomMapper`</ph> instance is available from its class constructor.</source>
          <target state="translated">Словарь, содержащий сопоставления наилучшего соответствия и определенный в экземпляре класса <ph id="ph1">`CustomMapper`</ph>, доступен из конструктора класса.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`Fallback`</ph> method returns <ph id="ph2">`true`</ph> if any of the Unicode characters that the ASCII encoder cannot encode are defined in the mapping dictionary; otherwise, it returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Его метод <ph id="ph1">`Fallback`</ph> возвращает значение <ph id="ph2">`true`</ph>, если какие-либо символы Юникода, которые не удается кодировать кодировщику ASCII, определены в словаре сопоставлений; в противном случае возвращается значение <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>For each fallback, the private <ph id="ph1">`count`</ph> variable indicates the number of characters that remain to be returned, and the private <ph id="ph2">`index`</ph> variable indicates the position in the string buffer, <ph id="ph3">`charsToReturn`</ph>, of the next character to return.</source>
          <target state="translated">Для каждого резервного действия закрытая переменная <ph id="ph1">`count`</ph> указывает число символов, которые осталось вернуть, а закрытая переменная <ph id="ph2">`index`</ph> указывает позицию в буфере строк (значение <ph id="ph3">`charsToReturn`</ph>) следующего символа, который нужно вернуть.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The following code then instantiates the <ph id="ph1">`CustomMapper`</ph> object and passes an instance of it to the <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> method.</source>
          <target state="translated">В приведенном ниже коде создается экземпляр объекта <ph id="ph1">`CustomMapper`</ph>, который передается в метод <bpt id="p1">[</bpt>Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)<ept id="p1">](xref:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The output indicates that the best-fit fallback implementation successfully handles the three non-ASCII characters in the original string.</source>
          <target state="translated">Выходные данные показывают, что реализация стратегии наилучшего соответствия успешно обрабатывает три символа исходной строки, отсутствующие в ASCII.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">См. также</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.Encoder<ept id="p1">](xref:System.Text.Encoder)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.Encoder<ept id="p1">](xref:System.Text.Encoder)</ept></target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.EncoderFallback<ept id="p1">](xref:System.Text.EncoderFallback)</ept></target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.Decoder<ept id="p1">](xref:System.Text.Decoder)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.Decoder<ept id="p1">](xref:System.Text.Decoder)</ept></target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.DecoderFallback<ept id="p1">](xref:System.Text.DecoderFallback)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.DecoderFallback<ept id="p1">](xref:System.Text.DecoderFallback)</ept></target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.Encoding<ept id="p1">](xref:System.Text.Encoding)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>