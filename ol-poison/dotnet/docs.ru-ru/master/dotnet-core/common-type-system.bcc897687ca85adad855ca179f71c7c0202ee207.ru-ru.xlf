<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">35098ce238af88229fddf2adc7cf762848781ebc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\common-type-system.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f66d2394f5af4bc23f5a34be8d74d91b9969f4c7</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">27ebc9a4a8a31450d653e65ed008ffe096e6a0cc</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file common-type-system.bcc897687ca85adad855ca179f71c7c0202ee207.ru-ru.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Common type system in depth</source>
          <target state="translated">Система общих типов CTS</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Common type system in depth</source>
          <target state="translated">Система общих типов CTS</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Common type system in depth</source>
          <target state="translated">Система общих типов CTS</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections that explore the common type system in depth:</source>
          <target state="translated">В этом разделе содержатся следующие подразделы с подробным описанием системы общих типов:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types in .NET<ept id="p1">](#types-in-net)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Типы в .NET<ept id="p1">](#types-in-net)</ept></target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type definitions<ept id="p1">](#type-definitions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Определения типов<ept id="p1">](#type-definitions)</ept></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type members<ept id="p1">](#type-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Члены типов<ept id="p1">](#type-members)</ept></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Characteristics of type members<ept id="p1">](#characteristics-of-type-members)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Характеристики членов типов<ept id="p1">](#characteristics-of-type-members)</ept></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Types in .NET</source>
          <target state="translated">Типы в .NET</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>All types in .NET are either value types or reference types.</source>
          <target state="translated">Все типы на платформе .NET делятся на типы значений и ссылочные типы.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Value types are data types whose objects are represented by the object's actual value.</source>
          <target state="translated">Типы значений — это типы данных, объекты которых представлены фактическим значением объекта.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If an instance of a value type is assigned to a variable, that variable is given a fresh copy of the value.</source>
          <target state="translated">Если экземпляр типа значения присваивается переменной, то эта переменная получает новую копию значения.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Reference types are data types whose objects are represented by a reference (similar to a pointer) to the object's actual value.</source>
          <target state="translated">Ссылочные типы — это типы данных, объекты которых представлены ссылкой (аналогичной указателю) на фактическое значение объекта.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If a reference type is assigned to a variable, that variable references (points to) the original value.</source>
          <target state="translated">Если экземпляр ссылочного типа присваивается переменной, то эта переменная будет ссылаться (указывать) на исходное значение.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>No copy is made.</source>
          <target state="translated">Копирования при этом не происходит.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The common type system in .NET supports the following five categories of types:</source>
          <target state="translated">Система общих типов CTS на платформе .NET поддерживает следующие пять категорий типов:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Classes<ept id="p1">](#classes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Классы<ept id="p1">](#classes)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Structures<ept id="p1">](#structures)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Структуры<ept id="p1">](#structures)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Enumerations<ept id="p1">](#enumerations)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Перечисления<ept id="p1">](#enumerations)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Interfaces<ept id="p1">](#interfaces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Интерфейсы<ept id="p1">](#interfaces)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates<ept id="p1">](#delegates)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Делегаты<ept id="p1">](#delegates)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Классы</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A class is a reference type that can be derived directly from another class and that is derived implicitly from <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</source>
          <target state="translated">Класс — это ссылочный тип, который может быть прямым производным от другого класса и является неявным производным от типа <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The class defines the operations that an object (which is an instance of the class) can perform (methods, events, or properties) and the data that the object contains (fields).</source>
          <target state="translated">В классе определяются операции, которые объект (являющийся экземпляром класса) может выполнять (методы, события или свойства), и данные, которые объект содержит (поля).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Although a class generally includes both definition and implementation (unlike interfaces, for example, which contain only definition without implementation), it can have one or more members that have no implementation.</source>
          <target state="translated">Обычно класс включает и определение, и реализацию (в отличие, например, от интерфейса, который содержит только определение без реализации), однако один или несколько членов класса могут не иметь реализации.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The following table describes some of the characteristics that a class may have.</source>
          <target state="translated">В приведенной ниже таблице описываются некоторые характеристики, которыми может обладать класс.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Each language that supports the runtime provides a way to indicate that a class or class member has one or more of these characteristics.</source>
          <target state="translated">Каждый язык, поддерживающий среду выполнения, позволяет указать на наличие у класса или члена класса одной или нескольких из этих характеристик.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>However, individual programming languages that target .NET may not make all these characteristics available.</source>
          <target state="translated">Вместе с тем отдельные языки программирования, ориентированные на платформу .NET, могут не поддерживать некоторые из этих характеристик.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Characteristic</source>
          <target state="translated">Характеристика</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>sealed</source>
          <target state="translated">sealed</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Specifies that another class cannot be derived from this type.</source>
          <target state="translated">Указывает, что наследование от данного класса не допускается.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>implements</source>
          <target state="translated">реализует</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Indicates that the class uses one or more interfaces by providing implementations of interface members.</source>
          <target state="translated">Показывает, что в классе используется один или несколько интерфейсов за счет предоставления реализаций их членов.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>abstract</source>
          <target state="translated">abstract</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Indicates that the class cannot be instantiated.</source>
          <target state="translated">Указывает, что создавать экземпляры этого класса нельзя.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>To use it, you must derive another class from it.</source>
          <target state="translated">Чтобы его использовать, необходимо создать из данного класса производный класс.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>inherits</source>
          <target state="translated">наследует</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Indicates that instances of the class can be used anywhere the base class is specified.</source>
          <target state="translated">Показывает, что экземпляры класса можно использовать везде, где задан базовый класс.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A derived class that inherits from a base class can use the implementation of any public members provided by the base class, or the derived class can override the implementation of the public members with its own implementation.</source>
          <target state="translated">Производный класс, который наследует от базового, может использовать реализацию любых открытых членов, предоставляемых базовым классом, либо переопределить реализацию этих открытых членов собственной их реализацией.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>exported or not exported</source>
          <target state="translated">exported или not exported</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Indicates whether a class is visible outside the assembly in which it is defined.</source>
          <target state="translated">Показывает, виден ли класс за пределами сборки, в которой он определен.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This characteristic applies only to top-level classes and not to nested classes.</source>
          <target state="translated">Эта характеристика применима только к классам верхнего уровня, но не к вложенным классам.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A class can also be nested in a parent class or structure.</source>
          <target state="translated">Класс может также быть вложен в родительский класс или родительскую структуру.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Nested classes also have member characteristics.</source>
          <target state="translated">Вложенные классы также имеют характеристики членов.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Nested types<ept id="p1">](#nested-types)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Вложенные типы<ept id="p1">](#nested-types)</ept>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Class members that have no implementation are abstract members.</source>
          <target state="translated">Члены классов, не имеющие реализации, являются абстрактными.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A class that has one or more abstract members is itself abstract; new instances of it cannot be created.</source>
          <target state="translated">Класс, содержащий несколько абстрактных членов, сам является абстрактным. Новые экземпляры этого класса создать нельзя.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Some languages that target the runtime let you mark a class as abstract even if none of its members are abstract.</source>
          <target state="translated">Некоторые языки, ориентированные на среду выполнения, позволяют пометить класс как абстрактный даже в том случае, если он не содержит ни одного абстрактного члена.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can use an abstract class when you want to encapsulate a basic set of functionality that derived classes can inherit or override when appropriate.</source>
          <target state="translated">Абстрактный класс можно использовать, когда требуется инкапсулировать базовый набор функциональных возможностей, которые производные классы могут наследовать или переопределять.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Classes that are not abstract are referred to as concrete classes.</source>
          <target state="translated">Классы, не являющиеся абстрактными, называются конкретными классами.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A class can implement any number of interfaces, but it can inherit from only one base class in addition to <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>, from which all classes inherit implicitly.</source>
          <target state="translated">Класс может реализовывать любое число интерфейсов, однако он также может наследовать только от одного базового класса в дополнение к <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>, от которого неявно наследуют все классы.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>All classes must have at least one constructor, which initializes new instances of the class.</source>
          <target state="translated">Любой класс должен иметь по крайней мере один конструктор, который инициализирует новые экземпляры класса.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you do not explicitly define a constructor, most compilers will automatically provide a default (parameterless) constructor.</source>
          <target state="translated">Если конструктор не определен явно, большинство компиляторов автоматически предоставят заданный по умолчанию конструктор без параметров.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Structures</source>
          <target state="translated">Структуры</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>A structure is a value type that derives implicitly from <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, which in turn is derived from <bpt id="p2">[</bpt>System.Object<ept id="p2">](xref:System.Object)</ept>.</source>
          <target state="translated">Структура — это тип значения, неявно производный от типа <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, который, в свою очередь, является производным от типа <bpt id="p2">[</bpt>System.Object<ept id="p2">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A structure is very useful for representing values whose memory requirements are small, and for passing values as by-value parameters to methods that have strongly typed parameters.</source>
          <target state="translated">Структуры весьма полезны для представления значений с небольшими требованиями к памяти и для передачи параметров по значению в методы со строгой типизацией параметров.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In .NET, all primitive data types (<bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>DateTime<ept id="p4">](xref:System.DateTime)</ept>, <bpt id="p5">[</bpt>Decimal<ept id="p5">](xref:System.Decimal)</ept>, <bpt id="p6">[</bpt>Double<ept id="p6">](xref:System.Double)</ept>, <bpt id="p7">[</bpt>Int16<ept id="p7">](xref:System.Int16)</ept>, <bpt id="p8">[</bpt>Int32<ept id="p8">](xref:System.Int32)</ept>, <bpt id="p9">[</bpt>Int64<ept id="p9">](xref:System.Int64)</ept>, <bpt id="p10">[</bpt>SByte<ept id="p10">](xref:System.SByte)</ept>, <bpt id="p11">[</bpt>Single<ept id="p11">](xref:System.Single)</ept>, <bpt id="p12">[</bpt>UInt16<ept id="p12">](xref:System.UInt16)</ept>, <bpt id="p13">[</bpt>UInt32<ept id="p13">](xref:System.UInt32)</ept>, and <bpt id="p14">[</bpt>UInt64<ept id="p14">](xref:System.UInt64)</ept>) are defined as structures.</source>
          <target state="translated">В среде .NET все типы-примитивы (<bpt id="p1">[</bpt>Boolean<ept id="p1">](xref:System.Boolean)</ept>, <bpt id="p2">[</bpt>Byte<ept id="p2">](xref:System.Byte)</ept>, <bpt id="p3">[</bpt>Char<ept id="p3">](xref:System.Char)</ept>, <bpt id="p4">[</bpt>DateTime<ept id="p4">](xref:System.DateTime)</ept>, <bpt id="p5">[</bpt>Decimal<ept id="p5">](xref:System.Decimal)</ept>, <bpt id="p6">[</bpt>Double<ept id="p6">](xref:System.Double)</ept>, <bpt id="p7">[</bpt>Int16<ept id="p7">](xref:System.Int16)</ept>, <bpt id="p8">[</bpt>Int32<ept id="p8">](xref:System.Int32)</ept>, <bpt id="p9">[</bpt>Int64<ept id="p9">](xref:System.Int64)</ept>, <bpt id="p10">[</bpt>SByte<ept id="p10">](xref:System.SByte)</ept>, <bpt id="p11">[</bpt>Single<ept id="p11">](xref:System.Single)</ept>, <bpt id="p12">[</bpt>UInt16<ept id="p12">](xref:System.UInt16)</ept>, <bpt id="p13">[</bpt>UInt32<ept id="p13">](xref:System.UInt32)</ept> и <bpt id="p14">[</bpt>UInt64<ept id="p14">](xref:System.UInt64)</ept>) определяются как структуры.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Like classes, structures define both data (the fields of the structure) and the operations that can be performed on that data (the methods of the structure).</source>
          <target state="translated">Как и в классах, в структурах определяются и данные (поля структуры), и операции, которые можно выполнять над этими данными (методы структуры).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This means that you can call methods on structures, including the virtual methods defined on the <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> and <bpt id="p2">[</bpt>System.ValueType<ept id="p2">](xref:System.ValueType)</ept> classes, and any methods defined on the value type itself.</source>
          <target state="translated">Это означает, что применительно к структурам можно вызывать методы, в том числе виртуальные методы, определенные в классах <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept> и <bpt id="p2">[</bpt>System.ValueType<ept id="p2">](xref:System.ValueType)</ept>, а также любые методы, определенные в самом типе значения.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In other words, structures can have fields, properties, and events, as well as static and nonstatic methods.</source>
          <target state="translated">Другими словами, структуры могут иметь поля, свойства и события, а также статические и нестатические методы.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You can create instances of structures, pass them as parameters, store them as local variables, or store them in a field of another value type or reference type.</source>
          <target state="translated">Можно создавать экземпляры структур, передавать их в качестве параметров, хранить их в качестве локальных переменных либо в поле другого типа значения или ссылочного типа.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Structures can also implement interfaces.</source>
          <target state="translated">Структуры также могут реализовывать интерфейсы.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Value types also differ from classes in several respects.</source>
          <target state="translated">Кроме того, типы значений отличаются от классов в ряде других вопросов.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>First, although they implicitly inherit from <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, they cannot directly inherit from any type.</source>
          <target state="translated">Во-первых, хотя они неявно наследуют от <bpt id="p1">[</bpt>System.ValueType<ept id="p1">](xref:System.ValueType)</ept>, они не могут напрямую наследовать ни от какого типа.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Similarly, all value types are sealed, which means that no other type can be derived from them.</source>
          <target state="translated">Аналогичным образом, все типы значений являются запечатанными. Это значит, что наследование от них не допускается.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>They also do not require constructors.</source>
          <target state="translated">Им также не требуются конструкторы.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For each value type, the common language runtime supplies a corresponding boxed type, which is a class that has the same state and behavior as the value type.</source>
          <target state="translated">Для каждого типа значения среда CLR предоставляет соответствующий упакованный тип — класс, имеющий то же состояние и поведение, что и тип значения.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>An instance of a value type is boxed when it is passed to a method that accepts a parameter of type <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</source>
          <target state="translated">Экземпляр типа значения упаковывается при передаче в метод, принимающий параметр типа <bpt id="p1">[</bpt>System.Object<ept id="p1">](xref:System.Object)</ept>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>It is unboxed (that is, converted from an instance of a class back to an instance of a value type) when control returns from a method call that accepts a value type as a by-reference parameter.</source>
          <target state="translated">Распаковка (преобразование из экземпляра класса обратно в экземпляр типа значения) производится при возврате управления после вызова метода, принимающего тип значения в качестве параметра по ссылке.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Some languages require that you use special syntax when the boxed type is required; others automatically use the boxed type when it is needed.</source>
          <target state="translated">В некоторых языках необходимо применение специального синтаксиса, когда требуется упакованный тип; в других упакованный тип используется автоматически, когда он нужен.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>When you define a value type, you are defining both the boxed and the unboxed type.</source>
          <target state="translated">При определении типа значений определяется и упакованный, и неупакованный тип.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Перечисления</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>An enumeration (enum) is a value type that inherits directly from <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept> and that supplies alternate names for the values of an underlying primitive type.</source>
          <target state="translated">Перечисление (enum) — это тип значения, который напрямую наследует от <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept> и предоставляет альтернативные имена для значений базового типа-примитива.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>An enumeration type has a name, an underlying type that must be one of the built-in signed or unsigned integer types (such as <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>, or <bpt id="p3">[</bpt>UInt64<ept id="p3">](xref:System.UInt64)</ept>), and a set of fields.</source>
          <target state="translated">Тип перечисления имеет имя, базовый тип, который должен быть одним из встроенных целочисленных знаковых или беззнаковых типов (например, <bpt id="p1">[</bpt>Byte<ept id="p1">](xref:System.Byte)</ept>, <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept> или <bpt id="p3">[</bpt>UInt64<ept id="p3">](xref:System.UInt64)</ept>), а также набор полей.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The fields are static literal fields, each of which represents a constant.</source>
          <target state="translated">Поля являются статическими полями литералов, каждое из которых представляет константу.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The same value can be assigned to multiple fields.</source>
          <target state="translated">Одно значение можно присвоить нескольким полям.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>When this occurs, you must mark one of the values as the primary enumeration value for reflection and string conversion.</source>
          <target state="translated">В этом случае необходимо пометить одно из значений как первичное значение перечисления для отражения и преобразования строк.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You can assign a value of the underlying type to an enumeration and vice versa (no cast is required by the runtime).</source>
          <target state="translated">Значение базового типа можно присвоить перечислению и наоборот (среда выполнения не требует приведения типов).</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You can create an instance of an enumeration and call the methods of <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept>, as well as any methods defined on the enumeration's underlying type.</source>
          <target state="translated">Можно создавать экземпляры перечислений и вызвать методы <bpt id="p1">[</bpt>System.Enum<ept id="p1">](xref:System.Enum)</ept>, а также любые методы, определенные в базовом типе перечисления.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>However, some languages might not let you pass an enumeration as a parameter when an instance of the underlying type is required (or vice versa).</source>
          <target state="translated">При этом в некоторых языках передача перечисления в виде параметра может не допускаться, если требуется передать экземпляр базового типа (или наоборот).</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following additional restrictions apply to enumerations:</source>
          <target state="translated">К перечислениям применяются следующие дополнительные ограничения.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>They cannot define their own methods.</source>
          <target state="translated">В них нельзя определять собственные методы.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>They cannot implement interfaces.</source>
          <target state="translated">В них нельзя реализовывать интерфейсы.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>They cannot define properties or events.</source>
          <target state="translated">В них нельзя определять свойства и события.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>They cannot be generic, unless they are generic only because they are nested within a generic type.</source>
          <target state="translated">Они не могут быть универсальными, если только они становятся таковыми за счет вложения внутрь универсального типа.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>That is, an enumeration cannot have type parameters of its own.</source>
          <target state="translated">То есть перечисления не могут иметь свои собственные параметры типов.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Nested types (including enumerations) created with C# include the type parameters of all enclosing generic types, and are therefore generic even if they do not have type parameters of their own.</source>
          <target state="translated">Вложенные типы (в том числе перечисления), созданные на языке C#, содержат параметры всех включающих их универсальных типов и, таким образом, являются универсальными, даже если они не имеют своих собственных параметров типов.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Type.MakeGenericType<ept id="p1">](xref:System.Type.MakeGenericType(System.Type[]))</ept> reference topic.</source>
          <target state="translated">Дополнительные сведения см. в разделе справки по <bpt id="p1">[</bpt>Type.MakeGenericType<ept id="p1">](xref:System.Type.MakeGenericType(System.Type[]))</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> attribute denotes a special kind of enumeration called a bit field.</source>
          <target state="translated">Атрибут <bpt id="p1">[</bpt>FlagsAttribute<ept id="p1">](xref:System.FlagsAttribute)</ept> обозначает специальный вид перечисления, называемый битовым полем.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The runtime itself does not distinguish between traditional enumerations and bit fields, but your language might do so.</source>
          <target state="translated">Среда выполнения (в отличие от языка программирования) не различает обычные перечисления и битовые поля.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>When this distinction is made, bitwise operators can be used on bit fields, but not on enumerations, to generate unnamed values.</source>
          <target state="translated">Если это отличие обнаружено, для создания неименованных значений в битовых полях можно использовать битовые операторы (в перечислениях их использовать нельзя).</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Enumerations are generally used for lists of unique elements, such as days of the week, country or region names, and so on.</source>
          <target state="translated">Перечисления обычно используются для списков уникальных элементов, например дней недели, названий стран или областей и т. д.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Bit fields are generally used for lists of qualities or quantities that might occur in combination, such as <ph id="ph1">`Red And Big And Fast`</ph>.</source>
          <target state="translated">Битовые поля обычно используются для списков количеств и качеств, которые могут возникать в таких комбинациях, как <ph id="ph1">`Red And Big And Fast`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following example shows how to use both bit fields and traditional enumerations.</source>
          <target state="translated">В следующем примере показан способ использования битовых полей и обычных перечислений.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Интерфейсы</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>An interface defines a contract that specifies a "can do" relationship or a "has a" relationship.</source>
          <target state="translated">Интерфейс задает контракт, определяющий отношение типа "может" или "имеет".</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Interfaces are often used to implement functionality, such as comparing and sorting (the <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> and <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept> interfaces), testing for equality (the <bpt id="p3">[</bpt>IEquatable<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p3">](xref:System.IEquatable%601)</ept> interface), or enumerating items in a collection (the <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept> and <bpt id="p5">[</bpt>IEnumerable<ph id="ph5">&amp;lt;</ph>T<ph id="ph6">&amp;gt;</ph><ept id="p5">](xref:System.Collections.Generic.IEnumerable%601)</ept> interfaces).</source>
          <target state="translated">Интерфейсы часто используются для реализации различных функций, например для сравнения и сортировки (интерфейсы <bpt id="p1">[</bpt>IComparable<ept id="p1">](xref:System.IComparable)</ept> и <bpt id="p2">[</bpt>IComparable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p2">](xref:System.IComparable%601)</ept>), проверки равенства (интерфейс <bpt id="p3">[</bpt>IEquatable<ph id="ph3">&amp;lt;</ph>T<ph id="ph4">&amp;gt;</ph><ept id="p3">](xref:System.IEquatable%601)</ept>) или перечисления элементов коллекции (интерфейсы <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept> и <bpt id="p5">[</bpt>IEnumerable<ph id="ph5">&amp;lt;</ph>T<ph id="ph6">&amp;gt;</ph><ept id="p5">](xref:System.Collections.Generic.IEnumerable%601)</ept>).</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Interfaces can have properties, methods, and events, all of which are abstract members; that is, although the interface defines the members and their signatures, it leaves it to the type that implements the interface to define the functionality of each interface member.</source>
          <target state="translated">Интерфейсы могут иметь свойства, методы и события, являющиеся абстрактными членами. Это значит, что хотя в интерфейсе определяются члены и их сигнатуры, за определение функциональности всех членов интерфейса отвечает тип, реализующий данный интерфейс.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This means that any class or structure that implements an interface must supply definitions for the abstract members declared in the interface.</source>
          <target state="translated">Любой класс или структура, реализующие интерфейс, должны содержать определения абстрактных членов, объявленных в этом интерфейсе.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>An interface can require any implementing class or structure to also implement one or more other interfaces.</source>
          <target state="translated">Обязательным условием реализации интерфейса в классе или структуре также может быть реализация одного или нескольких других интерфейсов.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to interfaces:</source>
          <target state="translated">К интерфейсам применяются следующие ограничения.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>An interface can be declared with any accessibility, but interface members must all have public accessibility.</source>
          <target state="translated">Интерфейс может быть объявлен с любой доступностью, однако, члены интерфейса всегда должны иметь доступность уровня public.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Interfaces cannot define constructors.</source>
          <target state="translated">В интерфейсах нельзя определять конструкторы.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Interfaces cannot define fields.</source>
          <target state="translated">В интерфейсах нельзя определять поля.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Interfaces can define only instance members.</source>
          <target state="translated">В интерфейсах можно определять только члены экземпляров.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>They cannot define static members.</source>
          <target state="translated">Статические члены определять в них нельзя.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Each language must provide rules for mapping an implementation to the interface that requires the member, because more than one interface can declare a member with the same signature, and these members can have separate implementations.</source>
          <target state="translated">Поскольку в нескольких интерфейсах могут быть объявлены члены с одной и той же сигнатурой, имеющие разные реализации, любой язык должен предоставлять правила сопоставления реализации с интерфейсом, для которого требуется данный член.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Delegates</source>
          <target state="translated">Делегаты</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Delegates are reference types that serve a purpose similar to that of function pointers in C++.</source>
          <target state="translated">Делегаты — это ссылочные типы, аналогичные по назначению указателям на функции в языке C++.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>They are used for event handlers and callback functions in .NET.</source>
          <target state="translated">Они применяются в обработчиках событий и функциях обратного вызова в составе платформы .NET.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Unlike function pointers, delegates are secure, verifiable, and type safe.</source>
          <target state="translated">В отличие от указателей функций, делегаты являются безопасными, проверяемыми и типобезопасными.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>A delegate type can represent any instance method or static method that has a compatible signature.</source>
          <target state="translated">Тип делегата может представлять любой метод экземпляра или статический метод, имеющий совместимую сигнатуру.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For example, a delegate that has a parameter of type <bpt id="p1">[</bpt>IEnumerable<ept id="p1">](xref:System.Collections.IEnumerable)</ept> and a return type of <bpt id="p2">[</bpt>Object<ept id="p2">](xref:System.Object)</ept> can represent a method that has a parameter of type <bpt id="p3">[</bpt>Object<ept id="p3">](xref:System.Object)</ept> and a return value of type <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept>.</source>
          <target state="translated">Например, делегат с параметром типа <bpt id="p1">[</bpt>IEnumerable<ept id="p1">](xref:System.Collections.IEnumerable)</ept> и типом возвращаемого значения <bpt id="p2">[</bpt>Object<ept id="p2">](xref:System.Object)</ept> может представлять метод с параметром типа <bpt id="p3">[</bpt>Object<ept id="p3">](xref:System.Object)</ept> и типом возвращаемого значения <bpt id="p4">[</bpt>IEnumerable<ept id="p4">](xref:System.Collections.IEnumerable)</ept>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>A delegate is said to be bound to the method it represents.</source>
          <target state="translated">Делегат называют связанным с методом, который он представляет.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In addition to being bound to the method, a delegate can be bound to an object.</source>
          <target state="translated">Помимо привязки к методу, делегат может быть связан с отдельным объектом.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The object represents the first parameter of the method, and is passed to the method every time the delegate is invoked.</source>
          <target state="translated">Этот объект представляет первый параметр метода и передается методу при каждом вызове делегата.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If the method is an instance method, the bound object is passed as the implicit <ph id="ph1">`this`</ph> parameter (<ph id="ph2">`Me`</ph> in Visual Basic); if the method is static, the object is passed as the first formal parameter of the method, and the delegate signature must match the remaining parameters.</source>
          <target state="translated">Если это метод экземпляра, то связанный объект передается как неявный параметр <ph id="ph1">`this`</ph> (<ph id="ph2">`Me`</ph> в Visual Basic); если метод является статическим, то объект передается как первый формальный параметр метода, и сигнатура делегата при этом должна соответствовать остальным параметрам.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>All delegates inherit from <bpt id="p1">[</bpt>System.MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, which inherits from <bpt id="p2">[</bpt>System.Delegate<ept id="p2">](xref:System.Delegate)</ept>.</source>
          <target state="translated">Все делегаты наследуют от <bpt id="p1">[</bpt>System.MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, который наследует от <bpt id="p2">[</bpt>System.Delegate<ept id="p2">](xref:System.Delegate)</ept>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The C# and Visual Basic languages don't allow inheritance from these types.</source>
          <target state="translated">Языки C# и Visual Basic не допускают наследование от этих типов.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Instead, they provide keywords for declaring delegates.</source>
          <target state="translated">Вместо этого они предоставляют ключевые слова для объявления делегатов.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Because delegates inherit from <bpt id="p1">[</bpt>MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, a delegate has an invocation list, which is a list of methods that the delegate represents and that are executed when the delegate is invoked.</source>
          <target state="translated">Поскольку делегаты наследуют от <bpt id="p1">[</bpt>MulticastDelegate<ept id="p1">](xref:System.MulticastDelegate)</ept>, делегат имеет список вызова, представляющий собой список методов, которые представляет делегат и которые выполняются при вызове делегата.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>All methods in the list receive the arguments supplied when the delegate is invoked.</source>
          <target state="translated">Все методы в списке получают аргументы, предоставляемые при вызове делегата.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The return value is not defined for a delegate that has more than one method in its invocation list, even if the delegate has a return type.</source>
          <target state="translated">Для делегата, имеющего более одного метода в списке вызовов, возвращаемое значение не определяется, даже если у делегата есть возвращаемый тип.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>In many cases, such as with callback methods, a delegate represents only one method, and the only actions you have to take are creating the delegate and invoking it.</source>
          <target state="translated">Зачастую, как, например, в случае с методами обратного вызова, делегат представляет только один метод, поэтому единственное действие, которое нужно выполнить, — это создание и вызов делегата.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>For delegates that represent multiple methods, .NET provides methods of the <bpt id="p1">[</bpt>Delegate<ept id="p1">](xref:System.Delegate)</ept> and <bpt id="p2">[</bpt>MulticastDelegate<ept id="p2">](xref:System.MulticastDelegate)</ept> delegate classes to support operations such as adding a method to a delegate's invocation list (the <bpt id="p3">[</bpt>Delegate.Combine<ept id="p3">](xref:System.Delegate.Combine(System.Delegate,System.Delegate))</ept> method), removing a method (the <bpt id="p4">[</bpt>Delegate.Remove<ept id="p4">](xref:System.Delegate.Remove(System.Delegate,System.Delegate))</ept> method), and getting the invocation list (the <bpt id="p5">[</bpt>Delegate.GetInvocationList<ept id="p5">](xref:System.Delegate.GetInvocationList)</ept> method).</source>
          <target state="translated">Для делегатов, представляющих несколько методов, .NET предоставляет методы классов делегатов <bpt id="p1">[</bpt>Delegate<ept id="p1">](xref:System.Delegate)</ept> и <bpt id="p2">[</bpt>MulticastDelegate<ept id="p2">](xref:System.MulticastDelegate)</ept> для поддержки таких операций, как добавление методов к списку вызовов делегата (метод <bpt id="p3">[</bpt>Delegate.Combine<ept id="p3">](xref:System.Delegate.Combine(System.Delegate,System.Delegate))</ept>), удаление метода (метод <bpt id="p4">[</bpt>Delegate.Remove<ept id="p4">](xref:System.Delegate.Remove(System.Delegate,System.Delegate))</ept>) и получение списка вызовов (метод <bpt id="p5">[</bpt>Delegate.GetInvocationList<ept id="p5">](xref:System.Delegate.GetInvocationList)</ept>).</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>It is not necessary to use these methods for event-handler delegates in C# or Visual Basic, because these languages provide syntax for adding and removing event handlers.</source>
          <target state="translated">Применение этих методов к делегатам обработчиков событий в C# или Visual Basic необязательно, так как эти языки предоставляют синтаксис для добавления и удаления обработчиков событий.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Type definitions</source>
          <target state="translated">Определения типов</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>A type definition includes the following:</source>
          <target state="translated">Определение типа включает следующее:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Any attributes defined on the type.</source>
          <target state="translated">все определенные в типе атрибуты;</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The type's accessibility (visibility).</source>
          <target state="translated">доступность (видимость) типа;</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The type's name.</source>
          <target state="translated">имя типа;</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The type's base type.</source>
          <target state="translated">базовый тип данного типа;</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Any interfaces implemented by the type.</source>
          <target state="translated">все интерфейсы, реализованные этим типом;</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Definitions for each of the type's members.</source>
          <target state="translated">определения каждого члена типа.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Атрибуты</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Attributes provide additional user-defined metadata.</source>
          <target state="translated">Атрибуты предоставляют дополнительные пользовательские метаданные.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Most commonly, they are used to store additional information about a type in its assembly, or to modify the behavior of a type member in either the design-time or run-time environment.</source>
          <target state="translated">Они чаще всего используются для хранения дополнительной информации о типе в его сборке либо для изменения поведения члена типа во время разработки или выполнения.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Attributes are themselves classes that inherit from <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept>.</source>
          <target state="translated">Сами атрибуты представляют собой классы, которые наследуют от <bpt id="p1">[</bpt>System.Attribute<ept id="p1">](xref:System.Attribute)</ept>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Languages that support the use of attributes each have their own syntax for applying attributes to a language element.</source>
          <target state="translated">Любой язык, поддерживающий использование атрибутов, имеет собственный синтаксис для применения атрибутов к элементам языка.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Attributes can be applied to almost any language element; the specific elements to which an attribute can be applied are defined by the <bpt id="p1">[</bpt>AttributeUsageAttribute<ept id="p1">](xref:System.AttributeUsageAttribute)</ept> that is applied to that attribute class.</source>
          <target state="translated">Атрибуты можно применять почти к любым элементам языка. Конкретные элементы, к которым можно применять определенный атрибут, задаются атрибутом <bpt id="p1">[</bpt>AttributeUsageAttribute<ept id="p1">](xref:System.AttributeUsageAttribute)</ept>, примененным к классу этого атрибута.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Type accessibility</source>
          <target state="translated">Доступность типов</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>All types have a modifier that governs their accessibility from other types.</source>
          <target state="translated">Все типы имеют модификатор, который определяет их доступность из других типов.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following table describes the type accessibilities supported by the runtime.</source>
          <target state="translated">В следующей таблице описаны виды доступности типов, поддерживаемые в среде выполнения.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Специальные возможности</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>public</source>
          <target state="translated">public</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The type is accessible by all assemblies.</source>
          <target state="translated">Тип доступен во всех сборках.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>assembly</source>
          <target state="translated">сборка</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The type is accessible only from within its assembly.</source>
          <target state="translated">Тип доступен только в пределах своей сборки.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The accessibility of a nested type depends on its accessibility domain, which is determined by both the declared accessibility of the member and the accessibility domain of the immediately containing type.</source>
          <target state="translated">Доступность вложенного типа зависит от домена доступности, который определяется объявленным уровнем доступности члена и доменом доступности непосредственно вмещающего его типа.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>However, the accessibility domain of a nested type cannot exceed that of the containing type.</source>
          <target state="translated">Однако домен доступности вложенного типа не может выходить за границы домена доступности содержащего его типа.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The accessibility domain of a nested member <ph id="ph1">`M`</ph> declared in a type <ph id="ph2">`T`</ph>within a program <ph id="ph3">`P`</ph> is defined as follows (noting that <ph id="ph4">`M`</ph> might itself be a type):</source>
          <target state="translated">Домен доступности вложенного члена <ph id="ph1">`M`</ph>, объявленного в типе <ph id="ph2">`T`</ph> в рамках программы <ph id="ph3">`P`</ph>, определяется следующим образом (при этом <ph id="ph4">`M`</ph> также может быть типом):</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`public`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the accessibility domain of <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Если объявленный уровень доступности <ph id="ph1">`M`</ph> — <ph id="ph2">`public`</ph>, то домен доступности <ph id="ph3">`M`</ph> совпадает с доменом доступности <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`protected internal`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the intersection of the accessibility domain of <ph id="ph4">`T`</ph> with the program text of <ph id="ph5">`P`</ph> and the program text of any type derived from <ph id="ph6">`T`</ph> declared outside <ph id="ph7">`P`</ph>.</source>
          <target state="translated">Если объявленный уровень доступности <ph id="ph1">`M`</ph> — <ph id="ph2">`protected internal`</ph>, то домен доступности <ph id="ph3">`M`</ph> представляет собой пересечение домена доступности <ph id="ph4">`T`</ph> с текстом программы <ph id="ph5">`P`</ph> и текстом программ любого типа, производного от <ph id="ph6">`T`</ph> и объявленного вне <ph id="ph7">`P`</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`protected`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the intersection of the accessibility domain of <ph id="ph4">`T`</ph> with the program text of <ph id="ph5">`T`</ph> and any type derived from <ph id="ph6">`T`</ph>.</source>
          <target state="translated">Если объявленный уровень доступности <ph id="ph1">`M`</ph> — <ph id="ph2">`protected`</ph>, то домен доступности <ph id="ph3">`M`</ph> представляет собой пересечение домена доступности <ph id="ph4">`T`</ph> с текстом программы <ph id="ph5">`T`</ph> и текстом программы любого типа, производного от <ph id="ph6">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`internal`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the intersection of the accessibility domain of <ph id="ph4">`T`</ph> with the program text of<ph id="ph5">`P`</ph>.</source>
          <target state="translated">Если объявленный уровень доступности <ph id="ph1">`M`</ph> — <ph id="ph2">`internal`</ph>, то домен доступности <ph id="ph3">`M`</ph> представляет собой пересечение домена доступности <ph id="ph4">`T`</ph> с текстом программы <ph id="ph5">`P`</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If the declared accessibility of <ph id="ph1">`M`</ph> is <ph id="ph2">`private`</ph>, the accessibility domain of <ph id="ph3">`M`</ph> is the program text of <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Если объявленный уровень доступности <ph id="ph1">`M`</ph> — <ph id="ph2">`private`</ph>, то домен доступности <ph id="ph3">`M`</ph> совпадает с текстом программы <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Type names</source>
          <target state="translated">Имена типов</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The common type system imposes only two restrictions on names:</source>
          <target state="translated">Система общих типов накладывает на имена только два следующих ограничения.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>All names are encoded as strings of Unicode (16-bit) characters.</source>
          <target state="translated">Все имена кодируются в виде строк, состоящих из символов Юникода (16-разрядная кодировка).</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Names are not permitted to have an embedded (16-bit) value of 0x0000.</source>
          <target state="translated">Имена не могут иметь внедренное (16-разрядное) значение 0x0000.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>However, most languages impose additional restrictions on type names.</source>
          <target state="translated">Тем не менее в большинстве языков на имена типов налагаются дополнительные ограничения.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>All comparisons are done on a byte-by-byte basis, and are therefore case-sensitive and locale-independent.</source>
          <target state="translated">Все сравнения выполняются на побайтовой основе, поэтому в них учитывается регистр, но они не зависят от языкового стандарта.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Although a type might reference types from other modules and assemblies, a type must be fully defined within one .NET module.</source>
          <target state="translated">Несмотря на то, что тип может ссылаться на типы из других модулей и сборок, он должен полностью определяться в одном модуле платформы .NET.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>(Depending on compiler support, however, it can be divided into multiple source code files.) Type names need be unique only within a namespace.</source>
          <target state="translated">(Тем не менее при поддержке соответствующей возможности в компиляторе он может быть разделен на несколько файлов исходного кода.) Имена типов должны быть уникальными только в пределах пространства имен.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>To fully identify a type, the type name must be qualified by the namespace that contains the implementation of the type.</source>
          <target state="translated">Для полной идентификации типа его имя должно квалифицироваться именем пространства имен, в котором содержится реализация этого типа.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Base types and interfaces</source>
          <target state="translated">Базовые типы и интерфейсы</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>A type can inherit values and behaviors from another type.</source>
          <target state="translated">Тип может наследовать значения и поведение другого типа.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The common type system does not allow types to inherit from more than one base type.</source>
          <target state="translated">Система общих типов не разрешает наследование от нескольких базовых типов.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>A type can implement any number of interfaces.</source>
          <target state="translated">Тип может реализовывать любое число интерфейсов.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>To implement an interface, a type must implement all the virtual members of that interface.</source>
          <target state="translated">Для этого он должен реализовать все виртуальные члены этого интерфейса.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>A virtual method can be implemented by a derived type and can be invoked either statically or dynamically.</source>
          <target state="translated">Виртуальный метод может быть реализован с помощью производного типа и может вызываться либо статически, либо динамически.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Type members</source>
          <target state="translated">Члены типов</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The runtime enables you to define members of your type, which specifies the behavior and state of a type.</source>
          <target state="translated">Среда выполнения позволяет определять члены типа, задающих поведение и состояние типа.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Type members include the following:</source>
          <target state="translated">К членам типа относятся:</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Fields<ept id="p1">](#fields)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Поля<ept id="p1">](#fields)</ept></target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](#properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Свойства<ept id="p1">](#properties)</ept></target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Methods<ept id="p1">](#methods)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Методы<ept id="p1">](#methods)</ept></target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Constructors<ept id="p1">](#constructors)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Конструкторы<ept id="p1">](#constructors)</ept></target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](#events)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>События<ept id="p1">](#events)</ept></target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nested types<ept id="p1">](#nested-types)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Вложенные типы<ept id="p1">](#nested-types)</ept></target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Поля</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>A field describes and contains part of the type's state.</source>
          <target state="translated">Поле описывает и содержит часть состояния типа.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Fields can be of any type supported by the runtime.</source>
          <target state="translated">Поля могут иметь любой тип, поддерживаемый средой выполнения.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Most commonly, fields are either <ph id="ph1">`private`</ph> or <ph id="ph2">`protected`</ph>, so that they are accessible only from within the class or from a derived class.</source>
          <target state="translated">Поля чаще всего имеют уровень доступности <ph id="ph1">`private`</ph> или <ph id="ph2">`protected`</ph>, поэтому они доступны только изнутри самого класса или из производных от него классов.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>If the value of a field can be modified from outside its type, a property set accessor is typically used.</source>
          <target state="translated">Если значение поля может быть изменено извне его типа, то для этого обычно используется метод доступа набора свойств.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Publicly exposed fields are usually read-only and can be of two types:</source>
          <target state="translated">Открытые поля обычно доступны только для чтения и могут относиться к одному из двух типов:</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Constants, whose value is assigned at design time.</source>
          <target state="translated">Константы, значение которых задается во время разработки.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>These are static members of a class, although they are not defined using the <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) keyword.</source>
          <target state="translated">Они являются статическими членами класса, хотя и не определяются с помощью ключевого слова <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Read-only variables, whose values can be assigned in the class constructor.</source>
          <target state="translated">Доступные только для чтения переменные, значения которых задаются в конструкторе класса.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The following example illustrates these two usages of read-only fields.</source>
          <target state="translated">В следующем примере демонстрируются эти два способа использования доступных только для чтения полей.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Свойства</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>A property names a value or state of the type and defines methods for getting or setting the property's value.</source>
          <target state="translated">Свойство задает определенное значение или состояние типа, а также определяет методы получения и установки значения свойства.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Properties can be primitive types, collections of primitive types, user-defined types, or collections of user-defined types.</source>
          <target state="translated">Свойства могут быть простыми типами, коллекциями простых типов, пользовательскими типами или коллекциями пользовательских типов.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Properties are often used to keep the public interface of a type independent from the type's actual representation.</source>
          <target state="translated">Свойства часто используются, чтобы обеспечить независимость общего интерфейса типа от фактической реализации данного типа.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>This enables properties to reflect values that are not directly stored in the class (for example, when a property returns a computed value) or to perform validation before values are assigned to private fields.</source>
          <target state="translated">Это позволяет представлять с помощью свойств значения, которые не хранятся непосредственно в классе (например, когда свойство возвращает вычисляемое значение), либо выполнять проверку перед присваиванием значений закрытым полям.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>The following example illustrates the latter pattern.</source>
          <target state="translated">В следующем примере демонстрируется второй вариант.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>In addition to including the property itself, the Microsoft intermediate language (MSIL) for a type that contains a readable property includes a <ph id="ph1">`get`</ph><bpt id="p1">*</bpt>_propertyname<ept id="p1">*</ept> method, and the MSIL for a type that contains a writable property includes a <ph id="ph2">`set`</ph><bpt id="p2">*</bpt>_propertyname<ept id="p2">*</ept> method.</source>
          <target state="translated">Помимо самого свойства MSIL-код типа, имеющего доступное для чтения свойство, включает метод <ph id="ph1">`get`</ph><bpt id="p1">*</bpt>_propertyname<ept id="p1">*</ept>, а MSIL-код типа, имеющего доступное для записи свойство, — метод <ph id="ph2">`set`</ph><bpt id="p2">*</bpt>_propertyname<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Методы</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>A method describes operations that are available on the type.</source>
          <target state="translated">Метод описывает операции, доступные в определенном типе.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>A method's signature specifies the allowable types of all its parameters and of its return value.</source>
          <target state="translated">Сигнатура метода указывает допустимые типы всех его параметров и возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Although most methods define the precise number of parameters required for method calls, some methods support a variable number of parameters.</source>
          <target state="translated">Хотя большинство методов определяют точное число параметров, необходимых для вызовов метода, некоторые методы поддерживают переменное число параметров.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The final declared parameter of these methods is marked with the <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> attribute.</source>
          <target state="translated">Конечный объявленный параметр этих методов помечается атрибутом <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Language compilers typically provide a keyword, such as <ph id="ph1">`params`</ph> in C# and <ph id="ph2">`ParamArray`</ph> in Visual Basic, that makes explicit use of <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept> unnecessary.</source>
          <target state="translated">Компиляторы языка обычно предоставляют ключевое слово, такое как <ph id="ph1">`params`</ph> в C# и <ph id="ph2">`ParamArray`</ph> в Visual Basic, которое исключает необходимость явного использования <bpt id="p1">[</bpt>ParamArrayAttribute<ept id="p1">](xref:System.ParamArrayAttribute)</ept>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Конструкторы</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>A constructor is a special kind of method that creates new instances of a class or structure.</source>
          <target state="translated">Конструктор — это специальный метод, который служит для создания новых экземпляров класса или структуры.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Like any other method, a constructor can include parameters; however, constructors have no return value (that is, they return <ph id="ph1">`void`</ph>).</source>
          <target state="translated">Как и любой другой метод, конструктор может иметь параметры, однако у конструкторов отсутствует возвращаемое значение (они возвращают <ph id="ph1">`void`</ph>).</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>If the source code for a class does not explicitly define a constructor, the compiler includes a default (parameterless) constructor.</source>
          <target state="translated">Если исходный код класса не содержит явного определения конструктора, то компилятор включает заданный по умолчанию конструктор без параметров.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>However, if the source code for a class defines only parameterized constructors, the C# compiler doesn't generate a parameterless constructor.</source>
          <target state="translated">Однако если исходный код класса определяет только параметризованные конструкторы, компилятор C# не создает конструктор без параметров.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>If the source code for a structure defines constructors, they must be parameterized; a structure cannot define a default (parameterless) constructor, and compilers do not generate parameterless constructors for structures or other value types.</source>
          <target state="translated">Если исходный код для структуры определяет конструкторы, они должны быть параметризованы; структура не может определять конструктор по умолчанию (без параметров), и компиляторы не создают конструкторы без параметров для структур и других типов значений.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>All value types do have an implicit default constructor.</source>
          <target state="translated">Все типы значений не имеют неявного конструктора, заданного по умолчанию.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>This constructor is implemented by the common language runtime and initializes all fields of the structure to their default values.</source>
          <target state="translated">Этот конструктор реализован средой CLR и инициализирует все поля структуры, задавая для них значения по умолчанию.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">События</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>An event defines an incident that can be responded to, and defines methods for subscribing to, unsubscribing from, and raising the event.</source>
          <target state="translated">Событие определяет происшествие, на которое можно реагировать, а также методы подписки, отказа от подписки или порождения события.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Events are often used to inform other types of state changes.</source>
          <target state="translated">События часто используются для оповещения других типов об изменениях состояния.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Nested types</source>
          <target state="translated">Вложенные типы</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>A nested type is a type that is a member of some other type.</source>
          <target state="translated">Вложенный тип — это тип, являющийся членом какого-либо другого типа.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Nested types should be tightly coupled to their containing type and must not be useful as a general-purpose type.</source>
          <target state="translated">Вложенные типы должны быть тесно связаны со своим вмещающим типом и не должны использоваться в качестве типа общего назначения.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Nested types are useful when the declaring type uses and creates instances of the nested type, and use of the nested type is not exposed in public members.</source>
          <target state="translated">Вложенные типы полезны, когда объявляющий тип использует и создает экземпляры вложенного типа и использование вложенного типа не открывается в публичных членах.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Nested types are confusing to some developers and should not be publicly visible unless there is a compelling reason for visibility.</source>
          <target state="translated">Особенности вложенных типов не всегда понятны некоторым разработчикам; эти типы не должны быть открыто видимыми, если существенной причины для подобной видимости не имеется.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>In a well-designed library, developers should rarely have to use nested types to instantiate objects or declare variables.</source>
          <target state="translated">В хорошо спроектированной библиотеке разработчикам редко приходится использовать вложенные типы для создания экземпляров объектов или объявления переменных.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Characteristics of type members</source>
          <target state="translated">Характеристики членов типов</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The common type system allows type members to have a variety of characteristics; however, languages are not required to support all these characteristics.</source>
          <target state="translated">Система общих типов CTS допускает наличие у членов типов различных характеристик, однако некоторые характеристики могут не поддерживаться в отдельных языках программирования.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following table describes member characteristics.</source>
          <target state="translated">В следующей таблице описаны характеристики членов.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Characteristic</source>
          <target state="translated">Характеристика</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Can apply to</source>
          <target state="translated">Применение</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>abstract</source>
          <target state="translated">abstract</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events</source>
          <target state="translated">Методы, свойства и события</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The type does not supply the method's implementation.</source>
          <target state="translated">Тип не предоставляет реализацию метода.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Types that inherit or implement abstract methods must supply an implementation for the method.</source>
          <target state="translated">Типы, которые наследуют или реализуют абстрактный метод, должны предоставлять реализацию метода.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The only exception is when the derived type is itself an abstract type.</source>
          <target state="translated">Единственное исключение — когда производный тип является абстрактным.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>All abstract methods are virtual.</source>
          <target state="translated">Все абстрактные методы являются виртуальными.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>private</source>
          <target state="translated">private</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Все</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Accessible only from within the same type as the member, or within a nested type.</source>
          <target state="translated">Доступен только изнутри типа, к которому принадлежит член, или изнутри вложенного типа.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>family</source>
          <target state="translated">family</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Все</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Accessible from within the same type as the member, and from derived types that inherit from it.</source>
          <target state="translated">Доступен изнутри типа, к которому принадлежит член, а также из производных от него типов.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>assemby</source>
          <target state="translated">assemby</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Все</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Accessible only in the assembly in which the type is defined.</source>
          <target state="translated">Доступен только в сборке, в которой определен тип.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>family and assembly</source>
          <target state="translated">family and assembly</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Все</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Accessible only from types that qualify for both family and assembly access.</source>
          <target state="translated">Доступен только в типах с уровнем доступа family и assembly.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>family or assemby</source>
          <target state="translated">family или assembly</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Все</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Accessible only from types that qualify for either family or assembly access.</source>
          <target state="translated">Доступен только в типах с уровнем доступа либо family, либо assembly.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>public</source>
          <target state="translated">public</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Все</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Accessible from any type.</source>
          <target state="translated">Доступен в любом типе.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>final</source>
          <target state="translated">final</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events</source>
          <target state="translated">Методы, свойства и события</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The virtual method cannot be overridden in a derived type.</source>
          <target state="translated">Виртуальный метод нельзя переопределить в производном типе.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>initialize-only</source>
          <target state="translated">initialize-only</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Поля</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The value can only be initialized, and cannot be written after initialization.</source>
          <target state="translated">Значение можно только инициализировать и невозможно установить после инициализации.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>instance</source>
          <target state="translated">экземпляр</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Fields, methods, properties, and events</source>
          <target state="translated">Поля, методы, свойства и события</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>If a member is not marked as <ph id="ph1">`static`</ph> (C#), <ph id="ph2">`Shared`</ph> (Visual Basic), <ph id="ph3">`virtual`</ph> (C#), or <ph id="ph4">`Overridable`</ph> (Visual Basic),  it is an instance member (there is no instance keyword).</source>
          <target state="translated">Если член не помечен как <ph id="ph1">`static`</ph> (C#), <ph id="ph2">`Shared`</ph> (Visual Basic), <ph id="ph3">`virtual`</ph> (C#) или <ph id="ph4">`Overridable`</ph> (Visual Basic), то он является членом экземпляра (ключевое слово instance не используется).</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>There will be as many copies of such members in memory as there are objects that use it.</source>
          <target state="translated">Копий таких членов в памяти будет столько, сколько объектов их использует.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>literal</source>
          <target state="translated">литерал</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Поля</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The value assigned to the field is a fixed value, known at compile time, of a built-in value type.</source>
          <target state="translated">Значение, присвоенное полю, является фиксированным значением встроенного типа значения и становится известным во время компиляции.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Literal fields are sometimes referred to as constants.</source>
          <target state="translated">Поля литералов иногда называются константами.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>newslot or override</source>
          <target state="translated">newslot или override</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">Все</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Defines how the member interacts with inherited members that have the same signature: <ph id="ph1">`newslot`</ph> hides inherited members that have the same signature; <ph id="ph2">`override`</ph> replaces the definition of an inherited virtual method.</source>
          <target state="translated">Определяет способ взаимодействия члена с унаследованными членами, имеющими ту же сигнатуру: <ph id="ph1">`newslot`</ph> скрывает унаследованные члены с той же сигнатурой. <ph id="ph2">`override`</ph> заменяет определение наследуемого виртуального метода.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The default is newslot.</source>
          <target state="translated">По умолчанию используется характеристика newslot.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>static</source>
          <target state="translated">статический</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Fields, methods, properties, and events</source>
          <target state="translated">Поля, методы, свойства и события</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The member belongs to the type it is defined on, not to a particular instance of the type; the member exists even if an instance of the type is not created, and it is shared among all instances of the type.</source>
          <target state="translated">Член принадлежит к типу, в котором он определен, а не к конкретному экземпляру типа. Член существует, даже если экземпляр типа не создан, и является общим для всех экземпляров типа.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>virtual</source>
          <target state="translated">виртуальный</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Methods, properties, and events</source>
          <target state="translated">Методы, свойства и события</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The method can be implemented by a derived type and can be invoked either statically or dynamically.</source>
          <target state="translated">Метод может реализовываться с помощью производного типа и вызываться либо статически, либо динамически.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>If dynamic invocation is used, the type of the instance that makes the call at run time (rather than the type known at compile time) determines which implementation of the method is called.</source>
          <target state="translated">Если используется динамический вызов, то вызываемая реализация метода определяется типом экземпляра, выполняющего вызов во время выполнения, а не типом, известным во время компиляции.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>To invoke a virtual method statically, the variable might have to be cast to a type that uses the desired version of the method.</source>
          <target state="translated">Для статического вызова виртуального метода может потребоваться приведение переменной к типу, который использует нужную версию метода.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Перегрузка</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Each type member has a unique signature.</source>
          <target state="translated">У каждого члена типа есть уникальная сигнатура.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Method signatures consist of the method name and a parameter list (the order and types of the method's arguments).</source>
          <target state="translated">Сигнатуры методов содержат имя метода и список параметров (порядок и типы аргументов метода).</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Multiple methods with the same name can be defined within a type as long as their signatures differ.</source>
          <target state="translated">В типе можно определить несколько методов с одним именем и разными сигнатурами.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>When two or more methods with the same name are defined, the method is said to be overloaded.</source>
          <target state="translated">При этом метод будет называться перегруженным.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>For example, in <bpt id="p1">[</bpt>System.Char<ept id="p1">](xref:System.Char)</ept>, the <ph id="ph1">`IsDigit`</ph> method is overloaded.</source>
          <target state="translated">Например, в <bpt id="p1">[</bpt>System.Char<ept id="p1">](xref:System.Char)</ept> метод <ph id="ph1">`IsDigit`</ph> перегружен.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>One method takes a <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept>.</source>
          <target state="translated">Один метод принимает параметр <bpt id="p1">[</bpt>Char<ept id="p1">](xref:System.Char)</ept>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The other method takes a <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> and an <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>.</source>
          <target state="translated">Другой метод принимает <bpt id="p1">[</bpt>String<ept id="p1">](xref:System.String)</ept> и <bpt id="p2">[</bpt>Int32<ept id="p2">](xref:System.Int32)</ept>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>The return type is not considered part of a method's signature.</source>
          <target state="translated">Тип возвращаемого значения не считается частью сигнатуры метода.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>That is, methods cannot be overloaded if they differ only by return type.</source>
          <target state="translated">Это значит, что методы не могут быть перегружены, если они различаются только типом возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Inheriting, overriding, and hiding members</source>
          <target state="translated">Наследование, переопределение и скрытие членов</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A derived type inherits all members of its base type; that is, these members are defined on, and available to, the derived type.</source>
          <target state="translated">Производный тип наследует все члены своего базового типа. Эти члены будут определены для производного типа и доступны в нем.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>The behavior or qualities of inherited members can be modified in two ways:</source>
          <target state="translated">Поведение или характеристики наследуемых членов можно изменить двумя способами.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>A derived type can hide an inherited member by defining a new member with the same signature.</source>
          <target state="translated">В производном типе можно скрыть наследуемый член, определив новый член с такой же сигнатурой.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>This might be done to make a previously public member private or to define new behavior for an inherited method that is marked as <ph id="ph1">`final`</ph>.</source>
          <target state="translated">Это может понадобиться для того, чтобы сделать ранее открытый член закрытым или определить новое поведение для унаследованного метода, помеченного как <ph id="ph1">`final`</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>A derived type can override an inherited virtual method.</source>
          <target state="translated">Производный тип может переопределять наследуемый виртуальный метод.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The overriding method provides a new definition of the method that will be invoked based on the type of the value at run time rather than the type of the variable known at compile time.</source>
          <target state="translated">Переопределяющий метод предоставляет новое определение метода, который будет вызываться, на основании типа значения во время выполнения, а не типа переменной, известной во время компиляции.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>A method can override a virtual method only if the virtual method is not marked as <ph id="ph1">`final`</ph> and the new method is at least as accessible as the virtual method.</source>
          <target state="translated">Метод может переопределить виртуальный метод только в том случае, если виртуальный метод не помечен как <ph id="ph1">`final`</ph>, и при этом уровень доступности нового метода не ниже уровня доступности виртуального метода.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">См. также</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type conversion in the .NET Framework<ept id="p1">](type-conversion.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Преобразование типов в .NET Framework<ept id="p1">](type-conversion.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>