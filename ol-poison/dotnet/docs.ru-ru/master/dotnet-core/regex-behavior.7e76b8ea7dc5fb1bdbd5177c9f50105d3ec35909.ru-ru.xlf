<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fa0513a5b450742995bd86fca495ba9904e7361b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\regex-behavior.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4487a8a5971b0098f55c989ab3c345500350eaad</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c84206223270960d50dfe758841e4cb5765524b6</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file regex-behavior.7e76b8ea7dc5fb1bdbd5177c9f50105d3ec35909.ru-ru.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Details of regular expression behavior</source>
          <target state="translated">Подробные сведения о поведении регулярных выражений</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Details of regular expression behavior</source>
          <target state="translated">Подробные сведения о поведении регулярных выражений</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Details of regular expression behavior</source>
          <target state="translated">Подробные сведения о поведении регулярных выражений</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The .NET regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</source>
          <target state="translated">Обработчик регулярных выражений .NET выполняет поиск с возвратом для регулярных выражений и является реализацией традиционной NFA-машины (недетерминированного конечного автомата), аналогично тем, которые используются в Perl, Python, Emacs и Tcl.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</source>
          <target state="translated">Это отличает его от более быстрых, но и более ограниченных DFA-машин (детерминированный конечный автомат), предназначенных только для регулярных выражений и используемых в awk, egrep или lex.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This also distinguishes it from standardized, but slower, POSIX NFAs.</source>
          <target state="translated">Это также отличает его от типовых, но более медленных POSIX NFA-машин.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The following section describes the three types of regular expression engines, and explains why regular expressions in .NET are implemented by using a traditional NFA engine.</source>
          <target state="translated">В следующем разделе представлено описание трех типов обработчиков регулярных выражений и объясняется причина реализации регулярных выражений в .NET с помощью обычной NFA-машины.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Benefits of the NFA Engine</source>
          <target state="translated">Преимущества NFA-машины</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When DFA engines perform pattern matching, their processing order is driven by the input string.</source>
          <target state="translated">Когда DFA-машины выполняют сопоставление шаблонов, порядок обработки определяется входной строкой.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</source>
          <target state="translated">Машина начинает обработку с начала входной строки и продолжает последовательную обработку для определения соответствия следующего символа шаблону регулярного выражения.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>They can guarantee to match the longest string possible.</source>
          <target state="translated">Их можно обнаружить как соответствия максимальной длины.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Because they never test the same character twice, DFA engines do not support backtracking.</source>
          <target state="translated">Так как DFA-машины не проверяют один и тот же знак дважды, они не поддерживают поиск с возвратом.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</source>
          <target state="translated">Но поскольку DFA-машина поддерживает только ограниченный режим работы, она не способна выполнять поиск соответствий по шаблону с обратными ссылками. Кроме того, она не создает явные выражения и не способна выделять части выражения.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</source>
          <target state="translated">В отличие от DFA-машин обычные NFA-машины выполняют поиск соответствий по шаблонам, и порядок обработки определяется шаблоном регулярных выражений.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</source>
          <target state="translated">По мере обработки определенного элемента языка машина использует жадное сопоставление: она выполняет сопоставление как можно большей части входной строки.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>But it also saves its state after successfully matching a subexpression.</source>
          <target state="translated">И кроме того, она сохраняет свое состояние после успешного поиска соответствия части выражения.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If a match eventually fails, the engine can return to a saved state so it can try additional matches.</source>
          <target state="translated">Если поиск соответствия в конечном счете завершился с ошибкой, машина может вернуться в сохраненное состояние, поэтому она может попытаться найти дополнительные соответствия.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as backtracking.</source>
          <target state="translated">Такой процесс оставления успешного соответствия части выражения, при котором последующие элементы языка также могут привести к соответствию, называется поиском с возвратом.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</source>
          <target state="translated">NFA-машины используют поиск с возвратом, проверяя все возможные расширения регулярного выражения в определенном порядке и принимая первое соответствие.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</source>
          <target state="translated">Поскольку обычная NFA-машина создает определенное расширение регулярного выражения для успешного сопоставления, она способна находить соответствия для частей выражений и обратных ссылок.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</source>
          <target state="translated">Но так как обычная NFA-машина выполняет поиск с возвратом, она может анализировать одно и то же состояние несколько раз, если к нему ведут несколько разных путей.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>As a result, it can run exponentially slowly in the worst case.</source>
          <target state="translated">В результате в наихудшем случае работа может замедляться по экспоненте.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</source>
          <target state="translated">Так как обычная NFA-машина принимает первое найденное соответствие, другие (возможно, более длинные) соответствия могут остаться необнаруженными.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</source>
          <target state="translated">POSIX NFA-машины похожи на обычные NFA-машины, за исключением того, что они продолжают поиск с возвратом до тех пор, пока не будет найдено наиболее длинное совпадение.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</source>
          <target state="translated">В результате POSIX NFA-машина работает медленнее обычной NFA-машины, и при использовании POSIX NFA-машины, изменив порядок поиска с возвратом, невозможно задать предпочтение короткому совпадению вместо более длинного.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</source>
          <target state="translated">Программисты предпочитают обычные NFA-машины, поскольку они превосходят по возможностям управления строковыми соответствиями обычные DFA-машины или POSIX NFA-машины.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</source>
          <target state="translated">Несмотря на то, что в наихудшем случае быстродействие NFA-машин снижается, ими можно управлять так, что поиск соответствий будет проходить по линейному или полиномиальному времени. Добиться этого можно с помощью шаблонов, уменьшающих неоднозначности и ограничивающих количество возвратов.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well-written and avoids cases in which backtracking degrades performance exponentially.</source>
          <target state="translated">Другими словами, несмотря на то, что NFA-машины жертвуют производительностью в обмен на мощность и гибкость, в большинстве случаев они обеспечивают хорошую (или хотя бы приемлемую) производительность, если регулярное выражение грамотно написано и позволяет избежать ситуаций, при которых производительность поиска с возвратом снижается экспоненциально.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see <bpt id="p1">[</bpt>Backtracking in Regular Expressions<ept id="p1">](backtracking.md)</ept>.</source>
          <target state="translated">Сведения о том, как излишнее использование поиска с возвратом может повлиять на производительность и как избежать проблем, см. в разделе <bpt id="p1">[</bpt>Поиск с возвратом в регулярных выражениях<ept id="p1">](backtracking.md)</ept>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>.NET Framework Engine Capabilities</source>
          <target state="translated">Возможности обработчика .NET Framework</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>To take advantage of the benefits of a traditional NFA engine, the .NET regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</source>
          <target state="translated">В обработчик регулярных выражений .NET были включены лучшие функции NFA-машины, а также полный набор структурных элементов, позволяющий программистам управлять процессом поиска с возвратом.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>These constructs can be used to find matches faster or to favor specific expansions over others.</source>
          <target state="translated">Эти структуры можно использовать для ускорения поиска или для выбора предпочтительных расширений.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Other features of the .NET regular expression engine include the following:</source>
          <target state="translated">Ниже представлены другие возможности обработчика регулярных выражений .NET.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Lazy quantifiers</source>
          <target state="translated">Ленивые квантификаторы</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Lazy quantifiers: <bpt id="p1">**</bpt>??<ept id="p1">**</ept>, <bpt id="p2">__</bpt>*?<ept id="p2">__</ept>, <bpt id="p3">**</bpt>+?<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,<ept id="p6">**</ept><bpt id="p7">_</bpt>m<ept id="p7">_</ept><bpt id="p8">**</bpt>}?<ept id="p8">**</ept>.</source>
          <target state="translated">Ленивые квантификаторы: <bpt id="p1">**</bpt>??<ept id="p1">**</ept>, <bpt id="p2">__</bpt>*?<ept id="p2">__</ept>, <bpt id="p3">**</bpt>+?<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,<ept id="p6">**</ept><bpt id="p7">_</bpt>m<ept id="p7">_</ept><bpt id="p8">**</bpt>}?<ept id="p8">**</ept>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>These constructs tell the backtracking engine to search the minimum number of repetitions first.</source>
          <target state="translated">В первую очередь они указывают обработчику на необходимость ведения поиска минимального числа повторений.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</source>
          <target state="translated">Обычные "жадные" квантификаторы, наоборот, пытаются сначала найти наибольшее число повторений.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between the two.</source>
          <target state="translated">В следующем примере кода демонстрируется различие между двумя квантификаторами.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</source>
          <target state="translated">Регулярное выражение соответствует предложению, оканчивающемуся на число, и захваченная группа должна извлечь это число.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`.+(\d+)\.`</ph> includes the greedy quantifier <ph id="ph2">`.+`</ph>, which causes the regular expression engine to capture only the last digit of the number.</source>
          <target state="translated">Регулярное выражение <ph id="ph1">`.+(\d+)\.`</ph> содержит жадный квантификатор <ph id="ph2">`.+`</ph>, под влиянием которого обработчик регулярных выражений захватывает только последнюю цифру числа.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In contrast, the regular expression <ph id="ph1">`.+?(\d+)\.`</ph> includes the lazy quantifier <ph id="ph2">`.+?`</ph>, which causes the regular expression engine to capture the entire number.</source>
          <target state="translated">И наоборот, регулярное выражение <ph id="ph1">`.+?(\d+)\.`</ph> содержит ленивый квантификатор <ph id="ph2">`.+?`</ph>, под влиянием которого обработчик регулярных выражений захватывает все число.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The greedy and lazy versions of this regular expression are defined as shown in the following table.</source>
          <target state="translated">Определение жадных и ленивых версий этого регулярного выражения представлено в следующей таблице.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`.+`</ph> (greedy quantifier)</source>
          <target state="translated"><ph id="ph1">`.+`</ph> ("жадный" квантификатор)</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Match at least one occurrence of any character.</source>
          <target state="translated">Соответствие как минимум одному вхождению любого символа.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</source>
          <target state="translated">Это дает обработчику регулярных выражений команду на сопоставление всей строки и выполнение поиска с возвратом, который требуется для сопоставления оставшейся части шаблона.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`.+?`</ph> (lazy quantifier)</source>
          <target state="translated"><ph id="ph1">`.+?`</ph> ("ленивый" квантификатор)</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Match at least one occurrence of any character, but match as few as possible.</source>
          <target state="translated">Соответствие как минимум одному вхождению любого символа, но как можно меньшему количеству.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Match at least one numeric character, and assign it to the first capturing group.</source>
          <target state="translated">Соответствие как минимум одной цифре и назначение ее для первой захваченной группы.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Match a period.</source>
          <target state="translated">Сопоставляется точка.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For more information about lazy quantifiers, see <bpt id="p1">[</bpt>Quantifiers in regular expressions<ept id="p1">](quantifiers.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о "ленивых" квантификаторах см. в статье <bpt id="p1">[</bpt>Квантификаторы в регулярных выражениях<ept id="p1">](quantifiers.md)</ept>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Positive lookahead</source>
          <target state="translated">Положительный поиск вперед</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Positive lookahead: <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">Положительный поиск: <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</source>
          <target state="translated">Эта функция позволяет обработчику с поиском с возвратом возвращаться в начальное место в тексте после сопоставления части выражения.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</source>
          <target state="translated">Эта функция полезна при осуществлении поиска с одной позиции с помощью нескольких шаблонов.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</source>
          <target state="translated">Она также позволяет обработчику проверять существование части строки в конце соответствия, не включая при этом часть строки в сопоставленный текст.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</source>
          <target state="translated">В следующем примере используется положительный поиск вперед для извлечения слов в предложении, после которых нет знаков препинания.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b[A-Z]+\b(?=\P{P})`</ph> is defined as shown in the following table.</source>
          <target state="translated">Определение регулярного выражения <ph id="ph1">`\b[A-Z]+\b(?=\P{P})`</ph> показано в таблице ниже.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Совпадение должно начинаться на границе слова.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Match any alphabetic character one or more times.</source>
          <target state="translated">Совпадение с любым символом один или более раз.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> method is called with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option, the comparison is case-insensitive.</source>
          <target state="translated">Так как метод <bpt id="p1">[</bpt>Regex.Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> вызывается с параметром <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>, сравнение не зависит от регистра символов.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Совпадение должно заканчиваться на границе слова.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Look ahead to determine whether the next character is a punctuation symbol.</source>
          <target state="translated">Поиск для определения, является ли следующий символ знаком препинания.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If it is not, the match succeeds.</source>
          <target state="translated">Если не является, соответствие считается успешным.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For more information about positive lookahead assertions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об утверждениях положительного поиска вперед см. в статье <bpt id="p1">[</bpt>Конструкции группировки в регулярных выражениях<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Negative lookahead</source>
          <target state="translated">Отрицательный поиск вперед</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Negative lookahead: <bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">Отрицательный поиск: <bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This feature adds the ability to match an expression only if a subexpression fails to match.</source>
          <target state="translated">Сопоставление выражения выполняется только в том случае, когда не было обнаружено соответствия части выражения.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</source>
          <target state="translated">Это существенно упрощает поиск, поскольку часто бывает проще описать выражения, не соответствующие правилу, чем само правило.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For example, it is difficult to write an expression for words that do not begin with "non".</source>
          <target state="translated">Например, трудно написать выражение для поиска слов, которые не начинаются с "non".</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The following example uses negative lookahead to exclude them.</source>
          <target state="translated">В следующем примере для их исключения используется отрицательный поиск.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(?!non)\w+\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\b(?!non)\w+\b`</ph> определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">Совпадение должно начинаться на границе слова.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Look ahead to ensure that the current string does not begin with "non".</source>
          <target state="translated">Поиск для определения, не начинается ли текущая строка с "non".</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>If it does, the match fails.</source>
          <target state="translated">Если начинается, соответствие считается неудачным.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">Совпадение с одним или несколькими символами слова.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">Совпадение должно заканчиваться на границе слова.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For more information about negative lookahead assertions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об утверждениях отрицательного поиска вперед см. в статье <bpt id="p1">[</bpt>Конструкции группировки в регулярных выражениях<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Conditional evaluation</source>
          <target state="translated">Условная оценка</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Conditional evaluation: <bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept>&amp;#124;<bpt id="p5">_</bpt>no<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> and<bpt id="p7">**</bpt>(?(<ept id="p7">**</ept><bpt id="p8">_</bpt>name<ept id="p8">_</ept><bpt id="p9">**</bpt>)<ept id="p9">**</ept><bpt id="p10">_</bpt>yes<ept id="p10">_</ept>&amp;#124;<bpt id="p11">_</bpt>no<ept id="p11">_</ept><bpt id="p12">**</bpt>)<ept id="p12">**</ept>, where <bpt id="p13">*</bpt>expression<ept id="p13">*</ept> is a subexpression to match, <bpt id="p14">*</bpt>name<ept id="p14">*</ept> is the name of a capturing group, <bpt id="p15">*</bpt>yes<ept id="p15">*</ept> is the string to match if <bpt id="p16">*</bpt>expression<ept id="p16">*</ept> is matched or <bpt id="p17">*</bpt>name<ept id="p17">*</ept> is a valid, non-empty captured group, and <bpt id="p18">*</bpt>no<ept id="p18">*</ept> is the subexpression to match if <bpt id="p19">*</bpt>expression<ept id="p19">*</ept> is not matched or <bpt id="p20">*</bpt>name<ept id="p20">*</ept> is not a valid, non-empty captured group.</source>
          <target state="translated">Условная оценка: <bpt id="p1">**</bpt>(?(<ept id="p1">**</ept><bpt id="p2">_</bpt>expression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept><bpt id="p4">_</bpt>yes<ept id="p4">_</ept>&amp;#124;<bpt id="p5">_</bpt>no<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> and<bpt id="p7">**</bpt>(?(<ept id="p7">**</ept><bpt id="p8">_</bpt>name<ept id="p8">_</ept><bpt id="p9">**</bpt>)<ept id="p9">**</ept><bpt id="p10">_</bpt>yes<ept id="p10">_</ept>&amp;#124;<bpt id="p11">_</bpt>no<ept id="p11">_</ept><bpt id="p12">**</bpt>)<ept id="p12">**</ept>, где <bpt id="p13">*</bpt>expression<ept id="p13">*</ept> — сопоставляемая часть выражения, <bpt id="p14">*</bpt>name<ept id="p14">*</ept> — имя захваченной группы, <bpt id="p15">*</bpt>yes<ept id="p15">*</ept> — сопоставляемая строка, если <bpt id="p16">*</bpt>expression<ept id="p16">*</ept> имеет соответствие или <bpt id="p17">*</bpt>name<ept id="p17">*</ept> является допустимой непустой захваченной группой, а <bpt id="p18">*</bpt>no<ept id="p18">*</ept> — сопоставляемая часть выражения, если <bpt id="p19">*</bpt>expression<ept id="p19">*</ept> не имеет соответствия или <bpt id="p20">*</bpt>name<ept id="p20">*</ept> не является допустимой непустой захваченной группой.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</source>
          <target state="translated">Эта функция позволяет обработчику вести поиск с использованием нескольких альтернативных шаблонов в зависимости от результатов сопоставлений предыдущей части выражения или утверждения нулевой ширины.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</source>
          <target state="translated">Это более действенный вид обратной ссылки, позволяющий, например, искать соответствия части выражения в зависимости от соответствия предыдущей части выражения.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The regular expression in the following example matches paragraphs that are intended for both public and internal use.</source>
          <target state="translated">Регулярное выражение в следующем примере соответствует абзацам, предназначенным для общего и внутреннего использования.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Paragraphs intended only for internal use begin with a <ph id="ph1">`&lt;PRIVATE&gt;`</ph> tag.</source>
          <target state="translated">Абзацы, предназначенные только для внутреннего использования, начинаются с тега <ph id="ph1">`&lt;PRIVATE&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^(?&lt;Pvt&gt;\&lt;PRIVATE\&gt;\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$`</ph> uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`^(?&lt;Pvt&gt;\&lt;PRIVATE\&gt;\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$`</ph> использует условную оценку для назначения содержимого абзацев, предназначенных для общего и внутреннего использования, для отдельных захваченных групп.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>These paragraphs can then be handled differently.</source>
          <target state="translated">Поэтому эти абзацы можно обработать по-разному.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">Шаблон регулярного выражения определяется, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of a line.</source>
          <target state="translated">Начало совпадения в начале строки.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of the string <ph id="ph1">`&lt;PRIVATE&gt;`</ph> followed by a white-space character.</source>
          <target state="translated">Соответствует вхождениям в количестве 0 или 1 строки <ph id="ph1">`&lt;PRIVATE&gt;`</ph> за которым следует символ пробела.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Assign the match to a capturing group named Pvt.</source>
          <target state="translated">Назначение соответствия для захваченной группы с именем.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Pvt`</ph> capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</source>
          <target state="translated">Если захваченная группа <ph id="ph1">`Pvt`</ph> существует, сопоставление одного или нескольких вхождений одного или нескольких вхождений символов слов, за которыми следует 0 или 1 пунктуационный разделитель с последующим любым пробелом.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Assign the substring to the first capturing group.</source>
          <target state="translated">Назначение части строки первой захваченной группе.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Pvt`</ph> capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</source>
          <target state="translated">Если захваченная группа <ph id="ph1">`Pvt`</ph> не существует, сопоставление одного или нескольких вхождений одного или нескольких вхождений символов слов, за которыми следует 0 или 1 пунктуационный разделитель с последующим любым пробелом.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Assign the substring to the third capturing group.</source>
          <target state="translated">Назначение части строки третьей захваченной группе.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Match the end of a line or the end of the string.</source>
          <target state="translated">Соответствует концу строки.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>For more information about conditional evaluation, see <bpt id="p1">[</bpt>Alternation constructs in regular expressions<ept id="p1">](alternation.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об условной оценке см. в статье <bpt id="p1">[</bpt>Конструкции изменения в регулярных выражениях<ept id="p1">](alternation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Balancing group definitions</source>
          <target state="translated">Сбалансированные определения группы</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Balancing group definitions: <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name1-name2<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</source>
          <target state="translated">Сбалансированные определения группы:<bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name1-name2<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</source>
          <target state="translated">Эта функция позволяет обработчику регулярных выражений отслеживать вложенные конструкции, такие как скобки или открывающие и закрывающие круглые скобки.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>For an example, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Пример см. в статье <bpt id="p1">[</bpt>Конструкции группировки в регулярных выражениях<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpressions</source>
          <target state="translated">Невозвращающиеся части выражения</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpressions (also known as greedy subexpressions): <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">Невозвращающиеся ("жадные") части выражения: <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</source>
          <target state="translated">Эта функция обеспечивает для подвыражения верность только первого соответствия, как будто выражение запускалось независимо от содержащего его выражения.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</source>
          <target state="translated">Без этой конструкции поиск в большом выражении с использованием поиска с возвратом может изменить поведение части выражения.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`(a+)\w`</ph> matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the <ph id="ph2">`\w`</ph> language element and is not included in the captured group.</source>
          <target state="translated">Например, регулярное выражение <ph id="ph1">`(a+)\w`</ph> соответствует одному или нескольким символам "a" наряду с буквой, после которой идет последовательность символов "a", и назначает последовательность символов "a" для первой захваченной группы. Однако если последний символ входной строки также является символом "a", он соответствует элементу языка <ph id="ph2">`\w`</ph> и не входит в захваченную группу.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`((?&gt;a+))\w`</ph> prevents this behavior.</source>
          <target state="translated">Регулярное выражение <ph id="ph1">`((?&gt;a+))\w`</ph> препятствует такому поведению.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</source>
          <target state="translated">Поскольку все последовательные символы "a" имеют соответствия без поиска с возвратом, первая захваченная группа содержит все последовательные символы "a".</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>If the "a" characters are not followed by at least one more character other than "a", the match fails.</source>
          <target state="translated">Если после символов "a" не следует ни один символ, отличный от "a", соответствие считается неудачным.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For more information about nonbacktracking subexpressions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о невозвращающихся частях выражений см. в статье <bpt id="p1">[</bpt>Конструкции группировки в регулярных выражениях<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Right-to-left matching</source>
          <target state="translated">Поиск совпадений справа налево</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Right-to-left matching, which is specified by supplying the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option to a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static instance matching method.</source>
          <target state="translated">Поиск совпадений справа налево, задаваемый путем передачи параметра <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> конструктору класса <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> или методу сопоставления статических экземпляров.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</source>
          <target state="translated">Эта функция полезна при поиске справа налево вместо обычного поиска слева направо, а также бывает более эффективно начинать поиск с правой части шаблона, а не с левой.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</source>
          <target state="translated">Как показано в примере ниже, использование поиска соответствий справа налево может изменить поведение жадных квантификаторов.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The example conducts two searches for a sentence that ends in a number.</source>
          <target state="translated">В примере выполняется два поисковых запроса предложения, оканчивающегося на число.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The left-to-right search that uses the greedy quantifier <ph id="ph1">`+`</ph> matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</source>
          <target state="translated">При поиске слева направо с использованием жадного квантификатора <ph id="ph1">`+`</ph> имеется соответствие одной из шести цифр в предложении, тогда как при поиске справа налево — всем шести цифрам.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>For an description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</source>
          <target state="translated">Описание шаблона регулярного выражения см. в примере с ленивыми квантификаторами ранее в этом разделе.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>For more information about right-to-left matching, see <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о поиске соответствий справа налево см. в статье <bpt id="p1">[</bpt>Параметры регулярных выражений<ept id="p1">](options.md)</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Positive and negative lookbehind</source>
          <target state="translated">Положительный и отрицательный поиск назад</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Positive and negative lookbehind: <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> for positive lookbehind, and <bpt id="p4">**</bpt>(?&lt;!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> for negative lookbehind.</source>
          <target state="translated">Положительный и отрицательный поиск назад: <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> для положительного поиска назад и <bpt id="p4">**</bpt>(?&lt;!<ept id="p4">**</ept><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> для отрицательного поиска назад.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>This feature is similar to lookahead, which is discussed earlier in this topic.</source>
          <target state="translated">Эта функция аналогична поиску вперед, рассмотренному ранее в этом разделе.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</source>
          <target state="translated">Поскольку обработчик регулярных выражений позволяет выполнять поиск справа налево, к регулярным выражениям можно применять поиск назад без каких-либо ограничений.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</source>
          <target state="translated">С помощью положительного и отрицательного поиска назад также можно избегать вложенных квантификаторов, когда вложенная часть выражения является супермножеством внешнего выражения.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Regular expressions with such nested quantifiers often offer poor performance.</source>
          <target state="translated">Регулярные выражения с такими вложенными квантификаторами часто являются причиной низкой производительности.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</source>
          <target state="translated">В следующем примере выполняется проверка, начинается ли и оканчивается ли строка с буквы или цифры, а также является ли любой другой символ в строке символом большего подмножества.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>It forms a portion of the regular expression used to validate e-mail addresses; for more information, see <bpt id="p1">[</bpt>How to: Verify that Strings Are in Valid Email Format<ept id="p1">](verify-format.md)</ept>.</source>
          <target state="translated">В результате формируется часть регулярного выражения, используемая для проверки адресов электронной почты. Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Практическое руководство. Проверка строк на соответствие формату электронной почты<ept id="p1">](verify-format.md)</ept>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^[A-Z0-9]([-!#$%&amp;'.*+/=?^`</ph>{}|~\w])*(?&lt;=[A-Z0-9])$` is defined as shown in the following table.</source>
          <target state="translated">В таблице ниже представлено определение регулярного выражения <ph id="ph1">`^[A-Z0-9]([-!#$%&amp;'.*+/=?^`</ph>{}|~\w])*(?&lt;=[A-Z0-9])$.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">Начало совпадения в начале строки.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Match any numeric or alphanumeric character.</source>
          <target state="translated">Соответствие любому алфавитно-цифровому символу.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>(The comparison is case-insensitive.)</source>
          <target state="translated">(При сравнении регистр не учитывается.)</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`([-!#$%&amp;'.*+/=?^`</ph>{}&amp;#124;~\w])*`</source>
          <target state="translated"><ph id="ph1">`([-!#$%&amp;'.*+/=?^`</ph>{}&amp;#124;~\w])*`</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of any word character, or any of the following characters: -, !, #, $, %, &amp;, ', ., *, +, /, =, ?, ^, `, {, }, &amp;#124;, or ~.</source>
          <target state="translated">Соответствие 0 или нескольким вхождениям любого символа слова или любого следующего символа: -, !, #, $, %, &amp;, ', ., *, +, /, =, ?, ^, `, {, }, &amp;#124;, или ~.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Look behind to the previous character, which must be numeric or alphanumeric.</source>
          <target state="translated">Поиск назад предыдущего символа, который должен являться числом или буквенно-цифровым символом.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>(The comparison is case-insensitive.)</source>
          <target state="translated">(При сравнении регистр не учитывается.)</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>End the match at the end of the string.</source>
          <target state="translated">Совпадение должно заканчиваться в конце строки.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>For more information about positive and negative lookbehind, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о положительном и отрицательном поиске назад см. в статье <bpt id="p1">[</bpt>Конструкции группировки в регулярных выражениях<ept id="p1">](grouping.md)</ept>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Related Topics</source>
          <target state="translated">Связанные разделы</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Заголовок</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Поиск с возвратом<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Provides information about how regular expression backtracking branches to find alternative matches.</source>
          <target state="translated">Сведения об использовании поиска с возвратом для поиска альтернативных соответствий.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Compilation and reuse<ept id="p1">](compilation.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Компиляция и многократное использование<ept id="p1">](compilation.md)</ept></target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Provides information about compiling and reusing regular expressions to increase performance.</source>
          <target state="translated">Сведения о компиляции и многократном использовании регулярных выражений для повышения производительности.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Thread safety<ept id="p1">](thread-safety.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Потокобезопасность<ept id="p1">](thread-safety.md)</ept></target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</source>
          <target state="translated">Сведения о потокобезопасности регулярных выражений и времени синхронизации доступа к объектам регулярных выражений.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET regular expressions<ept id="p1">](regular-expressions.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Регулярные выражения .NET<ept id="p1">](regular-expressions.md)</ept></target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Provides an overview of the programming language aspect of regular expressions.</source>
          <target state="translated">Общие сведения о регулярных выражениях в контексте языка программирования.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The regular expression Object Model<ept id="p1">](object-model.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Объектная модель регулярных выражений<ept id="p1">](object-model.md)</ept></target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Provides information and code examples illustrating how to use the regular expression classes.</source>
          <target state="translated">Сведения об использовании классов регулярных выражений и примеры кода.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression examples<ept id="p1">](regex-examples.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Примеры регулярных выражений<ept id="p1">](regex-examples.md)</ept></target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Contains code examples that illustrate the use of regular expressions in common applications.</source>
          <target state="translated">Примеры кодов, иллюстрирующих использование регулярных выражений в обычных приложениях.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Элементы языка регулярных выражений — краткий справочник<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</source>
          <target state="translated">Сведения о наборе символов, операторов и конструкций, которые можно использовать для определения регулярных выражений.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Ссылка</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>System.Text.RegularExpressions<ept id="p1">](xref:System.Text.RegularExpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Text.RegularExpressions<ept id="p1">](xref:System.Text.RegularExpressions)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>