<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e9601c51468fdf5adab8e521f8f89ee7f2e12869</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\comparison-of-xpath-and-linq-to-xml.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4578e7c54747148d91ae81a440fa01f0bc97206e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b885bdfb008473c4d3ea304db0d166c68a2322b0</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_comparison-of-xpath-and-linq-to-xml.82cef20ea272c2511f600ff1a01142b3a4b4fc11.ru-ru is different with handoff file name: comparison-of-xpath-and-linq-to-xml.82cef20ea272c2511f600ff1a01142b3a4b4fc11.ru-ru.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Comparison of XPath and LINQ to XML1 | Microsoft Docs</source>
          <target state="translated">Сравнение XPath и LINQ to XML1 | Документы Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Comparison of XPath and LINQ to XML</source>
          <target state="translated">Сравнительные характеристики XPath и LINQ to XML</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>XPath and <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> offer some similar functionality.</source>
          <target state="translated">XPath и <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> имеют некоторые сходные функциональные возможности.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Both can be used to query an XML tree, returning such results as a collection of elements, a collection of attributes, a collection of nodes, or the value of an element or attribute.</source>
          <target state="translated">И то и другое можно использовать, чтобы запрашивать XML-дерево для возвращения таких результатов, как коллекция элементов, коллекция атрибутов, коллекция узлов или значение элемента или атрибута.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>However, there are also some differences.</source>
          <target state="translated">Однако между ними также есть некоторые различия.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Differences Between XPath and LINQ to XML</source>
          <target state="translated">Различия между XPath и LINQ to XML</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>XPath does not allow projection of new types.</source>
          <target state="translated">XPath не поддерживает проекции новых типов.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>It can only return collections of nodes from the tree, whereas <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> can execute a query and project an object graph or an XML tree in a new shape.</source>
          <target state="translated">Может возвращать только коллекции узлов из дерева, тогда как <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> может выполнить запрос, проецировав граф объектов или XML-дерево в новой форме.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> queries encompass much more functionality and are much more powerful than XPath expressions.</source>
          <target state="translated">Запросы <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> гораздо более эффективны и обладают большими возможностями, чем выражения XPath.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>XPath expressions exist in isolation within a string.</source>
          <target state="translated">Выражение XPath представлено в изолированном виде, внутри строки.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The Visual Basic compiler cannot help parse the XPath expression at compile time.</source>
          <target state="translated">Компилятор Visual Basic не удается выполнить синтаксический анализ выражения XPath во время компиляции.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>By contrast, <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> queries are parsed and compiled by theVisual Basic compiler.</source>
          <target state="translated">Напротив <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> запросы анализируются и компилируются компилятором основных участников.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The compiler is able to catch many query errors.</source>
          <target state="translated">Компилятор способен обнаруживать многие ошибки запроса.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>XPath results are not strongly typed.</source>
          <target state="translated">Результаты XPath не являются строго типизированными.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In a number of circumstances, the result of evaluating an XPath expression is an object, and it is up to the developer to determine the proper type and cast the result as necessary.</source>
          <target state="translated">В некоторых ситуациях результатом вычисления выражения XPath является объект, а задача определения соответствующего типа и приведения результата в соответствии с необходимостью возлагается на разработчика.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>By contrast, the projections from a <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> query are strongly typed.</source>
          <target state="translated">В отличие от этого, проекции на основе запроса <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> являются строго типизированными.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Result Ordering</source>
          <target state="translated">Упорядочение результатов</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 Recommendation states that a collection that is the result of evaluating an XPath expression is unordered.</source>
          <target state="translated">В документе XPath 1.0 Recommendation указано, что коллекция, которая является результатом вычисления выражения XPath, не упорядочена.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>However, when iterating through a collection returned by a <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> XPath axis method, the nodes in the collection are returned in document order.</source>
          <target state="translated">Однако при просмотре коллекции, возвращенной методом оси <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> XPath, можно отметить, что узлы в коллекции возвращены в том же порядке, что и в документе.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This is the case even when accessing the XPath axes where predicates are expressed in terms of reverse document order, such as <ph id="ph1">`preceding`</ph> and <ph id="ph2">`preceding-sibling`</ph>.</source>
          <target state="translated">И они располагаются так даже при доступе к осям XPath, где предикаты выражены в обратном порядке по отношению к документу, например <ph id="ph1">`preceding`</ph> и <ph id="ph2">`preceding-sibling`</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>By contrast, most of the <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> axes return collections in document order, but two of them, &lt;xref:System.Xml.Linq.XNode.Ancestors%2A&gt; and &lt;xref:System.Xml.Linq.XElement.AncestorsAndSelf%2A&gt;, return collections in reverse document order.</source>
          <target state="translated">Напротив, большинство <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> осей возвращают коллекции в порядке документа, однако две из них, &lt;xref:System.Xml.Linq.XNode.Ancestors%2A&gt;и &lt;xref:System.Xml.Linq.XElement.AncestorsAndSelf%2A&gt;, возвращают коллекции в обратном порядке документа.&lt;/xref:System.Xml.Linq.XElement.AncestorsAndSelf%2A&gt; &lt;/xref:System.Xml.Linq.XNode.Ancestors%2A&gt;</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The following table enumerates the axes, and indicates collection order for each:</source>
          <target state="translated">В следующей таблице перечисляются эти оси и указывается порядок коллекций для каждой из них.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>LINQ to XML axis</source>
          <target state="translated">Ось LINQ to XML</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Упорядочение</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>XContainer.DescendantNodes</source>
          <target state="translated">XContainer.DescendantNodes</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>XContainer.Descendants</source>
          <target state="translated">XContainer.Descendants</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>XContainer.Elements</source>
          <target state="translated">XContainer.Elements</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>XContainer.Nodes</source>
          <target state="translated">XContainer.Nodes</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>XContainer.NodesAfterSelf</source>
          <target state="translated">XContainer.NodesAfterSelf</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>XContainer.NodesBeforeSelf</source>
          <target state="translated">XContainer.NodesBeforeSelf</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>XElement.AncestorsAndSelf</source>
          <target state="translated">XElement.AncestorsAndSelf</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Reverse document order</source>
          <target state="translated">Обратный порядок документа</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>XElement.Attributes</source>
          <target state="translated">XElement.Attributes</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>XElement.DescendantNodesAndSelf</source>
          <target state="translated">XElement.DescendantNodesAndSelf</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>XElement.DescendantsAndSelf</source>
          <target state="translated">XElement.DescendantsAndSelf</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>XNode.Ancestors</source>
          <target state="translated">XNode.Ancestors</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Reverse document order</source>
          <target state="translated">Обратный порядок документа</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>XNode.ElementsAfterSelf</source>
          <target state="translated">XNode.ElementsAfterSelf</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>XNode.ElementsBeforeSelf</source>
          <target state="translated">XNode.ElementsBeforeSelf</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>XNode.NodesAfterSelf</source>
          <target state="translated">XNode.NodesAfterSelf</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>XNode.NodesBeforeSelf</source>
          <target state="translated">XNode.NodesBeforeSelf</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Document order</source>
          <target state="translated">Порядок документа</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Positional Predicates</source>
          <target state="translated">Позиционные предикаты</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Within an XPath expression, positional predicates are expressed in terms of document order for many axes, but are expressed in reverse document order for reverse axes, which are <ph id="ph1">`preceding`</ph>, <ph id="ph2">`preceding-sibling`</ph>, <ph id="ph3">`ancestor`</ph>, and <ph id="ph4">`ancestor-or-self`</ph>.</source>
          <target state="translated">В выражении XPath позиционные предикаты представляются с учетом порядка расположения в документе для многих осей, однако они располагаются в порядке, обратном по отношению к документу, для обратных осей, а именно <ph id="ph1">`preceding`</ph>, <ph id="ph2">`preceding-sibling`</ph>, <ph id="ph3">`ancestor`</ph> и <ph id="ph4">`ancestor-or-self`</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For example, the XPath expression <ph id="ph1">`preceding-sibling::*[1]`</ph> returns the immediately preceding sibling.</source>
          <target state="translated">Например, выражение XPath <ph id="ph1">`preceding-sibling::*[1]`</ph> возвращает ближайший предшествующий одноуровневый элемент.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This is the case even though the final result set is presented in document order.</source>
          <target state="translated">Так происходит даже несмотря на то, что итоговый результирующий набор представляется в порядке документа.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>By contrast, all positional predicates in LINQ to XML are always expressed in terms of the order of the axis.</source>
          <target state="translated">В отличие от этого все позиционные предикаты в LINQ to XML всегда выражаются в порядке оси.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`anElement.ElementsBeforeSelf().ToList()[0]`</ph> returns the first child element of the parent of the queried element, not the immediate preceding sibling.</source>
          <target state="translated">Например, <ph id="ph1">`anElement.ElementsBeforeSelf().ToList()[0]`</ph> возвращает первый дочерний элемент родителя запрашиваемого элемента, а не ближайший предшествующий одноуровневый элемент.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Another example: <ph id="ph1">`anElement.Ancestors().ToList()[0]`</ph> returns the parent element.</source>
          <target state="translated">Другой пример: <ph id="ph1">`anElement.Ancestors().ToList()[0]`</ph> возвращает родительский элемент.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Note that the above approach materializes the entire collection.</source>
          <target state="translated">Отметим, что при описанном выше подходе материализуется вся коллекция.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This is not the most efficient way to write that query.</source>
          <target state="translated">Это не самый эффективный способ написания такого запроса.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>It was written in that way to demonstrate the behavior of positional predicates.</source>
          <target state="translated">Запрос был написан так в целях демонстрации поведения позиционных предикатов.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A more appropriate way to write the same query is to use the &lt;xref:System.Linq.Enumerable.First%2A&gt; method, as follows: <ph id="ph1">`anElement.ElementsBeforeSelf().First()`</ph>.</source>
          <target state="translated">Более подходящим способом написания этого же запроса является использование &lt;xref:System.Linq.Enumerable.First%2A&gt;метод следующим образом: <ph id="ph1">`anElement.ElementsBeforeSelf().First()`</ph>.&lt;/xref:System.Linq.Enumerable.First%2A&gt;</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If you wanted to find the immediately preceding element in <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, you would write the following expression:</source>
          <target state="translated">Если бы потребовалось найти ближайший предшествующий элемент в <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, то было бы написано следующее выражение:</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Performance Differences</source>
          <target state="translated">Различия в производительности</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>XPath queries that use the XPath functionality in <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> will not perform as well as <ph id="ph2">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> queries.</source>
          <target state="translated">Запросы XPath, которые используют функциональность XPath в <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> будет работать так же как <ph id="ph2">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> запросов.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Comparison of Composition</source>
          <target state="translated">Сравнение композиций</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Composition of a <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> query is somewhat parallel to composition of an XPath expression, although very different in syntax.</source>
          <target state="translated">Композиция запроса <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> немного напоминает композицию выражения XPath, хотя по синтаксису они совершенно различны.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example, if you have an element in a variable named <ph id="ph1">`customers`</ph>, and you want to find a grandchild element named <ph id="ph2">`CompanyName`</ph> under all child elements named <ph id="ph3">`Customer`</ph>, you would write an XPath expression as follows:</source>
          <target state="translated">Например, если в переменной с именем <ph id="ph1">`customers`</ph> имеется элемент и требуется найти внучатый элемент с именем <ph id="ph2">`CompanyName`</ph> во всех дочерних элементах с именем <ph id="ph3">`Customer`</ph>, то нужно написать следующее выражение XPath:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The equivalent <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> query is:</source>
          <target state="translated">Эквивалентное выражение <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> таково:</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>There are similar parallels for each of the XPath axes.</source>
          <target state="translated">Существуют похожие аналоги для каждой оси XPath.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>XPath axis</source>
          <target state="translated">Ось XPath</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>LINQ to XML axis</source>
          <target state="translated">Ось LINQ to XML</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>child (the default axis)</source>
          <target state="translated">дочерняя (ось по умолчанию)</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XContainer.Elements%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XContainer.Elements%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XContainer.Elements%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Parent (..)</source>
          <target state="translated">родительская (...)</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XObject.Parent%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XObject.Parent%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XObject.Parent%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>attribute axis (@)</source>
          <target state="translated">ось атрибутов (@)</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XElement.Attribute%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XElement.Attribute%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XElement.Attribute%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">или</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XElement.Attributes%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XElement.Attributes%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XElement.Attributes%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>ancestor axis</source>
          <target state="translated">ось ancestor</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XNode.Ancestors%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XNode.Ancestors%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XNode.Ancestors%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>ancestor-or-self axis</source>
          <target state="translated">ось ancestor-or-self</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XElement.AncestorsAndSelf%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XElement.AncestorsAndSelf%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XElement.AncestorsAndSelf%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>descendant axis (//)</source>
          <target state="translated">дочерняя ось (//)</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XContainer.Descendants%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XContainer.Descendants%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XContainer.Descendants%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">или</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XContainer.DescendantNodes%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XContainer.DescendantNodes%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XContainer.DescendantNodes%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>descendant-or-self</source>
          <target state="translated">descendant-or-self</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XElement.DescendantsAndSelf%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XElement.DescendantsAndSelf%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XElement.DescendantsAndSelf%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">или</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XElement.DescendantNodesAndSelf%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XElement.DescendantNodesAndSelf%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XElement.DescendantNodesAndSelf%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>following-sibling</source>
          <target state="translated">following-sibling</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XNode.ElementsAfterSelf%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XNode.ElementsAfterSelf%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XNode.ElementsAfterSelf%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">или</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XNode.NodesAfterSelf%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XNode.NodesAfterSelf%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XNode.NodesAfterSelf%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>preceding-sibling</source>
          <target state="translated">preceding-sibling</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XNode.ElementsBeforeSelf%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XNode.ElementsBeforeSelf%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XNode.ElementsBeforeSelf%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">или</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Xml.Linq.XNode.NodesBeforeSelf%2A?displayProperty=fullName&gt;</source>
          <target state="translated">&lt;xref:System.Xml.Linq.XNode.NodesBeforeSelf%2A?displayProperty=fullName&gt;&lt;/xref:System.Xml.Linq.XNode.NodesBeforeSelf%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>following</source>
          <target state="translated">following</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>No direct equivalent.</source>
          <target state="translated">Непосредственного эквивалента нет.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>preceding</source>
          <target state="translated">preceding</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>No direct equivalent.</source>
          <target state="translated">Непосредственного эквивалента нет.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">См. также</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>LINQ to XML for XPath Users (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/linq-to-xml-for-xpath-users.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>LINQ to XML для пользователей XPath (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/linq-to-xml-for-xpath-users.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>