<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e50593e76afecfe8807c3cb5bac479245d2feaef</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\procedures\lambda-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">895acd633a8cda2558af76ac524637fade1ae4a5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">517194bfb46ad17da82f6dda81810b1bb170a967</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_lambda-expressions.516f232819026ed497132389f62b2de45bffff48.ru-ru is different with handoff file name: lambda-expressions.516f232819026ed497132389f62b2de45bffff48.ru-ru.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Lambda Expressions (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Лямбда-выражения (Visual Basic) | Документы Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Lambda Expressions (Visual Basic)</source>
          <target state="translated">Лямбда-выражения (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>lambda expression<ept id="p1">*</ept> is a function or subroutine without a name that can be used wherever a delegate is valid.</source>
          <target state="translated">Объект <bpt id="p1">*</bpt>лямбда-выражение<ept id="p1">*</ept> является функцией или подпрограммой без имени, которую можно использовать везде, где допустим делегат.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be functions or subroutines and can be single-line or multi-line.</source>
          <target state="translated">Лямбда-выражения могут быть функциями или подпрограммами и может быть одной или нескольких строк.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can pass values from the current scope to a lambda expression.</source>
          <target state="translated">Лямбда-выражение можно передавать значения из текущей области.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`RemoveHandler`</ph> statement is an exception.</source>
          <target state="translated"><ph id="ph1">`RemoveHandler`</ph> Инструкция является исключением.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You cannot pass a lambda expression in for the delegate parameter of <ph id="ph1">`RemoveHandler`</ph>.</source>
          <target state="translated">Невозможно передать лямбда-выражение в параметра делегата для <ph id="ph1">`RemoveHandler`</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You create lambda expressions by using the <ph id="ph1">`Function`</ph> or <ph id="ph2">`Sub`</ph> keyword, just as you create a standard function or subroutine.</source>
          <target state="translated">Лямбда-выражения создаются с помощью <ph id="ph1">`Function`</ph> или <ph id="ph2">`Sub`</ph> ключевое слово, так же как стандартные функции или подпрограммы.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>However, lambda expressions are included in a statement.</source>
          <target state="translated">Однако лямбда-выражения включаются в оператор.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following example is a lambda expression that increments its argument and returns the value.</source>
          <target state="translated">Следующий пример является лямбда-выражение, которое увеличивает значение своего аргумента и возвращает значение.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The example shows both the single-line and multi-line lambda expression syntax for a function.</source>
          <target state="translated">В этом примере синтаксис однострочные и многострочные лямбда-выражения для функции.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#14<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#14;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The following example is a lambda expression that writes a value to the console.</source>
          <target state="translated">Следующий пример является лямбда-выражения, записывающего значение на консоль.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The example shows both the single-line and multi-line lambda expression syntax for a subroutine.</source>
          <target state="translated">В этом примере синтаксис однострочные и многострочные лямбда-выражения для подпрограммы.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#15<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#15;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Notice that in the previous examples the lambda expressions are assigned to a variable name.</source>
          <target state="translated">Обратите внимание, что в предыдущих примерах лямбда-выражения назначены имя переменной.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Whenever you refer to the variable, you invoke the lambda expression.</source>
          <target state="translated">При каждом обращении к переменной вызывается лямбда-выражение.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can also declare and invoke a lambda expression at the same time, as shown in the following example.</source>
          <target state="translated">Можно также объявить и вызвать лямбда-выражение, в то же время, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#3<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#3;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A lambda expression can be returned as the value of a function call (as is shown in the example in the <bpt id="p1">[</bpt>Context<ept id="p1">](#context)</ept> section later in this topic), or passed in as an argument to a parameter that takes a delegate type, as shown in the following example.</source>
          <target state="translated">Лямбда-выражения могут возвращаться как значение вызванной функции (как показано в примере в <bpt id="p1">[</bpt>контекста<ept id="p1">](#context)</ept> позже в этой статье), либо передано в качестве аргумента параметр, который принимает тип делегата, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#8<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas №&amp;8;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Lambda Expression Syntax</source>
          <target state="translated">Синтаксис лямбда-выражений</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The syntax of a lambda expression resembles that of a standard function or subroutine.</source>
          <target state="translated">Синтаксис лямбда-выражения похож стандартные функции или подпрограммы.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The differences are as follows:</source>
          <target state="translated">Ниже приведены различия.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A lambda expression does not have a name.</source>
          <target state="translated">Лямбда-выражение не имеет имени.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Lambda expressions cannot have modifiers, such as <ph id="ph1">`Overloads`</ph> or <ph id="ph2">`Overrides`</ph>.</source>
          <target state="translated">Лямбда-выражения не могут иметь модификаторы, такие как <ph id="ph1">`Overloads`</ph> или <ph id="ph2">`Overrides`</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Single-line lambda functions do not use an <ph id="ph1">`As`</ph> clause to designate the return type.</source>
          <target state="translated">Однострочные лямбда-функции не используют <ph id="ph1">`As`</ph> предложения, чтобы указать тип возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Instead, the type is inferred from the value that the body of the lambda expression evaluates to.</source>
          <target state="translated">Вместо этого тип выводится из значения, результатом которого является тело лямбда-выражения.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For example, if the body of the lambda expression is <ph id="ph1">`cust.City = "London"`</ph>, its return type is <ph id="ph2">`Boolean`</ph>.</source>
          <target state="translated">Например, если тело лямбда-выражения — <ph id="ph1">`cust.City = "London"`</ph>, возвращается тип <ph id="ph2">`Boolean`</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>In multi-line lambda functions, you can either specify a return type by using an <ph id="ph1">`As`</ph> clause, or omit the <ph id="ph2">`As`</ph> clause so that the return type is inferred.</source>
          <target state="translated">В многострочных лямбда-функции, можно указать тип возвращаемого значения с помощью <ph id="ph1">`As`</ph> предложение, или пропускать <ph id="ph2">`As`</ph> предложение, чтобы вывести тип возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`As`</ph> clause is omitted for a multi-line lambda function, the return type is inferred to be the dominant type from all the <ph id="ph2">`Return`</ph> statements in the multi-line lambda function.</source>
          <target state="translated">Когда <ph id="ph1">`As`</ph> опущен для многострочных лямбда-функции, возвращаемый тип определяется как главный тип из всех <ph id="ph2">`Return`</ph> инструкций в многострочных лямбда-функции.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>dominant type<ept id="p1">*</ept> is a unique type that all other types can widen to.</source>
          <target state="translated"><bpt id="p1">*</bpt>Главный тип<ept id="p1">*</ept> — это уникальный тип, могут быть расширены все другие типы.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If this unique type cannot be determined, the dominant type is the unique type that all other types in the array can narrow to.</source>
          <target state="translated">Если такой уникальный тип нельзя определить, главным типом будет тип, до которого можно сузить все другие типы массива.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If neither of these unique types can be determined, the dominant type is <ph id="ph1">`Object`</ph>.</source>
          <target state="translated">Если ни один из указанных уникальных типов нельзя определить, главным типом будет <ph id="ph1">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In this case, if <ph id="ph1">`Option Strict`</ph> is set to <ph id="ph2">`On`</ph>, a compiler error occurs.</source>
          <target state="translated">В этом случае если <ph id="ph1">`Option Strict`</ph> равен <ph id="ph2">`On`</ph>, возникает ошибка компилятора.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, if the expressions supplied to the <ph id="ph1">`Return`</ph> statement contain values of type <ph id="ph2">`Integer`</ph>, <ph id="ph3">`Long`</ph>, and <ph id="ph4">`Double`</ph>, the resulting array is of type <ph id="ph5">`Double`</ph>.</source>
          <target state="translated">Например, если передан выражения <ph id="ph1">`Return`</ph> инструкции содержат значения типа <ph id="ph2">`Integer`</ph>, <ph id="ph3">`Long`</ph>, и <ph id="ph4">`Double`</ph>, полученный массив имеет тип <ph id="ph5">`Double`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">`Integer`</ph> and <ph id="ph2">`Long`</ph> widen to <ph id="ph3">`Double`</ph> and only <ph id="ph4">`Double`</ph>.</source>
          <target state="translated">Оба <ph id="ph1">`Integer`</ph> и <ph id="ph2">`Long`</ph> расширяются до <ph id="ph3">`Double`</ph> и только <ph id="ph4">`Double`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Therefore, <ph id="ph1">`Double`</ph> is the dominant type.</source>
          <target state="translated">Поэтому <ph id="ph1">`Double`</ph> является главным типом.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Widening and Narrowing Conversions<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>расширяющие и сужающие преобразования<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The body of a single-line function must be an expression that returns a value, not a statement.</source>
          <target state="translated">Тело функции однострочный должно быть выражение, возвращающее значение, а не оператором.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>There is no <ph id="ph1">`Return`</ph> statement for single-line functions.</source>
          <target state="translated">Существует не <ph id="ph1">`Return`</ph> инструкции для однострочных функций.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The value returned by the single-line function is the value of the expression in the body of the function.</source>
          <target state="translated">Значение, возвращаемое функцией однострочный значение выражения в теле функции.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The body of a single-line subroutine must be single-line statement.</source>
          <target state="translated">Тело подпрограммы однострочный должно быть одностроковый оператор.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Single-line functions and subroutines do not include an <ph id="ph1">`End Function`</ph> or <ph id="ph2">`End Sub`</ph> statement.</source>
          <target state="translated">Не включайте однострочных функций и подпрограмм <ph id="ph1">`End Function`</ph> или <ph id="ph2">`End Sub`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can specify the data type of a lambda expression parameter by using the <ph id="ph1">`As`</ph> keyword, or the data type of the parameter can be inferred.</source>
          <target state="translated">Тип данных параметра лямбда-выражения можно указать с помощью <ph id="ph1">`As`</ph> ключевое слово или тип данных параметра может быть выведен.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Either all parameters must have specified data types or all must be inferred.</source>
          <target state="translated">Все параметры должно было быть задано, что необходимо определить типы данных или все.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Optional`</ph> and <ph id="ph2">`Paramarray`</ph> parameters are not permitted.</source>
          <target state="translated"><ph id="ph1">`Optional`</ph>и <ph id="ph2">`Paramarray`</ph> параметры не допускаются.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Generic parameters are not permitted.</source>
          <target state="translated">Универсальные параметры не допускаются.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Async Lambdas</source>
          <target state="translated">Асинхронные лямбда-выражения</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can easily create lambda expressions and statements that incorporate asynchronous processing by using the <bpt id="p1">[</bpt>Async<ept id="p1">](../../../../visual-basic/language-reference/modifiers/async.md)</ept> and <bpt id="p2">[</bpt>Await Operator<ept id="p2">](../../../../visual-basic/language-reference/operators/await-operator.md)</ept> keywords.</source>
          <target state="translated">Можно легко создавать лямбда-выражения и операторы, включающие асинхронную обработку с помощью <bpt id="p1">[</bpt>Async<ept id="p1">](../../../../visual-basic/language-reference/modifiers/async.md)</ept> и <bpt id="p2">[</bpt>оператор Await<ept id="p2">](../../../../visual-basic/language-reference/operators/await-operator.md)</ept> ключевые слова.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, the following Windows Forms example contains an event handler that calls and awaits an async method, <ph id="ph1">`ExampleMethodAsync`</ph>.</source>
          <target state="translated">Например, в следующем примере Windows Forms содержится обработчик событий, который вызывает асинхронный метод <ph id="ph1">`ExampleMethodAsync`</ph>и ожидает его.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can add the same event handler by using an async lambda in an <bpt id="p1">[</bpt>AddHandler Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/addhandler-statement.md)</ept>.</source>
          <target state="translated">Можно добавить тот же обработчик событий с помощью асинхронного лямбда-выражения в <bpt id="p1">[</bpt>оператор AddHandler<ept id="p1">](../../../../visual-basic/language-reference/statements/addhandler-statement.md)</ept>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>To add this handler, add an <ph id="ph1">`Async`</ph> modifier before the lambda parameter list, as the following example shows.</source>
          <target state="translated">Чтобы добавить этот обработчик, поставьте модификатор <ph id="ph1">`Async`</ph> перед списком параметров лямбда-выражения, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For more information about how to create and use async methods, see <bpt id="p1">[</bpt>Asynchronous Programming with Async and Await<ept id="p1">](../../../../visual-basic/programming-guide/concepts/async/index.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о том, как создавать и использовать асинхронные методы см. в разделе <bpt id="p1">[</bpt>асинхронное программирование с использованием Async и Await<ept id="p1">](../../../../visual-basic/programming-guide/concepts/async/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="context"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Context</source>
          <target state="translated"><bpt id="p1">&lt;a name="context"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept>Контекст</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>A lambda expression shares its context with the scope within which it is defined.</source>
          <target state="translated">Лямбда-выражение использует общий контекст с областью, в которой он определен.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It has the same access rights as any code written in the containing scope.</source>
          <target state="translated">Он имеет те же права доступа, что любой код, написанный в содержащей области.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This includes access to member variables, functions and subs, <ph id="ph1">`Me`</ph>, and parameters and local variables in the containing scope.</source>
          <target state="translated">Это включает доступ к переменным-членам, функции и подпрограммы, <ph id="ph1">`Me`</ph>и параметры, так и локальные переменные в содержащей области.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Access to local variables and parameters in the containing scope can extend beyond the lifetime of that scope.</source>
          <target state="translated">Доступ к локальным переменным и параметрам в содержащей области можно продлить сверх времени существования этой области.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>As long as a delegate referring to a lambda expression is not available to garbage collection, access to the variables in the original environment is retained.</source>
          <target state="translated">При условии, что делегат, относящийся к лямбда-выражение не доступен для сборки мусора, доступ к переменным среды исходного кода сохраняется.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>In the following example, variable <ph id="ph1">`target`</ph> is local to <ph id="ph2">`makeTheGame`</ph>, the method in which the lambda expression <ph id="ph3">`playTheGame`</ph> is defined.</source>
          <target state="translated">В следующем примере переменная <ph id="ph1">`target`</ph> является локальным для <ph id="ph2">`makeTheGame`</ph>, метод которого лямбда-выражение <ph id="ph3">`playTheGame`</ph> определен.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Note that the returned lambda expression, assigned to <ph id="ph1">`takeAGuess`</ph> in <ph id="ph2">`Main`</ph>, still has access to the local variable <ph id="ph3">`target`</ph>.</source>
          <target state="translated">Обратите внимание, что возвращаемое лямбда-выражения, назначенные <ph id="ph1">`takeAGuess`</ph> в <ph id="ph2">`Main`</ph>, по-прежнему есть доступ к локальной переменной <ph id="ph3">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#12<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_5.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#12;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_5.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the wide range of access rights of the nested lambda expression.</source>
          <target state="translated">В следующем примере показано широкий спектр прав доступа вложенных лямбда-выражения.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When the returned lambda expression is executed from <ph id="ph1">`Main`</ph> as <ph id="ph2">`aDel`</ph>, it accesses these elements:</source>
          <target state="translated">При выполнении возвращаемого лямбда-выражения из <ph id="ph1">`Main`</ph> как <ph id="ph2">`aDel`</ph>, он обращается к следующим элементам:</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>A field of the class in which it is defined: <ph id="ph1">`aField`</ph></source>
          <target state="translated">Поле класса, в котором он определен:<ph id="ph1">`aField`</ph></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>A property of the class in which it is defined: <ph id="ph1">`aProp`</ph></source>
          <target state="translated">Свойство класса, в котором он определен:<ph id="ph1">`aProp`</ph></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A parameter of method <ph id="ph1">`functionWithNestedLambda`</ph>, in which it is defined: <ph id="ph2">`level1`</ph></source>
          <target state="translated">Параметр метода <ph id="ph1">`functionWithNestedLambda`</ph>, в котором он определен:<ph id="ph2">`level1`</ph></target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A local variable of <ph id="ph1">`functionWithNestedLambda`</ph>: <ph id="ph2">`localVar`</ph></source>
          <target state="translated">Локальная переменная <ph id="ph1">`functionWithNestedLambda`</ph>:<ph id="ph2">`localVar`</ph></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A parameter of the lambda expression in which it is nested: <ph id="ph1">`level2`</ph></source>
          <target state="translated">Параметр лямбда-выражения, в котором он является вложенным:<ph id="ph1">`level2`</ph></target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#9<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_6.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas №&amp;9;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_6.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Converting to a Delegate Type</source>
          <target state="translated">Преобразование к типу делегата</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>A lambda expression can be implicitly converted to a compatible delegate type.</source>
          <target state="translated">Лямбда-выражения могут быть неявно преобразованы к совместимому типу делегата.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For information about the general requirements for compatibility, see <bpt id="p1">[</bpt>Relaxed Delegate Conversion<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept>.</source>
          <target state="translated">Сведения об общих требованиях для совместимости см. в разделе <bpt id="p1">[</bpt>неявное преобразование делегата<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For example, the following code example shows a lambda expression that implicitly converts to <ph id="ph1">`Func(Of Integer, Boolean)`</ph> or a matching delegate signature.</source>
          <target state="translated">Например, в следующем примере кода показано лямбда-выражение, которое неявно преобразуется к <ph id="ph1">`Func(Of Integer, Boolean)`</ph> или соответствующей сигнатуре делегата.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#16<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_7.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas №&amp;16;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_7.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The following code example shows a lambda expression that implicitly converts to <ph id="ph1">`Sub(Of Double, String, Double)`</ph> or a matching delegate signature.</source>
          <target state="translated">В следующем примере кода показано лямбда-выражение, которое неявно преобразуется к <ph id="ph1">`Sub(Of Double, String, Double)`</ph> или соответствующей сигнатуре делегата.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#23<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_8.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#23;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_8.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>When you assign lambda expressions to delegates or pass them as arguments to procedures, you can specify the parameter names but omit their data types, letting the types be taken from the delegate.</source>
          <target state="translated">При присваивании лямбда-выражений делегатам или передавать их в качестве аргументов для процедуры, можно указать имена параметров, но опустить их типы, позволяя принимать типы из делегата.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Примеры</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The following example defines a lambda expression that returns <ph id="ph1">`True`</ph> if the nullable argument has an assigned value, and <ph id="ph2">`False`</ph> if its value is <ph id="ph3">`Nothing`</ph>.</source>
          <target state="translated">В следующем примере определяется лямбда-выражение, возвращающее <ph id="ph1">`True`</ph> Если аргументу типа nullable было присвоено значение, и <ph id="ph2">`False`</ph> имеет значение <ph id="ph3">`Nothing`</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#4<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_9.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#4;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_9.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following example defines a lambda expression that returns the index of the last element in an array.</source>
          <target state="translated">В следующем примере определяется лямбда-выражение, возвращающее индекс последнего элемента в массиве.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas#5<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_10.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrLambdas&amp;#5;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/lambda-expressions_10.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">См. также</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Procedures<ept id="p1">](./index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Процедуры<ept id="p1">](./index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Introduction to LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Введение в LINQ в Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Delegates<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Делегаты<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Function Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/function-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Оператор Function<ept id="p1">](../../../../visual-basic/language-reference/statements/function-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Sub Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/sub-statement.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Оператор Sub<ept id="p1">](../../../../visual-basic/language-reference/statements/sub-statement.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Nullable Value Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/nullable-value-types.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Обнуляемые типы значений<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/nullable-value-types.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Pass Procedures to Another Procedure in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/how-to-pass-procedures-to-another-procedure.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Практическое руководство: передача процедур другой процедуре в Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/how-to-pass-procedures-to-another-procedure.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>How to: Create a Lambda Expression<ept id="p1">](./how-to-create-a-lambda-expression.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>Практическое руководство: создание лямбда-выражения<ept id="p1">](./how-to-create-a-lambda-expression.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Relaxed Delegate Conversion<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Неявное преобразование делегата<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>