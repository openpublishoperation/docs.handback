<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cbab7da8c97ca202f8a4d0a1a65b8fa240cca32d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\covariance-contravariance\variance-in-delegates.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">adc4b7a8e4176173779d75c2feb6b4b977377a41</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5c0afe04633a0673fb5ad45f6775338e0e4e9a81</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_variance-in-delegates.ccb121749004f99326e4697e7247cc3646aa2edb.ru-ru is different with handoff file name: variance-in-delegates.ccb121749004f99326e4697e7247cc3646aa2edb.ru-ru.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Variance in Delegates (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Вариативность в делегатах (Visual Basic) | Документы Microsoft</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Variance in Delegates (Visual Basic)</source>
          <target state="translated">Вариативность в делегатах (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET Framework 3.5 introduced variance support for matching method signatures with delegate types in all delegates in C# and Visual Basic.</source>
          <target state="translated">.NET framework 3.5 представила поддержка вариативности при сопоставлении сигнатур методов с типами делегатов в все делегаты в C# и Visual Basic.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This means that you can assign to delegates not only methods that have matching signatures, but also methods that return more derived types (covariance) or that accept parameters that have less derived types (contravariance) than that specified by the delegate type.</source>
          <target state="translated">Это означает, что можно назначить делегирует не только методы, которые обладают соответствующими сигнатурами, но методы, которые возвращают более производные типы (ковариация) или принимают параметры, которые имеют менее производные типы (контравариация), чем указано в типе делегата.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This includes both generic and non-generic delegates.</source>
          <target state="translated">Сюда входят универсальных и неуниверсальных делегатах.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, consider the following code, which has two classes and two delegates: generic and non-generic.</source>
          <target state="translated">Например, рассмотрим следующий код, который содержит два класса и два делегата: универсальный и неуниверсальный.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>When you create delegates of the <ph id="ph1">`SampleDelegate`</ph> or <ph id="ph2">`SampleDelegate(Of A, R)`</ph> types, you can assign any one of the following methods to those delegates.</source>
          <target state="translated">При создании делегатов <ph id="ph1">`SampleDelegate`</ph> или <ph id="ph2">`SampleDelegate(Of A, R)`</ph> типов, можно назначить один из следующих методов этих делегатов.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The following code example illustrates the implicit conversion between the method signature and the delegate type.</source>
          <target state="translated">В следующем примере кода показано неявное преобразование между сигнатуру метода и тип делегата.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more examples, see <bpt id="p1">[</bpt>Using Variance in Delegates (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-in-delegates.md)</ept> and <bpt id="p2">[</bpt>Using Variance for Func and Action Generic Delegates (Visual Basic)<ept id="p2">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept>.</source>
          <target state="translated">Дополнительные примеры см. в разделе <bpt id="p1">[</bpt>с помощью Вариативность в делегатах (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-in-delegates.md)</ept> и <bpt id="p2">[</bpt>с помощью дисперсию Func и Action универсальные делегаты (Visual Basic)<ept id="p2">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Variance in Generic Type Parameters</source>
          <target state="translated">Вариативность в параметрах универсального типа</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In .NET Framework 4 and later you can enable implicit conversion between delegates, so that generic delegates that have different types specified by generic type parameters can be assigned to each other, if the types are inherited from each other as required by variance.</source>
          <target state="translated">В .NET Framework 4 и более поздних версий неявное преобразование между делегатами, можно включить, чтобы универсальные делегаты, которые имеют разные типы, указанные параметрами универсального типа можно назначить друг к другу, если типы наследуются друг от друга, как требует вариативность.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>To enable implicit conversion, you must explicitly declare generic parameters in a delegate as covariant or contravariant by using the <ph id="ph1">`in`</ph> or <ph id="ph2">`out`</ph> keyword.</source>
          <target state="translated">Чтобы включить неявное преобразование, необходимо явно объявить универсальные параметры в делегате как ковариантные или контравариантные с помощью <ph id="ph1">`in`</ph> или <ph id="ph2">`out`</ph> ключевое слово.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The following code example shows how you can create a delegate that has a covariant generic type parameter.</source>
          <target state="translated">В следующем примере кода показано, как можно создать делегат, который имеет ковариантный параметр универсального типа.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If you use only variance support to match method signatures with delegate types and do not use the <ph id="ph1">`in`</ph> and <ph id="ph2">`out`</ph> keywords, you may find that sometimes you can instantiate delegates with identical lambda expressions or methods, but you cannot assign one delegate to another.</source>
          <target state="translated">Если только поддержка вариативности используется для сопоставления сигнатур методов с типами делегатов, а не используйте <ph id="ph1">`in`</ph> и <ph id="ph2">`out`</ph> ключевые слова, вы обнаружите, что можно создать экземпляры делегатов с одинаковыми лямбда-выражениями или методами, но нельзя назначить один делегат другому.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In the following code example, <ph id="ph1">`SampleGenericDelegate(Of String)`</ph> can't be explicitly converted to <ph id="ph2">`SampleGenericDelegate(Of Object)`</ph>, although <ph id="ph3">`String`</ph> inherits <ph id="ph4">`Object`</ph>.</source>
          <target state="translated">В следующем примере кода <ph id="ph1">`SampleGenericDelegate(Of String)`</ph> не может быть явно преобразованы <ph id="ph2">`SampleGenericDelegate(Of Object)`</ph>, хотя <ph id="ph3">`String`</ph> наследует <ph id="ph4">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can fix this problem by marking the generic parameter <ph id="ph1">`T`</ph> with the <ph id="ph2">`out`</ph> keyword.</source>
          <target state="translated">Эту проблему можно устранить, пометив универсальный параметр <ph id="ph1">`T`</ph> с <ph id="ph2">`out`</ph> ключевое слово.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Generic Delegates That Have Variant Type Parameters in the .NET Framework</source>
          <target state="translated">Универсальные делегаты, которые имеют вариант параметрами типа в .NET Framework</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>.NET Framework 4 introduced variance support for generic type parameters in several existing generic delegates:</source>
          <target state="translated">Платформа .NET framework 4 появилась поддержка вариативности для параметров универсального типа в нескольких существующих универсальных методов-делегатов:</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Action`</ph> delegates from the &lt;xref:System&gt; namespace, for example, &lt;xref:System.Action%601&gt; and &lt;xref:System.Action%602&gt;</source>
          <target state="translated"><ph id="ph1">`Action`</ph>делегирует с &lt;xref:System&gt;пространства имен, например, &lt;xref:System.Action%601&gt;и &lt;xref:System.Action%602&gt;&lt;/xref:System.Action%602&gt; &lt;/xref:System.Action%601&gt; &lt;/xref:System&gt;</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Func`</ph> delegates from the &lt;xref:System&gt; namespace, for example, &lt;xref:System.Func%601&gt; and &lt;xref:System.Func%602&gt;</source>
          <target state="translated"><ph id="ph1">`Func`</ph>делегирует с &lt;xref:System&gt;пространства имен, например, &lt;xref:System.Func%601&gt;и &lt;xref:System.Func%602&gt;&lt;/xref:System.Func%602&gt; &lt;/xref:System.Func%601&gt; &lt;/xref:System&gt;</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Predicate%601&gt; delegate</source>
          <target state="translated">&lt;xref:System.Predicate%601&gt;Делегат&lt;/xref:System.Predicate%601&gt;</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Comparison%601&gt; delegate</source>
          <target state="translated">&lt;xref:System.Comparison%601&gt;Делегат&lt;/xref:System.Comparison%601&gt;</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Converter%602&gt; delegate</source>
          <target state="translated">&lt;xref:System.Converter%602&gt;Делегат&lt;/xref:System.Converter%602&gt;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information and examples, see <bpt id="p1">[</bpt>Using Variance for Func and Action Generic Delegates (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept>.</source>
          <target state="translated">Дополнительные сведения и примеры см. в разделе <bpt id="p1">[</bpt>с помощью дисперсию Func и Action универсальные делегаты (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Declaring Variant Type Parameters in Generic Delegates</source>
          <target state="translated">Объявление параметров типа Variant в универсальных методах-делегатах</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If a generic delegate has covariant or contravariant generic type parameters, it can be referred to as a <bpt id="p1">*</bpt>variant generic delegate<ept id="p1">*</ept>.</source>
          <target state="translated">Если универсальный метод-делегат содержит ковариантные или контравариантные параметры универсального типа, он может называться <bpt id="p1">*</bpt>вариантных универсальных делегатов<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can declare a generic type parameter covariant in a generic delegate by using the <ph id="ph1">`out`</ph> keyword.</source>
          <target state="translated">Параметр универсального типа можно объявить ковариантный универсальный делегат с помощью <ph id="ph1">`out`</ph> ключевое слово.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The covariant type can be used only as a method return type and not as a type of method arguments.</source>
          <target state="translated">Параметры ковариантного типа может использоваться только в качестве типа возвращаемого значения метода, а не как тип аргументов метода.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following code example shows how to declare a covariant generic delegate.</source>
          <target state="translated">В следующем примере кода показано, как объявить ковариантный универсальный делегат.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>5<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>5<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>You can declare a generic type parameter contravariant in a generic delegate by using the <ph id="ph1">`in`</ph> keyword.</source>
          <target state="translated">Контравариантного параметра универсального типа в универсальный делегат можно объявить с помощью <ph id="ph1">`in`</ph> ключевое слово.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The contravariant type can be used only as a type of method arguments and not as a method return type.</source>
          <target state="translated">Контравариантный тип можно использовать только в качестве типа аргументов метода, а не как тип возвращаемого значения метода.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The following code example shows how to declare a contravariant generic delegate.</source>
          <target state="translated">В следующем примере кода показано, как объявить контравариантный универсальный делегат.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>6<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>6<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><ph id="ph1"> `ByRef`</ph> parameters in Visual Basic can't be marked as variant.</source>
          <target state="translated"><ph id="ph1"> `ByRef`</ph>в Visual Basic не может быть помечен как данные variant.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>It is also possible to support both variance and covariance in the same delegate, but for different type parameters.</source>
          <target state="translated">Также можно реализовать поддержку вариативности и ковариации в тот же делегат, но для разных параметров типа.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This is shown in the following example.</source>
          <target state="translated">Эти действия показаны в следующем примере.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>7<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>7<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Instantiating and Invoking Variant Generic Delegates</source>
          <target state="translated">Создание экземпляра и вызов вариативных универсальных методов-делегатов</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You can instantiate and invoke variant delegates just as you instantiate and invoke invariant delegates.</source>
          <target state="translated">Можно создать и вызов вариативных делегатов как экземпляра и вызове инвариантных делегатов.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In the following example, the delegate is instantiated by a lambda expression.</source>
          <target state="translated">В следующем примере создается экземпляр делегата, лямбда-выражение.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>8<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>8<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Combining Variant Generic Delegates</source>
          <target state="translated">Объединение вариативных универсальных методов-делегатов</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You should not combine variant delegates.</source>
          <target state="translated">Не следует объединять вариантные делегаты.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The &lt;xref:System.Delegate.Combine%2A&gt; method does not support variant delegate conversion and expects delegates to be of exactly the same type.</source>
          <target state="translated">&lt;xref:System.Delegate.Combine%2A&gt;Метод не поддерживает преобразование вариантных делегатов и ожидает делегаты точно того же типа.&lt;/xref:System.Delegate.Combine%2A&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This can lead to a run-time exception when you combine delegates either by using the &lt;xref:System.Delegate.Combine%2A&gt; method (in C# and Visual Basic) or by using the <ph id="ph1">`+`</ph> operator (in C#), as shown in the following code example.</source>
          <target state="translated">Это может привести к исключение времени выполнения при объединении делегатов с помощью &lt;xref:System.Delegate.Combine%2A&gt;метод (в C# и Visual Basic) или с помощью <ph id="ph1">`+`</ph> оператора (в C#), как показано в следующем примере кода.&lt;/xref:System.Delegate.Combine%2A&gt;</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>9<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>9<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Variance in Generic Type Parameters for Value and Reference Types</source>
          <target state="translated">Вариативность в параметрах универсального типа для значений и ссылочные типы</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Variance for generic type parameters is supported for reference types only.</source>
          <target state="translated">Вариативность для параметров универсального типа поддерживается только для ссылочных типов.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`DVariant(Of Int)`</ph>can't be implicitly converted to <ph id="ph2">`DVariant(Of Object)`</ph> or <ph id="ph3">`DVariant(Of Long)`</ph>, because integer is a value type.</source>
          <target state="translated">Например <ph id="ph1">`DVariant(Of Int)`</ph>не может быть неявно преобразован к <ph id="ph2">`DVariant(Of Object)`</ph> или <ph id="ph3">`DVariant(Of Long)`</ph>, так как целое число — это тип значения.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The following example demonstrates that variance in generic type parameters is not supported for value types.</source>
          <target state="translated">В следующем примере показано, что Вариативность в универсальных типов параметров не поддерживается для типов значений.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Relaxed Delegate Conversion in Visual Basic</source>
          <target state="translated">Неявное преобразование делегата в Visual Basic</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Relaxed delegate conversion enables more flexibility in matching method signatures with delegate types.</source>
          <target state="translated">Неявное преобразование делегата обеспечивает большую гибкость при сопоставлении сигнатур методов с типами делегатов.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For example, it lets you omit parameter specifications and omit function return values when you assign a method to a delegate.</source>
          <target state="translated">Например он позволяет опустить спецификации параметров и опустить возвращаемые значения функции при назначении метода делегату.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Relaxed Delegate Conversion<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>неявное преобразование делегата<ept id="p1">](../../../../visual-basic/programming-guide/language-features/delegates/relaxed-delegate-conversion.md)</ept>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">См. также</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generics<ept id="p1">](https://msdn.microsoft.com/library/ms172192)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Универсальные шаблоны<ept id="p1">](https://msdn.microsoft.com/library/ms172192)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Using Variance for Func and Action Generic Delegates (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Использование вариативности в Func и Action универсальные делегаты (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>