<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c724bf8b6794e71d49b32c7d3ce9e010f541f68f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\operators-and-expressions\arithmetic-operators.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">168c9f9933b2e34f593a9fafbf545bcaf77a67a3</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">22434cdfba0b468075a3151b855b9c76e3fb27c9</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_arithmetic-operators.d40b7d716eace7bfd9ca27742d78467e761c6a3e.zh-cn is different with handoff file name: arithmetic-operators.d40b7d716eace7bfd9ca27742d78467e761c6a3e.zh-cn.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators in Visual Basic | Microsoft Docs</source>
          <target state="translated">在 Visual Basic 中的算术运算符 |Microsoft 文档</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators in Visual Basic</source>
          <target state="translated">算术运算符 (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Arithmetic operators are used to perform many of the familiar arithmetic operations that involve the calculation of numeric values represented by literals, variables, other expressions, function and property calls, and constants.</source>
          <target state="translated">算术运算符用于执行很多熟悉的算术运算，涉及通过文字、 变量、 其他表达式、 函数和属性调用和常量表示的数值计算。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Also classified with arithmetic operators are the bit-shift operators, which act at the level of the individual bits of the operands and shift their bit patterns to the left or right.</source>
          <target state="translated">算术运算符也属于是移位运算符，该级别的单个位进行运算的操作数执行操作和向左或向右移动其位模式。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Arithmetic Operations</source>
          <target state="translated">算术运算</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can add two values in an expression together with the <bpt id="p1">[</bpt>+ Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/addition-operator.md)</ept>, or subtract one from another with the <bpt id="p2">[</bpt>- Operator (Visual Basic)<ept id="p2">](../../../../visual-basic/language-reference/operators/subtraction-operator.md)</ept>, as the following example demonstrates.</source>
          <target state="translated">您可以添加两个值一起使用的表达式中<bpt id="p1">[</bpt>+ 运算符<ept id="p1">](../../../../visual-basic/language-reference/operators/addition-operator.md)</ept>，或从另一个具有中减去&amp;1; <bpt id="p2">[</bpt>-运算符 (Visual Basic)<ept id="p2">](../../../../visual-basic/language-reference/operators/subtraction-operator.md)</ept>，如下面的示例所示。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#57<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_1.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators #&amp;57;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_1.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Negation also uses the <bpt id="p1">[</bpt>- Operator (Visual Basic)<ept id="p1">](../../../../visual-basic/language-reference/operators/subtraction-operator.md)</ept>, but with only one operand, as the following example demonstrates.</source>
          <target state="translated">求反也使用<bpt id="p1">[</bpt>-运算符 (Visual Basic)<ept id="p1">](../../../../visual-basic/language-reference/operators/subtraction-operator.md)</ept>，但只带一个操作数，如下面的示例演示了。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#58<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_2.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators #&amp;58; 页<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_2.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Multiplication and division use the <bpt id="p1">[</bpt>* Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/multiplication-operator.md)</ept> and <bpt id="p2">[</bpt>/ Operator (Visual Basic)<ept id="p2">](../../../../visual-basic/language-reference/operators/floating-point-division-operator.md)</ept>, respectively, as the following example demonstrates.</source>
          <target state="translated">乘法和除法使用<bpt id="p1">[</bpt>* 运算符<ept id="p1">](../../../../visual-basic/language-reference/operators/multiplication-operator.md)</ept>和<bpt id="p2">[</bpt>/ 运算符 (Visual Basic)<ept id="p2">](../../../../visual-basic/language-reference/operators/floating-point-division-operator.md)</ept>分别，如下面的示例所示。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#59<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_3.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators #&amp;59;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_3.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Exponentiation uses the <bpt id="p1">[</bpt>^ Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/exponentiation-operator.md)</ept>, as the following example demonstrates.</source>
          <target state="translated">求幂使用<bpt id="p1">[</bpt>^ 运算符<ept id="p1">](../../../../visual-basic/language-reference/operators/exponentiation-operator.md)</ept>，如下面的示例所示。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#60<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_4.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators #&amp;60;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_4.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Integer division is carried out using the <bpt id="p1">[</bpt>\ Operator (Visual Basic)<ept id="p1">](../../../../visual-basic/language-reference/operators/integer-division-operator.md)</ept>.</source>
          <target state="translated">整数除法利用执行<bpt id="p1">[</bpt>\ 运算符 (Visual Basic)<ept id="p1">](../../../../visual-basic/language-reference/operators/integer-division-operator.md)</ept>。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Integer division returns the quotient, that is, the integer that represents the number of times the divisor can divide into the dividend without consideration of any remainder.</source>
          <target state="translated">整数除法返回商，即表示的次数的整数除数可以除被除数而无需考虑了所有余数。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Both the divisor and the dividend must be integral types (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, and <ph id="ph8">`ULong`</ph>) for this operator.</source>
          <target state="translated">除数和被除数必须是整数类型 (<ph id="ph1">`SByte`</ph>， <ph id="ph2">`Byte`</ph>， <ph id="ph3">`Short`</ph>， <ph id="ph4">`UShort`</ph>， <ph id="ph5">`Integer`</ph>， <ph id="ph6">`UInteger`</ph>， <ph id="ph7">`Long`</ph>，和<ph id="ph8">`ULong`</ph>) 为此运算符。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>All other types must be converted to an integral type first.</source>
          <target state="translated">必须首先将所有其他类型转换为整数类型。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following example demonstrates integer division.</source>
          <target state="translated">下面的示例演示整数除法。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#61<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_5.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators #&amp;61;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_5.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Modulus arithmetic is performed using the <bpt id="p1">[</bpt>Mod Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/mod-operator.md)</ept>.</source>
          <target state="translated">使用执行求模算术<bpt id="p1">[</bpt>Mod 运算符<ept id="p1">](../../../../visual-basic/language-reference/operators/mod-operator.md)</ept>。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This operator returns the remainder after dividing the divisor into the dividend an integral number of times.</source>
          <target state="translated">此运算符返回其余部分被除数除以除数后的次数的整数。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>If both divisor and dividend are integral types, the returned value is integral.</source>
          <target state="translated">如果除数和被除数可以是整数类型，则返回的值是整数。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>If divisor and dividend are floating-point types, the returned value is also floating-point.</source>
          <target state="translated">如果除数和除数都是浮点类型，则返回的值也是浮点。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this behavior.</source>
          <target state="translated">下面的示例演示此行为。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#62<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_6.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators #&amp;62;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_6.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#63<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_7.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators #&amp;63;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_7.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Attempted Division by Zero</source>
          <target state="translated">尝试被零除</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Division by zero has different results depending on the data types involved.</source>
          <target state="translated">被零除具有不同的结果，具体取决于涉及的数据类型。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In integral divisions (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, <ph id="ph8">`ULong`</ph>), the <ph id="ph9">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> throws a &lt;xref:System.DivideByZeroException&gt; exception.</source>
          <target state="translated">In integral divisions (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, <ph id="ph8">`ULong`</ph>), the <ph id="ph9">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> throws a &lt;xref:System.DivideByZeroException&gt; exception.&lt;/xref:System.DivideByZeroException&gt;</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>In division operations on the <ph id="ph1">`Decimal`</ph> or <ph id="ph2">`Single`</ph> data type, the <ph id="ph3">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> also throws a &lt;xref:System.DivideByZeroException&gt; exception.</source>
          <target state="translated">在除法运算<ph id="ph1">`Decimal`</ph>或<ph id="ph2">`Single`</ph>数据类型，<ph id="ph3">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph>还会抛出&lt;xref:System.DivideByZeroException&gt;异常。&lt;/xref:System.DivideByZeroException&gt;</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In floating-point divisions involving the <ph id="ph1">`Double`</ph> data type, no exception is thrown, and the result is the class member representing &lt;xref:System.Double.NaN&gt;, &lt;xref:System.Double.PositiveInfinity&gt;, or &lt;xref:System.Double.NegativeInfinity&gt;, depending on the dividend.</source>
          <target state="translated">在涉及浮点部门<ph id="ph1">`Double`</ph>数据类型，不会引发异常，并且结果是表示的类成员&lt;xref:System.Double.NaN&gt;， &lt;xref:System.Double.PositiveInfinity&gt;，或&lt;xref:System.Double.NegativeInfinity&gt;，取决于被除数。&lt;/xref:System.Double.NegativeInfinity&gt; &lt;/xref:System.Double.PositiveInfinity&gt; &lt;/xref:System.Double.NaN&gt;</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following table summarizes the various results of attempting to divide a <ph id="ph1">`Double`</ph> value by zero.</source>
          <target state="translated">下表汇总了各个结果的尝试除<ph id="ph1">`Double`</ph>被零除的值。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Dividend data type</source>
          <target state="translated">被除数的数据类型</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Divisor data type</source>
          <target state="translated">除数数据类型</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Dividend value</source>
          <target state="translated">被除数的值</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">结果</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Double.NaN&gt; (not a mathematically defined number)</source>
          <target state="translated">&lt;xref:System.Double.NaN&gt;（不是数学上定义的数字）&lt;/xref:System.Double.NaN&gt;</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>&gt; 0</source>
          <target state="translated">&gt; 0</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Double.PositiveInfinity&gt;</source>
          <target state="translated">&lt;xref:System.Double.PositiveInfinity&gt;&lt;/xref:System.Double.PositiveInfinity&gt;</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\&lt;</ph> 0</source>
          <target state="translated"><ph id="ph1">\&lt;</ph> 0</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>&lt;xref:System.Double.NegativeInfinity&gt;</source>
          <target state="translated">&lt;xref:System.Double.NegativeInfinity&gt;&lt;/xref:System.Double.NegativeInfinity&gt;</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When you catch a &lt;xref:System.DivideByZeroException&gt; exception, you can use its members to help you handle it.</source>
          <target state="translated">当捕获的&lt;xref:System.DivideByZeroException&gt;异常，您可以使用其成员可以帮助您处理它。&lt;/xref:System.DivideByZeroException&gt;</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For example, the &lt;xref:System.Exception.Message%2A&gt; property holds the message text for the exception.</source>
          <target state="translated">例如，&lt;xref:System.Exception.Message%2A&gt;属性保留了该异常的消息文本。&lt;/xref:System.Exception.Message%2A&gt;</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Try...Catch...Finally Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>重试...Catch...Finally 语句<ept id="p1">](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Bit-Shift Operations</source>
          <target state="translated">移位运算</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A bit-shift operation performs an arithmetic shift on a bit pattern.</source>
          <target state="translated">移位运算对位模式执行算术移位运算。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The pattern is contained in the operand on the left, while the operand on the right specifies the number of positions to shift the pattern.</source>
          <target state="translated">模式包含在左侧，操作数中，而右侧操作数指定的位数移动模式。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>You can shift the pattern to the right with the <bpt id="p1">[</bpt>&gt;&gt; Operator<ept id="p1">](../../../../visual-basic/language-reference/operators/right-shift-operator.md)</ept> or to the left with the <bpt id="p2">[</bpt>&lt;&lt; Operator<ept id="p2">](../../../../visual-basic/language-reference/operators/left-shift-operator.md)</ept>.</source>
          <target state="translated">将模式切换到右<bpt id="p1">[</bpt>&gt;&gt; 运算符<ept id="p1">](../../../../visual-basic/language-reference/operators/right-shift-operator.md)</ept>滑动到左侧则与<bpt id="p2">[</bpt> &lt;&gt; &lt;/&gt; <ept id="p2">](../../../../visual-basic/language-reference/operators/left-shift-operator.md)</ept>。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The data type of the pattern operand must be <ph id="ph1">`SByte`</ph>, <ph id="ph2">`Byte`</ph>, <ph id="ph3">`Short`</ph>, <ph id="ph4">`UShort`</ph>, <ph id="ph5">`Integer`</ph>, <ph id="ph6">`UInteger`</ph>, <ph id="ph7">`Long`</ph>, or <ph id="ph8">`ULong`</ph>.</source>
          <target state="translated">模式操作数的数据类型必须是<ph id="ph1">`SByte`</ph>， <ph id="ph2">`Byte`</ph>， <ph id="ph3">`Short`</ph>， <ph id="ph4">`UShort`</ph>， <ph id="ph5">`Integer`</ph>， <ph id="ph6">`UInteger`</ph>， <ph id="ph7">`Long`</ph>，或<ph id="ph8">`ULong`</ph>。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The data type of the shift amount operand must be <ph id="ph1">`Integer`</ph> or must widen to <ph id="ph2">`Integer`</ph>.</source>
          <target state="translated">Shift 量操作数的数据类型必须是<ph id="ph1">`Integer`</ph>或者必须扩大到<ph id="ph2">`Integer`</ph>。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Arithmetic shifts are not circular, which means the bits shifted off one end of the result are not reintroduced at the other end.</source>
          <target state="translated">算术移位不是循环性的这意味着从结果的一端移掉的位在另一端不重新移入。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The bit positions vacated by a shift are set as follows:</source>
          <target state="translated">因移位而空出的位上将设置，如下所示︰</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>0 for an arithmetic left shift</source>
          <target state="translated">0 表示算术左移位运算</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>0 for an arithmetic right shift of a positive number</source>
          <target state="translated">0 的正数值的算术右移位</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>0 for an arithmetic right shift of an unsigned data type (<ph id="ph1">`Byte`</ph>, <ph id="ph2">`UShort`</ph>, <ph id="ph3">`UInteger`</ph>, <ph id="ph4">`ULong`</ph>)</source>
          <target state="translated">算术右移位运算的无符号的数据类型为&amp;0; (<ph id="ph1">`Byte`</ph>， <ph id="ph2">`UShort`</ph>， <ph id="ph3">`UInteger`</ph>， <ph id="ph4">`ULong`</ph>)</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>1 for an arithmetic right shift of a negative number (<ph id="ph1">`SByte`</ph>, <ph id="ph2">`Short`</ph>, <ph id="ph3">`Integer`</ph>, or <ph id="ph4">`Long`</ph>)</source>
          <target state="translated">1 表示负数的算术右移位 (<ph id="ph1">`SByte`</ph>， <ph id="ph2">`Short`</ph>， <ph id="ph3">`Integer`</ph>，或<ph id="ph4">`Long`</ph>)</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following example shifts an <ph id="ph1">`Integer`</ph> value both left and right.</source>
          <target state="translated">以下示例将推<ph id="ph1">`Integer`</ph>左侧和右侧的值。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators#64<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_8.vb)</ept><ept id="p1">]</ept></source>
          <target state="translated"><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>VbVbalrOperators #&amp;64;<ept id="p2">](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_8.vb)</ept><ept id="p1">]</ept></target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Arithmetic shifts never generate overflow exceptions.</source>
          <target state="translated">算术移位永远不会产生溢出异常。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Bitwise Operations</source>
          <target state="translated">按位运算</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In addition to being logical operators, <ph id="ph1">`Not`</ph>, <ph id="ph2">`Or`</ph>, <ph id="ph3">`And`</ph>, and <ph id="ph4">`Xor`</ph> also perform bitwise arithmetic when used on numeric values.</source>
          <target state="translated">逻辑运算符，除了<ph id="ph1">`Not`</ph>， <ph id="ph2">`Or`</ph>， <ph id="ph3">`And`</ph>，和<ph id="ph4">`Xor`</ph>还执行按位算术运算在数值中使用时。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For more information, see "Bitwise Operations" in <bpt id="p1">[</bpt>Logical and Bitwise Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅 》 的"按位操作"<bpt id="p1">[</bpt>逻辑和按位运算符在 Visual Basic 中<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept>。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Type Safety</source>
          <target state="translated">类型安全</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Operands should normally be of the same type.</source>
          <target state="translated">操作数通常应属于同一类型。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For example, if you are doing addition with an <ph id="ph1">`Integer`</ph> variable, you should add it to another <ph id="ph2">`Integer`</ph> variable, and you should assign the result to a variable of type <ph id="ph3">`Integer`</ph> as well.</source>
          <target state="translated">例如，如果你正在添加<ph id="ph1">`Integer`</ph>变量时，您应将其添加到另一个<ph id="ph2">`Integer`</ph>变量，并且您应将结果赋给一个类型的变量<ph id="ph3">`Integer`</ph>以及。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>One way to ensure good type-safe coding practice is to use the <bpt id="p1">[</bpt>Option Strict Statement<ept id="p1">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept>.</source>
          <target state="translated">一种方法以确保良好的类型安全编码做法是使用<bpt id="p1">[</bpt>Option Strict 语句<ept id="p1">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept>。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If you set <ph id="ph1">`Option Strict On`</ph>, <ph id="ph2">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> automatically performs <bpt id="p1">*</bpt>type-safe<ept id="p1">*</ept> conversions.</source>
          <target state="translated">如果您设置<ph id="ph1">`Option Strict On`</ph>，<ph id="ph2">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph>自动执行<bpt id="p1">*</bpt>类型安全<ept id="p1">*</ept>转换。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, if you try to add an <ph id="ph1">`Integer`</ph> variable to a <ph id="ph2">`Double`</ph> variable and assign the value to a <ph id="ph3">`Double`</ph> variable, the operation proceeds normally, because an <ph id="ph4">`Integer`</ph> value can be converted to <ph id="ph5">`Double`</ph> without loss of data.</source>
          <target state="translated">例如，如果你尝试添加<ph id="ph1">`Integer`</ph>变量<ph id="ph2">`Double`</ph>变量并将值赋给<ph id="ph3">`Double`</ph>变量时，该操作将正常进行，因为<ph id="ph4">`Integer`</ph>值可以转换为<ph id="ph5">`Double`</ph>而不丢失数据。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Type-unsafe conversions, on the other hand, cause a compiler error with <ph id="ph1">`Option Strict On`</ph>.</source>
          <target state="translated">类型不安全的转换，另一方面，导致编译器错误与<ph id="ph1">`Option Strict On`</ph>。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example, if you try to add an <ph id="ph1">`Integer`</ph> variable to a <ph id="ph2">`Double`</ph> variable and assign the value to an <ph id="ph3">`Integer`</ph> variable, a compiler error results, because a <ph id="ph4">`Double`</ph> variable cannot be implicitly converted to type <ph id="ph5">`Integer`</ph>.</source>
          <target state="translated">例如，如果你尝试添加<ph id="ph1">`Integer`</ph>变量<ph id="ph2">`Double`</ph>变量并将值赋给<ph id="ph3">`Integer`</ph>变量时，会导致编译器错误，因为<ph id="ph4">`Double`</ph>变量不能隐式转换为键入<ph id="ph5">`Integer`</ph>。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If you set <ph id="ph1">`Option Strict Off`</ph>, however, <ph id="ph2">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> allows implicit narrowing conversions to take place, although they can result in the unexpected loss of data or precision.</source>
          <target state="translated">如果您设置<ph id="ph1">`Option Strict Off`</ph>，但<ph id="ph2">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph>允许隐式收缩转换完成，但是它们可能会导致意外丢失的数据或精度。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For this reason, we recommend that you use <ph id="ph1">`Option Strict On`</ph> when writing production code.</source>
          <target state="translated">出于此原因，我们建议你使用<ph id="ph1">`Option Strict On`</ph>编写生产代码时。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Widening and Narrowing Conversions<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>扩大和收缩转换<ept id="p1">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">另请参阅</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Arithmetic Operators<ept id="p1">](../../../../visual-basic/language-reference/operators/arithmetic-operators.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>算术运算符<ept id="p1">](../../../../visual-basic/language-reference/operators/arithmetic-operators.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Bit Shift Operators<ept id="p1">](../../../../visual-basic/language-reference/operators/bit-shift-operators.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>移位运算符<ept id="p1">](../../../../visual-basic/language-reference/operators/bit-shift-operators.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Comparison Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/comparison-operators.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>在 Visual Basic 中的比较运算符<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/comparison-operators.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Concatenation Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>在 Visual Basic 中的串联运算符<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Logical and Bitwise Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>在 Visual Basic 中的逻辑和按位运算符<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Efficient Combination of Operators<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/efficient-combination-of-operators.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>运算符的有效组合<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/efficient-combination-of-operators.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>