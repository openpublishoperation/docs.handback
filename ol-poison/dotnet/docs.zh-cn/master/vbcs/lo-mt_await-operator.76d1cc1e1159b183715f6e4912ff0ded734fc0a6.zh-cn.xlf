<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b50b9c7283ddd4d3f8484854bdffff3d76181c9f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\language-reference\operators\await-operator.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">71f89e30a22fedd22c44b0cca01bbad2f317cc27</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5000d2b63426186cf649c3dd7579845ef11dfe50</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_await-operator.76d1cc1e1159b183715f6e4912ff0ded734fc0a6.zh-cn is different with handoff file name: await-operator.76d1cc1e1159b183715f6e4912ff0ded734fc0a6.zh-cn.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Await Operator (Visual Basic) | Microsoft Docs</source>
          <target state="translated">Await 运算符 (Visual Basic 中) |Microsoft 文档</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Await Operator (Visual Basic)</source>
          <target state="translated">Await 运算符 (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>You apply the <ph id="ph1">`Await`</ph> operator to an operand in an asynchronous method or lambda expression to suspend execution of the method until the awaited task completes.</source>
          <target state="translated">在异步方法或 lambda 表达式中对操作数应用 <ph id="ph1">`Await`</ph> 运算符可暂停执行方法，直到所等待的任务完成。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The task represents ongoing work.</source>
          <target state="translated">任务表示正在进行的工作。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The method in which <ph id="ph1">`Await`</ph> is used must have an <bpt id="p1">[</bpt>Async<ept id="p1">](../../../visual-basic/language-reference/modifiers/async.md)</ept> modifier.</source>
          <target state="translated">在其中方法<ph id="ph1">`Await`</ph>使用必须具有<bpt id="p1">[</bpt>异步<ept id="p1">](../../../visual-basic/language-reference/modifiers/async.md)</ept>修饰符。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Such a method, defined by using the <ph id="ph1">`Async`</ph> modifier, and usually containing one or more <ph id="ph2">`Await`</ph> expressions, is referred to as an <bpt id="p1">*</bpt>async method<ept id="p1">*</ept>.</source>
          <target state="translated">此类定义的方法，通过使用<ph id="ph1">`Async`</ph>修饰符，并通常包含一个或多<ph id="ph2">`Await`</ph>表达式中，称为<bpt id="p1">*</bpt>async 方法<ept id="p1">*</ept>。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Async`</ph> and <ph id="ph2">`Await`</ph> keywords were introduced in Visual Studio 2012.</source>
          <target state="translated"><ph id="ph1">`Async`</ph> 和 <ph id="ph2">`Await`</ph> 关键字是在 Visual Studio 2012 中引入的。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For an introduction to async programming, see <bpt id="p1">[</bpt>Asynchronous Programming with Async and Await<ept id="p1">](../../../visual-basic/programming-guide/concepts/async/index.md)</ept>.</source>
          <target state="translated">有关异步编程的介绍，请参阅<bpt id="p1">[</bpt>使用 Async 和 Await 的异步编程<ept id="p1">](../../../visual-basic/programming-guide/concepts/async/index.md)</ept>。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Typically, the task to which you apply the <ph id="ph1">`Await`</ph> operator is the return value from a call to a method that implements the <bpt id="p1">[</bpt>Task-Based Asynchronous Pattern<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204847)</ept>, that is, a &lt;xref:System.Threading.Tasks.Task&gt; or a &lt;xref:System.Threading.Tasks.Task%601&gt;.</source>
          <target state="translated">通常情况下，您将应用该任务<ph id="ph1">`Await`</ph>运算符是通过实现的方法调用的返回值<bpt id="p1">[</bpt>基于任务的异步模式<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204847)</ept>，也就是说，一个&lt;xref:System.Threading.Tasks.Task&gt;或一种&lt;xref:System.Threading.Tasks.Task%601&gt;。&lt;/xref:System.Threading.Tasks.Task%601&gt; &lt;/xref:System.Threading.Tasks.Task&gt;</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In the following code, the &lt;xref:System.Net.Http.HttpClient&gt; method &lt;xref:System.Net.Http.HttpClient.GetByteArrayAsync%2A&gt; returns <ph id="ph1">`getContentsTask`</ph>, a <ph id="ph2">`Task(Of Byte())`</ph>.</source>
          <target state="translated">在下面的代码中，&lt;xref:System.Net.Http.HttpClient&gt;方法&lt;xref:System.Net.Http.HttpClient.GetByteArrayAsync%2A&gt;返回<ph id="ph1">`getContentsTask`</ph>、 <ph id="ph2">`Task(Of Byte())`</ph>。&lt;/xref:System.Net.Http.HttpClient.GetByteArrayAsync%2A&gt; &lt;/xref:System.Net.Http.HttpClient&gt;</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The task is a promise to produce the actual byte array when the operation is complete.</source>
          <target state="translated">当操作完成时，任务约定生成一个实际字节数组。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Await`</ph> operator is applied to <ph id="ph2">`getContentsTask`</ph> to suspend execution in <ph id="ph3">`SumPageSizesAsync`</ph> until <ph id="ph4">`getContentsTask`</ph> is complete.</source>
          <target state="translated"><ph id="ph1">`Await`</ph> 运算符应用于 <ph id="ph2">`getContentsTask`</ph> 以在 <ph id="ph3">`SumPageSizesAsync`</ph> 中挂起执行，直到 <ph id="ph4">`getContentsTask`</ph> 完成。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>In the meantime, control is returned to the caller of <ph id="ph1">`SumPageSizesAsync`</ph>.</source>
          <target state="translated">同时，控制权会返回给 <ph id="ph1">`SumPageSizesAsync`</ph> 的调用方。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">`getContentsTask`</ph> is finished, the <ph id="ph2">`Await`</ph> expression evaluates to a byte array.</source>
          <target state="translated">当 <ph id="ph1">`getContentsTask`</ph> 完成之后，<ph id="ph2">`Await`</ph> 表达式计算为字节数组。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>0<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>0<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For the complete example, see <bpt id="p1">[</bpt>Walkthrough: Accessing the Web by Using Async and Await<ept id="p1">](../../../visual-basic/programming-guide/concepts/async/walkthrough-accessing-the-web-by-using-async-and-await.md)</ept>.</source>
          <target state="translated">有关完整示例，请参阅<bpt id="p1">[</bpt>演练︰ 访问通过使用 Async 和 Await Web<ept id="p1">](../../../visual-basic/programming-guide/concepts/async/walkthrough-accessing-the-web-by-using-async-and-await.md)</ept>。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You can download the sample from <bpt id="p1">[</bpt>Developer Code Samples<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=255191&amp;clcid=0x409)</ept> on the Microsoft website.</source>
          <target state="translated">你可以下载示例从<bpt id="p1">[</bpt>开发人员代码示例<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=255191&amp;clcid=0x409)</ept>Microsoft 网站上。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The example is in the AsyncWalkthrough_HttpClient project.</source>
          <target state="translated">该示例处于 AsyncWalkthrough_HttpClient 项目中。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Await`</ph> is applied to the result of a method call that returns a <ph id="ph2">`Task(Of TResult)`</ph>, the type of the <ph id="ph3">`Await`</ph> expression is TResult.</source>
          <target state="translated">如果 <ph id="ph1">`Await`</ph> 应用于返回 <ph id="ph2">`Task(Of TResult)`</ph> 的方法调用结果，则 <ph id="ph3">`Await`</ph> 表达式的类型为 TResult。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`Await`</ph> is applied to the result of a method call that returns a <ph id="ph2">`Task`</ph>, the <ph id="ph3">`Await`</ph> expression doesn't return a value.</source>
          <target state="translated">如果 <ph id="ph1">`Await`</ph> 应用于返回 <ph id="ph2">`Task`</ph> 的方法调用结果，则 <ph id="ph3">`Await`</ph> 表达式不返回值。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference.</source>
          <target state="translated">以下示例演示了差异。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>1<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></source>
          <target state="translated"><bpt id="p1">&lt;CodeContentPlaceHolder&gt;</bpt>1<ept id="p1">&lt;/CodeContentPlaceHolder&gt;</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`Await`</ph> expression or statement does not block the thread on which it is executing.</source>
          <target state="translated"><ph id="ph1">`Await`</ph> 表达式或声明不阻止正在执行它的线程。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Instead, it causes the compiler to sign up the rest of the async method, after the <ph id="ph1">`Await`</ph> expression, as a continuation on the awaited task.</source>
          <target state="translated">而是导致编译器在 <ph id="ph1">`Await`</ph> 表达式之后，将剩下的异步方法注册为等待任务的后续部分。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Control then returns to the caller of the async method.</source>
          <target state="translated">控制权随后会返回给异步方法的调用方。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>When the task completes, it invokes its continuation, and execution of the async method resumes where it left off.</source>
          <target state="translated">任务完成时，它会调用其延续任务，异步方法的执行会在暂停的位置处恢复。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`Await`</ph> expression can occur only in the body of an immediately enclosing method or lambda expression that is marked by an <ph id="ph2">`Async`</ph> modifier.</source>
          <target state="translated"><ph id="ph1">`Await`</ph> 表达式只出现在由 <ph id="ph2">`Async`</ph> 修饰符标记的一个立即封闭方法体或 lambda 表达式中。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The term <bpt id="p1">*</bpt>Await<ept id="p1">*</ept> serves as a keyword only in that context.</source>
          <target state="translated">术语<bpt id="p1">*</bpt>Await<ept id="p1">*</ept>用作关键字仅在该上下文中。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Elsewhere, it is interpreted as an identifier.</source>
          <target state="translated">在其他位置，它会解释为标识符。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Within the async method or lambda expression, an <ph id="ph1">`Await`</ph> expression cannot occur in a query expression, in the <ph id="ph2">`catch`</ph> or <ph id="ph3">`finally`</ph> block of a <bpt id="p1">[</bpt>Try…Catch…Finally<ept id="p1">](../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept> statement, in the loop control variable expression of a <ph id="ph4">`For`</ph> or <ph id="ph5">`For Each`</ph> loop, or in the body of a <bpt id="p2">[</bpt>SyncLock<ept id="p2">](../../../visual-basic/language-reference/statements/synclock-statement.md)</ept> statement.</source>
          <target state="translated">在异步方法或 lambda 表达式中，<ph id="ph1">`Await`</ph>表达式中不能出现在查询表达式中，<ph id="ph2">`catch`</ph>或<ph id="ph3">`finally`</ph>块<bpt id="p1">[</bpt>重试...Catch...最后<ept id="p1">](../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>中的循环控制变量表达式语句<ph id="ph4">`For`</ph>或<ph id="ph5">`For Each`</ph>循环中，或在正文中<bpt id="p2">[</bpt>SyncLock<ept id="p2">](../../../visual-basic/language-reference/statements/synclock-statement.md)</ept>语句。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">异常</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Most async methods return a &lt;xref:System.Threading.Tasks.Task&gt; or &lt;xref:System.Threading.Tasks.Task%601&gt;.</source>
          <target state="translated">大多数异步方法返回&lt;xref:System.Threading.Tasks.Task&gt;或&lt;xref:System.Threading.Tasks.Task%601&gt;.&lt;/xref:System.Threading.Tasks.Task%601&gt; &lt;/xref:System.Threading.Tasks.Task&gt;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The properties of the returned task carry information about its status and history, such as whether the task is complete, whether the async method caused an exception or was canceled, and what the final result is.</source>
          <target state="translated">返回任务的属性携带有关其状态和历史记录的信息，如任务是否完成、异步方法是否导致异常或已取消以及最终结果是什么。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Await`</ph> operator accesses those properties.</source>
          <target state="translated"><ph id="ph1">`Await`</ph> 运算符可访问这些属性。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you await a task-returning async method that causes an exception, the  <ph id="ph1">`Await`</ph> operator rethrows the exception.</source>
          <target state="translated">如果等待的任务返回异步方法导致异常，则 <ph id="ph1">`Await`</ph> 运算符会重新引发异常。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>If you await a task-returning async method that is canceled, the <ph id="ph1">`Await`</ph> operator rethrows an &lt;xref:System.OperationCanceledException&gt;.</source>
          <target state="translated">如果等待的返回任务的异步方法取消，<ph id="ph1">`Await`</ph>运算符将重新引发&lt;xref:System.OperationCanceledException&gt;。&lt;/xref:System.OperationCanceledException&gt;</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>A single task that is in a faulted state can reflect multiple exceptions.</source>
          <target state="translated">处于故障状态的单个任务可以反映多个异常。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For example, the task might be the result of a call to &lt;xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=fullName&gt;.</source>
          <target state="translated">例如，任务可能是到&lt;xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=fullName&gt;。&lt;/xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=fullName&gt;调用的结果</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>When you await such a task, the await operation rethrows only one of the exceptions.</source>
          <target state="translated">等待此类任务时，等待操作仅重新引发异常之一。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>However, you can't predict which of the exceptions is rethrown.</source>
          <target state="translated">但是，无法预测重新引发的异常。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For examples of error handling in async methods, see <bpt id="p1">[</bpt>Try...Catch...Finally Statement<ept id="p1">](../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>.</source>
          <target state="translated">异步方法中的错误处理的示例，请参阅<bpt id="p1">[</bpt>重试...Catch...Finally 语句<ept id="p1">](../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">示例</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following Windows Forms example illustrates the use of <ph id="ph1">`Await`</ph> in an async method, <ph id="ph2">`WaitAsynchronouslyAsync`</ph>.</source>
          <target state="translated">下面的 Windows 窗体示例阐释如何在异步方法 <ph id="ph2">`WaitAsynchronouslyAsync`</ph> 中使用 <ph id="ph1">`Await`</ph>。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Contrast the behavior of that method with the behavior of <ph id="ph1">`WaitSynchronously`</ph>.</source>
          <target state="translated">将该方法的行为与 <ph id="ph1">`WaitSynchronously`</ph> 的行为进行对比。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Without an <ph id="ph1">`Await`</ph> operator, <ph id="ph2">`WaitSynchronously`</ph> runs synchronously despite the use of the <ph id="ph3">`Async`</ph> modifier in its definition and a call to &lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName&gt; in its body.</source>
          <target state="translated">而无需<ph id="ph1">`Await`</ph>运算符，<ph id="ph2">`WaitSynchronously`</ph>会同步运行，不管是否使用<ph id="ph3">`Async`</ph>修饰符在其定义和调用&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName&gt;在其主体中。&lt;/xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName&gt;</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">另请参阅</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Asynchronous Programming with Async and Await<ept id="p1">](../../../visual-basic/programming-guide/concepts/async/index.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>异步编程使用 Async 和 Await<ept id="p1">](../../../visual-basic/programming-guide/concepts/async/index.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Walkthrough: Accessing the Web by Using Async and Await<ept id="p1">](../../../visual-basic/programming-guide/concepts/async/walkthrough-accessing-the-web-by-using-async-and-await.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1"> [</bpt>演练︰ 访问 Web 使用 Async 和 Await<ept id="p1">](../../../visual-basic/programming-guide/concepts/async/walkthrough-accessing-the-web-by-using-async-and-await.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Async<ept id="p1">](../../../visual-basic/language-reference/modifiers/async.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>Async<ept id="p1">](../../../visual-basic/language-reference/modifiers/async.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>