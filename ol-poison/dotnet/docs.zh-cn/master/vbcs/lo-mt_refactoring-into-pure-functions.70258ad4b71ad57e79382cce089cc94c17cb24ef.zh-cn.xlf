<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-317e149" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e622436905893872521994f6dc1a5bc1c8b3d06a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\refactoring-into-pure-functions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a3c178ff6c32487001cf6e01c8ab97ff0838655a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">734c77ad98f910cf0ab62e09062b2bbf519350b4</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Handback file name: lo-mt_refactoring-into-pure-functions.70258ad4b71ad57e79382cce089cc94c17cb24ef.zh-cn is different with handoff file name: refactoring-into-pure-functions.70258ad4b71ad57e79382cce089cc94c17cb24ef.zh-cn.</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Refactoring Into Pure Functions (Visual Basic) | Microsoft Docs</source>
          <target state="translated">重构为纯函数 (Visual Basic 中) |Microsoft 文档</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Refactoring Into Pure Functions (Visual Basic)</source>
          <target state="translated">重构为纯函数 (Visual Basic)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>An important aspect of pure functional transformations is learning how to refactor code using pure functions.</source>
          <target state="translated">纯函数转换的一个重要方面是学习如何使用纯函数重构代码。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>As noted previously in this section, a pure function has two useful characteristics:</source>
          <target state="translated">如本节前面所述，纯函数具有两个有用的特性：</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>It has no side effects.</source>
          <target state="translated">它没有任何副作用。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The function does not change any variables or the data of any type outside of the function.</source>
          <target state="translated">函数不会更改函数以外的任何变量或任何类型的数据。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>It is consistent.</source>
          <target state="translated">它具有一致性。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Given the same set of input data, it will always return the same output value.</source>
          <target state="translated">在提供同一组输入数据的情况下，它将始终返回相同的输出值。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>One way of transitioning to functional programming is to refactor existing code to eliminate unnecessary side effects and external dependencies.</source>
          <target state="translated">转换为函数编程的一种方式是重构现有代码以消除不必要的副作用和外部依赖项。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In this way, you can create pure function versions of existing code.</source>
          <target state="translated">这样，您可以创建现有代码的纯函数版本。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This topic discusses what a pure function is and what it is not.</source>
          <target state="translated">本主题讨论什么是纯函数，什么不是纯函数。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Tutorial: Manipulating Content in a WordprocessingML Document (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md)</ept> tutorial shows how to manipulate a WordprocessingML document, and includes two examples of how to refactor using a pure function.</source>
          <target state="translated"><bpt id="p1">[</bpt>教程︰ 在 WordprocessingML 文档 (Visual Basic 中) 中使用内容<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md)</ept>教程演示如何操作 WordprocessingML 文档，并包括两个有关如何的示例使用纯函数进行重构。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Eliminating Side Effects and External Dependencies</source>
          <target state="translated">消除副作用和外部依赖项</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The following examples contrast two non-pure functions and a pure function.</source>
          <target state="translated">下面的示例对比两个非纯函数和一个纯函数。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Non-Pure Function that Changes a Class Member</source>
          <target state="translated">可更改类成员的非纯函数</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In the following code, the <ph id="ph1">`HypenatedConcat`</ph> function is not a pure function, because it modifies the <ph id="ph2">`aMember`</ph> data member in the class:</source>
          <target state="translated">在下面的代码中，<ph id="ph1">`HypenatedConcat`</ph> 函数不是纯函数，因为它修改了类中的 <ph id="ph2">`aMember`</ph> 数据成员：</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This code produces the following output:</source>
          <target state="translated">此代码生成以下输出：</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Note that it is irrelevant whether the data being modified has <ph id="ph1">`public`</ph> or <ph id="ph2">`private`</ph> access, or is a  <ph id="ph3">`shared`</ph> member or an instance member.</source>
          <target state="translated">请注意，它是不相关是否被修改的数据具有<ph id="ph1">`public`</ph>或<ph id="ph2">`private`</ph>访问或者是<ph id="ph3">`shared`</ph>成员还是实例成员。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>A pure function does not change any data outside of the function.</source>
          <target state="translated">纯函数不会更改函数以外的任何数据。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Non-Pure Function that Changes an Argument</source>
          <target state="translated">可更改参数的非纯函数</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Furthermore, the following version of this same function is not pure because it modifies the contents of its parameter, <ph id="ph1">`sb`</ph>.</source>
          <target state="translated">此外，此同一个函数的下面版本不是纯函数，因为它修改了其参数 <ph id="ph1">`sb`</ph> 的内容。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This version of the program produces the same output as the first version, because the <ph id="ph1">`HypenatedConcat`</ph> function has changed the value (state) of its first parameter by invoking the &lt;xref:System.Text.StringBuilder.Append%2A&gt; member function.</source>
          <target state="translated">此版本的程序生成的相同的输出与第一个版本，因为<ph id="ph1">`HypenatedConcat`</ph>函数通过调用更改了其第一个参数的值 （状态）&lt;xref:System.Text.StringBuilder.Append%2A&gt;成员函数。&lt;/xref:System.Text.StringBuilder.Append%2A&gt;</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Note that this alteration occurs despite that fact that <ph id="ph1">`HypenatedConcat`</ph> uses call-by-value parameter passing.</source>
          <target state="translated">请注意，即使 <ph id="ph1">`HypenatedConcat`</ph> 实际上使用了按值调用参数传递，也会发生此更改。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For reference types, if you pass a parameter by value, it results in a copy of the reference to an object being passed.</source>
          <target state="translated">对于引用类型，按值传递参数会得到对所传递对象的引用的副本。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This copy is still associated with the same instance data as the original reference (until the reference variable is assigned to a new object).</source>
          <target state="translated">此副本与原始引用一样，仍与同一个实例数据关联（除非为引用变量分配新对象）。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Call-by-reference is not necessarily required for a function to modify a parameter.</source>
          <target state="translated">函数修改参数不一定需要按引用调用。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Pure Function</source>
          <target state="translated">纯函数</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This next version of the program hows how to implement the <ph id="ph1">`HypenatedConcat`</ph> function as a pure function.</source>
          <target state="translated">下面版本的程序演示如何将 <ph id="ph1">`HypenatedConcat`</ph> 函数作为纯函数实现。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Again, this version produces the same line of output: <ph id="ph1">`StringOne-StringTwo`</ph>.</source>
          <target state="translated">此版本同样生成相同的输出行：<ph id="ph1">`StringOne-StringTwo`</ph>。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Note that to retain the concatenated value, it is stored in the intermediate variable <ph id="ph1">`s2`</ph>.</source>
          <target state="translated">请注意保留串联值，它存储在中间变量 <ph id="ph1">`s2`</ph> 中。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>One approach that can be very useful is to write functions that are locally impure (that is, they declare and modify local variables) but are globally pure.</source>
          <target state="translated">一种非常实用的方法是编写本地不纯（即声明和修改本地变量）但在全局为纯的函数。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Such functions have many of the desirable composability characteristics, but avoid some of the more convoluted functional programming idioms, such as having to use recursion when a simple loop would accomplish the same thing.</source>
          <target state="translated">这些函数具有许多需要的可组合特性，但舍弃了一些较为繁复的函数编程语法，如在使用简单的循环即可完成同样操作时必须使用递归。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Standard Query Operators</source>
          <target state="translated">标准查询运算符</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>An important characteristic of the standard query operators is that they are implemented as pure functions.</source>
          <target state="translated">标准查询运算符的重要特性是它们以纯函数的形式实现。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Standard Query Operators Overview (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>标准查询运算符概述 (Visual Basic 中)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)</ept>。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">另请参阅</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Introduction to Pure Functional Transformations (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>介绍纯函数转换 (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Functional Programming vs. Imperative Programming (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/functional-programming-vs-imperative-programming.md)</ept></source>
          <target state="translated"><bpt id="p1"> [</bpt>函数编程与命令式编程 (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/functional-programming-vs-imperative-programming.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>