<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6aa304f5c4ed400faddd3869006cdd011aa06466</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\grouping.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2017a86039e285c3f7e84539ab1e03b25993ee39</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7faad857c3326bcbf1815b67708e4e9622566dc1</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file grouping.33793cd2e6bf04d024a452f85e13089b2709b3dd.zh-tw.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">規則運算式中的群組建構</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">規則運算式中的群組建構</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET, .NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Grouping constructs in regular expressions</source>
          <target state="translated">規則運算式中的群組建構</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</source>
          <target state="translated">群組建構會描寫規則運算式的子運算式，以及擷取輸入字串的子字串。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can use grouping constructs to do the following:</source>
          <target state="translated">您可以使用群組建構來執行下列作業：</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Match a subexpression that is repeated in the input string.</source>
          <target state="translated">比對輸入字串中重複的子運算式。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Apply a quantifier to a subexpression that has multiple regular expression language elements.</source>
          <target state="translated">將數量詞套用至具有多個規則運算式語言項目的子運算式。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more information about quantifiers, see <bpt id="p1">[</bpt>Quantifiers in regular expressions<ept id="p1">](quantifiers.md)</ept>.</source>
          <target state="translated">如需數量詞的詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式中的數量詞<ept id="p1">](quantifiers.md)</ept>。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Include a subexpression in the string that is returned by the <bpt id="p1">[</bpt>Regex.Replace<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> and <bpt id="p2">[</bpt>Match.Result<ept id="p2">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> methods.</source>
          <target state="translated">在 <bpt id="p1">[</bpt>Regex.Replace<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> 和 <bpt id="p2">[</bpt>Match.Result<ept id="p2">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> 方法傳回的字串中包含子運算式。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Retrieve individual subexpressions from the <bpt id="p1">[</bpt>Match.Groups<ept id="p1">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property and process them separately from the matched text as a whole.</source>
          <target state="translated">從 <bpt id="p1">[</bpt>Match.Groups<ept id="p1">](xref:System.Text.RegularExpressions.Match.Groups)</ept> 屬性擷取個別子運算式，再全部一起與相符文字分開處理。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following table lists the grouping constructs supported by .NET regular expression engine and indicates whether they are capturing or non-capturing.</source>
          <target state="translated">下表列出 .NET 規則運算式引擎支援的群組建構，並指出其為擷取或非擷取。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Grouping construct</source>
          <target state="translated">群組建構</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Capturing or noncapturing</source>
          <target state="translated">擷取或非擷取</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Matched subexpressions<ept id="p1">](#matched-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>相符的子運算式<ept id="p1">](#matched-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">擷取</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Named matched subexpressions<ept id="p1">](#named-matched-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>相符的具名子運算式<ept id="p1">](#named-matched-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">擷取</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Balancing group definitions<ept id="p1">](#balancing-group-definitions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>平衡群組定義<ept id="p1">](#balancing-group-definitions)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Capturing</source>
          <target state="translated">擷取</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Noncapturing groups<ept id="p1">](#noncapturing-groups)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>非擷取群組<ept id="p1">](#noncapturing-groups)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非擷取</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Group options<ept id="p1">](#group-options)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>群組選項<ept id="p1">](#group-options)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非擷取</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width positive lookahead assertions<ept id="p1">](#zero-width-positive-lookahead-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>零寬度右合樣 (Positive Lookahead) 判斷提示<ept id="p1">](#zero-width-positive-lookahead-assertions)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非擷取</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width negative lookahead assertions<ept id="p1">](#zero-width-negative-lookahead-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>零寬度右不合樣 (Negative Lookahead) 判斷提示<ept id="p1">](#zero-width-negative-lookahead-assertions)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非擷取</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width positive lookbehind assertions<ept id="p1">](#zero-width-positive-lookbehind-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>零寬度左合樣 (Positive Lookbehind) 判斷提示<ept id="p1">](#zero-width-positive-lookbehind-assertions)</ept></target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非擷取</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Zero-width negative lookbehind assertions<ept id="p1">](#zero-width-negative-lookbehind-assertions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>零寬度左不合樣 (Negative Lookbehind) 判斷提示<ept id="p1">](#zero-width-negative-lookbehind-assertions)</ept></target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非擷取</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nonbacktracking subexpressions<ept id="p1">](#nonbacktracking-subexpressions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>非回溯子運算式<ept id="p1">](#nonbacktracking-subexpressions)</ept></target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Noncapturing</source>
          <target state="translated">非擷取</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For information on groups and the regular expression object model, see <bpt id="p1">[</bpt>Grouping Constructs and Regular Expression Objects<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>.</source>
          <target state="translated">如需群組和規則運算式物件模型的資訊，請參閱<bpt id="p1">[</bpt>群組建構和規則運算式物件<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Matched subexpressions</source>
          <target state="translated">相符子運算式</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following grouping construct captures a matched subexpression:</source>
          <target state="translated">下列群組建構會擷取相符子運算式：</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">其中 <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 是任何有效的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</source>
          <target state="translated">使用括號的擷取會依據規則運算式中的左括號順序，從一開始，由左至右自動編號。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The capture that is numbered zero is the text matched by the entire regular expression pattern.</source>
          <target state="translated">編號零的擷取是整個規則運算式模式比對的文字。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>By default, the (subexpression) language element captures the matched subexpression.</source>
          <target state="translated">根據預設，(subexpression) 語言項目會擷取相符的子運算式。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>But if the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression (see Group options later in this topic), the matched subexpression is not captured.</source>
          <target state="translated">但是如果規則運算式模式比對方法的 RegexOptions 參數包含 RegexOptions.ExplicitCapture 旗標，或這個子運算式套用了 n 選項 (請參閱本主題稍後的＜群組選項＞)，則不會擷取相符的子運算式。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can access captured groups in four ways:</source>
          <target state="translated">您可以用四種方式來存取擷取群組：</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>By using the backreference construct within the regular expression.</source>
          <target state="translated">在規則運算式中使用反向參考建構。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept>, where <ept id="p1">*</ept>number* is the ordinal number of the captured subexpression.</source>
          <target state="translated">使用語法 <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept> (其中 where <ept id="p1">*</ept>number* 是所擷取子運算式的序號)，在相同的規則運算式中參考相符的子運算式。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>By using the named backreference construct within the regular expression.</source>
          <target state="translated">在規則運算式中使用具名的反向參考建構。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, where <bpt id="p4">*</bpt>name<ept id="p4">*</ept> is the name of a capturing group, or <bpt id="p5">**</bpt>\k<ept id="p5">**</ept><bpt id="p6">_</bpt>&lt;number<ept id="p6">_</ept><bpt id="p7">**</bpt><ph id="ph2">&gt;</ph><ept id="p7">**</ept>, where <bpt id="p8">*</bpt>number<ept id="p8">*</ept> is the ordinal number of a capturing group.</source>
          <target state="translated">使用語法 <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> (其中 <bpt id="p4">*</bpt>name<ept id="p4">*</ept> 是擷取群組的名稱) 或 <bpt id="p5">**</bpt>\k<ept id="p5">**</ept><bpt id="p6">_</bpt>&lt;number<ept id="p6">_</ept><bpt id="p7">**</bpt><ph id="ph2">&gt;</ph><ept id="p7">**</ept> (其中 <bpt id="p8">*</bpt>number<ept id="p8">*</ept> 是擷取群組的序號)，在相同的規則運算式中參考相符的子運算式。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A capturing group has a default name that is identical to its ordinal number.</source>
          <target state="translated">擷取群組的預設名稱與其序號相同。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For more information, see Grouping constructs and regular expression objects later in this topic.</source>
          <target state="translated">如需詳細資訊，請參閱本主題稍後的＜群組建構和規則運算式物件＞。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> replacement sequence in a <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p5">*</bpt>number<ept id="p5">*</ept> is the ordinal number of the captured subexpression.</source>
          <target state="translated">在 <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> 或 <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> 方法呼叫中使用 <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> 取代順序，其中 <bpt id="p5">*</bpt>number<ept id="p5">*</ept> 是所擷取子運算式的序號。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Programmatically, by using the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">以程式設計方式，使用 <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> 屬性傳回的 <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 物件。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The member at position zero in the collection represents the entire regular expression match.</source>
          <target state="translated">集合中位置為零的成員代表整個規則運算式相符。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Each subsequent member represents a matched subexpression.</source>
          <target state="translated">每個後續成員各代表一個相符子運算式。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Grouping Constructs and Regular Expression Objects<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept> section.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>群組建構和規則運算式物件<ept id="p1">](#grouping-constructs-and-regular-expression-objects)</ept>一節。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that identifies duplicated words in text.</source>
          <target state="translated">下列範例說明可識別文字中重複文字的規則運算式。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</source>
          <target state="translated">規則運算式模式的兩個擷取群組代表重複文字的兩個執行個體。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The second instance is captured to report its starting position in the input string.</source>
          <target state="translated">擷取第二個執行個體是為了報告其於輸入字串中的開始位置。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is the following:</source>
          <target state="translated">規則運算式模式如下：</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">下表顯示規則運算式模式的解譯方式。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">這是第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">比對空白字元。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Match the string in the first captured group.</source>
          <target state="translated">比對第一個擷取群組中的字串。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">這是第二個擷取群組。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the <ph id="ph1">`Match.Index`</ph> property.</source>
          <target state="translated">此範例將其指派給擷取群組，以便從 <ph id="ph1">`Match.Index`</ph> 屬性擷取重複文字的開始位置。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Match a non-word character, including white space and punctuation.</source>
          <target state="translated">比對非文字字元，包括空格和標點符號。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</source>
          <target state="translated">如此可防止規則運算式模式比對以第一個擷取群組中的文字為開頭的文字。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Named matched subexpressions</source>
          <target state="translated">具名的相符子運算式</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following grouping construct captures a matched subexpression and lets you access it by name or by number:</source>
          <target state="translated">下列群組建構會擷取相符子運算式，並可讓您依名稱或依號碼加以存取。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">或：</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is a valid group name, and <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">其中 <bpt id="p1">*</bpt>name<ept id="p1">*</ept> 是有效的群組名稱，而 <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept> 是任何有效的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>name<ept id="p1">*</ept> must not contain any punctuation characters and cannot begin with a number.</source>
          <target state="translated"><bpt id="p1">*</bpt>name<ept id="p1">*</ept> 絕不能包含任何標點符號字元，而且不能以數字開頭。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> parameter of a regular expression pattern matching method includes the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> flag, or if the <bpt id="p3">**</bpt>n<ept id="p3">**</ept> option is applied to this subexpression (see <bpt id="p4">[</bpt>Group options<ept id="p4">](#group-options)</ept> later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</source>
          <target state="translated">如果規則運算式模式比對方法的 <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 參數包含 <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> 旗標，或這個子運算式套用了 <bpt id="p3">**</bpt>n<ept id="p3">**</ept> 選項 (請參閱本主題稍後的<bpt id="p4">[</bpt>群組選項<ept id="p4">](#group-options)</ept>)，則擷取子運算式的唯一方式，就是明確地為擷取群組命名。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>You can access named captured groups in the following ways:</source>
          <target state="translated">您可以用下列方式來存取具名的擷取群組：</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>By using the named backreference construct within the regular expression.</source>
          <target state="translated">在規則運算式中使用具名的反向參考建構。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept>, where <bpt id="p4">*</bpt>name<ept id="p4">*</ept> is the name of the captured subexpression.</source>
          <target state="translated">使用語法 <bpt id="p1">**</bpt>\k&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> (其中 <bpt id="p4">*</bpt>name<ept id="p4">*</ept> 是所擷取子運算式的名稱)，在相同的規則運算式中參考相符的子運算式。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>By using the backreference construct within the regular expression.</source>
          <target state="translated">在規則運算式中使用反向參考建構。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The matched subexpression is referenced in the same regular expression by using the syntax <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept>, where <ept id="p1">*</ept>number* is the ordinal number of the captured subexpression.</source>
          <target state="translated">使用語法 <bpt id="p1">*</bpt><bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept><bpt id="p3">_</bpt>number<ept id="p3">_</ept> (其中 where <ept id="p1">*</ept>number* 是所擷取子運算式的序號)，在相同的規則運算式中參考相符的子運算式。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</source>
          <target state="translated">具名的相符子運算式會在相符子運算式之後，由左至右連續編號。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt>${<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> replacement sequence in a <bpt id="p4">[</bpt>Regex.Replace<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p5">[</bpt>Match.Result<ept id="p5">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p6">*</bpt>name<ept id="p6">*</ept> is the name of the captured subexpression.</source>
          <target state="translated">在 <bpt id="p4">[</bpt>Regex.Replace<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> 或 <bpt id="p5">[</bpt>Match.Result<ept id="p5">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> 方法呼叫中使用 <bpt id="p1">**</bpt>${<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> 取代順序，其中 <bpt id="p6">*</bpt>name<ept id="p6">*</ept> 是所擷取之子運算式的名稱。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> replacement sequence in a <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> or <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> method call, where <bpt id="p5">*</bpt>number<ept id="p5">*</ept> is the ordinal number of the captured subexpression.</source>
          <target state="translated">在 <bpt id="p3">[</bpt>Regex.Replace<ept id="p3">](xref:System.Text.RegularExpressions.Regex.Replace(System.String,System.String))</ept> 或 <bpt id="p4">[</bpt>Match.Result<ept id="p4">](xref:System.Text.RegularExpressions.Match.Result(System.String))</ept> 方法呼叫中使用 <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept><bpt id="p2">_</bpt>number<ept id="p2">_</ept> 取代順序，其中 <bpt id="p5">*</bpt>number<ept id="p5">*</ept> 是所擷取子運算式的序號。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Programmatically, by using the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object returned by the <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">以程式設計方式，使用 <bpt id="p2">[</bpt>Match.Groups<ept id="p2">](xref:System.Text.RegularExpressions.Match.Groups)</ept> 屬性傳回的 <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 物件。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The member at position zero in the collection represents the entire regular expression match.</source>
          <target state="translated">集合中位置為零的成員代表整個規則運算式相符。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Each subsequent member represents a matched subexpression.</source>
          <target state="translated">每個後續成員各代表一個相符子運算式。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Named captured groups are stored in the collection after numbered captured groups.</source>
          <target state="translated">具名的擷取群組儲存在集合中，編號的擷取群組之後。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Programmatically, by providing the subexpression name to the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object's indexer  (in C#) or to its Item property (in Visual Basic).</source>
          <target state="translated">以程式設計方式，提供子運算式名稱給 <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 物件的索引子 (在 C# 中) 或其 Item 屬性 (在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</source>
          <target state="translated">有一個簡單的規則運算式模式，說明如何以程式設計方式，或是使用規則運算式語言語法，來參考編號 (未具名) 和具名群組。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`((?&lt;One&gt;abc)\d+)?(?&lt;Two&gt;xyz)(.*)`</ph> produces the following capturing groups by number and by name.</source>
          <target state="translated">規則運算式 <ph id="ph1">`((?&lt;One&gt;abc)\d+)?(?&lt;Two&gt;xyz)(.*)`</ph> 會依號碼或依名稱產生下列擷取群組。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The first capturing group (number 0) always refers to the entire pattern.</source>
          <target state="translated">第一個擷取群組 (編號 0) 一律參考整個模式。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">數字</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">名稱</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>0 (default name)</source>
          <target state="translated">0 (預設名稱)</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>1 (default name)</source>
          <target state="translated">1 (預設名稱)</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>2 (default name)</source>
          <target state="translated">2 (預設名稱)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>One</source>
          <target state="translated">一</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Two</source>
          <target state="translated">二</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</source>
          <target state="translated">下列範例說明的規則運算式可識別重複文字，以及緊接在每個重複文字後面的文字。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The regular expression pattern defines two named subexpressions: <ph id="ph1">`duplicateWord`</ph>, which represents the duplicated word; and <ph id="ph2">`nextWord`</ph>, which represents the word that follows the duplicated word.</source>
          <target state="translated">規則運算式模式會定義兩個具名子運算式：<ph id="ph1">`duplicateWord`</ph> 代表重複文字，而 <ph id="ph2">`nextWord`</ph> 代表接在重複文字後面的文字。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is as follows:</source>
          <target state="translated">規則運算式模式如下：</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression is interpreted.</source>
          <target state="translated">下表顯示規則運算式的解譯方式。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`duplicateWord`</ph>.</source>
          <target state="translated">將此擷取群組命名為 <ph id="ph1">`duplicateWord`</ph>。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">比對空白字元。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Match the string from the captured group that is named <ph id="ph1">`duplicateWord`</ph>.</source>
          <target state="translated">從名為 <ph id="ph1">`duplicateWord`</ph> 的擷取群組比對字串。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Match a non-word character, including white space and punctuation.</source>
          <target state="translated">比對非文字字元，包括空格和標點符號。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</source>
          <target state="translated">如此可防止規則運算式模式比對以第一個擷取群組中的文字為開頭的文字。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Name this capturing group <ph id="ph1">`nextWord`</ph>.</source>
          <target state="translated">將此擷取群組命名為 <ph id="ph1">`nextWord`</ph>。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Note that a group name can be repeated in a regular expression.</source>
          <target state="translated">請注意可以在規則運算式中重複群組名稱。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>For example, it is possible for more than one group to be named <ph id="ph1">`digit`</ph>, as the following example illustrates.</source>
          <target state="translated">例如，可能會有多於一個群組命名為 <ph id="ph1">`digit`</ph>，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>In the case of duplicate names, the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object is determined by the last successful capture in the input string.</source>
          <target state="translated">對於重複名稱的案例，<bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 物件的值取決於輸入字串中的最後一個成功擷取。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>In addition, the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> is populated with information about each capture just as it would be if the group name was not duplicated.</source>
          <target state="translated">此外，將每個擷取的相關資訊填入 <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept>，就如同群組名稱不重複的情況。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression <ph id="ph1">`\D+(?&lt;digit&gt;\d+)\D+(?&lt;digit&gt;\d+)?`</ph> includes two occurrences of a group named <ph id="ph2">`digit`</ph>.</source>
          <target state="translated">在下列範例中，規則運算式 <ph id="ph1">`\D+(?&lt;digit&gt;\d+)\D+(?&lt;digit&gt;\d+)?`</ph> 包含兩次出現名為 <ph id="ph2">`digit`</ph> 的群組。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The first <ph id="ph1">`digit`</ph> named group captures one or more digit characters.</source>
          <target state="translated">第一個 <ph id="ph1">`digit`</ph> 具名群組擷取一或多個數字字元。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The second <ph id="ph1">`digit`</ph> named group captures either zero or one occurrence of one or more digit characters.</source>
          <target state="translated">第二個 <ph id="ph1">`digit`</ph> 具名群組擷取一或多個數字字元的零次或一次發生。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object.</source>
          <target state="translated">如範例的輸出所示，如果第二個擷取群組成功地與文字相符，該文字的值會定義 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 物件的值。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object.</source>
          <target state="translated">如果第二個擷取群組不符合輸入字串，則上一次成功比對的值會定義 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 物件的值。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The following table shows how the regular expression is interpreted.</source>
          <target state="translated">下表顯示規則運算式的解譯方式。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Match one or more non-decimal digit characters.</source>
          <target state="translated">比對一個或更多非十進位數字字元。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digit characters.</source>
          <target state="translated">比對一個或更多十進位數字字元。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Assign the match to the <ph id="ph1">`digit`</ph> named group.</source>
          <target state="translated">指派 <ph id="ph1">`digit`</ph> 具名群組的比對。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Match one or more non-decimal digit characters.</source>
          <target state="translated">比對一個或更多非十進位數字字元。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of one or more decimal digit characters.</source>
          <target state="translated">比對一或多個十進位數字字元的零次或一次發生。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Assign the match to the <ph id="ph1">`digit`</ph> named group.</source>
          <target state="translated">指派 <ph id="ph1">`digit`</ph> 具名群組的比對。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Balancing group definitions</source>
          <target state="translated">平衡群組定義</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</source>
          <target state="translated">平衡群組定義會刪除先前定義之群組的定義，並且在目前群組中儲存先前定義的群組與目前群組之間的間隔。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>This grouping construct has the following format:</source>
          <target state="translated">此群組建構的格式如下：</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">或：</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> is the current group (optional), <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> is a previously defined group, and <bpt id="p3">*</bpt>subexpression<ept id="p3">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">其中 <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> 是目前群組 (選擇性)，<bpt id="p2">*</bpt>name2<ept id="p2">*</ept> 是先前定義的群組，而 <bpt id="p3">*</bpt>subexpression<ept id="p3">*</ept> 是任何有效的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The balancing group definition deletes the definition of <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> and stores the interval between <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> and <bpt id="p3">*</bpt>name1<ept id="p3">*</ept> in <bpt id="p4">*</bpt>name1<ept id="p4">*</ept>.</source>
          <target state="translated">平衡群組定義會刪除 <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> 的定義，並且將 <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> 與 <bpt id="p3">*</bpt>name1<ept id="p3">*</ept> 之間的間隔儲存在 <bpt id="p4">*</bpt>name1<ept id="p4">*</ept> 中。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>If no <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> group is defined, the match backtracks.</source>
          <target state="translated">如果沒有定義 <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> 群組，比對結果會回溯。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Because deleting the last definition of <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> reveals the previous definition of <bpt id="p2">*</bpt>name2<ept id="p2">*</ept>, this construct lets you use the stack of captures for group <bpt id="p3">*</bpt>name2<ept id="p3">*</ept> as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</source>
          <target state="translated">因為刪除 <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> 的最後一個定義會顯示 <bpt id="p2">*</bpt>name2<ept id="p2">*</ept> 的上一個定義，所以此建構可讓您將擷取堆疊用於群組 <bpt id="p3">*</bpt>name2<ept id="p3">*</ept>，以作為追蹤巢狀建構 (例如圓括弧或左右方括弧) 的計數器。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The balancing group definition uses <bpt id="p1">*</bpt>name2<ept id="p1">*</ept>as a stack.</source>
          <target state="translated">平衡群組定義將 <bpt id="p1">*</bpt>name2<ept id="p1">*</ept> 當做堆疊使用。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The beginning character of each nested construct is placed in the group and in its <bpt id="p1">[</bpt>Group.Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collection.</source>
          <target state="translated">每個巢狀建構的開頭字元都會放在群組及其 <bpt id="p1">[</bpt>Group.Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> 集合中。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>When the closing character is matched, its corresponding opening character is removed from the group, and the <bpt id="p1">[</bpt>Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> collection is decreased by one.</source>
          <target state="translated">找到配對的結尾字元時，就會從群組中移除其對應的開頭字元，而 <bpt id="p1">[</bpt>Captures<ept id="p1">](xref:System.Text.RegularExpressions.Group.Captures)</ept> 集合中就會減少一個。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>After the opening and closing characters of all nested constructs have been matched, <bpt id="p1">*</bpt>name1<ept id="p1">*</ept> is empty.</source>
          <target state="translated">所有巢狀建構的開頭和結尾字元都配成對之後，<bpt id="p1">*</bpt>name1<ept id="p1">*</ept> 就空了。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</source>
          <target state="translated">在您修改下列範例中的規則運算式來使用巢狀建構的適當開頭和結尾字元之後，即可用它來處理大部分的巢狀建構，例如包含多個巢狀方法呼叫的數學運算式或程式碼字行。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The following example uses a balancing group definition to match left and right angle brackets (&lt;&gt;) in an input string.</source>
          <target state="translated">下列範例使用平衡群組定義來比對輸入字串中的左右角括號 (&lt;&gt;)。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The example defines two named groups, <ph id="ph1">`Open`</ph> and <ph id="ph2">`Close`</ph>, that are used like a stack to track matching pairs of angle brackets.</source>
          <target state="translated">此範例定義兩個具名群組 <ph id="ph1">`Open`</ph> 和 <ph id="ph2">`Close`</ph>，像堆疊一樣可用來追蹤成對的角括號。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Each captured left angle bracket is pushed into the capture collection of the <ph id="ph1">`Open`</ph> group, and each captured right angle bracket is pushed into the capture collection of the <ph id="ph2">`Close`</ph> group.</source>
          <target state="translated">所擷取的每個左角括號都會被推送至 <ph id="ph1">`Open`</ph> 群組的擷取集合中，而所擷取的每個右角括號都會被推送至 <ph id="ph2">`Close`</ph> 群組的擷取集合中。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</source>
          <target state="translated">平衡群組定義可確保每個左角括號都有成對的右角括號。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>If there is not, the final subpattern, <ph id="ph1">`(?(Open)(?!))`</ph>, is evaluated only if the <ph id="ph2">`Open`</ph> group is not empty (and, therefore, if all nested constructs have not been closed).</source>
          <target state="translated">如果沒有，唯有當 <ph id="ph1">`(?(Open)(?!))`</ph> 群組不是空的 (而因此如果所有巢狀建構都未關閉)，才會評估最後的子模式 <ph id="ph2">`Open`</ph>。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>If the final subpattern is evaluated, the match fails, because the <ph id="ph1">`(?!)`</ph> subpattern is a zero-width negative lookahead assertion that always fails.</source>
          <target state="translated">如果評估最後的子模式，比對會失敗，因為 <ph id="ph1">`(?!)`</ph> 子模式是一律會失敗的零寬度右不合樣 (Negative Lookahead) 判斷提示。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is:</source>
          <target state="translated">規則運算式模式為：</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The regular expression is interpreted as follows:</source>
          <target state="translated">規則運算式解譯如下：</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Begin at the start of the string.</source>
          <target state="translated">從字串開頭開始。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Match zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">比對非左右角括號的零或多個字元。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Match a left angle bracket and assign it to a group named <ph id="ph1">`Open`</ph>.</source>
          <target state="translated">比對左角括號，並將其指派給名為 <ph id="ph1">`Open`</ph> 的群組。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Match zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">比對非左右角括號的零或多個字元。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</source>
          <target state="translated">比對出現一或數次、後面接零或多個非左右角括號字元的左角括號。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">這是第二個擷取群組。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Match a right angle bracket, assign the substring between the <ph id="ph1">`Open`</ph> group and the current group to the <ph id="ph2">`Close`</ph> group, and delete the definition of the <ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">比對右角括號，將 <ph id="ph1">`Open`</ph> 群組與目前群組之間的子字串指派給 <ph id="ph2">`Close`</ph> 群組，並刪除 <ph id="ph3">`Open`</ph> 群組的定義。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of any character that is neither a left nor a right angle bracket.</source>
          <target state="translated">比對出現零或數次、非左右角括弧的任何字元。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</source>
          <target state="translated">比對出現一或數次、後接零或多個非左右角括號字元的右角括號。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>When matching the right angle bracket, assign the substring between the <ph id="ph1">`Open`</ph> group and the current group to the <ph id="ph2">`Close`</ph> group, and delete the definition of the<ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">比對右角括弧時，將 <ph id="ph1">`Open`</ph> 群組與目前群組之間的子字串指派給 <ph id="ph2">`Close`</ph> 群組，並刪除 <ph id="ph3">`Open`</ph> 群組的定義。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>This is the third capturing group.</source>
          <target state="translated">這是第三個擷取群組。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</source>
          <target state="translated">比對出現零或數次的下列模式：出現一或數次的左角括號，後接零或多個非角括號字元，後接出現一或數次的右角括號，後接出現零或數次的非角括號。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>When matching the right angle bracket, delete the definition of the <ph id="ph1">`Open`</ph> group, and assign the substring between the <ph id="ph2">`Open`</ph> group and the current group to the <ph id="ph3">`Close`</ph> group.</source>
          <target state="translated">比對右角括號時，刪除 <ph id="ph1">`Open`</ph> 群組的定義，並將 <ph id="ph2">`Open`</ph> 群組與目前群組之間的子字串指派給 <ph id="ph3">`Close`</ph> 群組。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">這是第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Open`</ph> group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</source>
          <target state="translated">如果 <ph id="ph1">`Open`</ph> 群組存在，若可以比對空字串，則放棄比對，但不要將字串中的規則運算式引擎的位置向前移動。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>This is a zero-width negative lookahead assertion.</source>
          <target state="translated">這是零寬度右不合樣 (Negative Lookahead) 判斷提示。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Because an empty string is always implicitly present in an input string, this match always fails.</source>
          <target state="translated">因為空字串一律以隱含方式存在於輸入字串中，所以此比對一定會失敗。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Failure of this match indicates that the angle brackets are not balanced.</source>
          <target state="translated">此比對失敗表示角括號不平衡。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Match the end of the input string.</source>
          <target state="translated">比對輸入字串的結尾。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The final subexpression, <ph id="ph1">`(?(Open)(?!))`</ph>, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</source>
          <target state="translated">最後的子運算式 <ph id="ph1">`(?(Open)(?!))`</ph> 指出輸入字串中的巢狀建構是否正確平衡 (例如，是否每個左角括號都有配對的右角括號)。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>It uses conditional matching based on a valid captured group; for more information, see <bpt id="p1">[</bpt>Alternation constructs in regular expressions<ept id="p1">](alternation.md)</ept>.</source>
          <target state="translated">其使用條件式比對，以有效的擷取群組為基礎；如需詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式中的替代建構<ept id="p1">](alternation.md)</ept>。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Open`</ph> group is defined, the regular expression engine attempts to match the subexpression <ph id="ph2">`(?!)`</ph> in the input string.</source>
          <target state="translated">如果已定義 <ph id="ph1">`Open`</ph> 群組，規則運算式引擎會嘗試比對輸入字串中的子運算式 <ph id="ph2">`(?!)`</ph>。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group should be defined only if nesting constructs are unbalanced.</source>
          <target state="translated">唯有當巢狀建構不平衡時，才應定義 <ph id="ph1">`Open`</ph> 群組。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</source>
          <target state="translated">因此，要在輸入字串中比對的模式，應該是一律導致比對失敗的模式。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In this case, <ph id="ph1">`(?!)`</ph> is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</source>
          <target state="translated">在這個情況下，<ph id="ph1">`(?!)`</ph> 是一律失敗的零寬度右不合樣 (Negative Lookahead) 判斷提示，因為空字串一律以隱含方式存在於輸入字串中。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>In the example, the regular expression engine evaluates the input string "<ph id="ph1">&lt;abc&gt;</ph>&lt;mno<ph id="ph2">&lt;xyz&gt;</ph>&gt;" as shown in the following table.</source>
          <target state="translated">在這個範例中，規則運算式引擎會評估輸入字串 "<ph id="ph1">&lt;abc&gt;</ph>&lt;mno<ph id="ph2">&lt;xyz&gt;</ph>&gt;"，如下表所示。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Step</source>
          <target state="translated">步驟</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">結果</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Starts the match at the beginning of the input string</source>
          <target state="translated">從輸入字串的開頭開始比對。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters before the left angle bracket;finds no matches.</source>
          <target state="translated">在左角括號之前尋找非角括號字元；沒有找到配對。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;abc&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">比對 "<ph id="ph1">&lt;abc&gt;</ph>" 中的左角括弧，並將其指派給 <ph id="ph2">`Open`</ph> 群組。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Matches "abc".</source>
          <target state="translated">比對 "abc"。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="translated">5</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>"&lt;abc" is the value of the second captured group.</source>
          <target state="translated">"&lt;abc" 是第二個擷取群組的值。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">輸入字串中的下一個字元不是左角括號，所以規則運算式引擎未回送至 <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>6</source>
          <target state="translated">6</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Matches the right angle bracket in "<ph id="ph1">&lt;abc&gt;</ph>", assigns "abc", which is the substring between the <ph id="ph2">`Open`</ph> group and the right angle bracket, to the <ph id="ph3">`Close`</ph> group, and deletes the current value ("&lt;") of the <ph id="ph4">`Open`</ph> group, leaving it empty.</source>
          <target state="translated">比對 "<ph id="ph1">&lt;abc&gt;</ph>" 中的右角括弧，將 "abc" (<ph id="ph2">`Open`</ph> 群組與右角括弧之間的子字串) 指派給 <ph id="ph3">`Close`</ph> 群組，並刪除 <ph id="ph4">`Open`</ph> 群組的目前值 ("&lt;")，使其空白。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>7</source>
          <target state="translated">7</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters after the right angle bracket; finds no matches.</source>
          <target state="translated">在右角括號之後尋找非角括號字元；沒有找到配對。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>8</source>
          <target state="translated">8</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">第三個擷取群組的值是 "&gt;"。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">輸入字串中的下一個字元不是右角括號，所以規則運算式引擎未回送至 <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>9</source>
          <target state="translated">9</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The value of the first captured group is "<ph id="ph1">&lt;abc&gt;</ph>".</source>
          <target state="translated">第一個擷取群組的值是 "<ph id="ph1">&lt;abc&gt;</ph>"。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The next character in the input string is a left angle bracket, so the regular expression engine loops back to the <ph id="ph1">`(((?'Open'&lt;)`</ph> subpattern.</source>
          <target state="translated">輸入字串中的下一個字元是左角括弧，所以規則運算式引擎會回送至 <ph id="ph1">`(((?'Open'&lt;)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>10</source>
          <target state="translated">10</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;mno&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">比對 "<ph id="ph1">&lt;mno&gt;</ph>" 中的左角括弧，並將其指派給 <ph id="ph2">`Open`</ph> 群組。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`Group.Captures`</ph> collection now has a single value, "&lt;".</source>
          <target state="translated">其 <ph id="ph1">`Group.Captures`</ph> 集合現在有單一值 "&lt;"。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>11</source>
          <target state="translated">11</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Matches "mno".</source>
          <target state="translated">比對 "mno"。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>12</source>
          <target state="translated">12</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>"&lt;mno" is the value of the second captured group.</source>
          <target state="translated">"&lt;mno" 是第二個擷取群組的值。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The next character in the input string is an left angle bracket, so the regular expression engine loops back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">輸入字串中的下一個字元是左角括號，所以規則運算式引擎會回送至 <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>13</source>
          <target state="translated">13</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Matches the left angle bracket in "<ph id="ph1">&lt;xyz&gt;</ph>" and assigns it to the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">比對 "<ph id="ph1">&lt;xyz&gt;</ph>" 中的左角括弧，並將其指派給 <ph id="ph2">`Open`</ph> 群組。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Group.Captures`</ph> collection of the <ph id="ph2">`Open`</ph> group now includes two captures: the left angle bracket from "<ph id="ph3">&lt;mno&gt;</ph>", and the left angle bracket from "<ph id="ph4">&lt;xyz&gt;</ph>".</source>
          <target state="translated">現在 <ph id="ph2">`Open`</ph> 群組的 <ph id="ph1">`Group.Captures`</ph> 集合包含兩個擷取："<ph id="ph3">&lt;mno&gt;</ph>" 的左角括弧，以及 "<ph id="ph4">&lt;xyz&gt;</ph>" 的左角括弧。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Matches "xyz".</source>
          <target state="translated">比對 "xyz"。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>"&lt;xyz" is the value of the second captured group.</source>
          <target state="translated">"&lt;xyz" 是第二個擷取群組的值。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">輸入字串中的下一個字元不是左角括號，所以規則運算式引擎未回送至 <ph id="ph1">`(?'Open'&lt;)[^&lt;&gt;]*)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Matches the right angle bracket in "<ph id="ph1">&lt;xyz&gt;</ph>".</source>
          <target state="translated">比對 "<ph id="ph1">&lt;xyz&gt;</ph>" 中的右角括弧。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>"xyz", assigns the substring between the <ph id="ph1">`Open`</ph> group and the right angle bracket to the <ph id="ph2">`Close`</ph> group, and deletes the current value of the <ph id="ph3">`Open`</ph> group.</source>
          <target state="translated">"xyz"，將 <ph id="ph1">`Open`</ph> 群組與右角括弧之間的子字串指派給 <ph id="ph2">`Close`</ph> 群組，並刪除 <ph id="ph3">`Open`</ph> 群組目前的值。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The value of the previous capture (the left angle bracket in "<ph id="ph1">&lt;mno&gt;</ph>") becomes the current value of the <ph id="ph2">`Open`</ph> group.</source>
          <target state="translated">先前擷取的值 ("<ph id="ph1">&lt;mno&gt;</ph>" 中的左角括弧) 變成 <ph id="ph2">`Open`</ph> 群組目前的值。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Captures`</ph> collection of the <ph id="ph2">`Open`</ph> group now includes a single capture, the left angle bracket from "<ph id="ph3">&lt;xyz&gt;</ph>".</source>
          <target state="translated">現在 <ph id="ph2">`Open`</ph> 群組的 <ph id="ph1">`Captures`</ph> 集合包含單一擷取："<ph id="ph3">&lt;xyz&gt;</ph>" 的左角括弧。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters; finds no matches.</source>
          <target state="translated">尋找非角括號字元；沒有找到配對。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">第三個擷取群組的值是 "&gt;"。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The next character in the input string is a right angle bracket, so the regular expression engine loops back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">輸入字串中的下一個字元是右角括號，所以規則運算式引擎會回送至 <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Matches the final right angle bracket in "xyz&gt;&gt;", assigns "mno<ph id="ph1">&lt;xyz&gt;</ph>" (the substring between the <ph id="ph2">`Open`</ph> group and the right angle bracket) to the <ph id="ph3">`Close`</ph> group, and deletes the current value of the <ph id="ph4">`Open`</ph> group.</source>
          <target state="translated">比對 "xyz&gt;&gt;" 中的最後一個右角括弧，將 "mno<ph id="ph1">&lt;xyz&gt;</ph>" (<ph id="ph2">`Open`</ph> 群組與右角括弧之間的子字串) 指派給 <ph id="ph3">`Close`</ph> 群組，並刪除 <ph id="ph4">`Open`</ph> 群組的目前值。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group is now empty.</source>
          <target state="translated"><ph id="ph1">`Open`</ph> 群組現在是空的。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>20</source>
          <target state="translated">20</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Looks for non-angle bracket characters; finds no matches.</source>
          <target state="translated">尋找非角括號字元；沒有找到配對。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>21</source>
          <target state="translated">21</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The value of the third captured group is "&gt;".</source>
          <target state="translated">第三個擷取群組的值是 "&gt;"。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> subpattern.</source>
          <target state="translated">輸入字串中的下一個字元不是右角括號，所以規則運算式引擎未回送至 <ph id="ph1">`((?'Close-Open'&gt;)[^&lt;&gt;]*)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>22</source>
          <target state="translated">22</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The value of the first captured group is "&lt;mno<ph id="ph1">&lt;xyz&gt;</ph>&gt;".</source>
          <target state="translated">第一個擷取群組的值是 "&lt;mno<ph id="ph1">&lt;xyz&gt;</ph>&gt;"。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the <ph id="ph1">`(((?'Open'&lt;)`</ph> subpattern.</source>
          <target state="translated">輸入字串中的下一個字元不是左角括號，所以規則運算式引擎未回送至 <ph id="ph1">`(((?'Open'&lt;)`</ph> 子模式。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>23</source>
          <target state="translated">23</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Open`</ph> group is not defined, so no match is attempted.</source>
          <target state="translated"><ph id="ph1">`Open`</ph> 群組未定義，所以未嘗試任何比對。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>24</source>
          <target state="translated">24</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Matches the end of the input string.</source>
          <target state="translated">比對輸入字串的結尾。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Noncapturing groups</source>
          <target state="translated">非擷取群組</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The following grouping construct does not capture the substring that is matched by a subexpression:</source>
          <target state="translated">下列群組建構不會擷取由下列子運算式比對的子字串：</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">其中 <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 是任何有效的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</source>
          <target state="translated">將數量詞套用至群組時，通常會使用非擷取群組建構，但是群組擷取的子字串沒有用。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
          <target state="translated">如果規則運算式包含巢狀群組建構，則外部非擷取群組建構不會套用至內部巢狀群組建構。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The following example illustrates a regular expression that includes noncapturing groups.</source>
          <target state="translated">下列範例說明包含非擷取群組的規則運算式。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Note that the output does not include any captured groups.</source>
          <target state="translated">請注意，輸出沒有包含任何擷取群組。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`(?:\b(?:\w+)\W*)+\.`</ph> matches a sentence that is terminated by a period.</source>
          <target state="translated">規則運算式 <ph id="ph1">`(?:\b(?:\w+)\W*)+\.`</ph> 符合以句點終止的句子。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</source>
          <target state="translated">因為規則運算式著重在句子，而不是個別文字，所以群組建構只會用做數量詞。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">規則運算式模式的解譯方式如下表所示。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Do not assign the matched text to a captured group.</source>
          <target state="translated">請勿將相符的文字指派給擷取群組。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Match zero or more non-word characters.</source>
          <target state="translated">比對零或多個非文字字元。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</source>
          <target state="translated">比對下列模式一次或多次：以字邊界開頭的一或多個文字字元，後面接零或多個非文字字元。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Do not assign the matched text to a captured group.</source>
          <target state="translated">請勿將相符的文字指派給擷取群組。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Match a period.</source>
          <target state="translated">比對句點。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Group options</source>
          <target state="translated">群組選項</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>The following grouping construct applies or disables the specified options within a subexpression:</source>
          <target state="translated">下列群組建構會在子運算式中套用或停用指定的選項：</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any valid regular expression pattern.</source>
          <target state="translated">其中 <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 是任何有效的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`(?i-s:)`</ph> turns on case insensitivity and disables single-line mode.</source>
          <target state="translated">例如，<ph id="ph1">`(?i-s:)`</ph> 會開啟不區分大小寫，並停用單行模式。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>For more information about the inline options you can specify, see <bpt id="p1">[</bpt>Regular expression options<ept id="p1">](options.md)</ept>.</source>
          <target state="translated">如需您能指定之內嵌選項的詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式選項<ept id="p1">](options.md)</ept>。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>You can specify options that apply to an entire regular expression rather than a subexpression by using a <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or a static method.</source>
          <target state="translated">若要將指定的選項套用至整個規則運算式，而不是單一子運算式，您可以使用 <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 類別建構函式或靜態方法。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>You can also specify inline options that apply after a specific point in a regular expression by using the <ph id="ph1">`(?imnsx-imnsx)`</ph> language construct.</source>
          <target state="translated">您也可以使用 <ph id="ph1">`(?imnsx-imnsx)`</ph> 語言建構，以指定在規則運算式的特定點之後，套用內嵌選項。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The group options construct is not a capturing group.</source>
          <target state="translated">群組選項建構不是擷取群組。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>That is, although any portion of a string that is captured by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is included in the match, it is not included in a captured group nor used to populate the <bpt id="p2">[</bpt>GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object.</source>
          <target state="translated">也就是說，雖然 <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 擷取之字串的任何部分都會包含在比對中，但不會包含在擷取群組中，也不會用來填入 <bpt id="p2">[</bpt>GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 物件。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\b(?ix: d \w+)\s `</ph>in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern whitespace in identifying all words that begin with the letter "d".</source>
          <target state="translated">例如，下列範例中的規則運算式 <ph id="ph1">`\b(?ix: d \w+)\s `</ph> 在群組建構中使用內嵌選項，以啟用不區分大小寫比對，並且在識別以字母 "d" 開頭的所有文字時，忽略模式空白字元。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>The regular expression is defined as shown in the following table.</source>
          <target state="translated">規則運算式的定義如下表所示。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</source>
          <target state="translated">使用不區分大小寫比對，並忽略此模式中的空格，比對後面接一或多個文字字元的 "d"。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">比對空白字元。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookahead assertions</source>
          <target state="translated">零寬度右合樣 (Positive Lookahead) 判斷提示</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width positive lookahead assertion:</source>
          <target state="translated">下列群組建構可定義零寬度右合樣 (Positive Lookahead) 判斷提示：</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><bpt id="p3">__</bpt>)<ept id="p3">__</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><bpt id="p3">__</bpt>)<ept id="p3">__</ept></target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">其中 <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 是任何規則運算式模式。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>For a match to be successful, the input string must match the regular expression pattern in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, although the matched substring is not included in the match result.</source>
          <target state="translated">若要讓比對成功，輸入字串必須符合 <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 中的規則運算式模式，但是相符的子字串不會包含在比對結果中。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookahead assertion does not backtrack.</source>
          <target state="translated">零寬度右合樣 (Positive Lookahead) 判斷提示不會回溯。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</source>
          <target state="translated">通常會在規則運算式模式結尾找到零寬度右合樣 (Positive Lookahead) 判斷提示。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</source>
          <target state="translated">它會定義必須在字串結尾找到，以讓相符項出現的子字串，但不應包含在比對中。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>It is also useful for preventing excessive backtracking.</source>
          <target state="translated">防止過度回溯也很有用。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</source>
          <target state="translated">您可以使用零寬度右合樣 (Positive Lookahead) 判斷提示，以確保特定擷取群組的開頭文字，符合針對該擷取群組所定義的模式子集。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</source>
          <target state="translated">例如，如果擷取群組符合連續的文字字元，您就可以使用零寬度右合樣 (Positive Lookahead) 判斷提示，要求第一個字元為英文字母大寫字元。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</source>
          <target state="translated">下列範例使用以零寬度右合樣判斷提示，比對輸入字串中在動詞 "is" 之前的字組。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>The regular expression \b\w+(?=\sis\b) is interpreted as shown in the following table.</source>
          <target state="translated">規則運算式 \b\w+(?=\sis\b) 的解譯方式如下表所示。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</source>
          <target state="translated">判定文字字元後面是否接著空格字元和字串 "is"，在字邊界結束。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>If so, the match is successful.</source>
          <target state="translated">若是如此，比對將會成功。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookahead assertions</source>
          <target state="translated">零寬度右不合樣 (Negative Lookahead) 判斷提示</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width negative lookahead assertion:</source>
          <target state="translated">下列群組建構可定義零寬度右不合樣 (Negative Lookahead) 判斷提示：</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">其中 <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 是任何規則運算式模式。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>For the match to be successful, the input string must not match the regular expression pattern in <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, although the matched string is not included in the match result.</source>
          <target state="translated">若要讓比對成功，輸入字串絕不能符合 <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 中的規則運算式模式，但是相符的字串不會包含在比對結果中。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</source>
          <target state="translated">零寬度右不合樣 (Negative Lookahead) 判斷提示通常會用在規則運算式開頭或結尾。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</source>
          <target state="translated">若是在規則運算式開頭，當規則運算式開頭定義類似但較為廣泛的模式以供比對時，此判斷提示可定義不應相符的模式。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>In this case, it is often used to limit backtracking.</source>
          <target state="translated">在此情況下，通常是用來限制回溯。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
          <target state="translated">若是在規則運算式結尾，則可定義不能出現在相符項結尾的子運算式。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</source>
          <target state="translated">下列範例定義的規則運算式在規則運算式開頭使用零寬度右合樣判斷提示，以比對不是以 "un" 開頭的文字。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The regular expression \b(?!un)\w+\b is interpreted as shown in the following table.</source>
          <target state="translated">規則運算式 \b(?!un)\w+\b 的解譯方式如下表所示。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Determine whether the next two characters are "un".</source>
          <target state="translated">判斷下兩個字元是否為 "un"。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>If they are not, a match is possible.</source>
          <target state="translated">如果不是，才可能比對。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">結束字緣比對。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</source>
          <target state="translated">下列範例定義的規則運算式在規則運算式結尾使用零寬度右合樣判斷提示，以比對不是以標點符號字元結尾的文字。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\b\w+\b(?!\p{P})`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">規則運算式 <ph id="ph1">`\b\w+\b(?!\p{P})`</ph> 的解譯方式如下表所示。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">結束字緣比對。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</source>
          <target state="translated">如果下一個字元不是標點符號 (例如句點或逗號)，則比對成功。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions</source>
          <target state="translated">零寬度左合樣 (Positive Lookbehind) 判斷提示</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width positive lookbehind assertion:</source>
          <target state="translated">下列群組建構可定義零寬度左合樣 (Positive Lookbehind) 判斷提示：</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;=<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;=<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">其中 <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 是任何規則運算式模式。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>For a match to be successful, <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> must occur at the input string to the left of the current position, although subexpression is not included in the match result.</source>
          <target state="translated">若要讓比對成功，<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 必須出現在目前位置左邊的輸入字串中，但是 subexpression 不會包含在比對結果中。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookbehind assertion does not backtrack.</source>
          <target state="translated">零寬度左合樣 (Positive Lookbehind) 判斷提示不會回溯。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</source>
          <target state="translated">零寬度左合樣 (Positive Lookbehind) 判斷提示通常會用在規則運算式開頭。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
          <target state="translated">其定義的模式是比對的前置條件，但不包含在比對結果中。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</source>
          <target state="translated">例如，下列範例會比對 21 世紀年份的後兩位數 (也就是說，比對的字串前面需要有數字 "20")。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(?&lt;=\b20)\d{2}\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`(?&lt;=\b20)\d{2}\b`</ph> 的解譯方式如下表所示。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>Match two decimal digits.</source>
          <target state="translated">比對兩個十進位數字。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</source>
          <target state="translated">如果字邊界上的兩個十進位數字前置十進位數字 "20"，則繼續比對。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
          <target state="translated">結束字緣比對。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</source>
          <target state="translated">當擷取群組中的最後一或多個字元，必須是符合該群組規則運算式模式的字元子集時，零寬度左合樣 (Positive Lookbehind) 判斷提示也可以用來限制回溯。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</source>
          <target state="translated">例如，如果群組擷取所有連續的文字字元，您就可以使用零寬度左合樣 (Positive Lookbehind) 判斷提示，要求最後一個字元為英文字母。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind assertions</source>
          <target state="translated">零寬度左不合樣 (Negative Lookbehind) 判斷提示</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The following grouping construct defines a zero-width negative lookbehind assertion:</source>
          <target state="translated">下列群組建構可定義零寬度左不合樣 (Negative Lookbehind) 判斷提示：</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&lt;!<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">其中 <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 是任何規則運算式模式。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>For a match to be successful, <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> must not occur at the input string to the left of the current position.</source>
          <target state="translated">若要讓比對成功，<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 絕不能出現在目前位置左邊的輸入字串中。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>However, any substring that does not match subexpression is not included in the match result.</source>
          <target state="translated">不過，不符合 subexpression 的任何子字串都不會包含在比對結果中。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</source>
          <target state="translated">零寬度左不合樣 (Negative Lookbehind) 判斷提示通常會用在規則運算式開頭。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>The pattern that they define precludes a match in the string that follows.</source>
          <target state="translated">其定義的模式排除了後面字串中的比對。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</source>
          <target state="translated">當擷取群組中的最後一或多個字元，絕不能是符合該群組規則運算式模式的一或多個字元時，此判斷提示也可以用來限制回溯。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (_).</source>
          <target state="translated">例如，如果群組擷取所有連續的文字字元，您就可以使用零寬度左合樣 (Positive Lookbehind) 判斷提示，要求最後一個字元不能是底線 (_)。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</source>
          <target state="translated">下列範例會比對週間非週末 (不是星期六也不是星期日) 任何一天的日期。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(?&lt;!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`(?&lt;!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b`</ph> 的解譯方式如下表所示。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a white-space character.</source>
          <target state="translated">比對後接空格字元的一或多個文字字元。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Match either one or two decimal digits followed by a white-space character and a comma.</source>
          <target state="translated">比對後接空格字元和逗號的一或兩個十進位數。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Match four decimal digits, and end the match at a word boundary.</source>
          <target state="translated">比對四個十進位數，並且在字邊界上結束比對。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>`(?&lt;!(Saturday</source>
          <target state="translated">`(?&lt;!(Saturday</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Sunday) )`</source>
          <target state="translated">Sunday) )`</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</source>
          <target state="translated">如果比對項目前置文字不是後接空格的字串 "Saturday" 或 "Sunday"，則比對成功。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Nonbacktracking subexpressions</source>
          <target state="translated">非回溯子運算式</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</source>
          <target state="translated">下列群組建構代表非回溯子運算式 (也稱為 Greedy (窮盡) 子運算式)：</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept></target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is any regular expression pattern.</source>
          <target state="translated">其中 <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> 是任何規則運算式模式。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</source>
          <target state="translated">一般而言，如果規則運算式包含選用性或替代性比對模式，而比對未成功，規則運算式引擎可以分支在多個方向，將輸入字串與模式比對。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</source>
          <target state="translated">如果採用第一個分支時，沒有找到比對項目，規則運算式引擎可以備份或回溯至採用第一個比對項目的點，並嘗試使用第二個分支來比對。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>This process can continue until all branches have been tried.</source>
          <target state="translated">此程序可以一直持續到所有分支都試過為止。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language construct disables backtracking.</source>
          <target state="translated"><bpt id="p1">**</bpt>(?&gt;<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> 語言建構會停用回溯。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>The regular expression engine will match as many characters in the input string as it can.</source>
          <target state="translated">規則運算式引擎會盡可能比對輸入字串中的所有字元。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>When no further match is possible, it will not backtrack to attempt alternate pattern matches.</source>
          <target state="translated">如果已無法進一步比對，將不會回溯嘗試替代模式比對。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</source>
          <target state="translated">(也就是說，子運算式只會比對該子運算式單獨比對的字串，而不會嘗試依據子運算式和其後的任何子運算式來比對字串。)</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>This option is recommended if you know that backtracking will not succeed.</source>
          <target state="translated">如果您知道回溯會成功，則建議使用此選項。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>Preventing the regular expression engine from performing unnecessary searching improves performance.</source>
          <target state="translated">防止規則運算式引擎執行不必要的搜尋，以提升效能。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</source>
          <target state="translated">下列範例說明非回溯子運算式如何修改模式比對的結果。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</source>
          <target state="translated">回溯規則運算式成功比對一連串重複的字元，其後面接著字邊界上出現一或多次的相同字元，而非回溯規則運算式則不成功。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>The nonbacktracking regular expression <ph id="ph1">`(?&gt;(\w)\1+).\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">非回溯規則運算式 <ph id="ph1">`(?&gt;(\w)\1+).\b`</ph> 的定義如下表所示。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Match a single word character and assign it to the first capturing group.</source>
          <target state="translated">比對單一文字字元，並將其指派給第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Match the value of the first captured substring one or more times.</source>
          <target state="translated">比對第一個擷取子字串的值一或數次。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>Match any character.</source>
          <target state="translated">比對任何字元。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>End the match on a word boundary.</source>
          <target state="translated">結束字邊界比對。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</source>
          <target state="translated">比對出現一或數次的重複文字字元，但不要回溯比對字邊界上的最後一個字元。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Grouping constructs and regular expression objects</source>
          <target state="translated">群組建構及和規則運算式物件</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Substrings that are matched by a regular expression capturing group are represented by <bpt id="p1">[</bpt>System.Text.RegularExpressions.Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects, which can be retrieved from the <bpt id="p2">[</bpt>System.Text.RegularExpressions.GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object that is returned by the <bpt id="p3">[</bpt>Match.Groups<ept id="p3">](xref:System.Text.RegularExpressions.Match.Groups)</ept> property.</source>
          <target state="translated">規則運算式擷取群組所比對的子字串會以 <bpt id="p1">[</bpt>System.Text.RegularExpressions.Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 物件來代表，此物件可從 <bpt id="p3">[</bpt>Match.Groups<ept id="p3">](xref:System.Text.RegularExpressions.Match.Groups)</ept> 屬性傳回的 <bpt id="p2">[</bpt>System.Text.RegularExpressions.GroupCollection<ept id="p2">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 物件來擷取。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object is populated as follows:</source>
          <target state="translated"><bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 物件的填入方式如下：</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>The first <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object in the collection (the object at index zero) represents the entire match.</source>
          <target state="translated">集合中的第一個 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 物件 (索引位置為零的物件) 代表整個比對。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>The next set of <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects represent unnamed (numbered) capturing groups.</source>
          <target state="translated">下一組 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 物件代表未具名 (編號的) 擷取群組。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>They appear in the order in which they are defined in the regular expression, from left to right.</source>
          <target state="translated">其出現順序會依照規則運算式中定義的順序，由左至右。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</source>
          <target state="translated">這些群組的索引值範圍是從 1 到集合中未具名擷取群組的編號。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>(The index of a particular group is equivalent to its numbered backreference.</source>
          <target state="translated">(特定群組的索引同等於其編號的反向參考。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>For more information about backreferences, see <bpt id="p1">[</bpt>Backreference constructs in regular expressions<ept id="p1">](backreference.md)</ept></source>
          <target state="translated">如需反向參考的詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式中的反向參考建構<ept id="p1">](backreference.md)</ept></target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>The final set of <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> objects represent named capturing groups.</source>
          <target state="translated">最後一組 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 物件代表具名擷取群組。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>They appear in the order in which they are defined in the regular expression, from left to right.</source>
          <target state="translated">其出現順序會依照規則運算式中定義的順序，由左至右。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</source>
          <target state="translated">第一個具名擷取群組的索引值比最後一個未具名擷取群組的索引值大一。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</source>
          <target state="translated">如果規則運算式中沒有未具名擷取群組，則第一個具名擷取群組的索引值為一。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>If you apply a quantifier to a capturing group, the corresponding <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object's <bpt id="p2">[</bpt>Capture.Value<ept id="p2">](xref:System.Text.RegularExpressions.Capture.Value)</ept>, <bpt id="p3">[</bpt>Capture.Index<ept id="p3">](xref:System.Text.RegularExpressions.Capture.Index)</ept>, and <bpt id="p4">[</bpt>Capture.Length<ept id="p4">](xref:System.Text.RegularExpressions.Capture.Length)</ept> properties reflect the last substring that is captured by a capturing group.</source>
          <target state="translated">如果您將數量詞套用至擷取群組，對應之 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 物件的 <bpt id="p2">[</bpt>Capture.Value<ept id="p2">](xref:System.Text.RegularExpressions.Capture.Value)</ept>、<bpt id="p3">[</bpt>Capture.Index<ept id="p3">](xref:System.Text.RegularExpressions.Capture.Index)</ept> 和 <bpt id="p4">[</bpt>Capture.Length<ept id="p4">](xref:System.Text.RegularExpressions.Capture.Length)</ept> 屬性會反映擷取群組所擷取的最後一個子字串。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object that is returned by the <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property.</source>
          <target state="translated">您可以擷取由群組所擷取的一組完整子字串，那些群組具有 <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> 屬性傳回之 <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> 物件中的數量詞。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>The following example clarifies the relationship between the <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> and <bpt id="p2">[</bpt>Capture<ept id="p2">](xref:System.Text.RegularExpressions.Capture)</ept> objects.</source>
          <target state="translated">下列範例說明 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 與 <bpt id="p2">[</bpt>Capture<ept id="p2">](xref:System.Text.RegularExpressions.Capture)</ept> 物件之間的關聯性。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b(\w+)\W+)+`</ph> extracts individual words from a string.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`\b(\w+)\W+)+`</ph> 會從字串擷取個別文字。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
          <target state="translated">其定義方式如下表所示。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Together, these characters form a word.</source>
          <target state="translated">這些字元共同構成一個單字。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">這是第二個擷取群組。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>Match one or more non-word characters.</source>
          <target state="translated">比對一或多個非文字字元。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</source>
          <target state="translated">一或多次比對一或多個文字字元後面接著一或多個非文字字元的模式。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">這是第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The first capturing group matches each word of the sentence.</source>
          <target state="translated">第一個擷取群組會比對句子中的每個字。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>The second capturing group matches each word along with the punctuation and white space that follow the word.</source>
          <target state="translated">第二個擷取群組會比對每個字以及接在該字後面的標點符號和空格。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> object whose index is 2 provides information about the text matched by the second capturing group.</source>
          <target state="translated">索引為 2 的 <bpt id="p1">[</bpt>Group<ept id="p1">](xref:System.Text.RegularExpressions.Group)</ept> 物件會提供第二個擷取群組所比對之文字的相關資訊。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The complete set of words captured by the capturing group are available from the <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> object returned by the <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> property.</source>
          <target state="translated">您可以從 <bpt id="p2">[</bpt>Group.Captures<ept id="p2">](xref:System.Text.RegularExpressions.Group.Captures)</ept> 屬性傳回的 <bpt id="p1">[</bpt>CaptureCollection<ept id="p1">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> 物件取得擷取群組所擷取的一整組文字。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">請參閱</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>規則運算式語言 - 快速參考<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking in regular expressions<ept id="p1">](backtracking.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>規則運算式中的回溯<ept id="p1">](backtracking.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>