<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-6a73dd2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a2a9fe356a0b2e9cf9415714bc01b77ea86229fc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\options.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ht-p2</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e7ed328ee4fc3ad1c060537e6e61b2ccbfdca11</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9843036ea6c346b0a75b08c6d3e1e5a955c63372</xliffext:olxliffhash>
      <xliffext:poisonError xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">file options.65329b23b2caac128f3130b9180bba5a93dcbed5.zh-tw.xlf is out of handoff scope</xliffext:poisonError>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">規則運算式選項</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">規則運算式選項</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core</source>
          <target state="translated">.NET、.NET Core</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Regular expression options</source>
          <target state="translated">規則運算式選項</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</source>
          <target state="translated">依預設，輸入字串與規則運算式模式中任何常值字元的比較會區分大小寫，規則運算式模式中的空白字元會解譯成常值空白字元，而規則運算式中的擷取群組會隱含也會明確命名。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</source>
          <target state="translated">您可以藉由指定規則運算式選項來修改這些預設規則運算式行為和幾個其他方面。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern matching method as a <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> enumeration value.</source>
          <target state="translated">這些選項 (列示於下表) 可以內嵌為規則運算式模式的部分，或是提供給 <bpt id="p1">[</bpt>System.Text.RegularExpressions.Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 類別建構函式或靜態模式比對方法，以作為 <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 列舉值。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>RegexOptions member</source>
          <target state="translated">RegexOptions 成員</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Inline character</source>
          <target state="translated">內嵌字元</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Effect</source>
          <target state="translated">作用</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>無<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">無法使用</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Use default behavior.</source>
          <target state="translated">使用預設行為。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Default options<ept id="p1">](#default-options)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>預設選項<ept id="p1">](#default-options)</ept>。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>i<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>i<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Use case-insensitive matching.</source>
          <target state="translated">使用不區分大小寫的比對方式。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Case-insensitive matching<ept id="p1">](#case-insensitive-matching)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>不區分大小寫的比對方式<ept id="p1">](#case-insensitive-matching)</ept>。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>多行<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>m<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Use multiline mode, where <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> match the beginning and end of each line (instead of the beginning and end of the input string).</source>
          <target state="translated">使用多行模式，其中 <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> 和 <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> 會比對每一行的開頭與結尾 (而不是輸入字串的開頭和結尾)。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Multiline mode<ept id="p1">](#multiline-mode)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>多行模式<ept id="p1">](#multiline-mode)</ept>。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>s<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>s<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Use single-line mode, where the period (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) matches every character (instead of every character except <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>).</source>
          <target state="translated">使用單行模式，其中句點 (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) 會比對每個字元 (而不是 <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> 以外的每個字元)。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Single-line mode<ept id="p1">](#single-line-mode)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>單行模式<ept id="p1">](#single-line-mode)</ept>。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>n<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>n<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Do not capture unnamed groups.</source>
          <target state="translated">不擷取未命名的群組。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The only valid captures are explicitly named or numbered groups of the form <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>.</source>
          <target state="translated">唯一有效的擷取是明確命名或編號的群組，格式如下：<bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept>。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Explicit captures only<ept id="p1">](#explicit-captures-only)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>僅明確擷取<ept id="p1">](#explicit-captures-only)</ept>。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>已編譯<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">無法使用</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Compile the regular expression to an assembly.</source>
          <target state="translated">將規則運算式編譯為組件。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Compiled regular expressions<ept id="p1">](#compiled-regular-expressions)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>編譯的規則運算式<ept id="p1">](#compiled-regular-expressions)</ept>。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>x<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>x<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Exclude unescaped white space from the pattern, and enable comments after a number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>).</source>
          <target state="translated">在模式中排除未逸出的空白字元，並且在數字符號 (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) 後面啟用註解。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Ignore white space<ept id="p1">](#ignore-white-space)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>忽略空白字元<ept id="p1">](#ignore-white-space)</ept>。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">無法使用</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Change the search direction.</source>
          <target state="translated">變更搜尋方向。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Search moves from right to left instead of from left to right.</source>
          <target state="translated">搜尋方向為由右至左，而不是由左至右。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Right-to-left mode<ept id="p1">](#right-to-left-mode)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>由右至左模式<ept id="p1">](#right-to-left-mode)</ept>。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">無法使用</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Enable ECMAScript-compliant behavior for the expression.</source>
          <target state="translated">為運算式啟用符合 ECMAScript 的行為。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>ECMAScript matching behavior<ept id="p1">](#ecmascript-matching-behavior)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱 <bpt id="p1">[</bpt>ECMAScript 比對行為<ept id="p1">](#ecmascript-matching-behavior)</ept>。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Not available</source>
          <target state="translated">無法使用</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Ignore cultural differences in language.</source>
          <target state="translated">忽略語言中的文化特性差異。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Comparison using the invariant culture<ept id="p1">](#comparison-using-the-invariant-culture)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>使用不因國別而異的文化特性比較<ept id="p1">](#comparison-using-the-invariant-culture)</ept>。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Specifying the options</source>
          <target state="translated">指定選項</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You can specify options for regular expressions in one of three ways:</source>
          <target state="translated">指定規則運算式選項的方式有三種：</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter of a <bpt id="p2">[</bpt>System.Text.RegularExpressions.Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor such as <bpt id="p3">[</bpt>Regex.Regex(String, RegexOptions)<ept id="p3">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions))</ept> or static (Shared in Visual Basic) pattern-matching method, such as  <bpt id="p4">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>.</source>
          <target state="translated">在如 <bpt id="p3">[</bpt>Regex.Regex(String, RegexOptions)<ept id="p3">](xref:System.Text.RegularExpressions.Regex.%23ctor(System.String,System.Text.RegularExpressions.RegexOptions))</ept> 等 <bpt id="p2">[</bpt>System.Text.RegularExpressions.Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 類別建構函式的 <bpt id="p1">*</bpt>options<ept id="p1">*</ept> 參數中，或靜態 (Visual Basic 中為 Shared) 模式比對方法中，例如 <bpt id="p4">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p4">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept>。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter is a bitwise OR combination of <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> enumerated values.</source>
          <target state="translated"><bpt id="p1">*</bpt>options<ept id="p1">*</ept> 參數是 <bpt id="p2">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 列舉值的位元 OR 組合。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>When options are supplied to a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> instance by using the <bpt id="p2">*</bpt>options<ept id="p2">*</ept> parameter of a class constructor, the options are are assigned to the <bpt id="p3">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property.</source>
          <target state="translated">當使用類別建構函式的 <bpt id="p2">*</bpt>options<ept id="p2">*</ept> 參數向給 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 執行個體提供選項時，選項會指派給 <bpt id="p3">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 屬性。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>However, the <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property does not reflect inline options in the regular expression pattern itself.</source>
          <target state="translated">不過，<bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 屬性不會在規則運算式模式中反映內嵌選項。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">下列範例提供一個實例。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter of the <bpt id="p2">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">其使用 <bpt id="p2">[</bpt>Regex.Match(String, String, RegexOptions)<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> 方法的 <bpt id="p1">*</bpt>options<ept id="p1">*</ept> 參數來啟用不區分大小寫比對，並且在識別以字母 "d" 開頭的文字時，忽略模式空白字元。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>By applying inline options in a regular expression pattern with the syntax <bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept>.</source>
          <target state="translated">使用語法 <bpt id="p1">**</bpt>(?imnsx-imnsx)<ept id="p1">**</ept>，在規則運算式模式中套用內嵌選項。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</source>
          <target state="translated">此選項會從定義選項的位置開始套用至模式，直到模式結尾，或是有其他內嵌選項取消定義選項為止。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Note that the <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> instance does not reflect these inline options.</source>
          <target state="translated">請注意，<bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 執行個體的 <bpt id="p1">[</bpt>System.Text.RegularExpressions.RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 屬性 不會反映這些內嵌選項。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Miscellaneous constructs in regular expressions<ept id="p1">](miscellaneous.md)</ept> topic.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式中的其他建構<ept id="p1">](miscellaneous.md)</ept>主題。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">下列範例提供一個實例。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">其使用內嵌選項來啟用不區分大小寫比對，並且在識別以字母 "d" 開頭的文字時，忽略模式空白字元。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>By applying inline options in a particular grouping construct in a regular expression pattern with the syntax <bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>.</source>
          <target state="translated">使用語法 <bpt id="p1">**</bpt>(?imnsx-imnsx:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept>，在規則運算式模式的特定群組建構中套用內嵌選項。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</source>
          <target state="translated">如果選項集前面沒有符號，會開啟選項集；如果選項集前面有減號，則會關閉選項集。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>(<bpt id="p1">**</bpt>?<ept id="p1">**</ept></source>
          <target state="translated">(<bpt id="p1">**</bpt>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</source>
          <target state="translated">是語言建構語法的固定部分，無論啟用或停用選項，都需要此部分。)此選項僅適用於該群組。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式中的群組建構<ept id="p1">](grouping.md)</ept>。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
          <target state="translated">下列範例提供一個實例。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</source>
          <target state="translated">其使用群組建構中的內嵌選項來啟用不區分大小寫比對，並且在識別以字母 "d" 開頭的文字時，忽略模式空白字元。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>If options are specified inline, a minus sign (-) before an option or set of options turns off those options.</source>
          <target state="translated">如果將選項指定為內嵌，選項或選項集前面的減號 (-) 會關閉那些選項。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For example, the inline construct <bpt id="p1">**</bpt>(?ix-ms)<ept id="p1">**</ept> turns on the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> and <bpt id="p3">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> options and turns off the <bpt id="p4">[</bpt>RegexOptions.Multiline<ept id="p4">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> and <bpt id="p5">[</bpt>RegexOptions.Singleline<ept id="p5">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> options.</source>
          <target state="translated">例如，內嵌建構 <bpt id="p1">**</bpt>(?ix-ms)<ept id="p1">**</ept> 會開啟 <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> 和 <bpt id="p3">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> 選項，並關閉 <bpt id="p4">[</bpt>RegexOptions.Multiline<ept id="p4">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 和 <bpt id="p5">[</bpt>RegexOptions.Singleline<ept id="p5">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> 選項。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>All regular expression options are turned off by default.</source>
          <target state="translated">依預設，會關閉所有規則運算式選項。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If the regular expression options specified in the options parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</source>
          <target state="translated">如果建構函式或方法呼叫的 options 參數指定的規則運算式選項，與規則運算式模式中指定內嵌的選項相衝突，則會使用內嵌選項。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The following five regular expression options can be set both with the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter and inline:</source>
          <target state="translated"><bpt id="p1">*</bpt>options<ept id="p1">*</ept> 參數和內嵌都可以用來設定下列五個規則運算式選項：</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept></target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept></target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The following five regular expression options can be set using the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter but cannot be set inline:</source>
          <target state="translated">下列五個規則運算式選項可以用 <bpt id="p1">*</bpt>options<ept id="p1">*</ept> 參數來設定，但不能設定內嵌：</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept></target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept></target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Determining the options</source>
          <target state="translated">決定選項</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can determine which options were provided to a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object when it was instantiated by retrieving the value of the read-only <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> property.</source>
          <target state="translated">您可以判定，在擷取唯讀 <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> 屬性的值來將物件具現化時，提供了哪些選項給 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 物件。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To test for the presence of any option except <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, perform an AND operation with the value of the <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> property and the <bpt id="p3">[</bpt>RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> value in which you are interested.</source>
          <target state="translated">若要測試任何選項 (<bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> 除外) 是否存在，請使用 <bpt id="p2">[</bpt>Regex.Options<ept id="p2">](xref:System.Text.RegularExpressions.Regex.Options)</ept> 屬性的值和您感興趣的 <bpt id="p3">[</bpt>RegexOptions<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 值來執行 AND 作業。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Then test whether the result equals that <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> value.</source>
          <target state="translated">然後測試結果是否等於 <bpt id="p1">[</bpt>RegexOptions<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 值。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The following example tests whether the <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option has been set.</source>
          <target state="translated">下列範例會測試是否已設定 <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> 選項。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>To test for <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, determine whether the value of the <bpt id="p2">[</bpt>RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> property is equal to <bpt id="p3">[</bpt>RegexOptions.None<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>, as the following example illustrates.</source>
          <target state="translated">請如下例所示，測試 <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>，判斷 <bpt id="p2">[</bpt>RegexOptions<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions)</ept> 屬性的值是否等於 <bpt id="p3">[</bpt>RegexOptions.None<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept>。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following sections list the options supported by regular expression in  .NET.</source>
          <target state="translated">以下各節會列出 .NET 中規則運算式所支援的選項。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Default options</source>
          <target state="translated">預設選項</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> 選項指出未指定任何選項，而規則運算式引擎使用其預設行為。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This includes the following:</source>
          <target state="translated">其中包括下列項目：</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</source>
          <target state="translated">模式被解譯為標準規則運算式，而不是 ECMAScript 規則運算式。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is matched in the input string from left to right.</source>
          <target state="translated">在輸入字串中，由左至右比對規則運算式模式。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Comparisons are case-sensitive.</source>
          <target state="translated">比較會區分大小寫。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> language elements match the beginning and end of the input string.</source>
          <target state="translated"><bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> 和 <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> 語言項目會比對輸入字串的開頭和結尾。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>language element matches every character except <bpt id="p1">**</bpt>\n<ept id="p1">**</ept>.</source>
          <target state="translated">語言項目會比對 <bpt id="p1">**</bpt>\n<ept id="p1">**</ept> 以外的每個字元。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Any white space in a regular expression pattern is interpreted as a literal space character.</source>
          <target state="translated">規則運算式模式中的任何空白字元會被解譯成常值空白字元。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The conventions of the current culture are used when comparing the pattern to the input string.</source>
          <target state="translated">將模式與輸入字串比較時，會使用目前文化特性的慣例。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Capturing groups in the regular expression pattern are implicit as well as explicit.</source>
          <target state="translated">規則運算式模式中的擷取群組是隱含的，也是明確的。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option has no inline equivalent.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> 選項沒有內嵌對等項目。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</source>
          <target state="translated">將規則運算式選項套用為內嵌時，會關閉特定選項，依據各選項逐一還原預設行為。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`(?i)`</ph> turns on case-insensitive comparison, and <ph id="ph2">`(?-i)`</ph> restores the default case-sensitive comparison.</source>
          <target state="translated">例如，<ph id="ph1">`(?i)`</ph> 會開啟不區分大小寫比較，而 <ph id="ph2">`(?-i)`</ph> 會還原預設區分大小寫比較。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</source>
          <target state="translated">因為 <bpt id="p1">[</bpt>RegexOptions.None<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.None)</ept> 選項代表規則運算式引擎的預設行為，所以很少明確地指定在方法呼叫中，</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>A constructor or static pattern-matching method without an options parameter is called instead.</source>
          <target state="translated">而是會呼叫不含 options 參數的建構函式或靜態模式比對方法。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Case-insensitive matching</source>
          <target state="translated">不區分大小寫的比對方式</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> option, or the <bpt id="p2">**</bpt>i<ept id="p2">**</ept> inline option, provides case-insensitive matching.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnoreCase<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> 選項 (或 <bpt id="p2">**</bpt>i<ept id="p2">**</ept> 內嵌選項) 提供不區分大小寫比對。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>By default, the casing conventions of the current culture are used.</source>
          <target state="translated">依預設，會使用目前文化特性的大小寫慣例。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The following example defines a regular expression pattern, <ph id="ph1">`\bthe\w*\b`</ph>, that matches all words starting with "the".</source>
          <target state="translated">下列範例定義規則運算式模式 <ph id="ph1">`\bthe\w*\b`</ph>，它會比對以 "the" 開頭的所有文字。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Because the first call to the Match method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</source>
          <target state="translated">因為第一次呼叫 Match 方法是使用預設的區分大小寫比較，所以輸出指出未比對句子開頭的 "The" 字串。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It is matched when the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with options set to <bpt id="p2">[</bpt>IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept>.</source>
          <target state="translated">選項設為 <bpt id="p2">[</bpt>IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> 來呼叫 <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> 方法時，才會加以比對。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The following example modifies the regular expression pattern from the previous example to use inline options instead of the <bpt id="p1">*</bpt>options<ept id="p1">*</ept> parameter to provide case-insensitive comparison.</source>
          <target state="translated">下列範例會修改上一個範例中的規則運算式模式，改為使用內嵌選項，而不是使用 <bpt id="p1">*</bpt>options<ept id="p1">*</ept> 參數，以提供不區分大小寫比較。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</source>
          <target state="translated">第一個模式在群組建構中定義不區分大小寫選項，只套用於字串 "the" 中的字母 "t"。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</source>
          <target state="translated">因為選項建構出現在模式開頭，所以第二個模式會將不區分大小寫選項套用於整個規則運算式。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Multiline mode</source>
          <target state="translated">多行模式</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, or the <bpt id="p2">**</bpt>m<ept id="p2">**</ept> inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 選項 (或 <bpt id="p2">**</bpt>m<ept id="p2">**</ept> 內嵌選項) 可讓規則運算式引擎處理構成多行的輸入字串。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It changes the interpretation of the <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</source>
          <target state="translated">它會變更 <bpt id="p1">**</bpt><ph id="ph1">^</ph><ept id="p1">**</ept> 和 <bpt id="p2">**</bpt><ph id="ph2">$</ph><ept id="p2">**</ept> 語言項目的解譯，以便比對字行的開頭和結尾，而不是輸入字串的開頭和結尾。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>By default, <bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> matches only the end of the input string.</source>
          <target state="translated">依預設，<bpt id="p1">**</bpt><ph id="ph1">$</ph><ept id="p1">**</ept> 只會比對輸入字串的結尾。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>If you specify the <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> option, it matches either the newline character <bpt id="p2">**</bpt>(\n)<ept id="p2">**</ept> or the end of the input string.</source>
          <target state="translated">如果您指定 <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 選項，則會比對新行字元 (<bpt id="p2">**</bpt>(\n)<ept id="p2">**</ept>) 或輸入字串的結尾。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>It does not, however, match the carriage return/line feed character combination.</source>
          <target state="translated">不過，並不會比對歸位字元/換行字元組合。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>To successfully match them, use the subexpression <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept> instead of just <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>.</source>
          <target state="translated">若要順利比對，請使用子運算式 <bpt id="p1">**</bpt>\r?$<ept id="p1">**</ept>，而不只是使用 <bpt id="p2">**</bpt><ph id="ph1">$</ph><ept id="p2">**</ept>。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The following example extracts bowlers names and scores and adds them to a <bpt id="p1">[</bpt>SortedList<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.SortedList%602)</ept> collection that sorts them in descending order.</source>
          <target state="translated">下列範例會擷取保齡球員的名字和分數，並將其加入 <bpt id="p1">[</bpt>SortedList<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph><ept id="p1">](xref:System.Collections.Generic.SortedList%602)</ept> 集合，以遞減順序排序。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> method is called twice.</source>
          <target state="translated">呼叫 <bpt id="p1">[</bpt>Matches<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Matches(System.String))</ept> 方法兩次。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>In the first method call, the regular expression is <ph id="ph1">`^(\w+)\s(\d+)$`</ph> and no options are set.</source>
          <target state="translated">在第一次呼叫方法時，規則運算式為 <ph id="ph1">`^(\w+)\s(\d+)$`</ph>，且沒有設定選項。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</source>
          <target state="translated">如輸出所示，因為規則運算式引擎無法隨著輸入字串的開頭和結尾來比對輸入模式，所以沒有找到相符項目。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>In the second method call, the regular expression is changed to <ph id="ph1">`^(\w+)\s(\d+)\r?$`</ph> and the options are set to <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>.</source>
          <target state="translated">在第二次呼叫方法時，規則運算式變更為 <ph id="ph1">`^(\w+)\s(\d+)\r?$`</ph>，且選項設為 <bpt id="p1">[</bpt>RegexOptions.Multiline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept>。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</source>
          <target state="translated">如輸出所示，已成功比對名字和分數，且分數以遞減順序顯示。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^(\w+)\s(\d+)\r*$`</ph> is defined as shown in the following table.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`^(\w+)\s(\d+)\r*$`</ph> 的定義如下表所示。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Begin at the start of the line.</source>
          <target state="translated">從字行開頭開始。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
          <target state="translated">這是第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">比對空白字元。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Match one or more decimal digits.</source>
          <target state="translated">比對一個或多個十進位數字。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>This is the second capturing group.</source>
          <target state="translated">這是第二個擷取群組。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Match zero or one carriage return character.</source>
          <target state="translated">比對零或一個歸位字元。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>End at the end of the line.</source>
          <target state="translated">在字行結尾結束。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous one, except that it uses the inline option <bpt id="p1">**</bpt>(?m)<ept id="p1">**</ept> to set the multiline option.</source>
          <target state="translated">下列範例與上一個範例相同，只是下列範例是使用內嵌選項 <bpt id="p1">**</bpt>(?m)<ept id="p1">**</ept> 來設定多行選項。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Single-line mode</source>
          <target state="translated">單行模式</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option, or the s inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> 選項 (或 s 內嵌選項) 會使規則運算式引擎將輸入字串當作其包含單行。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>It does this by changing the behavior of the period (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) language element so that it matches every character, instead of matching every character except for the newline character <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> or \u000A.</source>
          <target state="translated">其作法是變更句點 (<bpt id="p1">**</bpt>.<ept id="p1">**</ept>) 語言項目的行為，使其比對每個字元，而不是比對新行字元 <bpt id="p2">**</bpt>\n<ept id="p2">**</ept> 或 \u000A 以外的每個字元。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The following example illustrates how the behavior of the .</source>
          <target state="translated">下例說明 . 的</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>language element changes when you use the <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option.</source>
          <target state="translated">語言項目行為，在您使用 <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> 選項時如何變更。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`^.+`</ph> starts at the beginning of the string and matches every character.</source>
          <target state="translated">規則運算式 <ph id="ph1">`^.+`</ph> 會從字串開頭開始，比對每一個字元。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, <bpt id="p1">**</bpt>\r<ept id="p1">**</ept> or \u000D, but it does not match <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</source>
          <target state="translated">根據預設，比對會在第一行結尾結束。規則運算式模式會比對歸位字元 <bpt id="p1">**</bpt>\r<ept id="p1">**</ept> 或 \u000D，但不會比對 <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Because the <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> option interprets the entire input string as a single line, it matches every character in the input string, including <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>.</source>
          <target state="translated">由於 <bpt id="p1">[</bpt>RegexOptions.Singleline<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Singleline)</ept> 選項會將整個輸入字串解譯為單行，因此它會比對輸入字串中的每個字元，包括 <bpt id="p2">**</bpt>\n<ept id="p2">**</ept>。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The following example is equivalent to the previous one, except that it uses the inline option <bpt id="p1">**</bpt>(?s)<ept id="p1">**</ept> to enable single-line mode.</source>
          <target state="translated">下列範例與上一個範例相同，只是下列範例是使用內嵌選項 <bpt id="p1">**</bpt>(?s)<ept id="p1">**</ept> 來啟用單行模式。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Explicit captures only</source>
          <target state="translated">僅明確擷取</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</source>
          <target state="translated">依預設，擷取群組的定義方式是在規則運算式模式中使用括號。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Named groups are assigned a name or number by the <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> language option, whereas unnamed groups are accessible by index.</source>
          <target state="translated">具名群組是以 <bpt id="p1">**</bpt>(?&lt;<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt><ph id="ph1">&gt;</ph><ept id="p3">**</ept> <bpt id="p4">_</bpt>subexpression<ept id="p4">_</ept><bpt id="p5">**</bpt>)<ept id="p5">**</ept> 語言選項來指派名稱或號碼，而未具名群組可透過索引來存取。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> object, unnamed groups precede named groups.</source>
          <target state="translated">在 <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 物件中，未具名群組的前面是具名群組。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</source>
          <target state="translated">群組建構通常只用來將數量詞套用至多個語言項目，我們對所擷取的子字串並不感興趣。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>For example, if the following regular expression:</source>
          <target state="translated">例如，如果下列運算式：</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> object) is of interest.</source>
          <target state="translated">目的只是要從文件中擷取以句點、驚嘆號或問號結尾的句子，則我們只對所產生的句子 (由 <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Match)</ept> 物件代表) 感興趣。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The individual words in the collection are not.</source>
          <target state="translated">我們對集合中的個別文字並不感興趣。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collection objects.</source>
          <target state="translated">非後續使用的擷取群組可能會耗用很多資源，因為規則運算式引擎必須同時填入 <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 和 <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> 集合物件。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>As an alternative, you can use either the <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option or the <bpt id="p2">**</bpt>n<ept id="p2">**</ept> inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the <bpt id="p3">**</bpt>(?&lt;<ept id="p3">**</ept><bpt id="p4">_</bpt>name<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">&gt;</ph><ept id="p5">**</ept> <bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept> construct.</source>
          <target state="translated">或者，您也可以使用 <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> 選項或 <bpt id="p2">**</bpt>n<ept id="p2">**</ept> 內嵌選項，指定唯一有效的擷取是 <bpt id="p3">**</bpt>(?&lt;<ept id="p3">**</ept><bpt id="p4">_</bpt>name<ept id="p4">_</ept><bpt id="p5">**</bpt><ph id="ph1">&gt;</ph><ept id="p5">**</ept> <bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept> 建構所指定的明確命名或編號群組。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The following example displays information about the matches returned by the <ph id="ph1">`\b\(?((\w+),?\s?)+[\.!?]\)?`</ph> regular expression pattern when the <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept> method is called with and without the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">下列範例顯示，當呼叫 <bpt id="p1">[</bpt>Match<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept> 方法時，如果沒有使用 <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> 選項，<ph id="ph1">`\b\(?((\w+),?\s?)+[\.!?]\)?`</ph> 規則運算式模式所傳回的比對相關資訊。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>As the output from the first method call shows, the regular expression engine fully populates the <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> and <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> collection objects with information about captured substrings.</source>
          <target state="translated">當第一個方法呼叫的輸出顯示時，規則運算式引擎會以擷取子字串的相關資訊完整填入 <bpt id="p1">[</bpt>GroupCollection<ept id="p1">](xref:System.Text.RegularExpressions.GroupCollection)</ept> 和 <bpt id="p2">[</bpt>CaptureCollection<ept id="p2">](xref:System.Text.RegularExpressions.CaptureCollection)</ept> 集合物件。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Because the second method is called with options set to <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>, it does not capture information on groups.</source>
          <target state="translated">因為呼叫第二個方法時，選項設為 <bpt id="p1">[</bpt>RegexOptions.ExplicitCapture<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept>，所以沒有擷取群組的資訊。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\b\(?((?&gt;\w+),?\s?)+[\.!?]\)?`</ph> is defined as shown in the following table.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`\b\(?((?&gt;\w+),?\s?)+[\.!?]\)?`</ph> 的定義如下表所示。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Begin at a word boundary.</source>
          <target state="translated">從字邊界開始。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrences of the opening parenthesis ("(").</source>
          <target state="translated">比對出現零或一次的左括號 ("(")。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Match one or more word characters, followed by zero or one commas.</source>
          <target state="translated">比對後面接著零或一個逗號的一或多個文字字元。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Do not backtrack when matching word characters.</source>
          <target state="translated">比對文字字元時，請勿回溯。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Match zero or one white-space characters.</source>
          <target state="translated">比對零個或一個空白字元。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</source>
          <target state="translated">一或多次比對一或多個文字字元、零或一個逗號及零或一個空白字元的組合。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</source>
          <target state="translated">比對這三種標點符號中的任一種，後面接零或一個右括號 (")")。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>You can also use the <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> inline element to suppress automatic captures.</source>
          <target state="translated">您也可以使用 <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> 內嵌元素來隱藏自動擷取。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous regular expression pattern to use the <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> inline element instead of the <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> option.</source>
          <target state="translated">下列範例會修改上一個規則運算式模式，以使用 <bpt id="p1">**</bpt>(?n)<ept id="p1">**</ept> 內嵌項目，而不是使用 <bpt id="p2">[</bpt>RegexOptions.ExplicitCapture<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture)</ept> 選項。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Finally, you can use the inline group element <bpt id="p1">**</bpt>(?n:)<ept id="p1">**</ept> to suppress automatic captures on a group-by-group basis.</source>
          <target state="translated">最後，您可以使用內嵌群組項目 <bpt id="p1">**</bpt>(?n:)<ept id="p1">**</ept>，針對每個群組逐一隱藏自動擷取。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous pattern to suppress unnamed captures in the outer group, <ph id="ph1">`((?&gt;\w+),?\s?)`</ph>.</source>
          <target state="translated">下列範例會修改上一個模式，以隱藏外部群組 <ph id="ph1">`((?&gt;\w+),?\s?)`</ph> 中的未具名擷取。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Note that this suppresses unnamed captures in the inner group as well.</source>
          <target state="translated">請注意，這也會隱藏內部群組中的未具名擷取。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Compiled regular expressions</source>
          <target state="translated">編譯的規則運算式</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>By default, regular expressions in .NET are interpreted.</source>
          <target state="translated">預設會解譯 .NET 中的規則運算式。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>When a <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is instantiated or a static <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</source>
          <target state="translated">將 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 物件具現化，或是呼叫靜態 <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 方法時，會將規則運算式模式剖析成一組自訂作業碼，而解譯器會使用這些作業碼來執行規則運算式。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</source>
          <target state="translated">這需要有所取捨：要將初始化規則運算式引擎的成本降到最低，就會犧牲執行時期效能。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You can use compiled instead of interpreted regular expressions by using the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option.</source>
          <target state="translated">您可以使用 <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> 選項，以編譯的規則運算式來取代解譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</source>
          <target state="translated">在這個情況下，將模式傳遞至規則運算式時，會將該模式剖析成一組自訂作業碼，然後再轉換成 Microsoft 中繼語言 (MSIL)，可直接傳遞至通用語言執行平台。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Compiled regular expressions maximize run-time performance at the expense of initialization time.</source>
          <target state="translated">編譯的規則運算式可充分提升執行時期效能，但會犧牲初始化時間。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>A regular expression can be compiled only by supplying the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or a static pattern-matching method.</source>
          <target state="translated">若要編譯規則運算式，唯一的方法就是提供 <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> 值給 <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 類別建構函式或靜態模式比對方法的 options 參數。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">無法以內嵌選項來提供此值。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>You can use compiled regular expressions in calls to both static and instance regular expressions.</source>
          <target state="translated">在呼叫靜態和執行個體規則運算式時，都可以使用編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>In static regular expressions, the <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> option is passed to the options parameter of the regular expression pattern-matching method.</source>
          <target state="translated">在靜態規則運算式中，會將 <bpt id="p1">[</bpt>RegexOptions.Compiled<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.Compiled)</ept> 選項傳遞至規則運算式模式比對方法的 options 參數。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>In instance regular expressions, it is passed to the options parameter of the <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor.</source>
          <target state="translated">在執行個體規則運算式中，則會傳遞至 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 類別建構函式的 options 參數。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>In both cases, it results in enhanced performance.</source>
          <target state="translated">在這兩個情況中，都會增強效能。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>However, this improvement in performance occurs only under the following conditions:</source>
          <target state="translated">不過，只有在下列條件下，效能才會提升：</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</source>
          <target state="translated">在對規則運算式模式比對方法的多個呼叫中，都會使用代表特定規則運算式的 <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 物件。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> object is not allowed to go out of scope, so it can be reused.</source>
          <target state="translated"><bpt id="p1">[</bpt>Regex<ept id="p1">](xref:System.Text.RegularExpressions.Regex)</ept> 物件不能超出範圍，因此可以重複使用。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>A static regular expression is used in multiple calls to regular expression pattern-matching methods.</source>
          <target state="translated">在對規則運算式模式比對方法的多個呼叫中，會使用靜態規則運算式。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</source>
          <target state="translated">(效能提升是有可能的，因為規則運算式引擎會快取靜態方法呼叫中所使用的規則運算式。)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Ignore white space</source>
          <target state="translated">忽略空白字元</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</source>
          <target state="translated">依預設，規則運算式模式中的空白字元很重要；它會強制規則運算式引擎比對輸入字串中的空白字元。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Because of this, the regular expression <ph id="ph1">`"\b\w+\s"`</ph> and <ph id="ph2">`"\b\w+ "`</ph> are roughly equivalent regular expressions.</source>
          <target state="translated">因此，規則運算式 <ph id="ph1">`"\b\w+\s"`</ph> 和 <ph id="ph2">`"\b\w+ "`</ph> 是大致相等的規則運算式。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>In addition, when the number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</source>
          <target state="translated">此外，在規則運算式模式中遇到數字符號 (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) 時，會將其解譯成常值字元，以供比對。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option, or the <bpt id="p2">**</bpt>x<ept id="p2">**</ept> inline option, changes this default behavior as follows:</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> 選項 (或 <bpt id="p2">**</bpt>x<ept id="p2">**</ept> 內嵌選項) 會變更此預設行為，如下所示︰</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Unescaped white space in the regular expression pattern is ignored.</source>
          <target state="translated">規則運算式模式中未逸出的空白字元會被忽略。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>To be part of a regular expression pattern, white-space characters must be escaped (for example, as <bpt id="p1">**</bpt>\s<ept id="p1">**</ept> or "*<bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept> ").</source>
          <target state="translated">若要在規則運算式模式中使用空白字元，就必須將它逸出 (例如，<bpt id="p1">**</bpt>\s<ept id="p1">**</ept> 或 "*<bpt id="p2">*</bpt><ph id="ph1">\*</ph><ept id="p2">*</ept> ")。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The number sign (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) is interpreted as the beginning of a comment, rather than as a literal character.</source>
          <target state="translated">數字符號 (<bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept>) 會解譯成註解的開頭，而不是常值字元。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>All text in the regular expression pattern from the <bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept> character to the end of the string is interpreted as a comment.</source>
          <target state="translated">規則運算式模式中，從 <bpt id="p1">**</bpt><ph id="ph1">#</ph><ept id="p1">**</ept> 字元到字串結尾的所有文字會被解譯成註解。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>However, in the following cases, white space characters in a regular expression aren't ignored, even if you use the <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option:</source>
          <target state="translated">不過，在下列案例中，即使您使用 <bpt id="p1">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> 選項，也不會忽略規則運算式中的空白字元：</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>White space within a character class is always interpreted literally.</source>
          <target state="translated">字元類別中的空白字元一律解譯為常值。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`[ .,;:]`</ph> matches any single white-space character, period, comma, semicolon, or colon.</source>
          <target state="translated">例如，規則運算式模式 <ph id="ph1">`[ .,;:]`</ph> 會比對任何單一空白字元、句點、逗號、分號或冒號。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>White space isn't allowed within a bracketed quantifier, such as <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, <bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,}<ept id="p6">**</ept>, and <bpt id="p7">**</bpt>{<ept id="p7">**</ept><bpt id="p8">_</bpt>n<ept id="p8">_</ept><bpt id="p9">**</bpt>,<ept id="p9">**</ept><bpt id="p10">_</bpt>m<ept id="p10">_</ept><bpt id="p11">**</bpt>}<ept id="p11">**</ept>.</source>
          <target state="translated">方括號數量詞中不允許空白字元，例如 <bpt id="p1">**</bpt>{<ept id="p1">**</ept><bpt id="p2">_</bpt>n<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>、<bpt id="p4">**</bpt>{<ept id="p4">**</ept><bpt id="p5">_</bpt>n<ept id="p5">_</ept><bpt id="p6">**</bpt>,}<ept id="p6">**</ept> 和 <bpt id="p7">**</bpt>{<ept id="p7">**</ept><bpt id="p8">_</bpt>n<ept id="p8">_</ept><bpt id="p9">**</bpt>,<ept id="p9">**</ept><bpt id="p10">_</bpt>m<ept id="p10">_</ept><bpt id="p11">**</bpt>}<ept id="p11">**</ept>。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <bpt id="p1">**</bpt>\d{1. 3}<ept id="p1">**</ept> fails to match any sequences of digits from one to three digits because it contains a white-space character.</source>
          <target state="translated">例如，規則運算式模式 <bpt id="p1">**</bpt>\d{1. 3}<ept id="p1">**</ept> 無法比對從一到三位數的任何數字序列，因為其中包含空白字元。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>White space isn't allowed within a character sequence that introduces a language element.</source>
          <target state="translated">引進語言項目的字元序列中，不允許空白字元。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如: </target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The language element <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> represents a noncapturing group, and the <bpt id="p4">**</bpt>(?:<ept id="p4">**</ept> portion of the element can't have embedded spaces.</source>
          <target state="translated">語言項目 <bpt id="p1">**</bpt>(?:<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> 代表非擷取群組，而該項目的 <bpt id="p4">**</bpt>(?:<ept id="p4">**</ept> 部分不能有內嵌空格。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The pattern <bpt id="p1">**</bpt>(? :<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> throws an <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept> at run time because the regular expression engine can't parse the pattern, and the pattern <bpt id="p5">**</bpt>(? :<ept id="p5">**</ept><bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept>  fails to match <bpt id="p8">*</bpt>subexpression<ept id="p8">*</ept>.</source>
          <target state="translated">模式 <bpt id="p1">**</bpt>(? :<ept id="p1">**</ept><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> 會在執行時期擲回 <bpt id="p4">[</bpt>ArgumentException<ept id="p4">](xref:System.ArgumentException)</ept>，因為規則運算式引擎無法剖析該模式，而模式 <bpt id="p5">**</bpt>(? :<ept id="p5">**</ept><bpt id="p6">_</bpt>subexpression<ept id="p6">_</ept><bpt id="p7">**</bpt>)<ept id="p7">**</ept> 無法比對 <bpt id="p8">*</bpt>subexpression<ept id="p8">*</ept>。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The language element <bpt id="p1">**</bpt>\p{<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept>, which represents a Unicode category or named block, can't include embedded spaces in the <bpt id="p4">**</bpt>\p{<ept id="p4">**</ept> portion of the element.</source>
          <target state="translated">語言項目 <bpt id="p1">**</bpt>\p{<ept id="p1">**</ept><bpt id="p2">_</bpt>name<ept id="p2">_</ept><bpt id="p3">**</bpt>}<ept id="p3">**</ept> 代表 Unicode 類別或具名資料區塊，不能在此項目的 <bpt id="p4">**</bpt>\p{<ept id="p4">**</ept> 部分中包含內嵌空格。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>If you do include a white space, the element throws an <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept> at run time.</source>
          <target state="translated">如果包含空白字元，則此項目會在執行時期擲回 <bpt id="p1">[</bpt>ArgumentException<ept id="p1">](xref:System.ArgumentException)</ept>。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</source>
          <target state="translated">啟用此選項有助於簡化通常很難剖析及了解的規則運算式。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>It improves readability, and makes it possible to document a regular expression.</source>
          <target state="translated">其增進了可讀性，並且讓規則運算式可以被記載下來。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The following example defines the following regular expression pattern:</source>
          <target state="translated">下列範例定義下列規則運算式模式：</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`\b \(? ( (?&gt;\w+) ,?\s? )+ [\.!?] \)? # Matches an entire sentence`</ph>.</source>
          <target state="translated"><ph id="ph1">`\b \(? ( (?&gt;\w+) ,?\s? )+ [\.!?] \)? # Matches an entire sentence`</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>This pattern is similar to the pattern defined in the <bpt id="p1">[</bpt>Explicit captures only<ept id="p1">](#explicit-captures-only)</ept> section, except that it uses the <bpt id="p2">[</bpt>RegexOptions.IgnorePatternWhitespace<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> option to ignore pattern white space.</source>
          <target state="translated">此模式類似<bpt id="p1">[</bpt>僅明確擷取<ept id="p1">](#explicit-captures-only)</ept>一節中定義的模式，但會使用 <bpt id="p2">[</bpt>RegexOptions.IgnorePatternWhitespace <ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace)</ept> 選項忽略模式的空白字元。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following example uses the inline option <bpt id="p1">**</bpt>(?x)<ept id="p1">**</ept> to ignore pattern white space.</source>
          <target state="translated">下列範例使用內嵌選項 <bpt id="p1">**</bpt>(?x)<ept id="p1">**</ept> 來忽略模式空白字元。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Right-to-left mode</source>
          <target state="translated">由右至左模式</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine searches from left to right.</source>
          <target state="translated">依預設，規則運算式引擎會由左至右搜尋。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>You can reverse the search direction by using the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option.</source>
          <target state="translated">您可以使用 <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> 選項來反轉搜尋方向。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The search automatically begins at the last character position of the string.</source>
          <target state="translated">此搜尋會自動從字串最後一個字元的位置開始。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>For pattern-matching methods that include a starting position parameter, such as <bpt id="p1">[</bpt>Regex.Match(String, Int32)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept>, the starting position is the index of the rightmost character position at which the search is to begin.</source>
          <target state="translated">針對包含開始位置參數的模式比對方法，例如 <bpt id="p1">[</bpt>Regex.Match(String, Int32)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32))</ept>，開始位置是要開始搜尋之最右邊字元位置的索引。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Right-to-left pattern mode is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">若要使用由右至左模式，唯一的方法就是提供 <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> 值給 <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 類別建構函式或靜態模式比對方法的 options 參數。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">無法以內嵌選項來提供此值。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.RightToLeft<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.RightToLeft)</ept> 選項只會變更搜尋方向，並不會由右至左解譯規則運算式模式。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`\bb\w+\s`</ph> matches words that begin with the letter "b" and are followed by a white-space character.</source>
          <target state="translated">例如，規則運算式 <ph id="ph1">`\bb\w+\s`</ph> 會比對字母 "b" 開頭、後接空白字元的文字。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>In the following example, the input string consists of three words that include one or more "b" characters.</source>
          <target state="translated">在下列範例中，輸入字串是由包含一或數個 "b" 字元的三個單字所組成。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</source>
          <target state="translated">第一個單字以 "b" 開頭，第二個單字以 "b" 結尾，而第三個單字中間包含兩個 "b" 字元。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, only the first word matches the regular expression pattern.</source>
          <target state="translated">如範例輸出所示，只有第一個單字符合規則運算式模式。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Also note that the lookahead assertion (the <bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> language element) and the lookbehind assertion (the <bpt id="p4">**</bpt>(?&lt;<ept id="p4">**</ept><ph id="ph2">=</ph><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> language element) do not change direction.</source>
          <target state="translated">另請注意，右合樣判斷提示 (<bpt id="p1">**</bpt>(?<ept id="p1">**</ept><ph id="ph1">=</ph><bpt id="p2">_</bpt>subexpression<ept id="p2">_</ept><bpt id="p3">**</bpt>)<ept id="p3">**</ept> 語言項目) 和左合樣判斷提示 (<bpt id="p4">**</bpt>(?&lt;<ept id="p4">**</ept><ph id="ph2">=</ph><bpt id="p5">_</bpt>subexpression<ept id="p5">_</ept><bpt id="p6">**</bpt>)<ept id="p6">**</ept> 語言項目) 沒有變更方向。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The lookahead assertions look to the right; the lookbehind assertions look to the left.</source>
          <target state="translated">右合樣判斷提示朝右看，而左合樣判斷提示朝左看。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>For example, the regular expression <ph id="ph1">`(?&lt;=\d{1,2}\s)\w+,?\s\d{4}`</ph> uses the lookbehind assertion to test for a date that precedes a month name.</source>
          <target state="translated">例如，規則運算式 <ph id="ph1">`(?&lt;=\d{1,2}\s)\w+,?\s\d{4}`</ph> 使用左合樣判斷提示來測試月份名稱前面的日期。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The regular expression then matches the month and the year.</source>
          <target state="translated">然後規則運算式會比對月和年。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>For information on lookahead and lookbehind assertsions, see <bpt id="p1">[</bpt>Grouping constructs in regular expressions<ept id="p1">](grouping.md)</ept>.</source>
          <target state="translated">如需右合樣判斷提示和左合樣判斷提示的詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式中的群組建構<ept id="p1">](grouping.md)</ept>。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is defined as shown in the following table.</source>
          <target state="translated">規則運算式模式的定義如下表所示。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The beginning of the match must be preceded by one or two decimal digits followed by a space.</source>
          <target state="translated">相符項目的開頭前面必須要有一個或兩個十進位數字後接空格。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Match zero or one comma characters.</source>
          <target state="translated">比對零或一個逗號字元。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Match a white-space character.</source>
          <target state="translated">比對空白字元。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Match four decimal digits.</source>
          <target state="translated">比對四個十進位數字。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>ECMAScript matching behavior</source>
          <target state="translated">ECMAScript 比對行為</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</source>
          <target state="translated">依預設，在比對規則運算式模式與輸入文字時，規則運算式引擎會使用標準行為。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> option.</source>
          <target state="translated">不過，您可以指定 <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> 選項，以指示規則運算式引擎使用 ECMAScript 相符行為。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>ECMAScript-compliant behavior is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">若要使用由右至左模式，唯一的方法就是提供 <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> 值給 <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 類別建構函式或靜態模式比對方法的 options 參數。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">無法以內嵌選項來提供此值。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> option can be combined only with the <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> and <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> options.</source>
          <target state="translated"><bpt id="p1">[</bpt>RegexOptions.ECMAScript<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.ECMAScript)</ept> 選項只能結合 <bpt id="p2">[</bpt>RegexOptions.IgnoreCase<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase)</ept> 和 <bpt id="p3">[</bpt>RegexOptions.Multiline<ept id="p3">](xref:System.Text.RegularExpressions.RegexOptions.Multiline)</ept> 選項。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>The use of any other option in a regular expression results in an <bpt id="p1">[</bpt>ArgumentOutOfRangeException<ept id="p1">](xref:System.ArgumentOutOfRangeException)</ept>.</source>
          <target state="translated">在規則運算式中使用任何其他選項將會導致 <bpt id="p1">[</bpt>ArgumentOutOfRangeException<ept id="p1">](xref:System.ArgumentOutOfRangeException)</ept>。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</source>
          <target state="translated">ECMAScript 的行為與標準規則運算式有三個不同層面：字元類別語法、自我參考擷取群組，以及八進位與反向參考解譯。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Character class syntax.</source>
          <target state="translated">字元類別語法。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</source>
          <target state="translated">因為標準規則運算式支援 Unicode，而 ECMAScript 不支援，所以 ECMAScript 中的字元類別有較多的語法限制，而且有些字元類別語言項目有不同的意義。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>For example, ECMAScript does not support language elements such as the Unicode category or block elements <bpt id="p1">*</bpt>\p<ept id="p1">*</ept> and <bpt id="p2">**</bpt>\P<ept id="p2">**</ept>.</source>
          <target state="translated">例如，ECMAScript 不支援語言項目 (例如 Unicode 類別) 或資料區塊項目 <bpt id="p1">*</bpt>\p<ept id="p1">*</ept> 和 <bpt id="p2">**</bpt>\P<ept id="p2">**</ept>。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Similarly, the <bpt id="p1">**</bpt>\w<ept id="p1">**</ept> element, which matches a word character, is equivalent to the <bpt id="p2">**</bpt>[a-zA-Z_0-9]<ept id="p2">**</ept> character class when using ECMAScript and <bpt id="p3">**</bpt>[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]<ept id="p3">**</ept> when using canonical behavior.</source>
          <target state="translated">同樣地，比對文字字元的 <bpt id="p1">**</bpt>\w<ept id="p1">**</ept> 元素，在使用 ECMAScript 時相當於 <bpt id="p2">**</bpt>[a-zA-Z_0-9]<ept id="p2">**</ept> 字元類別，使用標準行為時相當於 <bpt id="p3">**</bpt>[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]<ept id="p3">**</ept>。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Character classes in regular expressions<ept id="p1">](classes.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式中的字元類別<ept id="p1">](classes.md)</ept>。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between canonical and ECMAScript pattern matching.</source>
          <target state="translated">下列範例說明標準與 ECMAScript 模式比對之間的差異。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>It defines a regular expression, <ph id="ph1">`\b(\w+\s*)+`</ph>, that matches words followed by white-space characters.</source>
          <target state="translated">其定義規則運算式 <ph id="ph1">`\b(\w+\s*)+`</ph>，可比對後接空白字元的文字。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</source>
          <target state="translated">該輸入包含兩個字串，一個使用 Latin 字元集，另一個使用 Cyrillic 字元集。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>As the output shows, the call to the <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</source>
          <target state="translated">如輸出所示，呼叫使用 ECMAScript 比對的 <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> 方法時，無法比對 Cyrillic 文字，而使用標準比對的方法呼叫則可比對這些文字。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Self-referencing capturing groups.</source>
          <target state="translated">自我參考擷取群組。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>A regular expression capture class with a backreference to itself must be updated with each capture iteration.</source>
          <target state="translated">具有自我反向參考的規則運算式擷取類別必須以每個擷取反覆項目來更新。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>As the following example shows, this feature enables the regular expression <ph id="ph1">`((a+)(\1) ?)+`</ph> to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</source>
          <target state="translated">如下列範例所示，使用 ECMAScript 時，此功能可讓規則運算式 <ph id="ph1">`((a+)(\1) ?)+`</ph> 比對輸入字串 " aa aaaa aaaaaa "，使用標準比對時則不能。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>For more information about string comparisons that are case-sensitive and that use the invariant culture, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](best-practices.md)</ept>.</source>
          <target state="translated">如需區分大小寫和使用不因國別而異的文化特性之字串比較的詳細資訊，請參閱<bpt id="p1">[</bpt>在 .NET Framework 中使用字串的最佳作法<ept id="p1">](best-practices.md)</ept>。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Instead of using the case-insensitive comparisons of the current culture, you can specify the <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> option to ignore cultural differences in language and to use the conventions of the invariant culture.</source>
          <target state="translated">您可以不要使用不因國別而異的文化特性的不區分大小寫比較，而是指定 <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> 選項來忽略語言中的文化特性差異，並使用不因國別而異的文化特性的慣例。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Comparison using the invariant culture is available only by supplying the <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> value to the options parameter of a <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> class constructor or static pattern-matching method.</source>
          <target state="translated">若要使用不因國別而異的文化特性的比較，唯一的方法就是提供 <bpt id="p1">[</bpt>RegexOptions.CultureInvariant<ept id="p1">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> 值給 <bpt id="p2">[</bpt>Regex<ept id="p2">](xref:System.Text.RegularExpressions.Regex)</ept> 類別建構函式或靜態模式比對方法的 options 參數。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>It is not available as an inline option.</source>
          <target state="translated">無法以內嵌選項來提供此值。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The following example is identical to the previous example, except that the static <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> method is called with options that include <bpt id="p2">[</bpt>RegexOptions.CultureInvariant<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept>.</source>
          <target state="translated">下列範例與上一個範例相同，差別在於呼叫靜態 <bpt id="p1">[</bpt>Regex.IsMatch(String, String, RegexOptions)<ept id="p1">](xref:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions))</ept> 方法時，是使用包含 <bpt id="p2">[</bpt>RegexOptions.CultureInvariant<ept id="p2">](xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant)</ept> 的選項。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</source>
          <target state="translated">即使目前的文化特性設為 Turkish (Turkey)，規則運算式引擎還是可以成功比對 "FILE" 和 "file"，並封鎖存取檔案資源。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">請參閱</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular expression language - quick reference<ept id="p1">](quick-ref.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>規則運算式語言 - 快速參考<ept id="p1">](quick-ref.md)</ept></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>